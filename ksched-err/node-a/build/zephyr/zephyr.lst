
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:

	return fd_entry->obj;
}

int z_reserve_fd(void)
{
   0:	20003e00 	.word	0x20003e00
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   4:	00004c8d 	.word	0x00004c8d
   8:	00025af5 	.word	0x00025af5
		if (fdtable[fd].obj == NULL) {
   c:	00004b7d 	.word	0x00004b7d
  10:	00004b7d 	.word	0x00004b7d
  14:	00004b7d 	.word	0x00004b7d
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
  18:	00004b7d 	.word	0x00004b7d
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
  1c:	00004b7d 	.word	0x00004b7d
	errno = ENFILE;
  20:	00004b7d 	.word	0x00004b7d
	return -1;
  24:	00004b7d 	.word	0x00004b7d
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
  28:	00004b7d 	.word	0x00004b7d
  2c:	00004939 	.word	0x00004939
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
  30:	00004b7d 	.word	0x00004b7d
		fdtable[fd].obj = FD_OBJ_RESERVED;
  34:	00004b7d 	.word	0x00004b7d
  38:	000048e1 	.word	0x000048e1
  3c:	000040b5 	.word	0x000040b5

00000040 <_irq_vector_table>:
  40:	00004c4d 0002876b 00004c4d 00004c4d     ML..k...ML..ML..
		sys_pm_notify_power_state_exit(pm_state);
		_sys_pm_power_state_exit_post_ops(pm_state);
	}

	return pm_state;
}
  50:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..

		cid = CID_NVAL;
		mod_id = sys_get_le16(&buf->data[10]);
	}

	if (mod_id != param->mod_id || cid != param->cid) {
  60:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
  70:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..
  80:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..
			BT_WARN("Unexpected Mod Pub Status with Vendor Model");
  90:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..
		BT_WARN("Mod Pub Model ID or Company ID mismatch");
		return;
	}

	status = net_buf_simple_pull_u8(buf);
  a0:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..

	elem_addr = net_buf_simple_pull_le16(buf);
	if (elem_addr != param->elem_addr) {
  b0:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..
		BT_WARN("Model Pub Status for unexpected element (0x%04x)",
  c0:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..
			elem_addr);
		return;
	}

	if (param->status) {
  d0:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..
		*param->status = status;
	}

	if (param->pub) {
		param->pub->addr = net_buf_simple_pull_le16(buf);
		param->pub->app_idx = net_buf_simple_pull_le16(buf);
  e0:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..
		param->pub->cred_flag = (param->pub->app_idx & BIT(12));
  f0:	00004c4d 00004c4d 00004c4d 00004c4d     ML..ML..ML..ML..

Disassembly of section text:

00000100 <__aeabi_ldivmod>:
		param->pub->app_idx &= BIT_MASK(12);
		param->pub->ttl = net_buf_simple_pull_u8(buf);
     100:	b97b      	cbnz	r3, 122 <__aeabi_ldivmod+0x22>
		param->pub->period = net_buf_simple_pull_u8(buf);
     102:	b972      	cbnz	r2, 122 <__aeabi_ldivmod+0x22>
     104:	2900      	cmp	r1, #0
     106:	bfbe      	ittt	lt
     108:	2000      	movlt	r0, #0
     10a:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
		param->pub->transmit = net_buf_simple_pull_u8(buf);
     10e:	e006      	blt.n	11e <__aeabi_ldivmod+0x1e>
     110:	bf08      	it	eq
     112:	2800      	cmpeq	r0, #0
     114:	bf1c      	itt	ne
	}

	k_sem_give(&cli->op_sync);
     116:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
}
     11a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
	k_sem_give(&cli->op_sync);
     11e:	f000 b9cd 	b.w	4bc <__aeabi_idiv0>
     122:	f1ad 0c08 	sub.w	ip, sp, #8
     126:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     12a:	2900      	cmp	r1, #0
     12c:	db09      	blt.n	142 <CONFIG_IDLE_STACK_SIZE+0x2>
     12e:	2b00      	cmp	r3, #0
     130:	db1a      	blt.n	168 <CONFIG_IDLE_STACK_SIZE+0x28>
     132:	f000 f861 	bl	1f8 <__udivmoddi4>
     136:	f8dd e004 	ldr.w	lr, [sp, #4]
     13a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     13e:	b004      	add	sp, #16
     140:	4770      	bx	lr
     142:	4240      	negs	r0, r0
     144:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     148:	2b00      	cmp	r3, #0
     14a:	db1b      	blt.n	184 <CONFIG_IDLE_STACK_SIZE+0x44>
     14c:	f000 f854 	bl	1f8 <__udivmoddi4>
     150:	f8dd e004 	ldr.w	lr, [sp, #4]
     154:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     158:	b004      	add	sp, #16
     15a:	4240      	negs	r0, r0
     15c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     160:	4252      	negs	r2, r2
     162:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     166:	4770      	bx	lr
     168:	4252      	negs	r2, r2
     16a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     16e:	f000 f843 	bl	1f8 <__udivmoddi4>
     172:	f8dd e004 	ldr.w	lr, [sp, #4]
     176:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     17a:	b004      	add	sp, #16
     17c:	4240      	negs	r0, r0
     17e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     182:	4770      	bx	lr
     184:	4252      	negs	r2, r2
     186:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     18a:	f000 f835 	bl	1f8 <__udivmoddi4>
     18e:	f8dd e004 	ldr.w	lr, [sp, #4]
     192:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     196:	b004      	add	sp, #16
     198:	4252      	negs	r2, r2
     19a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     19e:	4770      	bx	lr

000001a0 <__aeabi_uldivmod>:
     1a0:	b953      	cbnz	r3, 1b8 <__aeabi_uldivmod+0x18>
     1a2:	b94a      	cbnz	r2, 1b8 <__aeabi_uldivmod+0x18>
     1a4:	2900      	cmp	r1, #0
     1a6:	bf08      	it	eq
     1a8:	2800      	cmpeq	r0, #0
     1aa:	bf1c      	itt	ne
     1ac:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
     1b0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     1b4:	f000 b982 	b.w	4bc <__aeabi_idiv0>
     1b8:	f1ad 0c08 	sub.w	ip, sp, #8
     1bc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     1c0:	f000 f81a 	bl	1f8 <__udivmoddi4>
     1c4:	f8dd e004 	ldr.w	lr, [sp, #4]
     1c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     1cc:	b004      	add	sp, #16
     1ce:	4770      	bx	lr

000001d0 <__popcountsi2>:
     1d0:	0843      	lsrs	r3, r0, #1
     1d2:	f003 3355 	and.w	r3, r3, #1431655765	; 0x55555555
     1d6:	1ac0      	subs	r0, r0, r3
     1d8:	0883      	lsrs	r3, r0, #2
     1da:	f003 3333 	and.w	r3, r3, #858993459	; 0x33333333
     1de:	f000 3033 	and.w	r0, r0, #858993459	; 0x33333333
     1e2:	4418      	add	r0, r3
     1e4:	eb00 1010 	add.w	r0, r0, r0, lsr #4
     1e8:	f000 300f 	and.w	r0, r0, #252645135	; 0xf0f0f0f
     1ec:	eb00 2000 	add.w	r0, r0, r0, lsl #8
     1f0:	eb00 4000 	add.w	r0, r0, r0, lsl #16
     1f4:	0e00      	lsrs	r0, r0, #24
     1f6:	4770      	bx	lr

000001f8 <__udivmoddi4>:
     1f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     1fc:	9d08      	ldr	r5, [sp, #32]
     1fe:	460e      	mov	r6, r1
     200:	4604      	mov	r4, r0
     202:	468c      	mov	ip, r1
     204:	2b00      	cmp	r3, #0
     206:	f040 8081 	bne.w	30c <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xc>
     20a:	428a      	cmp	r2, r1
     20c:	4617      	mov	r7, r2
     20e:	d945      	bls.n	29c <CONFIG_BT_HCI_TX_STACK_SIZE+0x1c>
     210:	fab2 f282 	clz	r2, r2
     214:	b14a      	cbz	r2, 22a <__udivmoddi4+0x32>
     216:	f1c2 0120 	rsb	r1, r2, #32
     21a:	fa06 f302 	lsl.w	r3, r6, r2
     21e:	fa20 f101 	lsr.w	r1, r0, r1
     222:	4097      	lsls	r7, r2
     224:	ea41 0c03 	orr.w	ip, r1, r3
     228:	4094      	lsls	r4, r2
     22a:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     22e:	0c23      	lsrs	r3, r4, #16
     230:	fbbc f6fe 	udiv	r6, ip, lr
     234:	b2b9      	uxth	r1, r7
     236:	fb0e cc16 	mls	ip, lr, r6, ip
     23a:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
     23e:	fb06 f001 	mul.w	r0, r6, r1
     242:	4298      	cmp	r0, r3
     244:	d909      	bls.n	25a <__udivmoddi4+0x62>
     246:	18fb      	adds	r3, r7, r3
     248:	f106 3cff 	add.w	ip, r6, #4294967295	; 0xffffffff
     24c:	f080 8115 	bcs.w	47a <CONFIG_BT_HCI_ECC_STACK_SIZE+0x2e>
     250:	4298      	cmp	r0, r3
     252:	f240 8112 	bls.w	47a <CONFIG_BT_HCI_ECC_STACK_SIZE+0x2e>
     256:	3e02      	subs	r6, #2
     258:	443b      	add	r3, r7
     25a:	1a1b      	subs	r3, r3, r0
     25c:	b2a4      	uxth	r4, r4
     25e:	fbb3 f0fe 	udiv	r0, r3, lr
     262:	fb0e 3310 	mls	r3, lr, r0, r3
     266:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     26a:	fb00 f101 	mul.w	r1, r0, r1
     26e:	42a1      	cmp	r1, r4
     270:	d909      	bls.n	286 <CONFIG_BT_HCI_TX_STACK_SIZE+0x6>
     272:	193c      	adds	r4, r7, r4
     274:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
     278:	f080 8101 	bcs.w	47e <CONFIG_BT_HCI_ECC_STACK_SIZE+0x32>
     27c:	42a1      	cmp	r1, r4
     27e:	f240 80fe 	bls.w	47e <CONFIG_BT_HCI_ECC_STACK_SIZE+0x32>
     282:	3802      	subs	r0, #2
     284:	443c      	add	r4, r7
     286:	1a64      	subs	r4, r4, r1
     288:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     28c:	2100      	movs	r1, #0
     28e:	b11d      	cbz	r5, 298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     290:	40d4      	lsrs	r4, r2
     292:	2300      	movs	r3, #0
     294:	e9c5 4300 	strd	r4, r3, [r5]
     298:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     29c:	b902      	cbnz	r2, 2a0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x20>
     29e:	deff      	udf	#255	; 0xff
     2a0:	fab2 f282 	clz	r2, r2
     2a4:	2a00      	cmp	r2, #0
     2a6:	d14f      	bne.n	348 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x48>
     2a8:	1bcb      	subs	r3, r1, r7
     2aa:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     2ae:	fa1f f887 	uxth.w	r8, r7
     2b2:	2101      	movs	r1, #1
     2b4:	fbb3 fcfe 	udiv	ip, r3, lr
     2b8:	0c26      	lsrs	r6, r4, #16
     2ba:	fb0e 331c 	mls	r3, lr, ip, r3
     2be:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
     2c2:	fb08 f30c 	mul.w	r3, r8, ip
     2c6:	42b3      	cmp	r3, r6
     2c8:	d907      	bls.n	2da <CONFIG_BT_HCI_TX_STACK_SIZE+0x5a>
     2ca:	19be      	adds	r6, r7, r6
     2cc:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
     2d0:	d202      	bcs.n	2d8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x58>
     2d2:	42b3      	cmp	r3, r6
     2d4:	f200 80eb 	bhi.w	4ae <CONFIG_BT_HCI_ECC_STACK_SIZE+0x62>
     2d8:	4684      	mov	ip, r0
     2da:	1af6      	subs	r6, r6, r3
     2dc:	b2a3      	uxth	r3, r4
     2de:	fbb6 f0fe 	udiv	r0, r6, lr
     2e2:	fb0e 6610 	mls	r6, lr, r0, r6
     2e6:	ea43 4406 	orr.w	r4, r3, r6, lsl #16
     2ea:	fb08 f800 	mul.w	r8, r8, r0
     2ee:	45a0      	cmp	r8, r4
     2f0:	d907      	bls.n	302 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x2>
     2f2:	193c      	adds	r4, r7, r4
     2f4:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
     2f8:	d202      	bcs.n	300 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE>
     2fa:	45a0      	cmp	r8, r4
     2fc:	f200 80d2 	bhi.w	4a4 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x58>
     300:	4618      	mov	r0, r3
     302:	eba4 0408 	sub.w	r4, r4, r8
     306:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     30a:	e7c0      	b.n	28e <CONFIG_BT_HCI_TX_STACK_SIZE+0xe>
     30c:	428b      	cmp	r3, r1
     30e:	d908      	bls.n	322 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x22>
     310:	2d00      	cmp	r5, #0
     312:	f000 80af 	beq.w	474 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x28>
     316:	2100      	movs	r1, #0
     318:	e9c5 0600 	strd	r0, r6, [r5]
     31c:	4608      	mov	r0, r1
     31e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     322:	fab3 f183 	clz	r1, r3
     326:	2900      	cmp	r1, #0
     328:	d149      	bne.n	3be <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xbe>
     32a:	42b3      	cmp	r3, r6
     32c:	d302      	bcc.n	334 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x34>
     32e:	4282      	cmp	r2, r0
     330:	f200 80bb 	bhi.w	4aa <CONFIG_BT_HCI_ECC_STACK_SIZE+0x5e>
     334:	1a84      	subs	r4, r0, r2
     336:	eb66 0303 	sbc.w	r3, r6, r3
     33a:	2001      	movs	r0, #1
     33c:	469c      	mov	ip, r3
     33e:	2d00      	cmp	r5, #0
     340:	d0aa      	beq.n	298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     342:	e9c5 4c00 	strd	r4, ip, [r5]
     346:	e7a7      	b.n	298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     348:	f1c2 0320 	rsb	r3, r2, #32
     34c:	4097      	lsls	r7, r2
     34e:	40d8      	lsrs	r0, r3
     350:	4091      	lsls	r1, r2
     352:	40de      	lsrs	r6, r3
     354:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     358:	4308      	orrs	r0, r1
     35a:	ea4f 4c10 	mov.w	ip, r0, lsr #16
     35e:	fbb6 f1fe 	udiv	r1, r6, lr
     362:	fa1f f887 	uxth.w	r8, r7
     366:	fb0e 6611 	mls	r6, lr, r1, r6
     36a:	ea4c 4606 	orr.w	r6, ip, r6, lsl #16
     36e:	fb01 f308 	mul.w	r3, r1, r8
     372:	42b3      	cmp	r3, r6
     374:	fa04 f402 	lsl.w	r4, r4, r2
     378:	d909      	bls.n	38e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x8e>
     37a:	19be      	adds	r6, r7, r6
     37c:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
     380:	f080 808e 	bcs.w	4a0 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x54>
     384:	42b3      	cmp	r3, r6
     386:	f240 808b 	bls.w	4a0 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x54>
     38a:	3902      	subs	r1, #2
     38c:	443e      	add	r6, r7
     38e:	1af3      	subs	r3, r6, r3
     390:	b286      	uxth	r6, r0
     392:	fbb3 f0fe 	udiv	r0, r3, lr
     396:	fb0e 3310 	mls	r3, lr, r0, r3
     39a:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
     39e:	fb00 f308 	mul.w	r3, r0, r8
     3a2:	42b3      	cmp	r3, r6
     3a4:	d907      	bls.n	3b6 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb6>
     3a6:	19be      	adds	r6, r7, r6
     3a8:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
     3ac:	d274      	bcs.n	498 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x4c>
     3ae:	42b3      	cmp	r3, r6
     3b0:	d972      	bls.n	498 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x4c>
     3b2:	3802      	subs	r0, #2
     3b4:	443e      	add	r6, r7
     3b6:	1af3      	subs	r3, r6, r3
     3b8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
     3bc:	e77a      	b.n	2b4 <CONFIG_BT_HCI_TX_STACK_SIZE+0x34>
     3be:	f1c1 0720 	rsb	r7, r1, #32
     3c2:	fa03 f401 	lsl.w	r4, r3, r1
     3c6:	fa22 f307 	lsr.w	r3, r2, r7
     3ca:	431c      	orrs	r4, r3
     3cc:	fa20 f907 	lsr.w	r9, r0, r7
     3d0:	fa06 f301 	lsl.w	r3, r6, r1
     3d4:	ea4f 4c14 	mov.w	ip, r4, lsr #16
     3d8:	40fe      	lsrs	r6, r7
     3da:	ea49 0903 	orr.w	r9, r9, r3
     3de:	ea4f 4319 	mov.w	r3, r9, lsr #16
     3e2:	fbb6 fefc 	udiv	lr, r6, ip
     3e6:	fa1f f884 	uxth.w	r8, r4
     3ea:	fb0c 661e 	mls	r6, ip, lr, r6
     3ee:	ea43 4606 	orr.w	r6, r3, r6, lsl #16
     3f2:	fb0e fa08 	mul.w	sl, lr, r8
     3f6:	45b2      	cmp	sl, r6
     3f8:	fa02 f201 	lsl.w	r2, r2, r1
     3fc:	fa00 f301 	lsl.w	r3, r0, r1
     400:	d908      	bls.n	414 <CONFIG_FLASH_SIZE+0x14>
     402:	19a6      	adds	r6, r4, r6
     404:	f10e 30ff 	add.w	r0, lr, #4294967295	; 0xffffffff
     408:	d248      	bcs.n	49c <CONFIG_BT_HCI_ECC_STACK_SIZE+0x50>
     40a:	45b2      	cmp	sl, r6
     40c:	d946      	bls.n	49c <CONFIG_BT_HCI_ECC_STACK_SIZE+0x50>
     40e:	f1ae 0e02 	sub.w	lr, lr, #2
     412:	4426      	add	r6, r4
     414:	eba6 060a 	sub.w	r6, r6, sl
     418:	fa1f f989 	uxth.w	r9, r9
     41c:	fbb6 f0fc 	udiv	r0, r6, ip
     420:	fb0c 6610 	mls	r6, ip, r0, r6
     424:	ea49 4606 	orr.w	r6, r9, r6, lsl #16
     428:	fb00 f808 	mul.w	r8, r0, r8
     42c:	45b0      	cmp	r8, r6
     42e:	d907      	bls.n	440 <CONFIG_FLASH_SIZE+0x40>
     430:	19a6      	adds	r6, r4, r6
     432:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
     436:	d22d      	bcs.n	494 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x48>
     438:	45b0      	cmp	r8, r6
     43a:	d92b      	bls.n	494 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x48>
     43c:	3802      	subs	r0, #2
     43e:	4426      	add	r6, r4
     440:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     444:	eba6 0608 	sub.w	r6, r6, r8
     448:	fba0 8902 	umull	r8, r9, r0, r2
     44c:	454e      	cmp	r6, r9
     44e:	46c4      	mov	ip, r8
     450:	46ce      	mov	lr, r9
     452:	d318      	bcc.n	486 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x3a>
     454:	d015      	beq.n	482 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x36>
     456:	b375      	cbz	r5, 4b6 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x6a>
     458:	ebb3 020c 	subs.w	r2, r3, ip
     45c:	eb66 060e 	sbc.w	r6, r6, lr
     460:	fa06 f707 	lsl.w	r7, r6, r7
     464:	fa22 f301 	lsr.w	r3, r2, r1
     468:	40ce      	lsrs	r6, r1
     46a:	431f      	orrs	r7, r3
     46c:	e9c5 7600 	strd	r7, r6, [r5]
     470:	2100      	movs	r1, #0
     472:	e711      	b.n	298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     474:	4629      	mov	r1, r5
     476:	4628      	mov	r0, r5
     478:	e70e      	b.n	298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     47a:	4666      	mov	r6, ip
     47c:	e6ed      	b.n	25a <__udivmoddi4+0x62>
     47e:	4618      	mov	r0, r3
     480:	e701      	b.n	286 <CONFIG_BT_HCI_TX_STACK_SIZE+0x6>
     482:	4543      	cmp	r3, r8
     484:	d2e7      	bcs.n	456 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa>
     486:	ebb8 0c02 	subs.w	ip, r8, r2
     48a:	eb69 0404 	sbc.w	r4, r9, r4
     48e:	3801      	subs	r0, #1
     490:	46a6      	mov	lr, r4
     492:	e7e0      	b.n	456 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa>
     494:	4660      	mov	r0, ip
     496:	e7d3      	b.n	440 <CONFIG_FLASH_SIZE+0x40>
     498:	4660      	mov	r0, ip
     49a:	e78c      	b.n	3b6 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb6>
     49c:	4686      	mov	lr, r0
     49e:	e7b9      	b.n	414 <CONFIG_FLASH_SIZE+0x14>
     4a0:	4661      	mov	r1, ip
     4a2:	e774      	b.n	38e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x8e>
     4a4:	3802      	subs	r0, #2
     4a6:	443c      	add	r4, r7
     4a8:	e72b      	b.n	302 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x2>
     4aa:	4608      	mov	r0, r1
     4ac:	e747      	b.n	33e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x3e>
     4ae:	f1ac 0c02 	sub.w	ip, ip, #2
     4b2:	443e      	add	r6, r7
     4b4:	e711      	b.n	2da <CONFIG_BT_HCI_TX_STACK_SIZE+0x5a>
     4b6:	4629      	mov	r1, r5
     4b8:	e6ee      	b.n	298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     4ba:	bf00      	nop

000004bc <__aeabi_idiv0>:
     4bc:	4770      	bx	lr
     4be:	bf00      	nop

000004c0 <ll_adv_enable>:
{
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_HCI_MESH_EXT */
#else /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
u8_t ll_adv_enable(u8_t enable)
{
     4c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     4c4:	b08f      	sub	sp, #60	; 0x3c
	u16_t const handle = 0;
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
     4c6:	2302      	movs	r3, #2
     4c8:	930d      	str	r3, [sp, #52]	; 0x34
	u32_t ticks_slot_offset;
	struct ll_adv_set *adv;
	struct lll_adv *lll;
	u32_t ret;

	if (!enable) {
     4ca:	b930      	cbnz	r0, 4da <ll_adv_enable+0x1a>
		return disable(handle);
     4cc:	f01a fdea 	bl	1b0a4 <disable.constprop.0>
     4d0:	4606      	mov	r6, r0
		conn_release(adv);
	}
#endif /* CONFIG_BT_PERIPHERAL */

	return BT_HCI_ERR_CMD_DISALLOWED;
}
     4d2:	4630      	mov	r0, r6
     4d4:	b00f      	add	sp, #60	; 0x3c
     4d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static inline struct ll_adv_set *is_disabled_get(u16_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
     4da:	4fcf      	ldr	r7, [pc, #828]	; (818 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x18>)
     4dc:	f897 60cc 	ldrb.w	r6, [r7, #204]	; 0xcc
     4e0:	f016 0601 	ands.w	r6, r6, #1
     4e4:	463d      	mov	r5, r7
     4e6:	d001      	beq.n	4ec <ll_adv_enable+0x2c>
	return BT_HCI_ERR_CMD_DISALLOWED;
     4e8:	260c      	movs	r6, #12
     4ea:	e7f2      	b.n	4d2 <ll_adv_enable+0x12>
	lll_adv_pdu_enqueue(&lll->adv_data, idx);
}

static inline struct pdu_adv *lll_adv_data_peek(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     4ec:	f897 802b 	ldrb.w	r8, [r7, #43]	; 0x2b
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     4f0:	f897 a07b 	ldrb.w	sl, [r7, #123]	; 0x7b
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     4f4:	2327      	movs	r3, #39	; 0x27
     4f6:	222c      	movs	r2, #44	; 0x2c
     4f8:	fb13 2808 	smlabb	r8, r3, r8, r2
     4fc:	eb07 0208 	add.w	r2, r7, r8
			u8_t *tx_addr = ll_addr_get(pdu_adv->tx_addr, NULL);
     500:	f817 0008 	ldrb.w	r0, [r7, r8]
     504:	920a      	str	r2, [sp, #40]	; 0x28
     506:	4631      	mov	r1, r6
     508:	f3c0 1080 	ubfx	r0, r0, #6, #1
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     50c:	fb03 7a0a 	mla	sl, r3, sl, r7
     510:	f018 fc6e 	bl	18df0 <ll_addr_get>
			memcpy(&pdu_adv->adv_ind.addr[0], tx_addr,
     514:	9b0a      	ldr	r3, [sp, #40]	; 0x28
     516:	f103 0902 	add.w	r9, r3, #2
     51a:	4601      	mov	r1, r0
			u8_t *tx_addr = ll_addr_get(pdu_adv->tx_addr, NULL);
     51c:	4604      	mov	r4, r0
			memcpy(&pdu_adv->adv_ind.addr[0], tx_addr,
     51e:	2206      	movs	r2, #6
     520:	f10a 0a7c 	add.w	sl, sl, #124	; 0x7c
     524:	4648      	mov	r0, r9
     526:	f025 fbbf 	bl	25ca8 <memcpy>
			memcpy(&pdu_scan->scan_rsp.addr[0], tx_addr,
     52a:	2206      	movs	r2, #6
     52c:	4621      	mov	r1, r4
     52e:	f10a 0002 	add.w	r0, sl, #2
     532:	f025 fbb9 	bl	25ca8 <memcpy>
		if (pdu_adv->tx_addr &&
     536:	f817 3008 	ldrb.w	r3, [r7, r8]
     53a:	065a      	lsls	r2, r3, #25
     53c:	f100 8093 	bmi.w	666 <CONFIG_BT_COMPANY_ID+0x75>
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
     540:	f817 3008 	ldrb.w	r3, [r7, r8]
     544:	f013 0f0e 	tst.w	r3, #14
     548:	f000 8096 	beq.w	678 <CONFIG_BT_COMPANY_ID+0x87>
	u8_t ch_map = lll->chan_map;
     54c:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     550:	2101      	movs	r1, #1
	u8_t ch_map = lll->chan_map;
     552:	f3c3 0342 	ubfx	r3, r3, #1, #3
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     556:	f10d 0033 	add.w	r0, sp, #51	; 0x33
	u8_t ch_map = lll->chan_map;
     55a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     55e:	f027 fe0d 	bl	2817c <util_ones_count_get>
	if (adv_chn_cnt == 0) {
     562:	2800      	cmp	r0, #0
     564:	f000 814c 	beq.w	800 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL>
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
     568:	f817 4008 	ldrb.w	r4, [r7, r8]
		const u8_t adv_data_len = pdu_adv->len;
     56c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
     56e:	f004 040f 	and.w	r4, r4, #15
     572:	2c02      	cmp	r4, #2
		const u8_t adv_data_len = pdu_adv->len;
     574:	785a      	ldrb	r2, [r3, #1]
		const u8_t rsp_data_len = pdu_scan->len;
     576:	f89a 3001 	ldrb.w	r3, [sl, #1]
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
     57a:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
     57e:	f040 810f 	bne.w	7a0 <CONFIG_BT_COMPANY_ID+0x1af>
			adv_size += adv_data_len;
     582:	3210      	adds	r2, #16
			slot_us += BYTES2US(adv_size, phy) * adv_chn_cnt +
     584:	00d2      	lsls	r2, r2, #3
     586:	4350      	muls	r0, r2
     588:	f500 70aa 	add.w	r0, r0, #340	; 0x154
     58c:	2364      	movs	r3, #100	; 0x64
     58e:	fb03 0001 	mla	r0, r3, r1, r0
static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
	hdr->is_stop = 0U;
     592:	f895 3020 	ldrb.w	r3, [r5, #32]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
     596:	49a1      	ldr	r1, [pc, #644]	; (81c <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x1c>)
	hdr->parent = parent;
     598:	61ed      	str	r5, [r5, #28]
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->disabled_cb = hdr->disabled_param = NULL;
     59a:	2400      	movs	r4, #0
	hdr->is_stop = 0U;
     59c:	f364 0300 	bfi	r3, r4, #0, #1
     5a0:	f885 3020 	strb.w	r3, [r5, #32]
	adv->evt.ticks_xtal_to_start =
     5a4:	2331      	movs	r3, #49	; 0x31
     5a6:	602b      	str	r3, [r5, #0]
     5a8:	e9c5 4405 	strd	r4, r4, [r5, #20]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
     5ac:	a398      	add	r3, pc, #608	; (adr r3, 810 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x10>)
     5ae:	e9d3 2300 	ldrd	r2, r3, [r3]
	adv->evt.ticks_active_to_start = 0;
     5b2:	606c      	str	r4, [r5, #4]
	adv->evt.ticks_preempt_to_start =
     5b4:	60ac      	str	r4, [r5, #8]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
     5b6:	fba0 0101 	umull	r0, r1, r0, r1
     5ba:	f7ff fdf1 	bl	1a0 <__aeabi_uldivmod>
     5be:	60e8      	str	r0, [r5, #12]
	u16_t interval = adv->interval;
     5c0:	f8b5 a0d8 	ldrh.w	sl, [r5, #216]	; 0xd8
	ticks_anchor = ticker_ticks_now_get();
     5c4:	f027 fe95 	bl	282f2 <ticker_ticks_now_get>
     5c8:	4681      	mov	r9, r0
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
     5ca:	f1ba 0f00 	cmp.w	sl, #0
     5ce:	d106      	bne.n	5de <CONFIG_BT_CTLR_XTAL_THRESHOLD+0x2>
     5d0:	f817 4008 	ldrb.w	r4, [r7, r8]
     5d4:	f004 040f 	and.w	r4, r4, #15
     5d8:	1e63      	subs	r3, r4, #1
     5da:	425c      	negs	r4, r3
     5dc:	415c      	adcs	r4, r3
     5de:	f895 7028 	ldrb.w	r7, [r5, #40]	; 0x28
     5e2:	f8df 8248 	ldr.w	r8, [pc, #584]	; 82c <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x2c>
     5e6:	4a8e      	ldr	r2, [pc, #568]	; (820 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x20>)
     5e8:	68eb      	ldr	r3, [r5, #12]
     5ea:	f364 0700 	bfi	r7, r4, #0, #1
     5ee:	f885 7028 	strb.w	r7, [r5, #40]	; 0x28
	if (lll->is_hdcd) {
     5f2:	ac0d      	add	r4, sp, #52	; 0x34
     5f4:	f017 0701 	ands.w	r7, r7, #1
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     5f8:	e9cd 8407 	strd	r8, r4, [sp, #28]
     5fc:	e9cd 2505 	strd	r2, r5, [sp, #20]
     600:	9304      	str	r3, [sp, #16]
	if (lll->is_hdcd) {
     602:	f000 80e9 	beq.w	7d8 <CONFIG_BT_COMPANY_ID+0x1e7>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     606:	2000      	movs	r0, #0
     608:	e9cd 0300 	strd	r0, r3, [sp]
     60c:	2103      	movs	r1, #3
     60e:	e9cd 0002 	strd	r0, r0, [sp, #8]
     612:	464b      	mov	r3, r9
     614:	2202      	movs	r2, #2
     616:	f018 fb23 	bl	18c60 <ticker_start>
		ret = ull_ticker_status_take(ret, &ret_cb);
     61a:	4621      	mov	r1, r4
     61c:	f01a f800 	bl	1a620 <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
     620:	2800      	cmp	r0, #0
     622:	f040 80ed 	bne.w	800 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL>
		ret_cb = TICKER_STATUS_BUSY;
     626:	2202      	movs	r2, #2
     628:	920d      	str	r2, [sp, #52]	; 0x34
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     62a:	e9cd 8407 	strd	r8, r4, [sp, #28]
     62e:	4a7d      	ldr	r2, [pc, #500]	; (824 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x24>)
     630:	9506      	str	r5, [sp, #24]
     632:	e9cd 0002 	strd	r0, r0, [sp, #8]
     636:	f24a 33d8 	movw	r3, #41944	; 0xa3d8
     63a:	e9cd 0204 	strd	r0, r2, [sp, #16]
     63e:	9300      	str	r3, [sp, #0]
     640:	9001      	str	r0, [sp, #4]
     642:	464b      	mov	r3, r9
     644:	2201      	movs	r2, #1
     646:	2103      	movs	r1, #3
		ret = ticker_start(
     648:	f018 fb0a 	bl	18c60 <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
     64c:	4621      	mov	r1, r4
     64e:	f019 ffe7 	bl	1a620 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     652:	2800      	cmp	r0, #0
     654:	f040 80d4 	bne.w	800 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL>
	adv->is_enabled = 1;
     658:	f895 30cc 	ldrb.w	r3, [r5, #204]	; 0xcc
     65c:	f043 0301 	orr.w	r3, r3, #1
     660:	f885 30cc 	strb.w	r3, [r5, #204]	; 0xcc
	return 0;
     664:	e735      	b.n	4d2 <ll_adv_enable+0x12>
		    !mem_nz(pdu_adv->adv_ind.addr, BDADDR_SIZE)) {
     666:	2106      	movs	r1, #6
     668:	4648      	mov	r0, r9
     66a:	f027 fd50 	bl	2810e <mem_nz>
		if (pdu_adv->tx_addr &&
     66e:	2800      	cmp	r0, #0
     670:	f47f af66 	bne.w	540 <ll_adv_enable+0x80>
			return BT_HCI_ERR_INVALID_PARAM;
     674:	2612      	movs	r6, #18
     676:	e72c      	b.n	4d2 <ll_adv_enable+0x12>
		if (lll->conn) {
     678:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     67a:	2b00      	cmp	r3, #0
     67c:	f47f af34 	bne.w	4e8 <ll_adv_enable+0x28>
		link = ll_rx_link_alloc();
     680:	f019 ff26 	bl	1a4d0 <ll_rx_link_alloc>
		if (!link) {
     684:	4681      	mov	r9, r0
     686:	b130      	cbz	r0, 696 <CONFIG_BT_COMPANY_ID+0xa5>
		node_rx = ll_rx_alloc();
     688:	f019 ff2e 	bl	1a4e8 <ll_rx_alloc>
		if (!node_rx) {
     68c:	4683      	mov	fp, r0
     68e:	b920      	cbnz	r0, 69a <CONFIG_BT_COMPANY_ID+0xa9>
			ll_rx_link_release(link);
     690:	4648      	mov	r0, r9
     692:	f019 ff23 	bl	1a4dc <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
     696:	2607      	movs	r6, #7
     698:	e71b      	b.n	4d2 <ll_adv_enable+0x12>
		conn = ll_conn_acquire();
     69a:	f01a ff91 	bl	1b5c0 <ll_conn_acquire>
		if (!conn) {
     69e:	4604      	mov	r4, r0
     6a0:	b918      	cbnz	r0, 6aa <CONFIG_BT_COMPANY_ID+0xb9>
			ll_rx_release(node_rx);
     6a2:	4658      	mov	r0, fp
     6a4:	f019 ff26 	bl	1a4f4 <ll_rx_release>
     6a8:	e7f2      	b.n	690 <CONFIG_BT_COMPANY_ID+0x9f>
		conn_lll->handle = 0xFFFF;
     6aa:	f64f 72ff 	movw	r2, #65535	; 0xffff
     6ae:	8582      	strh	r2, [r0, #44]	; 0x2c
		if (!conn_lll->link_tx_free) {
     6b0:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
		conn_lll = &conn->lll;
     6b2:	f100 031c 	add.w	r3, r0, #28
     6b6:	930b      	str	r3, [sp, #44]	; 0x2c
		if (!conn_lll->link_tx_free) {
     6b8:	b912      	cbnz	r2, 6c0 <CONFIG_BT_COMPANY_ID+0xcf>
			conn_lll->link_tx_free = &conn_lll->link_tx;
     6ba:	f100 0264 	add.w	r2, r0, #100	; 0x64
     6be:	66c2      	str	r2, [r0, #108]	; 0x6c
		memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
     6c0:	f104 0260 	add.w	r2, r4, #96	; 0x60
     6c4:	f104 015c 	add.w	r1, r4, #92	; 0x5c
     6c8:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
     6ca:	f027 fd2b 	bl	28124 <memq_init>
		conn_lll->sn = 0;
     6ce:	f894 1072 	ldrb.w	r1, [r4, #114]	; 0x72
		conn->llcp_terminate.node_rx.hdr.link = link;
     6d2:	f8c4 90c8 	str.w	r9, [r4, #200]	; 0xc8
		conn_lll->sn = 0;
     6d6:	f021 0107 	bic.w	r1, r1, #7
     6da:	f884 1072 	strb.w	r1, [r4, #114]	; 0x72
		conn_lll->data_chan_sel = 0;
     6de:	f894 103d 	ldrb.w	r1, [r4, #61]	; 0x3d
     6e2:	f001 013f 	and.w	r1, r1, #63	; 0x3f
     6e6:	f061 017f 	orn	r1, r1, #127	; 0x7f
     6ea:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
		conn_lll->slave.latency_enabled = 0;
     6ee:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
		conn_lll->link_tx_free = NULL;
     6f2:	2200      	movs	r2, #0
		conn_lll->slave.latency_enabled = 0;
     6f4:	f362 0100 	bfi	r1, r2, #0, #1
     6f8:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
		conn->common.fex_valid = 0;
     6fc:	f894 1080 	ldrb.w	r1, [r4, #128]	; 0x80
		conn_lll->link_tx_free = NULL;
     700:	66e2      	str	r2, [r4, #108]	; 0x6c
		conn->common.fex_valid = 0;
     702:	f021 0103 	bic.w	r1, r1, #3
     706:	f884 1080 	strb.w	r1, [r4, #128]	; 0x80
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
     70a:	f894 10be 	ldrb.w	r1, [r4, #190]	; 0xbe
		conn_lll->packet_tx_head_len = 0;
     70e:	f8a4 2070 	strh.w	r2, [r4, #112]	; 0x70
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
     712:	f021 0103 	bic.w	r1, r1, #3
     716:	f884 10be 	strb.w	r1, [r4, #190]	; 0xbe
		conn->llcp_conn_param.disabled = 0;
     71a:	f894 10ee 	ldrb.w	r1, [r4, #238]	; 0xee
		conn_lll->data_chan_use = 0;
     71e:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
		conn->connect_expire = 6;
     722:	2006      	movs	r0, #6
		conn->llcp_conn_param.disabled = 0;
     724:	f362 1104 	bfi	r1, r2, #4, #1
		conn_lll->slave.window_widening_event_us = 0;
     728:	e9c4 2213 	strd	r2, r2, [r4, #76]	; 0x4c
		conn_lll->latency_prepare = 0;
     72c:	8662      	strh	r2, [r4, #50]	; 0x32
		conn_lll->latency_event = 0;
     72e:	6362      	str	r2, [r4, #52]	; 0x34
		conn_lll->slave.window_size_prepare_us = 0;
     730:	6562      	str	r2, [r4, #84]	; 0x54
		conn->connect_expire = 6;
     732:	f8a4 0074 	strh.w	r0, [r4, #116]	; 0x74
		conn->supervision_expire = 0;
     736:	f8a4 2078 	strh.w	r2, [r4, #120]	; 0x78
		conn->procedure_expire = 0;
     73a:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
		conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0;
     73e:	f8a4 208c 	strh.w	r2, [r4, #140]	; 0x8c
     742:	f884 208e 	strb.w	r2, [r4, #142]	; 0x8e
		conn->llcp_rx = NULL;
     746:	f8c4 209c 	str.w	r2, [r4, #156]	; 0x9c
		conn->llcp_cu.req = conn->llcp_cu.ack = 0;
     74a:	f8a4 20a0 	strh.w	r2, [r4, #160]	; 0xa0
		conn->llcp_feature.req = conn->llcp_feature.ack = 0;
     74e:	f8a4 20b4 	strh.w	r2, [r4, #180]	; 0xb4
		conn->llcp_feature.features = LL_FEAT;
     752:	f8c4 00b8 	str.w	r0, [r4, #184]	; 0xb8
		conn->llcp_version.req = conn->llcp_version.ack = 0;
     756:	f8a4 20bc 	strh.w	r2, [r4, #188]	; 0xbc
		conn->llcp_terminate.reason_peer = 0;
     75a:	f884 20c7 	strb.w	r2, [r4, #199]	; 0xc7
		conn->llcp_conn_param.req = 0;
     75e:	f8a4 20ec 	strh.w	r2, [r4, #236]	; 0xec
		conn->llcp_conn_param.disabled = 0;
     762:	f884 10ee 	strb.w	r1, [r4, #238]	; 0xee
		adv->node_rx_cc_free = node_rx;
     766:	e9c5 9b34 	strd	r9, fp, [r5, #208]	; 0xd0
		lll->conn = conn_lll;
     76a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
     76c:	626b      	str	r3, [r5, #36]	; 0x24
     76e:	f894 3020 	ldrb.w	r3, [r4, #32]
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
     772:	f8c4 2114 	str.w	r2, [r4, #276]	; 0x114
     776:	f362 0300 	bfi	r3, r2, #0, #1
		conn->tx_data = conn->tx_data_last = 0;
     77a:	e9c4 2248 	strd	r2, r2, [r4, #288]	; 0x120
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
     77e:	e9c4 2246 	strd	r2, r2, [r4, #280]	; 0x118
     782:	e9c4 2205 	strd	r2, r2, [r4, #20]
	hdr->parent = parent;
     786:	61e4      	str	r4, [r4, #28]
	hdr->is_stop = 0U;
     788:	f884 3020 	strb.w	r3, [r4, #32]
		err = lll_clock_wait();
     78c:	f01c fb80 	bl	1ce90 <lll_clock_wait>
		if (err) {
     790:	2800      	cmp	r0, #0
     792:	f43f aedb 	beq.w	54c <ll_adv_enable+0x8c>
			conn_release(adv);
     796:	4820      	ldr	r0, [pc, #128]	; (818 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x18>)
     798:	f01a fa9c 	bl	1acd4 <conn_release>
			return BT_HCI_ERR_HW_FAILURE;
     79c:	2603      	movs	r6, #3
     79e:	e698      	b.n	4d2 <ll_adv_enable+0x12>
			if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
     7a0:	2c01      	cmp	r4, #1
     7a2:	d015      	beq.n	7d0 <CONFIG_BT_COMPANY_ID+0x1df>
					  BYTES2US(ADVA_SIZE + rsp_data_len,
     7a4:	00db      	lsls	r3, r3, #3
		const u16_t scan_rsp_us  = ll_hdr_us +
     7a6:	3380      	adds	r3, #128	; 0x80
			} else if (pdu_adv->type == PDU_ADV_TYPE_ADV_IND) {
     7a8:	b964      	cbnz	r4, 7c4 <CONFIG_BT_COMPANY_ID+0x1d3>
				adv_size += adv_data_len;
     7aa:	f102 0010 	add.w	r0, r2, #16
				slot_us += scan_req_us + EVENT_IFS_MAX_US +
     7ae:	f503 7327 	add.w	r3, r3, #668	; 0x29c
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
     7b2:	00c2      	lsls	r2, r0, #3
     7b4:	3398      	adds	r3, #152	; 0x98
     7b6:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
				  + rx_to_us + rxtx_turn_us) * (adv_chn_cnt-1)
     7ba:	f502 709a 	add.w	r0, r2, #308	; 0x134
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
     7be:	fb01 3000 	mla	r0, r1, r0, r3
     7c2:	e6e6      	b.n	592 <ll_adv_enable+0xd2>
			} else if (pdu_adv->type == PDU_ADV_TYPE_SCAN_IND) {
     7c4:	2c06      	cmp	r4, #6
     7c6:	d0f0      	beq.n	7aa <CONFIG_BT_COMPANY_ID+0x1b9>
		u32_t adv_size		= ll_hdr_size + ADVA_SIZE;
     7c8:	2010      	movs	r0, #16
	u32_t slot_us	= EVENT_OVERHEAD_START_US + EVENT_OVERHEAD_END_US;
     7ca:	f44f 73aa 	mov.w	r3, #340	; 0x154
     7ce:	e7f0      	b.n	7b2 <CONFIG_BT_COMPANY_ID+0x1c1>
				adv_size += TARGETA_SIZE;
     7d0:	2016      	movs	r0, #22
				slot_us += conn_ind_us;
     7d2:	f44f 732d 	mov.w	r3, #692	; 0x2b4
     7d6:	e7ec      	b.n	7b2 <CONFIG_BT_COMPANY_ID+0x1c1>
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
     7d8:	4813      	ldr	r0, [pc, #76]	; (828 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x28>)
     7da:	2391      	movs	r3, #145	; 0x91
     7dc:	fbaa 0100 	umull	r0, r1, sl, r0
     7e0:	fb03 110a 	mla	r1, r3, sl, r1
     7e4:	a30a      	add	r3, pc, #40	; (adr r3, 810 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x10>)
     7e6:	e9d3 2300 	ldrd	r2, r3, [r3]
		ret = ticker_start(
     7ea:	e9cd 7702 	strd	r7, r7, [sp, #8]
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
     7ee:	f7ff fcd7 	bl	1a0 <__aeabi_uldivmod>
		ret = ticker_start(
     7f2:	464b      	mov	r3, r9
     7f4:	e9cd 7000 	strd	r7, r0, [sp]
     7f8:	2202      	movs	r2, #2
     7fa:	2103      	movs	r1, #3
     7fc:	4638      	mov	r0, r7
     7fe:	e723      	b.n	648 <CONFIG_BT_COMPANY_ID+0x57>
	if (adv->lll.conn) {
     800:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     802:	2b00      	cmp	r3, #0
     804:	f43f ae70 	beq.w	4e8 <ll_adv_enable+0x28>
		conn_release(adv);
     808:	4803      	ldr	r0, [pc, #12]	; (818 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x18>)
     80a:	f01a fa63 	bl	1acd4 <conn_release>
     80e:	e66b      	b.n	4e8 <ll_adv_enable+0x28>
     810:	1afd498d 	.word	0x1afd498d
     814:	00000007 	.word	0x00000007
     818:	20001658 	.word	0x20001658
     81c:	3b9aca00 	.word	0x3b9aca00
     820:	0001abd5 	.word	0x0001abd5
     824:	0001ae2d 	.word	0x0001ae2d
     828:	84e72a00 	.word	0x84e72a00
     82c:	0001a615 	.word	0x0001a615

00000830 <ull_scan_enable>:
	lll->interval = interval;
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
}

u8_t ull_scan_enable(struct ll_scan_set *scan)
{
     830:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
     834:	b08c      	sub	sp, #48	; 0x30
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
     836:	2302      	movs	r3, #2
{
     838:	4604      	mov	r4, r0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
     83a:	930b      	str	r3, [sp, #44]	; 0x2c
	u32_t ticks_slot_offset;
	u32_t ticks_interval;
	u32_t ticks_anchor;
	u32_t ret;

	lll->chan = 0;
     83c:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
	lll->init_addr_type = scan->own_addr_type;
     840:	f890 0038 	ldrb.w	r0, [r0, #56]	; 0x38
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	ull_hdr_init(&scan->ull);
	lll_hdr_init(lll, scan);

	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
     844:	4e36      	ldr	r6, [pc, #216]	; (920 <ull_scan_enable+0xf0>)
	lll->init_addr_type = scan->own_addr_type;
     846:	f3c0 0040 	ubfx	r0, r0, #1, #1
     84a:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
     84e:	f360 1386 	bfi	r3, r0, #6, #1
     852:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	ll_addr_get(lll->init_addr_type, lll->init_addr);
     856:	f104 0125 	add.w	r1, r4, #37	; 0x25
     85a:	f018 fac9 	bl	18df0 <ll_addr_get>
     85e:	f894 3020 	ldrb.w	r3, [r4, #32]
	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
     862:	8e67      	ldrh	r7, [r4, #50]	; 0x32
	hdr->parent = parent;
     864:	61e4      	str	r4, [r4, #28]
     866:	2500      	movs	r5, #0
	hdr->is_stop = 0U;
     868:	f365 0300 	bfi	r3, r5, #0, #1
     86c:	fba7 0106 	umull	r0, r1, r7, r6
     870:	f884 3020 	strb.w	r3, [r4, #32]
     874:	2391      	movs	r3, #145	; 0x91
     876:	fb03 1107 	mla	r1, r3, r7, r1
     87a:	e9c4 5505 	strd	r5, r5, [r4, #20]
     87e:	a326      	add	r3, pc, #152	; (adr r3, 918 <ull_scan_enable+0xe8>)
     880:	e9d3 2300 	ldrd	r2, r3, [r3]
     884:	f7ff fc8c 	bl	1a0 <__aeabi_uldivmod>

	/* TODO: active_to_start feature port */
	scan->evt.ticks_active_to_start = 0U;
	scan->evt.ticks_xtal_to_start =
     888:	2331      	movs	r3, #49	; 0x31
     88a:	6023      	str	r3, [r4, #0]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	scan->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	if ((lll->ticks_window +
     88c:	6b63      	ldr	r3, [r4, #52]	; 0x34
	scan->evt.ticks_active_to_start = 0U;
     88e:	6065      	str	r5, [r4, #4]
	if ((lll->ticks_window +
     890:	3309      	adds	r3, #9
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) <
	    (ticks_interval -
     892:	f1a0 0231 	sub.w	r2, r0, #49	; 0x31
	if ((lll->ticks_window +
     896:	4293      	cmp	r3, r2
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US))) {
		scan->evt.ticks_slot =
     898:	bf32      	itee	cc
     89a:	60e3      	strcc	r3, [r4, #12]
			(lll->ticks_window +
			 HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US));
	} else {
		scan->evt.ticks_slot =
     89c:	60e2      	strcs	r2, [r4, #12]
			(ticks_interval -
			 HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US));
		lll->ticks_window = 0;
     89e:	6365      	strcs	r5, [r4, #52]	; 0x34
	scan->evt.ticks_preempt_to_start =
     8a0:	60a5      	str	r5, [r4, #8]
	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
     8a2:	4607      	mov	r7, r0
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	ticks_anchor = ticker_ticks_now_get();
     8a4:	f027 fd25 	bl	282f2 <ticker_ticks_now_get>
				       HAL_TICKER_US_TO_TICKS(offset_us);
		}
	}
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8a8:	4b1e      	ldr	r3, [pc, #120]	; (924 <ull_scan_enable+0xf4>)
			   TICKER_USER_ID_THREAD, TICKER_ID_SCAN_BASE,
			   ticks_anchor, 0, ticks_interval,
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
     8aa:	f8b4 b032 	ldrh.w	fp, [r4, #50]	; 0x32
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8ae:	e9cd 4306 	strd	r4, r3, [sp, #24]
     8b2:	4b1d      	ldr	r3, [pc, #116]	; (928 <ull_scan_enable+0xf8>)
     8b4:	9305      	str	r3, [sp, #20]
     8b6:	46b1      	mov	r9, r6
     8b8:	68e3      	ldr	r3, [r4, #12]
     8ba:	9304      	str	r3, [sp, #16]
	ticks_anchor = ticker_ticks_now_get();
     8bc:	4680      	mov	r8, r0
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
     8be:	2391      	movs	r3, #145	; 0x91
     8c0:	fbab 0109 	umull	r0, r1, fp, r9
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8c4:	2500      	movs	r5, #0
     8c6:	ae0b      	add	r6, sp, #44	; 0x2c
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
     8c8:	fb03 110b 	mla	r1, r3, fp, r1
     8cc:	a312      	add	r3, pc, #72	; (adr r3, 918 <ull_scan_enable+0xe8>)
     8ce:	e9d3 2300 	ldrd	r2, r3, [r3]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8d2:	9608      	str	r6, [sp, #32]
     8d4:	9503      	str	r5, [sp, #12]
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
     8d6:	f7ff fc63 	bl	1a0 <__aeabi_uldivmod>
     8da:	4610      	mov	r0, r2
     8dc:	4619      	mov	r1, r3
     8de:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     8e2:	2300      	movs	r3, #0
     8e4:	f7ff fc5c 	bl	1a0 <__aeabi_uldivmod>
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8e8:	2103      	movs	r1, #3
     8ea:	e9cd 7001 	strd	r7, r0, [sp, #4]
     8ee:	9500      	str	r5, [sp, #0]
     8f0:	4643      	mov	r3, r8
     8f2:	2204      	movs	r2, #4
     8f4:	4628      	mov	r0, r5
     8f6:	f018 f9b3 	bl	18c60 <ticker_start>
			   TICKER_NULL_LAZY,
			   (scan->evt.ticks_slot + ticks_slot_overhead),
			   ticker_cb, scan,
			   ull_ticker_status_give, (void *)&ret_cb);

	ret = ull_ticker_status_take(ret, &ret_cb);
     8fa:	4631      	mov	r1, r6
     8fc:	f019 fe90 	bl	1a620 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     900:	b940      	cbnz	r0, 914 <ull_scan_enable+0xe4>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	scan->is_enabled = 1U;
     902:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
     906:	f043 0301 	orr.w	r3, r3, #1
     90a:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
		ull_filter_adv_scan_state_cb(BIT(1));
	}
#endif

	return 0;
}
     90e:	b00c      	add	sp, #48	; 0x30
     910:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
     914:	200c      	movs	r0, #12
     916:	e7fa      	b.n	90e <ull_scan_enable+0xde>
     918:	1afd498d 	.word	0x1afd498d
     91c:	00000007 	.word	0x00000007
     920:	84e72a00 	.word	0x84e72a00
     924:	0001a615 	.word	0x0001a615
     928:	0001b1c5 	.word	0x0001b1c5
     92c:	00000000 	.word	0x00000000

00000930 <ll_scan_params_set>:
{
     930:	b570      	push	{r4, r5, r6, lr}
     932:	4605      	mov	r5, r0
	scan = ull_scan_is_disabled_get(0);
     934:	2000      	movs	r0, #0
{
     936:	461e      	mov	r6, r3
	scan = ull_scan_is_disabled_get(0);
     938:	f01a fd06 	bl	1b348 <ull_scan_is_disabled_get>
	if (!scan) {
     93c:	4604      	mov	r4, r0
     93e:	b310      	cbz	r0, 986 <ll_scan_params_set+0x56>
	scan->own_addr_type = own_addr_type;
     940:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
     944:	f366 0342 	bfi	r3, r6, #1, #2
     948:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
	lll->filter_policy = filter_policy;
     94c:	f89d 3010 	ldrb.w	r3, [sp, #16]
	lll->interval = interval;
     950:	8661      	strh	r1, [r4, #50]	; 0x32
	lll->filter_policy = filter_policy;
     952:	00db      	lsls	r3, r3, #3
     954:	f003 0318 	and.w	r3, r3, #24
     958:	ea43 10c5 	orr.w	r0, r3, r5, lsl #7
     95c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
     960:	f003 0367 	and.w	r3, r3, #103	; 0x67
     964:	4318      	orrs	r0, r3
     966:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
     96a:	480b      	ldr	r0, [pc, #44]	; (998 <ll_scan_params_set+0x68>)
     96c:	2391      	movs	r3, #145	; 0x91
     96e:	fba2 0100 	umull	r0, r1, r2, r0
     972:	fb03 1102 	mla	r1, r3, r2, r1
     976:	a306      	add	r3, pc, #24	; (adr r3, 990 <ll_scan_params_set+0x60>)
     978:	e9d3 2300 	ldrd	r2, r3, [r3]
     97c:	f7ff fc10 	bl	1a0 <__aeabi_uldivmod>
     980:	6360      	str	r0, [r4, #52]	; 0x34
	return 0;
     982:	2000      	movs	r0, #0
}
     984:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
     986:	200c      	movs	r0, #12
     988:	e7fc      	b.n	984 <ll_scan_params_set+0x54>
     98a:	bf00      	nop
     98c:	f3af 8000 	nop.w
     990:	1afd498d 	.word	0x1afd498d
     994:	00000007 	.word	0x00000007
     998:	84e72a00 	.word	0x84e72a00
     99c:	00000000 	.word	0x00000000

000009a0 <ull_conn_llcp>:

	return 0;
}

int ull_conn_llcp(struct ll_conn *conn, u32_t ticks_at_expire, u16_t lazy)
{
     9a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     9a4:	4690      	mov	r8, r2
	LL_ASSERT(conn->lll.handle != 0xFFFF);
     9a6:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
     9a8:	f64f 73ff 	movw	r3, #65535	; 0xffff
     9ac:	429a      	cmp	r2, r3
{
     9ae:	b08d      	sub	sp, #52	; 0x34
     9b0:	4604      	mov	r4, r0
     9b2:	460e      	mov	r6, r1
	LL_ASSERT(conn->lll.handle != 0xFFFF);
     9b4:	d10c      	bne.n	9d0 <ull_conn_llcp+0x30>
     9b6:	4acd      	ldr	r2, [pc, #820]	; (cec <ull_conn_llcp+0x34c>)
     9b8:	49cd      	ldr	r1, [pc, #820]	; (cf0 <ull_conn_llcp+0x350>)
     9ba:	48ce      	ldr	r0, [pc, #824]	; (cf4 <ull_conn_llcp+0x354>)
     9bc:	f44f 7344 	mov.w	r3, #784	; 0x310
     9c0:	f023 fa8f 	bl	23ee2 <printk>
     9c4:	4040      	eors	r0, r0
     9c6:	f380 8811 	msr	BASEPRI, r0
     9ca:	f04f 0003 	mov.w	r0, #3
     9ce:	df02      	svc	2

	/* Check if no other procedure with instant is requested and not in
	 * Encryption setup.
	 */
	if ((conn->llcp_ack == conn->llcp_req) &&
     9d0:	f894 208d 	ldrb.w	r2, [r4, #141]	; 0x8d
     9d4:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
     9d8:	4293      	cmp	r3, r2
     9da:	d10b      	bne.n	9f4 <ull_conn_llcp+0x54>
#endif /* !CONFIG_BT_CTLR_LE_ENC */

		/* TODO: Optimize the checks below, maybe have common flag */

		/* check if connection update procedure is requested */
		if (conn->llcp_cu.ack != conn->llcp_cu.req) {
     9dc:	f894 20a1 	ldrb.w	r2, [r4, #161]	; 0xa1
     9e0:	f894 10a0 	ldrb.w	r1, [r4, #160]	; 0xa0
     9e4:	4291      	cmp	r1, r2
     9e6:	d025      	beq.n	a34 <ull_conn_llcp+0x94>
			/* switch to LLCP_CONN_UPD state machine */
			conn->llcp_type = LLCP_CONN_UPD;
     9e8:	2201      	movs	r2, #1
			conn->llcp_ack -= 2U;
     9ea:	3b02      	subs	r3, #2
			conn->llcp_type = LLCP_CONN_UPD;
     9ec:	f884 208e 	strb.w	r2, [r4, #142]	; 0x8e
			conn->llcp_ack -= 2U;
     9f0:	f884 308d 	strb.w	r3, [r4, #141]	; 0x8d
	}

	/* Check if procedures with instant or encryption setup is requested or
	 * active.
	 */
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
     9f4:	f894 108c 	ldrb.w	r1, [r4, #140]	; 0x8c
     9f8:	f894 308d 	ldrb.w	r3, [r4, #141]	; 0x8d
     9fc:	1acb      	subs	r3, r1, r3
     9fe:	f003 0303 	and.w	r3, r3, #3
     a02:	2b02      	cmp	r3, #2
     a04:	f040 8279 	bne.w	efa <ull_conn_llcp+0x55a>
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */
		}

		/* Process procedures with instants or encryption setup */
		/* FIXME: Make LE Ping cacheable */
		switch (conn->llcp_type) {
     a08:	f894 308e 	ldrb.w	r3, [r4, #142]	; 0x8e
     a0c:	2b01      	cmp	r3, #1
     a0e:	f000 8222 	beq.w	e56 <ull_conn_llcp+0x4b6>
     a12:	2b02      	cmp	r3, #2
     a14:	f000 8438 	beq.w	1288 <ull_conn_llcp+0x8e8>
		}
		break;
#endif /* CONFIG_BT_CTLR_PHY */

		default:
			LL_ASSERT(0);
     a18:	4ab4      	ldr	r2, [pc, #720]	; (cec <ull_conn_llcp+0x34c>)
     a1a:	49b7      	ldr	r1, [pc, #732]	; (cf8 <ull_conn_llcp+0x358>)
     a1c:	48b5      	ldr	r0, [pc, #724]	; (cf4 <ull_conn_llcp+0x354>)
     a1e:	f240 3396 	movw	r3, #918	; 0x396
     a22:	f023 fa5e 	bl	23ee2 <printk>
     a26:	4040      	eors	r0, r0
     a28:	f380 8811 	msr	BASEPRI, r0
     a2c:	f04f 0003 	mov.w	r0, #3
     a30:	df02      	svc	2
			break;
     a32:	e262      	b.n	efa <ull_conn_llcp+0x55a>
		} else if (conn->llcp_feature.ack != conn->llcp_feature.req) {
     a34:	f894 30b5 	ldrb.w	r3, [r4, #181]	; 0xb5
     a38:	f894 10b4 	ldrb.w	r1, [r4, #180]	; 0xb4
     a3c:	428b      	cmp	r3, r1
     a3e:	d067      	beq.n	b10 <ull_conn_llcp+0x170>
static inline void event_fex_prep(struct ll_conn *conn)
{
	struct node_tx *tx;

	/* If waiting for response, do nothing */
	if (!((conn->llcp_feature.ack - conn->llcp_feature.req) & 0x01)) {
     a40:	1a5b      	subs	r3, r3, r1
     a42:	07d8      	lsls	r0, r3, #31
     a44:	d5d6      	bpl.n	9f4 <ull_conn_llcp+0x54>
		return;
	}

	if (conn->common.fex_valid) {
     a46:	f894 1080 	ldrb.w	r1, [r4, #128]	; 0x80
     a4a:	f011 0701 	ands.w	r7, r1, #1
     a4e:	d02e      	beq.n	aae <ull_conn_llcp+0x10e>
		struct node_rx_pdu *rx;
		struct pdu_data *pdu;

		/* get a rx node for ULL->LL */
		rx = ll_pdu_rx_alloc();
     a50:	f019 fd7e 	bl	1a550 <ll_pdu_rx_alloc>
		if (!rx) {
     a54:	4605      	mov	r5, r0
     a56:	2800      	cmp	r0, #0
     a58:	d0cc      	beq.n	9f4 <ull_conn_llcp+0x54>
			return;
		}

		/* procedure request acked */
		conn->llcp_feature.ack = conn->llcp_feature.req;
     a5a:	f894 30b4 	ldrb.w	r3, [r4, #180]	; 0xb4
     a5e:	f884 30b5 	strb.w	r3, [r4, #181]	; 0xb5

		/* prepare feature rsp structure */
		rx->hdr.handle = conn->lll.handle;
     a62:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
     a64:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
     a66:	2302      	movs	r3, #2
     a68:	7103      	strb	r3, [r0, #4]
		pdu = (void *)rx->pdu;
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     a6a:	f890 3020 	ldrb.w	r3, [r0, #32]
     a6e:	f043 0303 	orr.w	r3, r3, #3
     a72:	f880 3020 	strb.w	r3, [r0, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
     a76:	2309      	movs	r3, #9
     a78:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
			   sizeof(struct pdu_data_llctrl_feature_rsp);
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
     a7c:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
     a80:	2208      	movs	r2, #8
     a82:	2100      	movs	r1, #0
     a84:	3024      	adds	r0, #36	; 0x24
     a86:	f025 f93a 	bl	25cfe <memset>
			sizeof(pdu->llctrl.feature_rsp.features));
		sys_put_le24(conn->llcp_feature.features,
     a8a:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(u16_t val, u8_t dst[2])
{
	dst[0] = val;
     a8e:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
	dst[1] = val >> 8;
     a92:	f3c3 2207 	ubfx	r2, r3, #8, #8
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le24(u32_t val, u8_t dst[3])
{
	sys_put_le16(val, dst);
	dst[2] = val >> 16;
     a96:	0c1b      	lsrs	r3, r3, #16
	dst[1] = val >> 8;
     a98:	f885 2025 	strb.w	r2, [r5, #37]	; 0x25
	dst[2] = val >> 16;
     a9c:	f885 3026 	strb.w	r3, [r5, #38]	; 0x26
			     pdu->llctrl.feature_req.features);

		/* enqueue feature rsp structure into rx queue */
		ll_rx_put(rx->hdr.link, rx);
     aa0:	4629      	mov	r1, r5
			sys_cpu_to_le16(conn->llcp_version.company_id);
		pdu->llctrl.version_ind.sub_version_number =
			sys_cpu_to_le16(conn->llcp_version.sub_version_number);

		/* enqueue version ind structure into rx queue */
		ll_rx_put(rx->hdr.link, rx);
     aa2:	6808      	ldr	r0, [r1, #0]
     aa4:	f019 fd2c 	bl	1a500 <ll_rx_put>
		ll_rx_sched();
     aa8:	f019 fd34 	bl	1a514 <ll_rx_sched>
     aac:	e7a2      	b.n	9f4 <ull_conn_llcp+0x54>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
     aae:	4893      	ldr	r0, [pc, #588]	; (cfc <ull_conn_llcp+0x35c>)
     ab0:	f027 fae8 	bl	28084 <mem_acquire>
	if (tx) {
     ab4:	4605      	mov	r5, r0
     ab6:	2800      	cmp	r0, #0
     ab8:	d09c      	beq.n	9f4 <ull_conn_llcp+0x54>
		conn->llcp_feature.ack--;
     aba:	f894 30b5 	ldrb.w	r3, [r4, #181]	; 0xb5
     abe:	3b01      	subs	r3, #1
     ac0:	f884 30b5 	strb.w	r3, [r4, #181]	; 0xb5
		conn->llcp_feature.features = LL_FEAT;
     ac4:	2306      	movs	r3, #6
     ac6:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     aca:	7903      	ldrb	r3, [r0, #4]
     acc:	f043 0303 	orr.w	r3, r3, #3
     ad0:	7103      	strb	r3, [r0, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
     ad2:	2309      	movs	r3, #9
     ad4:	7143      	strb	r3, [r0, #5]
		pdu->llctrl.opcode = !conn->lll.role ?
     ad6:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
     ada:	2b00      	cmp	r3, #0
     adc:	bfac      	ite	ge
     ade:	2308      	movge	r3, #8
     ae0:	230e      	movlt	r3, #14
		(void)memset(&pdu->llctrl.feature_req.features[0],
     ae2:	2208      	movs	r2, #8
		pdu->llctrl.opcode = !conn->lll.role ?
     ae4:	71c3      	strb	r3, [r0, #7]
		(void)memset(&pdu->llctrl.feature_req.features[0],
     ae6:	4639      	mov	r1, r7
     ae8:	4410      	add	r0, r2
     aea:	f025 f908 	bl	25cfe <memset>
		sys_put_le24(conn->llcp_feature.features,
     aee:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
	dst[0] = val;
     af2:	722b      	strb	r3, [r5, #8]
	dst[1] = val >> 8;
     af4:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
     af8:	0c1b      	lsrs	r3, r3, #16
	dst[1] = val >> 8;
     afa:	726a      	strb	r2, [r5, #9]
	dst[2] = val >> 16;
     afc:	72ab      	strb	r3, [r5, #10]
		ctrl_tx_enqueue(conn, tx);
     afe:	4629      	mov	r1, r5
			ctrl_tx_enqueue(conn, tx);
     b00:	4620      	mov	r0, r4
     b02:	f027 fd3c 	bl	2857e <ctrl_tx_enqueue>
			conn->procedure_expire = conn->procedure_reload;
     b06:	f8b4 307a 	ldrh.w	r3, [r4, #122]	; 0x7a
     b0a:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
     b0e:	e771      	b.n	9f4 <ull_conn_llcp+0x54>
		} else if (conn->llcp_version.ack != conn->llcp_version.req) {
     b10:	f894 30bd 	ldrb.w	r3, [r4, #189]	; 0xbd
     b14:	f894 10bc 	ldrb.w	r1, [r4, #188]	; 0xbc
     b18:	428b      	cmp	r3, r1
     b1a:	d064      	beq.n	be6 <ull_conn_llcp+0x246>
	if (!((conn->llcp_version.ack - conn->llcp_version.req) & 0x01)) {
     b1c:	1a5b      	subs	r3, r3, r1
     b1e:	07d9      	lsls	r1, r3, #31
     b20:	f57f af68 	bpl.w	9f4 <ull_conn_llcp+0x54>
	if (conn->llcp_version.tx == 0U) {
     b24:	f894 30be 	ldrb.w	r3, [r4, #190]	; 0xbe
     b28:	07da      	lsls	r2, r3, #31
     b2a:	d425      	bmi.n	b78 <ull_conn_llcp+0x1d8>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
     b2c:	4873      	ldr	r0, [pc, #460]	; (cfc <ull_conn_llcp+0x35c>)
     b2e:	f027 faa9 	bl	28084 <mem_acquire>
		if (tx) {
     b32:	4601      	mov	r1, r0
     b34:	2800      	cmp	r0, #0
     b36:	f43f af5d 	beq.w	9f4 <ull_conn_llcp+0x54>
			conn->llcp_version.ack--;
     b3a:	f894 30bd 	ldrb.w	r3, [r4, #189]	; 0xbd
     b3e:	3b01      	subs	r3, #1
     b40:	f884 30bd 	strb.w	r3, [r4, #189]	; 0xbd
			conn->llcp_version.tx = 1U;
     b44:	f894 30be 	ldrb.w	r3, [r4, #190]	; 0xbe
     b48:	f043 0301 	orr.w	r3, r3, #1
     b4c:	f884 30be 	strb.w	r3, [r4, #190]	; 0xbe
			pdu->ll_id = PDU_DATA_LLID_CTRL;
     b50:	7903      	ldrb	r3, [r0, #4]
     b52:	f043 0303 	orr.w	r3, r3, #3
     b56:	7103      	strb	r3, [r0, #4]
			pdu->len =
     b58:	2306      	movs	r3, #6
     b5a:	7143      	strb	r3, [r0, #5]
			pdu->llctrl.opcode =
     b5c:	230c      	movs	r3, #12
     b5e:	71c3      	strb	r3, [r0, #7]
			pdu->llctrl.version_ind.version_number =
     b60:	230a      	movs	r3, #10
     b62:	7203      	strb	r3, [r0, #8]
			pdu->llctrl.version_ind.company_id = cid;
     b64:	f06f 030e 	mvn.w	r3, #14
     b68:	7243      	strb	r3, [r0, #9]
     b6a:	2305      	movs	r3, #5
     b6c:	7283      	strb	r3, [r0, #10]
			pdu->llctrl.version_ind.sub_version_number = svn;
     b6e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     b72:	72c3      	strb	r3, [r0, #11]
     b74:	7303      	strb	r3, [r0, #12]
     b76:	e7c3      	b.n	b00 <ull_conn_llcp+0x160>
	} else if (conn->llcp_version.rx) {
     b78:	079f      	lsls	r7, r3, #30
     b7a:	d526      	bpl.n	bca <ull_conn_llcp+0x22a>
		rx = ll_pdu_rx_alloc();
     b7c:	f019 fce8 	bl	1a550 <ll_pdu_rx_alloc>
		if (!rx) {
     b80:	4601      	mov	r1, r0
     b82:	2800      	cmp	r0, #0
     b84:	f43f af36 	beq.w	9f4 <ull_conn_llcp+0x54>
		conn->llcp_version.ack = conn->llcp_version.req;
     b88:	f894 30bc 	ldrb.w	r3, [r4, #188]	; 0xbc
     b8c:	f884 30bd 	strb.w	r3, [r4, #189]	; 0xbd
		rx->hdr.handle = conn->lll.handle;
     b90:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
     b92:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
     b94:	2302      	movs	r3, #2
     b96:	7103      	strb	r3, [r0, #4]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     b98:	f890 3020 	ldrb.w	r3, [r0, #32]
     b9c:	f043 0303 	orr.w	r3, r3, #3
     ba0:	f880 3020 	strb.w	r3, [r0, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
     ba4:	2306      	movs	r3, #6
     ba6:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
     baa:	230c      	movs	r3, #12
     bac:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		pdu->llctrl.version_ind.version_number =
     bb0:	f894 30bf 	ldrb.w	r3, [r4, #191]	; 0xbf
     bb4:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
		pdu->llctrl.version_ind.company_id =
     bb8:	f8b4 30c0 	ldrh.w	r3, [r4, #192]	; 0xc0
     bbc:	f8a0 3025 	strh.w	r3, [r0, #37]	; 0x25
		pdu->llctrl.version_ind.sub_version_number =
     bc0:	f8b4 30c2 	ldrh.w	r3, [r4, #194]	; 0xc2
     bc4:	f8a0 3027 	strh.w	r3, [r0, #39]	; 0x27
     bc8:	e76b      	b.n	aa2 <ull_conn_llcp+0x102>
	} else {
		/* tx-ed but no rx, and new request placed */
		LL_ASSERT(0);
     bca:	f640 332a 	movw	r3, #2858	; 0xb2a
	case LLCP_CPR_STATE_UPD:
		/* Do nothing */
		break;

	default:
		LL_ASSERT(0);
     bce:	4a47      	ldr	r2, [pc, #284]	; (cec <ull_conn_llcp+0x34c>)
     bd0:	4949      	ldr	r1, [pc, #292]	; (cf8 <ull_conn_llcp+0x358>)
     bd2:	4848      	ldr	r0, [pc, #288]	; (cf4 <ull_conn_llcp+0x354>)
     bd4:	f023 f985 	bl	23ee2 <printk>
     bd8:	4040      	eors	r0, r0
     bda:	f380 8811 	msr	BASEPRI, r0
     bde:	f04f 0003 	mov.w	r0, #3
     be2:	df02      	svc	2
		break;
     be4:	e706      	b.n	9f4 <ull_conn_llcp+0x54>
		} else if (conn->llcp_conn_param.ack !=
     be6:	f894 10ed 	ldrb.w	r1, [r4, #237]	; 0xed
     bea:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
     bee:	4299      	cmp	r1, r3
     bf0:	f43f af00 	beq.w	9f4 <ull_conn_llcp+0x54>
	conn_upd = conn_upd_curr;
     bf4:	4d42      	ldr	r5, [pc, #264]	; (d00 <ull_conn_llcp+0x360>)
     bf6:	682b      	ldr	r3, [r5, #0]
	if (conn_upd && (conn_upd != conn)) {
     bf8:	b113      	cbz	r3, c00 <ull_conn_llcp+0x260>
     bfa:	429c      	cmp	r4, r3
     bfc:	f47f aefa 	bne.w	9f4 <ull_conn_llcp+0x54>
	switch (conn->llcp_conn_param.state) {
     c00:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
     c04:	f003 0307 	and.w	r3, r3, #7
     c08:	2b05      	cmp	r3, #5
     c0a:	f200 8121 	bhi.w	e50 <ull_conn_llcp+0x4b0>
     c0e:	a101      	add	r1, pc, #4	; (adr r1, c14 <ull_conn_llcp+0x274>)
     c10:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
     c14:	00000c2d 	.word	0x00000c2d
     c18:	00000ca9 	.word	0x00000ca9
     c1c:	00000dff 	.word	0x00000dff
     c20:	000009f5 	.word	0x000009f5
     c24:	000009f5 	.word	0x000009f5
     c28:	000009f5 	.word	0x000009f5
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
     c2c:	4833      	ldr	r0, [pc, #204]	; (cfc <ull_conn_llcp+0x35c>)
			event_counter = lll->event_counter +
     c2e:	8ee7      	ldrh	r7, [r4, #54]	; 0x36
					lll->latency_prepare + lazy;
     c30:	f8b4 9032 	ldrh.w	r9, [r4, #50]	; 0x32
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
     c34:	f027 fa26 	bl	28084 <mem_acquire>
	if (!tx) {
     c38:	4601      	mov	r1, r0
     c3a:	2800      	cmp	r0, #0
     c3c:	f43f aeda 	beq.w	9f4 <ull_conn_llcp+0x54>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
     c40:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
     c44:	2204      	movs	r2, #4
     c46:	f362 0302 	bfi	r3, r2, #0, #3
     c4a:	f884 30ee 	strb.w	r3, [r4, #238]	; 0xee
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
     c4e:	7903      	ldrb	r3, [r0, #4]
     c50:	f043 0303 	orr.w	r3, r3, #3
     c54:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
     c56:	2318      	movs	r3, #24
     c58:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
     c5a:	230f      	movs	r3, #15
     c5c:	71c3      	strb	r3, [r0, #7]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
     c5e:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
     c62:	8103      	strh	r3, [r0, #8]
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
     c64:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
     c68:	8143      	strh	r3, [r0, #10]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
     c6a:	f8b4 30f4 	ldrh.w	r3, [r4, #244]	; 0xf4
     c6e:	8183      	strh	r3, [r0, #12]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
     c70:	f8b4 30f6 	ldrh.w	r3, [r4, #246]	; 0xf6
     c74:	81c3      	strh	r3, [r0, #14]
			event_counter = lll->event_counter +
     c76:	444f      	add	r7, r9
	p->preferred_periodicity = 0U;
     c78:	2300      	movs	r3, #0
     c7a:	7403      	strb	r3, [r0, #16]
	p->offset0 = sys_cpu_to_le16(0x0000);
     c7c:	74c3      	strb	r3, [r0, #19]
     c7e:	7503      	strb	r3, [r0, #20]
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
     c80:	4447      	add	r7, r8
	p->offset1 = sys_cpu_to_le16(0xffff);
     c82:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
     c86:	f8a0 7011 	strh.w	r7, [r0, #17]
	p->offset1 = sys_cpu_to_le16(0xffff);
     c8a:	7543      	strb	r3, [r0, #21]
     c8c:	7583      	strb	r3, [r0, #22]
	p->offset2 = sys_cpu_to_le16(0xffff);
     c8e:	75c3      	strb	r3, [r0, #23]
     c90:	7603      	strb	r3, [r0, #24]
	p->offset3 = sys_cpu_to_le16(0xffff);
     c92:	7643      	strb	r3, [r0, #25]
     c94:	7683      	strb	r3, [r0, #26]
	p->offset4 = sys_cpu_to_le16(0xffff);
     c96:	76c3      	strb	r3, [r0, #27]
     c98:	7703      	strb	r3, [r0, #28]
	p->offset5 = sys_cpu_to_le16(0xffff);
     c9a:	7743      	strb	r3, [r0, #29]
     c9c:	7783      	strb	r3, [r0, #30]
	ctrl_tx_enqueue(conn, tx);
     c9e:	4620      	mov	r0, r4
     ca0:	f027 fc6d 	bl	2857e <ctrl_tx_enqueue>
	conn_upd_curr = conn;
     ca4:	602c      	str	r4, [r5, #0]
	conn->procedure_expire = conn->procedure_reload;
     ca6:	e72e      	b.n	b06 <ull_conn_llcp+0x166>
	if (conn->llcp_conn_param.status) {
     ca8:	f894 70ef 	ldrb.w	r7, [r4, #239]	; 0xef
     cac:	b357      	cbz	r7, d04 <ull_conn_llcp+0x364>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
     cae:	4813      	ldr	r0, [pc, #76]	; (cfc <ull_conn_llcp+0x35c>)
     cb0:	f027 f9e8 	bl	28084 <mem_acquire>
		if (!tx) {
     cb4:	4601      	mov	r1, r0
     cb6:	2800      	cmp	r0, #0
     cb8:	f43f ae9c 	beq.w	9f4 <ull_conn_llcp+0x54>
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     cbc:	7903      	ldrb	r3, [r0, #4]
     cbe:	f043 0303 	orr.w	r3, r3, #3
     cc2:	7103      	strb	r3, [r0, #4]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
     cc4:	2311      	movs	r3, #17
     cc6:	71c3      	strb	r3, [r0, #7]
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
     cc8:	2303      	movs	r3, #3
     cca:	7143      	strb	r3, [r0, #5]
		rej->reject_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
     ccc:	230f      	movs	r3, #15
     cce:	7203      	strb	r3, [r0, #8]
		rej->error_code = conn->llcp_conn_param.status;
     cd0:	f894 30ef 	ldrb.w	r3, [r4, #239]	; 0xef
     cd4:	7243      	strb	r3, [r0, #9]
		ctrl_tx_enqueue(conn, tx);
     cd6:	4620      	mov	r0, r4
     cd8:	f027 fc51 	bl	2857e <ctrl_tx_enqueue>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
     cdc:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
     ce0:	f884 30ed 	strb.w	r3, [r4, #237]	; 0xed
		conn_upd_curr = NULL;
     ce4:	2300      	movs	r3, #0
     ce6:	602b      	str	r3, [r5, #0]
		return;
     ce8:	e684      	b.n	9f4 <ull_conn_llcp+0x54>
     cea:	bf00      	nop
     cec:	00030625 	.word	0x00030625
     cf0:	00030752 	.word	0x00030752
     cf4:	0002a5e8 	.word	0x0002a5e8
     cf8:	0002e3c9 	.word	0x0002e3c9
     cfc:	20001944 	.word	0x20001944
     d00:	200018c8 	.word	0x200018c8
	if (!conn->lll.role) {
     d04:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
     d08:	2b00      	cmp	r3, #0
     d0a:	db35      	blt.n	d78 <ull_conn_llcp+0x3d8>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
     d0c:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
		conn->llcp_cu.win_offset_us = 0U;
     d10:	f8c4 70ac 	str.w	r7, [r4, #172]	; 0xac
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
     d14:	2105      	movs	r1, #5
     d16:	f361 0302 	bfi	r3, r1, #0, #3
		if (conn->llcp_conn_param.preferred_periodicity) {
     d1a:	f894 10f8 	ldrb.w	r1, [r4, #248]	; 0xf8
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
     d1e:	f884 30ee 	strb.w	r3, [r4, #238]	; 0xee
		conn->llcp_cu.win_size = 1U;
     d22:	2301      	movs	r3, #1
     d24:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
		if (conn->llcp_conn_param.preferred_periodicity) {
     d28:	b319      	cbz	r1, d72 <ull_conn_llcp+0x3d2>
				((conn->llcp_conn_param.interval_min /
     d2a:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
     d2e:	fbb3 f3f1 	udiv	r3, r3, r1
				  conn->llcp_conn_param.preferred_periodicity) +
     d32:	3301      	adds	r3, #1
			conn->llcp_cu.interval =
     d34:	fb13 f301 	smulbb	r3, r3, r1
     d38:	b29b      	uxth	r3, r3
     d3a:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
     d3e:	f8b4 30f4 	ldrh.w	r3, [r4, #244]	; 0xf4
     d42:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
     d46:	f8b4 30f6 	ldrh.w	r3, [r4, #246]	; 0xf6
     d4a:	f8a4 30a8 	strh.w	r3, [r4, #168]	; 0xa8
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
     d4e:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
     d52:	f894 10a2 	ldrb.w	r1, [r4, #162]	; 0xa2
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
     d56:	f3c3 03c0 	ubfx	r3, r3, #3, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
     d5a:	009b      	lsls	r3, r3, #2
     d5c:	f043 0302 	orr.w	r3, r3, #2
     d60:	f021 0107 	bic.w	r1, r1, #7
     d64:	430b      	orrs	r3, r1
		conn->llcp_cu.ack--;
     d66:	3a01      	subs	r2, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
     d68:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
		conn->llcp_cu.ack--;
     d6c:	f884 20a1 	strb.w	r2, [r4, #161]	; 0xa1
		return;
     d70:	e640      	b.n	9f4 <ull_conn_llcp+0x54>
				conn->llcp_conn_param.interval_max;
     d72:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
     d76:	e7e0      	b.n	d3a <ull_conn_llcp+0x39a>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
     d78:	4865      	ldr	r0, [pc, #404]	; (f10 <ull_conn_llcp+0x570>)
     d7a:	f027 f983 	bl	28084 <mem_acquire>
	if (!tx) {
     d7e:	4601      	mov	r1, r0
     d80:	2800      	cmp	r0, #0
     d82:	f43f ae37 	beq.w	9f4 <ull_conn_llcp+0x54>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
     d86:	7903      	ldrb	r3, [r0, #4]
     d88:	f043 0303 	orr.w	r3, r3, #3
     d8c:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
     d8e:	2318      	movs	r3, #24
     d90:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
     d92:	2310      	movs	r3, #16
     d94:	71c3      	strb	r3, [r0, #7]
	rsp->interval_min =
     d96:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
     d9a:	8103      	strh	r3, [r0, #8]
	rsp->interval_max =
     d9c:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
     da0:	8143      	strh	r3, [r0, #10]
	rsp->latency =
     da2:	f8b4 30f4 	ldrh.w	r3, [r4, #244]	; 0xf4
     da6:	8183      	strh	r3, [r0, #12]
	rsp->timeout =
     da8:	f8b4 30f6 	ldrh.w	r3, [r4, #246]	; 0xf6
     dac:	81c3      	strh	r3, [r0, #14]
	rsp->preferred_periodicity =
     dae:	f894 30f8 	ldrb.w	r3, [r4, #248]	; 0xf8
     db2:	7403      	strb	r3, [r0, #16]
	rsp->reference_conn_event_count =
     db4:	f8b4 30fa 	ldrh.w	r3, [r4, #250]	; 0xfa
     db8:	f8a0 3011 	strh.w	r3, [r0, #17]
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
     dbc:	f8b4 30fc 	ldrh.w	r3, [r4, #252]	; 0xfc
     dc0:	f8a0 3013 	strh.w	r3, [r0, #19]
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
     dc4:	f8b4 30fe 	ldrh.w	r3, [r4, #254]	; 0xfe
     dc8:	f8a0 3015 	strh.w	r3, [r0, #21]
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
     dcc:	f8b4 3100 	ldrh.w	r3, [r4, #256]	; 0x100
     dd0:	f8a0 3017 	strh.w	r3, [r0, #23]
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
     dd4:	f8b4 3102 	ldrh.w	r3, [r4, #258]	; 0x102
     dd8:	f8a0 3019 	strh.w	r3, [r0, #25]
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
     ddc:	f8b4 3104 	ldrh.w	r3, [r4, #260]	; 0x104
     de0:	f8a0 301b 	strh.w	r3, [r0, #27]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
     de4:	f8b4 3106 	ldrh.w	r3, [r4, #262]	; 0x106
     de8:	f8a0 301d 	strh.w	r3, [r0, #29]
	ctrl_tx_enqueue(conn, tx);
     dec:	4620      	mov	r0, r4
     dee:	f027 fbc6 	bl	2857e <ctrl_tx_enqueue>
	conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
     df2:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
     df6:	f884 30ed 	strb.w	r3, [r4, #237]	; 0xed
	conn_upd_curr = NULL;
     dfa:	602f      	str	r7, [r5, #0]
     dfc:	e5fa      	b.n	9f4 <ull_conn_llcp+0x54>
	rx = ll_pdu_rx_alloc();
     dfe:	f019 fba7 	bl	1a550 <ll_pdu_rx_alloc>
	if (!rx) {
     e02:	4601      	mov	r1, r0
     e04:	2800      	cmp	r0, #0
     e06:	f43f adf5 	beq.w	9f4 <ull_conn_llcp+0x54>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
     e0a:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
     e0e:	2203      	movs	r2, #3
     e10:	f362 0302 	bfi	r3, r2, #0, #3
     e14:	f884 30ee 	strb.w	r3, [r4, #238]	; 0xee
	rx->hdr.handle = conn->lll.handle;
     e18:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
     e1a:	80c3      	strh	r3, [r0, #6]
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
     e1c:	2302      	movs	r3, #2
     e1e:	7103      	strb	r3, [r0, #4]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
     e20:	f890 3020 	ldrb.w	r3, [r0, #32]
     e24:	4313      	orrs	r3, r2
     e26:	f880 3020 	strb.w	r3, [r0, #32]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
     e2a:	2318      	movs	r3, #24
     e2c:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
     e30:	230f      	movs	r3, #15
     e32:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
     e36:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
     e3a:	8483      	strh	r3, [r0, #36]	; 0x24
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
     e3c:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
     e40:	84c3      	strh	r3, [r0, #38]	; 0x26
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
     e42:	f8b4 30f4 	ldrh.w	r3, [r4, #244]	; 0xf4
     e46:	8503      	strh	r3, [r0, #40]	; 0x28
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
     e48:	f8b4 30f6 	ldrh.w	r3, [r4, #246]	; 0xf6
     e4c:	8543      	strh	r3, [r0, #42]	; 0x2a
	ll_rx_put(rx->hdr.link, rx);
     e4e:	e628      	b.n	aa2 <ull_conn_llcp+0x102>
		LL_ASSERT(0);
     e50:	f640 4337 	movw	r3, #3127	; 0xc37
     e54:	e6bb      	b.n	bce <ull_conn_llcp+0x22e>
	conn_upd = conn_upd_curr;
     e56:	4b2f      	ldr	r3, [pc, #188]	; (f14 <ull_conn_llcp+0x574>)
	if (!conn_upd) {
     e58:	681a      	ldr	r2, [r3, #0]
     e5a:	b902      	cbnz	r2, e5e <ull_conn_llcp+0x4be>
		conn_upd_curr = conn;
     e5c:	601c      	str	r4, [r3, #0]
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
     e5e:	8e62      	ldrh	r2, [r4, #50]	; 0x32
     e60:	8ee7      	ldrh	r7, [r4, #54]	; 0x36
     e62:	4417      	add	r7, r2
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
     e64:	f894 20a2 	ldrb.w	r2, [r4, #162]	; 0xa2
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
     e68:	4447      	add	r7, r8
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
     e6a:	f012 0003 	ands.w	r0, r2, #3
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
     e6e:	b2bf      	uxth	r7, r7
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
     e70:	d052      	beq.n	f18 <ull_conn_llcp+0x578>
		rx = ll_pdu_rx_alloc_peek(1);
     e72:	2001      	movs	r0, #1
     e74:	f019 fb54 	bl	1a520 <ll_pdu_rx_alloc_peek>
		if (!rx) {
     e78:	4606      	mov	r6, r0
     e7a:	2800      	cmp	r0, #0
     e7c:	d03d      	beq.n	efa <ull_conn_llcp+0x55a>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
     e7e:	4824      	ldr	r0, [pc, #144]	; (f10 <ull_conn_llcp+0x570>)
     e80:	f027 f900 	bl	28084 <mem_acquire>
		if (!tx) {
     e84:	4605      	mov	r5, r0
     e86:	b3c0      	cbz	r0, efa <ull_conn_llcp+0x55a>
		(void)ll_pdu_rx_alloc();
     e88:	f019 fb62 	bl	1a550 <ll_pdu_rx_alloc>
		rx->hdr.link->mem = conn->llcp_rx;
     e8c:	6833      	ldr	r3, [r6, #0]
     e8e:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
     e92:	605a      	str	r2, [r3, #4]
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
     e94:	f894 30a2 	ldrb.w	r3, [r4, #162]	; 0xa2
		conn->llcp_rx = rx;
     e98:	f8c4 609c 	str.w	r6, [r4, #156]	; 0x9c
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
     e9c:	f36f 0301 	bfc	r3, #0, #2
     ea0:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
     ea4:	8e23      	ldrh	r3, [r4, #48]	; 0x30
     ea6:	441f      	add	r7, r3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
     ea8:	792b      	ldrb	r3, [r5, #4]
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
     eaa:	3706      	adds	r7, #6
     eac:	b2bf      	uxth	r7, r7
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
     eae:	f043 0303 	orr.w	r3, r3, #3
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
     eb2:	f8a4 7090 	strh.w	r7, [r4, #144]	; 0x90
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
     eb6:	712b      	strb	r3, [r5, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
     eb8:	230c      	movs	r3, #12
     eba:	716b      	strb	r3, [r5, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
     ebc:	2300      	movs	r3, #0
     ebe:	71eb      	strb	r3, [r5, #7]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
     ec0:	f894 30b0 	ldrb.w	r3, [r4, #176]	; 0xb0
     ec4:	722b      	strb	r3, [r5, #8]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
     ec6:	f240 42e2 	movw	r2, #1250	; 0x4e2
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us / 1250U);
     eca:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
     ece:	fbb3 f3f2 	udiv	r3, r3, r2
     ed2:	f8a5 3009 	strh.w	r3, [r5, #9]
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
     ed6:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	; 0xa4
     eda:	f8a5 300b 	strh.w	r3, [r5, #11]
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
     ede:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
     ee2:	f8a5 300d 	strh.w	r3, [r5, #13]
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
     ee6:	f8b4 30a8 	ldrh.w	r3, [r4, #168]	; 0xa8
     eea:	f8a5 300f 	strh.w	r3, [r5, #15]
	pdu_ctrl_tx->llctrl.conn_update_ind.instant =
     eee:	f8a5 7011 	strh.w	r7, [r5, #17]
			ctrl_tx_enqueue(conn, tx);
     ef2:	4629      	mov	r1, r5
     ef4:	4620      	mov	r0, r4
     ef6:	f027 fb42 	bl	2857e <ctrl_tx_enqueue>
	if (conn->llcp_terminate.ack != conn->llcp_terminate.req) {
     efa:	f894 20c5 	ldrb.w	r2, [r4, #197]	; 0xc5
     efe:	f894 30c4 	ldrb.w	r3, [r4, #196]	; 0xc4
     f02:	429a      	cmp	r2, r3
     f04:	f040 8210 	bne.w	1328 <ull_conn_llcp+0x988>
	return 0;
     f08:	2000      	movs	r0, #0
}
     f0a:	b00d      	add	sp, #52	; 0x34
     f0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     f10:	20001944 	.word	0x20001944
     f14:	200018c8 	.word	0x200018c8
	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
     f18:	f8b4 9090 	ldrh.w	r9, [r4, #144]	; 0x90
     f1c:	eba7 0209 	sub.w	r2, r7, r9
	} else if (instant_latency <= 0x7FFF) {
     f20:	0415      	lsls	r5, r2, #16
	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
     f22:	fa1f fb82 	uxth.w	fp, r2
	} else if (instant_latency <= 0x7FFF) {
     f26:	d4e8      	bmi.n	efa <ull_conn_llcp+0x55a>
		conn->llcp_cu.ack = conn->llcp_cu.req;
     f28:	f894 20a0 	ldrb.w	r2, [r4, #160]	; 0xa0
     f2c:	f884 20a1 	strb.w	r2, [r4, #161]	; 0xa1
		conn->llcp_ack = conn->llcp_req;
     f30:	f884 108d 	strb.w	r1, [r4, #141]	; 0x8d
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
     f34:	f894 20ed 	ldrb.w	r2, [r4, #237]	; 0xed
     f38:	f894 10ec 	ldrb.w	r1, [r4, #236]	; 0xec
     f3c:	428a      	cmp	r2, r1
     f3e:	d009      	beq.n	f54 <ull_conn_llcp+0x5b4>
		    (conn->llcp_conn_param.state == LLCP_CPR_STATE_UPD)) {
     f40:	f894 20ee 	ldrb.w	r2, [r4, #238]	; 0xee
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
     f44:	f002 0207 	and.w	r2, r2, #7
     f48:	2a05      	cmp	r2, #5
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
     f4a:	bf04      	itt	eq
     f4c:	f884 10ed 	strbeq.w	r1, [r4, #237]	; 0xed
			conn->procedure_expire = 0U;
     f50:	f8a4 007c 	strheq.w	r0, [r4, #124]	; 0x7c
		if (conn_upd_curr == conn) {
     f54:	681a      	ldr	r2, [r3, #0]
		rx = conn->llcp_rx;
     f56:	f8d4 509c 	ldr.w	r5, [r4, #156]	; 0x9c
		if (conn_upd_curr == conn) {
     f5a:	4294      	cmp	r4, r2
			conn_upd_curr = NULL;
     f5c:	bf04      	itt	eq
     f5e:	2200      	moveq	r2, #0
     f60:	601a      	streq	r2, [r3, #0]
		LL_ASSERT(rx && rx->hdr.link);
     f62:	b10d      	cbz	r5, f68 <ull_conn_llcp+0x5c8>
     f64:	682b      	ldr	r3, [r5, #0]
     f66:	b963      	cbnz	r3, f82 <ull_conn_llcp+0x5e2>
     f68:	4abb      	ldr	r2, [pc, #748]	; (1258 <ull_conn_llcp+0x8b8>)
     f6a:	49bc      	ldr	r1, [pc, #752]	; (125c <ull_conn_llcp+0x8bc>)
     f6c:	48bc      	ldr	r0, [pc, #752]	; (1260 <ull_conn_llcp+0x8c0>)
     f6e:	f640 03c3 	movw	r3, #2243	; 0x8c3
     f72:	f022 ffb6 	bl	23ee2 <printk>
     f76:	4040      	eors	r0, r0
     f78:	f380 8811 	msr	BASEPRI, r0
     f7c:	f04f 0003 	mov.w	r0, #3
     f80:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
     f82:	6828      	ldr	r0, [r5, #0]
		if ((conn->llcp_cu.interval != lll->interval) ||
     f84:	f8b4 20a4 	ldrh.w	r2, [r4, #164]	; 0xa4
		conn->llcp_rx = rx->hdr.link->mem;
     f88:	6843      	ldr	r3, [r0, #4]
     f8a:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
		if ((conn->llcp_cu.interval != lll->interval) ||
     f8e:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
     f90:	f8b4 c0a6 	ldrh.w	ip, [r4, #166]	; 0xa6
     f94:	f8b4 10a8 	ldrh.w	r1, [r4, #168]	; 0xa8
     f98:	429a      	cmp	r2, r3
     f9a:	d113      	bne.n	fc4 <ull_conn_llcp+0x624>
     f9c:	8e23      	ldrh	r3, [r4, #48]	; 0x30
     f9e:	4563      	cmp	r3, ip
     fa0:	d110      	bne.n	fc4 <ull_conn_llcp+0x624>
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
     fa2:	f240 43e2 	movw	r3, #1250	; 0x4e2
     fa6:	fb03 fe02 	mul.w	lr, r3, r2
     faa:	f242 7310 	movw	r3, #10000	; 0x2710
     fae:	fb03 e301 	mla	r3, r3, r1, lr
     fb2:	3b01      	subs	r3, #1
     fb4:	fbb3 f3fe 	udiv	r3, r3, lr
		    (conn->llcp_cu.latency != lll->latency) ||
     fb8:	f8b4 e076 	ldrh.w	lr, [r4, #118]	; 0x76
     fbc:	b29b      	uxth	r3, r3
     fbe:	459e      	cmp	lr, r3
     fc0:	f000 8124 	beq.w	120c <ull_conn_llcp+0x86c>
			rx->hdr.handle = lll->handle;
     fc4:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
     fc6:	80eb      	strh	r3, [r5, #6]
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
     fc8:	230a      	movs	r3, #10
     fca:	712b      	strb	r3, [r5, #4]
			cu->status = 0x00;
     fcc:	2300      	movs	r3, #0
     fce:	f885 3020 	strb.w	r3, [r5, #32]
			cu->interval = conn->llcp_cu.interval;
     fd2:	846a      	strh	r2, [r5, #34]	; 0x22
			cu->latency = conn->llcp_cu.latency;
     fd4:	f8a5 c024 	strh.w	ip, [r5, #36]	; 0x24
			cu->timeout = conn->llcp_cu.timeout;
     fd8:	84e9      	strh	r1, [r5, #38]	; 0x26
		ll_rx_put(rx->hdr.link, rx);
     fda:	4629      	mov	r1, r5
     fdc:	f019 fa90 	bl	1a500 <ll_rx_put>
		ll_rx_sched();
     fe0:	f019 fa98 	bl	1a514 <ll_rx_sched>
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
     fe4:	6823      	ldr	r3, [r4, #0]
     fe6:	2b00      	cmp	r3, #0
     fe8:	da09      	bge.n	ffe <ull_conn_llcp+0x65e>
			u32_t ticks_prepare_to_start =
     fea:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
     fee:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
     ff2:	4281      	cmp	r1, r0
     ff4:	bf2c      	ite	cs
     ff6:	1876      	addcs	r6, r6, r1
     ff8:	1836      	addcc	r6, r6, r0
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
     ffa:	6023      	str	r3, [r4, #0]
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
     ffc:	1af6      	subs	r6, r6, r3
		conn_interval_old = instant_latency * lll->interval;
     ffe:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
		latency = conn_interval_old / conn->llcp_cu.interval;
    1000:	f8b4 50a4 	ldrh.w	r5, [r4, #164]	; 0xa4
    1004:	f8df a27c 	ldr.w	sl, [pc, #636]	; 1284 <ull_conn_llcp+0x8e4>
		conn_interval_old = instant_latency * lll->interval;
    1008:	fb13 f30b 	smulbb	r3, r3, fp
    100c:	b29b      	uxth	r3, r3
		latency = conn_interval_old / conn->llcp_cu.interval;
    100e:	fbb3 f1f5 	udiv	r1, r3, r5
    1012:	b28a      	uxth	r2, r1
    1014:	920a      	str	r2, [sp, #40]	; 0x28
		conn_interval_new = latency * conn->llcp_cu.interval;
    1016:	fb15 f201 	smulbb	r2, r5, r1
    101a:	b292      	uxth	r2, r2
		if (conn_interval_new > conn_interval_old) {
    101c:	4293      	cmp	r3, r2
    101e:	f240 40e2 	movw	r0, #1250	; 0x4e2
    1022:	f080 80f6 	bcs.w	1212 <ull_conn_llcp+0x872>
			ticks_at_expire += HAL_TICKER_US_TO_TICKS(
    1026:	1ad3      	subs	r3, r2, r3
    1028:	4358      	muls	r0, r3
    102a:	fba0 010a 	umull	r0, r1, r0, sl
    102e:	a388      	add	r3, pc, #544	; (adr r3, 1250 <ull_conn_llcp+0x8b0>)
    1030:	e9d3 2300 	ldrd	r2, r3, [r3]
    1034:	f7ff f8b4 	bl	1a0 <__aeabi_uldivmod>
    1038:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    103c:	4406      	add	r6, r0
		lll->latency_prepare -= (instant_latency - latency);
    103e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
		lll->latency_prepare += lazy;
    1040:	8e62      	ldrh	r2, [r4, #50]	; 0x32
		lll->latency_prepare -= (instant_latency - latency);
    1042:	eba9 0707 	sub.w	r7, r9, r7
    1046:	441f      	add	r7, r3
		} else if (lll->role) {
    1048:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
		lll->latency_prepare += lazy;
    104c:	4490      	add	r8, r2
		lll->latency_prepare -= (instant_latency - latency);
    104e:	4447      	add	r7, r8
		} else if (lll->role) {
    1050:	2b00      	cmp	r3, #0
		conn_interval_us = conn->llcp_cu.interval * 1250U;
    1052:	f240 48e2 	movw	r8, #1250	; 0x4e2
		lll->latency_prepare -= (instant_latency - latency);
    1056:	8667      	strh	r7, [r4, #50]	; 0x32
		conn_interval_us = conn->llcp_cu.interval * 1250U;
    1058:	fb08 f505 	mul.w	r5, r8, r5
		} else if (lll->role) {
    105c:	f280 80e6 	bge.w	122c <ull_conn_llcp+0x88c>
			lll->slave.window_widening_prepare_us -=
    1060:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				lll->slave.window_widening_periodic_us *
    1062:	6c63      	ldr	r3, [r4, #68]	; 0x44
			lll->slave.window_widening_prepare_us -=
    1064:	fb03 231b 	mls	r3, r3, fp, r2
    1068:	64e3      	str	r3, [r4, #76]	; 0x4c
				(((lll_conn_ppm_local_get() +
    106a:	f027 fcc9 	bl	28a00 <lll_conn_ppm_local_get>
    106e:	4607      	mov	r7, r0
				   lll_conn_ppm_get(conn->slave.sca)) *
    1070:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
    1074:	f3c0 0082 	ubfx	r0, r0, #2, #3
    1078:	f01c fe3e 	bl	1dcf8 <lll_conn_ppm_get>
				conn->llcp_cu.win_size * 1250U;
    107c:	f894 20b0 	ldrb.w	r2, [r4, #176]	; 0xb0
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    1080:	4b78      	ldr	r3, [pc, #480]	; (1264 <ull_conn_llcp+0x8c4>)
				conn->llcp_cu.win_size * 1250U;
    1082:	fb08 f202 	mul.w	r2, r8, r2
				(((lll_conn_ppm_local_get() +
    1086:	4407      	add	r7, r0
			lll->slave.window_size_prepare_us =
    1088:	6562      	str	r2, [r4, #84]	; 0x54
				lll->slave.window_widening_periodic_us *
    108a:	980a      	ldr	r0, [sp, #40]	; 0x28
			conn->slave.ticks_to_offset = 0U;
    108c:	2200      	movs	r2, #0
				   lll_conn_ppm_get(conn->slave.sca)) *
    108e:	436f      	muls	r7, r5
			conn->slave.ticks_to_offset = 0U;
    1090:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    1094:	f507 2774 	add.w	r7, r7, #999424	; 0xf4000
			lll->slave.window_widening_prepare_us +=
    1098:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    109a:	f207 273f 	addw	r7, r7, #575	; 0x23f
    109e:	fbb7 f7f3 	udiv	r7, r7, r3
				(conn_interval_us >> 1) - EVENT_IFS_US;
    10a2:	086b      	lsrs	r3, r5, #1
				lll->slave.window_widening_periodic_us *
    10a4:	4378      	muls	r0, r7
				(conn_interval_us >> 1) - EVENT_IFS_US;
    10a6:	3b96      	subs	r3, #150	; 0x96
			lll->slave.window_widening_prepare_us +=
    10a8:	4402      	add	r2, r0
			lll->slave.window_widening_max_us =
    10aa:	64a3      	str	r3, [r4, #72]	; 0x48
			lll->slave.window_widening_prepare_us +=
    10ac:	429a      	cmp	r2, r3
    10ae:	bf94      	ite	ls
    10b0:	64e2      	strls	r2, [r4, #76]	; 0x4c
    10b2:	64e3      	strhi	r3, [r4, #76]	; 0x4c
			lll->slave.window_widening_periodic_us =
    10b4:	6467      	str	r7, [r4, #68]	; 0x44
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    10b6:	a366      	add	r3, pc, #408	; (adr r3, 1250 <ull_conn_llcp+0x8b0>)
    10b8:	e9d3 2300 	ldrd	r2, r3, [r3]
    10bc:	fba0 010a 	umull	r0, r1, r0, sl
    10c0:	f7ff f86e 	bl	1a0 <__aeabi_uldivmod>
    10c4:	1a36      	subs	r6, r6, r0
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    10c6:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
    10ca:	fbb0 f0f8 	udiv	r0, r0, r8
    10ce:	fb08 f000 	mul.w	r0, r8, r0
    10d2:	a35f      	add	r3, pc, #380	; (adr r3, 1250 <ull_conn_llcp+0x8b0>)
    10d4:	e9d3 2300 	ldrd	r2, r3, [r3]
    10d8:	fba0 010a 	umull	r0, r1, r0, sl
    10dc:	f7ff f860 	bl	1a0 <__aeabi_uldivmod>
			periodic_us -= lll->slave.window_widening_periodic_us;
    10e0:	eba5 0907 	sub.w	r9, r5, r7
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    10e4:	f020 487f 	bic.w	r8, r0, #4278190080	; 0xff000000
		lll->interval = conn->llcp_cu.interval;
    10e8:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	; 0xa4
    10ec:	85e3      	strh	r3, [r4, #46]	; 0x2e
		lll->latency = conn->llcp_cu.latency;
    10ee:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
    10f2:	8623      	strh	r3, [r4, #48]	; 0x30
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    10f4:	f8b4 30a8 	ldrh.w	r3, [r4, #168]	; 0xa8
    10f8:	f242 7210 	movw	r2, #10000	; 0x2710
    10fc:	fb02 5303 	mla	r3, r2, r3, r5
    1100:	3b01      	subs	r3, #1
    1102:	fbb3 f3f5 	udiv	r3, r3, r5
    1106:	f8a4 3076 	strh.w	r3, [r4, #118]	; 0x76
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    110a:	4b57      	ldr	r3, [pc, #348]	; (1268 <ull_conn_llcp+0x8c8>)
    110c:	442b      	add	r3, r5
    110e:	fbb3 f5f5 	udiv	r5, r3, r5
		if (conn->llcp_cu.cmd) {
    1112:	f894 30a2 	ldrb.w	r3, [r4, #162]	; 0xa2
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    1116:	f8a4 507a 	strh.w	r5, [r4, #122]	; 0x7a
		if (conn->llcp_cu.cmd) {
    111a:	075a      	lsls	r2, r3, #29
			conn->supervision_expire = 0U;
    111c:	bf44      	itt	mi
    111e:	2300      	movmi	r3, #0
    1120:	f8a4 3078 	strhmi.w	r3, [r4, #120]	; 0x78
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    1124:	2102      	movs	r1, #2
    1126:	2001      	movs	r0, #1
    1128:	f01d fcca 	bl	1eac0 <mayfly_is_enabled>
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    112c:	2200      	movs	r2, #0
    112e:	2102      	movs	r1, #2
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    1130:	4607      	mov	r7, r0
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    1132:	2001      	movs	r0, #1
    1134:	f016 ffd2 	bl	180dc <mayfly_enable>
		ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    1138:	4620      	mov	r0, r4
    113a:	f01a fa4d 	bl	1b5d8 <ll_conn_handle_get>
    113e:	1d45      	adds	r5, r0, #5
    1140:	b2ed      	uxtb	r5, r5
		ticker_status =	ticker_stop(TICKER_INSTANCE_ID_CTLR,
    1142:	4b4a      	ldr	r3, [pc, #296]	; (126c <ull_conn_llcp+0x8cc>)
    1144:	9400      	str	r4, [sp, #0]
    1146:	462a      	mov	r2, r5
    1148:	2101      	movs	r1, #1
    114a:	2000      	movs	r0, #0
    114c:	f017 fe18 	bl	18d80 <ticker_stop>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    1150:	f030 0302 	bics.w	r3, r0, #2
    1154:	d00c      	beq.n	1170 <ull_conn_llcp+0x7d0>
    1156:	4a40      	ldr	r2, [pc, #256]	; (1258 <ull_conn_llcp+0x8b8>)
    1158:	4945      	ldr	r1, [pc, #276]	; (1270 <ull_conn_llcp+0x8d0>)
    115a:	4841      	ldr	r0, [pc, #260]	; (1260 <ull_conn_llcp+0x8c0>)
    115c:	f640 1367 	movw	r3, #2407	; 0x967
    1160:	f022 febf 	bl	23ee2 <printk>
    1164:	4040      	eors	r0, r0
    1166:	f380 8811 	msr	BASEPRI, r0
    116a:	f04f 0003 	mov.w	r0, #3
    116e:	df02      	svc	2
				     HAL_TICKER_US_TO_TICKS(periodic_us),
    1170:	fba9 230a 	umull	r2, r3, r9, sl
    1174:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    1178:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    117c:	a334      	add	r3, pc, #208	; (adr r3, 1250 <ull_conn_llcp+0x8b0>)
    117e:	e9d3 2300 	ldrd	r2, r3, [r3]
    1182:	f7ff f80d 	bl	1a0 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    1186:	4b3b      	ldr	r3, [pc, #236]	; (1274 <ull_conn_llcp+0x8d4>)
    1188:	9408      	str	r4, [sp, #32]
    118a:	e9cd 4306 	strd	r4, r3, [sp, #24]
    118e:	4b3a      	ldr	r3, [pc, #232]	; (1278 <ull_conn_llcp+0x8d8>)
    1190:	9305      	str	r3, [sp, #20]
    1192:	68e3      	ldr	r3, [r4, #12]
    1194:	9304      	str	r3, [sp, #16]
				     HAL_TICKER_REMAINDER(periodic_us),
    1196:	4b39      	ldr	r3, [pc, #228]	; (127c <ull_conn_llcp+0x8dc>)
    1198:	990a      	ldr	r1, [sp, #40]	; 0x28
    119a:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
    119e:	fba4 ab03 	umull	sl, fp, r4, r3
    11a2:	ebb1 000a 	subs.w	r0, r1, sl
    11a6:	f04f 0307 	mov.w	r3, #7
    11aa:	990b      	ldr	r1, [sp, #44]	; 0x2c
    11ac:	fb03 bb04 	mla	fp, r3, r4, fp
    11b0:	eb61 010b 	sbc.w	r1, r1, fp
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    11b4:	f04f 0900 	mov.w	r9, #0
				     HAL_TICKER_REMAINDER(periodic_us),
    11b8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    11bc:	2300      	movs	r3, #0
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    11be:	f8cd 900c 	str.w	r9, [sp, #12]
				     HAL_TICKER_REMAINDER(periodic_us),
    11c2:	f7fe ffed 	bl	1a0 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    11c6:	4633      	mov	r3, r6
    11c8:	e9cd 4001 	strd	r4, r0, [sp, #4]
    11cc:	f8cd 8000 	str.w	r8, [sp]
    11d0:	462a      	mov	r2, r5
    11d2:	2101      	movs	r1, #1
    11d4:	4648      	mov	r0, r9
    11d6:	f017 fd43 	bl	18c60 <ticker_start>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    11da:	f030 0302 	bics.w	r3, r0, #2
    11de:	d00c      	beq.n	11fa <ull_conn_llcp+0x85a>
    11e0:	4a1d      	ldr	r2, [pc, #116]	; (1258 <ull_conn_llcp+0x8b8>)
    11e2:	4923      	ldr	r1, [pc, #140]	; (1270 <ull_conn_llcp+0x8d0>)
    11e4:	481e      	ldr	r0, [pc, #120]	; (1260 <ull_conn_llcp+0x8c0>)
    11e6:	f640 1381 	movw	r3, #2433	; 0x981
    11ea:	f022 fe7a 	bl	23ee2 <printk>
    11ee:	4040      	eors	r0, r0
    11f0:	f380 8811 	msr	BASEPRI, r0
    11f4:	f04f 0003 	mov.w	r0, #3
    11f8:	df02      	svc	2
		if (mayfly_was_enabled) {
    11fa:	b127      	cbz	r7, 1206 <ull_conn_llcp+0x866>
			mayfly_enable(TICKER_USER_ID_ULL_HIGH,
    11fc:	2201      	movs	r2, #1
    11fe:	2102      	movs	r1, #2
    1200:	4610      	mov	r0, r2
    1202:	f016 ff6b 	bl	180dc <mayfly_enable>
				return -ECANCELED;
    1206:	f06f 0047 	mvn.w	r0, #71	; 0x47
    120a:	e67e      	b.n	f0a <ull_conn_llcp+0x56a>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    120c:	2303      	movs	r3, #3
    120e:	712b      	strb	r3, [r5, #4]
    1210:	e6e3      	b.n	fda <ull_conn_llcp+0x63a>
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    1212:	fb05 3111 	mls	r1, r5, r1, r3
    1216:	b289      	uxth	r1, r1
    1218:	4348      	muls	r0, r1
    121a:	a30d      	add	r3, pc, #52	; (adr r3, 1250 <ull_conn_llcp+0x8b0>)
    121c:	e9d3 2300 	ldrd	r2, r3, [r3]
    1220:	fba0 010a 	umull	r0, r1, r0, sl
    1224:	f7fe ffbc 	bl	1a0 <__aeabi_uldivmod>
    1228:	1a36      	subs	r6, r6, r0
    122a:	e708      	b.n	103e <ull_conn_llcp+0x69e>
			LL_ASSERT(0);
    122c:	4a0a      	ldr	r2, [pc, #40]	; (1258 <ull_conn_llcp+0x8b8>)
    122e:	4914      	ldr	r1, [pc, #80]	; (1280 <ull_conn_llcp+0x8e0>)
    1230:	480b      	ldr	r0, [pc, #44]	; (1260 <ull_conn_llcp+0x8c0>)
    1232:	f640 1338 	movw	r3, #2360	; 0x938
    1236:	f022 fe54 	bl	23ee2 <printk>
    123a:	4040      	eors	r0, r0
    123c:	f380 8811 	msr	BASEPRI, r0
    1240:	f04f 0003 	mov.w	r0, #3
    1244:	df02      	svc	2
		u32_t ticks_win_offset = 0;
    1246:	f04f 0800 	mov.w	r8, #0
		periodic_us = conn_interval_us;
    124a:	46a9      	mov	r9, r5
    124c:	e74c      	b.n	10e8 <ull_conn_llcp+0x748>
    124e:	bf00      	nop
    1250:	1afd498d 	.word	0x1afd498d
    1254:	00000007 	.word	0x00000007
    1258:	00030625 	.word	0x00030625
    125c:	0003076d 	.word	0x0003076d
    1260:	0002a5e8 	.word	0x0002a5e8
    1264:	000f4240 	.word	0x000f4240
    1268:	026259ff 	.word	0x026259ff
    126c:	0001b481 	.word	0x0001b481
    1270:	000306db 	.word	0x000306db
    1274:	0001b429 	.word	0x0001b429
    1278:	0001c8c9 	.word	0x0001c8c9
    127c:	1afd498d 	.word	0x1afd498d
    1280:	0002e3c9 	.word	0x0002e3c9
    1284:	3b9aca00 	.word	0x3b9aca00
			event_counter = lll->event_counter +
    1288:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    128a:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
    128c:	441a      	add	r2, r3
	if (conn->llcp.chan_map.initiate) {
    128e:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
					lll->latency_prepare + lazy;
    1292:	4490      	add	r8, r2
	if (conn->llcp.chan_map.initiate) {
    1294:	07db      	lsls	r3, r3, #31
			event_counter = lll->event_counter +
    1296:	fa1f f888 	uxth.w	r8, r8
	if (conn->llcp.chan_map.initiate) {
    129a:	d525      	bpl.n	12e8 <ull_conn_llcp+0x948>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    129c:	4835      	ldr	r0, [pc, #212]	; (1374 <ull_conn_llcp+0x9d4>)
    129e:	f026 fef1 	bl	28084 <mem_acquire>
		if (tx) {
    12a2:	4605      	mov	r5, r0
    12a4:	2800      	cmp	r0, #0
    12a6:	f43f ae28 	beq.w	efa <ull_conn_llcp+0x55a>
			conn->llcp.chan_map.initiate = 0U;
    12aa:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
    12ae:	f36f 0300 	bfc	r3, #0, #1
    12b2:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
			conn->llcp.chan_map.instant = event_counter +
    12b6:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    12b8:	4498      	add	r8, r3
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    12ba:	7903      	ldrb	r3, [r0, #4]
						      conn->lll.latency + 6;
    12bc:	f108 0806 	add.w	r8, r8, #6
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    12c0:	f043 0303 	orr.w	r3, r3, #3
			conn->llcp.chan_map.instant = event_counter +
    12c4:	f8a4 8096 	strh.w	r8, [r4, #150]	; 0x96
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    12c8:	7103      	strb	r3, [r0, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
    12ca:	2308      	movs	r3, #8
    12cc:	7143      	strb	r3, [r0, #5]
			pdu_ctrl_tx->llctrl.opcode =
    12ce:	2301      	movs	r3, #1
    12d0:	71c3      	strb	r3, [r0, #7]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
    12d2:	2205      	movs	r2, #5
    12d4:	f104 0191 	add.w	r1, r4, #145	; 0x91
    12d8:	3008      	adds	r0, #8
    12da:	f024 fce5 	bl	25ca8 <memcpy>
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
    12de:	f8b4 3096 	ldrh.w	r3, [r4, #150]	; 0x96
    12e2:	f8a5 300d 	strh.w	r3, [r5, #13]
    12e6:	e604      	b.n	ef2 <ull_conn_llcp+0x552>
	} else if (((event_counter - conn->llcp.chan_map.instant) & 0xFFFF)
    12e8:	f8b4 3096 	ldrh.w	r3, [r4, #150]	; 0x96
    12ec:	eba8 0803 	sub.w	r8, r8, r3
    12f0:	f418 4f00 	tst.w	r8, #32768	; 0x8000
    12f4:	f47f ae01 	bne.w	efa <ull_conn_llcp+0x55a>
		memcpy(&lll->data_chan_map[0],
    12f8:	f104 0538 	add.w	r5, r4, #56	; 0x38
		conn->llcp_ack = conn->llcp_req;
    12fc:	f884 108d 	strb.w	r1, [r4, #141]	; 0x8d
		memcpy(&lll->data_chan_map[0],
    1300:	2205      	movs	r2, #5
    1302:	f104 0191 	add.w	r1, r4, #145	; 0x91
    1306:	4628      	mov	r0, r5
    1308:	f024 fcce 	bl	25ca8 <memcpy>
			util_ones_count_get(&lll->data_chan_map[0],
    130c:	2105      	movs	r1, #5
    130e:	4628      	mov	r0, r5
    1310:	f026 ff34 	bl	2817c <util_ones_count_get>
		lll->data_chan_count =
    1314:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
    1318:	f360 0305 	bfi	r3, r0, #0, #6
    131c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
		conn->chm_updated = 1U;
    1320:	2301      	movs	r3, #1
    1322:	f884 3128 	strb.w	r3, [r4, #296]	; 0x128
    1326:	e5e8      	b.n	efa <ull_conn_llcp+0x55a>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1328:	4812      	ldr	r0, [pc, #72]	; (1374 <ull_conn_llcp+0x9d4>)
    132a:	f026 feab 	bl	28084 <mem_acquire>
		if (tx) {
    132e:	4601      	mov	r1, r0
    1330:	b180      	cbz	r0, 1354 <ull_conn_llcp+0x9b4>
			conn->llcp_terminate.ack = conn->llcp_terminate.req;
    1332:	f894 30c4 	ldrb.w	r3, [r4, #196]	; 0xc4
    1336:	f884 30c5 	strb.w	r3, [r4, #197]	; 0xc5
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
    133a:	7903      	ldrb	r3, [r0, #4]
    133c:	f043 0303 	orr.w	r3, r3, #3
    1340:	7103      	strb	r3, [r0, #4]
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
    1342:	2302      	movs	r3, #2
    1344:	7143      	strb	r3, [r0, #5]
			pdu_tx->llctrl.opcode =
    1346:	71c3      	strb	r3, [r0, #7]
			pdu_tx->llctrl.terminate_ind.error_code =
    1348:	f894 30c6 	ldrb.w	r3, [r4, #198]	; 0xc6
    134c:	7203      	strb	r3, [r0, #8]
			ctrl_tx_enqueue(conn, tx);
    134e:	4620      	mov	r0, r4
    1350:	f027 f915 	bl	2857e <ctrl_tx_enqueue>
		if (!conn->procedure_expire) {
    1354:	f8b4 007c 	ldrh.w	r0, [r4, #124]	; 0x7c
    1358:	2800      	cmp	r0, #0
    135a:	f47f add5 	bne.w	f08 <ull_conn_llcp+0x568>
			conn->procedure_expire = conn->supervision_reload;
    135e:	f8b4 3076 	ldrh.w	r3, [r4, #118]	; 0x76
			if (conn->procedure_expire <= 1U) {
    1362:	2b01      	cmp	r3, #1
    1364:	d902      	bls.n	136c <ull_conn_llcp+0x9cc>
			conn->procedure_expire = conn->supervision_reload;
    1366:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
    136a:	e5cd      	b.n	f08 <ull_conn_llcp+0x568>
				conn->procedure_expire++;
    136c:	3301      	adds	r3, #1
    136e:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
    1372:	e5ca      	b.n	f0a <ull_conn_llcp+0x56a>
    1374:	20001944 	.word	0x20001944

00001378 <ull_slave_setup>:
static void ticker_op_stop_adv_cb(u32_t status, void *param);
static void ticker_op_cb(u32_t status, void *param);

void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx,
		     struct node_rx_ftr *ftr, struct lll_conn *lll)
{
    1378:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    137c:	b091      	sub	sp, #68	; 0x44
    137e:	461c      	mov	r4, r3
    1380:	900b      	str	r0, [sp, #44]	; 0x2c
	u16_t win_offset;
	u16_t timeout;
	u16_t interval;
	u8_t chan_sel;

	((struct lll_adv *)ftr->param)->conn = NULL;
    1382:	6813      	ldr	r3, [r2, #0]

	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
	conn = lll->hdr.parent;
    1384:	4620      	mov	r0, r4
	((struct lll_adv *)ftr->param)->conn = NULL;
    1386:	2700      	movs	r7, #0
{
    1388:	4689      	mov	r9, r1
	conn = lll->hdr.parent;
    138a:	f850 5b0c 	ldr.w	r5, [r0], #12
	((struct lll_adv *)ftr->param)->conn = NULL;
    138e:	609f      	str	r7, [r3, #8]
{
    1390:	4690      	mov	r8, r2

	/* Populate the slave context */
	pdu_adv = (void *)((struct node_rx_pdu *)rx)->pdu;
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
    1392:	f104 0b08 	add.w	fp, r4, #8
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
    1396:	2203      	movs	r2, #3
    1398:	3132      	adds	r1, #50	; 0x32
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
    139a:	f8d3 a000 	ldr.w	sl, [r3]
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
    139e:	f104 061c 	add.w	r6, r4, #28
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
    13a2:	f024 fc81 	bl	25ca8 <memcpy>
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
    13a6:	f109 012e 	add.w	r1, r9, #46	; 0x2e
    13aa:	2204      	movs	r2, #4
    13ac:	4658      	mov	r0, fp
    13ae:	f024 fc7b 	bl	25ca8 <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
    13b2:	2205      	movs	r2, #5
    13b4:	f109 013e 	add.w	r1, r9, #62	; 0x3e
    13b8:	4630      	mov	r0, r6
    13ba:	f024 fc75 	bl	25ca8 <memcpy>
	       sizeof(lll->data_chan_map));
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
    13be:	2105      	movs	r1, #5
    13c0:	4630      	mov	r0, r6
    13c2:	f026 fedb 	bl	2817c <util_ones_count_get>
    13c6:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    13ca:	f360 0305 	bfi	r3, r0, #0, #6
    13ce:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
			       sizeof(lll->data_chan_map));
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
    13d2:	f899 3043 	ldrb.w	r3, [r9, #67]	; 0x43
    13d6:	f3c3 0304 	ubfx	r3, r3, #0, #5
    13da:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
    13de:	f8b9 6038 	ldrh.w	r6, [r9, #56]	; 0x38
	lll->interval = interval;
    13e2:	8266      	strh	r6, [r4, #18]
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
    13e4:	f899 203b 	ldrb.w	r2, [r9, #59]	; 0x3b
    13e8:	f899 303a 	ldrb.w	r3, [r9, #58]	; 0x3a
    13ec:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    13f0:	82a3      	strh	r3, [r4, #20]

	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
    13f2:	f8b9 3036 	ldrh.w	r3, [r9, #54]	; 0x36
    13f6:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
	conn_interval_us = interval * 1250U;
    13fa:	f240 43e2 	movw	r3, #1250	; 0x4e2
    13fe:	435e      	muls	r6, r3

	/* calculate the window widening */
	conn->slave.sca = pdu_adv->connect_ind.sca;
    1400:	f899 3043 	ldrb.w	r3, [r9, #67]	; 0x43
    1404:	f895 2080 	ldrb.w	r2, [r5, #128]	; 0x80
    1408:	095b      	lsrs	r3, r3, #5
    140a:	f363 0284 	bfi	r2, r3, #2, #3
    140e:	f885 2080 	strb.w	r2, [r5, #128]	; 0x80
	lll->slave.window_widening_periodic_us =
		(((lll_conn_ppm_local_get() +
    1412:	f027 faf5 	bl	28a00 <lll_conn_ppm_local_get>
    1416:	900d      	str	r0, [sp, #52]	; 0x34
		   lll_conn_ppm_get(conn->slave.sca)) *
    1418:	f895 0080 	ldrb.w	r0, [r5, #128]	; 0x80
    141c:	f3c0 0082 	ubfx	r0, r0, #2, #3
    1420:	f01c fc6a 	bl	1dcf8 <lll_conn_ppm_get>
		(((lll_conn_ppm_local_get() +
    1424:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1426:	4418      	add	r0, r3
		   lll_conn_ppm_get(conn->slave.sca)) *
    1428:	4370      	muls	r0, r6
		  conn_interval_us) + (1000000 - 1)) / 1000000U;
    142a:	f500 2074 	add.w	r0, r0, #999424	; 0xf4000
    142e:	4b7e      	ldr	r3, [pc, #504]	; (1628 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2a0>)
    1430:	f200 203f 	addw	r0, r0, #575	; 0x23f
    1434:	fbb0 f0f3 	udiv	r0, r0, r3
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
    1438:	0873      	lsrs	r3, r6, #1
    143a:	3b96      	subs	r3, #150	; 0x96
    143c:	62e3      	str	r3, [r4, #44]	; 0x2c
					    EVENT_IFS_US;
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
    143e:	f899 3035 	ldrb.w	r3, [r9, #53]	; 0x35
	lll->slave.window_widening_periodic_us =
    1442:	62a0      	str	r0, [r4, #40]	; 0x28
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
    1444:	f240 42e2 	movw	r2, #1250	; 0x4e2
    1448:	4353      	muls	r3, r2
    144a:	63e3      	str	r3, [r4, #60]	; 0x3c

	/* procedure timeouts */
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
    144c:	f8b9 303c 	ldrh.w	r3, [r9, #60]	; 0x3c
	conn->supervision_reload =
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
    1450:	930d      	str	r3, [sp, #52]	; 0x34
    1452:	f242 7210 	movw	r2, #10000	; 0x2710
    1456:	fb02 6203 	mla	r2, r2, r3, r6
    145a:	3a01      	subs	r2, #1
    145c:	fbb2 f2f6 	udiv	r2, r2, r6
    1460:	f8a5 2076 	strh.w	r2, [r5, #118]	; 0x76
	conn->procedure_reload =
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    1464:	4a71      	ldr	r2, [pc, #452]	; (162c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2a4>)
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
			     (conn->apto_reload - (lll->latency + 6)) :
			     conn->apto_reload;
#endif /* CONFIG_BT_CTLR_LE_PING */

	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
    1466:	4659      	mov	r1, fp
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    1468:	4432      	add	r2, r6
	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
    146a:	f105 0084 	add.w	r0, r5, #132	; 0x84
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    146e:	fbb2 f2f6 	udiv	r2, r2, r6
    1472:	f8a5 207a 	strh.w	r2, [r5, #122]	; 0x7a
	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
    1476:	2204      	movs	r2, #4
    1478:	f024 fc16 	bl	25ca8 <memcpy>
	u8_t rl_idx = ftr->rl_idx;

	memcpy(own_addr, &pdu_adv->connect_ind.adv_addr[0], BDADDR_SIZE);
#endif

	peer_addr_type = pdu_adv->tx_addr;
    147c:	f899 b020 	ldrb.w	fp, [r9, #32]
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    1480:	f109 0122 	add.w	r1, r9, #34	; 0x22
    1484:	2206      	movs	r2, #6
    1486:	a80e      	add	r0, sp, #56	; 0x38
    1488:	f024 fc0e 	bl	25ca8 <memcpy>
	peer_addr_type = pdu_adv->tx_addr;
    148c:	f3cb 1b80 	ubfx	fp, fp, #6, #1

	chan_sel = pdu_adv->chan_sel;

	cc = (void *)pdu_adv;
	cc->status = 0U;
    1490:	f44f 7280 	mov.w	r2, #256	; 0x100
    1494:	f8a9 2020 	strh.w	r2, [r9, #32]
	} else {
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
#else
	if (1) {
#endif /* CONFIG_BT_CTLR_PRIVACY */
		cc->peer_addr_type = peer_addr_type;
    1498:	f889 b022 	strb.w	fp, [r9, #34]	; 0x22
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
    149c:	a90e      	add	r1, sp, #56	; 0x38
    149e:	2206      	movs	r2, #6
    14a0:	f109 0023 	add.w	r0, r9, #35	; 0x23
    14a4:	f024 fc00 	bl	25ca8 <memcpy>
	}

	cc->interval = lll->interval;
    14a8:	8a62      	ldrh	r2, [r4, #18]
	cc->latency = lll->latency;
	cc->timeout = timeout;
    14aa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	cc->interval = lll->interval;
    14ac:	f8a9 202a 	strh.w	r2, [r9, #42]	; 0x2a
	cc->latency = lll->latency;
    14b0:	8aa2      	ldrh	r2, [r4, #20]
	cc->timeout = timeout;
    14b2:	f8a9 302e 	strh.w	r3, [r9, #46]	; 0x2e
	cc->sca = conn->slave.sca;
    14b6:	f895 3080 	ldrb.w	r3, [r5, #128]	; 0x80
	cc->latency = lll->latency;
    14ba:	f8a9 202c 	strh.w	r2, [r9, #44]	; 0x2c
	cc->sca = conn->slave.sca;
    14be:	f3c3 0382 	ubfx	r3, r3, #2, #3
    14c2:	f889 3030 	strb.w	r3, [r9, #48]	; 0x30

	lll->handle = ll_conn_handle_get(conn);
    14c6:	4628      	mov	r0, r5
    14c8:	f01a f886 	bl	1b5d8 <ll_conn_handle_get>
		} else {
			cs->csa = 0x00;
		}
	}

	ll_rx_put(link, rx);
    14cc:	4649      	mov	r1, r9
	lll->handle = ll_conn_handle_get(conn);
    14ce:	8220      	strh	r0, [r4, #16]
	rx->handle = lll->handle;
    14d0:	f8a9 0006 	strh.w	r0, [r9, #6]
	ll_rx_put(link, rx);
    14d4:	980b      	ldr	r0, [sp, #44]	; 0x2c
	conn->evt.ticks_xtal_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	conn->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	conn->evt.ticks_slot =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    14d6:	f8df 9174 	ldr.w	r9, [pc, #372]	; 164c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2c4>
	ll_rx_put(link, rx);
    14da:	f019 f811 	bl	1a500 <ll_rx_put>
	ll_rx_sched();
    14de:	f019 f819 	bl	1a514 <ll_rx_sched>
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    14e2:	f8d8 b010 	ldr.w	fp, [r8, #16]
	conn->evt.ticks_active_to_start = 0U;
    14e6:	606f      	str	r7, [r5, #4]
	conn->evt.ticks_xtal_to_start =
    14e8:	2331      	movs	r3, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    14ea:	f20b 4052 	addw	r0, fp, #1106	; 0x452
	conn->evt.ticks_xtal_to_start =
    14ee:	602b      	str	r3, [r5, #0]
	conn->evt.ticks_preempt_to_start =
    14f0:	60af      	str	r7, [r5, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    14f2:	a34b      	add	r3, pc, #300	; (adr r3, 1620 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x298>)
    14f4:	e9d3 2300 	ldrd	r2, r3, [r3]
    14f8:	fba0 0109 	umull	r0, r1, r0, r9
    14fc:	f7fe fe50 	bl	1a0 <__aeabi_uldivmod>
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	conn_interval_us -= lll->slave.window_widening_periodic_us;
    1500:	6aa3      	ldr	r3, [r4, #40]	; 0x28

	conn_offset_us = ftr->us_radio_end;
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    1502:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
	conn_interval_us -= lll->slave.window_widening_periodic_us;
    1506:	1af6      	subs	r6, r6, r3
    1508:	f8d8 300c 	ldr.w	r3, [r8, #12]
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    150c:	4611      	mov	r1, r2
    150e:	f5a3 73ae 	sub.w	r3, r3, #348	; 0x15c
    1512:	f240 42e2 	movw	r2, #1250	; 0x4e2
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    1516:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    151a:	eba3 030b 	sub.w	r3, r3, fp
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    151e:	fb02 2b01 	mla	fp, r2, r1, r2
	conn_offset_us -= EVENT_OVERHEAD_START_US;
	conn_offset_us -= EVENT_TICKER_RES_MARGIN_US;
	conn_offset_us -= EVENT_JITTER_US;
	conn_offset_us -= ftr->us_radio_rdy;
    1522:	445b      	add	r3, fp

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* disable ticker job, in order to chain stop and start to avoid RTC
	 * being stopped if no tickers active.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    1524:	463a      	mov	r2, r7
    1526:	2102      	movs	r1, #2
	conn->evt.ticks_slot =
    1528:	60e8      	str	r0, [r5, #12]
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    152a:	2001      	movs	r0, #1
	conn_offset_us -= ftr->us_radio_rdy;
    152c:	930b      	str	r3, [sp, #44]	; 0x2c
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    152e:	f016 fdd5 	bl	180dc <mayfly_enable>
#endif

	/* Stop Advertiser */
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
    1532:	4650      	mov	r0, sl
    1534:	f019 fd94 	bl	1b060 <ull_adv_handle_get>
    1538:	1c82      	adds	r2, r0, #2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    153a:	4b3d      	ldr	r3, [pc, #244]	; (1630 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2a8>)
    153c:	f8cd a000 	str.w	sl, [sp]
    1540:	b2d2      	uxtb	r2, r2
    1542:	2101      	movs	r1, #1
    1544:	4638      	mov	r0, r7
    1546:	f017 fc1b 	bl	18d80 <ticker_stop>
				    TICKER_USER_ID_ULL_HIGH,
				    ticker_id_adv, ticker_op_stop_adv_cb, adv);
	ticker_op_stop_adv_cb(ticker_status, adv);
    154a:	4651      	mov	r1, sl
    154c:	f01b f9a0 	bl	1c890 <ticker_op_stop_adv_cb>

	/* Stop Direct Adv Stop */
	if (adv->lll.is_hdcd) {
    1550:	f89a 3028 	ldrb.w	r3, [sl, #40]	; 0x28
    1554:	07db      	lsls	r3, r3, #31
    1556:	d506      	bpl.n	1566 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x1de>
		/* Advertiser stop can expire while here in this ISR.
		 * Deferred attempt to stop can fail as it would have
		 * expired, hence ignore failure.
		 */
		ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
    1558:	2201      	movs	r2, #1
    155a:	9700      	str	r7, [sp, #0]
    155c:	463b      	mov	r3, r7
    155e:	4611      	mov	r1, r2
    1560:	4638      	mov	r0, r7
    1562:	f017 fc0d 	bl	18d80 <ticker_stop>
			    TICKER_ID_ADV_STOP, NULL, NULL);
	}

	/* Start Slave */
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    1566:	4628      	mov	r0, r5
    1568:	f01a f836 	bl	1b5d8 <ll_conn_handle_get>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ftr->ticks_anchor - ticks_slot_offset,
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    156c:	fba6 6709 	umull	r6, r7, r6, r9
    1570:	a32b      	add	r3, pc, #172	; (adr r3, 1620 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x298>)
    1572:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    1576:	4604      	mov	r4, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    1578:	4639      	mov	r1, r7
    157a:	4630      	mov	r0, r6
    157c:	f7fe fe10 	bl	1a0 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    1580:	f8d8 3008 	ldr.w	r3, [r8, #8]
    1584:	f1a3 0831 	sub.w	r8, r3, #49	; 0x31
    1588:	f240 131d 	movw	r3, #285	; 0x11d
    158c:	9308      	str	r3, [sp, #32]
    158e:	4b29      	ldr	r3, [pc, #164]	; (1634 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2ac>)
    1590:	e9cd 5306 	strd	r5, r3, [sp, #24]
    1594:	4b28      	ldr	r3, [pc, #160]	; (1638 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2b0>)
    1596:	9305      	str	r3, [sp, #20]
    1598:	68eb      	ldr	r3, [r5, #12]
    159a:	9304      	str	r3, [sp, #16]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    159c:	4b27      	ldr	r3, [pc, #156]	; (163c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2b4>)
    159e:	f020 457f 	bic.w	r5, r0, #4278190080	; 0xff000000
    15a2:	fba5 bc03 	umull	fp, ip, r5, r3
    15a6:	2307      	movs	r3, #7
    15a8:	fb03 cc05 	mla	ip, r3, r5, ip
    15ac:	ebb6 000b 	subs.w	r0, r6, fp
    15b0:	eb67 010c 	sbc.w	r1, r7, ip
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    15b4:	f04f 0a00 	mov.w	sl, #0
				     HAL_TICKER_REMAINDER(conn_interval_us),
    15b8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    15bc:	2300      	movs	r3, #0
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    15be:	f8cd a00c 	str.w	sl, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    15c2:	f7fe fded 	bl	1a0 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    15c6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    15c8:	a315      	add	r3, pc, #84	; (adr r3, 1620 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x298>)
    15ca:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    15ce:	e9cd 5001 	strd	r5, r0, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    15d2:	fba1 0109 	umull	r0, r1, r1, r9
    15d6:	f7fe fde3 	bl	1a0 <__aeabi_uldivmod>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    15da:	3405      	adds	r4, #5
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    15dc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    15e0:	b2e4      	uxtb	r4, r4
    15e2:	9000      	str	r0, [sp, #0]
    15e4:	4643      	mov	r3, r8
    15e6:	4622      	mov	r2, r4
    15e8:	2101      	movs	r1, #1
    15ea:	4650      	mov	r0, sl
    15ec:	f017 fb38 	bl	18c60 <ticker_start>
#endif /* CONFIG_BT_CTLR_CONN_META */
				     (conn->evt.ticks_slot +
				      ticks_slot_overhead),
				     ull_slave_ticker_cb, conn, ticker_op_cb,
				     (void *)__LINE__);
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    15f0:	f030 0302 	bics.w	r3, r0, #2
    15f4:	d00c      	beq.n	1610 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x288>
    15f6:	4a12      	ldr	r2, [pc, #72]	; (1640 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2b8>)
    15f8:	4912      	ldr	r1, [pc, #72]	; (1644 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2bc>)
    15fa:	4813      	ldr	r0, [pc, #76]	; (1648 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2c0>)
    15fc:	f44f 738f 	mov.w	r3, #286	; 0x11e
    1600:	f022 fc6f 	bl	23ee2 <printk>
    1604:	4040      	eors	r0, r0
    1606:	f380 8811 	msr	BASEPRI, r0
    160a:	f04f 0003 	mov.w	r0, #3
    160e:	df02      	svc	2

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* enable ticker job, irrespective of disabled in this function so
	 * first connection event can be scheduled as soon as possible.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
    1610:	2201      	movs	r2, #1
    1612:	2102      	movs	r1, #2
    1614:	4610      	mov	r0, r2
    1616:	f016 fd61 	bl	180dc <mayfly_enable>
#endif
}
    161a:	b011      	add	sp, #68	; 0x44
    161c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1620:	1afd498d 	.word	0x1afd498d
    1624:	00000007 	.word	0x00000007
    1628:	000f4240 	.word	0x000f4240
    162c:	026259ff 	.word	0x026259ff
    1630:	0001c891 	.word	0x0001c891
    1634:	0001c865 	.word	0x0001c865
    1638:	0001c8c9 	.word	0x0001c8c9
    163c:	1afd498d 	.word	0x1afd498d
    1640:	00030802 	.word	0x00030802
    1644:	000306db 	.word	0x000306db
    1648:	0002a5e8 	.word	0x0002a5e8
    164c:	3b9aca00 	.word	0x3b9aca00

00001650 <ull_slave_done>:
 * @param ticks_drift_plus[out]  Positive part of drift uncertainty window
 * @param ticks_drift_minus[out] Negative part of drift uncertainty window
 */
void ull_slave_done(struct node_rx_event_done *done, u32_t *ticks_drift_plus,
		    u32_t *ticks_drift_minus)
{
    1650:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1654:	4688      	mov	r8, r1
	u32_t window_widening_event_us;
	u32_t preamble_to_addr_us;

	start_to_address_actual_us =
		done->extra.slave.start_to_address_actual_us;
	window_widening_event_us =
    1656:	e9d0 910b 	ldrd	r9, r1, [r0, #44]	; 0x2c
		done->extra.slave.window_widening_event_us;
	preamble_to_addr_us =
    165a:	6b45      	ldr	r5, [r0, #52]	; 0x34
		done->extra.slave.preamble_to_addr_us;

	start_to_address_expected_us = EVENT_JITTER_US +
    165c:	4f16      	ldr	r7, [pc, #88]	; (16b8 <ull_slave_done+0x68>)
				       EVENT_TICKER_RES_MARGIN_US +
				       window_widening_event_us +
    165e:	194c      	adds	r4, r1, r5
	start_to_address_expected_us = EVENT_JITTER_US +
    1660:	3430      	adds	r4, #48	; 0x30
				       preamble_to_addr_us;

	if (start_to_address_actual_us <= start_to_address_expected_us) {
    1662:	45a1      	cmp	r9, r4
{
    1664:	4616      	mov	r6, r2
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
    1666:	a312      	add	r3, pc, #72	; (adr r3, 16b0 <ull_slave_done+0x60>)
    1668:	e9d3 2300 	ldrd	r2, r3, [r3]
	if (start_to_address_actual_us <= start_to_address_expected_us) {
    166c:	d815      	bhi.n	169a <ull_slave_done+0x4a>
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
    166e:	fba1 0107 	umull	r0, r1, r1, r7
    1672:	f7fe fd95 	bl	1a0 <__aeabi_uldivmod>
    1676:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
    167a:	f8c8 0000 	str.w	r0, [r8]
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
    167e:	eba4 0009 	sub.w	r0, r4, r9
					       start_to_address_actual_us));
	} else {
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
    1682:	a30b      	add	r3, pc, #44	; (adr r3, 16b0 <ull_slave_done+0x60>)
    1684:	e9d3 2300 	ldrd	r2, r3, [r3]
    1688:	fba0 0107 	umull	r0, r1, r0, r7
    168c:	f7fe fd88 	bl	1a0 <__aeabi_uldivmod>
    1690:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_minus =
    1694:	6030      	str	r0, [r6, #0]
					       EVENT_TICKER_RES_MARGIN_US +
					       preamble_to_addr_us);
	}
}
    1696:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
    169a:	fba9 0107 	umull	r0, r1, r9, r7
    169e:	f7fe fd7f 	bl	1a0 <__aeabi_uldivmod>
    16a2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
    16a6:	f8c8 0000 	str.w	r0, [r8]
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
    16aa:	f105 0030 	add.w	r0, r5, #48	; 0x30
    16ae:	e7e8      	b.n	1682 <ull_slave_done+0x32>
    16b0:	1afd498d 	.word	0x1afd498d
    16b4:	00000007 	.word	0x00000007
    16b8:	3b9aca00 	.word	0x3b9aca00
    16bc:	00000000 	.word	0x00000000

000016c0 <erase_op>:
}

#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

static int erase_op(void *context)
{
    16c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    16c4:	4604      	mov	r4, r0
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    16c6:	f027 fd61 	bl	2918c <nrfx_nvmc_flash_page_size_get>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 0U;

	if (e_ctx->enable_time_limit) {
    16ca:	7b25      	ldrb	r5, [r4, #12]
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    16cc:	4606      	mov	r6, r0
	if (e_ctx->enable_time_limit) {
    16ce:	b115      	cbz	r5, 16d6 <erase_op+0x16>
		ticks_begin = ticker_ticks_now_get();
    16d0:	f026 fe0f 	bl	282f2 <ticker_ticks_now_get>
    16d4:	4605      	mov	r5, r0
		if (e_ctx->enable_time_limit) {
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
						      ticks_begin);
			if (ticks_diff + ticks_diff/i >
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
    16d6:	f20f 0968 	addw	r9, pc, #104	; 0x68
    16da:	e9d9 8900 	ldrd	r8, r9, [r9]
    16de:	f8df b068 	ldr.w	fp, [pc, #104]	; 1748 <erase_op+0x88>
	u32_t ticks_begin = 0U;
    16e2:	f04f 0a00 	mov.w	sl, #0
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
    16e6:	6860      	ldr	r0, [r4, #4]
    16e8:	f01e fde8 	bl	202bc <nrfx_nvmc_page_erase>
		e_ctx->len -= pg_size;
    16ec:	68a3      	ldr	r3, [r4, #8]
    16ee:	1b9b      	subs	r3, r3, r6
    16f0:	60a3      	str	r3, [r4, #8]
		e_ctx->flash_addr += pg_size;
    16f2:	6863      	ldr	r3, [r4, #4]
    16f4:	4433      	add	r3, r6
    16f6:	6063      	str	r3, [r4, #4]
		if (e_ctx->enable_time_limit) {
    16f8:	7b23      	ldrb	r3, [r4, #12]
		i++;
    16fa:	f10a 0a01 	add.w	sl, sl, #1
		if (e_ctx->enable_time_limit) {
    16fe:	b94b      	cbnz	r3, 1714 <erase_op+0x54>
				break;
			}
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	} while (e_ctx->len > 0);
    1700:	68a3      	ldr	r3, [r4, #8]
    1702:	2b00      	cmp	r3, #0
    1704:	d1ef      	bne.n	16e6 <erase_op+0x26>

	return (e_ctx->len > 0) ? FLASH_OP_ONGOING : FLASH_OP_DONE;
    1706:	68a0      	ldr	r0, [r4, #8]
    1708:	3800      	subs	r0, #0
    170a:	bf18      	it	ne
    170c:	2001      	movne	r0, #1
}
    170e:	4240      	negs	r0, r0
    1710:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    1714:	f026 fded 	bl	282f2 <ticker_ticks_now_get>
    1718:	4629      	mov	r1, r5
    171a:	f026 fdec 	bl	282f6 <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
    171e:	fbb0 f7fa 	udiv	r7, r0, sl
    1722:	4407      	add	r7, r0
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
    1724:	6960      	ldr	r0, [r4, #20]
    1726:	4642      	mov	r2, r8
    1728:	464b      	mov	r3, r9
    172a:	fba0 010b 	umull	r0, r1, r0, fp
    172e:	f7fe fd37 	bl	1a0 <__aeabi_uldivmod>
    1732:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
    1736:	4287      	cmp	r7, r0
    1738:	d9e2      	bls.n	1700 <erase_op+0x40>
    173a:	e7e4      	b.n	1706 <erase_op+0x46>
    173c:	f3af 8000 	nop.w
    1740:	1afd498d 	.word	0x1afd498d
    1744:	00000007 	.word	0x00000007
    1748:	3b9aca00 	.word	0x3b9aca00
    174c:	00000000 	.word	0x00000000

00001750 <work_in_time_slice>:
{
    1750:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1754:	b08f      	sub	sp, #60	; 0x3c
	struct flash_context *context = p_flash_op_desc->context;
    1756:	f8d0 9004 	ldr.w	r9, [r0, #4]
			   HAL_TICKER_US_TO_TICKS(context->interval),
    175a:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 183c <work_in_time_slice+0xec>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    175e:	f10d 0137 	add.w	r1, sp, #55	; 0x37
{
    1762:	4606      	mov	r6, r0
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    1764:	f10d 0036 	add.w	r0, sp, #54	; 0x36
    1768:	f026 fe43 	bl	283f2 <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index,
    176c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    1770:	f89d a036 	ldrb.w	sl, [sp, #54]	; 0x36
    1774:	930a      	str	r3, [sp, #40]	; 0x28
    1776:	f026 fdbc 	bl	282f2 <ticker_ticks_now_get>
			   HAL_TICKER_US_TO_TICKS(context->interval),
    177a:	f8d9 4010 	ldr.w	r4, [r9, #16]
    177e:	fba4 450b 	umull	r4, r5, r4, fp
    1782:	a329      	add	r3, pc, #164	; (adr r3, 1828 <work_in_time_slice+0xd8>)
    1784:	e9d3 2300 	ldrd	r2, r3, [r3]
	err = ticker_start(instance_index,
    1788:	2700      	movs	r7, #0
    178a:	4680      	mov	r8, r0
			   HAL_TICKER_US_TO_TICKS(context->interval),
    178c:	4629      	mov	r1, r5
    178e:	4620      	mov	r0, r4
    1790:	f7fe fd06 	bl	1a0 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    1794:	e9cd 7707 	strd	r7, r7, [sp, #28]
    1798:	4b25      	ldr	r3, [pc, #148]	; (1830 <work_in_time_slice+0xe0>)
    179a:	9305      	str	r3, [sp, #20]
    179c:	9606      	str	r6, [sp, #24]
			   HAL_TICKER_US_TO_TICKS(context->interval),
    179e:	900b      	str	r0, [sp, #44]	; 0x2c
			   HAL_TICKER_US_TO_TICKS(context->slot),
    17a0:	f8d9 0014 	ldr.w	r0, [r9, #20]
    17a4:	a320      	add	r3, pc, #128	; (adr r3, 1828 <work_in_time_slice+0xd8>)
    17a6:	e9d3 2300 	ldrd	r2, r3, [r3]
    17aa:	fba0 010b 	umull	r0, r1, r0, fp
    17ae:	f7fe fcf7 	bl	1a0 <__aeabi_uldivmod>
			   HAL_TICKER_REMAINDER(context->interval),
    17b2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    17b4:	f023 497f 	bic.w	r9, r3, #4278190080	; 0xff000000
    17b8:	4b1e      	ldr	r3, [pc, #120]	; (1834 <work_in_time_slice+0xe4>)
	err = ticker_start(instance_index,
    17ba:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			   HAL_TICKER_REMAINDER(context->interval),
    17be:	fba9 bc03 	umull	fp, ip, r9, r3
    17c2:	2307      	movs	r3, #7
    17c4:	fb03 cc09 	mla	ip, r3, r9, ip
	err = ticker_start(instance_index,
    17c8:	e9cd 7003 	strd	r7, r0, [sp, #12]
			   HAL_TICKER_REMAINDER(context->interval),
    17cc:	ebb4 000b 	subs.w	r0, r4, fp
    17d0:	eb65 010c 	sbc.w	r1, r5, ip
    17d4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    17d8:	2300      	movs	r3, #0
    17da:	f7fe fce1 	bl	1a0 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    17de:	4643      	mov	r3, r8
    17e0:	e9cd 9001 	strd	r9, r0, [sp, #4]
    17e4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    17e6:	9700      	str	r7, [sp, #0]
    17e8:	2103      	movs	r1, #3
    17ea:	4650      	mov	r0, sl
    17ec:	f017 fa38 	bl	18c60 <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
    17f0:	f030 0302 	bics.w	r3, r0, #2
    17f4:	d113      	bne.n	181e <work_in_time_slice+0xce>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sem, *(uintptr_t *)&timeout, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    17f6:	4810      	ldr	r0, [pc, #64]	; (1838 <work_in_time_slice+0xe8>)
    17f8:	f645 11b3 	movw	r1, #22963	; 0x59b3
    17fc:	f020 ff9c 	bl	22738 <z_impl_k_sem_take>
	} else if (k_sem_take(&sem_sync, K_MSEC(FLASH_TIMEOUT_MS)) != 0) {
    1800:	b158      	cbz	r0, 181a <work_in_time_slice+0xca>
		_ticker_stop(instance_index, 3, ticker_id);
    1802:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
    1806:	f89d 0036 	ldrb.w	r0, [sp, #54]	; 0x36
    180a:	2103      	movs	r1, #3
    180c:	f01d ffc4 	bl	1f798 <_ticker_stop>
		result = -ETIMEDOUT;
    1810:	f06f 003b 	mvn.w	r0, #59	; 0x3b
}
    1814:	b00f      	add	sp, #60	; 0x3c
    1816:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		result = p_flash_op_desc->result;
    181a:	68b0      	ldr	r0, [r6, #8]
    181c:	e7fa      	b.n	1814 <work_in_time_slice+0xc4>
		result = -ECANCELED;
    181e:	f06f 0047 	mvn.w	r0, #71	; 0x47
	return result;
    1822:	e7f7      	b.n	1814 <work_in_time_slice+0xc4>
    1824:	f3af 8000 	nop.w
    1828:	1afd498d 	.word	0x1afd498d
    182c:	00000007 	.word	0x00000007
    1830:	0001f7e1 	.word	0x0001f7e1
    1834:	1afd498d 	.word	0x1afd498d
    1838:	20001bdc 	.word	0x20001bdc
    183c:	3b9aca00 	.word	0x3b9aca00

00001840 <write_op>:
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
{
    1840:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 1U;

	if (w_ctx->enable_time_limit) {
    1844:	7b05      	ldrb	r5, [r0, #12]
{
    1846:	4604      	mov	r4, r0
	if (w_ctx->enable_time_limit) {
    1848:	b115      	cbz	r5, 1850 <write_op+0x10>
		ticks_begin = ticker_ticks_now_get();
    184a:	f026 fd52 	bl	282f2 <ticker_ticks_now_get>
    184e:	4605      	mov	r5, r0
		if (w_ctx->enable_time_limit) {
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
						      ticks_begin);
			if (ticks_diff + ticks_diff/i >
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    1850:	f20f 0980 	addw	r9, pc, #128	; 0x80
    1854:	e9d9 8900 	ldrd	r8, r9, [r9]
    1858:	f8df a080 	ldr.w	sl, [pc, #128]	; 18dc <write_op+0x9c>
	u32_t ticks_begin = 0U;
    185c:	2601      	movs	r6, #1
	while (w_ctx->len >= sizeof(u32_t)) {
    185e:	68a3      	ldr	r3, [r4, #8]
    1860:	2b03      	cmp	r3, #3
    1862:	d807      	bhi.n	1874 <write_op+0x34>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
    1864:	4a1a      	ldr	r2, [pc, #104]	; (18d0 <write_op+0x90>)
    1866:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
    186a:	07db      	lsls	r3, r3, #31
    186c:	d5fb      	bpl.n	1866 <write_op+0x26>
		shift_write_context(w_ctx->len, w_ctx);
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	nvmc_wait_ready();

	return FLASH_OP_DONE;
    186e:	2000      	movs	r0, #0
}
    1870:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				     UNALIGNED_GET((u32_t *)w_ctx->data_addr));
    1874:	6823      	ldr	r3, [r4, #0]
		nrfx_nvmc_word_write(w_ctx->flash_addr,
    1876:	6860      	ldr	r0, [r4, #4]
    1878:	6819      	ldr	r1, [r3, #0]
    187a:	f01e fd55 	bl	20328 <nrfx_nvmc_word_write>
	w_ctx->flash_addr += shift;
    187e:	6863      	ldr	r3, [r4, #4]
    1880:	3304      	adds	r3, #4
    1882:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
    1884:	6823      	ldr	r3, [r4, #0]
    1886:	3304      	adds	r3, #4
    1888:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    188a:	68a3      	ldr	r3, [r4, #8]
    188c:	3b04      	subs	r3, #4
    188e:	60a3      	str	r3, [r4, #8]
		if (w_ctx->enable_time_limit) {
    1890:	7b23      	ldrb	r3, [r4, #12]
		i++;
    1892:	3601      	adds	r6, #1
		if (w_ctx->enable_time_limit) {
    1894:	2b00      	cmp	r3, #0
    1896:	d0e2      	beq.n	185e <write_op+0x1e>
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    1898:	f026 fd2b 	bl	282f2 <ticker_ticks_now_get>
    189c:	4629      	mov	r1, r5
    189e:	f026 fd2a 	bl	282f6 <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
    18a2:	fbb0 f7f6 	udiv	r7, r0, r6
    18a6:	4407      	add	r7, r0
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    18a8:	6960      	ldr	r0, [r4, #20]
    18aa:	4642      	mov	r2, r8
    18ac:	464b      	mov	r3, r9
    18ae:	fba0 010a 	umull	r0, r1, r0, sl
    18b2:	f7fe fc75 	bl	1a0 <__aeabi_uldivmod>
    18b6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
    18ba:	4287      	cmp	r7, r0
    18bc:	d9cf      	bls.n	185e <write_op+0x1e>
    18be:	4a04      	ldr	r2, [pc, #16]	; (18d0 <write_op+0x90>)
    18c0:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
    18c4:	07d9      	lsls	r1, r3, #31
    18c6:	d5fb      	bpl.n	18c0 <write_op+0x80>
				return FLASH_OP_ONGOING;
    18c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    18cc:	e7d0      	b.n	1870 <write_op+0x30>
    18ce:	bf00      	nop
    18d0:	4001e000 	.word	0x4001e000
    18d4:	1afd498d 	.word	0x1afd498d
    18d8:	00000007 	.word	0x00000007
    18dc:	3b9aca00 	.word	0x3b9aca00

000018e0 <prov_complete>:
	.elem = elements,
	.elem_count = ARRAY_SIZE(elements),
};

static void prov_complete(u16_t net_idx, u16_t addr)
{
    18e0:	b508      	push	{r3, lr}
	struct bt_mesh_elem *ele = &elements[0];

	printk(APP_NAME"%s\n", __func__);
    18e2:	4905      	ldr	r1, [pc, #20]	; (18f8 <prov_complete+0x18>)
    18e4:	4805      	ldr	r0, [pc, #20]	; (18fc <prov_complete+0x1c>)
    18e6:	f022 fafc 	bl	23ee2 <printk>
	net.local = addr;
        net.net_idx = net_idx,
        net.dst = addr;
	
	addr = ele->addr;
	printk("GW_ADDR = 0x%04x\n", addr);
    18ea:	4b05      	ldr	r3, [pc, #20]	; (1900 <prov_complete+0x20>)
    18ec:	4805      	ldr	r0, [pc, #20]	; (1904 <prov_complete+0x24>)
    18ee:	8819      	ldrh	r1, [r3, #0]
}
    18f0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	printk("GW_ADDR = 0x%04x\n", addr);
    18f4:	f022 baf5 	b.w	23ee2 <printk>
    18f8:	0002a85b 	.word	0x0002a85b
    18fc:	0002a568 	.word	0x0002a568
    1900:	20006a0c 	.word	0x20006a0c
    1904:	0002a56e 	.word	0x0002a56e

00001908 <gpio_pin_configure>:
static inline int gpio_pin_configure(struct device *port, gpio_pin_t pin,
				     gpio_flags_t flags)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;
	const struct gpio_driver_config *const cfg =
    1908:	6803      	ldr	r3, [r0, #0]
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH
			| GPIO_OUTPUT_INIT_LOGICAL;
	}

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    190a:	689b      	ldr	r3, [r3, #8]
{
    190c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    1910:	681b      	ldr	r3, [r3, #0]
    1912:	2701      	movs	r7, #1
    1914:	408f      	lsls	r7, r1
    1916:	421f      	tst	r7, r3
	struct gpio_driver_data *data =
    1918:	e9d0 9801 	ldrd	r9, r8, [r0, #4]
{
    191c:	4604      	mov	r4, r0
    191e:	460e      	mov	r6, r1
    1920:	4615      	mov	r5, r2
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    1922:	d10e      	bne.n	1942 <gpio_pin_configure+0x3a>
    1924:	492e      	ldr	r1, [pc, #184]	; (19e0 <gpio_pin_configure+0xd8>)
    1926:	4a2f      	ldr	r2, [pc, #188]	; (19e4 <gpio_pin_configure+0xdc>)
    1928:	482f      	ldr	r0, [pc, #188]	; (19e8 <gpio_pin_configure+0xe0>)
    192a:	f240 23ee 	movw	r3, #750	; 0x2ee
    192e:	f022 fad8 	bl	23ee2 <printk>
    1932:	482e      	ldr	r0, [pc, #184]	; (19ec <gpio_pin_configure+0xe4>)
    1934:	f022 fad5 	bl	23ee2 <printk>
    1938:	482a      	ldr	r0, [pc, #168]	; (19e4 <gpio_pin_configure+0xdc>)
    193a:	f240 21ee 	movw	r1, #750	; 0x2ee
    193e:	f022 fb13 	bl	23f68 <assert_post_action>
	return api->pin_configure(port, pin, flags);
    1942:	6863      	ldr	r3, [r4, #4]
    1944:	462a      	mov	r2, r5
    1946:	681b      	ldr	r3, [r3, #0]
    1948:	4631      	mov	r1, r6
    194a:	4620      	mov	r0, r4
    194c:	4798      	blx	r3
		 "Unsupported pin");

	ret = gpio_config(port, pin, flags);
	if (ret != 0) {
    194e:	2800      	cmp	r0, #0
    1950:	d143      	bne.n	19da <gpio_pin_configure+0xd2>
	}

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    1952:	f8d8 3000 	ldr.w	r3, [r8]
	}
	if (((flags & (GPIO_INT_DISABLE | GPIO_INT_ENABLE)) != 0U)
    1956:	f415 4fc0 	tst.w	r5, #24576	; 0x6000
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    195a:	ea23 0307 	bic.w	r3, r3, r7
    195e:	f8c8 3000 	str.w	r3, [r8]
	if (((flags & (GPIO_INT_DISABLE | GPIO_INT_ENABLE)) != 0U)
    1962:	d03a      	beq.n	19da <gpio_pin_configure+0xd2>
	    && (api->pin_interrupt_configure != NULL)) {
    1964:	f8d9 3018 	ldr.w	r3, [r9, #24]
    1968:	2b00      	cmp	r3, #0
    196a:	d036      	beq.n	19da <gpio_pin_configure+0xd2>
	const struct gpio_driver_config *const cfg =
    196c:	e9d4 3800 	ldrd	r3, r8, [r4]
    1970:	f8d3 9008 	ldr.w	r9, [r3, #8]
	__ASSERT(((flags & GPIO_INT_ENABLE) == 0) ||
    1974:	f405 23c8 	and.w	r3, r5, #409600	; 0x64000
    1978:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    197c:	d10e      	bne.n	199c <gpio_pin_configure+0x94>
    197e:	491c      	ldr	r1, [pc, #112]	; (19f0 <gpio_pin_configure+0xe8>)
    1980:	4a18      	ldr	r2, [pc, #96]	; (19e4 <gpio_pin_configure+0xdc>)
    1982:	4819      	ldr	r0, [pc, #100]	; (19e8 <gpio_pin_configure+0xe0>)
    1984:	f240 23a3 	movw	r3, #675	; 0x2a3
    1988:	f022 faab 	bl	23ee2 <printk>
    198c:	4819      	ldr	r0, [pc, #100]	; (19f4 <gpio_pin_configure+0xec>)
    198e:	f022 faa8 	bl	23ee2 <printk>
    1992:	4814      	ldr	r0, [pc, #80]	; (19e4 <gpio_pin_configure+0xdc>)
    1994:	f240 21a3 	movw	r1, #675	; 0x2a3
    1998:	f022 fae6 	bl	23f68 <assert_post_action>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    199c:	f8d9 3000 	ldr.w	r3, [r9]
    19a0:	421f      	tst	r7, r3
    19a2:	d10e      	bne.n	19c2 <gpio_pin_configure+0xba>
    19a4:	490e      	ldr	r1, [pc, #56]	; (19e0 <gpio_pin_configure+0xd8>)
    19a6:	4a0f      	ldr	r2, [pc, #60]	; (19e4 <gpio_pin_configure+0xdc>)
    19a8:	480f      	ldr	r0, [pc, #60]	; (19e8 <gpio_pin_configure+0xe0>)
    19aa:	f240 23a9 	movw	r3, #681	; 0x2a9
    19ae:	f022 fa98 	bl	23ee2 <printk>
    19b2:	480e      	ldr	r0, [pc, #56]	; (19ec <gpio_pin_configure+0xe4>)
    19b4:	f022 fa95 	bl	23ee2 <printk>
    19b8:	480a      	ldr	r0, [pc, #40]	; (19e4 <gpio_pin_configure+0xdc>)
    19ba:	f240 21a9 	movw	r1, #681	; 0x2a9
    19be:	f022 fad3 	bl	23f68 <assert_post_action>
	return api->pin_interrupt_configure(port, pin, mode, trig);
    19c2:	f8d8 7018 	ldr.w	r7, [r8, #24]
    19c6:	f405 23c0 	and.w	r3, r5, #393216	; 0x60000
    19ca:	f405 32b0 	and.w	r2, r5, #90112	; 0x16000
    19ce:	4631      	mov	r1, r6
    19d0:	4620      	mov	r0, r4
    19d2:	46bc      	mov	ip, r7
		flags &= ~GPIO_INT_DEBOUNCE;
		ret = z_impl_gpio_pin_interrupt_configure(port, pin, flags);
	}

	return ret;
}
    19d4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return api->pin_interrupt_configure(port, pin, mode, trig);
    19d8:	4760      	bx	ip
}
    19da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    19de:	bf00      	nop
    19e0:	0002a5aa 	.word	0x0002a5aa
    19e4:	0002a580 	.word	0x0002a580
    19e8:	0002a5e8 	.word	0x0002a5e8
    19ec:	0002a605 	.word	0x0002a605
    19f0:	0002a617 	.word	0x0002a617
    19f4:	0002a661 	.word	0x0002a661

000019f8 <z_impl_gpio_enable_callback>:
{
    19f8:	b570      	push	{r4, r5, r6, lr}
	const struct gpio_driver_config *const cfg =
    19fa:	e9d0 3600 	ldrd	r3, r6, [r0]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    19fe:	689a      	ldr	r2, [r3, #8]
    1a00:	2301      	movs	r3, #1
    1a02:	6812      	ldr	r2, [r2, #0]
    1a04:	408b      	lsls	r3, r1
    1a06:	4213      	tst	r3, r2
{
    1a08:	4604      	mov	r4, r0
    1a0a:	460d      	mov	r5, r1
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    1a0c:	d10e      	bne.n	1a2c <z_impl_gpio_enable_callback+0x34>
    1a0e:	490c      	ldr	r1, [pc, #48]	; (1a40 <z_impl_gpio_enable_callback+0x48>)
    1a10:	4a0c      	ldr	r2, [pc, #48]	; (1a44 <z_impl_gpio_enable_callback+0x4c>)
    1a12:	480d      	ldr	r0, [pc, #52]	; (1a48 <z_impl_gpio_enable_callback+0x50>)
    1a14:	f44f 7313 	mov.w	r3, #588	; 0x24c
    1a18:	f022 fa63 	bl	23ee2 <printk>
    1a1c:	480b      	ldr	r0, [pc, #44]	; (1a4c <z_impl_gpio_enable_callback+0x54>)
    1a1e:	f022 fa60 	bl	23ee2 <printk>
    1a22:	4808      	ldr	r0, [pc, #32]	; (1a44 <z_impl_gpio_enable_callback+0x4c>)
    1a24:	f44f 7113 	mov.w	r1, #588	; 0x24c
    1a28:	f022 fa9e 	bl	23f68 <assert_post_action>
	if (api->enable_callback == NULL) {
    1a2c:	6a33      	ldr	r3, [r6, #32]
    1a2e:	b123      	cbz	r3, 1a3a <z_impl_gpio_enable_callback+0x42>
	return api->enable_callback(port, pin);
    1a30:	4629      	mov	r1, r5
    1a32:	4620      	mov	r0, r4
}
    1a34:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return api->enable_callback(port, pin);
    1a38:	4718      	bx	r3
}
    1a3a:	f06f 0022 	mvn.w	r0, #34	; 0x22
    1a3e:	bd70      	pop	{r4, r5, r6, pc}
    1a40:	0002a5aa 	.word	0x0002a5aa
    1a44:	0002a580 	.word	0x0002a580
    1a48:	0002a5e8 	.word	0x0002a5e8
    1a4c:	0002a605 	.word	0x0002a605

00001a50 <button_pressed>:
}
static void envi_report_set(u8_t cmd);
static u32_t time, last_time;
static void button_pressed(struct device *dev, struct gpio_callback *cb,
		u32_t pin_pos)
{
    1a50:	b538      	push	{r3, r4, r5, lr}
	u8_t button;

	printk(APP_NAME"%s\n", __func__);
    1a52:	492a      	ldr	r1, [pc, #168]	; (1afc <button_pressed+0xac>)
    1a54:	482a      	ldr	r0, [pc, #168]	; (1b00 <button_pressed+0xb0>)
{
    1a56:	4614      	mov	r4, r2
	printk(APP_NAME"%s\n", __func__);
    1a58:	f022 fa43 	bl	23ee2 <printk>
	return z_impl_k_uptime_ticks();
    1a5c:	f027 fcd9 	bl	29412 <z_impl_k_uptime_ticks>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
    1a60:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    1a64:	460a      	mov	r2, r1
    1a66:	fba0 0103 	umull	r0, r1, r0, r3
    1a6a:	fb03 1102 	mla	r1, r3, r2, r1

	time = k_uptime_get_32();

	/* debounce the switch */
	if (time < last_time + BUTTON_DEBOUNCE_DELAY_MS) {
    1a6e:	4a25      	ldr	r2, [pc, #148]	; (1b04 <button_pressed+0xb4>)
    1a70:	0bc3      	lsrs	r3, r0, #15
    1a72:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
    1a76:	6811      	ldr	r1, [r2, #0]
		last_time = time;
    1a78:	6013      	str	r3, [r2, #0]
	if (time < last_time + BUTTON_DEBOUNCE_DELAY_MS) {
    1a7a:	31fa      	adds	r1, #250	; 0xfa
    1a7c:	4299      	cmp	r1, r3
    1a7e:	d900      	bls.n	1a82 <button_pressed+0x32>
	last_time = time;

	button = pin_to_sw(pin_pos);

	envi_report_set(button);
}
    1a80:	bd38      	pop	{r3, r4, r5, pc}
	switch (pin_pos) {
    1a82:	f1b4 7f80 	cmp.w	r4, #16777216	; 0x1000000
    1a86:	d014      	beq.n	1ab2 <button_pressed+0x62>
    1a88:	d80e      	bhi.n	1aa8 <button_pressed+0x58>
    1a8a:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
    1a8e:	d009      	beq.n	1aa4 <button_pressed+0x54>
    1a90:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    1a94:	d027      	beq.n	1ae6 <button_pressed+0x96>
		printk("Invalid pin_pos\n");
    1a96:	481c      	ldr	r0, [pc, #112]	; (1b08 <button_pressed+0xb8>)
    1a98:	f022 fa23 	bl	23ee2 <printk>
	printk("No match for GPIO pin 0x%08x\n", pin_pos);
    1a9c:	481b      	ldr	r0, [pc, #108]	; (1b0c <button_pressed+0xbc>)
    1a9e:	4621      	mov	r1, r4
    1aa0:	f022 fa1f 	bl	23ee2 <printk>
	case BIT(DT_GPIO_KEYS_SW0_GPIOS_PIN): return 0;
    1aa4:	2400      	movs	r4, #0
    1aa6:	e005      	b.n	1ab4 <button_pressed+0x64>
	switch (pin_pos) {
    1aa8:	f1b4 7f00 	cmp.w	r4, #33554432	; 0x2000000
    1aac:	d1f3      	bne.n	1a96 <button_pressed+0x46>
	case BIT(DT_GPIO_KEYS_SW3_GPIOS_PIN): return 3;
    1aae:	2403      	movs	r4, #3
    1ab0:	e000      	b.n	1ab4 <button_pressed+0x64>
	case BIT(DT_GPIO_KEYS_SW2_GPIOS_PIN): return 2;
    1ab2:	2402      	movs	r4, #2

static void envi_report_set(u8_t cmd)
{
	int ret;

	bt_mesh_model_msg_init(mod_pub->msg, OP_ENVI_REPORT_SET);
    1ab4:	4d16      	ldr	r5, [pc, #88]	; (1b10 <button_pressed+0xc0>)
    1ab6:	682b      	ldr	r3, [r5, #0]
    1ab8:	f44f 4102 	mov.w	r1, #33280	; 0x8200
    1abc:	6918      	ldr	r0, [r3, #16]
    1abe:	f025 fe77 	bl	277b0 <bt_mesh_model_msg_init>
	
	cmd = cmd ? 1 : 0;
	net_buf_simple_add_u8(mod_pub->msg, cmd); //cmd = 0 to stop and 1 to start the envi report.
    1ac2:	682b      	ldr	r3, [r5, #0]
    1ac4:	1e21      	subs	r1, r4, #0
    1ac6:	bf18      	it	ne
    1ac8:	2101      	movne	r1, #1
    1aca:	6918      	ldr	r0, [r3, #16]
    1acc:	f027 f97f 	bl	28dce <net_buf_simple_add_u8>


	ret = bt_mesh_model_publish(mod_cli);
    1ad0:	4b10      	ldr	r3, [pc, #64]	; (1b14 <button_pressed+0xc4>)
    1ad2:	6818      	ldr	r0, [r3, #0]
    1ad4:	f00e f920 	bl	fd18 <bt_mesh_model_publish>

	if (ret) {
    1ad8:	4601      	mov	r1, r0
    1ada:	b130      	cbz	r0, 1aea <button_pressed+0x9a>
}
    1adc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		printk("\nmsg publish failed, ERR = %d\n", ret);
    1ae0:	480d      	ldr	r0, [pc, #52]	; (1b18 <button_pressed+0xc8>)
    1ae2:	f022 b9fe 	b.w	23ee2 <printk>
	switch (pin_pos) {
    1ae6:	2401      	movs	r4, #1
    1ae8:	e7e4      	b.n	1ab4 <button_pressed+0x64>
		return;
	}

	if (cmd)
    1aea:	b124      	cbz	r4, 1af6 <button_pressed+0xa6>
		printk("GW:Start ENVI report\n");
    1aec:	480b      	ldr	r0, [pc, #44]	; (1b1c <button_pressed+0xcc>)
}
    1aee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	else
		printk("GW:Stop ENVI report\n");
    1af2:	f022 b9f6 	b.w	23ee2 <printk>
    1af6:	480a      	ldr	r0, [pc, #40]	; (1b20 <button_pressed+0xd0>)
    1af8:	e7f9      	b.n	1aee <button_pressed+0x9e>
    1afa:	bf00      	nop
    1afc:	0002a872 	.word	0x0002a872
    1b00:	0002a568 	.word	0x0002a568
    1b04:	20000154 	.word	0x20000154
    1b08:	0002a6a6 	.word	0x0002a6a6
    1b0c:	0002a6b7 	.word	0x0002a6b7
    1b10:	2000015c 	.word	0x2000015c
    1b14:	20000158 	.word	0x20000158
    1b18:	0002a6d5 	.word	0x0002a6d5
    1b1c:	0002a6f4 	.word	0x0002a6f4
    1b20:	0002a70a 	.word	0x0002a70a

00001b24 <envi_report>:
{
    1b24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        s8_t temperature = net_buf_simple_pull_u8(buf);
    1b26:	4610      	mov	r0, r2
{
    1b28:	4614      	mov	r4, r2
    1b2a:	460f      	mov	r7, r1
        s8_t temperature = net_buf_simple_pull_u8(buf);
    1b2c:	f027 f913 	bl	28d56 <net_buf_simple_pull_u8>
    1b30:	4605      	mov	r5, r0
        u16_t airp = net_buf_simple_pull_le16(buf);
    1b32:	4620      	mov	r0, r4
    1b34:	f027 f917 	bl	28d66 <net_buf_simple_pull_le16>
    1b38:	4606      	mov	r6, r0
        u16_t humidity = net_buf_simple_pull_le16(buf);
    1b3a:	4620      	mov	r0, r4
    1b3c:	f027 f913 	bl	28d66 <net_buf_simple_pull_le16>
    1b40:	4604      	mov	r4, r0
       printk("------------------------\n");
    1b42:	4809      	ldr	r0, [pc, #36]	; (1b68 <envi_report+0x44>)
    1b44:	f022 f9cd 	bl	23ee2 <printk>
       printk("-->[0x%04x] ", ctx->addr);
    1b48:	88b9      	ldrh	r1, [r7, #4]
    1b4a:	4808      	ldr	r0, [pc, #32]	; (1b6c <envi_report+0x48>)
    1b4c:	f022 f9c9 	bl	23ee2 <printk>
       printk("temperature:%hhd airp:%hu humidity:%hu\n", temperature, airp, humidity);
    1b50:	4807      	ldr	r0, [pc, #28]	; (1b70 <envi_report+0x4c>)
    1b52:	4623      	mov	r3, r4
    1b54:	4632      	mov	r2, r6
    1b56:	b269      	sxtb	r1, r5
    1b58:	f022 f9c3 	bl	23ee2 <printk>
}
    1b5c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
       printk("-------------------------\n");
    1b60:	4804      	ldr	r0, [pc, #16]	; (1b74 <envi_report+0x50>)
    1b62:	f022 b9be 	b.w	23ee2 <printk>
    1b66:	bf00      	nop
    1b68:	0002a755 	.word	0x0002a755
    1b6c:	0002a71f 	.word	0x0002a71f
    1b70:	0002a72c 	.word	0x0002a72c
    1b74:	0002a754 	.word	0x0002a754

00001b78 <bt_ready>:
{
    1b78:	b508      	push	{r3, lr}
		printk(APP_NAME"%s: Bluetooth init failed (err %d)\n", __func__, err);
    1b7a:	4920      	ldr	r1, [pc, #128]	; (1bfc <bt_ready+0x84>)
	if (err) {
    1b7c:	4602      	mov	r2, r0
    1b7e:	b120      	cbz	r0, 1b8a <bt_ready+0x12>
		printk(APP_NAME"%s: Bluetooth init failed (err %d)\n", __func__, err);
    1b80:	481f      	ldr	r0, [pc, #124]	; (1c00 <bt_ready+0x88>)
}
    1b82:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		printk(APP_NAME"%s: Initializing mesh failed (err %d)\n", __func__, err);
    1b86:	f022 b9ac 	b.w	23ee2 <printk>
	printk(APP_NAME"%s:Bluetooth initialized\n", __func__);
    1b8a:	481e      	ldr	r0, [pc, #120]	; (1c04 <bt_ready+0x8c>)
    1b8c:	f022 f9a9 	bl	23ee2 <printk>
	err = bt_mesh_init(&prov, &comp);
    1b90:	491d      	ldr	r1, [pc, #116]	; (1c08 <bt_ready+0x90>)
    1b92:	481e      	ldr	r0, [pc, #120]	; (1c0c <bt_ready+0x94>)
    1b94:	f025 fa24 	bl	26fe0 <bt_mesh_init>
	if (err) {
    1b98:	4602      	mov	r2, r0
    1b9a:	b110      	cbz	r0, 1ba2 <bt_ready+0x2a>
		printk(APP_NAME"%s: Initializing mesh failed (err %d)\n", __func__, err);
    1b9c:	4917      	ldr	r1, [pc, #92]	; (1bfc <bt_ready+0x84>)
    1b9e:	481c      	ldr	r0, [pc, #112]	; (1c10 <bt_ready+0x98>)
    1ba0:	e7ef      	b.n	1b82 <bt_ready+0xa>
		settings_load();
    1ba2:	f022 fdc2 	bl	2472a <settings_load>
        err = bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT);
    1ba6:	2003      	movs	r0, #3
    1ba8:	f014 fcde 	bl	16568 <bt_mesh_prov_enable>
	if (err == -EALREADY) {
    1bac:	3045      	adds	r0, #69	; 0x45
    1bae:	d120      	bne.n	1bf2 <bt_ready+0x7a>
		printk("\nUsing stored settings\n");
    1bb0:	4818      	ldr	r0, [pc, #96]	; (1c14 <bt_ready+0x9c>)
    1bb2:	f022 f996 	bl	23ee2 <printk>
		printk("GW_ADDR = 0x%04x\n", addr);
    1bb6:	4b18      	ldr	r3, [pc, #96]	; (1c18 <bt_ready+0xa0>)
    1bb8:	4818      	ldr	r0, [pc, #96]	; (1c1c <bt_ready+0xa4>)
    1bba:	8819      	ldrh	r1, [r3, #0]
    1bbc:	f022 f991 	bl	23ee2 <printk>
	printk(APP_NAME"%s: Mesh initialized\n", __func__);
    1bc0:	490e      	ldr	r1, [pc, #56]	; (1bfc <bt_ready+0x84>)
    1bc2:	4817      	ldr	r0, [pc, #92]	; (1c20 <bt_ready+0xa8>)
    1bc4:	f022 f98d 	bl	23ee2 <printk>
	mod_cli = &root_models[ARRAY_SIZE(root_models)-1];
    1bc8:	4b16      	ldr	r3, [pc, #88]	; (1c24 <bt_ready+0xac>)
    1bca:	4a17      	ldr	r2, [pc, #92]	; (1c28 <bt_ready+0xb0>)
	printk("\n....GW....\n");
    1bcc:	4817      	ldr	r0, [pc, #92]	; (1c2c <bt_ready+0xb4>)
	mod_cli = &root_models[ARRAY_SIZE(root_models)-1];
    1bce:	f103 0120 	add.w	r1, r3, #32
    1bd2:	6011      	str	r1, [r2, #0]
	mod_pub = mod_cli->pub;
    1bd4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1bd6:	4b16      	ldr	r3, [pc, #88]	; (1c30 <bt_ready+0xb8>)
    1bd8:	601a      	str	r2, [r3, #0]
	printk("\n....GW....\n");
    1bda:	f022 f982 	bl	23ee2 <printk>
	err = bt_set_name("GW");
    1bde:	4815      	ldr	r0, [pc, #84]	; (1c34 <bt_ready+0xbc>)
    1be0:	f006 f99e 	bl	7f20 <bt_set_name>
	if(err)
    1be4:	4601      	mov	r1, r0
    1be6:	b140      	cbz	r0, 1bfa <bt_ready+0x82>
}
    1be8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		printk("bt_set_name failed, err=%d\n", err);
    1bec:	4812      	ldr	r0, [pc, #72]	; (1c38 <bt_ready+0xc0>)
    1bee:	f022 b978 	b.w	23ee2 <printk>
		printk("\n\nPlease provision the node\n\n");
    1bf2:	4812      	ldr	r0, [pc, #72]	; (1c3c <bt_ready+0xc4>)
    1bf4:	f022 f975 	bl	23ee2 <printk>
    1bf8:	e7e2      	b.n	1bc0 <bt_ready+0x48>
}
    1bfa:	bd08      	pop	{r3, pc}
    1bfc:	0002a869 	.word	0x0002a869
    1c00:	0002a76f 	.word	0x0002a76f
    1c04:	0002a795 	.word	0x0002a795
    1c08:	00029ac8 	.word	0x00029ac8
    1c0c:	00029af0 	.word	0x00029af0
    1c10:	0002a7b1 	.word	0x0002a7b1
    1c14:	0002a7da 	.word	0x0002a7da
    1c18:	20006a0c 	.word	0x20006a0c
    1c1c:	0002a56e 	.word	0x0002a56e
    1c20:	0002a810 	.word	0x0002a810
    1c24:	20006a54 	.word	0x20006a54
    1c28:	20000158 	.word	0x20000158
    1c2c:	0002a828 	.word	0x0002a828
    1c30:	2000015c 	.word	0x2000015c
    1c34:	0002a835 	.word	0x0002a835
    1c38:	0002a838 	.word	0x0002a838
    1c3c:	0002a7f2 	.word	0x0002a7f2

00001c40 <init_led>:
{
    1c40:	b570      	push	{r4, r5, r6, lr}
    1c42:	460d      	mov	r5, r1
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    1c44:	f01e fbc0 	bl	203c8 <z_impl_device_get_binding>
        gpio_pin_configure(led_device,
    1c48:	b2ed      	uxtb	r5, r5
    1c4a:	4604      	mov	r4, r0
    1c4c:	4629      	mov	r1, r5
    1c4e:	f44f 7204 	mov.w	r2, #528	; 0x210
    1c52:	f7ff fe59 	bl	1908 <gpio_pin_configure>
 * @retval -EIO I/O error when accessing an external GPIO chip.
 * @retval -EWOULDBLOCK if operation would block.
 */
static inline int gpio_pin_set(struct device *port, gpio_pin_t pin, int value)
{
	const struct gpio_driver_config *const cfg =
    1c56:	6823      	ldr	r3, [r4, #0]
		(const struct gpio_driver_config *)port->config->config_info;
	const struct gpio_driver_data *const data =
    1c58:	68a6      	ldr	r6, [r4, #8]
			(const struct gpio_driver_data *)port->driver_data;

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    1c5a:	689b      	ldr	r3, [r3, #8]
    1c5c:	2101      	movs	r1, #1
    1c5e:	681b      	ldr	r3, [r3, #0]
    1c60:	fa01 f505 	lsl.w	r5, r1, r5
    1c64:	421d      	tst	r5, r3
    1c66:	d10e      	bne.n	1c86 <init_led+0x46>
    1c68:	4918      	ldr	r1, [pc, #96]	; (1ccc <init_led+0x8c>)
    1c6a:	4a19      	ldr	r2, [pc, #100]	; (1cd0 <init_led+0x90>)
    1c6c:	4819      	ldr	r0, [pc, #100]	; (1cd4 <init_led+0x94>)
    1c6e:	f240 438a 	movw	r3, #1162	; 0x48a
    1c72:	f022 f936 	bl	23ee2 <printk>
    1c76:	4818      	ldr	r0, [pc, #96]	; (1cd8 <init_led+0x98>)
    1c78:	f022 f933 	bl	23ee2 <printk>
    1c7c:	4814      	ldr	r0, [pc, #80]	; (1cd0 <init_led+0x90>)
    1c7e:	f240 418a 	movw	r1, #1162	; 0x48a
    1c82:	f022 f971 	bl	23f68 <assert_post_action>
	const struct gpio_driver_config *const cfg =
    1c86:	6823      	ldr	r3, [r4, #0]
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    1c88:	6836      	ldr	r6, [r6, #0]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    1c8a:	689b      	ldr	r3, [r3, #8]
    1c8c:	681b      	ldr	r3, [r3, #0]
    1c8e:	421d      	tst	r5, r3
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    1c90:	ea06 0605 	and.w	r6, r6, r5
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    1c94:	d10e      	bne.n	1cb4 <init_led+0x74>
    1c96:	490d      	ldr	r1, [pc, #52]	; (1ccc <init_led+0x8c>)
    1c98:	4a0d      	ldr	r2, [pc, #52]	; (1cd0 <init_led+0x90>)
    1c9a:	480e      	ldr	r0, [pc, #56]	; (1cd4 <init_led+0x94>)
    1c9c:	f240 4361 	movw	r3, #1121	; 0x461
    1ca0:	f022 f91f 	bl	23ee2 <printk>
    1ca4:	480c      	ldr	r0, [pc, #48]	; (1cd8 <init_led+0x98>)
    1ca6:	f022 f91c 	bl	23ee2 <printk>
    1caa:	4809      	ldr	r0, [pc, #36]	; (1cd0 <init_led+0x90>)
    1cac:	f240 4161 	movw	r1, #1121	; 0x461
    1cb0:	f022 f95a 	bl	23f68 <assert_post_action>
	if (value != 0)	{
    1cb4:	b936      	cbnz	r6, 1cc4 <init_led+0x84>
	return api->port_set_bits_raw(port, pins);
    1cb6:	6863      	ldr	r3, [r4, #4]
    1cb8:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
    1cba:	4629      	mov	r1, r5
    1cbc:	4620      	mov	r0, r4
}
    1cbe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    1cc2:	4718      	bx	r3
    1cc4:	6863      	ldr	r3, [r4, #4]
    1cc6:	691b      	ldr	r3, [r3, #16]
    1cc8:	e7f7      	b.n	1cba <init_led+0x7a>
    1cca:	bf00      	nop
    1ccc:	0002a5aa 	.word	0x0002a5aa
    1cd0:	0002a580 	.word	0x0002a580
    1cd4:	0002a5e8 	.word	0x0002a5e8
    1cd8:	0002a605 	.word	0x0002a605

00001cdc <main>:
{
    1cdc:	b510      	push	{r4, lr}
	err = bt_enable(bt_ready);
    1cde:	4820      	ldr	r0, [pc, #128]	; (1d60 <main+0x84>)
    1ce0:	f006 f8a6 	bl	7e30 <bt_enable>
	if (err) {
    1ce4:	4601      	mov	r1, r0
    1ce6:	b110      	cbz	r0, 1cee <main+0x12>
		printk("Bluetooth init failed (err %d)\n", err);
    1ce8:	481e      	ldr	r0, [pc, #120]	; (1d64 <main+0x88>)
    1cea:	f022 f8fa 	bl	23ee2 <printk>
    1cee:	481e      	ldr	r0, [pc, #120]	; (1d68 <main+0x8c>)
	sw_device = device_get_binding(DT_GPIO_KEYS_SW0_GPIOS_CONTROLLER);
    1cf0:	4c1e      	ldr	r4, [pc, #120]	; (1d6c <main+0x90>)
    1cf2:	f01e fb69 	bl	203c8 <z_impl_device_get_binding>
	gpio_pin_configure(sw_device, DT_GPIO_KEYS_SW0_GPIOS_PIN,
    1cf6:	4a1e      	ldr	r2, [pc, #120]	; (1d70 <main+0x94>)
	sw_device = device_get_binding(DT_GPIO_KEYS_SW0_GPIOS_CONTROLLER);
    1cf8:	6020      	str	r0, [r4, #0]
	gpio_pin_configure(sw_device, DT_GPIO_KEYS_SW0_GPIOS_PIN,
    1cfa:	210b      	movs	r1, #11
    1cfc:	f7ff fe04 	bl	1908 <gpio_pin_configure>
	gpio_pin_configure(sw_device, DT_GPIO_KEYS_SW1_GPIOS_PIN,
    1d00:	4a1b      	ldr	r2, [pc, #108]	; (1d70 <main+0x94>)
    1d02:	6820      	ldr	r0, [r4, #0]
    1d04:	210c      	movs	r1, #12
    1d06:	f7ff fdff 	bl	1908 <gpio_pin_configure>
	gpio_pin_configure(sw_device, DT_GPIO_KEYS_SW2_GPIOS_PIN,
    1d0a:	4a19      	ldr	r2, [pc, #100]	; (1d70 <main+0x94>)
    1d0c:	6820      	ldr	r0, [r4, #0]
    1d0e:	2118      	movs	r1, #24
    1d10:	f7ff fdfa 	bl	1908 <gpio_pin_configure>
	gpio_pin_configure(sw_device, DT_GPIO_KEYS_SW3_GPIOS_PIN,
    1d14:	2119      	movs	r1, #25
    1d16:	4a16      	ldr	r2, [pc, #88]	; (1d70 <main+0x94>)
    1d18:	6820      	ldr	r0, [r4, #0]
    1d1a:	f7ff fdf5 	bl	1908 <gpio_pin_configure>
				      gpio_port_pins_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
    1d1e:	4915      	ldr	r1, [pc, #84]	; (1d74 <main+0x98>)
    1d20:	4b15      	ldr	r3, [pc, #84]	; (1d78 <main+0x9c>)
	gpio_add_callback(sw_device, &button_cb);
    1d22:	6820      	ldr	r0, [r4, #0]
    1d24:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
    1d26:	4b15      	ldr	r3, [pc, #84]	; (1d7c <main+0xa0>)
    1d28:	608b      	str	r3, [r1, #8]
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	if (api->manage_callback == NULL) {
    1d2a:	6843      	ldr	r3, [r0, #4]
    1d2c:	69db      	ldr	r3, [r3, #28]
    1d2e:	b10b      	cbz	r3, 1d34 <main+0x58>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
    1d30:	2201      	movs	r2, #1
    1d32:	4798      	blx	r3
	gpio_pin_enable_callback(sw_device, DT_GPIO_KEYS_SW0_GPIOS_PIN);
    1d34:	6820      	ldr	r0, [r4, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&port, *(uintptr_t *)&pin, K_SYSCALL_GPIO_ENABLE_CALLBACK);
	}
#endif
	compiler_barrier();
	return z_impl_gpio_enable_callback(port, pin);
    1d36:	210b      	movs	r1, #11
    1d38:	f7ff fe5e 	bl	19f8 <z_impl_gpio_enable_callback>
	gpio_pin_enable_callback(sw_device, DT_GPIO_KEYS_SW1_GPIOS_PIN);
    1d3c:	6820      	ldr	r0, [r4, #0]
    1d3e:	210c      	movs	r1, #12
    1d40:	f7ff fe5a 	bl	19f8 <z_impl_gpio_enable_callback>
	gpio_pin_enable_callback(sw_device, DT_GPIO_KEYS_SW2_GPIOS_PIN);
    1d44:	6820      	ldr	r0, [r4, #0]
    1d46:	2118      	movs	r1, #24
    1d48:	f7ff fe56 	bl	19f8 <z_impl_gpio_enable_callback>
	gpio_pin_enable_callback(sw_device, DT_GPIO_KEYS_SW3_GPIOS_PIN);
    1d4c:	6820      	ldr	r0, [r4, #0]
    1d4e:	2119      	movs	r1, #25
    1d50:	f7ff fe52 	bl	19f8 <z_impl_gpio_enable_callback>
}
    1d54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	init_led(DT_ALIAS_LED1_GPIOS_CONTROLLER, DT_ALIAS_LED1_GPIOS_PIN);
    1d58:	4803      	ldr	r0, [pc, #12]	; (1d68 <main+0x8c>)
    1d5a:	210e      	movs	r1, #14
    1d5c:	f7ff bf70 	b.w	1c40 <init_led>
    1d60:	00001b79 	.word	0x00001b79
    1d64:	0002a775 	.word	0x0002a775
    1d68:	0002a854 	.word	0x0002a854
    1d6c:	20000160 	.word	0x20000160
    1d70:	00034110 	.word	0x00034110
    1d74:	20000148 	.word	0x20000148
    1d78:	00001a51 	.word	0x00001a51
    1d7c:	03001800 	.word	0x03001800

00001d80 <crc8_ccitt>:
	0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
	0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d
};

u8_t crc8_ccitt(u8_t val, const void *buf, size_t cnt)
{
    1d80:	b530      	push	{r4, r5, lr}
	int i;
	const u8_t *p = buf;

	for (i = 0; i < cnt; i++) {
		val ^= p[i];
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    1d82:	4c0a      	ldr	r4, [pc, #40]	; (1dac <crc8_ccitt+0x2c>)
    1d84:	440a      	add	r2, r1
	for (i = 0; i < cnt; i++) {
    1d86:	4291      	cmp	r1, r2
    1d88:	d100      	bne.n	1d8c <crc8_ccitt+0xc>
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
	}
	return val;
}
    1d8a:	bd30      	pop	{r4, r5, pc}
		val ^= p[i];
    1d8c:	f811 3b01 	ldrb.w	r3, [r1], #1
    1d90:	4058      	eors	r0, r3
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    1d92:	0903      	lsrs	r3, r0, #4
    1d94:	5ce3      	ldrb	r3, [r4, r3]
    1d96:	ea83 1300 	eor.w	r3, r3, r0, lsl #4
    1d9a:	b2dd      	uxtb	r5, r3
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    1d9c:	f3c3 1303 	ubfx	r3, r3, #4, #4
    1da0:	5ce0      	ldrb	r0, [r4, r3]
    1da2:	ea80 1005 	eor.w	r0, r0, r5, lsl #4
    1da6:	b2c0      	uxtb	r0, r0
	for (i = 0; i < cnt; i++) {
    1da8:	e7ed      	b.n	1d86 <crc8_ccitt+0x6>
    1daa:	bf00      	nop
    1dac:	0002a891 	.word	0x0002a891

00001db0 <z_sys_mem_pool_block_free>:
	return 0;
}

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
    1db0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1db4:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    1db6:	7a83      	ldrb	r3, [r0, #10]
    1db8:	009b      	lsls	r3, r3, #2
    1dba:	3307      	adds	r3, #7
    1dbc:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
{
    1dc0:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    1dc2:	ebad 0d03 	sub.w	sp, sp, r3
    1dc6:	46e9      	mov	r9, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
    1dc8:	6843      	ldr	r3, [r0, #4]
    1dca:	f8c9 3000 	str.w	r3, [r9]
{
    1dce:	4688      	mov	r8, r1
    1dd0:	4615      	mov	r5, r2
    1dd2:	4606      	mov	r6, r0
	for (i = 1; i <= level; i++) {
    1dd4:	4649      	mov	r1, r9
    1dd6:	2201      	movs	r2, #1
    1dd8:	4590      	cmp	r8, r2
    1dda:	d220      	bcs.n	1e1e <z_sys_mem_pool_block_free+0x6e>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    1ddc:	7c34      	ldrb	r4, [r6, #16]
    1dde:	f014 0401 	ands.w	r4, r4, #1
    1de2:	d002      	beq.n	1dea <z_sys_mem_pool_block_free+0x3a>
    1de4:	f021 ff4c 	bl	23c80 <pool_irq_lock.isra.0.part.0>
    1de8:	4604      	mov	r4, r0
	while (level >= 0) {
    1dea:	f1b8 0f00 	cmp.w	r8, #0
    1dee:	da1e      	bge.n	1e2e <z_sys_mem_pool_block_free+0x7e>
	__ASSERT(0, "out of levels");
    1df0:	4a50      	ldr	r2, [pc, #320]	; (1f34 <z_sys_mem_pool_block_free+0x184>)
    1df2:	4951      	ldr	r1, [pc, #324]	; (1f38 <z_sys_mem_pool_block_free+0x188>)
    1df4:	4851      	ldr	r0, [pc, #324]	; (1f3c <z_sys_mem_pool_block_free+0x18c>)
    1df6:	23bc      	movs	r3, #188	; 0xbc
    1df8:	f022 f873 	bl	23ee2 <printk>
    1dfc:	4850      	ldr	r0, [pc, #320]	; (1f40 <z_sys_mem_pool_block_free+0x190>)
    1dfe:	f022 f870 	bl	23ee2 <printk>
    1e02:	484c      	ldr	r0, [pc, #304]	; (1f34 <z_sys_mem_pool_block_free+0x184>)
    1e04:	21bc      	movs	r1, #188	; 0xbc
    1e06:	f022 f8af 	bl	23f68 <assert_post_action>
	return -1;
    1e0a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	pool_irq_unlock(p, key);
    1e0e:	7c30      	ldrb	r0, [r6, #16]
    1e10:	4621      	mov	r1, r4
    1e12:	f021 ff3e 	bl	23c92 <pool_irq_unlock.isra.0>
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
}
    1e16:	3714      	adds	r7, #20
    1e18:	46bd      	mov	sp, r7
    1e1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
    1e1e:	680b      	ldr	r3, [r1, #0]
    1e20:	089b      	lsrs	r3, r3, #2
    1e22:	f023 0303 	bic.w	r3, r3, #3
    1e26:	f841 3f04 	str.w	r3, [r1, #4]!
	for (i = 1; i <= level; i++) {
    1e2a:	3201      	adds	r2, #1
    1e2c:	e7d4      	b.n	1dd8 <z_sys_mem_pool_block_free+0x28>
		int i, lsz = lsizes[level];
    1e2e:	f859 3028 	ldr.w	r3, [r9, r8, lsl #2]
    1e32:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
    1e34:	fb03 fb05 	mul.w	fp, r3, r5
    1e38:	6833      	ldr	r3, [r6, #0]
    1e3a:	603b      	str	r3, [r7, #0]
    1e3c:	eb03 0a0b 	add.w	sl, r3, fp
	int bit = get_bit_ptr(p, level, bn, &word);
    1e40:	462a      	mov	r2, r5
    1e42:	f107 030c 	add.w	r3, r7, #12
    1e46:	4641      	mov	r1, r8
    1e48:	4630      	mov	r0, r6
    1e4a:	f021 ff01 	bl	23c50 <get_bit_ptr>
	return (*word >> bit) & 1;
    1e4e:	68fb      	ldr	r3, [r7, #12]
    1e50:	681b      	ldr	r3, [r3, #0]
    1e52:	40c3      	lsrs	r3, r0
		__ASSERT(alloc_bit_is_set(p, level, bn),
    1e54:	07db      	lsls	r3, r3, #31
    1e56:	d40d      	bmi.n	1e74 <z_sys_mem_pool_block_free+0xc4>
    1e58:	4a36      	ldr	r2, [pc, #216]	; (1f34 <z_sys_mem_pool_block_free+0x184>)
    1e5a:	493a      	ldr	r1, [pc, #232]	; (1f44 <z_sys_mem_pool_block_free+0x194>)
    1e5c:	4837      	ldr	r0, [pc, #220]	; (1f3c <z_sys_mem_pool_block_free+0x18c>)
    1e5e:	23a2      	movs	r3, #162	; 0xa2
    1e60:	f022 f83f 	bl	23ee2 <printk>
    1e64:	4838      	ldr	r0, [pc, #224]	; (1f48 <z_sys_mem_pool_block_free+0x198>)
    1e66:	4651      	mov	r1, sl
    1e68:	f022 f83b 	bl	23ee2 <printk>
    1e6c:	4831      	ldr	r0, [pc, #196]	; (1f34 <z_sys_mem_pool_block_free+0x184>)
    1e6e:	21a2      	movs	r1, #162	; 0xa2
    1e70:	f022 f87a 	bl	23f68 <assert_post_action>
	int bit = get_bit_ptr(p, level, bn, &word);
    1e74:	f107 030c 	add.w	r3, r7, #12
    1e78:	462a      	mov	r2, r5
    1e7a:	4641      	mov	r1, r8
    1e7c:	4630      	mov	r0, r6
    1e7e:	f021 fee7 	bl	23c50 <get_bit_ptr>
	*word &= ~(1<<bit);
    1e82:	68fa      	ldr	r2, [r7, #12]
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
    1e84:	6839      	ldr	r1, [r7, #0]
    1e86:	2301      	movs	r3, #1
    1e88:	fa03 f000 	lsl.w	r0, r3, r0
    1e8c:	6813      	ldr	r3, [r2, #0]
    1e8e:	ea23 0300 	bic.w	r3, r3, r0
    1e92:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
    1e94:	68f2      	ldr	r2, [r6, #12]
    1e96:	230c      	movs	r3, #12
    1e98:	fb03 2308 	mla	r3, r3, r8, r2
    1e9c:	1d1a      	adds	r2, r3, #4
    1e9e:	f841 200b 	str.w	r2, [r1, fp]
	node->prev = list->tail;
    1ea2:	689a      	ldr	r2, [r3, #8]
    1ea4:	f8ca 2004 	str.w	r2, [sl, #4]

	list->tail->next = node;
    1ea8:	689a      	ldr	r2, [r3, #8]
    1eaa:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
    1eae:	f8c3 a008 	str.w	sl, [r3, #8]
		pool_irq_unlock(p, key);
    1eb2:	4621      	mov	r1, r4
    1eb4:	7c30      	ldrb	r0, [r6, #16]
    1eb6:	f021 feec 	bl	23c92 <pool_irq_unlock.isra.0>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    1eba:	7c34      	ldrb	r4, [r6, #16]
    1ebc:	f014 0401 	ands.w	r4, r4, #1
    1ec0:	d002      	beq.n	1ec8 <z_sys_mem_pool_block_free+0x118>
    1ec2:	f021 fedd 	bl	23c80 <pool_irq_lock.isra.0.part.0>
    1ec6:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
    1ec8:	f1b8 0f00 	cmp.w	r8, #0
    1ecc:	d09f      	beq.n	1e0e <z_sys_mem_pool_block_free+0x5e>
	int bit = get_bit_ptr(p, level, bn, &word);
    1ece:	f107 030c 	add.w	r3, r7, #12
    1ed2:	462a      	mov	r2, r5
    1ed4:	4641      	mov	r1, r8
    1ed6:	4630      	mov	r0, r6
    1ed8:	f021 feba 	bl	23c50 <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
    1edc:	68fb      	ldr	r3, [r7, #12]
    1ede:	2800      	cmp	r0, #0
    1ee0:	681b      	ldr	r3, [r3, #0]
    1ee2:	bfb8      	it	lt
    1ee4:	3003      	addlt	r0, #3
    1ee6:	f020 0003 	bic.w	r0, r0, #3
    1eea:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
    1eee:	f010 030f 	ands.w	r3, r0, #15
    1ef2:	d18c      	bne.n	1e0e <z_sys_mem_pool_block_free+0x5e>
			int b = (bn & ~3) + i;
    1ef4:	f025 0b03 	bic.w	fp, r5, #3
	node->next = NULL;
    1ef8:	469c      	mov	ip, r3
	return (u8_t *)p->buf + lsz * block;
    1efa:	6879      	ldr	r1, [r7, #4]
			int b = (bn & ~3) + i;
    1efc:	eb0b 0203 	add.w	r2, fp, r3
	return (u8_t *)p->buf + lsz * block;
    1f00:	434a      	muls	r2, r1
    1f02:	6831      	ldr	r1, [r6, #0]
    1f04:	1888      	adds	r0, r1, r2
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    1f06:	f851 e002 	ldr.w	lr, [r1, r2]
    1f0a:	f8d0 a004 	ldr.w	sl, [r0, #4]
		for (i = 0; i < 4; i++) {
    1f0e:	3301      	adds	r3, #1
    1f10:	2b04      	cmp	r3, #4
    1f12:	f8ca e000 	str.w	lr, [sl]
	node->next->prev = node->prev;
    1f16:	f8ce a004 	str.w	sl, [lr, #4]
	node->next = NULL;
    1f1a:	f841 c002 	str.w	ip, [r1, r2]
	node->prev = NULL;
    1f1e:	f8c0 c004 	str.w	ip, [r0, #4]
    1f22:	d1ea      	bne.n	1efa <z_sys_mem_pool_block_free+0x14a>
		bn = bn / 4;
    1f24:	2d00      	cmp	r5, #0
    1f26:	bfb8      	it	lt
    1f28:	3503      	addlt	r5, #3
		level = level - 1;
    1f2a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		bn = bn / 4;
    1f2e:	10ad      	asrs	r5, r5, #2
    1f30:	e75b      	b.n	1dea <z_sys_mem_pool_block_free+0x3a>
    1f32:	bf00      	nop
    1f34:	0002a8a1 	.word	0x0002a8a1
    1f38:	0002e3c9 	.word	0x0002e3c9
    1f3c:	0002a5e8 	.word	0x0002a5e8
    1f40:	0002a909 	.word	0x0002a909
    1f44:	0002a8c5 	.word	0x0002a8c5
    1f48:	0002a8e4 	.word	0x0002a8e4

00001f4c <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    1f4c:	680b      	ldr	r3, [r1, #0]
    1f4e:	3301      	adds	r3, #1
    1f50:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    1f52:	4b01      	ldr	r3, [pc, #4]	; (1f58 <char_out+0xc>)
    1f54:	681b      	ldr	r3, [r3, #0]
    1f56:	4718      	bx	r3
    1f58:	20006a94 	.word	0x20006a94

00001f5c <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    1f5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1f60:	b085      	sub	sp, #20
    1f62:	469b      	mov	fp, r3
    1f64:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    1f66:	f8df 9090 	ldr.w	r9, [pc, #144]	; 1ff8 <_printk_dec_ulong+0x9c>
    1f6a:	2c01      	cmp	r4, #1
    1f6c:	bfb8      	it	lt
    1f6e:	2401      	movlt	r4, #1
    1f70:	2b01      	cmp	r3, #1
    1f72:	bf0c      	ite	eq
    1f74:	2330      	moveq	r3, #48	; 0x30
    1f76:	2320      	movne	r3, #32
    1f78:	4615      	mov	r5, r2
    1f7a:	4606      	mov	r6, r0
    1f7c:	468a      	mov	sl, r1
    1f7e:	9302      	str	r3, [sp, #8]
    1f80:	2701      	movs	r7, #1
    1f82:	f04f 080a 	mov.w	r8, #10
    1f86:	2200      	movs	r2, #0
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
    1f88:	fbb5 f3f9 	udiv	r3, r5, r9
    1f8c:	9301      	str	r3, [sp, #4]
    1f8e:	b90a      	cbnz	r2, 1f94 <_printk_dec_ulong+0x38>
    1f90:	45a9      	cmp	r9, r5
    1f92:	d81f      	bhi.n	1fd4 <_printk_dec_ulong+0x78>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
    1f94:	9b01      	ldr	r3, [sp, #4]
    1f96:	4651      	mov	r1, sl
    1f98:	f103 0030 	add.w	r0, r3, #48	; 0x30
    1f9c:	47b0      	blx	r6
			digits++;
    1f9e:	3701      	adds	r7, #1
			found_largest_digit = 1;
    1fa0:	2201      	movs	r2, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
    1fa2:	9b01      	ldr	r3, [sp, #4]
		remaining--;
    1fa4:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
	while (pos >= 10) {
    1fa8:	f1b8 0f01 	cmp.w	r8, #1
		remainder %= pos;
    1fac:	fb09 5513 	mls	r5, r9, r3, r5
		pos /= 10;
    1fb0:	f04f 030a 	mov.w	r3, #10
    1fb4:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
    1fb8:	d1e6      	bne.n	1f88 <_printk_dec_ulong+0x2c>
	}
	out((int)(remainder + 48), ctx);
    1fba:	4651      	mov	r1, sl
    1fbc:	f105 0030 	add.w	r0, r5, #48	; 0x30
    1fc0:	47b0      	blx	r6

	if (padding == PAD_SPACE_AFTER) {
    1fc2:	f1bb 0f03 	cmp.w	fp, #3
    1fc6:	d102      	bne.n	1fce <_printk_dec_ulong+0x72>
		remaining = min_width - digits;
    1fc8:	1be4      	subs	r4, r4, r7
		while (remaining-- > 0) {
    1fca:	2c00      	cmp	r4, #0
    1fcc:	dc0e      	bgt.n	1fec <_printk_dec_ulong+0x90>
			out(' ', ctx);
		}
	}
}
    1fce:	b005      	add	sp, #20
    1fd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
    1fd4:	4544      	cmp	r4, r8
    1fd6:	dbe4      	blt.n	1fa2 <_printk_dec_ulong+0x46>
				&& padding < PAD_SPACE_AFTER) {
    1fd8:	f1bb 0f02 	cmp.w	fp, #2
    1fdc:	d8e1      	bhi.n	1fa2 <_printk_dec_ulong+0x46>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    1fde:	9802      	ldr	r0, [sp, #8]
    1fe0:	9203      	str	r2, [sp, #12]
    1fe2:	4651      	mov	r1, sl
    1fe4:	47b0      	blx	r6
			digits++;
    1fe6:	3701      	adds	r7, #1
    1fe8:	9a03      	ldr	r2, [sp, #12]
    1fea:	e7da      	b.n	1fa2 <_printk_dec_ulong+0x46>
			out(' ', ctx);
    1fec:	4651      	mov	r1, sl
    1fee:	2020      	movs	r0, #32
    1ff0:	47b0      	blx	r6
    1ff2:	3c01      	subs	r4, #1
    1ff4:	e7e9      	b.n	1fca <_printk_dec_ulong+0x6e>
    1ff6:	bf00      	nop
    1ff8:	3b9aca00 	.word	0x3b9aca00

00001ffc <__printk_hook_install>:
	_char_out = fn;
    1ffc:	4b01      	ldr	r3, [pc, #4]	; (2004 <__printk_hook_install+0x8>)
    1ffe:	6018      	str	r0, [r3, #0]
}
    2000:	4770      	bx	lr
    2002:	bf00      	nop
    2004:	20006a94 	.word	0x20006a94

00002008 <z_vprintk>:
{
    2008:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    200c:	b08d      	sub	sp, #52	; 0x34
    200e:	461c      	mov	r4, r3
	char length_mod = 0;
    2010:	2700      	movs	r7, #0
    2012:	1e53      	subs	r3, r2, #1
{
    2014:	4605      	mov	r5, r0
    2016:	468b      	mov	fp, r1
    2018:	9303      	str	r3, [sp, #12]
	int min_width = -1;
    201a:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
    201e:	46b8      	mov	r8, r7
			might_format = 0;
    2020:	2600      	movs	r6, #0
					break;
    2022:	e005      	b.n	2030 <z_vprintk+0x28>
		if (!might_format) {
    2024:	b96e      	cbnz	r6, 2042 <z_vprintk+0x3a>
			if (*fmt != '%') {
    2026:	2825      	cmp	r0, #37	; 0x25
    2028:	f000 8171 	beq.w	230e <z_vprintk+0x306>
				out((int)*fmt, ctx);
    202c:	4659      	mov	r1, fp
    202e:	47a8      	blx	r5
	while (*fmt) {
    2030:	9b03      	ldr	r3, [sp, #12]
    2032:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    2036:	9303      	str	r3, [sp, #12]
    2038:	2800      	cmp	r0, #0
    203a:	d1f3      	bne.n	2024 <z_vprintk+0x1c>
}
    203c:	b00d      	add	sp, #52	; 0x34
    203e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
    2042:	287a      	cmp	r0, #122	; 0x7a
    2044:	d80a      	bhi.n	205c <z_vprintk+0x54>
    2046:	2862      	cmp	r0, #98	; 0x62
    2048:	d810      	bhi.n	206c <z_vprintk+0x64>
    204a:	2830      	cmp	r0, #48	; 0x30
    204c:	d054      	beq.n	20f8 <z_vprintk+0xf0>
    204e:	d845      	bhi.n	20dc <z_vprintk+0xd4>
    2050:	2825      	cmp	r0, #37	; 0x25
    2052:	f000 815a 	beq.w	230a <z_vprintk+0x302>
    2056:	282d      	cmp	r0, #45	; 0x2d
    2058:	f000 815f 	beq.w	231a <z_vprintk+0x312>
					out((int)'%', ctx);
    205c:	4659      	mov	r1, fp
    205e:	2025      	movs	r0, #37	; 0x25
    2060:	47a8      	blx	r5
					out((int)*fmt, ctx);
    2062:	9b03      	ldr	r3, [sp, #12]
    2064:	7818      	ldrb	r0, [r3, #0]
    2066:	4659      	mov	r1, fp
    2068:	47a8      	blx	r5
    206a:	e7d9      	b.n	2020 <z_vprintk+0x18>
    206c:	f1a0 0363 	sub.w	r3, r0, #99	; 0x63
    2070:	2b17      	cmp	r3, #23
    2072:	d8f3      	bhi.n	205c <z_vprintk+0x54>
    2074:	a201      	add	r2, pc, #4	; (adr r2, 207c <z_vprintk+0x74>)
    2076:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    207a:	bf00      	nop
    207c:	00002303 	.word	0x00002303
    2080:	00002147 	.word	0x00002147
    2084:	0000205d 	.word	0x0000205d
    2088:	0000205d 	.word	0x0000205d
    208c:	0000205d 	.word	0x0000205d
    2090:	00002129 	.word	0x00002129
    2094:	00002147 	.word	0x00002147
    2098:	0000205d 	.word	0x0000205d
    209c:	0000205d 	.word	0x0000205d
    20a0:	00002129 	.word	0x00002129
    20a4:	0000205d 	.word	0x0000205d
    20a8:	0000205d 	.word	0x0000205d
    20ac:	0000205d 	.word	0x0000205d
    20b0:	000021e9 	.word	0x000021e9
    20b4:	0000205d 	.word	0x0000205d
    20b8:	0000205d 	.word	0x0000205d
    20bc:	000022d3 	.word	0x000022d3
    20c0:	0000205d 	.word	0x0000205d
    20c4:	000021b7 	.word	0x000021b7
    20c8:	0000205d 	.word	0x0000205d
    20cc:	0000205d 	.word	0x0000205d
    20d0:	000020e5 	.word	0x000020e5
    20d4:	0000205d 	.word	0x0000205d
    20d8:	00002129 	.word	0x00002129
			switch (*fmt) {
    20dc:	2839      	cmp	r0, #57	; 0x39
    20de:	d91a      	bls.n	2116 <z_vprintk+0x10e>
    20e0:	2858      	cmp	r0, #88	; 0x58
    20e2:	d1bb      	bne.n	205c <z_vprintk+0x54>
				if (*fmt == 'p') {
    20e4:	9b03      	ldr	r3, [sp, #12]
    20e6:	781b      	ldrb	r3, [r3, #0]
    20e8:	2b70      	cmp	r3, #112	; 0x70
    20ea:	f040 8088 	bne.w	21fe <z_vprintk+0x1f6>
					x = va_arg(ap, unsigned int);
    20ee:	f854 3b04 	ldr.w	r3, [r4], #4
    20f2:	9306      	str	r3, [sp, #24]
    20f4:	2200      	movs	r2, #0
    20f6:	e090      	b.n	221a <z_vprintk+0x212>
				if (min_width < 0 && padding == PAD_NONE) {
    20f8:	f1b9 0f00 	cmp.w	r9, #0
    20fc:	da0e      	bge.n	211c <z_vprintk+0x114>
    20fe:	f1b8 0f00 	cmp.w	r8, #0
    2102:	f000 810d 	beq.w	2320 <z_vprintk+0x318>
					min_width = *fmt - '0';
    2106:	f1a0 0930 	sub.w	r9, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
    210a:	f1b8 0f00 	cmp.w	r8, #0
    210e:	bf08      	it	eq
    2110:	f04f 0802 	moveq.w	r8, #2
    2114:	e78c      	b.n	2030 <z_vprintk+0x28>
				if (min_width < 0) {
    2116:	f1b9 0f00 	cmp.w	r9, #0
    211a:	dbf4      	blt.n	2106 <z_vprintk+0xfe>
					min_width = 10 * min_width + *fmt - '0';
    211c:	230a      	movs	r3, #10
    211e:	fb03 0909 	mla	r9, r3, r9, r0
    2122:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
    2126:	e7f0      	b.n	210a <z_vprintk+0x102>
				if (*fmt == 'h' && length_mod == 'h') {
    2128:	2868      	cmp	r0, #104	; 0x68
    212a:	d103      	bne.n	2134 <z_vprintk+0x12c>
    212c:	2f68      	cmp	r7, #104	; 0x68
    212e:	d106      	bne.n	213e <z_vprintk+0x136>
					length_mod = 'H';
    2130:	2748      	movs	r7, #72	; 0x48
    2132:	e77d      	b.n	2030 <z_vprintk+0x28>
				} else if (*fmt == 'l' && length_mod == 'l') {
    2134:	286c      	cmp	r0, #108	; 0x6c
    2136:	d102      	bne.n	213e <z_vprintk+0x136>
    2138:	2f6c      	cmp	r7, #108	; 0x6c
    213a:	f000 80f4 	beq.w	2326 <z_vprintk+0x31e>
				} else if (length_mod == 0) {
    213e:	2f00      	cmp	r7, #0
    2140:	d18c      	bne.n	205c <z_vprintk+0x54>
    2142:	4607      	mov	r7, r0
    2144:	e774      	b.n	2030 <z_vprintk+0x28>
				if (length_mod == 'z') {
    2146:	2f7a      	cmp	r7, #122	; 0x7a
    2148:	d102      	bne.n	2150 <z_vprintk+0x148>
					d = va_arg(ap, int);
    214a:	f854 6b04 	ldr.w	r6, [r4], #4
    214e:	e021      	b.n	2194 <z_vprintk+0x18c>
				} else if (length_mod == 'l') {
    2150:	2f6c      	cmp	r7, #108	; 0x6c
    2152:	d0fa      	beq.n	214a <z_vprintk+0x142>
				} else if (length_mod == 'L') {
    2154:	2f4c      	cmp	r7, #76	; 0x4c
    2156:	d1f8      	bne.n	214a <z_vprintk+0x142>
					long long lld = va_arg(ap, long long);
    2158:	3407      	adds	r4, #7
    215a:	f024 0407 	bic.w	r4, r4, #7
    215e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
    2162:	e9cd 2304 	strd	r2, r3, [sp, #16]
					if (lld > __LONG_MAX__ ||
    2166:	9b04      	ldr	r3, [sp, #16]
    2168:	f113 4100 	adds.w	r1, r3, #2147483648	; 0x80000000
    216c:	9b05      	ldr	r3, [sp, #20]
    216e:	9108      	str	r1, [sp, #32]
    2170:	f143 0100 	adc.w	r1, r3, #0
    2174:	9109      	str	r1, [sp, #36]	; 0x24
    2176:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    217a:	2100      	movs	r1, #0
    217c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2180:	4299      	cmp	r1, r3
    2182:	bf08      	it	eq
    2184:	4290      	cmpeq	r0, r2
    2186:	d204      	bcs.n	2192 <z_vprintk+0x18a>
						print_err(out, ctx);
    2188:	4659      	mov	r1, fp
    218a:	4628      	mov	r0, r5
    218c:	f021 fe88 	bl	23ea0 <print_err>
						break;
    2190:	e746      	b.n	2020 <z_vprintk+0x18>
					d = lld;
    2192:	9e04      	ldr	r6, [sp, #16]
				if (d < 0) {
    2194:	2e00      	cmp	r6, #0
    2196:	da05      	bge.n	21a4 <z_vprintk+0x19c>
					out((int)'-', ctx);
    2198:	4659      	mov	r1, fp
    219a:	202d      	movs	r0, #45	; 0x2d
    219c:	47a8      	blx	r5
					d = -d;
    219e:	4276      	negs	r6, r6
					min_width--;
    21a0:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
				_printk_dec_ulong(out, ctx, d, padding,
    21a4:	f8cd 9000 	str.w	r9, [sp]
    21a8:	4643      	mov	r3, r8
    21aa:	4632      	mov	r2, r6
				_printk_dec_ulong(out, ctx, u, padding,
    21ac:	4659      	mov	r1, fp
    21ae:	4628      	mov	r0, r5
    21b0:	f7ff fed4 	bl	1f5c <_printk_dec_ulong>
				break;
    21b4:	e734      	b.n	2020 <z_vprintk+0x18>
				if (length_mod == 'z') {
    21b6:	2f7a      	cmp	r7, #122	; 0x7a
    21b8:	d102      	bne.n	21c0 <z_vprintk+0x1b8>
					u = va_arg(ap, unsigned int);
    21ba:	f854 2b04 	ldr.w	r2, [r4], #4
    21be:	e00f      	b.n	21e0 <z_vprintk+0x1d8>
				} else if (length_mod == 'l') {
    21c0:	2f6c      	cmp	r7, #108	; 0x6c
    21c2:	d0fa      	beq.n	21ba <z_vprintk+0x1b2>
				} else if (length_mod == 'L') {
    21c4:	2f4c      	cmp	r7, #76	; 0x4c
    21c6:	d1f8      	bne.n	21ba <z_vprintk+0x1b2>
					unsigned long long llu =
    21c8:	3407      	adds	r4, #7
    21ca:	f024 0407 	bic.w	r4, r4, #7
    21ce:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
    21d2:	2100      	movs	r1, #0
    21d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    21d8:	4299      	cmp	r1, r3
    21da:	bf08      	it	eq
    21dc:	4290      	cmpeq	r0, r2
    21de:	d3d3      	bcc.n	2188 <z_vprintk+0x180>
				_printk_dec_ulong(out, ctx, u, padding,
    21e0:	f8cd 9000 	str.w	r9, [sp]
    21e4:	4643      	mov	r3, r8
    21e6:	e7e1      	b.n	21ac <z_vprintk+0x1a4>
				out('0', ctx);
    21e8:	4659      	mov	r1, fp
    21ea:	2030      	movs	r0, #48	; 0x30
    21ec:	47a8      	blx	r5
				out('x', ctx);
    21ee:	4659      	mov	r1, fp
    21f0:	2078      	movs	r0, #120	; 0x78
    21f2:	47a8      	blx	r5
					min_width = 8;
    21f4:	f04f 0908 	mov.w	r9, #8
				padding = PAD_ZERO_BEFORE;
    21f8:	f04f 0801 	mov.w	r8, #1
    21fc:	e772      	b.n	20e4 <z_vprintk+0xdc>
				} else if (length_mod == 'l') {
    21fe:	2f6c      	cmp	r7, #108	; 0x6c
    2200:	f43f af75 	beq.w	20ee <z_vprintk+0xe6>
				} else if (length_mod == 'L') {
    2204:	2f4c      	cmp	r7, #76	; 0x4c
    2206:	f47f af72 	bne.w	20ee <z_vprintk+0xe6>
					x = va_arg(ap, unsigned long long);
    220a:	1de3      	adds	r3, r4, #7
    220c:	f023 0307 	bic.w	r3, r3, #7
    2210:	461c      	mov	r4, r3
    2212:	f854 2b08 	ldr.w	r2, [r4], #8
    2216:	9206      	str	r2, [sp, #24]
    2218:	685a      	ldr	r2, [r3, #4]
	int digits = 0;
    221a:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
    221c:	2310      	movs	r3, #16
	int digits = 0;
    221e:	9104      	str	r1, [sp, #16]
	int found_largest_digit = 0;
    2220:	9107      	str	r1, [sp, #28]
	int shift = sizeof(num) * 8;
    2222:	f04f 0a40 	mov.w	sl, #64	; 0x40
		shift -= 4;
    2226:	f1aa 0a04 	sub.w	sl, sl, #4
		nibble = (num >> shift) & 0xf;
    222a:	9906      	ldr	r1, [sp, #24]
    222c:	f1ca 0e20 	rsb	lr, sl, #32
    2230:	f1aa 0c20 	sub.w	ip, sl, #32
    2234:	fa21 f00a 	lsr.w	r0, r1, sl
    2238:	fa02 fe0e 	lsl.w	lr, r2, lr
    223c:	ea40 000e 	orr.w	r0, r0, lr
    2240:	fa22 fc0c 	lsr.w	ip, r2, ip
    2244:	ea40 000c 	orr.w	r0, r0, ip
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
    2248:	f010 000f 	ands.w	r0, r0, #15
    224c:	d107      	bne.n	225e <z_vprintk+0x256>
    224e:	9907      	ldr	r1, [sp, #28]
    2250:	b911      	cbnz	r1, 2258 <z_vprintk+0x250>
    2252:	f1ba 0f00 	cmp.w	sl, #0
    2256:	d125      	bne.n	22a4 <z_vprintk+0x29c>
			nibble += nibble > 9 ? 87 : 48;
    2258:	f04f 0c30 	mov.w	ip, #48	; 0x30
    225c:	e005      	b.n	226a <z_vprintk+0x262>
    225e:	2809      	cmp	r0, #9
    2260:	bf8c      	ite	hi
    2262:	f04f 0c57 	movhi.w	ip, #87	; 0x57
    2266:	f04f 0c30 	movls.w	ip, #48	; 0x30
    226a:	4460      	add	r0, ip
			out((int)nibble, ctx);
    226c:	4659      	mov	r1, fp
    226e:	b240      	sxtb	r0, r0
    2270:	920a      	str	r2, [sp, #40]	; 0x28
    2272:	9307      	str	r3, [sp, #28]
    2274:	47a8      	blx	r5
			digits++;
    2276:	9b04      	ldr	r3, [sp, #16]
	while (shift >= 4) {
    2278:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			digits++;
    227a:	3301      	adds	r3, #1
    227c:	9304      	str	r3, [sp, #16]
	while (shift >= 4) {
    227e:	9b07      	ldr	r3, [sp, #28]
    2280:	f1ba 0f00 	cmp.w	sl, #0
    2284:	d123      	bne.n	22ce <z_vprintk+0x2c6>
	if (padding == PAD_SPACE_AFTER) {
    2286:	f1b8 0f03 	cmp.w	r8, #3
    228a:	f47f aec9 	bne.w	2020 <z_vprintk+0x18>
		remaining = min_width * 2 - digits;
    228e:	9b04      	ldr	r3, [sp, #16]
    2290:	ebc3 0649 	rsb	r6, r3, r9, lsl #1
		while (remaining-- > 0) {
    2294:	2e00      	cmp	r6, #0
    2296:	f77f aec3 	ble.w	2020 <z_vprintk+0x18>
			out(' ', ctx);
    229a:	4659      	mov	r1, fp
    229c:	2020      	movs	r0, #32
    229e:	47a8      	blx	r5
    22a0:	3e01      	subs	r6, #1
    22a2:	e7f7      	b.n	2294 <z_vprintk+0x28c>
		if (remaining-- <= min_width) {
    22a4:	1e59      	subs	r1, r3, #1
    22a6:	4599      	cmp	r9, r3
    22a8:	910a      	str	r1, [sp, #40]	; 0x28
    22aa:	db07      	blt.n	22bc <z_vprintk+0x2b4>
			if (padding == PAD_ZERO_BEFORE) {
    22ac:	f1b8 0f01 	cmp.w	r8, #1
    22b0:	d106      	bne.n	22c0 <z_vprintk+0x2b8>
    22b2:	920b      	str	r2, [sp, #44]	; 0x2c
				out('0', ctx);
    22b4:	4659      	mov	r1, fp
    22b6:	2030      	movs	r0, #48	; 0x30
				out(' ', ctx);
    22b8:	47a8      	blx	r5
    22ba:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
			nibble += nibble > 9 ? 87 : 48;
    22bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    22be:	e7b2      	b.n	2226 <z_vprintk+0x21e>
			} else if (padding == PAD_SPACE_BEFORE) {
    22c0:	f1b8 0f02 	cmp.w	r8, #2
    22c4:	d1fa      	bne.n	22bc <z_vprintk+0x2b4>
    22c6:	920b      	str	r2, [sp, #44]	; 0x2c
				out(' ', ctx);
    22c8:	4659      	mov	r1, fp
    22ca:	2020      	movs	r0, #32
    22cc:	e7f4      	b.n	22b8 <z_vprintk+0x2b0>
			found_largest_digit = 1;
    22ce:	9607      	str	r6, [sp, #28]
    22d0:	e7a9      	b.n	2226 <z_vprintk+0x21e>
				char *s = va_arg(ap, char *);
    22d2:	f854 6b04 	ldr.w	r6, [r4], #4
				while (*s) {
    22d6:	46b2      	mov	sl, r6
    22d8:	4653      	mov	r3, sl
    22da:	f81a 0b01 	ldrb.w	r0, [sl], #1
    22de:	b968      	cbnz	r0, 22fc <z_vprintk+0x2f4>
				if (padding == PAD_SPACE_AFTER) {
    22e0:	f1b8 0f03 	cmp.w	r8, #3
    22e4:	d121      	bne.n	232a <z_vprintk+0x322>
					int remaining = min_width - (s - start);
    22e6:	1b9e      	subs	r6, r3, r6
    22e8:	eba9 0606 	sub.w	r6, r9, r6
					while (remaining-- > 0) {
    22ec:	2e00      	cmp	r6, #0
    22ee:	f77f ae97 	ble.w	2020 <z_vprintk+0x18>
						out(' ', ctx);
    22f2:	4659      	mov	r1, fp
    22f4:	2020      	movs	r0, #32
    22f6:	47a8      	blx	r5
    22f8:	3e01      	subs	r6, #1
    22fa:	e7f7      	b.n	22ec <z_vprintk+0x2e4>
					out((int)(*s++), ctx);
    22fc:	4659      	mov	r1, fp
    22fe:	47a8      	blx	r5
    2300:	e7ea      	b.n	22d8 <z_vprintk+0x2d0>
				out(c, ctx);
    2302:	f854 0b04 	ldr.w	r0, [r4], #4
    2306:	4659      	mov	r1, fp
    2308:	e6ae      	b.n	2068 <z_vprintk+0x60>
				out((int)'%', ctx);
    230a:	4659      	mov	r1, fp
    230c:	e6ac      	b.n	2068 <z_vprintk+0x60>
				length_mod = 0;
    230e:	4637      	mov	r7, r6
				padding = PAD_NONE;
    2310:	46b0      	mov	r8, r6
				min_width = -1;
    2312:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
				might_format = 1;
    2316:	2601      	movs	r6, #1
    2318:	e68a      	b.n	2030 <z_vprintk+0x28>
			switch (*fmt) {
    231a:	f04f 0803 	mov.w	r8, #3
    231e:	e687      	b.n	2030 <z_vprintk+0x28>
					padding = PAD_ZERO_BEFORE;
    2320:	f04f 0801 	mov.w	r8, #1
    2324:	e684      	b.n	2030 <z_vprintk+0x28>
					length_mod = 'L';
    2326:	274c      	movs	r7, #76	; 0x4c
    2328:	e682      	b.n	2030 <z_vprintk+0x28>
			might_format = 0;
    232a:	4606      	mov	r6, r0
		++fmt;
    232c:	e680      	b.n	2030 <z_vprintk+0x28>
    232e:	bf00      	nop

00002330 <vprintk>:
{
    2330:	b507      	push	{r0, r1, r2, lr}
    2332:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
    2334:	2100      	movs	r1, #0
{
    2336:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
    2338:	9101      	str	r1, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
    233a:	4803      	ldr	r0, [pc, #12]	; (2348 <vprintk+0x18>)
    233c:	a901      	add	r1, sp, #4
    233e:	f7ff fe63 	bl	2008 <z_vprintk>
}
    2342:	b003      	add	sp, #12
    2344:	f85d fb04 	ldr.w	pc, [sp], #4
    2348:	00001f4d 	.word	0x00001f4d

0000234c <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    234c:	b530      	push	{r4, r5, lr}
    234e:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
    2350:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
    2354:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
    2356:	2500      	movs	r5, #0

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    2358:	4805      	ldr	r0, [pc, #20]	; (2370 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
    235a:	9503      	str	r5, [sp, #12]
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    235c:	a901      	add	r1, sp, #4
    235e:	f7ff fe53 	bl	2008 <z_vprintk>

	if (ctx.count < ctx.max) {
    2362:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
    2366:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
    2368:	bfb8      	it	lt
    236a:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
    236c:	b005      	add	sp, #20
    236e:	bd30      	pop	{r4, r5, pc}
    2370:	00023ebd 	.word	0x00023ebd

00002374 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
    2374:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    2376:	490e      	ldr	r1, [pc, #56]	; (23b0 <enable_logger+0x3c>)
    2378:	480e      	ldr	r0, [pc, #56]	; (23b4 <enable_logger+0x40>)
{
    237a:	b087      	sub	sp, #28
		k_timer_init(&log_process_thread_timer,
    237c:	2200      	movs	r2, #0
    237e:	f027 f871 	bl	29464 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    2382:	4d0d      	ldr	r5, [pc, #52]	; (23b8 <enable_logger+0x44>)
    2384:	490d      	ldr	r1, [pc, #52]	; (23bc <enable_logger+0x48>)
    2386:	2400      	movs	r4, #0
    2388:	230e      	movs	r3, #14
    238a:	e9cd 4302 	strd	r4, r3, [sp, #8]
    238e:	e9cd 4404 	strd	r4, r4, [sp, #16]
    2392:	e9cd 4400 	strd	r4, r4, [sp]
    2396:	4b0a      	ldr	r3, [pc, #40]	; (23c0 <enable_logger+0x4c>)
    2398:	f44f 7240 	mov.w	r2, #768	; 0x300
    239c:	4628      	mov	r0, r5
    239e:	f020 faa1 	bl	228e4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    23a2:	4908      	ldr	r1, [pc, #32]	; (23c4 <enable_logger+0x50>)
    23a4:	4628      	mov	r0, r5
    23a6:	f020 fa63 	bl	22870 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    23aa:	4620      	mov	r0, r4
    23ac:	b007      	add	sp, #28
    23ae:	bd30      	pop	{r4, r5, pc}
    23b0:	000023c9 	.word	0x000023c9
    23b4:	20000178 	.word	0x20000178
    23b8:	200001c0 	.word	0x200001c0
    23bc:	200024e0 	.word	0x200024e0
    23c0:	0000289d 	.word	0x0000289d
    23c4:	0002a919 	.word	0x0002a919

000023c8 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    23c8:	4801      	ldr	r0, [pc, #4]	; (23d0 <log_process_thread_timer_expiry_fn+0x8>)
    23ca:	f020 b971 	b.w	226b0 <z_impl_k_sem_give>
    23ce:	bf00      	nop
    23d0:	200075b0 	.word	0x200075b0

000023d4 <z_log_get_s_mask>:
	__ASSERT_NO_MSG(nargs <= 8*sizeof(mask));
    23d4:	2920      	cmp	r1, #32
{
    23d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    23d8:	4605      	mov	r5, r0
    23da:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(nargs <= 8*sizeof(mask));
    23dc:	d909      	bls.n	23f2 <z_log_get_s_mask+0x1e>
    23de:	4914      	ldr	r1, [pc, #80]	; (2430 <z_log_get_s_mask+0x5c>)
    23e0:	4814      	ldr	r0, [pc, #80]	; (2434 <z_log_get_s_mask+0x60>)
    23e2:	4a15      	ldr	r2, [pc, #84]	; (2438 <z_log_get_s_mask+0x64>)
    23e4:	235b      	movs	r3, #91	; 0x5b
    23e6:	f021 fd7c 	bl	23ee2 <printk>
    23ea:	4813      	ldr	r0, [pc, #76]	; (2438 <z_log_get_s_mask+0x64>)
    23ec:	215b      	movs	r1, #91	; 0x5b
    23ee:	f021 fdbb 	bl	23f68 <assert_post_action>
			arm = false;
    23f2:	2000      	movs	r0, #0
    23f4:	4603      	mov	r3, r0
    23f6:	4602      	mov	r2, r0
				mask |= BIT(arg);
    23f8:	2701      	movs	r7, #1
	while ((curr = *str++) && arg < nargs) {
    23fa:	f815 1b01 	ldrb.w	r1, [r5], #1
    23fe:	b109      	cbz	r1, 2404 <z_log_get_s_mask+0x30>
    2400:	42a3      	cmp	r3, r4
    2402:	d300      	bcc.n	2406 <z_log_get_s_mask+0x32>
}
    2404:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (curr == '%') {
    2406:	2925      	cmp	r1, #37	; 0x25
    2408:	d102      	bne.n	2410 <z_log_get_s_mask+0x3c>
			arm = !arm;
    240a:	f082 0201 	eor.w	r2, r2, #1
    240e:	e7f4      	b.n	23fa <z_log_get_s_mask+0x26>
		} else if (arm && isalpha((int)curr)) {
    2410:	2a00      	cmp	r2, #0
    2412:	d0f2      	beq.n	23fa <z_log_get_s_mask+0x26>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
}

static inline int isalpha(int c)
{
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    2414:	f041 0620 	orr.w	r6, r1, #32
    2418:	3e61      	subs	r6, #97	; 0x61
    241a:	2e19      	cmp	r6, #25
    241c:	d8ed      	bhi.n	23fa <z_log_get_s_mask+0x26>
			if (curr == 's') {
    241e:	2973      	cmp	r1, #115	; 0x73
				mask |= BIT(arg);
    2420:	bf04      	itt	eq
    2422:	fa07 f203 	lsleq.w	r2, r7, r3
    2426:	4310      	orreq	r0, r2
			arg++;
    2428:	3301      	adds	r3, #1
			arm = false;
    242a:	2200      	movs	r2, #0
    242c:	e7e5      	b.n	23fa <z_log_get_s_mask+0x26>
    242e:	bf00      	nop
    2430:	0002a94e 	.word	0x0002a94e
    2434:	0002a5e8 	.word	0x0002a5e8
    2438:	0002a921 	.word	0x0002a921

0000243c <log_core_init>:
{
    243c:	b508      	push	{r3, lr}
		log_msg_pool_init();
    243e:	f000 faa9 	bl	2994 <log_msg_pool_init>
		log_list_init(&list);
    2442:	4809      	ldr	r0, [pc, #36]	; (2468 <log_core_init+0x2c>)
    2444:	f021 fd98 	bl	23f78 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    2448:	2304      	movs	r3, #4
    244a:	2228      	movs	r2, #40	; 0x28
    244c:	4907      	ldr	r1, [pc, #28]	; (246c <log_core_init+0x30>)
    244e:	4808      	ldr	r0, [pc, #32]	; (2470 <log_core_init+0x34>)
    2450:	f026 feaf 	bl	291b2 <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
    2454:	4b07      	ldr	r3, [pc, #28]	; (2474 <log_core_init+0x38>)
    2456:	4a08      	ldr	r2, [pc, #32]	; (2478 <log_core_init+0x3c>)
    2458:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
    245a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
    245e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	log_output_timestamp_freq_set(freq);
    2462:	f000 bd8b 	b.w	2f7c <log_output_timestamp_freq_set>
    2466:	bf00      	nop
    2468:	20000170 	.word	0x20000170
    246c:	20004d14 	.word	0x20004d14
    2470:	200001a4 	.word	0x200001a4
    2474:	20006a98 	.word	0x20006a98
    2478:	00023fbd 	.word	0x00023fbd

0000247c <dropped_notify>:
{
    247c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    247e:	4b10      	ldr	r3, [pc, #64]	; (24c0 <dropped_notify+0x44>)
    2480:	f3bf 8f5b 	dmb	ish
    2484:	2500      	movs	r5, #0
    2486:	e853 7f00 	ldrex	r7, [r3]
    248a:	e843 5200 	strex	r2, r5, [r3]
    248e:	2a00      	cmp	r2, #0
    2490:	d1f9      	bne.n	2486 <dropped_notify+0xa>
    2492:	f3bf 8f5b 	dmb	ish
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    2496:	4c0b      	ldr	r4, [pc, #44]	; (24c4 <dropped_notify+0x48>)
    2498:	4e0b      	ldr	r6, [pc, #44]	; (24c8 <dropped_notify+0x4c>)
    249a:	1b36      	subs	r6, r6, r4
    249c:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    249e:	42b5      	cmp	r5, r6
    24a0:	db00      	blt.n	24a4 <dropped_notify+0x28>
}
    24a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (log_backend_is_active(backend)) {
    24a4:	4620      	mov	r0, r4
    24a6:	f021 fd7d 	bl	23fa4 <log_backend_is_active>
    24aa:	b128      	cbz	r0, 24b8 <dropped_notify+0x3c>
	if (backend->api->dropped != NULL) {
    24ac:	6823      	ldr	r3, [r4, #0]
    24ae:	68db      	ldr	r3, [r3, #12]
    24b0:	b113      	cbz	r3, 24b8 <dropped_notify+0x3c>
		backend->api->dropped(backend, cnt);
    24b2:	4639      	mov	r1, r7
    24b4:	4620      	mov	r0, r4
    24b6:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    24b8:	3501      	adds	r5, #1
    24ba:	3410      	adds	r4, #16
    24bc:	e7ef      	b.n	249e <dropped_notify+0x22>
    24be:	bf00      	nop
    24c0:	20000168 	.word	0x20000168
    24c4:	000299e8 	.word	0x000299e8
    24c8:	00029a08 	.word	0x00029a08

000024cc <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    24cc:	4b06      	ldr	r3, [pc, #24]	; (24e8 <log_dropped+0x1c>)
    24ce:	f3bf 8f5b 	dmb	ish
    24d2:	e853 2f00 	ldrex	r2, [r3]
    24d6:	3201      	adds	r2, #1
    24d8:	e843 2100 	strex	r1, r2, [r3]
    24dc:	2900      	cmp	r1, #0
    24de:	d1f8      	bne.n	24d2 <log_dropped+0x6>
    24e0:	f3bf 8f5b 	dmb	ish
}
    24e4:	4770      	bx	lr
    24e6:	bf00      	nop
    24e8:	20000168 	.word	0x20000168

000024ec <log_source_name_get>:
    24ec:	4a04      	ldr	r2, [pc, #16]	; (2500 <log_source_name_get+0x14>)
    24ee:	4b05      	ldr	r3, [pc, #20]	; (2504 <log_source_name_get+0x18>)
    24f0:	1a9b      	subs	r3, r3, r2
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    24f2:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
    24f6:	bf34      	ite	cc
    24f8:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
    24fc:	2000      	movcs	r0, #0
}
    24fe:	4770      	bx	lr
    2500:	00029830 	.word	0x00029830
    2504:	000299e8 	.word	0x000299e8

00002508 <log_backend_enable>:
{
    2508:	b570      	push	{r4, r5, r6, lr}
	id += backend - log_backend_get(0);
    250a:	4c10      	ldr	r4, [pc, #64]	; (254c <log_backend_enable+0x44>)
    250c:	1b04      	subs	r4, r0, r4
    250e:	1124      	asrs	r4, r4, #4
    2510:	3401      	adds	r4, #1
{
    2512:	4605      	mov	r5, r0
    2514:	460e      	mov	r6, r1
	log_backend_id_set(backend, id);
    2516:	b2e4      	uxtb	r4, r4
	__ASSERT_NO_MSG(backend != NULL);
    2518:	b948      	cbnz	r0, 252e <log_backend_enable+0x26>
    251a:	490d      	ldr	r1, [pc, #52]	; (2550 <log_backend_enable+0x48>)
    251c:	480d      	ldr	r0, [pc, #52]	; (2554 <log_backend_enable+0x4c>)
    251e:	4a0e      	ldr	r2, [pc, #56]	; (2558 <log_backend_enable+0x50>)
    2520:	23c0      	movs	r3, #192	; 0xc0
    2522:	f021 fcde 	bl	23ee2 <printk>
    2526:	480c      	ldr	r0, [pc, #48]	; (2558 <log_backend_enable+0x50>)
    2528:	21c0      	movs	r1, #192	; 0xc0
    252a:	f021 fd1d 	bl	23f68 <assert_post_action>
	backend->cb->id = id;
    252e:	686b      	ldr	r3, [r5, #4]
    2530:	711c      	strb	r4, [r3, #4]
	if (!backend_attached) {
    2532:	4c0a      	ldr	r4, [pc, #40]	; (255c <log_backend_enable+0x54>)
 */
static inline void log_backend_activate(const struct log_backend *const backend,
					void *ctx)
{
	__ASSERT_NO_MSG(backend != NULL);
	backend->cb->ctx = ctx;
    2534:	601e      	str	r6, [r3, #0]
	backend->cb->active = true;
    2536:	2201      	movs	r2, #1
    2538:	715a      	strb	r2, [r3, #5]
    253a:	7822      	ldrb	r2, [r4, #0]
    253c:	b912      	cbnz	r2, 2544 <log_backend_enable+0x3c>
    253e:	4808      	ldr	r0, [pc, #32]	; (2560 <log_backend_enable+0x58>)
    2540:	f020 f8b6 	bl	226b0 <z_impl_k_sem_give>
	backend_attached = true;
    2544:	2301      	movs	r3, #1
    2546:	7023      	strb	r3, [r4, #0]
}
    2548:	bd70      	pop	{r4, r5, r6, pc}
    254a:	bf00      	nop
    254c:	000299e8 	.word	0x000299e8
    2550:	0002a993 	.word	0x0002a993
    2554:	0002a5e8 	.word	0x0002a5e8
    2558:	0002a966 	.word	0x0002a966
    255c:	20001f30 	.word	0x20001f30
    2560:	200075b0 	.word	0x200075b0

00002564 <log_init>:
{
    2564:	b570      	push	{r4, r5, r6, lr}
	return __log_backends_end - __log_backends_start;
    2566:	4b18      	ldr	r3, [pc, #96]	; (25c8 <log_init+0x64>)
    2568:	4c18      	ldr	r4, [pc, #96]	; (25cc <log_init+0x68>)
    256a:	1ae4      	subs	r4, r4, r3
	assert(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
    256c:	2c90      	cmp	r4, #144	; 0x90
    256e:	dd0b      	ble.n	2588 <log_init+0x24>
    2570:	4917      	ldr	r1, [pc, #92]	; (25d0 <log_init+0x6c>)
    2572:	4818      	ldr	r0, [pc, #96]	; (25d4 <log_init+0x70>)
    2574:	4a18      	ldr	r2, [pc, #96]	; (25d8 <log_init+0x74>)
    2576:	f44f 73f9 	mov.w	r3, #498	; 0x1f2
    257a:	f021 fcb2 	bl	23ee2 <printk>
    257e:	4816      	ldr	r0, [pc, #88]	; (25d8 <log_init+0x74>)
    2580:	f44f 71f9 	mov.w	r1, #498	; 0x1f2
    2584:	f021 fcf0 	bl	23f68 <assert_post_action>
    2588:	f3bf 8f5b 	dmb	ish
    258c:	4b13      	ldr	r3, [pc, #76]	; (25dc <log_init+0x78>)
    258e:	e853 5f00 	ldrex	r5, [r3]
    2592:	1c6a      	adds	r2, r5, #1
    2594:	e843 2100 	strex	r1, r2, [r3]
    2598:	2900      	cmp	r1, #0
    259a:	d1f8      	bne.n	258e <log_init+0x2a>
    259c:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    25a0:	b91d      	cbnz	r5, 25aa <log_init+0x46>
    25a2:	4e09      	ldr	r6, [pc, #36]	; (25c8 <log_init+0x64>)
    25a4:	1124      	asrs	r4, r4, #4
	for (i = 0; i < log_backend_count_get(); i++) {
    25a6:	42a5      	cmp	r5, r4
    25a8:	db00      	blt.n	25ac <log_init+0x48>
}
    25aa:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
    25ac:	7b33      	ldrb	r3, [r6, #12]
    25ae:	b143      	cbz	r3, 25c2 <log_init+0x5e>
			if (backend->api->init != NULL) {
    25b0:	6833      	ldr	r3, [r6, #0]
    25b2:	695b      	ldr	r3, [r3, #20]
    25b4:	b103      	cbz	r3, 25b8 <log_init+0x54>
				backend->api->init();
    25b6:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
    25b8:	2204      	movs	r2, #4
    25ba:	2100      	movs	r1, #0
    25bc:	4630      	mov	r0, r6
    25be:	f7ff ffa3 	bl	2508 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    25c2:	3501      	adds	r5, #1
    25c4:	3610      	adds	r6, #16
    25c6:	e7ee      	b.n	25a6 <log_init+0x42>
    25c8:	000299e8 	.word	0x000299e8
    25cc:	00029a08 	.word	0x00029a08
    25d0:	0002a9aa 	.word	0x0002a9aa
    25d4:	0002a5e8 	.word	0x0002a5e8
    25d8:	0002a921 	.word	0x0002a921
    25dc:	2000016c 	.word	0x2000016c

000025e0 <log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
    25e0:	4b16      	ldr	r3, [pc, #88]	; (263c <log_strdup+0x5c>)
    25e2:	4298      	cmp	r0, r3
{
    25e4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    25e6:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
    25e8:	d302      	bcc.n	25f0 <log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    25ea:	4b15      	ldr	r3, [pc, #84]	; (2640 <log_strdup+0x60>)
    25ec:	4298      	cmp	r0, r3
    25ee:	d31f      	bcc.n	2630 <log_strdup+0x50>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    25f0:	4814      	ldr	r0, [pc, #80]	; (2644 <log_strdup+0x64>)
    25f2:	2200      	movs	r2, #0
    25f4:	a901      	add	r1, sp, #4
    25f6:	f01e f8c3 	bl	20780 <k_mem_slab_alloc>
	if (err != 0) {
    25fa:	4605      	mov	r5, r0
    25fc:	b9d8      	cbnz	r0, 2636 <log_strdup+0x56>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    25fe:	2201      	movs	r2, #1
    2600:	9b01      	ldr	r3, [sp, #4]
    2602:	f3bf 8f5b 	dmb	ish
    2606:	e853 1f00 	ldrex	r1, [r3]
    260a:	e843 2000 	strex	r0, r2, [r3]
    260e:	2800      	cmp	r0, #0
    2610:	d1f9      	bne.n	2606 <log_strdup+0x26>
    2612:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    2616:	9801      	ldr	r0, [sp, #4]
    2618:	4621      	mov	r1, r4
    261a:	221f      	movs	r2, #31
    261c:	3004      	adds	r0, #4
    261e:	f023 faf0 	bl	25c02 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    2622:	9c01      	ldr	r4, [sp, #4]
    2624:	237e      	movs	r3, #126	; 0x7e
    2626:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
    262a:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
    262e:	3404      	adds	r4, #4
}
    2630:	4620      	mov	r0, r4
    2632:	b003      	add	sp, #12
    2634:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
    2636:	4c04      	ldr	r4, [pc, #16]	; (2648 <log_strdup+0x68>)
    2638:	e7fa      	b.n	2630 <log_strdup+0x50>
    263a:	bf00      	nop
    263c:	00029580 	.word	0x00029580
    2640:	0003179c 	.word	0x0003179c
    2644:	200001a4 	.word	0x200001a4
    2648:	0002a9cd 	.word	0x0002a9cd

0000264c <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
    264c:	b148      	cbz	r0, 2662 <log_is_strdup+0x16>
    264e:	4b05      	ldr	r3, [pc, #20]	; (2664 <log_is_strdup+0x18>)
    2650:	4298      	cmp	r0, r3
    2652:	d305      	bcc.n	2660 <log_is_strdup+0x14>
    2654:	33a0      	adds	r3, #160	; 0xa0
    2656:	4298      	cmp	r0, r3
    2658:	bf2c      	ite	cs
    265a:	2000      	movcs	r0, #0
    265c:	2001      	movcc	r0, #1
    265e:	4770      	bx	lr
    2660:	2000      	movs	r0, #0
}
    2662:	4770      	bx	lr
    2664:	20004d14 	.word	0x20004d14

00002668 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
    2668:	4b4e      	ldr	r3, [pc, #312]	; (27a4 <z_impl_log_process+0x13c>)
    266a:	781b      	ldrb	r3, [r3, #0]
{
    266c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2670:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
    2672:	b903      	cbnz	r3, 2676 <z_impl_log_process+0xe>
    2674:	b360      	cbz	r0, 26d0 <z_impl_log_process+0x68>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    2676:	f04f 0320 	mov.w	r3, #32
    267a:	f3ef 8611 	mrs	r6, BASEPRI
    267e:	f383 8811 	msr	BASEPRI, r3
    2682:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
    2686:	4848      	ldr	r0, [pc, #288]	; (27a8 <z_impl_log_process+0x140>)
    2688:	f021 fc86 	bl	23f98 <log_list_head_get>
    268c:	4605      	mov	r5, r0
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    268e:	f386 8811 	msr	BASEPRI, r6
    2692:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
    2696:	b178      	cbz	r0, 26b8 <z_impl_log_process+0x50>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    2698:	f3bf 8f5b 	dmb	ish
    269c:	4b43      	ldr	r3, [pc, #268]	; (27ac <z_impl_log_process+0x144>)
    269e:	e853 2f00 	ldrex	r2, [r3]
    26a2:	3a01      	subs	r2, #1
    26a4:	e843 2100 	strex	r1, r2, [r3]
    26a8:	2900      	cmp	r1, #0
    26aa:	d1f8      	bne.n	269e <z_impl_log_process+0x36>
    26ac:	f3bf 8f5b 	dmb	ish
	if (!bypass) {
    26b0:	b194      	cbz	r4, 26d8 <z_impl_log_process+0x70>
	log_msg_put(msg);
    26b2:	4628      	mov	r0, r5
    26b4:	f021 fd6a 	bl	2418c <log_msg_put>
	if (!bypass && dropped_cnt) {
    26b8:	b924      	cbnz	r4, 26c4 <z_impl_log_process+0x5c>
    26ba:	4b3d      	ldr	r3, [pc, #244]	; (27b0 <z_impl_log_process+0x148>)
    26bc:	681b      	ldr	r3, [r3, #0]
    26be:	b10b      	cbz	r3, 26c4 <z_impl_log_process+0x5c>
		dropped_notify();
    26c0:	f7ff fedc 	bl	247c <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
    26c4:	4838      	ldr	r0, [pc, #224]	; (27a8 <z_impl_log_process+0x140>)
    26c6:	f021 fc65 	bl	23f94 <log_list_head_peek>
    26ca:	1e04      	subs	r4, r0, #0
    26cc:	bf18      	it	ne
    26ce:	2401      	movne	r4, #1
}
    26d0:	4620      	mov	r0, r4
    26d2:	b003      	add	sp, #12
    26d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
    26d8:	4b36      	ldr	r3, [pc, #216]	; (27b4 <z_impl_log_process+0x14c>)
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
    26da:	781b      	ldrb	r3, [r3, #0]
    26dc:	b9b3      	cbnz	r3, 270c <z_impl_log_process+0xa4>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    26de:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
    26e0:	07db      	lsls	r3, r3, #31
    26e2:	d413      	bmi.n	270c <z_impl_log_process+0xa4>
	msg_str = log_msg_str_get(msg);
    26e4:	f021 fd65 	bl	241b2 <log_msg_str_get>
    26e8:	4681      	mov	r9, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    26ea:	4628      	mov	r0, r5
    26ec:	f021 fd2c 	bl	24148 <log_msg_nargs_get>
    26f0:	4601      	mov	r1, r0
    26f2:	4648      	mov	r0, r9
    26f4:	f7ff fe6e 	bl	23d4 <z_log_get_s_mask>
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    26f8:	4a2f      	ldr	r2, [pc, #188]	; (27b8 <z_impl_log_process+0x150>)
    26fa:	4b30      	ldr	r3, [pc, #192]	; (27bc <z_impl_log_process+0x154>)
				__ASSERT(0, ERR_MSG, idx, src_name, msg_str);
    26fc:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 27e0 <z_impl_log_process+0x178>
    2700:	9201      	str	r2, [sp, #4]
    2702:	1a9b      	subs	r3, r3, r2
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    2704:	4607      	mov	r7, r0
    2706:	ea4f 0bd3 	mov.w	fp, r3, lsr #3
	while (mask) {
    270a:	b937      	cbnz	r7, 271a <z_impl_log_process+0xb2>
    270c:	4e2c      	ldr	r6, [pc, #176]	; (27c0 <z_impl_log_process+0x158>)
    270e:	4f2d      	ldr	r7, [pc, #180]	; (27c4 <z_impl_log_process+0x15c>)
    2710:	1bbf      	subs	r7, r7, r6
    2712:	113f      	asrs	r7, r7, #4
    2714:	f04f 0800 	mov.w	r8, #0
    2718:	e041      	b.n	279e <z_impl_log_process+0x136>
		idx = 31 - __builtin_clz(mask);
    271a:	fab7 f887 	clz	r8, r7
    271e:	f1c8 081f 	rsb	r8, r8, #31
		str = (const char *)log_msg_arg_get(msg, idx);
    2722:	4641      	mov	r1, r8
    2724:	4628      	mov	r0, r5
    2726:	f021 fd12 	bl	2414e <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
    272a:	4b27      	ldr	r3, [pc, #156]	; (27c8 <z_impl_log_process+0x160>)
    272c:	4298      	cmp	r0, r3
		str = (const char *)log_msg_arg_get(msg, idx);
    272e:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
    2730:	d302      	bcc.n	2738 <z_impl_log_process+0xd0>
		if (!is_rodata(str) && !log_is_strdup(str) &&
    2732:	4b26      	ldr	r3, [pc, #152]	; (27cc <z_impl_log_process+0x164>)
    2734:	4298      	cmp	r0, r3
    2736:	d320      	bcc.n	277a <z_impl_log_process+0x112>
    2738:	4610      	mov	r0, r2
    273a:	f7ff ff87 	bl	264c <log_is_strdup>
    273e:	4606      	mov	r6, r0
    2740:	b9d8      	cbnz	r0, 277a <z_impl_log_process+0x112>
    2742:	4b23      	ldr	r3, [pc, #140]	; (27d0 <z_impl_log_process+0x168>)
    2744:	429a      	cmp	r2, r3
    2746:	d018      	beq.n	277a <z_impl_log_process+0x112>
	return msg->hdr.ids.source_id;
    2748:	896b      	ldrh	r3, [r5, #10]
				__ASSERT(0, ERR_MSG, idx, src_name, msg_str);
    274a:	4922      	ldr	r1, [pc, #136]	; (27d4 <z_impl_log_process+0x16c>)
    274c:	4822      	ldr	r0, [pc, #136]	; (27d8 <z_impl_log_process+0x170>)
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    274e:	ebbb 1f93 	cmp.w	fp, r3, lsr #6
    2752:	ea4f 1293 	mov.w	r2, r3, lsr #6
	return __log_const_start[source_id].name;
    2756:	bf84      	itt	hi
    2758:	9b01      	ldrhi	r3, [sp, #4]
    275a:	f853 6032 	ldrhi.w	r6, [r3, r2, lsl #3]
				__ASSERT(0, ERR_MSG, idx, src_name, msg_str);
    275e:	23ad      	movs	r3, #173	; 0xad
    2760:	4652      	mov	r2, sl
    2762:	f021 fbbe 	bl	23ee2 <printk>
    2766:	481d      	ldr	r0, [pc, #116]	; (27dc <z_impl_log_process+0x174>)
    2768:	4641      	mov	r1, r8
    276a:	464b      	mov	r3, r9
    276c:	4632      	mov	r2, r6
    276e:	f021 fbb8 	bl	23ee2 <printk>
    2772:	21ad      	movs	r1, #173	; 0xad
    2774:	4650      	mov	r0, sl
    2776:	f021 fbf7 	bl	23f68 <assert_post_action>
		mask &= ~BIT(idx);
    277a:	2301      	movs	r3, #1
    277c:	fa03 f808 	lsl.w	r8, r3, r8
    2780:	ea27 0708 	bic.w	r7, r7, r8
    2784:	e7c1      	b.n	270a <z_impl_log_process+0xa2>
			if (log_backend_is_active(backend) &&
    2786:	4630      	mov	r0, r6
    2788:	f021 fc0c 	bl	23fa4 <log_backend_is_active>
    278c:	b120      	cbz	r0, 2798 <z_impl_log_process+0x130>
	backend->api->put(backend, msg);
    278e:	6833      	ldr	r3, [r6, #0]
    2790:	4629      	mov	r1, r5
    2792:	681b      	ldr	r3, [r3, #0]
    2794:	4630      	mov	r0, r6
    2796:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
    2798:	f108 0801 	add.w	r8, r8, #1
    279c:	3610      	adds	r6, #16
    279e:	45b8      	cmp	r8, r7
    27a0:	dbf1      	blt.n	2786 <z_impl_log_process+0x11e>
    27a2:	e786      	b.n	26b2 <z_impl_log_process+0x4a>
    27a4:	20001f30 	.word	0x20001f30
    27a8:	20000170 	.word	0x20000170
    27ac:	20000164 	.word	0x20000164
    27b0:	20000168 	.word	0x20000168
    27b4:	20001f31 	.word	0x20001f31
    27b8:	00029830 	.word	0x00029830
    27bc:	000299e8 	.word	0x000299e8
    27c0:	000299e8 	.word	0x000299e8
    27c4:	00029a08 	.word	0x00029a08
    27c8:	00029580 	.word	0x00029580
    27cc:	0003179c 	.word	0x0003179c
    27d0:	0002a9cd 	.word	0x0002a9cd
    27d4:	0002e3c9 	.word	0x0002e3c9
    27d8:	0002a5e8 	.word	0x0002a5e8
    27dc:	0002a9e7 	.word	0x0002a9e7
    27e0:	0002a921 	.word	0x0002a921

000027e4 <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
    27e4:	4b26      	ldr	r3, [pc, #152]	; (2880 <msg_finalize+0x9c>)
{
    27e6:	b570      	push	{r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
    27e8:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
    27ea:	8141      	strh	r1, [r0, #10]
{
    27ec:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
    27ee:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    27f0:	4d24      	ldr	r5, [pc, #144]	; (2884 <msg_finalize+0xa0>)
    27f2:	60e0      	str	r0, [r4, #12]
    27f4:	f3bf 8f5b 	dmb	ish
    27f8:	e855 3f00 	ldrex	r3, [r5]
    27fc:	3301      	adds	r3, #1
    27fe:	e845 3200 	strex	r2, r3, [r5]
    2802:	2a00      	cmp	r2, #0
    2804:	d1f8      	bne.n	27f8 <msg_finalize+0x14>
    2806:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    280a:	f04f 0320 	mov.w	r3, #32
    280e:	f3ef 8611 	mrs	r6, BASEPRI
    2812:	f383 8811 	msr	BASEPRI, r3
    2816:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    281a:	481b      	ldr	r0, [pc, #108]	; (2888 <msg_finalize+0xa4>)
    281c:	4621      	mov	r1, r4
    281e:	f021 fbaf 	bl	23f80 <log_list_add_tail>
	__asm__ volatile(
    2822:	f386 8811 	msr	BASEPRI, r6
    2826:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    282a:	4b18      	ldr	r3, [pc, #96]	; (288c <msg_finalize+0xa8>)
    282c:	781a      	ldrb	r2, [r3, #0]
    282e:	b17a      	cbz	r2, 2850 <msg_finalize+0x6c>
	__asm__ volatile(
    2830:	f04f 0320 	mov.w	r3, #32
    2834:	f3ef 8411 	mrs	r4, BASEPRI
    2838:	f383 8811 	msr	BASEPRI, r3
    283c:	f3bf 8f6f 	isb	sy
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    2840:	2000      	movs	r0, #0
    2842:	f7ff ff11 	bl	2668 <z_impl_log_process>
	__asm__ volatile(
    2846:	f384 8811 	msr	BASEPRI, r4
    284a:	f3bf 8f6f 	isb	sy
}
    284e:	bd70      	pop	{r4, r5, r6, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    2850:	490f      	ldr	r1, [pc, #60]	; (2890 <msg_finalize+0xac>)
    2852:	682b      	ldr	r3, [r5, #0]
    2854:	6809      	ldr	r1, [r1, #0]
    2856:	2900      	cmp	r1, #0
    2858:	d0f9      	beq.n	284e <msg_finalize+0x6a>
    285a:	2b01      	cmp	r3, #1
    285c:	d106      	bne.n	286c <msg_finalize+0x88>
	z_impl_k_timer_start(timer, duration, period);
    285e:	480d      	ldr	r0, [pc, #52]	; (2894 <msg_finalize+0xb0>)
}
    2860:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    2864:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    2868:	f020 bdaa 	b.w	233c0 <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    286c:	2b0a      	cmp	r3, #10
    286e:	d1ee      	bne.n	284e <msg_finalize+0x6a>
	z_impl_k_timer_stop(timer);
    2870:	4808      	ldr	r0, [pc, #32]	; (2894 <msg_finalize+0xb0>)
    2872:	f026 fe03 	bl	2947c <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    2876:	4808      	ldr	r0, [pc, #32]	; (2898 <msg_finalize+0xb4>)
}
    2878:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    287c:	f01f bf18 	b.w	226b0 <z_impl_k_sem_give>
    2880:	20006a98 	.word	0x20006a98
    2884:	20000164 	.word	0x20000164
    2888:	20000170 	.word	0x20000170
    288c:	20001f31 	.word	0x20001f31
    2890:	20000254 	.word	0x20000254
    2894:	20000178 	.word	0x20000178
    2898:	200075b0 	.word	0x200075b0

0000289c <log_process_thread_func>:
{
    289c:	b508      	push	{r3, lr}
	return __log_backends_end - __log_backends_start;
    289e:	4a15      	ldr	r2, [pc, #84]	; (28f4 <log_process_thread_func+0x58>)
    28a0:	4b15      	ldr	r3, [pc, #84]	; (28f8 <log_process_thread_func+0x5c>)
    28a2:	1a9b      	subs	r3, r3, r2
	__ASSERT_NO_MSG(log_backend_count_get() > 0);
    28a4:	2b00      	cmp	r3, #0
    28a6:	dc0b      	bgt.n	28c0 <log_process_thread_func+0x24>
    28a8:	4914      	ldr	r1, [pc, #80]	; (28fc <log_process_thread_func+0x60>)
    28aa:	4815      	ldr	r0, [pc, #84]	; (2900 <log_process_thread_func+0x64>)
    28ac:	4a15      	ldr	r2, [pc, #84]	; (2904 <log_process_thread_func+0x68>)
    28ae:	f240 437f 	movw	r3, #1151	; 0x47f
    28b2:	f021 fb16 	bl	23ee2 <printk>
    28b6:	4813      	ldr	r0, [pc, #76]	; (2904 <log_process_thread_func+0x68>)
    28b8:	f240 417f 	movw	r1, #1151	; 0x47f
    28bc:	f021 fb54 	bl	23f68 <assert_post_action>
	log_init();
    28c0:	f7ff fe50 	bl	2564 <log_init>
	return z_impl_k_current_get();
    28c4:	f01f feee 	bl	226a4 <z_impl_k_current_get>
	proc_tid = process_tid;
    28c8:	4b0f      	ldr	r3, [pc, #60]	; (2908 <log_process_thread_func+0x6c>)
    28ca:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    28cc:	b130      	cbz	r0, 28dc <log_process_thread_func+0x40>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    28ce:	4b0f      	ldr	r3, [pc, #60]	; (290c <log_process_thread_func+0x70>)
	    process_tid &&
    28d0:	681b      	ldr	r3, [r3, #0]
    28d2:	2b09      	cmp	r3, #9
    28d4:	dd02      	ble.n	28dc <log_process_thread_func+0x40>
	z_impl_k_sem_give(sem);
    28d6:	480e      	ldr	r0, [pc, #56]	; (2910 <log_process_thread_func+0x74>)
    28d8:	f01f feea 	bl	226b0 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
    28dc:	4c0c      	ldr	r4, [pc, #48]	; (2910 <log_process_thread_func+0x74>)
    28de:	2000      	movs	r0, #0
    28e0:	f7ff fec2 	bl	2668 <z_impl_log_process>
		if (log_process(false) == false) {
    28e4:	2800      	cmp	r0, #0
    28e6:	d1fa      	bne.n	28de <log_process_thread_func+0x42>
    28e8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    28ec:	4620      	mov	r0, r4
    28ee:	f01f ff23 	bl	22738 <z_impl_k_sem_take>
    28f2:	e7f4      	b.n	28de <log_process_thread_func+0x42>
    28f4:	000299e8 	.word	0x000299e8
    28f8:	00029a08 	.word	0x00029a08
    28fc:	0002aa28 	.word	0x0002aa28
    2900:	0002a5e8 	.word	0x0002a5e8
    2904:	0002a921 	.word	0x0002a921
    2908:	20000254 	.word	0x20000254
    290c:	20000164 	.word	0x20000164
    2910:	200075b0 	.word	0x200075b0

00002914 <z_impl_log_panic>:
{
    2914:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
    2916:	4f0f      	ldr	r7, [pc, #60]	; (2954 <z_impl_log_panic+0x40>)
    2918:	783d      	ldrb	r5, [r7, #0]
    291a:	b975      	cbnz	r5, 293a <z_impl_log_panic+0x26>
    291c:	4c0e      	ldr	r4, [pc, #56]	; (2958 <z_impl_log_panic+0x44>)
    291e:	4e0f      	ldr	r6, [pc, #60]	; (295c <z_impl_log_panic+0x48>)
	log_init();
    2920:	f7ff fe20 	bl	2564 <log_init>
    2924:	1b36      	subs	r6, r6, r4
    2926:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    2928:	42b5      	cmp	r5, r6
    292a:	db07      	blt.n	293c <z_impl_log_panic+0x28>
    292c:	2000      	movs	r0, #0
    292e:	f7ff fe9b 	bl	2668 <z_impl_log_process>
		while (log_process(false) == true) {
    2932:	2800      	cmp	r0, #0
    2934:	d1fa      	bne.n	292c <z_impl_log_panic+0x18>
	panic_mode = true;
    2936:	2301      	movs	r3, #1
    2938:	703b      	strb	r3, [r7, #0]
}
    293a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (log_backend_is_active(backend)) {
    293c:	4620      	mov	r0, r4
    293e:	f021 fb31 	bl	23fa4 <log_backend_is_active>
    2942:	b118      	cbz	r0, 294c <z_impl_log_panic+0x38>
	backend->api->panic(backend);
    2944:	6823      	ldr	r3, [r4, #0]
    2946:	4620      	mov	r0, r4
    2948:	691b      	ldr	r3, [r3, #16]
    294a:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    294c:	3501      	adds	r5, #1
    294e:	3410      	adds	r4, #16
    2950:	e7ea      	b.n	2928 <z_impl_log_panic+0x14>
    2952:	bf00      	nop
    2954:	20001f31 	.word	0x20001f31
    2958:	000299e8 	.word	0x000299e8
    295c:	00029a08 	.word	0x00029a08

00002960 <log_free>:
{
    2960:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    2962:	3804      	subs	r0, #4
    2964:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    2966:	f3bf 8f5b 	dmb	ish
    296a:	e850 3f00 	ldrex	r3, [r0]
    296e:	1e5a      	subs	r2, r3, #1
    2970:	e840 2100 	strex	r1, r2, [r0]
    2974:	2900      	cmp	r1, #0
    2976:	d1f8      	bne.n	296a <log_free+0xa>
    2978:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
    297c:	2b01      	cmp	r3, #1
    297e:	d103      	bne.n	2988 <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    2980:	4803      	ldr	r0, [pc, #12]	; (2990 <log_free+0x30>)
    2982:	a901      	add	r1, sp, #4
    2984:	f01d ff60 	bl	20848 <k_mem_slab_free>
}
    2988:	b003      	add	sp, #12
    298a:	f85d fb04 	ldr.w	pc, [sp], #4
    298e:	bf00      	nop
    2990:	200001a4 	.word	0x200001a4

00002994 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    2994:	2320      	movs	r3, #32
    2996:	4902      	ldr	r1, [pc, #8]	; (29a0 <log_msg_pool_init+0xc>)
    2998:	4802      	ldr	r0, [pc, #8]	; (29a4 <log_msg_pool_init+0x10>)
    299a:	461a      	mov	r2, r3
    299c:	f026 bc09 	b.w	291b2 <k_mem_slab_init>
    29a0:	20004db4 	.word	0x20004db4
    29a4:	20000258 	.word	0x20000258

000029a8 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
    29a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	union log_msg_chunk *msg = NULL;
    29aa:	2300      	movs	r3, #0

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
    29ac:	4d09      	ldr	r5, [pc, #36]	; (29d4 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
    29ae:	9301      	str	r3, [sp, #4]
    29b0:	2001      	movs	r0, #1
    29b2:	f7ff fe59 	bl	2668 <z_impl_log_process>
    29b6:	4604      	mov	r4, r0
			log_dropped();
    29b8:	f7ff fd88 	bl	24cc <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    29bc:	2200      	movs	r2, #0
    29be:	a901      	add	r1, sp, #4
    29c0:	4628      	mov	r0, r5
    29c2:	f01d fedd 	bl	20780 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
    29c6:	b108      	cbz	r0, 29cc <log_msg_no_space_handle+0x24>
    29c8:	2c00      	cmp	r4, #0
    29ca:	d1f1      	bne.n	29b0 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
    29cc:	9801      	ldr	r0, [sp, #4]
    29ce:	b003      	add	sp, #12
    29d0:	bd30      	pop	{r4, r5, pc}
    29d2:	bf00      	nop
    29d4:	20000258 	.word	0x20000258

000029d8 <log_msg_chunk_alloc>:
{
    29d8:	b507      	push	{r0, r1, r2, lr}
	union log_msg_chunk *msg = NULL;
    29da:	2200      	movs	r2, #0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    29dc:	4806      	ldr	r0, [pc, #24]	; (29f8 <log_msg_chunk_alloc+0x20>)
	union log_msg_chunk *msg = NULL;
    29de:	9201      	str	r2, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    29e0:	a901      	add	r1, sp, #4
    29e2:	f01d fecd 	bl	20780 <k_mem_slab_alloc>
	if (err != 0) {
    29e6:	b110      	cbz	r0, 29ee <log_msg_chunk_alloc+0x16>
		msg = log_msg_no_space_handle();
    29e8:	f7ff ffde 	bl	29a8 <log_msg_no_space_handle>
    29ec:	9001      	str	r0, [sp, #4]
}
    29ee:	9801      	ldr	r0, [sp, #4]
    29f0:	b003      	add	sp, #12
    29f2:	f85d fb04 	ldr.w	pc, [sp], #4
    29f6:	bf00      	nop
    29f8:	20000258 	.word	0x20000258

000029fc <msg_free>:
{
    29fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    29fe:	7a03      	ldrb	r3, [r0, #8]
	}
}

u32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
    2a00:	7a46      	ldrb	r6, [r0, #9]
{
    2a02:	b085      	sub	sp, #20
	if (log_msg_is_std(msg) && nargs) {
    2a04:	07d9      	lsls	r1, r3, #31
{
    2a06:	9001      	str	r0, [sp, #4]
	return msg->hdr.params.std.nargs;
    2a08:	ea4f 1616 	mov.w	r6, r6, lsr #4
	if (log_msg_is_std(msg) && nargs) {
    2a0c:	d50e      	bpl.n	2a2c <msg_free+0x30>
	if (msg->hdr.params.generic.ext == 1) {
    2a0e:	9b01      	ldr	r3, [sp, #4]
    2a10:	7a1a      	ldrb	r2, [r3, #8]
    2a12:	0792      	lsls	r2, r2, #30
    2a14:	d504      	bpl.n	2a20 <msg_free+0x24>
		cont_free(msg->payload.ext.next);
    2a16:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    2a18:	4c18      	ldr	r4, [pc, #96]	; (2a7c <msg_free+0x80>)
    2a1a:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
    2a1c:	9b03      	ldr	r3, [sp, #12]
    2a1e:	bb33      	cbnz	r3, 2a6e <msg_free+0x72>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    2a20:	4816      	ldr	r0, [pc, #88]	; (2a7c <msg_free+0x80>)
    2a22:	a901      	add	r1, sp, #4
    2a24:	f01d ff10 	bl	20848 <k_mem_slab_free>
}
    2a28:	b005      	add	sp, #20
    2a2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (log_msg_is_std(msg) && nargs) {
    2a2c:	2e00      	cmp	r6, #0
    2a2e:	d0ee      	beq.n	2a0e <msg_free+0x12>
		u32_t smask = 0;
    2a30:	2400      	movs	r4, #0
		for (i = 0; i < nargs; i++) {
    2a32:	4625      	mov	r5, r4
    2a34:	e017      	b.n	2a66 <msg_free+0x6a>
			void *buf = (void *)log_msg_arg_get(msg, i);
    2a36:	4629      	mov	r1, r5
    2a38:	f021 fb89 	bl	2414e <log_msg_arg_get>
    2a3c:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
    2a3e:	f7ff fe05 	bl	264c <log_is_strdup>
    2a42:	b178      	cbz	r0, 2a64 <msg_free+0x68>
				if (smask == 0) {
    2a44:	b93c      	cbnz	r4, 2a56 <msg_free+0x5a>
					smask = z_log_get_s_mask(
    2a46:	9b01      	ldr	r3, [sp, #4]
    2a48:	4631      	mov	r1, r6
    2a4a:	6918      	ldr	r0, [r3, #16]
    2a4c:	f7ff fcc2 	bl	23d4 <z_log_get_s_mask>
					if (smask == 0) {
    2a50:	4604      	mov	r4, r0
    2a52:	2800      	cmp	r0, #0
    2a54:	d0db      	beq.n	2a0e <msg_free+0x12>
				if (smask & BIT(i)) {
    2a56:	fa24 f305 	lsr.w	r3, r4, r5
    2a5a:	07db      	lsls	r3, r3, #31
    2a5c:	d502      	bpl.n	2a64 <msg_free+0x68>
					log_free(buf);
    2a5e:	4638      	mov	r0, r7
    2a60:	f7ff ff7e 	bl	2960 <log_free>
		for (i = 0; i < nargs; i++) {
    2a64:	3501      	adds	r5, #1
    2a66:	42ae      	cmp	r6, r5
    2a68:	9801      	ldr	r0, [sp, #4]
    2a6a:	d8e4      	bhi.n	2a36 <msg_free+0x3a>
    2a6c:	e7cf      	b.n	2a0e <msg_free+0x12>
		next = cont->next;
    2a6e:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    2a70:	a903      	add	r1, sp, #12
    2a72:	4620      	mov	r0, r4
    2a74:	f01d fee8 	bl	20848 <k_mem_slab_free>
		cont = next;
    2a78:	9503      	str	r5, [sp, #12]
    2a7a:	e7cf      	b.n	2a1c <msg_free+0x20>
    2a7c:	20000258 	.word	0x20000258

00002a80 <log_msg_create_n>:
	}
}

struct log_msg *log_msg_create_n(const char *str, log_arg_t *args, u32_t nargs)
{
	__ASSERT_NO_MSG(nargs < LOG_MAX_NARGS);
    2a80:	2a0e      	cmp	r2, #14
{
    2a82:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2a86:	4681      	mov	r9, r0
    2a88:	4688      	mov	r8, r1
    2a8a:	4615      	mov	r5, r2
	__ASSERT_NO_MSG(nargs < LOG_MAX_NARGS);
    2a8c:	d90b      	bls.n	2aa6 <log_msg_create_n+0x26>
    2a8e:	492d      	ldr	r1, [pc, #180]	; (2b44 <log_msg_create_n+0xc4>)
    2a90:	482d      	ldr	r0, [pc, #180]	; (2b48 <log_msg_create_n+0xc8>)
    2a92:	4a2e      	ldr	r2, [pc, #184]	; (2b4c <log_msg_create_n+0xcc>)
    2a94:	f44f 739b 	mov.w	r3, #310	; 0x136
    2a98:	f021 fa23 	bl	23ee2 <printk>
    2a9c:	482b      	ldr	r0, [pc, #172]	; (2b4c <log_msg_create_n+0xcc>)
    2a9e:	f44f 719b 	mov.w	r1, #310	; 0x136
    2aa2:	f021 fa61 	bl	23f68 <assert_post_action>
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    2aa6:	f7ff ff97 	bl	29d8 <log_msg_chunk_alloc>

	if (msg != NULL) {
    2aaa:	4604      	mov	r4, r0
    2aac:	b330      	cbz	r0, 2afc <log_msg_create_n+0x7c>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    2aae:	2301      	movs	r3, #1
		msg->hdr.params.raw = 0U;
    2ab0:	2700      	movs	r7, #0
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    2ab2:	2d03      	cmp	r5, #3
		msg->hdr.ref_cnt = 1;
    2ab4:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    2ab6:	8107      	strh	r7, [r0, #8]
    2ab8:	d909      	bls.n	2ace <log_msg_create_n+0x4e>
	msg->hdr.params.generic.ext = 1;
    2aba:	2202      	movs	r2, #2
    2abc:	8102      	strh	r2, [r0, #8]
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
    2abe:	f1a5 0a02 	sub.w	sl, r5, #2
	next = &msg->payload.ext.next;
    2ac2:	f100 0b14 	add.w	fp, r0, #20
	*next = NULL;
    2ac6:	6147      	str	r7, [r0, #20]
	while (n > 0) {
    2ac8:	f1ba 0f00 	cmp.w	sl, #0
    2acc:	dc0e      	bgt.n	2aec <log_msg_create_n+0x6c>

	msg = msg_alloc(nargs);

	if (msg != NULL) {
		msg->str = str;
		msg->hdr.params.std.nargs = nargs;
    2ace:	7a63      	ldrb	r3, [r4, #9]
		msg->str = str;
    2ad0:	f8c4 9010 	str.w	r9, [r4, #16]
		msg->hdr.params.std.nargs = nargs;
    2ad4:	f365 1307 	bfi	r3, r5, #4, #4
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
    2ad8:	2d03      	cmp	r5, #3
		msg->hdr.params.std.nargs = nargs;
    2ada:	7263      	strb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
    2adc:	d818      	bhi.n	2b10 <log_msg_create_n+0x90>
		(void)memcpy(msg->payload.single.args, args,
    2ade:	00aa      	lsls	r2, r5, #2
    2ae0:	4641      	mov	r1, r8
    2ae2:	f104 0014 	add.w	r0, r4, #20
    2ae6:	f023 f8df 	bl	25ca8 <memcpy>
	while (nargs != 0U) {
    2aea:	e007      	b.n	2afc <log_msg_create_n+0x7c>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
    2aec:	f7ff ff74 	bl	29d8 <log_msg_chunk_alloc>
		if (cont == NULL) {
    2af0:	4606      	mov	r6, r0
    2af2:	b930      	cbnz	r0, 2b02 <log_msg_create_n+0x82>
			msg_free(msg);
    2af4:	4620      	mov	r0, r4
    2af6:	f7ff ff81 	bl	29fc <msg_free>
			return NULL;
    2afa:	4634      	mov	r4, r6
		copy_args_to_msg(msg, args, nargs);
	}

	return msg;
}
    2afc:	4620      	mov	r0, r4
    2afe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*next = cont;
    2b02:	f8cb 0000 	str.w	r0, [fp]
		cont->next = NULL;
    2b06:	f1aa 0a07 	sub.w	sl, sl, #7
    2b0a:	6007      	str	r7, [r0, #0]
		next = &cont->next;
    2b0c:	4683      	mov	fp, r0
		n -= ARGS_CONT_MSG;
    2b0e:	e7db      	b.n	2ac8 <log_msg_create_n+0x48>
		(void)memcpy(msg->payload.ext.data.args, args,
    2b10:	4641      	mov	r1, r8
    2b12:	2208      	movs	r2, #8
    2b14:	f104 0018 	add.w	r0, r4, #24
	struct log_msg_cont *cont = msg->payload.ext.next;
    2b18:	6967      	ldr	r7, [r4, #20]
		(void)memcpy(msg->payload.ext.data.args, args,
    2b1a:	f023 f8c5 	bl	25ca8 <memcpy>
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
    2b1e:	3d02      	subs	r5, #2
		args += LOG_MSG_NARGS_HEAD_CHUNK;
    2b20:	f108 0808 	add.w	r8, r8, #8
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
    2b24:	2d07      	cmp	r5, #7
    2b26:	462e      	mov	r6, r5
    2b28:	bf28      	it	cs
    2b2a:	2607      	movcs	r6, #7
		(void)memcpy(cont->payload.args, args,
    2b2c:	ea4f 0986 	mov.w	r9, r6, lsl #2
    2b30:	4641      	mov	r1, r8
    2b32:	1d38      	adds	r0, r7, #4
    2b34:	464a      	mov	r2, r9
    2b36:	f023 f8b7 	bl	25ca8 <memcpy>
	while (nargs != 0U) {
    2b3a:	1bad      	subs	r5, r5, r6
		cont = cont->next;
    2b3c:	683f      	ldr	r7, [r7, #0]
		args += cpy_args;
    2b3e:	44c8      	add	r8, r9
	while (nargs != 0U) {
    2b40:	d1f0      	bne.n	2b24 <log_msg_create_n+0xa4>
    2b42:	e7db      	b.n	2afc <log_msg_create_n+0x7c>
    2b44:	0002aa74 	.word	0x0002aa74
    2b48:	0002a5e8 	.word	0x0002a5e8
    2b4c:	0002aa48 	.word	0x0002aa48

00002b50 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
    2b50:	b40e      	push	{r1, r2, r3}
    2b52:	b503      	push	{r0, r1, lr}
    2b54:	ab03      	add	r3, sp, #12
    2b56:	4601      	mov	r1, r0
    2b58:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
    2b5c:	4804      	ldr	r0, [pc, #16]	; (2b70 <print_formatted+0x20>)
	va_start(args, fmt);
    2b5e:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
    2b60:	f7ff fa52 	bl	2008 <z_vprintk>
#endif
	va_end(args);

	return length;
}
    2b64:	2000      	movs	r0, #0
    2b66:	b002      	add	sp, #8
    2b68:	f85d eb04 	ldr.w	lr, [sp], #4
    2b6c:	b003      	add	sp, #12
    2b6e:	4770      	bx	lr
    2b70:	00002da9 	.word	0x00002da9

00002b74 <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
    2b74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2b78:	b085      	sub	sp, #20
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
    2b7a:	f011 0402 	ands.w	r4, r1, #2
{
    2b7e:	4690      	mov	r8, r2
    2b80:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
    2b84:	4606      	mov	r6, r0
    2b86:	461a      	mov	r2, r3
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    2b88:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    2b8c:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
    2b90:	d007      	beq.n	2ba2 <prefix_print+0x2e>
	if (!format) {
    2b92:	f011 0f44 	tst.w	r1, #68	; 0x44
    2b96:	d137      	bne.n	2c08 <prefix_print+0x94>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
    2b98:	4932      	ldr	r1, [pc, #200]	; (2c64 <prefix_print+0xf0>)
    2b9a:	f7ff ffd9 	bl	2b50 <print_formatted>
			length = print_formatted(log_output,
    2b9e:	4601      	mov	r1, r0
		length += timestamp_print(log_output, flags, timestamp);
    2ba0:	460c      	mov	r4, r1
	if (color) {
    2ba2:	f1b9 0f00 	cmp.w	r9, #0
    2ba6:	d00a      	beq.n	2bbe <prefix_print+0x4a>
		const char *color = start && (colors[level] != NULL) ?
    2ba8:	4b2f      	ldr	r3, [pc, #188]	; (2c68 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
    2baa:	4930      	ldr	r1, [pc, #192]	; (2c6c <prefix_print+0xf8>)
		const char *color = start && (colors[level] != NULL) ?
    2bac:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
    2bb0:	4b2f      	ldr	r3, [pc, #188]	; (2c70 <prefix_print+0xfc>)
    2bb2:	4630      	mov	r0, r6
    2bb4:	2a00      	cmp	r2, #0
    2bb6:	bf08      	it	eq
    2bb8:	461a      	moveq	r2, r3
    2bba:	f7ff ffc9 	bl	2b50 <print_formatted>
	if (level_on) {
    2bbe:	b13d      	cbz	r5, 2bd0 <prefix_print+0x5c>
		total += print_formatted(log_output, "<%s> ", severity[level]);
    2bc0:	4b2c      	ldr	r3, [pc, #176]	; (2c74 <prefix_print+0x100>)
    2bc2:	492d      	ldr	r1, [pc, #180]	; (2c78 <prefix_print+0x104>)
    2bc4:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
    2bc8:	4630      	mov	r0, r6
    2bca:	f7ff ffc1 	bl	2b50 <print_formatted>
    2bce:	4605      	mov	r5, r0
	total += print_formatted(log_output,
    2bd0:	f1b8 0f00 	cmp.w	r8, #0
    2bd4:	d043      	beq.n	2c5e <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    2bd6:	2301      	movs	r3, #1
    2bd8:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
    2bdc:	4b27      	ldr	r3, [pc, #156]	; (2c7c <prefix_print+0x108>)
    2bde:	f017 0f10 	tst.w	r7, #16
    2be2:	4f27      	ldr	r7, [pc, #156]	; (2c80 <prefix_print+0x10c>)
    2be4:	bf18      	it	ne
    2be6:	461f      	movne	r7, r3
    2be8:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
    2bec:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
    2bf0:	f7ff fc7c 	bl	24ec <log_source_name_get>
    2bf4:	4639      	mov	r1, r7
    2bf6:	4602      	mov	r2, r0
    2bf8:	4630      	mov	r0, r6
    2bfa:	f7ff ffa9 	bl	2b50 <print_formatted>
    2bfe:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
    2c00:	4420      	add	r0, r4
    2c02:	b005      	add	sp, #20
    2c04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
    2c08:	4b1e      	ldr	r3, [pc, #120]	; (2c84 <prefix_print+0x110>)
    2c0a:	6819      	ldr	r1, [r3, #0]
    2c0c:	2900      	cmp	r1, #0
    2c0e:	d0c7      	beq.n	2ba0 <prefix_print+0x2c>
		timestamp /= timestamp_div;
    2c10:	4b1d      	ldr	r3, [pc, #116]	; (2c88 <prefix_print+0x114>)
    2c12:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
    2c16:	681b      	ldr	r3, [r3, #0]
    2c18:	fbb2 f3f3 	udiv	r3, r2, r3
		ms = (remainder * 1000U) / freq;
    2c1c:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		seconds = timestamp / freq;
    2c20:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
    2c24:	fbb4 f2fe 	udiv	r2, r4, lr
    2c28:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
    2c2c:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
    2c30:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
    2c34:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    2c38:	fbb4 fbf1 	udiv	fp, r4, r1
    2c3c:	fb01 441b 	mls	r4, r1, fp, r4
    2c40:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
    2c44:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    2c48:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
    2c4c:	e9cd b101 	strd	fp, r1, [sp, #4]
    2c50:	fb0a e113 	mls	r1, sl, r3, lr
    2c54:	9100      	str	r1, [sp, #0]
    2c56:	490d      	ldr	r1, [pc, #52]	; (2c8c <prefix_print+0x118>)
    2c58:	f7ff ff7a 	bl	2b50 <print_formatted>
    2c5c:	e79f      	b.n	2b9e <prefix_print+0x2a>
	total += print_formatted(log_output,
    2c5e:	4f08      	ldr	r7, [pc, #32]	; (2c80 <prefix_print+0x10c>)
    2c60:	e7c2      	b.n	2be8 <prefix_print+0x74>
    2c62:	bf00      	nop
    2c64:	0002aa8d 	.word	0x0002aa8d
    2c68:	00029b30 	.word	0x00029b30
    2c6c:	0002f98a 	.word	0x0002f98a
    2c70:	0002aa7f 	.word	0x0002aa7f
    2c74:	00029b44 	.word	0x00029b44
    2c78:	0002aab2 	.word	0x0002aab2
    2c7c:	0002aa89 	.word	0x0002aa89
    2c80:	0002aa84 	.word	0x0002aa84
    2c84:	20000274 	.word	0x20000274
    2c88:	20000278 	.word	0x20000278
    2c8c:	0002aa96 	.word	0x0002aa96

00002c90 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
    2c90:	b538      	push	{r3, r4, r5, lr}
    2c92:	460c      	mov	r4, r1
	if (color) {
    2c94:	07e1      	lsls	r1, r4, #31
{
    2c96:	4605      	mov	r5, r0
	if (color) {
    2c98:	d503      	bpl.n	2ca2 <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
    2c9a:	4a08      	ldr	r2, [pc, #32]	; (2cbc <postfix_print+0x2c>)
    2c9c:	4908      	ldr	r1, [pc, #32]	; (2cc0 <postfix_print+0x30>)
    2c9e:	f7ff ff57 	bl	2b50 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    2ca2:	06e2      	lsls	r2, r4, #27
    2ca4:	d408      	bmi.n	2cb8 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    2ca6:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
    2ca8:	4628      	mov	r0, r5
		print_formatted(ctx, "\n");
    2caa:	bf4c      	ite	mi
    2cac:	4905      	ldrmi	r1, [pc, #20]	; (2cc4 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
    2cae:	4906      	ldrpl	r1, [pc, #24]	; (2cc8 <postfix_print+0x38>)
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
    2cb0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\r\n");
    2cb4:	f7ff bf4c 	b.w	2b50 <print_formatted>
}
    2cb8:	bd38      	pop	{r3, r4, r5, pc}
    2cba:	bf00      	nop
    2cbc:	0002aa7f 	.word	0x0002aa7f
    2cc0:	0002f98a 	.word	0x0002f98a
    2cc4:	00030d24 	.word	0x00030d24
    2cc8:	0002aab8 	.word	0x0002aab8

00002ccc <hexdump_line_print>:
{
    2ccc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2cd0:	461d      	mov	r5, r3
    2cd2:	9b08      	ldr	r3, [sp, #32]
    2cd4:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    2cd6:	06da      	lsls	r2, r3, #27
{
    2cd8:	4604      	mov	r4, r0
    2cda:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    2cdc:	d405      	bmi.n	2cea <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    2cde:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
    2ce0:	bf4c      	ite	mi
    2ce2:	492a      	ldrmi	r1, [pc, #168]	; (2d8c <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
    2ce4:	492a      	ldrpl	r1, [pc, #168]	; (2d90 <hexdump_line_print+0xc4>)
    2ce6:	f7ff ff33 	bl	2b50 <print_formatted>
		print_formatted(log_output, " ");
    2cea:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 2d98 <hexdump_line_print+0xcc>
{
    2cee:	f04f 0800 	mov.w	r8, #0
	for (int i = 0; i < prefix_offset; i++) {
    2cf2:	45a8      	cmp	r8, r5
    2cf4:	db2a      	blt.n	2d4c <hexdump_line_print+0x80>
			print_formatted(log_output, "   ");
    2cf6:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 2d9c <hexdump_line_print+0xd0>
			print_formatted(log_output, "%02x ", data[i]);
    2cfa:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 2da0 <hexdump_line_print+0xd4>
			print_formatted(log_output, " ");
    2cfe:	f8df a098 	ldr.w	sl, [pc, #152]	; 2d98 <hexdump_line_print+0xcc>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2d02:	2500      	movs	r5, #0
		if (i < length) {
    2d04:	42bd      	cmp	r5, r7
    2d06:	d22f      	bcs.n	2d68 <hexdump_line_print+0x9c>
			print_formatted(log_output, "%02x ", data[i]);
    2d08:	5d72      	ldrb	r2, [r6, r5]
    2d0a:	4649      	mov	r1, r9
    2d0c:	4620      	mov	r0, r4
    2d0e:	f7ff ff1f 	bl	2b50 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2d12:	3501      	adds	r5, #1
    2d14:	2d10      	cmp	r5, #16
    2d16:	d120      	bne.n	2d5a <hexdump_line_print+0x8e>
	print_formatted(log_output, "|");
    2d18:	491e      	ldr	r1, [pc, #120]	; (2d94 <hexdump_line_print+0xc8>)
			print_formatted(log_output, " ");
    2d1a:	f8df 807c 	ldr.w	r8, [pc, #124]	; 2d98 <hexdump_line_print+0xcc>
			print_formatted(log_output, "%c",
    2d1e:	f8df 9084 	ldr.w	r9, [pc, #132]	; 2da4 <hexdump_line_print+0xd8>
	print_formatted(log_output, "|");
    2d22:	4620      	mov	r0, r4
    2d24:	f7ff ff14 	bl	2b50 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2d28:	2500      	movs	r5, #0
		if (i < length) {
    2d2a:	42af      	cmp	r7, r5
    2d2c:	d928      	bls.n	2d80 <hexdump_line_print+0xb4>
			      isprint((int)c) ? c : '.');
    2d2e:	5d72      	ldrb	r2, [r6, r5]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isprint(int c)
{
	return (int)((((unsigned)c) >= ' ') &&
    2d30:	f1a2 0320 	sub.w	r3, r2, #32
			print_formatted(log_output, "%c",
    2d34:	2b5f      	cmp	r3, #95	; 0x5f
    2d36:	bf28      	it	cs
    2d38:	222e      	movcs	r2, #46	; 0x2e
    2d3a:	4649      	mov	r1, r9
    2d3c:	4620      	mov	r0, r4
    2d3e:	f7ff ff07 	bl	2b50 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2d42:	3501      	adds	r5, #1
    2d44:	2d10      	cmp	r5, #16
    2d46:	d114      	bne.n	2d72 <hexdump_line_print+0xa6>
}
    2d48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
    2d4c:	4649      	mov	r1, r9
    2d4e:	4620      	mov	r0, r4
    2d50:	f7ff fefe 	bl	2b50 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    2d54:	f108 0801 	add.w	r8, r8, #1
    2d58:	e7cb      	b.n	2cf2 <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
    2d5a:	076a      	lsls	r2, r5, #29
    2d5c:	d1d2      	bne.n	2d04 <hexdump_line_print+0x38>
			print_formatted(log_output, " ");
    2d5e:	4651      	mov	r1, sl
    2d60:	4620      	mov	r0, r4
    2d62:	f7ff fef5 	bl	2b50 <print_formatted>
    2d66:	e7cd      	b.n	2d04 <hexdump_line_print+0x38>
			print_formatted(log_output, "   ");
    2d68:	4641      	mov	r1, r8
    2d6a:	4620      	mov	r0, r4
    2d6c:	f7ff fef0 	bl	2b50 <print_formatted>
    2d70:	e7cf      	b.n	2d12 <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
    2d72:	076b      	lsls	r3, r5, #29
    2d74:	d1d9      	bne.n	2d2a <hexdump_line_print+0x5e>
			print_formatted(log_output, " ");
    2d76:	4641      	mov	r1, r8
    2d78:	4620      	mov	r0, r4
    2d7a:	f7ff fee9 	bl	2b50 <print_formatted>
    2d7e:	e7d4      	b.n	2d2a <hexdump_line_print+0x5e>
			print_formatted(log_output, " ");
    2d80:	4641      	mov	r1, r8
    2d82:	4620      	mov	r0, r4
    2d84:	f7ff fee4 	bl	2b50 <print_formatted>
    2d88:	e7db      	b.n	2d42 <hexdump_line_print+0x76>
    2d8a:	bf00      	nop
    2d8c:	00030d24 	.word	0x00030d24
    2d90:	0002aab8 	.word	0x0002aab8
    2d94:	0002aac5 	.word	0x0002aac5
    2d98:	0002aac3 	.word	0x0002aac3
    2d9c:	0002aac1 	.word	0x0002aac1
    2da0:	0002aabb 	.word	0x0002aabb
    2da4:	0002aac7 	.word	0x0002aac7

00002da8 <out_func>:
{
    2da8:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
    2daa:	684b      	ldr	r3, [r1, #4]
    2dac:	681a      	ldr	r2, [r3, #0]
    2dae:	68cb      	ldr	r3, [r1, #12]
    2db0:	429a      	cmp	r2, r3
{
    2db2:	4605      	mov	r5, r0
    2db4:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
    2db6:	d102      	bne.n	2dbe <out_func+0x16>
		log_output_flush(out_ctx);
    2db8:	4608      	mov	r0, r1
    2dba:	f021 fb6d 	bl	24498 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    2dbe:	6863      	ldr	r3, [r4, #4]
    2dc0:	f3bf 8f5b 	dmb	ish
    2dc4:	e853 2f00 	ldrex	r2, [r3]
    2dc8:	1c51      	adds	r1, r2, #1
    2dca:	e843 1000 	strex	r0, r1, [r3]
    2dce:	2800      	cmp	r0, #0
    2dd0:	d1f8      	bne.n	2dc4 <out_func+0x1c>
    2dd2:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (u8_t)c;
    2dd6:	68a3      	ldr	r3, [r4, #8]
    2dd8:	549d      	strb	r5, [r3, r2]
	__ASSERT_NO_MSG(out_ctx->control_block->offset <= out_ctx->size);
    2dda:	6863      	ldr	r3, [r4, #4]
    2ddc:	681a      	ldr	r2, [r3, #0]
    2dde:	68e3      	ldr	r3, [r4, #12]
    2de0:	429a      	cmp	r2, r3
    2de2:	d909      	bls.n	2df8 <out_func+0x50>
    2de4:	4905      	ldr	r1, [pc, #20]	; (2dfc <out_func+0x54>)
    2de6:	4806      	ldr	r0, [pc, #24]	; (2e00 <out_func+0x58>)
    2de8:	4a06      	ldr	r2, [pc, #24]	; (2e04 <out_func+0x5c>)
    2dea:	2378      	movs	r3, #120	; 0x78
    2dec:	f021 f879 	bl	23ee2 <printk>
    2df0:	4804      	ldr	r0, [pc, #16]	; (2e04 <out_func+0x5c>)
    2df2:	2178      	movs	r1, #120	; 0x78
    2df4:	f021 f8b8 	bl	23f68 <assert_post_action>
}
    2df8:	2000      	movs	r0, #0
    2dfa:	bd38      	pop	{r3, r4, r5, pc}
    2dfc:	0002aaf9 	.word	0x0002aaf9
    2e00:	0002a5e8 	.word	0x0002a5e8
    2e04:	0002aaca 	.word	0x0002aaca

00002e08 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
    2e08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
    2e0c:	7a8b      	ldrb	r3, [r1, #10]
		log_output_msg_syst_process(log_output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    2e0e:	f013 0707 	ands.w	r7, r3, #7
{
    2e12:	4616      	mov	r6, r2
    2e14:	b08a      	sub	sp, #40	; 0x28
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    2e16:	7a0a      	ldrb	r2, [r1, #8]
    2e18:	4604      	mov	r4, r0
    2e1a:	460d      	mov	r5, r1
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    2e1c:	d01f      	beq.n	2e5e <log_output_msg_process+0x56>
	return msg->hdr.ids.source_id;
    2e1e:	8949      	ldrh	r1, [r1, #10]
    2e20:	f3c3 03c2 	ubfx	r3, r3, #3, #3
    2e24:	0989      	lsrs	r1, r1, #6
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    2e26:	43d2      	mvns	r2, r2
    2e28:	e9cd 7300 	strd	r7, r3, [sp]
    2e2c:	9102      	str	r1, [sp, #8]
    2e2e:	68eb      	ldr	r3, [r5, #12]
    2e30:	f002 0201 	and.w	r2, r2, #1
    2e34:	4631      	mov	r1, r6
    2e36:	f7ff fe9d 	bl	2b74 <prefix_print>
    2e3a:	4681      	mov	r9, r0
    2e3c:	7a2b      	ldrb	r3, [r5, #8]
    2e3e:	43db      	mvns	r3, r3
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
    2e40:	f013 0801 	ands.w	r8, r3, #1
    2e44:	d00d      	beq.n	2e62 <log_output_msg_process+0x5a>
		std_print(msg, log_output);
    2e46:	4621      	mov	r1, r4
    2e48:	4628      	mov	r0, r5
    2e4a:	f021 f9c8 	bl	241de <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
    2e4e:	2f00      	cmp	r7, #0
    2e50:	d03c      	beq.n	2ecc <log_output_msg_process+0xc4>
		postfix_print(log_output, flags, level);
    2e52:	463a      	mov	r2, r7
    2e54:	4631      	mov	r1, r6
    2e56:	4620      	mov	r0, r4
    2e58:	f7ff ff1a 	bl	2c90 <postfix_print>
    2e5c:	e036      	b.n	2ecc <log_output_msg_process+0xc4>
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    2e5e:	46b9      	mov	r9, r7
    2e60:	e7ec      	b.n	2e3c <log_output_msg_process+0x34>
	} else if (raw_string) {
    2e62:	2f00      	cmp	r7, #0
    2e64:	d138      	bne.n	2ed8 <log_output_msg_process+0xd0>
	__ASSERT_NO_MSG(log_output->size);
    2e66:	68e3      	ldr	r3, [r4, #12]
    2e68:	b95b      	cbnz	r3, 2e82 <log_output_msg_process+0x7a>
    2e6a:	492a      	ldr	r1, [pc, #168]	; (2f14 <log_output_msg_process+0x10c>)
    2e6c:	482a      	ldr	r0, [pc, #168]	; (2f18 <log_output_msg_process+0x110>)
    2e6e:	4a2b      	ldr	r2, [pc, #172]	; (2f1c <log_output_msg_process+0x114>)
    2e70:	f240 13b9 	movw	r3, #441	; 0x1b9
    2e74:	f021 f835 	bl	23ee2 <printk>
    2e78:	4828      	ldr	r0, [pc, #160]	; (2f1c <log_output_msg_process+0x114>)
    2e7a:	f240 11b9 	movw	r1, #441	; 0x1b9
    2e7e:	f021 f873 	bl	23f68 <assert_post_action>
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    2e82:	2600      	movs	r6, #0
		length = log_output->size;
    2e84:	68e3      	ldr	r3, [r4, #12]
    2e86:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    2e88:	aa06      	add	r2, sp, #24
    2e8a:	4633      	mov	r3, r6
    2e8c:	68a1      	ldr	r1, [r4, #8]
    2e8e:	4628      	mov	r0, r5
    2e90:	f021 f991 	bl	241b6 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
    2e94:	9a06      	ldr	r2, [sp, #24]
    2e96:	6863      	ldr	r3, [r4, #4]
    2e98:	601a      	str	r2, [r3, #0]
		if (length != 0) {
    2e9a:	b14a      	cbz	r2, 2eb0 <log_output_msg_process+0xa8>
			eol = (log_output->buf[length - 1] == '\n');
    2e9c:	68a3      	ldr	r3, [r4, #8]
    2e9e:	4413      	add	r3, r2
    2ea0:	f813 8c01 	ldrb.w	r8, [r3, #-1]
    2ea4:	f1a8 030a 	sub.w	r3, r8, #10
    2ea8:	f1d3 0800 	rsbs	r8, r3, #0
    2eac:	eb48 0803 	adc.w	r8, r8, r3
		log_output_flush(log_output);
    2eb0:	4620      	mov	r0, r4
    2eb2:	f021 faf1 	bl	24498 <log_output_flush>
		offset += length;
    2eb6:	9b06      	ldr	r3, [sp, #24]
    2eb8:	441e      	add	r6, r3
	} while (length > 0);
    2eba:	2b00      	cmp	r3, #0
    2ebc:	d1e2      	bne.n	2e84 <log_output_msg_process+0x7c>
	if (eol) {
    2ebe:	f1b8 0f00 	cmp.w	r8, #0
    2ec2:	d003      	beq.n	2ecc <log_output_msg_process+0xc4>
		print_formatted(log_output, "\r");
    2ec4:	4916      	ldr	r1, [pc, #88]	; (2f20 <log_output_msg_process+0x118>)
    2ec6:	4620      	mov	r0, r4
    2ec8:	f7ff fe42 	bl	2b50 <print_formatted>
	}

	log_output_flush(log_output);
    2ecc:	4620      	mov	r0, r4
    2ece:	f021 fae3 	bl	24498 <log_output_flush>
}
    2ed2:	b00a      	add	sp, #40	; 0x28
    2ed4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(log_output, "%s", log_msg_str_get(msg));
    2ed8:	4628      	mov	r0, r5
    2eda:	f021 f96a 	bl	241b2 <log_msg_str_get>
    2ede:	4911      	ldr	r1, [pc, #68]	; (2f24 <log_output_msg_process+0x11c>)
    2ee0:	4602      	mov	r2, r0
    2ee2:	4620      	mov	r0, r4
    2ee4:	f7ff fe34 	bl	2b50 <print_formatted>
		length = sizeof(buf);
    2ee8:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    2eec:	aa05      	add	r2, sp, #20
    2eee:	4643      	mov	r3, r8
    2ef0:	a906      	add	r1, sp, #24
    2ef2:	4628      	mov	r0, r5
		length = sizeof(buf);
    2ef4:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    2ef8:	f021 f95d 	bl	241b6 <log_msg_hexdump_data_get>
		if (length) {
    2efc:	9a05      	ldr	r2, [sp, #20]
    2efe:	2a00      	cmp	r2, #0
    2f00:	d0a7      	beq.n	2e52 <log_output_msg_process+0x4a>
			hexdump_line_print(log_output, buf, length,
    2f02:	464b      	mov	r3, r9
    2f04:	9600      	str	r6, [sp, #0]
    2f06:	a906      	add	r1, sp, #24
    2f08:	4620      	mov	r0, r4
    2f0a:	f7ff fedf 	bl	2ccc <hexdump_line_print>
			offset += length;
    2f0e:	9b05      	ldr	r3, [sp, #20]
    2f10:	4498      	add	r8, r3
		length = sizeof(buf);
    2f12:	e7eb      	b.n	2eec <log_output_msg_process+0xe4>
    2f14:	0002ab29 	.word	0x0002ab29
    2f18:	0002a5e8 	.word	0x0002a5e8
    2f1c:	0002aaca 	.word	0x0002aaca
    2f20:	0002ab3a 	.word	0x0002ab3a
    2f24:	0002f98a 	.word	0x0002f98a

00002f28 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
    2f28:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
	struct device *dev = (struct device *)log_output->control_block->ctx;
    2f2a:	e9d0 4300 	ldrd	r4, r3, [r0]
    2f2e:	685d      	ldr	r5, [r3, #4]

	cnt = MIN(cnt, 9999);
	len = snprintf(buf, sizeof(buf), "%d", cnt);
    2f30:	4a0f      	ldr	r2, [pc, #60]	; (2f70 <log_output_dropped_process+0x48>)
    2f32:	f242 730f 	movw	r3, #9999	; 0x270f
    2f36:	428b      	cmp	r3, r1
    2f38:	bf28      	it	cs
    2f3a:	460b      	movcs	r3, r1
    2f3c:	4668      	mov	r0, sp
    2f3e:	2105      	movs	r1, #5
    2f40:	f002 ffa6 	bl	5e90 <snprintf>

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    2f44:	462b      	mov	r3, r5
	len = snprintf(buf, sizeof(buf), "%d", cnt);
    2f46:	4606      	mov	r6, r0
	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    2f48:	490a      	ldr	r1, [pc, #40]	; (2f74 <log_output_dropped_process+0x4c>)
    2f4a:	4620      	mov	r0, r4
    2f4c:	220b      	movs	r2, #11
    2f4e:	f021 f939 	bl	241c4 <buffer_write>
	buffer_write(outf, buf, len, dev);
    2f52:	462b      	mov	r3, r5
    2f54:	4632      	mov	r2, r6
    2f56:	4669      	mov	r1, sp
    2f58:	4620      	mov	r0, r4
    2f5a:	f021 f933 	bl	241c4 <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
    2f5e:	4906      	ldr	r1, [pc, #24]	; (2f78 <log_output_dropped_process+0x50>)
    2f60:	462b      	mov	r3, r5
    2f62:	221b      	movs	r2, #27
    2f64:	4620      	mov	r0, r4
    2f66:	f021 f92d 	bl	241c4 <buffer_write>
}
    2f6a:	b002      	add	sp, #8
    2f6c:	bd70      	pop	{r4, r5, r6, pc}
    2f6e:	bf00      	nop
    2f70:	0002ea6a 	.word	0x0002ea6a
    2f74:	0002ab74 	.word	0x0002ab74
    2f78:	0002ab58 	.word	0x0002ab58

00002f7c <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
    2f7c:	4a08      	ldr	r2, [pc, #32]	; (2fa0 <log_output_timestamp_freq_set+0x24>)
{
    2f7e:	b510      	push	{r4, lr}
	timestamp_div = 1U;
    2f80:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    2f82:	4c08      	ldr	r4, [pc, #32]	; (2fa4 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
    2f84:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
    2f86:	2100      	movs	r1, #0
    2f88:	42a0      	cmp	r0, r4
    2f8a:	d804      	bhi.n	2f96 <log_output_timestamp_freq_set+0x1a>
    2f8c:	b101      	cbz	r1, 2f90 <log_output_timestamp_freq_set+0x14>
    2f8e:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
    2f90:	4b05      	ldr	r3, [pc, #20]	; (2fa8 <log_output_timestamp_freq_set+0x2c>)
    2f92:	6018      	str	r0, [r3, #0]
}
    2f94:	bd10      	pop	{r4, pc}
		frequency /= 2U;
    2f96:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    2f98:	005b      	lsls	r3, r3, #1
    2f9a:	2101      	movs	r1, #1
    2f9c:	e7f4      	b.n	2f88 <log_output_timestamp_freq_set+0xc>
    2f9e:	bf00      	nop
    2fa0:	20000278 	.word	0x20000278
    2fa4:	000f4240 	.word	0x000f4240
    2fa8:	20000274 	.word	0x20000274

00002fac <panic>:
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
    2fac:	4801      	ldr	r0, [pc, #4]	; (2fb4 <panic+0x8>)
    2fae:	f021 ba73 	b.w	24498 <log_output_flush>
    2fb2:	bf00      	nop
    2fb4:	00029b70 	.word	0x00029b70

00002fb8 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const log_output, u32_t cnt)
{
	log_output_dropped_process(log_output, cnt);
    2fb8:	4801      	ldr	r0, [pc, #4]	; (2fc0 <dropped+0x8>)
    2fba:	f7ff bfb5 	b.w	2f28 <log_output_dropped_process>
    2fbe:	bf00      	nop
    2fc0:	00029b70 	.word	0x00029b70

00002fc4 <log_backend_uart_init>:

	log_backend_std_put(&log_output, flag, msg);
}

static void log_backend_uart_init(void)
{
    2fc4:	b510      	push	{r4, lr}
    2fc6:	4809      	ldr	r0, [pc, #36]	; (2fec <log_backend_uart_init+0x28>)
    2fc8:	f01d f9fe 	bl	203c8 <z_impl_device_get_binding>
	struct device *dev;

	dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
	assert(dev);
    2fcc:	4604      	mov	r4, r0
    2fce:	b948      	cbnz	r0, 2fe4 <log_backend_uart_init+0x20>
    2fd0:	4907      	ldr	r1, [pc, #28]	; (2ff0 <log_backend_uart_init+0x2c>)
    2fd2:	4808      	ldr	r0, [pc, #32]	; (2ff4 <log_backend_uart_init+0x30>)
    2fd4:	4a08      	ldr	r2, [pc, #32]	; (2ff8 <log_backend_uart_init+0x34>)
    2fd6:	232d      	movs	r3, #45	; 0x2d
    2fd8:	f020 ff83 	bl	23ee2 <printk>
    2fdc:	4806      	ldr	r0, [pc, #24]	; (2ff8 <log_backend_uart_init+0x34>)
    2fde:	212d      	movs	r1, #45	; 0x2d
    2fe0:	f020 ffc2 	bl	23f68 <assert_post_action>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
    2fe4:	4b05      	ldr	r3, [pc, #20]	; (2ffc <log_backend_uart_init+0x38>)
    2fe6:	605c      	str	r4, [r3, #4]

	log_output_ctx_set(&log_output, dev);
}
    2fe8:	bd10      	pop	{r4, pc}
    2fea:	bf00      	nop
    2fec:	0002ab80 	.word	0x0002ab80
    2ff0:	0002abbc 	.word	0x0002abbc
    2ff4:	0002a5e8 	.word	0x0002a5e8
    2ff8:	0002ab87 	.word	0x0002ab87
    2ffc:	20000284 	.word	0x20000284

00003000 <put>:
{
    3000:	b510      	push	{r4, lr}
	log_msg_get(msg);
    3002:	4608      	mov	r0, r1
    3004:	460c      	mov	r4, r1
    3006:	f021 f892 	bl	2412e <log_msg_get>
	log_output_msg_process(log_output, msg, flags);
    300a:	4805      	ldr	r0, [pc, #20]	; (3020 <put+0x20>)
    300c:	4621      	mov	r1, r4
    300e:	220f      	movs	r2, #15
    3010:	f7ff fefa 	bl	2e08 <log_output_msg_process>
	log_msg_put(msg);
    3014:	4620      	mov	r0, r4
}
    3016:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    301a:	f021 b8b7 	b.w	2418c <log_msg_put>
    301e:	bf00      	nop
    3020:	00029b70 	.word	0x00029b70

00003024 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
    3024:	4b01      	ldr	r3, [pc, #4]	; (302c <log_backend_rtt_init+0x8>)
    3026:	2201      	movs	r2, #1
    3028:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
    302a:	4770      	bx	lr
    302c:	20001f43 	.word	0x20001f43

00003030 <panic>:

static void panic(struct log_backend const *const backend)
{
    3030:	b508      	push	{r3, lr}
	log_output_flush(log_output);
    3032:	4803      	ldr	r0, [pc, #12]	; (3040 <panic+0x10>)
    3034:	f021 fa30 	bl	24498 <log_output_flush>
	log_backend_std_panic(&log_output);
	panic_mode = true;
    3038:	4b02      	ldr	r3, [pc, #8]	; (3044 <panic+0x14>)
    303a:	2201      	movs	r2, #1
    303c:	701a      	strb	r2, [r3, #0]
}
    303e:	bd08      	pop	{r3, pc}
    3040:	00029b98 	.word	0x00029b98
    3044:	20001f44 	.word	0x20001f44

00003048 <dropped>:
	log_output_dropped_process(log_output, cnt);
    3048:	4801      	ldr	r0, [pc, #4]	; (3050 <dropped+0x8>)
    304a:	f7ff bf6d 	b.w	2f28 <log_output_dropped_process>
    304e:	bf00      	nop
    3050:	00029b98 	.word	0x00029b98

00003054 <put>:
{
    3054:	b510      	push	{r4, lr}
	log_msg_get(msg);
    3056:	4608      	mov	r0, r1
    3058:	460c      	mov	r4, r1
    305a:	f021 f868 	bl	2412e <log_msg_get>
	log_output_msg_process(log_output, msg, flags);
    305e:	4805      	ldr	r0, [pc, #20]	; (3074 <put+0x20>)
    3060:	4621      	mov	r1, r4
    3062:	220f      	movs	r2, #15
    3064:	f7ff fed0 	bl	2e08 <log_output_msg_process>
	log_msg_put(msg);
    3068:	4620      	mov	r0, r4
}
    306a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    306e:	f021 b88d 	b.w	2418c <log_msg_put>
    3072:	bf00      	nop
    3074:	00029b98 	.word	0x00029b98

00003078 <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    3078:	4b04      	ldr	r3, [pc, #16]	; (308c <on_failed_write.part.0+0x14>)
	} else if (is_sync_mode()) {
    307a:	781b      	ldrb	r3, [r3, #0]
    307c:	b11b      	cbz	r3, 3086 <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
    307e:	f241 3088 	movw	r0, #5000	; 0x1388
    3082:	f026 b93f 	b.w	29304 <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
    3086:	2005      	movs	r0, #5
    3088:	f01f bad0 	b.w	2262c <z_impl_k_sleep>
    308c:	20001f44 	.word	0x20001f44

00003090 <data_out_block_mode>:
{
    3090:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    3094:	f8df 908c 	ldr.w	r9, [pc, #140]	; 3124 <data_out_block_mode+0x94>
	return z_impl_k_mutex_lock(mutex, timeout);
    3098:	f8df b08c 	ldr.w	fp, [pc, #140]	; 3128 <data_out_block_mode+0x98>
{
    309c:	4607      	mov	r7, r0
    309e:	460e      	mov	r6, r1
	int retry_cnt = CONFIG_LOG_BACKEND_RTT_RETRY_CNT;
    30a0:	2404      	movs	r4, #4
    30a2:	46ca      	mov	sl, r9
		if (!is_sync_mode()) {
    30a4:	f899 3000 	ldrb.w	r3, [r9]
    30a8:	b923      	cbnz	r3, 30b4 <data_out_block_mode+0x24>
    30aa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    30ae:	4658      	mov	r0, fp
    30b0:	f01d fd3a 	bl	20b28 <z_impl_k_mutex_lock>
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    30b4:	4632      	mov	r2, r6
    30b6:	4639      	mov	r1, r7
    30b8:	2000      	movs	r0, #0
    30ba:	f001 f9ff 	bl	44bc <SEGGER_RTT_WriteSkipNoLock>
		if (!is_sync_mode()) {
    30be:	f89a 3000 	ldrb.w	r3, [sl]
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    30c2:	4680      	mov	r8, r0
		if (!is_sync_mode()) {
    30c4:	b913      	cbnz	r3, 30cc <data_out_block_mode+0x3c>
	return z_impl_k_mutex_unlock(mutex);
    30c6:	4658      	mov	r0, fp
    30c8:	f01d fe0c 	bl	20ce4 <z_impl_k_mutex_unlock>
		if (ret) {
    30cc:	4d14      	ldr	r5, [pc, #80]	; (3120 <data_out_block_mode+0x90>)
    30ce:	f1b8 0f00 	cmp.w	r8, #0
    30d2:	d018      	beq.n	3106 <data_out_block_mode+0x76>
	host_present = true;
    30d4:	2301      	movs	r3, #1
    30d6:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
    30d8:	f89a 3000 	ldrb.w	r3, [sl]
    30dc:	b933      	cbnz	r3, 30ec <data_out_block_mode+0x5c>
}
    30de:	4630      	mov	r0, r6
    30e0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (retry_cnt == 0) {
    30e4:	b95c      	cbnz	r4, 30fe <data_out_block_mode+0x6e>
		host_present = false;
    30e6:	702c      	strb	r4, [r5, #0]
    30e8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
    30ec:	2000      	movs	r0, #0
    30ee:	f001 fa31 	bl	4554 <SEGGER_RTT_HasDataUp>
    30f2:	2800      	cmp	r0, #0
    30f4:	d0f3      	beq.n	30de <data_out_block_mode+0x4e>
    30f6:	782b      	ldrb	r3, [r5, #0]
    30f8:	2b00      	cmp	r3, #0
    30fa:	d1f3      	bne.n	30e4 <data_out_block_mode+0x54>
    30fc:	e7ef      	b.n	30de <data_out_block_mode+0x4e>
			on_failed_write(retry_cnt--);
    30fe:	3c01      	subs	r4, #1
    3100:	f7ff ffba 	bl	3078 <on_failed_write.part.0>
    3104:	e7f2      	b.n	30ec <data_out_block_mode+0x5c>
		} else if (host_present) {
    3106:	782b      	ldrb	r3, [r5, #0]
    3108:	b113      	cbz	r3, 3110 <data_out_block_mode+0x80>
	if (retry_cnt == 0) {
    310a:	3c01      	subs	r4, #1
    310c:	d104      	bne.n	3118 <data_out_block_mode+0x88>
		host_present = false;
    310e:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
    3110:	782b      	ldrb	r3, [r5, #0]
    3112:	2b00      	cmp	r3, #0
    3114:	d1c6      	bne.n	30a4 <data_out_block_mode+0x14>
    3116:	e7e2      	b.n	30de <data_out_block_mode+0x4e>
    3118:	f7ff ffae 	bl	3078 <on_failed_write.part.0>
    311c:	e7f8      	b.n	3110 <data_out_block_mode+0x80>
    311e:	bf00      	nop
    3120:	20001f43 	.word	0x20001f43
    3124:	20001f44 	.word	0x20001f44
    3128:	20007620 	.word	0x20007620

0000312c <nvs_prev_ate>:

/* walking through allocation entry list, from newest to oldest entries
 * read ate from addr, modify addr to the previous ate
 */
static int nvs_prev_ate(struct nvs_fs *fs, u32_t *addr, struct nvs_ate *ate)
{
    312c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    3130:	2308      	movs	r3, #8
{
    3132:	b085      	sub	sp, #20
    3134:	460d      	mov	r5, r1
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    3136:	6809      	ldr	r1, [r1, #0]
	int rc;
	struct nvs_ate close_ate, end_ate;
	u32_t data_end_addr, ate_end_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3138:	7c04      	ldrb	r4, [r0, #16]
{
    313a:	4607      	mov	r7, r0
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    313c:	f021 f9cc 	bl	244d8 <nvs_flash_rd>

	rc = nvs_flash_ate_rd(fs, *addr, ate);
	if (rc) {
    3140:	b968      	cbnz	r0, 315e <nvs_prev_ate+0x32>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3142:	2108      	movs	r1, #8
    3144:	4620      	mov	r0, r4
    3146:	f021 fa13 	bl	24570 <nvs_al_size.isra.0>
		return rc;
	}

	*addr += ate_size;
    314a:	6829      	ldr	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
    314c:	89bb      	ldrh	r3, [r7, #12]
	*addr += ate_size;
    314e:	4401      	add	r1, r0
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
    3150:	b28a      	uxth	r2, r1
    3152:	1a1b      	subs	r3, r3, r0
    3154:	429a      	cmp	r2, r3
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3156:	4606      	mov	r6, r0
	*addr += ate_size;
    3158:	6029      	str	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
    315a:	d003      	beq.n	3164 <nvs_prev_ate+0x38>
		return 0;
    315c:	2000      	movs	r0, #0
	/* remark: if there was absolutely no valid data in the sector *addr
	 * is kept at sector_end - 2*ate_size, the next read will contain
	 * invalid data and continue with a sector jump
	 */
	return 0;
}
    315e:	b005      	add	sp, #20
    3160:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
    3164:	0c0b      	lsrs	r3, r1, #16
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
    3166:	bf03      	ittte	eq
    3168:	89fb      	ldrheq	r3, [r7, #14]
    316a:	f103 33ff 	addeq.w	r3, r3, #4294967295	; 0xffffffff
    316e:	eb01 4103 	addeq.w	r1, r1, r3, lsl #16
		*addr -= (1 << ADDR_SECT_SHIFT);
    3172:	f5a1 3180 	subne.w	r1, r1, #65536	; 0x10000
    3176:	6029      	str	r1, [r5, #0]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    3178:	2308      	movs	r3, #8
    317a:	466a      	mov	r2, sp
    317c:	4638      	mov	r0, r7
    317e:	f021 f9ab 	bl	244d8 <nvs_flash_rd>
	if (rc) {
    3182:	2800      	cmp	r0, #0
    3184:	d1eb      	bne.n	315e <nvs_prev_ate+0x32>
    3186:	466a      	mov	r2, sp
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    3188:	4603      	mov	r3, r0
		if (data8[i] != value) {
    318a:	f812 1b01 	ldrb.w	r1, [r2], #1
    318e:	29ff      	cmp	r1, #255	; 0xff
    3190:	d115      	bne.n	31be <nvs_prev_ate+0x92>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    3192:	3301      	adds	r3, #1
    3194:	2b08      	cmp	r3, #8
    3196:	d1f8      	bne.n	318a <nvs_prev_ate+0x5e>
		*addr = fs->ate_wra;
    3198:	687b      	ldr	r3, [r7, #4]
    319a:	602b      	str	r3, [r5, #0]
		return 0;
    319c:	e7df      	b.n	315e <nvs_prev_ate+0x32>
		if (close_ate.offset < (fs->sector_size - ate_size) &&
    319e:	89bb      	ldrh	r3, [r7, #12]
    31a0:	f8bd 1002 	ldrh.w	r1, [sp, #2]
    31a4:	1b9b      	subs	r3, r3, r6
    31a6:	4299      	cmp	r1, r3
    31a8:	d20f      	bcs.n	31ca <nvs_prev_ate+0x9e>
		    !(close_ate.offset % ate_size)) {
    31aa:	fbb1 f3f6 	udiv	r3, r1, r6
    31ae:	fb06 1313 	mls	r3, r6, r3, r1
		if (close_ate.offset < (fs->sector_size - ate_size) &&
    31b2:	b953      	cbnz	r3, 31ca <nvs_prev_ate+0x9e>
			(*addr) &= ADDR_SECT_MASK;
    31b4:	0c24      	lsrs	r4, r4, #16
    31b6:	0424      	lsls	r4, r4, #16
			(*addr) += close_ate.offset;
    31b8:	440c      	add	r4, r1
    31ba:	602c      	str	r4, [r5, #0]
			return 0;
    31bc:	e7cf      	b.n	315e <nvs_prev_ate+0x32>
	if (!nvs_ate_crc8_check(&close_ate)) {
    31be:	4668      	mov	r0, sp
    31c0:	f021 f9c1 	bl	24546 <nvs_ate_crc8_check>
    31c4:	682c      	ldr	r4, [r5, #0]
    31c6:	2800      	cmp	r0, #0
    31c8:	d0e9      	beq.n	319e <nvs_prev_ate+0x72>
	data_end_addr = *addr & ADDR_SECT_MASK;
    31ca:	4b10      	ldr	r3, [pc, #64]	; (320c <nvs_prev_ate+0xe0>)
	*addr -= ate_size;
    31cc:	1ba4      	subs	r4, r4, r6
    31ce:	602c      	str	r4, [r5, #0]
	data_end_addr = *addr & ADDR_SECT_MASK;
    31d0:	ea04 0803 	and.w	r8, r4, r3
			data_end_addr &= ADDR_SECT_MASK;
    31d4:	4699      	mov	r9, r3
	while (ate_end_addr > data_end_addr) {
    31d6:	45a0      	cmp	r8, r4
    31d8:	d2c0      	bcs.n	315c <nvs_prev_ate+0x30>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    31da:	2308      	movs	r3, #8
    31dc:	eb0d 0203 	add.w	r2, sp, r3
    31e0:	4621      	mov	r1, r4
    31e2:	4638      	mov	r0, r7
    31e4:	f021 f978 	bl	244d8 <nvs_flash_rd>
		if (rc) {
    31e8:	2800      	cmp	r0, #0
    31ea:	d1b8      	bne.n	315e <nvs_prev_ate+0x32>
		if (!nvs_ate_crc8_check(&end_ate)) {
    31ec:	a802      	add	r0, sp, #8
    31ee:	f021 f9aa 	bl	24546 <nvs_ate_crc8_check>
    31f2:	b940      	cbnz	r0, 3206 <nvs_prev_ate+0xda>
			data_end_addr += end_ate.offset + end_ate.len;
    31f4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    31f8:	f8bd 200c 	ldrh.w	r2, [sp, #12]
			*addr = ate_end_addr;
    31fc:	602c      	str	r4, [r5, #0]
			data_end_addr &= ADDR_SECT_MASK;
    31fe:	ea08 0809 	and.w	r8, r8, r9
			data_end_addr += end_ate.offset + end_ate.len;
    3202:	4413      	add	r3, r2
    3204:	4498      	add	r8, r3
		ate_end_addr -= ate_size;
    3206:	1ba4      	subs	r4, r4, r6
    3208:	e7e5      	b.n	31d6 <nvs_prev_ate+0xaa>
    320a:	bf00      	nop
    320c:	ffff0000 	.word	0xffff0000

00003210 <nvs_gc>:
/* garbage collection: the address ate_wra has been updated to the new sector
 * that has just been started. The data to gc is in the sector after this new
 * sector.
 */
static int nvs_gc(struct nvs_fs *fs)
{
    3210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3214:	4605      	mov	r5, r0
    3216:	b095      	sub	sp, #84	; 0x54
	struct nvs_ate close_ate, gc_ate, wlk_ate;
	u32_t sec_addr, gc_addr, gc_prev_addr, wlk_addr, wlk_prev_addr,
	      data_addr, stop_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3218:	7c00      	ldrb	r0, [r0, #16]
    321a:	2108      	movs	r1, #8
    321c:	f021 f9a8 	bl	24570 <nvs_al_size.isra.0>

	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
    3220:	686b      	ldr	r3, [r5, #4]
    3222:	0c1b      	lsrs	r3, r3, #16
    3224:	041b      	lsls	r3, r3, #16
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3226:	4606      	mov	r6, r0
	nvs_sector_advance(fs, &sec_addr);
    3228:	a903      	add	r1, sp, #12
    322a:	89e8      	ldrh	r0, [r5, #14]
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
    322c:	9303      	str	r3, [sp, #12]
	nvs_sector_advance(fs, &sec_addr);
    322e:	f021 f9a9 	bl	24584 <nvs_sector_advance.isra.0>
	gc_addr = sec_addr + fs->sector_size - ate_size;
    3232:	9b03      	ldr	r3, [sp, #12]
    3234:	89a9      	ldrh	r1, [r5, #12]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    3236:	af06      	add	r7, sp, #24
	gc_addr = sec_addr + fs->sector_size - ate_size;
    3238:	4419      	add	r1, r3
    323a:	1b89      	subs	r1, r1, r6
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    323c:	2308      	movs	r3, #8
    323e:	463a      	mov	r2, r7
    3240:	4628      	mov	r0, r5
	gc_addr = sec_addr + fs->sector_size - ate_size;
    3242:	9104      	str	r1, [sp, #16]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    3244:	f021 f948 	bl	244d8 <nvs_flash_rd>

	/* if the sector is not closed don't do gc */
	rc = nvs_flash_ate_rd(fs, gc_addr, &close_ate);
	if (rc < 0) {
    3248:	1e04      	subs	r4, r0, #0
    324a:	db71      	blt.n	3330 <nvs_gc+0x120>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    324c:	2300      	movs	r3, #0
		if (data8[i] != value) {
    324e:	5cfa      	ldrb	r2, [r7, r3]
    3250:	2aff      	cmp	r2, #255	; 0xff
    3252:	d171      	bne.n	3338 <nvs_gc+0x128>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    3254:	3301      	adds	r3, #1
    3256:	2b08      	cmp	r3, #8
    3258:	d1f9      	bne.n	324e <nvs_gc+0x3e>
		return rc;
	}

	rc = nvs_ate_cmp_const(&close_ate, 0xff);
	if (!rc) {
		rc = nvs_flash_erase_sector(fs, sec_addr);
    325a:	9903      	ldr	r1, [sp, #12]
    325c:	4628      	mov	r0, r5
    325e:	f021 f9c0 	bl	245e2 <nvs_flash_erase_sector>
    3262:	4604      	mov	r4, r0
		if (rc) {
    3264:	e064      	b.n	3330 <nvs_gc+0x120>
		bytes_to_copy = MIN(block_size, len);
    3266:	4557      	cmp	r7, sl
    3268:	463e      	mov	r6, r7
    326a:	bf28      	it	cs
    326c:	4656      	movcs	r6, sl
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_copy);
    326e:	4633      	mov	r3, r6
    3270:	aa0c      	add	r2, sp, #48	; 0x30
    3272:	4641      	mov	r1, r8
    3274:	4628      	mov	r0, r5
    3276:	f021 f92f 	bl	244d8 <nvs_flash_rd>
		if (rc) {
    327a:	4604      	mov	r4, r0
    327c:	2800      	cmp	r0, #0
    327e:	d157      	bne.n	3330 <nvs_gc+0x120>
	if (!len) {
    3280:	b136      	cbz	r6, 3290 <nvs_gc+0x80>
    3282:	68a9      	ldr	r1, [r5, #8]
    3284:	4633      	mov	r3, r6
    3286:	aa0c      	add	r2, sp, #48	; 0x30
    3288:	4628      	mov	r0, r5
    328a:	f021 f9d0 	bl	2462e <nvs_flash_al_wrt.part.0>
    328e:	4604      	mov	r4, r0
	fs->data_wra += nvs_al_size(fs, len);
    3290:	7c28      	ldrb	r0, [r5, #16]
    3292:	4631      	mov	r1, r6
    3294:	f021 f96c 	bl	24570 <nvs_al_size.isra.0>
    3298:	68aa      	ldr	r2, [r5, #8]
    329a:	4402      	add	r2, r0
    329c:	60aa      	str	r2, [r5, #8]
		if (rc) {
    329e:	2c00      	cmp	r4, #0
    32a0:	d146      	bne.n	3330 <nvs_gc+0x120>
		len -= bytes_to_copy;
    32a2:	ebaa 0a06 	sub.w	sl, sl, r6
		addr += bytes_to_copy;
    32a6:	44b0      	add	r8, r6
    32a8:	e038      	b.n	331c <nvs_gc+0x10c>
				return rc;
			}
		}

		/* stop gc at end of the sector */
		if (gc_prev_addr == stop_addr) {
    32aa:	9b01      	ldr	r3, [sp, #4]
    32ac:	455b      	cmp	r3, fp
    32ae:	d0d4      	beq.n	325a <nvs_gc+0x4a>
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
    32b0:	aa08      	add	r2, sp, #32
    32b2:	a904      	add	r1, sp, #16
    32b4:	4628      	mov	r0, r5
		gc_prev_addr = gc_addr;
    32b6:	f8dd b010 	ldr.w	fp, [sp, #16]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
    32ba:	f7ff ff37 	bl	312c <nvs_prev_ate>
		if (rc) {
    32be:	4604      	mov	r4, r0
    32c0:	2800      	cmp	r0, #0
    32c2:	d135      	bne.n	3330 <nvs_gc+0x120>
		wlk_addr = fs->ate_wra;
    32c4:	686b      	ldr	r3, [r5, #4]
    32c6:	9305      	str	r3, [sp, #20]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    32c8:	aa0a      	add	r2, sp, #40	; 0x28
    32ca:	a905      	add	r1, sp, #20
    32cc:	4628      	mov	r0, r5
			wlk_prev_addr = wlk_addr;
    32ce:	9f05      	ldr	r7, [sp, #20]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    32d0:	f7ff ff2c 	bl	312c <nvs_prev_ate>
			if (rc) {
    32d4:	4604      	mov	r4, r0
    32d6:	bb58      	cbnz	r0, 3330 <nvs_gc+0x120>
			if ((wlk_ate.id == gc_ate.id) &&
    32d8:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
    32dc:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    32e0:	429a      	cmp	r2, r3
    32e2:	d1f1      	bne.n	32c8 <nvs_gc+0xb8>
			    (!nvs_ate_crc8_check(&wlk_ate))) {
    32e4:	a80a      	add	r0, sp, #40	; 0x28
    32e6:	f021 f92e 	bl	24546 <nvs_ate_crc8_check>
			if ((wlk_ate.id == gc_ate.id) &&
    32ea:	2800      	cmp	r0, #0
    32ec:	d1ec      	bne.n	32c8 <nvs_gc+0xb8>
		if ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {
    32ee:	455f      	cmp	r7, fp
    32f0:	d1db      	bne.n	32aa <nvs_gc+0x9a>
    32f2:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    32f6:	2b00      	cmp	r3, #0
    32f8:	d0d7      	beq.n	32aa <nvs_gc+0x9a>
			data_addr += gc_ate.offset;
    32fa:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
    32fe:	ea0b 0809 	and.w	r8, fp, r9
			data_addr += gc_ate.offset;
    3302:	4498      	add	r8, r3
			nvs_ate_crc8_update(&gc_ate);
    3304:	a808      	add	r0, sp, #32
			gc_ate.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
    3306:	68ab      	ldr	r3, [r5, #8]
    3308:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
			nvs_ate_crc8_update(&gc_ate);
    330c:	f021 f927 	bl	2455e <nvs_ate_crc8_update>
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
    3310:	7c2f      	ldrb	r7, [r5, #16]
			rc = nvs_flash_block_move(fs, data_addr, gc_ate.len);
    3312:	f8bd a024 	ldrh.w	sl, [sp, #36]	; 0x24
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
    3316:	427f      	negs	r7, r7
    3318:	f007 0720 	and.w	r7, r7, #32
	while (len) {
    331c:	f1ba 0f00 	cmp.w	sl, #0
    3320:	d1a1      	bne.n	3266 <nvs_gc+0x56>
			rc = nvs_flash_ate_wrt(fs, &gc_ate);
    3322:	a908      	add	r1, sp, #32
    3324:	4628      	mov	r0, r5
    3326:	f021 f9c6 	bl	246b6 <nvs_flash_ate_wrt>
			if (rc) {
    332a:	4604      	mov	r4, r0
    332c:	2800      	cmp	r0, #0
    332e:	d0bc      	beq.n	32aa <nvs_gc+0x9a>
	rc = nvs_flash_erase_sector(fs, sec_addr);
	if (rc) {
		return rc;
	}
	return 0;
}
    3330:	4620      	mov	r0, r4
    3332:	b015      	add	sp, #84	; 0x54
    3334:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	stop_addr = gc_addr - ate_size;
    3338:	9b04      	ldr	r3, [sp, #16]
	gc_addr += close_ate.offset;
    333a:	f8bd 101a 	ldrh.w	r1, [sp, #26]
	stop_addr = gc_addr - ate_size;
    333e:	1b9a      	subs	r2, r3, r6
    3340:	9201      	str	r2, [sp, #4]
	gc_addr &= ADDR_SECT_MASK;
    3342:	4a03      	ldr	r2, [pc, #12]	; (3350 <nvs_gc+0x140>)
    3344:	4013      	ands	r3, r2
	gc_addr += close_ate.offset;
    3346:	440b      	add	r3, r1
    3348:	9304      	str	r3, [sp, #16]
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
    334a:	4691      	mov	r9, r2
    334c:	e7b0      	b.n	32b0 <nvs_gc+0xa0>
    334e:	bf00      	nop
    3350:	ffff0000 	.word	0xffff0000

00003354 <nvs_init>:
	}
	return 0;
}

int nvs_init(struct nvs_fs *fs, const char *dev_name)
{
    3354:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3358:	4604      	mov	r4, r0
    335a:	b087      	sub	sp, #28
    335c:	460d      	mov	r5, r1

	int rc;
	struct flash_pages_info info;

	k_mutex_init(&fs->nvs_lock);
    335e:	f100 0614 	add.w	r6, r0, #20
	return z_impl_k_mutex_init(mutex);
    3362:	4630      	mov	r0, r6
    3364:	f025 ff59 	bl	2921a <z_impl_k_mutex_init>
    3368:	4628      	mov	r0, r5
    336a:	f01d f82d 	bl	203c8 <z_impl_device_get_binding>

	fs->flash_device = device_get_binding(dev_name);
    336e:	62a0      	str	r0, [r4, #40]	; 0x28
	if (!fs->flash_device) {
    3370:	b978      	cbnz	r0, 3392 <nvs_init+0x3e>
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    3372:	4b91      	ldr	r3, [pc, #580]	; (35b8 <nvs_init+0x264>)
    3374:	4991      	ldr	r1, [pc, #580]	; (35bc <nvs_init+0x268>)
		LOG_ERR("No valid flash device found");
    3376:	4892      	ldr	r0, [pc, #584]	; (35c0 <nvs_init+0x26c>)
    3378:	1ac9      	subs	r1, r1, r3
    337a:	08c9      	lsrs	r1, r1, #3
    337c:	0189      	lsls	r1, r1, #6
    337e:	f041 0101 	orr.w	r1, r1, #1
    3382:	f020 fe1f 	bl	23fc4 <log_0>
		return -ENXIO;
    3386:	f06f 0505 	mvn.w	r5, #5
	LOG_INF("data wra: %d, %x",
		(fs->data_wra >> ADDR_SECT_SHIFT),
		(fs->data_wra & ADDR_OFFS_MASK));

	return 0;
}
    338a:	4628      	mov	r0, r5
    338c:	b007      	add	sp, #28
    338e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
static inline size_t z_impl_flash_get_write_block_size(struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->write_block_size;
    3392:	6843      	ldr	r3, [r0, #4]
	fs->write_block_size = flash_get_write_block_size(fs->flash_device);
    3394:	7d1b      	ldrb	r3, [r3, #20]
    3396:	7423      	strb	r3, [r4, #16]
	if (fs->write_block_size > NVS_BLOCK_SIZE) {
    3398:	2b20      	cmp	r3, #32
    339a:	d90c      	bls.n	33b6 <nvs_init+0x62>
    339c:	4987      	ldr	r1, [pc, #540]	; (35bc <nvs_init+0x268>)
    339e:	4b86      	ldr	r3, [pc, #536]	; (35b8 <nvs_init+0x264>)
		LOG_ERR("Unsupported write block size");
    33a0:	4888      	ldr	r0, [pc, #544]	; (35c4 <nvs_init+0x270>)
    33a2:	1ac9      	subs	r1, r1, r3
    33a4:	08c9      	lsrs	r1, r1, #3
    33a6:	0189      	lsls	r1, r1, #6
    33a8:	f041 0101 	orr.w	r1, r1, #1
		LOG_ERR("Unable to get page info");
    33ac:	f020 fe0a 	bl	23fc4 <log_0>
		return -EINVAL;
    33b0:	f06f 0515 	mvn.w	r5, #21
    33b4:	e7e9      	b.n	338a <nvs_init+0x36>
	rc = flash_get_page_info_by_offs(fs->flash_device, fs->offset, &info);
    33b6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    33b8:	6821      	ldr	r1, [r4, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&offset, *(uintptr_t *)&info, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
    33ba:	aa03      	add	r2, sp, #12
    33bc:	f025 fea4 	bl	29108 <z_impl_flash_get_page_info_by_offs>
	if (rc) {
    33c0:	b140      	cbz	r0, 33d4 <nvs_init+0x80>
    33c2:	497e      	ldr	r1, [pc, #504]	; (35bc <nvs_init+0x268>)
    33c4:	4b7c      	ldr	r3, [pc, #496]	; (35b8 <nvs_init+0x264>)
		LOG_ERR("Unable to get page info");
    33c6:	4880      	ldr	r0, [pc, #512]	; (35c8 <nvs_init+0x274>)
    33c8:	1ac9      	subs	r1, r1, r3
    33ca:	08c9      	lsrs	r1, r1, #3
    33cc:	0189      	lsls	r1, r1, #6
    33ce:	f041 0101 	orr.w	r1, r1, #1
    33d2:	e7eb      	b.n	33ac <nvs_init+0x58>
	if (!fs->sector_size || fs->sector_size % info.size) {
    33d4:	89a3      	ldrh	r3, [r4, #12]
    33d6:	b12b      	cbz	r3, 33e4 <nvs_init+0x90>
    33d8:	9a04      	ldr	r2, [sp, #16]
    33da:	fbb3 f5f2 	udiv	r5, r3, r2
    33de:	fb02 3515 	mls	r5, r2, r5, r3
    33e2:	b145      	cbz	r5, 33f6 <nvs_init+0xa2>
    33e4:	4975      	ldr	r1, [pc, #468]	; (35bc <nvs_init+0x268>)
    33e6:	4b74      	ldr	r3, [pc, #464]	; (35b8 <nvs_init+0x264>)
		LOG_ERR("Invalid sector size");
    33e8:	4878      	ldr	r0, [pc, #480]	; (35cc <nvs_init+0x278>)
    33ea:	1ac9      	subs	r1, r1, r3
    33ec:	08c9      	lsrs	r1, r1, #3
    33ee:	0189      	lsls	r1, r1, #6
    33f0:	f041 0101 	orr.w	r1, r1, #1
    33f4:	e7da      	b.n	33ac <nvs_init+0x58>
	if (fs->sector_count < 2) {
    33f6:	89e3      	ldrh	r3, [r4, #14]
    33f8:	2b01      	cmp	r3, #1
    33fa:	d808      	bhi.n	340e <nvs_init+0xba>
    33fc:	496f      	ldr	r1, [pc, #444]	; (35bc <nvs_init+0x268>)
    33fe:	4b6e      	ldr	r3, [pc, #440]	; (35b8 <nvs_init+0x264>)
		LOG_ERR("Configuration error - sector count");
    3400:	4873      	ldr	r0, [pc, #460]	; (35d0 <nvs_init+0x27c>)
    3402:	1ac9      	subs	r1, r1, r3
    3404:	08c9      	lsrs	r1, r1, #3
    3406:	0189      	lsls	r1, r1, #6
    3408:	f041 0101 	orr.w	r1, r1, #1
    340c:	e7ce      	b.n	33ac <nvs_init+0x58>
	u32_t addr = 0U;
    340e:	9500      	str	r5, [sp, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
    3410:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3414:	4630      	mov	r0, r6
    3416:	f01d fb87 	bl	20b28 <z_impl_k_mutex_lock>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    341a:	7c20      	ldrb	r0, [r4, #16]
    341c:	2108      	movs	r1, #8
    341e:	f021 f8a7 	bl	24570 <nvs_al_size.isra.0>
	u16_t i, closed_sectors = 0;
    3422:	46a9      	mov	r9, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3424:	4607      	mov	r7, r0
	for (i = 0; i < fs->sector_count; i++) {
    3426:	89e3      	ldrh	r3, [r4, #14]
    3428:	fa1f f885 	uxth.w	r8, r5
    342c:	4543      	cmp	r3, r8
    342e:	d805      	bhi.n	343c <nvs_init+0xe8>
	if (closed_sectors == fs->sector_count) {
    3430:	89e3      	ldrh	r3, [r4, #14]
    3432:	454b      	cmp	r3, r9
    3434:	d11e      	bne.n	3474 <nvs_init+0x120>
		return -EDEADLK;
    3436:	f06f 0520 	mvn.w	r5, #32
    343a:	e7a6      	b.n	338a <nvs_init+0x36>
		       (u16_t)(fs->sector_size - ate_size);
    343c:	89a1      	ldrh	r1, [r4, #12]
		addr = (i << ADDR_SECT_SHIFT) +
    343e:	042b      	lsls	r3, r5, #16
		       (u16_t)(fs->sector_size - ate_size);
    3440:	1bc9      	subs	r1, r1, r7
		addr = (i << ADDR_SECT_SHIFT) +
    3442:	fa13 f181 	uxtah	r1, r3, r1
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
    3446:	2208      	movs	r2, #8
    3448:	4620      	mov	r0, r4
		addr = (i << ADDR_SECT_SHIFT) +
    344a:	9100      	str	r1, [sp, #0]
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
    344c:	f021 f8a5 	bl	2459a <nvs_flash_cmp_const.constprop.0>
		if (rc) {
    3450:	b170      	cbz	r0, 3470 <nvs_init+0x11c>
			nvs_sector_advance(fs, &addr);
    3452:	89e0      	ldrh	r0, [r4, #14]
    3454:	4669      	mov	r1, sp
    3456:	f021 f895 	bl	24584 <nvs_sector_advance.isra.0>
			closed_sectors++;
    345a:	f109 0901 	add.w	r9, r9, #1
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
    345e:	9900      	ldr	r1, [sp, #0]
    3460:	2208      	movs	r2, #8
    3462:	4620      	mov	r0, r4
			closed_sectors++;
    3464:	fa1f f989 	uxth.w	r9, r9
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
    3468:	f021 f897 	bl	2459a <nvs_flash_cmp_const.constprop.0>
			if (!rc) {
    346c:	2800      	cmp	r0, #0
    346e:	d0df      	beq.n	3430 <nvs_init+0xdc>
	for (i = 0; i < fs->sector_count; i++) {
    3470:	3501      	adds	r5, #1
    3472:	e7d8      	b.n	3426 <nvs_init+0xd2>
	if (i == fs->sector_count) {
    3474:	4598      	cmp	r8, r3
    3476:	d10a      	bne.n	348e <nvs_init+0x13a>
		rc = nvs_flash_cmp_const(fs, addr - ate_size, 0xff,
    3478:	9900      	ldr	r1, [sp, #0]
    347a:	2208      	movs	r2, #8
    347c:	1bc9      	subs	r1, r1, r7
    347e:	4620      	mov	r0, r4
    3480:	f021 f88b 	bl	2459a <nvs_flash_cmp_const.constprop.0>
		if (!rc) {
    3484:	b918      	cbnz	r0, 348e <nvs_init+0x13a>
			nvs_sector_advance(fs, &addr);
    3486:	89e0      	ldrh	r0, [r4, #14]
    3488:	4669      	mov	r1, sp
    348a:	f021 f87b 	bl	24584 <nvs_sector_advance.isra.0>
	fs->ate_wra = addr - ate_size;
    348e:	9b00      	ldr	r3, [sp, #0]
    3490:	1bda      	subs	r2, r3, r7
    3492:	6062      	str	r2, [r4, #4]
	fs->data_wra = addr & ADDR_SECT_MASK;
    3494:	4a4f      	ldr	r2, [pc, #316]	; (35d4 <nvs_init+0x280>)
    3496:	4013      	ands	r3, r2
    3498:	60a3      	str	r3, [r4, #8]
			fs->data_wra = addr & ADDR_SECT_MASK;
    349a:	4690      	mov	r8, r2
	while (fs->ate_wra >= fs->data_wra) {
    349c:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
    34a0:	4299      	cmp	r1, r3
    34a2:	d30e      	bcc.n	34c2 <nvs_init+0x16e>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    34a4:	2308      	movs	r3, #8
    34a6:	aa01      	add	r2, sp, #4
    34a8:	4620      	mov	r0, r4
    34aa:	f021 f815 	bl	244d8 <nvs_flash_rd>
		if (rc) {
    34ae:	4605      	mov	r5, r0
    34b0:	bb18      	cbnz	r0, 34fa <nvs_init+0x1a6>
    34b2:	ab01      	add	r3, sp, #4
		if (data8[i] != value) {
    34b4:	f813 2b01 	ldrb.w	r2, [r3], #1
    34b8:	2aff      	cmp	r2, #255	; 0xff
    34ba:	d165      	bne.n	3588 <nvs_init+0x234>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    34bc:	3501      	adds	r5, #1
    34be:	2d08      	cmp	r5, #8
    34c0:	d1f8      	bne.n	34b4 <nvs_init+0x160>
	while (fs->ate_wra > fs->data_wra) {
    34c2:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
    34c6:	428a      	cmp	r2, r1
    34c8:	d906      	bls.n	34d8 <nvs_init+0x184>
		rc = nvs_flash_cmp_const(fs, fs->data_wra, 0xff, empty_len);
    34ca:	1a52      	subs	r2, r2, r1
    34cc:	4620      	mov	r0, r4
    34ce:	f021 f864 	bl	2459a <nvs_flash_cmp_const.constprop.0>
		if (rc < 0) {
    34d2:	1e05      	subs	r5, r0, #0
    34d4:	db11      	blt.n	34fa <nvs_init+0x1a6>
		if (!rc) {
    34d6:	d13a      	bne.n	354e <nvs_init+0x1fa>
	addr = fs->ate_wra & ADDR_SECT_MASK;
    34d8:	6863      	ldr	r3, [r4, #4]
    34da:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 35d4 <nvs_init+0x280>
	nvs_sector_advance(fs, &addr);
    34de:	89e0      	ldrh	r0, [r4, #14]
	addr = fs->ate_wra & ADDR_SECT_MASK;
    34e0:	ea03 0308 	and.w	r3, r3, r8
	nvs_sector_advance(fs, &addr);
    34e4:	4669      	mov	r1, sp
	addr = fs->ate_wra & ADDR_SECT_MASK;
    34e6:	9300      	str	r3, [sp, #0]
	nvs_sector_advance(fs, &addr);
    34e8:	f021 f84c 	bl	24584 <nvs_sector_advance.isra.0>
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
    34ec:	89a2      	ldrh	r2, [r4, #12]
    34ee:	9900      	ldr	r1, [sp, #0]
    34f0:	4620      	mov	r0, r4
    34f2:	f021 f852 	bl	2459a <nvs_flash_cmp_const.constprop.0>
	if (rc < 0) {
    34f6:	1e05      	subs	r5, r0, #0
    34f8:	da2e      	bge.n	3558 <nvs_init+0x204>
	return z_impl_k_mutex_unlock(mutex);
    34fa:	4630      	mov	r0, r6
    34fc:	f01d fbf2 	bl	20ce4 <z_impl_k_mutex_unlock>
	if (rc) {
    3500:	2d00      	cmp	r5, #0
    3502:	f47f af42 	bne.w	338a <nvs_init+0x36>
	fs->ready = true;
    3506:	2301      	movs	r3, #1
    3508:	7463      	strb	r3, [r4, #17]
    350a:	4e2c      	ldr	r6, [pc, #176]	; (35bc <nvs_init+0x268>)
    350c:	4b2a      	ldr	r3, [pc, #168]	; (35b8 <nvs_init+0x264>)
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
    350e:	89a2      	ldrh	r2, [r4, #12]
    3510:	89e1      	ldrh	r1, [r4, #14]
    3512:	4831      	ldr	r0, [pc, #196]	; (35d8 <nvs_init+0x284>)
    3514:	1af6      	subs	r6, r6, r3
    3516:	08f6      	lsrs	r6, r6, #3
    3518:	01b6      	lsls	r6, r6, #6
    351a:	f046 0603 	orr.w	r6, r6, #3
    351e:	4633      	mov	r3, r6
    3520:	f020 fd71 	bl	24006 <log_2>
	LOG_INF("alloc wra: %d, %x",
    3524:	6861      	ldr	r1, [r4, #4]
    3526:	482d      	ldr	r0, [pc, #180]	; (35dc <nvs_init+0x288>)
    3528:	4633      	mov	r3, r6
    352a:	b28a      	uxth	r2, r1
    352c:	0c09      	lsrs	r1, r1, #16
    352e:	f020 fd6a 	bl	24006 <log_2>
	LOG_INF("data wra: %d, %x",
    3532:	68a1      	ldr	r1, [r4, #8]
    3534:	482a      	ldr	r0, [pc, #168]	; (35e0 <nvs_init+0x28c>)
    3536:	b28a      	uxth	r2, r1
    3538:	4633      	mov	r3, r6
    353a:	0c09      	lsrs	r1, r1, #16
    353c:	f020 fd63 	bl	24006 <log_2>
	return 0;
    3540:	e723      	b.n	338a <nvs_init+0x36>
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    3542:	f1b9 0f00 	cmp.w	r9, #0
    3546:	d034      	beq.n	35b2 <nvs_init+0x25e>
				return -ESPIPE;
    3548:	f06f 051c 	mvn.w	r5, #28
    354c:	e71d      	b.n	338a <nvs_init+0x36>
		fs->data_wra += fs->write_block_size;
    354e:	68a3      	ldr	r3, [r4, #8]
    3550:	7c22      	ldrb	r2, [r4, #16]
    3552:	4413      	add	r3, r2
    3554:	60a3      	str	r3, [r4, #8]
    3556:	e7b4      	b.n	34c2 <nvs_init+0x16e>
	if (rc) {
    3558:	d0cf      	beq.n	34fa <nvs_init+0x1a6>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
    355a:	6861      	ldr	r1, [r4, #4]
    355c:	4620      	mov	r0, r4
    355e:	f021 f840 	bl	245e2 <nvs_flash_erase_sector>
		if (rc) {
    3562:	4605      	mov	r5, r0
    3564:	2800      	cmp	r0, #0
    3566:	d1c8      	bne.n	34fa <nvs_init+0x1a6>
		fs->ate_wra &= ADDR_SECT_MASK;
    3568:	6863      	ldr	r3, [r4, #4]
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
    356a:	89a0      	ldrh	r0, [r4, #12]
		fs->ate_wra &= ADDR_SECT_MASK;
    356c:	ea03 0308 	and.w	r3, r3, r8
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
    3570:	4403      	add	r3, r0
    3572:	eba3 0047 	sub.w	r0, r3, r7, lsl #1
    3576:	6060      	str	r0, [r4, #4]
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
    3578:	ea00 0008 	and.w	r0, r0, r8
    357c:	60a0      	str	r0, [r4, #8]
		rc = nvs_gc(fs);
    357e:	4620      	mov	r0, r4
    3580:	f7ff fe46 	bl	3210 <nvs_gc>
    3584:	4605      	mov	r5, r0
end:
    3586:	e7b8      	b.n	34fa <nvs_init+0x1a6>
		if (!nvs_ate_crc8_check(&last_ate)) {
    3588:	a801      	add	r0, sp, #4
    358a:	f020 ffdc 	bl	24546 <nvs_ate_crc8_check>
    358e:	6865      	ldr	r5, [r4, #4]
    3590:	b978      	cbnz	r0, 35b2 <nvs_init+0x25e>
			fs->data_wra = addr & ADDR_SECT_MASK;
    3592:	9800      	ldr	r0, [sp, #0]
			fs->data_wra += last_ate.offset;
    3594:	f8bd 2006 	ldrh.w	r2, [sp, #6]
			fs->data_wra += nvs_al_size(fs, last_ate.len);
    3598:	f8bd 9008 	ldrh.w	r9, [sp, #8]
			fs->data_wra = addr & ADDR_SECT_MASK;
    359c:	ea00 0008 	and.w	r0, r0, r8
			fs->data_wra += last_ate.offset;
    35a0:	4402      	add	r2, r0
			fs->data_wra += nvs_al_size(fs, last_ate.len);
    35a2:	4649      	mov	r1, r9
    35a4:	7c20      	ldrb	r0, [r4, #16]
    35a6:	f020 ffe3 	bl	24570 <nvs_al_size.isra.0>
    35aa:	4410      	add	r0, r2
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    35ac:	42a8      	cmp	r0, r5
			fs->data_wra += nvs_al_size(fs, last_ate.len);
    35ae:	60a0      	str	r0, [r4, #8]
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    35b0:	d0c7      	beq.n	3542 <nvs_init+0x1ee>
		fs->ate_wra -= ate_size;
    35b2:	1bed      	subs	r5, r5, r7
    35b4:	6065      	str	r5, [r4, #4]
    35b6:	e771      	b.n	349c <nvs_init+0x148>
    35b8:	00029830 	.word	0x00029830
    35bc:	000299a8 	.word	0x000299a8
    35c0:	0002abf5 	.word	0x0002abf5
    35c4:	0002ac11 	.word	0x0002ac11
    35c8:	0002ac2e 	.word	0x0002ac2e
    35cc:	0002ac46 	.word	0x0002ac46
    35d0:	0002ac5a 	.word	0x0002ac5a
    35d4:	ffff0000 	.word	0xffff0000
    35d8:	0002ac7d 	.word	0x0002ac7d
    35dc:	0002ac94 	.word	0x0002ac94
    35e0:	0002aca6 	.word	0x0002aca6

000035e4 <nvs_write>:

ssize_t nvs_write(struct nvs_fs *fs, u16_t id, const void *data, size_t len)
{
    35e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    35e8:	461e      	mov	r6, r3
	struct nvs_ate wlk_ate;
	u32_t wlk_addr, rd_addr;
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
	bool prev_found = false;

	if (!fs->ready) {
    35ea:	7c43      	ldrb	r3, [r0, #17]
{
    35ec:	b089      	sub	sp, #36	; 0x24
    35ee:	4604      	mov	r4, r0
    35f0:	4689      	mov	r9, r1
    35f2:	4690      	mov	r8, r2
	if (!fs->ready) {
    35f4:	b97b      	cbnz	r3, 3616 <nvs_write+0x32>
    35f6:	4b67      	ldr	r3, [pc, #412]	; (3794 <nvs_write+0x1b0>)
    35f8:	4967      	ldr	r1, [pc, #412]	; (3798 <nvs_write+0x1b4>)
		LOG_ERR("NVS not initialized");
    35fa:	4868      	ldr	r0, [pc, #416]	; (379c <nvs_write+0x1b8>)
    35fc:	1ac9      	subs	r1, r1, r3
    35fe:	08c9      	lsrs	r1, r1, #3
    3600:	0189      	lsls	r1, r1, #6
    3602:	f041 0101 	orr.w	r1, r1, #1
    3606:	f020 fcdd 	bl	23fc4 <log_0>
		return -EACCES;
    360a:	f06f 050c 	mvn.w	r5, #12
	}
	rc = len;
end:
	k_mutex_unlock(&fs->nvs_lock);
	return rc;
}
    360e:	4628      	mov	r0, r5
    3610:	b009      	add	sp, #36	; 0x24
    3612:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3616:	f890 b010 	ldrb.w	fp, [r0, #16]
    361a:	2108      	movs	r1, #8
    361c:	4658      	mov	r0, fp
    361e:	f020 ffa7 	bl	24570 <nvs_al_size.isra.0>
	if ((len > (fs->sector_size - 3 * ate_size)) ||
    3622:	89a3      	ldrh	r3, [r4, #12]
    3624:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    3628:	1a9b      	subs	r3, r3, r2
    362a:	42b3      	cmp	r3, r6
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    362c:	4682      	mov	sl, r0
	if ((len > (fs->sector_size - 3 * ate_size)) ||
    362e:	f0c0 80ac 	bcc.w	378a <nvs_write+0x1a6>
    3632:	b11e      	cbz	r6, 363c <nvs_write+0x58>
	    ((len > 0) && (data == NULL))) {
    3634:	f1b8 0f00 	cmp.w	r8, #0
    3638:	f000 80a7 	beq.w	378a <nvs_write+0x1a6>
	wlk_addr = fs->ate_wra;
    363c:	6863      	ldr	r3, [r4, #4]
    363e:	9303      	str	r3, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3640:	aa04      	add	r2, sp, #16
    3642:	a903      	add	r1, sp, #12
    3644:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
    3646:	9f03      	ldr	r7, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3648:	f7ff fd70 	bl	312c <nvs_prev_ate>
		if (rc) {
    364c:	4605      	mov	r5, r0
    364e:	2800      	cmp	r0, #0
    3650:	d1dd      	bne.n	360e <nvs_write+0x2a>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
    3652:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    3656:	454b      	cmp	r3, r9
    3658:	d005      	beq.n	3666 <nvs_write+0x82>
		if (wlk_addr == fs->ate_wra) {
    365a:	6862      	ldr	r2, [r4, #4]
    365c:	9b03      	ldr	r3, [sp, #12]
    365e:	429a      	cmp	r2, r3
    3660:	d1ee      	bne.n	3640 <nvs_write+0x5c>
		if (len == 0) {
    3662:	b9d6      	cbnz	r6, 369a <nvs_write+0xb6>
    3664:	e7d3      	b.n	360e <nvs_write+0x2a>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
    3666:	a804      	add	r0, sp, #16
    3668:	f020 ff6d 	bl	24546 <nvs_ate_crc8_check>
    366c:	2800      	cmp	r0, #0
    366e:	d1f4      	bne.n	365a <nvs_write+0x76>
		if (len == 0) {
    3670:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    3674:	b17e      	cbz	r6, 3696 <nvs_write+0xb2>
		} else if (len == wlk_ate.len) {
    3676:	42b3      	cmp	r3, r6
    3678:	d10f      	bne.n	369a <nvs_write+0xb6>
		rd_addr += wlk_ate.offset;
    367a:	f8bd 0012 	ldrh.w	r0, [sp, #18]
		rd_addr &= ADDR_SECT_MASK;
    367e:	0c39      	lsrs	r1, r7, #16
    3680:	0409      	lsls	r1, r1, #16
			rc = nvs_flash_block_cmp(fs, rd_addr, data, len);
    3682:	4401      	add	r1, r0
    3684:	4633      	mov	r3, r6
    3686:	4642      	mov	r2, r8
    3688:	4620      	mov	r0, r4
    368a:	f020 ff33 	bl	244f4 <nvs_flash_block_cmp>
			if (rc <= 0) {
    368e:	2800      	cmp	r0, #0
    3690:	dc03      	bgt.n	369a <nvs_write+0xb6>
    3692:	4605      	mov	r5, r0
    3694:	e7bb      	b.n	360e <nvs_write+0x2a>
			if (wlk_ate.len == 0U) {
    3696:	2b00      	cmp	r3, #0
    3698:	d0b9      	beq.n	360e <nvs_write+0x2a>
	data_size = nvs_al_size(fs, len);
    369a:	4631      	mov	r1, r6
    369c:	4658      	mov	r0, fp
    369e:	f020 ff67 	bl	24570 <nvs_al_size.isra.0>
	if (data_size) {
    36a2:	4607      	mov	r7, r0
    36a4:	2800      	cmp	r0, #0
    36a6:	d13d      	bne.n	3724 <nvs_write+0x140>
	k_mutex_lock(&fs->nvs_lock, K_FOREVER);
    36a8:	f104 0a14 	add.w	sl, r4, #20
	return z_impl_k_mutex_lock(mutex, timeout);
    36ac:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    36b0:	4650      	mov	r0, sl
	fs->ate_wra &= ADDR_SECT_MASK;
    36b2:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 37a0 <nvs_write+0x1bc>
    36b6:	f01d fa37 	bl	20b28 <z_impl_k_mutex_lock>
	gc_count = 0;
    36ba:	2300      	movs	r3, #0
		if (gc_count == fs->sector_count) {
    36bc:	89e2      	ldrh	r2, [r4, #14]
    36be:	4293      	cmp	r3, r2
    36c0:	d060      	beq.n	3784 <nvs_write+0x1a0>
		if (fs->ate_wra >= fs->data_wra + required_space) {
    36c2:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
    36c6:	1878      	adds	r0, r7, r1
    36c8:	4282      	cmp	r2, r0
    36ca:	d32e      	bcc.n	372a <nvs_write+0x146>
	entry.part = 0xff;
    36cc:	23ff      	movs	r3, #255	; 0xff
	nvs_ate_crc8_update(&entry);
    36ce:	a806      	add	r0, sp, #24
	entry.id = id;
    36d0:	f8ad 9018 	strh.w	r9, [sp, #24]
	entry.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
    36d4:	f8ad 101a 	strh.w	r1, [sp, #26]
	entry.len = (u16_t)len;
    36d8:	f8ad 601c 	strh.w	r6, [sp, #28]
	entry.part = 0xff;
    36dc:	f88d 301e 	strb.w	r3, [sp, #30]
	nvs_ate_crc8_update(&entry);
    36e0:	f020 ff3d 	bl	2455e <nvs_ate_crc8_update>
	if (!len) {
    36e4:	b136      	cbz	r6, 36f4 <nvs_write+0x110>
    36e6:	68a1      	ldr	r1, [r4, #8]
    36e8:	4633      	mov	r3, r6
    36ea:	4642      	mov	r2, r8
    36ec:	4620      	mov	r0, r4
    36ee:	f020 ff9e 	bl	2462e <nvs_flash_al_wrt.part.0>
    36f2:	4605      	mov	r5, r0
	fs->data_wra += nvs_al_size(fs, len);
    36f4:	7c20      	ldrb	r0, [r4, #16]
    36f6:	4631      	mov	r1, r6
    36f8:	f020 ff3a 	bl	24570 <nvs_al_size.isra.0>
    36fc:	68a3      	ldr	r3, [r4, #8]
    36fe:	4403      	add	r3, r0
    3700:	60a3      	str	r3, [r4, #8]
	if (rc) {
    3702:	2d00      	cmp	r5, #0
    3704:	d144      	bne.n	3790 <nvs_write+0x1ac>
	rc = nvs_flash_ate_wrt(fs, &entry);
    3706:	a906      	add	r1, sp, #24
    3708:	4620      	mov	r0, r4
    370a:	f020 ffd4 	bl	246b6 <nvs_flash_ate_wrt>
	if (rc) {
    370e:	4605      	mov	r5, r0
    3710:	2800      	cmp	r0, #0
    3712:	d13d      	bne.n	3790 <nvs_write+0x1ac>
	rc = len;
    3714:	4632      	mov	r2, r6
    3716:	9201      	str	r2, [sp, #4]
	return z_impl_k_mutex_unlock(mutex);
    3718:	4650      	mov	r0, sl
    371a:	f01d fae3 	bl	20ce4 <z_impl_k_mutex_unlock>
	return rc;
    371e:	9a01      	ldr	r2, [sp, #4]
    3720:	4615      	mov	r5, r2
    3722:	e774      	b.n	360e <nvs_write+0x2a>
		required_space = data_size + ate_size;
    3724:	4457      	add	r7, sl
    3726:	b2bf      	uxth	r7, r7
    3728:	e7be      	b.n	36a8 <nvs_write+0xc4>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    372a:	7c20      	ldrb	r0, [r4, #16]
    372c:	9301      	str	r3, [sp, #4]
    372e:	2108      	movs	r1, #8
    3730:	f020 ff1e 	bl	24570 <nvs_al_size.isra.0>
	close_ate.id = 0xFFFF;
    3734:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3738:	f8ad 1018 	strh.w	r1, [sp, #24]
	close_ate.len = 0U;
    373c:	2100      	movs	r1, #0
    373e:	f8ad 101c 	strh.w	r1, [sp, #28]
	close_ate.offset = (u16_t)((fs->ate_wra + ate_size) & ADDR_OFFS_MASK);
    3742:	1811      	adds	r1, r2, r0
    3744:	f8ad 101a 	strh.w	r1, [sp, #26]
	fs->ate_wra += (fs->sector_size - ate_size);
    3748:	89a1      	ldrh	r1, [r4, #12]
	fs->ate_wra &= ADDR_SECT_MASK;
    374a:	ea02 020b 	and.w	r2, r2, fp
	fs->ate_wra += (fs->sector_size - ate_size);
    374e:	440a      	add	r2, r1
    3750:	1a10      	subs	r0, r2, r0
    3752:	6060      	str	r0, [r4, #4]
	nvs_ate_crc8_update(&close_ate);
    3754:	a806      	add	r0, sp, #24
    3756:	f020 ff02 	bl	2455e <nvs_ate_crc8_update>
	rc = nvs_flash_ate_wrt(fs, &close_ate);
    375a:	a906      	add	r1, sp, #24
    375c:	4620      	mov	r0, r4
    375e:	f020 ffaa 	bl	246b6 <nvs_flash_ate_wrt>
	nvs_sector_advance(fs, &fs->ate_wra);
    3762:	89e0      	ldrh	r0, [r4, #14]
    3764:	1d21      	adds	r1, r4, #4
    3766:	f020 ff0d 	bl	24584 <nvs_sector_advance.isra.0>
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
    376a:	6862      	ldr	r2, [r4, #4]
    376c:	ea02 020b 	and.w	r2, r2, fp
    3770:	60a2      	str	r2, [r4, #8]
		rc = nvs_gc(fs);
    3772:	4620      	mov	r0, r4
    3774:	f7ff fd4c 	bl	3210 <nvs_gc>
		if (rc) {
    3778:	4602      	mov	r2, r0
    377a:	2800      	cmp	r0, #0
    377c:	d1cb      	bne.n	3716 <nvs_write+0x132>
		gc_count++;
    377e:	9b01      	ldr	r3, [sp, #4]
    3780:	3301      	adds	r3, #1
		if (gc_count == fs->sector_count) {
    3782:	e79b      	b.n	36bc <nvs_write+0xd8>
			rc = -ENOSPC;
    3784:	f06f 021b 	mvn.w	r2, #27
    3788:	e7c5      	b.n	3716 <nvs_write+0x132>
		return -EINVAL;
    378a:	f06f 0515 	mvn.w	r5, #21
    378e:	e73e      	b.n	360e <nvs_write+0x2a>
			if (rc) {
    3790:	462a      	mov	r2, r5
    3792:	e7c0      	b.n	3716 <nvs_write+0x132>
    3794:	00029830 	.word	0x00029830
    3798:	000299a8 	.word	0x000299a8
    379c:	0002abe1 	.word	0x0002abe1
    37a0:	ffff0000 	.word	0xffff0000

000037a4 <nvs_read_hist>:
	return nvs_write(fs, id, NULL, 0);
}

ssize_t nvs_read_hist(struct nvs_fs *fs, u16_t id, void *data, size_t len,
		      u16_t cnt)
{
    37a4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    37a8:	461e      	mov	r6, r3
	u32_t wlk_addr, rd_addr;
	u16_t cnt_his;
	struct nvs_ate wlk_ate;
	size_t ate_size;

	if (!fs->ready) {
    37aa:	7c43      	ldrb	r3, [r0, #17]
{
    37ac:	f8bd 9030 	ldrh.w	r9, [sp, #48]	; 0x30
    37b0:	4604      	mov	r4, r0
    37b2:	460f      	mov	r7, r1
    37b4:	4690      	mov	r8, r2
	if (!fs->ready) {
    37b6:	b973      	cbnz	r3, 37d6 <nvs_read_hist+0x32>
    37b8:	4b2b      	ldr	r3, [pc, #172]	; (3868 <nvs_read_hist+0xc4>)
    37ba:	492c      	ldr	r1, [pc, #176]	; (386c <nvs_read_hist+0xc8>)
		LOG_ERR("NVS not initialized");
    37bc:	482c      	ldr	r0, [pc, #176]	; (3870 <nvs_read_hist+0xcc>)
    37be:	1ac9      	subs	r1, r1, r3
    37c0:	08c9      	lsrs	r1, r1, #3
    37c2:	0189      	lsls	r1, r1, #6
    37c4:	f041 0101 	orr.w	r1, r1, #1
    37c8:	f020 fbfc 	bl	23fc4 <log_0>
		return -EACCES;
    37cc:	f06f 000c 	mvn.w	r0, #12

	return wlk_ate.len;

err:
	return rc;
}
    37d0:	b004      	add	sp, #16
    37d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    37d6:	7c00      	ldrb	r0, [r0, #16]
    37d8:	2108      	movs	r1, #8
    37da:	f020 fec9 	bl	24570 <nvs_al_size.isra.0>
	if (len > (fs->sector_size - 2 * ate_size)) {
    37de:	89a3      	ldrh	r3, [r4, #12]
    37e0:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
    37e4:	42b3      	cmp	r3, r6
    37e6:	d33b      	bcc.n	3860 <nvs_read_hist+0xbc>
	wlk_addr = fs->ate_wra;
    37e8:	6863      	ldr	r3, [r4, #4]
    37ea:	9301      	str	r3, [sp, #4]
	cnt_his = 0U;
    37ec:	f04f 0a00 	mov.w	sl, #0
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    37f0:	aa02      	add	r2, sp, #8
    37f2:	a901      	add	r1, sp, #4
    37f4:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
    37f6:	9d01      	ldr	r5, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    37f8:	f7ff fc98 	bl	312c <nvs_prev_ate>
		if (rc) {
    37fc:	2800      	cmp	r0, #0
    37fe:	d1e7      	bne.n	37d0 <nvs_read_hist+0x2c>
		if ((wlk_ate.id == id) &&  (!nvs_ate_crc8_check(&wlk_ate))) {
    3800:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    3804:	42bb      	cmp	r3, r7
    3806:	d107      	bne.n	3818 <nvs_read_hist+0x74>
    3808:	a802      	add	r0, sp, #8
    380a:	f020 fe9c 	bl	24546 <nvs_ate_crc8_check>
    380e:	b918      	cbnz	r0, 3818 <nvs_read_hist+0x74>
			cnt_his++;
    3810:	f10a 0a01 	add.w	sl, sl, #1
    3814:	fa1f fa8a 	uxth.w	sl, sl
		if (wlk_addr == fs->ate_wra) {
    3818:	6862      	ldr	r2, [r4, #4]
    381a:	9b01      	ldr	r3, [sp, #4]
    381c:	429a      	cmp	r2, r3
    381e:	d018      	beq.n	3852 <nvs_read_hist+0xae>
	while (cnt_his <= cnt) {
    3820:	45ca      	cmp	sl, r9
    3822:	d9e5      	bls.n	37f0 <nvs_read_hist+0x4c>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
    3824:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
    3828:	b1bb      	cbz	r3, 385a <nvs_read_hist+0xb6>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
    382a:	45ca      	cmp	sl, r9
    382c:	d315      	bcc.n	385a <nvs_read_hist+0xb6>
	rd_addr += wlk_ate.offset;
    382e:	f8bd 100a 	ldrh.w	r1, [sp, #10]
	rd_addr &= ADDR_SECT_MASK;
    3832:	0c2d      	lsrs	r5, r5, #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
    3834:	42b3      	cmp	r3, r6
	rd_addr &= ADDR_SECT_MASK;
    3836:	ea4f 4505 	mov.w	r5, r5, lsl #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
    383a:	bf28      	it	cs
    383c:	4633      	movcs	r3, r6
    383e:	4642      	mov	r2, r8
    3840:	4429      	add	r1, r5
    3842:	4620      	mov	r0, r4
    3844:	f020 fe48 	bl	244d8 <nvs_flash_rd>
	if (rc) {
    3848:	2800      	cmp	r0, #0
    384a:	d1c1      	bne.n	37d0 <nvs_read_hist+0x2c>
	return wlk_ate.len;
    384c:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    3850:	e7be      	b.n	37d0 <nvs_read_hist+0x2c>
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
    3852:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    3856:	42bb      	cmp	r3, r7
    3858:	d0e4      	beq.n	3824 <nvs_read_hist+0x80>
		return -ENOENT;
    385a:	f06f 0001 	mvn.w	r0, #1
    385e:	e7b7      	b.n	37d0 <nvs_read_hist+0x2c>
		return -EINVAL;
    3860:	f06f 0015 	mvn.w	r0, #21
    3864:	e7b4      	b.n	37d0 <nvs_read_hist+0x2c>
    3866:	bf00      	nop
    3868:	00029830 	.word	0x00029830
    386c:	000299a8 	.word	0x000299a8
    3870:	0002abe1 	.word	0x0002abe1

00003874 <get_flash_area_from_id>:
extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static struct flash_area const *get_flash_area_from_id(int idx)
{
	for (int i = 0; i < flash_map_entries; i++) {
    3874:	4b09      	ldr	r3, [pc, #36]	; (389c <get_flash_area_from_id+0x28>)
{
    3876:	b530      	push	{r4, r5, lr}
	for (int i = 0; i < flash_map_entries; i++) {
    3878:	681d      	ldr	r5, [r3, #0]
		if (flash_map[i].fa_id == idx) {
    387a:	4b09      	ldr	r3, [pc, #36]	; (38a0 <get_flash_area_from_id+0x2c>)
{
    387c:	4602      	mov	r2, r0
		if (flash_map[i].fa_id == idx) {
    387e:	681c      	ldr	r4, [r3, #0]
	for (int i = 0; i < flash_map_entries; i++) {
    3880:	2300      	movs	r3, #0
    3882:	429d      	cmp	r5, r3
    3884:	dc01      	bgt.n	388a <get_flash_area_from_id+0x16>
			return &flash_map[i];
		}
	}

	return NULL;
    3886:	2000      	movs	r0, #0
}
    3888:	bd30      	pop	{r4, r5, pc}
		if (flash_map[i].fa_id == idx) {
    388a:	0119      	lsls	r1, r3, #4
    388c:	eb04 1003 	add.w	r0, r4, r3, lsl #4
    3890:	5c61      	ldrb	r1, [r4, r1]
    3892:	4291      	cmp	r1, r2
    3894:	d0f8      	beq.n	3888 <get_flash_area_from_id+0x14>
	for (int i = 0; i < flash_map_entries; i++) {
    3896:	3301      	adds	r3, #1
    3898:	e7f3      	b.n	3882 <get_flash_area_from_id+0xe>
    389a:	bf00      	nop
    389c:	00029bf8 	.word	0x00029bf8
    38a0:	20006a9c 	.word	0x20006a9c

000038a4 <flash_area_open>:

int flash_area_open(u8_t id, const struct flash_area **fap)
{
	const struct flash_area *area;

	if (flash_map == NULL) {
    38a4:	4b08      	ldr	r3, [pc, #32]	; (38c8 <flash_area_open+0x24>)
    38a6:	681b      	ldr	r3, [r3, #0]
{
    38a8:	b510      	push	{r4, lr}
    38aa:	460c      	mov	r4, r1
	if (flash_map == NULL) {
    38ac:	b12b      	cbz	r3, 38ba <flash_area_open+0x16>
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
    38ae:	f7ff ffe1 	bl	3874 <get_flash_area_from_id>
	if (area == NULL) {
    38b2:	b128      	cbz	r0, 38c0 <flash_area_open+0x1c>
		return -ENOENT;
	}

	*fap = area;
    38b4:	6020      	str	r0, [r4, #0]
	return 0;
    38b6:	2000      	movs	r0, #0
}
    38b8:	bd10      	pop	{r4, pc}
		return -EACCES;
    38ba:	f06f 000c 	mvn.w	r0, #12
    38be:	e7fb      	b.n	38b8 <flash_area_open+0x14>
		return -ENOENT;
    38c0:	f06f 0001 	mvn.w	r0, #1
    38c4:	e7f8      	b.n	38b8 <flash_area_open+0x14>
    38c6:	bf00      	nop
    38c8:	20006a9c 	.word	0x20006a9c

000038cc <flash_area_get_sectors>:

	return true;
}

int flash_area_get_sectors(int idx, u32_t *cnt, struct flash_sector *ret)
{
    38cc:	b530      	push	{r4, r5, lr}
    38ce:	b089      	sub	sp, #36	; 0x24
    38d0:	460c      	mov	r4, r1
    38d2:	4615      	mov	r5, r2
	cb_data->area_idx = idx;
    38d4:	9001      	str	r0, [sp, #4]
	fa = get_flash_area_from_id(idx);
    38d6:	f7ff ffcd 	bl	3874 <get_flash_area_from_id>
	if (fa == NULL) {
    38da:	b1b8      	cbz	r0, 390c <flash_area_get_sectors+0x40>
	cb_data->area_off = fa->fa_off;
    38dc:	6843      	ldr	r3, [r0, #4]
    38de:	9302      	str	r3, [sp, #8]
	cb_data->area_len = fa->fa_size;
    38e0:	6883      	ldr	r3, [r0, #8]
	cb_data->ret_len = *cnt;
    38e2:	6822      	ldr	r2, [r4, #0]
	flash_dev = device_get_binding(fa->fa_dev_name);
    38e4:	68c0      	ldr	r0, [r0, #12]
	cb_data->ret = ret;
    38e6:	e9cd 3503 	strd	r3, r5, [sp, #12]
	cb_data->ret_idx = 0U;
    38ea:	2300      	movs	r3, #0
	cb_data->status = 0;
    38ec:	e9cd 2306 	strd	r2, r3, [sp, #24]
	cb_data->ret_idx = 0U;
    38f0:	9305      	str	r3, [sp, #20]
    38f2:	f01c fd69 	bl	203c8 <z_impl_device_get_binding>
	if (flash_dev == NULL) {
    38f6:	b160      	cbz	r0, 3912 <flash_area_get_sectors+0x46>
	flash_page_foreach(flash_dev, cb, cb_data);
    38f8:	4907      	ldr	r1, [pc, #28]	; (3918 <flash_area_get_sectors+0x4c>)
    38fa:	aa01      	add	r2, sp, #4
    38fc:	f025 fc08 	bl	29110 <flash_page_foreach>
	if (cb_data->status == 0) {
    3900:	9807      	ldr	r0, [sp, #28]
    3902:	b908      	cbnz	r0, 3908 <flash_area_get_sectors+0x3c>
		*cnt = cb_data->ret_idx;
    3904:	9b05      	ldr	r3, [sp, #20]
    3906:	6023      	str	r3, [r4, #0]
	struct layout_data data;

	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
}
    3908:	b009      	add	sp, #36	; 0x24
    390a:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
    390c:	f06f 0015 	mvn.w	r0, #21
    3910:	e7fa      	b.n	3908 <flash_area_get_sectors+0x3c>
		return -ENODEV;
    3912:	f06f 0012 	mvn.w	r0, #18
	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
    3916:	e7f7      	b.n	3908 <flash_area_get_sectors+0x3c>
    3918:	000246ef 	.word	0x000246ef

0000391c <settings_save_one>:
int settings_save_one(const char *name, const void *value, size_t val_len)
{
	int rc;
	struct settings_store *cs;

	cs = settings_save_dst;
    391c:	4b0f      	ldr	r3, [pc, #60]	; (395c <settings_save_one+0x40>)
{
    391e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	cs = settings_save_dst;
    3922:	681c      	ldr	r4, [r3, #0]
{
    3924:	4605      	mov	r5, r0
    3926:	460e      	mov	r6, r1
    3928:	4617      	mov	r7, r2
	if (!cs) {
    392a:	b19c      	cbz	r4, 3954 <settings_save_one+0x38>
	return z_impl_k_mutex_lock(mutex, timeout);
    392c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3930:	480b      	ldr	r0, [pc, #44]	; (3960 <settings_save_one+0x44>)
    3932:	f01d f8f9 	bl	20b28 <z_impl_k_mutex_lock>
		return -ENOENT;
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	rc = cs->cs_itf->csi_save(cs, name, (char *)value, val_len);
    3936:	6863      	ldr	r3, [r4, #4]
    3938:	4632      	mov	r2, r6
    393a:	f8d3 8008 	ldr.w	r8, [r3, #8]
    393e:	4629      	mov	r1, r5
    3940:	463b      	mov	r3, r7
    3942:	4620      	mov	r0, r4
    3944:	47c0      	blx	r8
    3946:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
    3948:	4805      	ldr	r0, [pc, #20]	; (3960 <settings_save_one+0x44>)
    394a:	f01d f9cb 	bl	20ce4 <z_impl_k_mutex_unlock>

	k_mutex_unlock(&settings_lock);

	return rc;
}
    394e:	4620      	mov	r0, r4
    3950:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOENT;
    3954:	f06f 0401 	mvn.w	r4, #1
    3958:	e7f9      	b.n	394e <settings_save_one+0x32>
    395a:	bf00      	nop
    395c:	200002ac 	.word	0x200002ac
    3960:	2000760c 	.word	0x2000760c

00003964 <settings_src_register>:
	return node->next;
}

static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child)
{
	parent->next = child;
    3964:	2300      	movs	r3, #0
    3966:	6003      	str	r3, [r0, #0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    3968:	4b04      	ldr	r3, [pc, #16]	; (397c <settings_src_register+0x18>)
    396a:	685a      	ldr	r2, [r3, #4]
    396c:	b912      	cbnz	r2, 3974 <settings_src_register+0x10>
	list->head = node;
    396e:	e9c3 0000 	strd	r0, r0, [r3]
}
    3972:	4770      	bx	lr
	parent->next = child;
    3974:	6010      	str	r0, [r2, #0]
	list->tail = node;
    3976:	6058      	str	r0, [r3, #4]
}
    3978:	4770      	bx	lr
    397a:	bf00      	nop
    397c:	200002a4 	.word	0x200002a4

00003980 <settings_dst_register>:
	settings_save_dst = cs;
    3980:	4b01      	ldr	r3, [pc, #4]	; (3988 <settings_dst_register+0x8>)
    3982:	6018      	str	r0, [r3, #0]
}
    3984:	4770      	bx	lr
    3986:	bf00      	nop
    3988:	200002ac 	.word	0x200002ac

0000398c <settings_load_subtree>:
{
    398c:	b530      	push	{r4, r5, lr}
    398e:	b085      	sub	sp, #20
	const struct settings_load_arg arg = {
    3990:	2300      	movs	r3, #0
{
    3992:	4605      	mov	r5, r0
	const struct settings_load_arg arg = {
    3994:	e9cd 3302 	strd	r3, r3, [sp, #8]
    3998:	9001      	str	r0, [sp, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
    399a:	480e      	ldr	r0, [pc, #56]	; (39d4 <settings_load_subtree+0x48>)
    399c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    39a0:	f01d f8c2 	bl	20b28 <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    39a4:	4b0c      	ldr	r3, [pc, #48]	; (39d8 <settings_load_subtree+0x4c>)
    39a6:	681c      	ldr	r4, [r3, #0]
    39a8:	2c00      	cmp	r4, #0
    39aa:	bf38      	it	cc
    39ac:	2400      	movcc	r4, #0
    39ae:	b13c      	cbz	r4, 39c0 <settings_load_subtree+0x34>
		cs->cs_itf->csi_load(cs, &arg);
    39b0:	6863      	ldr	r3, [r4, #4]
    39b2:	4620      	mov	r0, r4
    39b4:	681b      	ldr	r3, [r3, #0]
    39b6:	a901      	add	r1, sp, #4
    39b8:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    39ba:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    39bc:	2c00      	cmp	r4, #0
    39be:	d1f6      	bne.n	39ae <settings_load_subtree+0x22>
	rc = settings_commit_subtree(subtree);
    39c0:	4628      	mov	r0, r5
    39c2:	f000 f8ef 	bl	3ba4 <settings_commit_subtree>
    39c6:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
    39c8:	4802      	ldr	r0, [pc, #8]	; (39d4 <settings_load_subtree+0x48>)
    39ca:	f01d f98b 	bl	20ce4 <z_impl_k_mutex_unlock>
}
    39ce:	4620      	mov	r0, r4
    39d0:	b005      	add	sp, #20
    39d2:	bd30      	pop	{r4, r5, pc}
    39d4:	2000760c 	.word	0x2000760c
    39d8:	200002a4 	.word	0x200002a4

000039dc <settings_load_subtree_direct>:
{
    39dc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	const struct settings_load_arg arg = {
    39de:	e9cd 0101 	strd	r0, r1, [sp, #4]
    39e2:	9203      	str	r2, [sp, #12]
	return z_impl_k_mutex_lock(mutex, timeout);
    39e4:	480c      	ldr	r0, [pc, #48]	; (3a18 <settings_load_subtree_direct+0x3c>)
    39e6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    39ea:	f01d f89d 	bl	20b28 <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    39ee:	4b0b      	ldr	r3, [pc, #44]	; (3a1c <settings_load_subtree_direct+0x40>)
    39f0:	681c      	ldr	r4, [r3, #0]
    39f2:	2c00      	cmp	r4, #0
    39f4:	bf38      	it	cc
    39f6:	2400      	movcc	r4, #0
    39f8:	b13c      	cbz	r4, 3a0a <settings_load_subtree_direct+0x2e>
		cs->cs_itf->csi_load(cs, &arg);
    39fa:	6863      	ldr	r3, [r4, #4]
    39fc:	4620      	mov	r0, r4
    39fe:	681b      	ldr	r3, [r3, #0]
    3a00:	a901      	add	r1, sp, #4
    3a02:	4798      	blx	r3
    3a04:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    3a06:	2c00      	cmp	r4, #0
    3a08:	d1f6      	bne.n	39f8 <settings_load_subtree_direct+0x1c>
	return z_impl_k_mutex_unlock(mutex);
    3a0a:	4803      	ldr	r0, [pc, #12]	; (3a18 <settings_load_subtree_direct+0x3c>)
    3a0c:	f01d f96a 	bl	20ce4 <z_impl_k_mutex_unlock>
}
    3a10:	2000      	movs	r0, #0
    3a12:	b004      	add	sp, #16
    3a14:	bd10      	pop	{r4, pc}
    3a16:	bf00      	nop
    3a18:	2000760c 	.word	0x2000760c
    3a1c:	200002a4 	.word	0x200002a4

00003a20 <settings_store_init>:
	list->head = NULL;
    3a20:	4b02      	ldr	r3, [pc, #8]	; (3a2c <settings_store_init+0xc>)
    3a22:	2200      	movs	r2, #0
	list->tail = NULL;
    3a24:	e9c3 2200 	strd	r2, r2, [r3]
}

void settings_store_init(void)
{
	sys_slist_init(&settings_load_srcs);
}
    3a28:	4770      	bx	lr
    3a2a:	bf00      	nop
    3a2c:	200002a4 	.word	0x200002a4

00003a30 <settings_init>:
	list->head = NULL;
    3a30:	4b02      	ldr	r3, [pc, #8]	; (3a3c <settings_init+0xc>)
    3a32:	2200      	movs	r2, #0
	list->tail = NULL;
    3a34:	e9c3 2200 	strd	r2, r2, [r3]
void settings_init(void)
{
#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	sys_slist_init(&settings_handlers);
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	settings_store_init();
    3a38:	f7ff bff2 	b.w	3a20 <settings_store_init>
    3a3c:	200002b0 	.word	0x200002b0

00003a40 <settings_parse_and_lookup>:
	return rc;
}

struct settings_handler_static *settings_parse_and_lookup(const char *name,
							const char **next)
{
    3a40:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    3a44:	4607      	mov	r7, r0
	struct settings_handler_static *bestmatch;
	const char *tmpnext;

	bestmatch = NULL;
	if (next) {
    3a46:	460e      	mov	r6, r1
    3a48:	b109      	cbz	r1, 3a4e <settings_parse_and_lookup+0xe>
		*next = NULL;
    3a4a:	2300      	movs	r3, #0
    3a4c:	600b      	str	r3, [r1, #0]
	}

	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3a4e:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 3b00 <settings_parse_and_lookup+0xc0>
    3a52:	4c26      	ldr	r4, [pc, #152]	; (3aec <settings_parse_and_lookup+0xac>)
    3a54:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 3b04 <settings_parse_and_lookup+0xc4>
    3a58:	2500      	movs	r5, #0
    3a5a:	46c2      	mov	sl, r8
    3a5c:	4544      	cmp	r4, r8
    3a5e:	d90c      	bls.n	3a7a <settings_parse_and_lookup+0x3a>
    3a60:	4923      	ldr	r1, [pc, #140]	; (3af0 <settings_parse_and_lookup+0xb0>)
    3a62:	4824      	ldr	r0, [pc, #144]	; (3af4 <settings_parse_and_lookup+0xb4>)
    3a64:	2394      	movs	r3, #148	; 0x94
    3a66:	464a      	mov	r2, r9
    3a68:	f020 fa3b 	bl	23ee2 <printk>
    3a6c:	4822      	ldr	r0, [pc, #136]	; (3af8 <settings_parse_and_lookup+0xb8>)
    3a6e:	f020 fa38 	bl	23ee2 <printk>
    3a72:	2194      	movs	r1, #148	; 0x94
    3a74:	4648      	mov	r0, r9
    3a76:	f020 fa77 	bl	23f68 <assert_post_action>
    3a7a:	4554      	cmp	r4, sl
    3a7c:	d308      	bcc.n	3a90 <settings_parse_and_lookup+0x50>
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;

	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    3a7e:	4b1f      	ldr	r3, [pc, #124]	; (3afc <settings_parse_and_lookup+0xbc>)
    3a80:	681c      	ldr	r4, [r3, #0]
    3a82:	b10c      	cbz	r4, 3a88 <settings_parse_and_lookup+0x48>
    3a84:	3c14      	subs	r4, #20
    3a86:	b9c4      	cbnz	r4, 3aba <settings_parse_and_lookup+0x7a>
			}
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	return bestmatch;
}
    3a88:	4628      	mov	r0, r5
    3a8a:	b002      	add	sp, #8
    3a8c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    3a90:	6821      	ldr	r1, [r4, #0]
    3a92:	aa01      	add	r2, sp, #4
    3a94:	4638      	mov	r0, r7
    3a96:	f020 fe4f 	bl	24738 <settings_name_steq>
    3a9a:	b160      	cbz	r0, 3ab6 <settings_parse_and_lookup+0x76>
		if (!bestmatch) {
    3a9c:	b925      	cbnz	r5, 3aa8 <settings_parse_and_lookup+0x68>
			if (next) {
    3a9e:	b10e      	cbz	r6, 3aa4 <settings_parse_and_lookup+0x64>
				*next = tmpnext;
    3aa0:	9b01      	ldr	r3, [sp, #4]
    3aa2:	6033      	str	r3, [r6, #0]
    3aa4:	4625      	mov	r5, r4
    3aa6:	e006      	b.n	3ab6 <settings_parse_and_lookup+0x76>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    3aa8:	6829      	ldr	r1, [r5, #0]
    3aaa:	6820      	ldr	r0, [r4, #0]
    3aac:	2200      	movs	r2, #0
    3aae:	f020 fe43 	bl	24738 <settings_name_steq>
    3ab2:	2800      	cmp	r0, #0
    3ab4:	d1f3      	bne.n	3a9e <settings_parse_and_lookup+0x5e>
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3ab6:	3414      	adds	r4, #20
    3ab8:	e7d0      	b.n	3a5c <settings_parse_and_lookup+0x1c>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    3aba:	6821      	ldr	r1, [r4, #0]
    3abc:	aa01      	add	r2, sp, #4
    3abe:	4638      	mov	r0, r7
    3ac0:	f020 fe3a 	bl	24738 <settings_name_steq>
    3ac4:	b160      	cbz	r0, 3ae0 <settings_parse_and_lookup+0xa0>
		if (!bestmatch) {
    3ac6:	b925      	cbnz	r5, 3ad2 <settings_parse_and_lookup+0x92>
			if (next) {
    3ac8:	b10e      	cbz	r6, 3ace <settings_parse_and_lookup+0x8e>
				*next = tmpnext;
    3aca:	9b01      	ldr	r3, [sp, #4]
    3acc:	6033      	str	r3, [r6, #0]
    3ace:	4625      	mov	r5, r4
    3ad0:	e006      	b.n	3ae0 <settings_parse_and_lookup+0xa0>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    3ad2:	6829      	ldr	r1, [r5, #0]
    3ad4:	6820      	ldr	r0, [r4, #0]
    3ad6:	2200      	movs	r2, #0
    3ad8:	f020 fe2e 	bl	24738 <settings_name_steq>
    3adc:	2800      	cmp	r0, #0
    3ade:	d1f3      	bne.n	3ac8 <settings_parse_and_lookup+0x88>
Z_GENLIST_PEEK_NEXT(slist, snode)
    3ae0:	f114 0f14 	cmn.w	r4, #20
    3ae4:	d0d0      	beq.n	3a88 <settings_parse_and_lookup+0x48>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    3ae6:	6964      	ldr	r4, [r4, #20]
    3ae8:	e7cb      	b.n	3a82 <settings_parse_and_lookup+0x42>
    3aea:	bf00      	nop
    3aec:	000297f4 	.word	0x000297f4
    3af0:	0002ad03 	.word	0x0002ad03
    3af4:	0002a5e8 	.word	0x0002a5e8
    3af8:	0002ad2b 	.word	0x0002ad2b
    3afc:	200002b0 	.word	0x200002b0
    3b00:	00029830 	.word	0x00029830
    3b04:	0002acd1 	.word	0x0002acd1

00003b08 <settings_call_set_handler>:
int settings_call_set_handler(const char *name,
			      size_t len,
			      settings_read_cb read_cb,
			      void *read_cb_arg,
			      const struct settings_load_arg *load_arg)
{
    3b08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3b0c:	b085      	sub	sp, #20
    3b0e:	4605      	mov	r5, r0
    3b10:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
	int rc;
	const char *name_key = name;
    3b14:	9003      	str	r0, [sp, #12]
{
    3b16:	460c      	mov	r4, r1
    3b18:	4616      	mov	r6, r2
    3b1a:	461f      	mov	r7, r3

	if (load_arg && load_arg->subtree &&
    3b1c:	f1b8 0f00 	cmp.w	r8, #0
    3b20:	d018      	beq.n	3b54 <settings_call_set_handler+0x4c>
    3b22:	f8d8 1000 	ldr.w	r1, [r8]
    3b26:	b181      	cbz	r1, 3b4a <settings_call_set_handler+0x42>
	    !settings_name_steq(name, load_arg->subtree, &name_key)) {
    3b28:	aa03      	add	r2, sp, #12
    3b2a:	f020 fe05 	bl	24738 <settings_name_steq>
	if (load_arg && load_arg->subtree &&
    3b2e:	b960      	cbnz	r0, 3b4a <settings_call_set_handler+0x42>

		if (rc != 0) {
			LOG_ERR("set-value failure. key: %s error(%d)",
				log_strdup(name), rc);
			/* Ignoring the error */
			rc = 0;
    3b30:	2000      	movs	r0, #0
    3b32:	e007      	b.n	3b44 <settings_call_set_handler+0x3c>
		rc = load_arg->cb(name_key, len, read_cb, read_cb_arg,
    3b34:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3b38:	9300      	str	r3, [sp, #0]
    3b3a:	9803      	ldr	r0, [sp, #12]
    3b3c:	463b      	mov	r3, r7
    3b3e:	4632      	mov	r2, r6
    3b40:	4621      	mov	r1, r4
    3b42:	47c8      	blx	r9
			LOG_DBG("set-value OK. key: %s",
				log_strdup(name));
		}
	}
	return rc;
}
    3b44:	b005      	add	sp, #20
    3b46:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (load_arg && load_arg->cb) {
    3b4a:	f8d8 9004 	ldr.w	r9, [r8, #4]
    3b4e:	f1b9 0f00 	cmp.w	r9, #0
    3b52:	d1ef      	bne.n	3b34 <settings_call_set_handler+0x2c>
		ch = settings_parse_and_lookup(name, &name_key);
    3b54:	a903      	add	r1, sp, #12
    3b56:	4628      	mov	r0, r5
    3b58:	f7ff ff72 	bl	3a40 <settings_parse_and_lookup>
		if (!ch) {
    3b5c:	2800      	cmp	r0, #0
    3b5e:	d0e7      	beq.n	3b30 <settings_call_set_handler+0x28>
		rc = ch->h_set(name_key, len, read_cb, read_cb_arg);
    3b60:	f8d0 8008 	ldr.w	r8, [r0, #8]
    3b64:	9803      	ldr	r0, [sp, #12]
    3b66:	4632      	mov	r2, r6
    3b68:	463b      	mov	r3, r7
    3b6a:	4621      	mov	r1, r4
    3b6c:	47c0      	blx	r8
		if (rc != 0) {
    3b6e:	4606      	mov	r6, r0
    3b70:	2800      	cmp	r0, #0
    3b72:	d0dd      	beq.n	3b30 <settings_call_set_handler+0x28>
    3b74:	4b08      	ldr	r3, [pc, #32]	; (3b98 <settings_call_set_handler+0x90>)
    3b76:	4c09      	ldr	r4, [pc, #36]	; (3b9c <settings_call_set_handler+0x94>)
			LOG_ERR("set-value failure. key: %s error(%d)",
    3b78:	4628      	mov	r0, r5
    3b7a:	1ae4      	subs	r4, r4, r3
    3b7c:	08e4      	lsrs	r4, r4, #3
    3b7e:	f7fe fd2f 	bl	25e0 <log_strdup>
    3b82:	01a4      	lsls	r4, r4, #6
    3b84:	f044 0401 	orr.w	r4, r4, #1
    3b88:	4601      	mov	r1, r0
    3b8a:	4623      	mov	r3, r4
    3b8c:	4804      	ldr	r0, [pc, #16]	; (3ba0 <settings_call_set_handler+0x98>)
    3b8e:	4632      	mov	r2, r6
    3b90:	f020 fa39 	bl	24006 <log_2>
    3b94:	e7cc      	b.n	3b30 <settings_call_set_handler+0x28>
    3b96:	bf00      	nop
    3b98:	00029830 	.word	0x00029830
    3b9c:	000299d8 	.word	0x000299d8
    3ba0:	0002ad4a 	.word	0x0002ad4a

00003ba4 <settings_commit_subtree>:
{
	return settings_commit_subtree(NULL);
}

int settings_commit_subtree(const char *subtree)
{
    3ba4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int rc;
	int rc2;

	rc = 0;

	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3ba8:	4f23      	ldr	r7, [pc, #140]	; (3c38 <settings_commit_subtree+0x94>)
    3baa:	4c24      	ldr	r4, [pc, #144]	; (3c3c <settings_commit_subtree+0x98>)
    3bac:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 3c50 <settings_commit_subtree+0xac>
{
    3bb0:	4606      	mov	r6, r0
	rc = 0;
    3bb2:	2500      	movs	r5, #0
    3bb4:	46b9      	mov	r9, r7
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3bb6:	42bc      	cmp	r4, r7
    3bb8:	d90c      	bls.n	3bd4 <settings_commit_subtree+0x30>
    3bba:	4921      	ldr	r1, [pc, #132]	; (3c40 <settings_commit_subtree+0x9c>)
    3bbc:	4821      	ldr	r0, [pc, #132]	; (3c44 <settings_commit_subtree+0xa0>)
    3bbe:	23f4      	movs	r3, #244	; 0xf4
    3bc0:	4642      	mov	r2, r8
    3bc2:	f020 f98e 	bl	23ee2 <printk>
    3bc6:	4820      	ldr	r0, [pc, #128]	; (3c48 <settings_commit_subtree+0xa4>)
    3bc8:	f020 f98b 	bl	23ee2 <printk>
    3bcc:	21f4      	movs	r1, #244	; 0xf4
    3bce:	4640      	mov	r0, r8
    3bd0:	f020 f9ca 	bl	23f68 <assert_post_action>
    3bd4:	454c      	cmp	r4, r9
    3bd6:	d307      	bcc.n	3be8 <settings_commit_subtree+0x44>
		}
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    3bd8:	4b1c      	ldr	r3, [pc, #112]	; (3c4c <settings_commit_subtree+0xa8>)
    3bda:	681c      	ldr	r4, [r3, #0]
    3bdc:	b10c      	cbz	r4, 3be2 <settings_commit_subtree+0x3e>
    3bde:	3c14      	subs	r4, #20
    3be0:	b9a4      	cbnz	r4, 3c0c <settings_commit_subtree+0x68>
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */

	return rc;
}
    3be2:	4628      	mov	r0, r5
    3be4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3be8:	b91e      	cbnz	r6, 3bf2 <settings_commit_subtree+0x4e>
		if (ch->h_commit) {
    3bea:	68e3      	ldr	r3, [r4, #12]
    3bec:	b94b      	cbnz	r3, 3c02 <settings_commit_subtree+0x5e>
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3bee:	3414      	adds	r4, #20
    3bf0:	e7e1      	b.n	3bb6 <settings_commit_subtree+0x12>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3bf2:	6820      	ldr	r0, [r4, #0]
    3bf4:	2200      	movs	r2, #0
    3bf6:	4631      	mov	r1, r6
    3bf8:	f020 fd9e 	bl	24738 <settings_name_steq>
    3bfc:	2800      	cmp	r0, #0
    3bfe:	d1f4      	bne.n	3bea <settings_commit_subtree+0x46>
    3c00:	e7f5      	b.n	3bee <settings_commit_subtree+0x4a>
			rc2 = ch->h_commit();
    3c02:	4798      	blx	r3
				rc = rc2;
    3c04:	2d00      	cmp	r5, #0
    3c06:	bf08      	it	eq
    3c08:	4605      	moveq	r5, r0
    3c0a:	e7f0      	b.n	3bee <settings_commit_subtree+0x4a>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3c0c:	b936      	cbnz	r6, 3c1c <settings_commit_subtree+0x78>
		if (ch->h_commit) {
    3c0e:	68e3      	ldr	r3, [r4, #12]
    3c10:	b963      	cbnz	r3, 3c2c <settings_commit_subtree+0x88>
Z_GENLIST_PEEK_NEXT(slist, snode)
    3c12:	f114 0f14 	cmn.w	r4, #20
    3c16:	d0e4      	beq.n	3be2 <settings_commit_subtree+0x3e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    3c18:	6964      	ldr	r4, [r4, #20]
    3c1a:	e7df      	b.n	3bdc <settings_commit_subtree+0x38>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3c1c:	6820      	ldr	r0, [r4, #0]
    3c1e:	2200      	movs	r2, #0
    3c20:	4631      	mov	r1, r6
    3c22:	f020 fd89 	bl	24738 <settings_name_steq>
    3c26:	2800      	cmp	r0, #0
    3c28:	d1f1      	bne.n	3c0e <settings_commit_subtree+0x6a>
    3c2a:	e7f2      	b.n	3c12 <settings_commit_subtree+0x6e>
			rc2 = ch->h_commit();
    3c2c:	4798      	blx	r3
				rc = rc2;
    3c2e:	2d00      	cmp	r5, #0
    3c30:	bf08      	it	eq
    3c32:	4605      	moveq	r5, r0
    3c34:	e7ed      	b.n	3c12 <settings_commit_subtree+0x6e>
    3c36:	bf00      	nop
    3c38:	00029830 	.word	0x00029830
    3c3c:	000297f4 	.word	0x000297f4
    3c40:	0002ad03 	.word	0x0002ad03
    3c44:	0002a5e8 	.word	0x0002a5e8
    3c48:	0002ad2b 	.word	0x0002ad2b
    3c4c:	200002b0 	.word	0x200002b0
    3c50:	0002acd1 	.word	0x0002acd1

00003c54 <settings_subsys_init>:
void settings_init(void);

int settings_backend_init(void);

int settings_subsys_init(void)
{
    3c54:	b510      	push	{r4, lr}

	int err = 0;

	if (settings_subsys_initialized) {
    3c56:	4c06      	ldr	r4, [pc, #24]	; (3c70 <settings_subsys_init+0x1c>)
    3c58:	7823      	ldrb	r3, [r4, #0]
    3c5a:	b93b      	cbnz	r3, 3c6c <settings_subsys_init+0x18>
		return 0;
	}

	settings_init();
    3c5c:	f7ff fee8 	bl	3a30 <settings_init>

	err = settings_backend_init(); /* func rises kernel panic once error */
    3c60:	f000 f864 	bl	3d2c <settings_backend_init>

	if (!err) {
    3c64:	b908      	cbnz	r0, 3c6a <settings_subsys_init+0x16>
		settings_subsys_initialized = true;
    3c66:	2301      	movs	r3, #1
    3c68:	7023      	strb	r3, [r4, #0]
	}

	return err;
}
    3c6a:	bd10      	pop	{r4, pc}
		return 0;
    3c6c:	2000      	movs	r0, #0
    3c6e:	e7fc      	b.n	3c6a <settings_subsys_init+0x16>
    3c70:	20001f45 	.word	0x20001f45

00003c74 <settings_nvs_load>:
	return 0;
}

static int settings_nvs_load(struct settings_store *cs,
			     const struct settings_load_arg *arg)
{
    3c74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	char name[SETTINGS_MAX_NAME_LEN + SETTINGS_EXTRA_LEN + 1];
	char buf;
	ssize_t rc1, rc2;
	u16_t name_id = NVS_NAMECNT_ID;

	name_id = cf->last_name_id + 1;
    3c78:	8e84      	ldrh	r4, [r0, #52]	; 0x34
		/* Found a name, this might not include a trailing \0 */
		name[rc1] = '\0';
		read_fn_arg.fs = &cf->cf_nvs;
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;

		ret = settings_call_set_handler(
    3c7a:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 3d28 <settings_nvs_load+0xb4>
	name_id = cf->last_name_id + 1;
    3c7e:	3401      	adds	r4, #1
{
    3c80:	b098      	sub	sp, #96	; 0x60
    3c82:	4680      	mov	r8, r0
    3c84:	4689      	mov	r9, r1
	name_id = cf->last_name_id + 1;
    3c86:	b2a4      	uxth	r4, r4
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
    3c88:	f100 0608 	add.w	r6, r0, #8
		name_id--;
    3c8c:	1e65      	subs	r5, r4, #1
    3c8e:	b2ad      	uxth	r5, r5
		if (name_id == NVS_NAMECNT_ID) {
    3c90:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
    3c94:	d045      	beq.n	3d22 <settings_nvs_load+0xae>
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
    3c96:	234a      	movs	r3, #74	; 0x4a
    3c98:	aa05      	add	r2, sp, #20
    3c9a:	4629      	mov	r1, r5
    3c9c:	4630      	mov	r0, r6
    3c9e:	f020 fd1f 	bl	246e0 <nvs_read>
    3ca2:	f504 547f 	add.w	r4, r4, #16320	; 0x3fc0
    3ca6:	343f      	adds	r4, #63	; 0x3f
    3ca8:	b2a4      	uxth	r4, r4
    3caa:	4607      	mov	r7, r0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
    3cac:	4621      	mov	r1, r4
    3cae:	2301      	movs	r3, #1
    3cb0:	f10d 020b 	add.w	r2, sp, #11
    3cb4:	4630      	mov	r0, r6
    3cb6:	f020 fd13 	bl	246e0 <nvs_read>
		if ((rc1 <= 0) && (rc2 <= 0)) {
    3cba:	2f00      	cmp	r7, #0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
    3cbc:	4601      	mov	r1, r0
		if ((rc1 <= 0) && (rc2 <= 0)) {
    3cbe:	dc03      	bgt.n	3cc8 <settings_nvs_load+0x54>
    3cc0:	2800      	cmp	r0, #0
    3cc2:	dc03      	bgt.n	3ccc <settings_nvs_load+0x58>
{
    3cc4:	462c      	mov	r4, r5
    3cc6:	e7e1      	b.n	3c8c <settings_nvs_load+0x18>
		if ((rc1 <= 0) || (rc2 <= 0)) {
    3cc8:	2800      	cmp	r0, #0
    3cca:	dc16      	bgt.n	3cfa <settings_nvs_load+0x86>
			if (name_id == cf->last_name_id) {
    3ccc:	f8b8 3034 	ldrh.w	r3, [r8, #52]	; 0x34
    3cd0:	42ab      	cmp	r3, r5
    3cd2:	d109      	bne.n	3ce8 <settings_nvs_load+0x74>
				cf->last_name_id--;
    3cd4:	4642      	mov	r2, r8
    3cd6:	1e6b      	subs	r3, r5, #1
    3cd8:	f822 3f34 	strh.w	r3, [r2, #52]!
				nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
    3cdc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    3ce0:	2302      	movs	r3, #2
    3ce2:	4630      	mov	r0, r6
    3ce4:	f7ff fc7e 	bl	35e4 <nvs_write>
			nvs_delete(&cf->cf_nvs, name_id);
    3ce8:	4629      	mov	r1, r5
    3cea:	4630      	mov	r0, r6
    3cec:	f020 fcf4 	bl	246d8 <nvs_delete>
			nvs_delete(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET);
    3cf0:	4621      	mov	r1, r4
    3cf2:	4630      	mov	r0, r6
    3cf4:	f020 fcf0 	bl	246d8 <nvs_delete>
			continue;
    3cf8:	e7e4      	b.n	3cc4 <settings_nvs_load+0x50>
		name[rc1] = '\0';
    3cfa:	ab18      	add	r3, sp, #96	; 0x60
    3cfc:	441f      	add	r7, r3
    3cfe:	2300      	movs	r3, #0
    3d00:	f807 3c4c 	strb.w	r3, [r7, #-76]
		ret = settings_call_set_handler(
    3d04:	4652      	mov	r2, sl
    3d06:	f8cd 9000 	str.w	r9, [sp]
    3d0a:	ab03      	add	r3, sp, #12
    3d0c:	a805      	add	r0, sp, #20
		read_fn_arg.fs = &cf->cf_nvs;
    3d0e:	9603      	str	r6, [sp, #12]
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;
    3d10:	f8ad 4010 	strh.w	r4, [sp, #16]
		ret = settings_call_set_handler(
    3d14:	f7ff fef8 	bl	3b08 <settings_call_set_handler>
			name, rc2,
			settings_nvs_read_fn, &read_fn_arg,
			(void *)arg);
		if (ret) {
    3d18:	2800      	cmp	r0, #0
    3d1a:	d0d3      	beq.n	3cc4 <settings_nvs_load+0x50>
			break;
		}
	}
	return ret;
}
    3d1c:	b018      	add	sp, #96	; 0x60
    3d1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3d22:	2000      	movs	r0, #0
	return ret;
    3d24:	e7fa      	b.n	3d1c <settings_nvs_load+0xa8>
    3d26:	bf00      	nop
    3d28:	000247ab 	.word	0x000247ab

00003d2c <settings_backend_init>:
	LOG_DBG("Initialized");
	return 0;
}

int settings_backend_init(void)
{
    3d2c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	int rc;
	u16_t cnt = 0;
	size_t nvs_sector_size, nvs_size = 0;
	const struct flash_area *fa;
	struct flash_sector hw_flash_sector;
	u32_t sector_cnt = 1;
    3d2e:	2301      	movs	r3, #1

	rc = flash_area_open(DT_FLASH_AREA_STORAGE_ID, &fa);
    3d30:	4669      	mov	r1, sp
    3d32:	2004      	movs	r0, #4
	u32_t sector_cnt = 1;
    3d34:	9301      	str	r3, [sp, #4]
	rc = flash_area_open(DT_FLASH_AREA_STORAGE_ID, &fa);
    3d36:	f7ff fdb5 	bl	38a4 <flash_area_open>
	if (rc) {
    3d3a:	4604      	mov	r4, r0
    3d3c:	2800      	cmp	r0, #0
    3d3e:	d136      	bne.n	3dae <settings_backend_init+0x82>
		return rc;
	}

	rc = flash_area_get_sectors(DT_FLASH_AREA_STORAGE_ID, &sector_cnt,
    3d40:	aa02      	add	r2, sp, #8
    3d42:	a901      	add	r1, sp, #4
    3d44:	2004      	movs	r0, #4
    3d46:	f7ff fdc1 	bl	38cc <flash_area_get_sectors>
				    &hw_flash_sector);
	if (rc == -ENODEV) {
    3d4a:	f110 0f13 	cmn.w	r0, #19
	rc = flash_area_get_sectors(DT_FLASH_AREA_STORAGE_ID, &sector_cnt,
    3d4e:	4604      	mov	r4, r0
	if (rc == -ENODEV) {
    3d50:	d02d      	beq.n	3dae <settings_backend_init+0x82>
		return rc;
	} else if (rc != 0 && rc != -ENOMEM) {
    3d52:	b138      	cbz	r0, 3d64 <settings_backend_init+0x38>
    3d54:	340c      	adds	r4, #12
    3d56:	d005      	beq.n	3d64 <settings_backend_init+0x38>
		k_panic();
    3d58:	4040      	eors	r0, r0
    3d5a:	f380 8811 	msr	BASEPRI, r0
    3d5e:	f04f 0004 	mov.w	r0, #4
    3d62:	df02      	svc	2
	}

	nvs_sector_size = CONFIG_SETTINGS_NVS_SECTOR_SIZE_MULT *
    3d64:	9903      	ldr	r1, [sp, #12]
			  hw_flash_sector.fs_size;

	if (nvs_sector_size > UINT16_MAX) {
    3d66:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    3d6a:	d223      	bcs.n	3db4 <settings_backend_init+0x88>
		return -EDOM;
	}

	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
		nvs_size += nvs_sector_size;
		if (nvs_size > fa->fa_size) {
    3d6c:	9a00      	ldr	r2, [sp, #0]
    3d6e:	2300      	movs	r3, #0
    3d70:	6895      	ldr	r5, [r2, #8]
	size_t nvs_sector_size, nvs_size = 0;
    3d72:	4618      	mov	r0, r3
		nvs_size += nvs_sector_size;
    3d74:	4408      	add	r0, r1
		if (nvs_size > fa->fa_size) {
    3d76:	4285      	cmp	r5, r0
    3d78:	b29c      	uxth	r4, r3
    3d7a:	d303      	bcc.n	3d84 <settings_backend_init+0x58>
	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
    3d7c:	3301      	adds	r3, #1
    3d7e:	2b08      	cmp	r3, #8
    3d80:	d1f8      	bne.n	3d74 <settings_backend_init+0x48>
    3d82:	461c      	mov	r4, r3
		}
		cnt++;
	}

	/* define the nvs file system using the page_info */
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
    3d84:	4d0d      	ldr	r5, [pc, #52]	; (3dbc <settings_backend_init+0x90>)
	default_settings_nvs.cf_nvs.sector_count = cnt;
	default_settings_nvs.cf_nvs.offset = fa->fa_off;
    3d86:	6853      	ldr	r3, [r2, #4]
    3d88:	60ab      	str	r3, [r5, #8]
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;

	rc = settings_nvs_backend_init(&default_settings_nvs);
    3d8a:	4628      	mov	r0, r5
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;
    3d8c:	68d3      	ldr	r3, [r2, #12]
	default_settings_nvs.cf_nvs.sector_count = cnt;
    3d8e:	82ec      	strh	r4, [r5, #22]
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
    3d90:	82a9      	strh	r1, [r5, #20]
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;
    3d92:	63ab      	str	r3, [r5, #56]	; 0x38
	rc = settings_nvs_backend_init(&default_settings_nvs);
    3d94:	f020 fd9e 	bl	248d4 <settings_nvs_backend_init>
	if (rc) {
    3d98:	4604      	mov	r4, r0
    3d9a:	b940      	cbnz	r0, 3dae <settings_backend_init+0x82>
	cf->cf_store.cs_itf = &settings_nvs_itf;
    3d9c:	4e08      	ldr	r6, [pc, #32]	; (3dc0 <settings_backend_init+0x94>)
    3d9e:	606e      	str	r6, [r5, #4]
	settings_src_register(&cf->cf_store);
    3da0:	4628      	mov	r0, r5
    3da2:	f7ff fddf 	bl	3964 <settings_src_register>
	settings_dst_register(&cf->cf_store);
    3da6:	4628      	mov	r0, r5
	cf->cf_store.cs_itf = &settings_nvs_itf;
    3da8:	606e      	str	r6, [r5, #4]
	settings_dst_register(&cf->cf_store);
    3daa:	f7ff fde9 	bl	3980 <settings_dst_register>
	}

	rc = settings_nvs_dst(&default_settings_nvs);

	return rc;
}
    3dae:	4620      	mov	r0, r4
    3db0:	b004      	add	sp, #16
    3db2:	bd70      	pop	{r4, r5, r6, pc}
		return -EDOM;
    3db4:	f06f 0424 	mvn.w	r4, #36	; 0x24
    3db8:	e7f9      	b.n	3dae <settings_backend_init+0x82>
    3dba:	bf00      	nop
    3dbc:	200002b8 	.word	0x200002b8
    3dc0:	20006aa0 	.word	0x20006aa0

00003dc4 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    3dc4:	b510      	push	{r4, lr}
    3dc6:	4807      	ldr	r0, [pc, #28]	; (3de4 <uart_console_init+0x20>)
	__stdout_hook_install(console_out);
    3dc8:	4c07      	ldr	r4, [pc, #28]	; (3de8 <uart_console_init+0x24>)
    3dca:	f01c fafd 	bl	203c8 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    3dce:	4b07      	ldr	r3, [pc, #28]	; (3dec <uart_console_init+0x28>)
    3dd0:	6018      	str	r0, [r3, #0]
	__stdout_hook_install(console_out);
    3dd2:	4620      	mov	r0, r4
    3dd4:	f002 f856 	bl	5e84 <__stdout_hook_install>
	__printk_hook_install(console_out);
    3dd8:	4620      	mov	r0, r4
    3dda:	f7fe f90f 	bl	1ffc <__printk_hook_install>
#endif

	uart_console_hook_install();

	return 0;
}
    3dde:	2000      	movs	r0, #0
    3de0:	bd10      	pop	{r4, pc}
    3de2:	bf00      	nop
    3de4:	0002ab80 	.word	0x0002ab80
    3de8:	00003df1 	.word	0x00003df1
    3dec:	200002f4 	.word	0x200002f4

00003df0 <console_out>:
	if ('\n' == c) {
    3df0:	280a      	cmp	r0, #10
{
    3df2:	b538      	push	{r3, r4, r5, lr}
    3df4:	4d07      	ldr	r5, [pc, #28]	; (3e14 <console_out+0x24>)
    3df6:	4604      	mov	r4, r0
	if ('\n' == c) {
    3df8:	d104      	bne.n	3e04 <console_out+0x14>
    3dfa:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
    3dfc:	6843      	ldr	r3, [r0, #4]
    3dfe:	210d      	movs	r1, #13
    3e00:	685b      	ldr	r3, [r3, #4]
    3e02:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
    3e04:	6828      	ldr	r0, [r5, #0]
    3e06:	6843      	ldr	r3, [r0, #4]
    3e08:	b2e1      	uxtb	r1, r4
    3e0a:	685b      	ldr	r3, [r3, #4]
    3e0c:	4798      	blx	r3
}
    3e0e:	4620      	mov	r0, r4
    3e10:	bd38      	pop	{r3, r4, r5, pc}
    3e12:	bf00      	nop
    3e14:	200002f4 	.word	0x200002f4

00003e18 <get_status>:
	return &config->subsys[type];
}

static enum clock_control_status get_status(struct device *dev,
					    clock_control_subsys_t subsys)
{
    3e18:	b538      	push	{r3, r4, r5, lr}
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
	struct nrf_clock_control_sub_data *data;

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    3e1a:	b2cc      	uxtb	r4, r1
    3e1c:	2c01      	cmp	r4, #1
{
    3e1e:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    3e20:	d909      	bls.n	3e36 <get_status+0x1e>
    3e22:	490b      	ldr	r1, [pc, #44]	; (3e50 <get_status+0x38>)
    3e24:	480b      	ldr	r0, [pc, #44]	; (3e54 <get_status+0x3c>)
    3e26:	4a0c      	ldr	r2, [pc, #48]	; (3e58 <get_status+0x40>)
    3e28:	237d      	movs	r3, #125	; 0x7d
    3e2a:	f020 f85a 	bl	23ee2 <printk>
    3e2e:	480a      	ldr	r0, [pc, #40]	; (3e58 <get_status+0x40>)
    3e30:	217d      	movs	r1, #125	; 0x7d
    3e32:	f020 f899 	bl	23f68 <assert_post_action>
	data = get_sub_data(dev, type);
    3e36:	68ab      	ldr	r3, [r5, #8]
	if (data->started) {
    3e38:	210c      	movs	r1, #12
    3e3a:	fb04 3101 	mla	r1, r4, r1, r3
    3e3e:	7a4b      	ldrb	r3, [r1, #9]
    3e40:	b923      	cbnz	r3, 3e4c <get_status+0x34>
		return CLOCK_CONTROL_STATUS_ON;
	}

	if (data->ref > 0) {
    3e42:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
    3e44:	fab0 f080 	clz	r0, r0
    3e48:	0940      	lsrs	r0, r0, #5
		return CLOCK_CONTROL_STATUS_STARTING;
	}

	return CLOCK_CONTROL_STATUS_OFF;
}
    3e4a:	bd38      	pop	{r3, r4, r5, pc}
		return CLOCK_CONTROL_STATUS_ON;
    3e4c:	2002      	movs	r0, #2
    3e4e:	e7fc      	b.n	3e4a <get_status+0x32>
    3e50:	0002adb0 	.word	0x0002adb0
    3e54:	0002a5e8 	.word	0x0002a5e8
    3e58:	0002ad75 	.word	0x0002ad75

00003e5c <clock_async_start>:
}

static int clock_async_start(struct device *dev,
			     clock_control_subsys_t subsys,
			     struct clock_control_async_data *data)
{
    3e5c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct nrf_clock_control_sub_config *config;
	struct nrf_clock_control_sub_data *clk_data;
	int key;
	u8_t ref;

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    3e60:	b2ce      	uxtb	r6, r1
    3e62:	2e01      	cmp	r6, #1
{
    3e64:	4607      	mov	r7, r0
    3e66:	4689      	mov	r9, r1
    3e68:	4614      	mov	r4, r2
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    3e6a:	d909      	bls.n	3e80 <clock_async_start+0x24>
    3e6c:	4940      	ldr	r1, [pc, #256]	; (3f70 <clock_async_start+0x114>)
    3e6e:	4841      	ldr	r0, [pc, #260]	; (3f74 <clock_async_start+0x118>)
    3e70:	4a41      	ldr	r2, [pc, #260]	; (3f78 <clock_async_start+0x11c>)
    3e72:	23ed      	movs	r3, #237	; 0xed
    3e74:	f020 f835 	bl	23ee2 <printk>
    3e78:	483f      	ldr	r0, [pc, #252]	; (3f78 <clock_async_start+0x11c>)
    3e7a:	21ed      	movs	r1, #237	; 0xed
    3e7c:	f020 f874 	bl	23f68 <assert_post_action>
	const struct nrf_clock_control_config *config =
    3e80:	683b      	ldr	r3, [r7, #0]
	config = get_sub_config(dev, type);
	clk_data = get_sub_data(dev, type);
    3e82:	f8d7 8008 	ldr.w	r8, [r7, #8]
	const struct nrf_clock_control_config *config =
    3e86:	f8d3 a008 	ldr.w	sl, [r3, #8]

	__ASSERT_NO_MSG((data == NULL) ||
    3e8a:	2c00      	cmp	r4, #0
    3e8c:	d151      	bne.n	3f32 <clock_async_start+0xd6>
	__asm__ volatile(
    3e8e:	f04f 0320 	mov.w	r3, #32
    3e92:	f3ef 8b11 	mrs	fp, BASEPRI
    3e96:	f383 8811 	msr	BASEPRI, r3
    3e9a:	f3bf 8f6f 	isb	sy
	    && is_in_list(&clk_data->list, &data->node)) {
		return -EBUSY;
	}

	key = irq_lock();
	ref = ++clk_data->ref;
    3e9e:	230c      	movs	r3, #12
    3ea0:	fb06 8303 	mla	r3, r6, r3, r8
    3ea4:	7a1d      	ldrb	r5, [r3, #8]
    3ea6:	3501      	adds	r5, #1
    3ea8:	b2ed      	uxtb	r5, r5
    3eaa:	721d      	strb	r5, [r3, #8]
	__ASSERT_NO_MSG(clk_data->ref > 0);
    3eac:	b94d      	cbnz	r5, 3ec2 <clock_async_start+0x66>
    3eae:	4933      	ldr	r1, [pc, #204]	; (3f7c <clock_async_start+0x120>)
    3eb0:	4830      	ldr	r0, [pc, #192]	; (3f74 <clock_async_start+0x118>)
    3eb2:	4a31      	ldr	r2, [pc, #196]	; (3f78 <clock_async_start+0x11c>)
    3eb4:	23fe      	movs	r3, #254	; 0xfe
    3eb6:	f020 f814 	bl	23ee2 <printk>
    3eba:	482f      	ldr	r0, [pc, #188]	; (3f78 <clock_async_start+0x11c>)
    3ebc:	21fe      	movs	r1, #254	; 0xfe
    3ebe:	f020 f853 	bl	23f68 <assert_post_action>
	__asm__ volatile(
    3ec2:	f38b 8811 	msr	BASEPRI, fp
    3ec6:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	if (data) {
    3eca:	b344      	cbz	r4, 3f1e <clock_async_start+0xc2>
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
    3ecc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3ed0:	2203      	movs	r2, #3
    3ed2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		bool already_started;

		clock_irqs_disable();
		already_started = clk_data->started;
    3ed6:	220c      	movs	r2, #12
    3ed8:	4372      	muls	r2, r6
    3eda:	eb08 0302 	add.w	r3, r8, r2
    3ede:	7a59      	ldrb	r1, [r3, #9]
		if (!already_started) {
    3ee0:	b991      	cbnz	r1, 3f08 <clock_async_start+0xac>
	__asm__ volatile(
    3ee2:	f04f 0020 	mov.w	r0, #32
    3ee6:	f3ef 8c11 	mrs	ip, BASEPRI
    3eea:	f380 8811 	msr	BASEPRI, r0
    3eee:	f3bf 8f6f 	isb	sy
	parent->next = child;
    3ef2:	6021      	str	r1, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
    3ef4:	6858      	ldr	r0, [r3, #4]
    3ef6:	2800      	cmp	r0, #0
    3ef8:	d133      	bne.n	3f62 <clock_async_start+0x106>
	list->tail = node;
    3efa:	605c      	str	r4, [r3, #4]
	list->head = node;
    3efc:	f848 4002 	str.w	r4, [r8, r2]
	__asm__ volatile(
    3f00:	f38c 8811 	msr	BASEPRI, ip
    3f04:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
    3f08:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3f0c:	2203      	movs	r2, #3
    3f0e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
			list_append(&clk_data->list, &data->node);
		}
		clock_irqs_enable();

		if (already_started) {
    3f12:	b121      	cbz	r1, 3f1e <clock_async_start+0xc2>
			data->cb(dev, subsys, data->user_data);
    3f14:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
    3f18:	4649      	mov	r1, r9
    3f1a:	4638      	mov	r0, r7
    3f1c:	4798      	blx	r3
		}
	}

	if (ref == 1) {
    3f1e:	2d01      	cmp	r5, #1
    3f20:	d105      	bne.n	3f2e <clock_async_start+0xd2>
		if (IS_ENABLED(CONFIG_NRF52_ANOMALY_132_WORKAROUND) &&
			(subsys == CLOCK_CONTROL_NRF_SUBSYS_LF)) {
			anomaly_132_workaround();
		}

		nrf_clock_task_trigger(NRF_CLOCK, config->start_tsk);
    3f22:	eb0a 06c6 	add.w	r6, sl, r6, lsl #3
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
}

NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    3f26:	78b3      	ldrb	r3, [r6, #2]
    3f28:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    3f2c:	601d      	str	r5, [r3, #0]
	}

	return 0;
    3f2e:	2000      	movs	r0, #0
    3f30:	e01c      	b.n	3f6c <clock_async_start+0x110>
	__ASSERT_NO_MSG((data == NULL) ||
    3f32:	6863      	ldr	r3, [r4, #4]
    3f34:	b94b      	cbnz	r3, 3f4a <clock_async_start+0xee>
    3f36:	4912      	ldr	r1, [pc, #72]	; (3f80 <clock_async_start+0x124>)
    3f38:	480e      	ldr	r0, [pc, #56]	; (3f74 <clock_async_start+0x118>)
    3f3a:	4a0f      	ldr	r2, [pc, #60]	; (3f78 <clock_async_start+0x11c>)
    3f3c:	23f1      	movs	r3, #241	; 0xf1
    3f3e:	f01f ffd0 	bl	23ee2 <printk>
    3f42:	480d      	ldr	r0, [pc, #52]	; (3f78 <clock_async_start+0x11c>)
    3f44:	21f1      	movs	r1, #241	; 0xf1
    3f46:	f020 f80f 	bl	23f68 <assert_post_action>
	sys_snode_t *item = sys_slist_peek_head(list);
    3f4a:	230c      	movs	r3, #12
    3f4c:	4373      	muls	r3, r6
    3f4e:	f858 3003 	ldr.w	r3, [r8, r3]
		if (item == node) {
    3f52:	429c      	cmp	r4, r3
    3f54:	d008      	beq.n	3f68 <clock_async_start+0x10c>
Z_GENLIST_PEEK_NEXT(slist, snode)
    3f56:	2b00      	cmp	r3, #0
    3f58:	d099      	beq.n	3e8e <clock_async_start+0x32>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    3f5a:	681b      	ldr	r3, [r3, #0]
	} while (item);
    3f5c:	2b00      	cmp	r3, #0
    3f5e:	d1f8      	bne.n	3f52 <clock_async_start+0xf6>
    3f60:	e795      	b.n	3e8e <clock_async_start+0x32>
	parent->next = child;
    3f62:	6004      	str	r4, [r0, #0]
	list->tail = node;
    3f64:	605c      	str	r4, [r3, #4]
}
    3f66:	e7cb      	b.n	3f00 <clock_async_start+0xa4>
		return -EBUSY;
    3f68:	f06f 000f 	mvn.w	r0, #15
}
    3f6c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3f70:	0002adb0 	.word	0x0002adb0
    3f74:	0002a5e8 	.word	0x0002a5e8
    3f78:	0002ad75 	.word	0x0002ad75
    3f7c:	0002ae22 	.word	0x0002ae22
    3f80:	0002add4 	.word	0x0002add4

00003f84 <clock_stop>:
{
    3f84:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    3f86:	b2cc      	uxtb	r4, r1
    3f88:	2c01      	cmp	r4, #1
{
    3f8a:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    3f8c:	d909      	bls.n	3fa2 <clock_stop+0x1e>
    3f8e:	4919      	ldr	r1, [pc, #100]	; (3ff4 <clock_stop+0x70>)
    3f90:	4819      	ldr	r0, [pc, #100]	; (3ff8 <clock_stop+0x74>)
    3f92:	4a1a      	ldr	r2, [pc, #104]	; (3ffc <clock_stop+0x78>)
    3f94:	2392      	movs	r3, #146	; 0x92
    3f96:	f01f ffa4 	bl	23ee2 <printk>
    3f9a:	4818      	ldr	r0, [pc, #96]	; (3ffc <clock_stop+0x78>)
    3f9c:	2192      	movs	r1, #146	; 0x92
    3f9e:	f01f ffe3 	bl	23f68 <assert_post_action>
	const struct nrf_clock_control_config *config =
    3fa2:	682b      	ldr	r3, [r5, #0]
	data = get_sub_data(dev, type);
    3fa4:	68ad      	ldr	r5, [r5, #8]
	const struct nrf_clock_control_config *config =
    3fa6:	6899      	ldr	r1, [r3, #8]
	__asm__ volatile(
    3fa8:	f04f 0320 	mov.w	r3, #32
    3fac:	f3ef 8611 	mrs	r6, BASEPRI
    3fb0:	f383 8811 	msr	BASEPRI, r3
    3fb4:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
    3fb8:	220c      	movs	r2, #12
    3fba:	4362      	muls	r2, r4
    3fbc:	18ab      	adds	r3, r5, r2
    3fbe:	7a18      	ldrb	r0, [r3, #8]
    3fc0:	b190      	cbz	r0, 3fe8 <clock_stop+0x64>
	data->ref--;
    3fc2:	3801      	subs	r0, #1
    3fc4:	b2c0      	uxtb	r0, r0
    3fc6:	7218      	strb	r0, [r3, #8]
	if (data->ref == 0) {
    3fc8:	b988      	cbnz	r0, 3fee <clock_stop+0x6a>
		nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
    3fca:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
	list->head = NULL;
    3fce:	50a8      	str	r0, [r5, r2]
    3fd0:	78e2      	ldrb	r2, [r4, #3]
	list->tail = NULL;
    3fd2:	6058      	str	r0, [r3, #4]
    3fd4:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    3fd8:	2101      	movs	r1, #1
    3fda:	6011      	str	r1, [r2, #0]
		data->started = false;
    3fdc:	7258      	strb	r0, [r3, #9]
	__asm__ volatile(
    3fde:	f386 8811 	msr	BASEPRI, r6
    3fe2:	f3bf 8f6f 	isb	sy
}
    3fe6:	bd70      	pop	{r4, r5, r6, pc}
		err = -EALREADY;
    3fe8:	f06f 0044 	mvn.w	r0, #68	; 0x44
    3fec:	e7f7      	b.n	3fde <clock_stop+0x5a>
	int err = 0;
    3fee:	2000      	movs	r0, #0
    3ff0:	e7f5      	b.n	3fde <clock_stop+0x5a>
    3ff2:	bf00      	nop
    3ff4:	0002adb0 	.word	0x0002adb0
    3ff8:	0002a5e8 	.word	0x0002a5e8
    3ffc:	0002ad75 	.word	0x0002ad75

00004000 <clkstarted_handle.constprop.0>:
		    DT_INST_0_NORDIC_NRF_CLOCK_LABEL,
		    clk_init, &data, &config, PRE_KERNEL_1,
		    CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &clock_control_api);

static void clkstarted_handle(struct device *dev,
    4000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			      enum clock_control_nrf_type type)
{
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    4002:	4e12      	ldr	r6, [pc, #72]	; (404c <clkstarted_handle.constprop.0+0x4c>)
    4004:	68b3      	ldr	r3, [r6, #8]
	struct clock_control_async_data *async_data;

	DBG(dev, type, "Clock started");
	sub_data->started = true;
    4006:	240c      	movs	r4, #12
    4008:	fb04 3400 	mla	r4, r4, r0, r3
    400c:	2301      	movs	r3, #1
static void clkstarted_handle(struct device *dev,
    400e:	4605      	mov	r5, r0
	sub_data->started = true;
    4010:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
    4012:	f04f 0320 	mov.w	r3, #32
    4016:	f3ef 8111 	mrs	r1, BASEPRI
    401a:	f383 8811 	msr	BASEPRI, r3
    401e:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
    4022:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    4024:	b12b      	cbz	r3, 4032 <clkstarted_handle.constprop.0+0x32>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    4026:	6860      	ldr	r0, [r4, #4]
    4028:	681a      	ldr	r2, [r3, #0]
	list->head = node;
    402a:	6022      	str	r2, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    402c:	4283      	cmp	r3, r0
	list->tail = node;
    402e:	bf08      	it	eq
    4030:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
    4032:	f381 8811 	msr	BASEPRI, r1
    4036:	f3bf 8f6f 	isb	sy

	while ((async_data = list_get(&sub_data->list)) != NULL) {
    403a:	b903      	cbnz	r3, 403e <clkstarted_handle.constprop.0+0x3e>
		async_data->cb(dev, (clock_control_subsys_t)type,
				async_data->user_data);
	}
}
    403c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		async_data->cb(dev, (clock_control_subsys_t)type,
    403e:	e9d3 7201 	ldrd	r7, r2, [r3, #4]
    4042:	4629      	mov	r1, r5
    4044:	4630      	mov	r0, r6
    4046:	47b8      	blx	r7
    4048:	e7e3      	b.n	4012 <clkstarted_handle.constprop.0+0x12>
    404a:	bf00      	nop
    404c:	200074d8 	.word	0x200074d8

00004050 <nrf_power_clock_isr>:
#endif
}

NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    4050:	4b15      	ldr	r3, [pc, #84]	; (40a8 <nrf_power_clock_isr+0x58>)
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
    4052:	b507      	push	{r0, r1, r2, lr}
    4054:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    4056:	b182      	cbz	r2, 407a <nrf_power_clock_isr+0x2a>
    return p_reg->INTENSET & mask;
    4058:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    405c:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    4060:	07d1      	lsls	r1, r2, #31
    4062:	d50a      	bpl.n	407a <nrf_power_clock_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4064:	2200      	movs	r2, #0
    4066:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    4068:	681b      	ldr	r3, [r3, #0]
    406a:	9300      	str	r3, [sp, #0]
    (void)dummy;
    406c:	9b00      	ldr	r3, [sp, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    406e:	4b0f      	ldr	r3, [pc, #60]	; (40ac <nrf_power_clock_isr+0x5c>)

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
    4070:	689b      	ldr	r3, [r3, #8]
    4072:	7a58      	ldrb	r0, [r3, #9]
    4074:	b908      	cbnz	r0, 407a <nrf_power_clock_isr+0x2a>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    4076:	f7ff ffc3 	bl	4000 <clkstarted_handle.constprop.0>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    407a:	4b0d      	ldr	r3, [pc, #52]	; (40b0 <nrf_power_clock_isr+0x60>)
    407c:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    407e:	b182      	cbz	r2, 40a2 <nrf_power_clock_isr+0x52>
    return p_reg->INTENSET & mask;
    4080:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4084:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    4088:	0792      	lsls	r2, r2, #30
    408a:	d50a      	bpl.n	40a2 <nrf_power_clock_isr+0x52>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    408c:	2200      	movs	r2, #0
    408e:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    4090:	681b      	ldr	r3, [r3, #0]
    4092:	9301      	str	r3, [sp, #4]
    (void)dummy;
    4094:	9b01      	ldr	r3, [sp, #4]
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started();
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    4096:	2001      	movs	r0, #1
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
    4098:	b003      	add	sp, #12
    409a:	f85d eb04 	ldr.w	lr, [sp], #4
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    409e:	f7ff bfaf 	b.w	4000 <clkstarted_handle.constprop.0>
}
    40a2:	b003      	add	sp, #12
    40a4:	f85d fb04 	ldr.w	pc, [sp], #4
    40a8:	40000100 	.word	0x40000100
    40ac:	200074d8 	.word	0x200074d8
    40b0:	40000104 	.word	0x40000104

000040b4 <z_clock_isr>:
#include <drivers/timer/system_timer.h>

/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
    40b4:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(false);
    40b6:	4c06      	ldr	r4, [pc, #24]	; (40d0 <z_clock_isr+0x1c>)
    40b8:	4906      	ldr	r1, [pc, #24]	; (40d4 <z_clock_isr+0x20>)
    40ba:	4807      	ldr	r0, [pc, #28]	; (40d8 <z_clock_isr+0x24>)
    40bc:	4622      	mov	r2, r4
    40be:	2317      	movs	r3, #23
    40c0:	f01f ff0f 	bl	23ee2 <printk>
    40c4:	4620      	mov	r0, r4
    40c6:	2117      	movs	r1, #23
}
    40c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT_NO_MSG(false);
    40cc:	f01f bf4c 	b.w	23f68 <assert_post_action>
    40d0:	0002ae54 	.word	0x0002ae54
    40d4:	0002e3c9 	.word	0x0002e3c9
    40d8:	0002a5e8 	.word	0x0002a5e8

000040dc <rtc1_nrf_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
    40dc:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
    40de:	4c22      	ldr	r4, [pc, #136]	; (4168 <rtc1_nrf_isr+0x8c>)
    40e0:	2300      	movs	r3, #0
    40e2:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
	__asm__ volatile(
    40e6:	f04f 0320 	mov.w	r3, #32
    40ea:	f3ef 8511 	mrs	r5, BASEPRI
    40ee:	f383 8811 	msr	BASEPRI, r3
    40f2:	f3bf 8f6f 	isb	sy
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    40f6:	481d      	ldr	r0, [pc, #116]	; (416c <rtc1_nrf_isr+0x90>)
    40f8:	f01e fce8 	bl	22acc <z_spin_lock_valid>
    40fc:	b968      	cbnz	r0, 411a <rtc1_nrf_isr+0x3e>
    40fe:	4a1c      	ldr	r2, [pc, #112]	; (4170 <rtc1_nrf_isr+0x94>)
    4100:	491c      	ldr	r1, [pc, #112]	; (4174 <rtc1_nrf_isr+0x98>)
    4102:	481d      	ldr	r0, [pc, #116]	; (4178 <rtc1_nrf_isr+0x9c>)
    4104:	234a      	movs	r3, #74	; 0x4a
    4106:	f01f feec 	bl	23ee2 <printk>
    410a:	4918      	ldr	r1, [pc, #96]	; (416c <rtc1_nrf_isr+0x90>)
    410c:	481b      	ldr	r0, [pc, #108]	; (417c <rtc1_nrf_isr+0xa0>)
    410e:	f01f fee8 	bl	23ee2 <printk>
    4112:	4817      	ldr	r0, [pc, #92]	; (4170 <rtc1_nrf_isr+0x94>)
    4114:	214a      	movs	r1, #74	; 0x4a
    4116:	f01f ff27 	bl	23f68 <assert_post_action>
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
    411a:	4814      	ldr	r0, [pc, #80]	; (416c <rtc1_nrf_isr+0x90>)
    411c:	f01e fcf4 	bl	22b08 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    4120:	4a17      	ldr	r2, [pc, #92]	; (4180 <rtc1_nrf_isr+0xa4>)
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
    4122:	f8d4 4504 	ldr.w	r4, [r4, #1284]	; 0x504
    4126:	6813      	ldr	r3, [r2, #0]
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4128:	4810      	ldr	r0, [pc, #64]	; (416c <rtc1_nrf_isr+0x90>)
	return (a - b) & COUNTER_MAX;
    412a:	1ae4      	subs	r4, r4, r3
    412c:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    4130:	4423      	add	r3, r4
    4132:	6013      	str	r3, [r2, #0]
    4134:	f01e fcd8 	bl	22ae8 <z_spin_unlock_valid>
    4138:	b968      	cbnz	r0, 4156 <rtc1_nrf_isr+0x7a>
    413a:	4a0d      	ldr	r2, [pc, #52]	; (4170 <rtc1_nrf_isr+0x94>)
    413c:	4911      	ldr	r1, [pc, #68]	; (4184 <rtc1_nrf_isr+0xa8>)
    413e:	480e      	ldr	r0, [pc, #56]	; (4178 <rtc1_nrf_isr+0x9c>)
    4140:	235d      	movs	r3, #93	; 0x5d
    4142:	f01f fece 	bl	23ee2 <printk>
    4146:	4909      	ldr	r1, [pc, #36]	; (416c <rtc1_nrf_isr+0x90>)
    4148:	480f      	ldr	r0, [pc, #60]	; (4188 <rtc1_nrf_isr+0xac>)
    414a:	f01f feca 	bl	23ee2 <printk>
    414e:	4808      	ldr	r0, [pc, #32]	; (4170 <rtc1_nrf_isr+0x94>)
    4150:	215d      	movs	r1, #93	; 0x5d
    4152:	f01f ff09 	bl	23f68 <assert_post_action>
	__asm__ volatile(
    4156:	f385 8811 	msr	BASEPRI, r5
    415a:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    415e:	4620      	mov	r0, r4
}
    4160:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    4164:	f01f b80a 	b.w	2317c <z_clock_announce>
    4168:	40011000 	.word	0x40011000
    416c:	20000314 	.word	0x20000314
    4170:	0002ae90 	.word	0x0002ae90
    4174:	0002aeb2 	.word	0x0002aeb2
    4178:	0002a5e8 	.word	0x0002a5e8
    417c:	0002aec7 	.word	0x0002aec7
    4180:	20000310 	.word	0x20000310
    4184:	0002aedf 	.word	0x0002aedf
    4188:	0002aef6 	.word	0x0002aef6

0000418c <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
    418c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    418e:	4818      	ldr	r0, [pc, #96]	; (41f0 <z_clock_driver_init+0x64>)
    4190:	f01c f91a 	bl	203c8 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);
	if (!clock) {
    4194:	b348      	cbz	r0, 41ea <z_clock_driver_init+0x5e>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    4196:	6843      	ldr	r3, [r0, #4]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    4198:	4d16      	ldr	r5, [pc, #88]	; (41f4 <z_clock_driver_init+0x68>)
    419a:	681b      	ldr	r3, [r3, #0]
    419c:	2101      	movs	r1, #1
    419e:	4798      	blx	r3
    41a0:	2400      	movs	r4, #0
    p_reg->CC[ch] = cc_val;
    41a2:	2601      	movs	r6, #1
    p_reg->INTENSET = mask;
    41a4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->PRESCALER = val;
    41a8:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
    41ac:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
    41b0:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    41b4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    41b8:	f503 538a 	add.w	r3, r3, #4416	; 0x1140
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    41bc:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    41c0:	601c      	str	r4, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    41c2:	681b      	ldr	r3, [r3, #0]
    41c4:	9301      	str	r3, [sp, #4]
    (void)dummy;
    41c6:	9b01      	ldr	r3, [sp, #4]
    41c8:	4b0b      	ldr	r3, [pc, #44]	; (41f8 <z_clock_driver_init+0x6c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    41ca:	4631      	mov	r1, r6
    41cc:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    41d0:	2011      	movs	r0, #17
    41d2:	4622      	mov	r2, r4
    41d4:	f000 fbf2 	bl	49bc <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
    41d8:	2011      	movs	r0, #17
    41da:	f000 fbbd 	bl	4958 <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    41de:	4b07      	ldr	r3, [pc, #28]	; (41fc <z_clock_driver_init+0x70>)

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
    41e0:	4620      	mov	r0, r4
    41e2:	601e      	str	r6, [r3, #0]
    41e4:	602e      	str	r6, [r5, #0]
}
    41e6:	b002      	add	sp, #8
    41e8:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
    41ea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    41ee:	e7fa      	b.n	41e6 <z_clock_driver_init+0x5a>
    41f0:	0002ae34 	.word	0x0002ae34
    41f4:	40011000 	.word	0x40011000
    41f8:	e000e100 	.word	0xe000e100
    41fc:	40011008 	.word	0x40011008

00004200 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    4200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    4202:	4c39      	ldr	r4, [pc, #228]	; (42e8 <z_clock_set_timeout+0xe8>)
    4204:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    4208:	bf18      	it	ne
    420a:	4604      	movne	r4, r0
	__asm__ volatile(
    420c:	f04f 0320 	mov.w	r3, #32
    4210:	f3ef 8511 	mrs	r5, BASEPRI
    4214:	f383 8811 	msr	BASEPRI, r3
    4218:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    421c:	4833      	ldr	r0, [pc, #204]	; (42ec <z_clock_set_timeout+0xec>)
    421e:	f01e fc55 	bl	22acc <z_spin_lock_valid>
    4222:	b968      	cbnz	r0, 4240 <z_clock_set_timeout+0x40>
    4224:	4a32      	ldr	r2, [pc, #200]	; (42f0 <z_clock_set_timeout+0xf0>)
    4226:	4933      	ldr	r1, [pc, #204]	; (42f4 <z_clock_set_timeout+0xf4>)
    4228:	4833      	ldr	r0, [pc, #204]	; (42f8 <z_clock_set_timeout+0xf8>)
    422a:	234a      	movs	r3, #74	; 0x4a
    422c:	f01f fe59 	bl	23ee2 <printk>
    4230:	492e      	ldr	r1, [pc, #184]	; (42ec <z_clock_set_timeout+0xec>)
    4232:	4832      	ldr	r0, [pc, #200]	; (42fc <z_clock_set_timeout+0xfc>)
    4234:	f01f fe55 	bl	23ee2 <printk>
    4238:	482d      	ldr	r0, [pc, #180]	; (42f0 <z_clock_set_timeout+0xf0>)
    423a:	214a      	movs	r1, #74	; 0x4a
    423c:	f01f fe94 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
    4240:	482a      	ldr	r0, [pc, #168]	; (42ec <z_clock_set_timeout+0xec>)
    4242:	4f29      	ldr	r7, [pc, #164]	; (42e8 <z_clock_set_timeout+0xe8>)
    4244:	f01e fc60 	bl	22b08 <z_spin_lock_set_owner>
     return p_reg->COUNTER;
    4248:	4a2d      	ldr	r2, [pc, #180]	; (4300 <z_clock_set_timeout+0x100>)
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
    424a:	4b2e      	ldr	r3, [pc, #184]	; (4304 <z_clock_set_timeout+0x104>)
    424c:	f8d2 1504 	ldr.w	r1, [r2, #1284]	; 0x504
    4250:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
    4252:	1ac8      	subs	r0, r1, r3
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    4254:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
	return (a - b) & COUNTER_MAX;
    4258:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000
	if (unannounced >= COUNTER_HALF_SPAN) {
    425c:	d12b      	bne.n	42b6 <z_clock_set_timeout+0xb6>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    425e:	1e60      	subs	r0, r4, #1
    4260:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    4264:	42b8      	cmp	r0, r7
    4266:	bfa8      	it	ge
    4268:	4638      	movge	r0, r7
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    426a:	1c74      	adds	r4, r6, #1
    426c:	4420      	add	r0, r4
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
    426e:	42b8      	cmp	r0, r7
    4270:	bf94      	ite	ls
    4272:	181b      	addls	r3, r3, r0
    4274:	19db      	addhi	r3, r3, r7
	return (a - b) & COUNTER_MAX;
    4276:	1a59      	subs	r1, r3, r1
    4278:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    427c:	f023 407f 	bic.w	r0, r3, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
    4280:	2902      	cmp	r1, #2
    p_reg->CC[ch] = cc_val;
    4282:	f8c2 0540 	str.w	r0, [r2, #1344]	; 0x540
    4286:	d918      	bls.n	42ba <z_clock_set_timeout+0xba>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4288:	4818      	ldr	r0, [pc, #96]	; (42ec <z_clock_set_timeout+0xec>)
    428a:	f01e fc2d 	bl	22ae8 <z_spin_unlock_valid>
    428e:	b968      	cbnz	r0, 42ac <z_clock_set_timeout+0xac>
    4290:	4a17      	ldr	r2, [pc, #92]	; (42f0 <z_clock_set_timeout+0xf0>)
    4292:	491d      	ldr	r1, [pc, #116]	; (4308 <z_clock_set_timeout+0x108>)
    4294:	4818      	ldr	r0, [pc, #96]	; (42f8 <z_clock_set_timeout+0xf8>)
    4296:	235d      	movs	r3, #93	; 0x5d
    4298:	f01f fe23 	bl	23ee2 <printk>
    429c:	4913      	ldr	r1, [pc, #76]	; (42ec <z_clock_set_timeout+0xec>)
    429e:	481b      	ldr	r0, [pc, #108]	; (430c <z_clock_set_timeout+0x10c>)
    42a0:	f01f fe1f 	bl	23ee2 <printk>
    42a4:	4812      	ldr	r0, [pc, #72]	; (42f0 <z_clock_set_timeout+0xf0>)
    42a6:	215d      	movs	r1, #93	; 0x5d
    42a8:	f01f fe5e 	bl	23f68 <assert_post_action>
	__asm__ volatile(
    42ac:	f385 8811 	msr	BASEPRI, r5
    42b0:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
    42b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		ticks = 0;
    42b6:	2000      	movs	r0, #0
    42b8:	e7d7      	b.n	426a <z_clock_set_timeout+0x6a>
     return p_reg->COUNTER;
    42ba:	f8d2 1504 	ldr.w	r1, [r2, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
    42be:	4814      	ldr	r0, [pc, #80]	; (4310 <z_clock_set_timeout+0x110>)
	return (a - b) & COUNTER_MAX;
    42c0:	1a59      	subs	r1, r3, r1
    42c2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
    42c6:	1e4c      	subs	r4, r1, #1
    42c8:	4284      	cmp	r4, r0
    42ca:	d905      	bls.n	42d8 <z_clock_set_timeout+0xd8>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    42cc:	4b11      	ldr	r3, [pc, #68]	; (4314 <z_clock_set_timeout+0x114>)
    42ce:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    42d2:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
    42d6:	e7d7      	b.n	4288 <z_clock_set_timeout+0x88>
		} else if (dt == 1) {
    42d8:	2901      	cmp	r1, #1
			set_comparator(cyc + 2);
    42da:	bf02      	ittt	eq
    42dc:	3302      	addeq	r3, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    42de:	f023 437f 	biceq.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    42e2:	f8c2 3540 	streq.w	r3, [r2, #1344]	; 0x540
}
    42e6:	e7cf      	b.n	4288 <z_clock_set_timeout+0x88>
    42e8:	00fffffe 	.word	0x00fffffe
    42ec:	20000314 	.word	0x20000314
    42f0:	0002ae90 	.word	0x0002ae90
    42f4:	0002aeb2 	.word	0x0002aeb2
    42f8:	0002a5e8 	.word	0x0002a5e8
    42fc:	0002aec7 	.word	0x0002aec7
    4300:	40011000 	.word	0x40011000
    4304:	20000310 	.word	0x20000310
    4308:	0002aedf 	.word	0x0002aedf
    430c:	0002aef6 	.word	0x0002aef6
    4310:	007ffffe 	.word	0x007ffffe
    4314:	e000e100 	.word	0xe000e100

00004318 <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
    4318:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    431a:	f04f 0320 	mov.w	r3, #32
    431e:	f3ef 8511 	mrs	r5, BASEPRI
    4322:	f383 8811 	msr	BASEPRI, r3
    4326:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    432a:	481a      	ldr	r0, [pc, #104]	; (4394 <z_clock_elapsed+0x7c>)
    432c:	f01e fbce 	bl	22acc <z_spin_lock_valid>
    4330:	b968      	cbnz	r0, 434e <z_clock_elapsed+0x36>
    4332:	4a19      	ldr	r2, [pc, #100]	; (4398 <z_clock_elapsed+0x80>)
    4334:	4919      	ldr	r1, [pc, #100]	; (439c <z_clock_elapsed+0x84>)
    4336:	481a      	ldr	r0, [pc, #104]	; (43a0 <z_clock_elapsed+0x88>)
    4338:	234a      	movs	r3, #74	; 0x4a
    433a:	f01f fdd2 	bl	23ee2 <printk>
    433e:	4915      	ldr	r1, [pc, #84]	; (4394 <z_clock_elapsed+0x7c>)
    4340:	4818      	ldr	r0, [pc, #96]	; (43a4 <z_clock_elapsed+0x8c>)
    4342:	f01f fdce 	bl	23ee2 <printk>
    4346:	4814      	ldr	r0, [pc, #80]	; (4398 <z_clock_elapsed+0x80>)
    4348:	214a      	movs	r1, #74	; 0x4a
    434a:	f01f fe0d 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
    434e:	4811      	ldr	r0, [pc, #68]	; (4394 <z_clock_elapsed+0x7c>)
    4350:	f01e fbda 	bl	22b08 <z_spin_lock_set_owner>
     return p_reg->COUNTER;
    4354:	4b14      	ldr	r3, [pc, #80]	; (43a8 <z_clock_elapsed+0x90>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4356:	480f      	ldr	r0, [pc, #60]	; (4394 <z_clock_elapsed+0x7c>)
    4358:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    435c:	4b13      	ldr	r3, [pc, #76]	; (43ac <z_clock_elapsed+0x94>)
	return (a - b) & COUNTER_MAX;
    435e:	681b      	ldr	r3, [r3, #0]
    4360:	1ae4      	subs	r4, r4, r3
    4362:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
    4366:	f01e fbbf 	bl	22ae8 <z_spin_unlock_valid>
    436a:	b968      	cbnz	r0, 4388 <z_clock_elapsed+0x70>
    436c:	4a0a      	ldr	r2, [pc, #40]	; (4398 <z_clock_elapsed+0x80>)
    436e:	4910      	ldr	r1, [pc, #64]	; (43b0 <z_clock_elapsed+0x98>)
    4370:	480b      	ldr	r0, [pc, #44]	; (43a0 <z_clock_elapsed+0x88>)
    4372:	235d      	movs	r3, #93	; 0x5d
    4374:	f01f fdb5 	bl	23ee2 <printk>
    4378:	4906      	ldr	r1, [pc, #24]	; (4394 <z_clock_elapsed+0x7c>)
    437a:	480e      	ldr	r0, [pc, #56]	; (43b4 <z_clock_elapsed+0x9c>)
    437c:	f01f fdb1 	bl	23ee2 <printk>
    4380:	4805      	ldr	r0, [pc, #20]	; (4398 <z_clock_elapsed+0x80>)
    4382:	215d      	movs	r1, #93	; 0x5d
    4384:	f01f fdf0 	bl	23f68 <assert_post_action>
	__asm__ volatile(
    4388:	f385 8811 	msr	BASEPRI, r5
    438c:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    4390:	4620      	mov	r0, r4
    4392:	bd38      	pop	{r3, r4, r5, pc}
    4394:	20000314 	.word	0x20000314
    4398:	0002ae90 	.word	0x0002ae90
    439c:	0002aeb2 	.word	0x0002aeb2
    43a0:	0002a5e8 	.word	0x0002a5e8
    43a4:	0002aec7 	.word	0x0002aec7
    43a8:	40011000 	.word	0x40011000
    43ac:	20000310 	.word	0x20000310
    43b0:	0002aedf 	.word	0x0002aedf
    43b4:	0002aef6 	.word	0x0002aef6

000043b8 <z_timer_cycle_get_32>:

u32_t z_timer_cycle_get_32(void)
{
    43b8:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    43ba:	f04f 0320 	mov.w	r3, #32
    43be:	f3ef 8511 	mrs	r5, BASEPRI
    43c2:	f383 8811 	msr	BASEPRI, r3
    43c6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    43ca:	481b      	ldr	r0, [pc, #108]	; (4438 <z_timer_cycle_get_32+0x80>)
    43cc:	f01e fb7e 	bl	22acc <z_spin_lock_valid>
    43d0:	b968      	cbnz	r0, 43ee <z_timer_cycle_get_32+0x36>
    43d2:	4a1a      	ldr	r2, [pc, #104]	; (443c <z_timer_cycle_get_32+0x84>)
    43d4:	491a      	ldr	r1, [pc, #104]	; (4440 <z_timer_cycle_get_32+0x88>)
    43d6:	481b      	ldr	r0, [pc, #108]	; (4444 <z_timer_cycle_get_32+0x8c>)
    43d8:	234a      	movs	r3, #74	; 0x4a
    43da:	f01f fd82 	bl	23ee2 <printk>
    43de:	4916      	ldr	r1, [pc, #88]	; (4438 <z_timer_cycle_get_32+0x80>)
    43e0:	4819      	ldr	r0, [pc, #100]	; (4448 <z_timer_cycle_get_32+0x90>)
    43e2:	f01f fd7e 	bl	23ee2 <printk>
    43e6:	4815      	ldr	r0, [pc, #84]	; (443c <z_timer_cycle_get_32+0x84>)
    43e8:	214a      	movs	r1, #74	; 0x4a
    43ea:	f01f fdbd 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
    43ee:	4812      	ldr	r0, [pc, #72]	; (4438 <z_timer_cycle_get_32+0x80>)
    43f0:	f01e fb8a 	bl	22b08 <z_spin_lock_set_owner>
    43f4:	4b15      	ldr	r3, [pc, #84]	; (444c <z_timer_cycle_get_32+0x94>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    43f6:	4810      	ldr	r0, [pc, #64]	; (4438 <z_timer_cycle_get_32+0x80>)
    43f8:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    43fc:	4b14      	ldr	r3, [pc, #80]	; (4450 <z_timer_cycle_get_32+0x98>)
    43fe:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
    4400:	1ae4      	subs	r4, r4, r3
    4402:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    4406:	441c      	add	r4, r3
    4408:	f01e fb6e 	bl	22ae8 <z_spin_unlock_valid>
    440c:	b968      	cbnz	r0, 442a <z_timer_cycle_get_32+0x72>
    440e:	4a0b      	ldr	r2, [pc, #44]	; (443c <z_timer_cycle_get_32+0x84>)
    4410:	4910      	ldr	r1, [pc, #64]	; (4454 <z_timer_cycle_get_32+0x9c>)
    4412:	480c      	ldr	r0, [pc, #48]	; (4444 <z_timer_cycle_get_32+0x8c>)
    4414:	235d      	movs	r3, #93	; 0x5d
    4416:	f01f fd64 	bl	23ee2 <printk>
    441a:	4907      	ldr	r1, [pc, #28]	; (4438 <z_timer_cycle_get_32+0x80>)
    441c:	480e      	ldr	r0, [pc, #56]	; (4458 <z_timer_cycle_get_32+0xa0>)
    441e:	f01f fd60 	bl	23ee2 <printk>
    4422:	4806      	ldr	r0, [pc, #24]	; (443c <z_timer_cycle_get_32+0x84>)
    4424:	215d      	movs	r1, #93	; 0x5d
    4426:	f01f fd9f 	bl	23f68 <assert_post_action>
	__asm__ volatile(
    442a:	f385 8811 	msr	BASEPRI, r5
    442e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    4432:	4620      	mov	r0, r4
    4434:	bd38      	pop	{r3, r4, r5, pc}
    4436:	bf00      	nop
    4438:	20000314 	.word	0x20000314
    443c:	0002ae90 	.word	0x0002ae90
    4440:	0002aeb2 	.word	0x0002aeb2
    4444:	0002a5e8 	.word	0x0002a5e8
    4448:	0002aec7 	.word	0x0002aec7
    444c:	40011000 	.word	0x40011000
    4450:	20000310 	.word	0x20000310
    4454:	0002aedf 	.word	0x0002aedf
    4458:	0002aef6 	.word	0x0002aef6

0000445c <_DoInit>:
*
*/
#define INIT()  do {                                            \
                  if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
                } while (0)
static void _DoInit(void) {
    445c:	b510      	push	{r4, lr}
  SEGGER_RTT_CB* p;
  //
  // Initialize control block
  //
  p = &_SEGGER_RTT;
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    445e:	4c11      	ldr	r4, [pc, #68]	; (44a4 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    4460:	4a11      	ldr	r2, [pc, #68]	; (44a8 <_DoInit+0x4c>)
    4462:	61a2      	str	r2, [r4, #24]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    4464:	2303      	movs	r3, #3
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    4466:	e9c4 3304 	strd	r3, r3, [r4, #16]
  p->aUp[0].pBuffer       = _acUpBuffer;
    446a:	4b10      	ldr	r3, [pc, #64]	; (44ac <_DoInit+0x50>)
    446c:	61e3      	str	r3, [r4, #28]
  p->aUp[0].WrOff         = 0u;
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
    446e:	6622      	str	r2, [r4, #96]	; 0x60
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    4470:	f44f 6380 	mov.w	r3, #1024	; 0x400
  p->aDown[0].pBuffer       = _acDownBuffer;
    4474:	4a0e      	ldr	r2, [pc, #56]	; (44b0 <_DoInit+0x54>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  strcpy(&p->acID[7], "RTT");
    4476:	490f      	ldr	r1, [pc, #60]	; (44b4 <_DoInit+0x58>)
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    4478:	6223      	str	r3, [r4, #32]
  p->aDown[0].pBuffer       = _acDownBuffer;
    447a:	6662      	str	r2, [r4, #100]	; 0x64
  p->aUp[0].RdOff         = 0u;
    447c:	2300      	movs	r3, #0
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    447e:	2210      	movs	r2, #16
  strcpy(&p->acID[7], "RTT");
    4480:	1de0      	adds	r0, r4, #7
  p->aUp[0].RdOff         = 0u;
    4482:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    4484:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    4486:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
    4488:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    448a:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    448c:	6763      	str	r3, [r4, #116]	; 0x74
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    448e:	66a2      	str	r2, [r4, #104]	; 0x68
  strcpy(&p->acID[7], "RTT");
    4490:	f021 fbad 	bl	25bee <strcpy>
  strcpy(&p->acID[0], "SEGGER");
    4494:	4908      	ldr	r1, [pc, #32]	; (44b8 <_DoInit+0x5c>)
    4496:	4620      	mov	r0, r4
    4498:	f021 fba9 	bl	25bee <strcpy>
  p->acID[6] = ' ';
    449c:	2320      	movs	r3, #32
    449e:	71a3      	strb	r3, [r4, #6]
}
    44a0:	bd10      	pop	{r4, pc}
    44a2:	bf00      	nop
    44a4:	20000318 	.word	0x20000318
    44a8:	0002af0b 	.word	0x0002af0b
    44ac:	20001f56 	.word	0x20001f56
    44b0:	20001f46 	.word	0x20001f46
    44b4:	0002af14 	.word	0x0002af14
    44b8:	0002af18 	.word	0x0002af18

000044bc <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    44bc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  RdOff = pRing->RdOff;
    44c0:	4f23      	ldr	r7, [pc, #140]	; (4550 <SEGGER_RTT_WriteSkipNoLock+0x94>)
    44c2:	f04f 0b18 	mov.w	fp, #24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    44c6:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
    44c8:	fb0b 7200 	mla	r2, fp, r0, r7
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    44cc:	4606      	mov	r6, r0
  RdOff = pRing->RdOff;
    44ce:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
    44d0:	6a55      	ldr	r5, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    44d2:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    44d4:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    44d6:	d834      	bhi.n	4542 <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
    44d8:	f8d2 a020 	ldr.w	sl, [r2, #32]
    44dc:	ebaa 0905 	sub.w	r9, sl, r5
    44e0:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
    44e4:	4294      	cmp	r4, r2
    44e6:	d811      	bhi.n	450c <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    44e8:	f04f 0918 	mov.w	r9, #24
    44ec:	fb06 9309 	mla	r3, r6, r9, r9
    44f0:	443b      	add	r3, r7
    44f2:	4622      	mov	r2, r4
    44f4:	6858      	ldr	r0, [r3, #4]
    44f6:	4641      	mov	r1, r8
    44f8:	4428      	add	r0, r5
    44fa:	f021 fbd5 	bl	25ca8 <memcpy>
      pRing->WrOff = WrOff + NumBytes;
    44fe:	fb09 7606 	mla	r6, r9, r6, r7
    4502:	442c      	add	r4, r5
      // Therefore, check if 2nd memcpy is necessary at all
      //
      if (NumBytes) {
        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
      }
      pRing->WrOff = NumBytes;
    4504:	6274      	str	r4, [r6, #36]	; 0x24
      return 1;
    4506:	2001      	movs	r0, #1
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
    4508:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
    450c:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
    450e:	429c      	cmp	r4, r3
    4510:	d81b      	bhi.n	454a <SEGGER_RTT_WriteSkipNoLock+0x8e>
      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
    4512:	fb00 bb0b 	mla	fp, r0, fp, fp
    4516:	44bb      	add	fp, r7
    4518:	464a      	mov	r2, r9
    451a:	f8db 0004 	ldr.w	r0, [fp, #4]
    451e:	442c      	add	r4, r5
    4520:	4428      	add	r0, r5
    4522:	f021 fbc1 	bl	25ca8 <memcpy>
      if (NumBytes) {
    4526:	ebb4 040a 	subs.w	r4, r4, sl
    452a:	d006      	beq.n	453a <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
    452c:	f8db 0004 	ldr.w	r0, [fp, #4]
    4530:	4622      	mov	r2, r4
    4532:	eb08 0109 	add.w	r1, r8, r9
    4536:	f021 fbb7 	bl	25ca8 <memcpy>
      pRing->WrOff = NumBytes;
    453a:	2018      	movs	r0, #24
    453c:	fb00 7606 	mla	r6, r0, r6, r7
    4540:	e7e0      	b.n	4504 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
    4542:	3b01      	subs	r3, #1
    4544:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
    4546:	42a3      	cmp	r3, r4
    4548:	d2ce      	bcs.n	44e8 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
    454a:	2000      	movs	r0, #0
    454c:	e7dc      	b.n	4508 <SEGGER_RTT_WriteSkipNoLock+0x4c>
    454e:	bf00      	nop
    4550:	20000318 	.word	0x20000318

00004554 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  v = pRing->RdOff;
    4554:	4b03      	ldr	r3, [pc, #12]	; (4564 <SEGGER_RTT_HasDataUp+0x10>)
    4556:	2218      	movs	r2, #24
    4558:	fb02 3300 	mla	r3, r2, r0, r3
    455c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
    455e:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
    4560:	1a80      	subs	r0, r0, r2
    4562:	4770      	bx	lr
    4564:	20000318 	.word	0x20000318

00004568 <uECC_get_rng>:
}

uECC_RNG_Function uECC_get_rng(void)
{
	return g_rng_function;
}
    4568:	4b01      	ldr	r3, [pc, #4]	; (4570 <uECC_get_rng+0x8>)
    456a:	6818      	ldr	r0, [r3, #0]
    456c:	4770      	bx	lr
    456e:	bf00      	nop
    4570:	20006ab0 	.word	0x20006ab0

00004574 <vli_mmod_fast_secp256r1>:
{
	return &curve_secp256r1;
}

void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
{
    4574:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
    4576:	2208      	movs	r2, #8
{
    4578:	b089      	sub	sp, #36	; 0x24
    457a:	460c      	mov	r4, r1
    457c:	4606      	mov	r6, r0
	uECC_vli_set(result, product, NUM_ECC_WORDS);
    457e:	f020 fbac 	bl	24cda <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
	tmp[3] = product[11];
    4582:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    4584:	9303      	str	r3, [sp, #12]
	tmp[4] = product[12];
    4586:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    4588:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
    458a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    458c:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
    458e:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    4590:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
    4592:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    4594:	9307      	str	r3, [sp, #28]
	tmp[0] = tmp[1] = tmp[2] = 0;
    4596:	2700      	movs	r7, #0
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    4598:	2308      	movs	r3, #8
    459a:	466a      	mov	r2, sp
    459c:	4669      	mov	r1, sp
    459e:	4668      	mov	r0, sp
	tmp[0] = tmp[1] = tmp[2] = 0;
    45a0:	e9cd 7701 	strd	r7, r7, [sp, #4]
    45a4:	9700      	str	r7, [sp, #0]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    45a6:	f020 fa9a 	bl	24ade <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    45aa:	2308      	movs	r3, #8
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    45ac:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    45ae:	466a      	mov	r2, sp
    45b0:	4631      	mov	r1, r6
    45b2:	4630      	mov	r0, r6
    45b4:	f020 fa93 	bl	24ade <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
    45b8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    45ba:	9303      	str	r3, [sp, #12]
	tmp[4] = product[13];
    45bc:	6b63      	ldr	r3, [r4, #52]	; 0x34
    45be:	9304      	str	r3, [sp, #16]
	tmp[5] = product[14];
    45c0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    45c2:	9305      	str	r3, [sp, #20]
	tmp[6] = product[15];
    45c4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    45c6:	4405      	add	r5, r0
	tmp[7] = 0;
    45c8:	e9cd 3706 	strd	r3, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    45cc:	466a      	mov	r2, sp
    45ce:	2308      	movs	r3, #8
    45d0:	4669      	mov	r1, sp
    45d2:	4668      	mov	r0, sp
    45d4:	f020 fa83 	bl	24ade <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    45d8:	4631      	mov	r1, r6
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    45da:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    45dc:	2308      	movs	r3, #8
    45de:	466a      	mov	r2, sp
    45e0:	4630      	mov	r0, r6
    45e2:	f020 fa7c 	bl	24ade <uECC_vli_add>

	/* s3 */
	tmp[0] = product[8];
    45e6:	6a23      	ldr	r3, [r4, #32]
    45e8:	9300      	str	r3, [sp, #0]
	tmp[1] = product[9];
    45ea:	6a63      	ldr	r3, [r4, #36]	; 0x24
    45ec:	9301      	str	r3, [sp, #4]
	tmp[2] = product[10];
    45ee:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    45f0:	9302      	str	r3, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[14];
    45f2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    45f4:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
    45f6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    45f8:	9307      	str	r3, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    45fa:	4405      	add	r5, r0
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    45fc:	2308      	movs	r3, #8
    45fe:	466a      	mov	r2, sp
    4600:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
    4602:	e9cd 7704 	strd	r7, r7, [sp, #16]
    4606:	9703      	str	r7, [sp, #12]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4608:	f020 fa69 	bl	24ade <uECC_vli_add>

	/* s4 */
	tmp[0] = product[9];
    460c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    460e:	9300      	str	r3, [sp, #0]
	tmp[1] = product[10];
    4610:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[2] = product[11];
	tmp[3] = product[13];
	tmp[4] = product[14];
    4612:	6ba2      	ldr	r2, [r4, #56]	; 0x38
	tmp[1] = product[10];
    4614:	9301      	str	r3, [sp, #4]
	tmp[2] = product[11];
    4616:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    4618:	9302      	str	r3, [sp, #8]
	tmp[4] = product[14];
    461a:	9204      	str	r2, [sp, #16]
	tmp[3] = product[13];
    461c:	6b63      	ldr	r3, [r4, #52]	; 0x34
	tmp[5] = product[15];
    461e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	tmp[3] = product[13];
    4620:	9303      	str	r3, [sp, #12]
	tmp[6] = product[13];
    4622:	e9cd 2305 	strd	r2, r3, [sp, #20]
	tmp[7] = product[8];
    4626:	6a23      	ldr	r3, [r4, #32]
    4628:	9307      	str	r3, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    462a:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    462c:	2308      	movs	r3, #8
    462e:	466a      	mov	r2, sp
    4630:	4630      	mov	r0, r6
    4632:	f020 fa54 	bl	24ade <uECC_vli_add>

	/* d1 */
	tmp[0] = product[11];
    4636:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    4638:	9300      	str	r3, [sp, #0]
	tmp[1] = product[12];
    463a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    463c:	9301      	str	r3, [sp, #4]
	tmp[2] = product[13];
    463e:	6b63      	ldr	r3, [r4, #52]	; 0x34
    4640:	9302      	str	r3, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[8];
    4642:	6a23      	ldr	r3, [r4, #32]
    4644:	9306      	str	r3, [sp, #24]
	tmp[7] = product[10];
    4646:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4648:	9307      	str	r3, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    464a:	4405      	add	r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    464c:	2308      	movs	r3, #8
    464e:	466a      	mov	r2, sp
    4650:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
    4652:	e9cd 7704 	strd	r7, r7, [sp, #16]
    4656:	9703      	str	r7, [sp, #12]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    4658:	f020 fb75 	bl	24d46 <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
    465c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    465e:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
    4660:	6b63      	ldr	r3, [r4, #52]	; 0x34
    4662:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
    4664:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    4666:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
    4668:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    466a:	9303      	str	r3, [sp, #12]
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
    466c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    466e:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
    4670:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    4672:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    4674:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    4676:	2308      	movs	r3, #8
    4678:	466a      	mov	r2, sp
    467a:	4630      	mov	r0, r6
	tmp[4] = tmp[5] = 0;
    467c:	e9cd 7704 	strd	r7, r7, [sp, #16]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    4680:	f020 fb61 	bl	24d46 <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
    4684:	6b63      	ldr	r3, [r4, #52]	; 0x34
    4686:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
    4688:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    468a:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
    468c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    468e:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
    4690:	6a23      	ldr	r3, [r4, #32]
    4692:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
    4694:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4696:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
    4698:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[6] = 0;
    469a:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
    469e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    46a0:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    46a2:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    46a4:	2308      	movs	r3, #8
    46a6:	466a      	mov	r2, sp
    46a8:	4630      	mov	r0, r6
    46aa:	f020 fb4c 	bl	24d46 <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
    46ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    46b0:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
    46b2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[2] = 0;
    46b4:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
    46b8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    46ba:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
    46bc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    46be:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
    46c0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[6] = 0;
    46c2:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[13];
    46c6:	6b63      	ldr	r3, [r4, #52]	; 0x34
    46c8:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    46ca:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    46cc:	2308      	movs	r3, #8
    46ce:	466a      	mov	r2, sp
    46d0:	4630      	mov	r0, r6
    46d2:	f020 fb38 	bl	24d46 <uECC_vli_sub>

	if (carry < 0) {
    46d6:	1a2d      	subs	r5, r5, r0
    46d8:	d410      	bmi.n	46fc <vli_mmod_fast_secp256r1+0x188>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
		}
		while (carry < 0);
	} else  {
		while (carry || 
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
    46da:	4c0d      	ldr	r4, [pc, #52]	; (4710 <vli_mmod_fast_secp256r1+0x19c>)
		while (carry || 
    46dc:	b935      	cbnz	r5, 46ec <vli_mmod_fast_secp256r1+0x178>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
    46de:	2208      	movs	r2, #8
    46e0:	4631      	mov	r1, r6
    46e2:	4620      	mov	r0, r4
    46e4:	f020 fb05 	bl	24cf2 <uECC_vli_cmp_unsafe>
		while (carry || 
    46e8:	2801      	cmp	r0, #1
    46ea:	d00f      	beq.n	470c <vli_mmod_fast_secp256r1+0x198>
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    46ec:	2308      	movs	r3, #8
    46ee:	4622      	mov	r2, r4
    46f0:	4631      	mov	r1, r6
    46f2:	4630      	mov	r0, r6
    46f4:	f020 fb27 	bl	24d46 <uECC_vli_sub>
    46f8:	1a2d      	subs	r5, r5, r0
    46fa:	e7ef      	b.n	46dc <vli_mmod_fast_secp256r1+0x168>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    46fc:	4a04      	ldr	r2, [pc, #16]	; (4710 <vli_mmod_fast_secp256r1+0x19c>)
    46fe:	2308      	movs	r3, #8
    4700:	4631      	mov	r1, r6
    4702:	4630      	mov	r0, r6
    4704:	f020 f9eb 	bl	24ade <uECC_vli_add>
		while (carry < 0);
    4708:	182d      	adds	r5, r5, r0
    470a:	d4f8      	bmi.n	46fe <vli_mmod_fast_secp256r1+0x18a>
		}
	}
}
    470c:	b009      	add	sp, #36	; 0x24
    470e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4710:	00029c24 	.word	0x00029c24

00004714 <tc_aes128_set_encrypt_key>:

#define subbyte(a, o)(sbox[((a) >> (o))&0xff] << (o))
#define subword(a)(subbyte(a, 24)|subbyte(a, 16)|subbyte(a, 8)|subbyte(a, 0))

int tc_aes128_set_encrypt_key(TCAesKeySched_t s, const uint8_t *k)
{
    4714:	b5f0      	push	{r4, r5, r6, r7, lr}
	const unsigned int rconst[11] = {
    4716:	4e26      	ldr	r6, [pc, #152]	; (47b0 <tc_aes128_set_encrypt_key+0x9c>)
{
    4718:	4607      	mov	r7, r0
    471a:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
    471c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
{
    471e:	b08d      	sub	sp, #52	; 0x34
	const unsigned int rconst[11] = {
    4720:	ad01      	add	r5, sp, #4
    4722:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    4724:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    4726:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    4728:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
    472c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000
	};
	unsigned int i;
	unsigned int t;

	if (s == (TCAesKeySched_t) 0) {
    4730:	4638      	mov	r0, r7
    4732:	2f00      	cmp	r7, #0
    4734:	d038      	beq.n	47a8 <tc_aes128_set_encrypt_key+0x94>
		return TC_CRYPTO_FAIL;
	} else if (k == (const uint8_t *) 0) {
    4736:	2c00      	cmp	r4, #0
    4738:	d038      	beq.n	47ac <tc_aes128_set_encrypt_key+0x98>
    473a:	1f38      	subs	r0, r7, #4
    473c:	4621      	mov	r1, r4
    473e:	4602      	mov	r2, r0
    4740:	3410      	adds	r4, #16
		return TC_CRYPTO_FAIL;
	}

	for (i = 0; i < Nk; ++i) {
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    4742:	784b      	ldrb	r3, [r1, #1]
    4744:	780d      	ldrb	r5, [r1, #0]
    4746:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    4748:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    474c:	78cd      	ldrb	r5, [r1, #3]
    474e:	432b      	orrs	r3, r5
    4750:	788d      	ldrb	r5, [r1, #2]
    4752:	3104      	adds	r1, #4
    4754:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	for (i = 0; i < Nk; ++i) {
    4758:	428c      	cmp	r4, r1
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    475a:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
    475e:	d1f0      	bne.n	4742 <tc_aes128_set_encrypt_key+0x2e>
	}

	for (; i < (Nb * (Nr + 1)); ++i) {
		t = s->words[i-1];
		if ((i % Nk) == 0) {
			t = subword(rotword(t)) ^ rconst[i/Nk];
    4760:	4c14      	ldr	r4, [pc, #80]	; (47b4 <tc_aes128_set_encrypt_key+0xa0>)
    4762:	2104      	movs	r1, #4
		if ((i % Nk) == 0) {
    4764:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
    4766:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
    4768:	d116      	bne.n	4798 <tc_aes128_set_encrypt_key+0x84>
			t = subword(rotword(t)) ^ rconst[i/Nk];
    476a:	f3c3 4207 	ubfx	r2, r3, #16, #8
    476e:	5ca5      	ldrb	r5, [r4, r2]
    4770:	0e1a      	lsrs	r2, r3, #24
    4772:	5ca2      	ldrb	r2, [r4, r2]
    4774:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
    4778:	f3c3 2507 	ubfx	r5, r3, #8, #8
    477c:	b2db      	uxtb	r3, r3
    477e:	5d65      	ldrb	r5, [r4, r5]
    4780:	5ce3      	ldrb	r3, [r4, r3]
    4782:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    4786:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    478a:	ad0c      	add	r5, sp, #48	; 0x30
    478c:	f021 0303 	bic.w	r3, r1, #3
    4790:	442b      	add	r3, r5
    4792:	f853 3c2c 	ldr.w	r3, [r3, #-44]
    4796:	4053      	eors	r3, r2
		}
		s->words[i] = s->words[i-Nk] ^ t;
    4798:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
    479c:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
    479e:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
    47a0:	292c      	cmp	r1, #44	; 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
    47a2:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
    47a4:	d1de      	bne.n	4764 <tc_aes128_set_encrypt_key+0x50>
	}

	return TC_CRYPTO_SUCCESS;
    47a6:	2001      	movs	r0, #1
}
    47a8:	b00d      	add	sp, #52	; 0x34
    47aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
    47ac:	4620      	mov	r0, r4
    47ae:	e7fb      	b.n	47a8 <tc_aes128_set_encrypt_key+0x94>
    47b0:	00029a10 	.word	0x00029a10
    47b4:	0002af1f 	.word	0x0002af1f

000047b8 <tc_aes_encrypt>:
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	(void) _copy(s, sizeof(t), t, sizeof(t));
}

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
    47b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    47bc:	4615      	mov	r5, r2
    47be:	b089      	sub	sp, #36	; 0x24
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
    47c0:	4606      	mov	r6, r0
    47c2:	2800      	cmp	r0, #0
    47c4:	d058      	beq.n	4878 <tc_aes_encrypt+0xc0>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
    47c6:	2900      	cmp	r1, #0
    47c8:	d059      	beq.n	487e <tc_aes_encrypt+0xc6>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    47ca:	2a00      	cmp	r2, #0
    47cc:	d059      	beq.n	4882 <tc_aes_encrypt+0xca>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    47ce:	2310      	movs	r3, #16
    47d0:	460a      	mov	r2, r1
    47d2:	4668      	mov	r0, sp
    47d4:	4619      	mov	r1, r3
    47d6:	f020 f8be 	bl	24956 <_copy>
	add_round_key(state, s->words);
    47da:	4629      	mov	r1, r5
    47dc:	4668      	mov	r0, sp
		s[i] = sbox[s[i]];
    47de:	4c2a      	ldr	r4, [pc, #168]	; (4888 <tc_aes_encrypt+0xd0>)
	add_round_key(state, s->words);
    47e0:	f020 ffc3 	bl	2576a <add_round_key>

	for (i = 0; i < (Nr - 1); ++i) {
    47e4:	f105 0710 	add.w	r7, r5, #16
    47e8:	46a1      	mov	r9, r4
    47ea:	35a0      	adds	r5, #160	; 0xa0
	for (i = 0; i < (Nb * Nk); ++i) {
    47ec:	46e8      	mov	r8, sp
{
    47ee:	466a      	mov	r2, sp
    47f0:	2310      	movs	r3, #16
		s[i] = sbox[s[i]];
    47f2:	7811      	ldrb	r1, [r2, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
    47f4:	3b01      	subs	r3, #1
		s[i] = sbox[s[i]];
    47f6:	5c61      	ldrb	r1, [r4, r1]
    47f8:	f802 1b01 	strb.w	r1, [r2], #1
	for (i = 0; i < (Nb * Nk); ++i) {
    47fc:	d1f9      	bne.n	47f2 <tc_aes_encrypt+0x3a>
		sub_bytes(state);
		shift_rows(state);
    47fe:	4668      	mov	r0, sp
    4800:	f020 fff8 	bl	257f4 <shift_rows>
	mult_row_column(t, s);
    4804:	4669      	mov	r1, sp
    4806:	a804      	add	r0, sp, #16
    4808:	f021 f82d 	bl	25866 <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
    480c:	a901      	add	r1, sp, #4
    480e:	a805      	add	r0, sp, #20
    4810:	f021 f829 	bl	25866 <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
    4814:	a902      	add	r1, sp, #8
    4816:	a806      	add	r0, sp, #24
    4818:	f021 f825 	bl	25866 <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
    481c:	a903      	add	r1, sp, #12
    481e:	a807      	add	r0, sp, #28
    4820:	f021 f821 	bl	25866 <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
    4824:	2310      	movs	r3, #16
    4826:	4619      	mov	r1, r3
    4828:	eb0d 0203 	add.w	r2, sp, r3
    482c:	4668      	mov	r0, sp
    482e:	f020 f892 	bl	24956 <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
    4832:	4639      	mov	r1, r7
    4834:	4668      	mov	r0, sp
    4836:	3710      	adds	r7, #16
    4838:	f020 ff97 	bl	2576a <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
    483c:	42af      	cmp	r7, r5
    483e:	d1d5      	bne.n	47ec <tc_aes_encrypt+0x34>
    4840:	2410      	movs	r4, #16
		s[i] = sbox[s[i]];
    4842:	f898 3000 	ldrb.w	r3, [r8]
	for (i = 0; i < (Nb * Nk); ++i) {
    4846:	3c01      	subs	r4, #1
		s[i] = sbox[s[i]];
    4848:	f819 3003 	ldrb.w	r3, [r9, r3]
    484c:	f808 3b01 	strb.w	r3, [r8], #1
	for (i = 0; i < (Nb * Nk); ++i) {
    4850:	d1f7      	bne.n	4842 <tc_aes_encrypt+0x8a>
	}

	sub_bytes(state);
	shift_rows(state);
    4852:	4668      	mov	r0, sp
    4854:	f020 ffce 	bl	257f4 <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
    4858:	4629      	mov	r1, r5
    485a:	4668      	mov	r0, sp
    485c:	f020 ff85 	bl	2576a <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
    4860:	2310      	movs	r3, #16
    4862:	4619      	mov	r1, r3
    4864:	466a      	mov	r2, sp
    4866:	4630      	mov	r0, r6
    4868:	f020 f875 	bl	24956 <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    486c:	4668      	mov	r0, sp
    486e:	2210      	movs	r2, #16
    4870:	4621      	mov	r1, r4
    4872:	f020 f87d 	bl	24970 <_set>

	return TC_CRYPTO_SUCCESS;
    4876:	2001      	movs	r0, #1
}
    4878:	b009      	add	sp, #36	; 0x24
    487a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return TC_CRYPTO_FAIL;
    487e:	4608      	mov	r0, r1
    4880:	e7fa      	b.n	4878 <tc_aes_encrypt+0xc0>
    4882:	4610      	mov	r0, r2
    4884:	e7f8      	b.n	4878 <tc_aes_encrypt+0xc0>
    4886:	bf00      	nop
    4888:	0002af1f 	.word	0x0002af1f

0000488c <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
    488c:	4804      	ldr	r0, [pc, #16]	; (48a0 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
    488e:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
    4890:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
    4892:	4288      	cmp	r0, r1
    beq _EXIT_EXC
    4894:	d003      	beq.n	489e <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
    4896:	4903      	ldr	r1, [pc, #12]	; (48a4 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
    4898:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
    489c:	600a      	str	r2, [r1, #0]

0000489e <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
    489e:	4770      	bx	lr
    ldr r0, =_kernel
    48a0:	20001d80 	.word	0x20001d80
    ldr r1, =_SCS_ICSR
    48a4:	e000ed04 	.word	0xe000ed04

000048a8 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    48a8:	4a0a      	ldr	r2, [pc, #40]	; (48d4 <arch_swap+0x2c>)
	_current->arch.swap_return_value = _k_neg_eagain;
    48aa:	490b      	ldr	r1, [pc, #44]	; (48d8 <arch_swap+0x30>)
	_current->arch.basepri = key;
    48ac:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    48ae:	6809      	ldr	r1, [r1, #0]
    48b0:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    48b4:	4909      	ldr	r1, [pc, #36]	; (48dc <arch_swap+0x34>)
	_current->arch.basepri = key;
    48b6:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    48ba:	684b      	ldr	r3, [r1, #4]
    48bc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    48c0:	604b      	str	r3, [r1, #4]
    48c2:	2300      	movs	r3, #0
    48c4:	f383 8811 	msr	BASEPRI, r3
    48c8:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    48cc:	6893      	ldr	r3, [r2, #8]
}
    48ce:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
    48d2:	4770      	bx	lr
    48d4:	20001d80 	.word	0x20001d80
    48d8:	0002a540 	.word	0x0002a540
    48dc:	e000ed00 	.word	0xe000ed00

000048e0 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    48e0:	4913      	ldr	r1, [pc, #76]	; (4930 <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
    48e2:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    48e4:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    48e8:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    48ea:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    48ee:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    48f2:	2020      	movs	r0, #32
    msr BASEPRI, r0
    48f4:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    48f8:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    48fc:	4f0d      	ldr	r7, [pc, #52]	; (4934 <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    48fe:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    4902:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    4904:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    4906:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    4908:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
    movs r3, #0
    490c:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    490e:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    4912:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
    4916:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    4918:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    491a:	f000 fc85 	bl	5228 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    491e:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    4922:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    4926:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    492a:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    492e:	4770      	bx	lr
    ldr r1, =_kernel
    4930:	20001d80 	.word	0x20001d80
    ldr v4, =_SCS_ICSR
    4934:	e000ed04 	.word	0xe000ed04

00004938 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    4938:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    493c:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    493e:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    4942:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    4946:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    4948:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    494c:	2902      	cmp	r1, #2
    beq _oops
    494e:	d0ff      	beq.n	4950 <_oops>

00004950 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    4950:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    4952:	f021 f8cb 	bl	25aec <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    4956:	bd01      	pop	{r0, pc}

00004958 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    4958:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    495a:	2b00      	cmp	r3, #0
    495c:	db08      	blt.n	4970 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    495e:	2201      	movs	r2, #1
    4960:	f000 001f 	and.w	r0, r0, #31
    4964:	fa02 f000 	lsl.w	r0, r2, r0
    4968:	095b      	lsrs	r3, r3, #5
    496a:	4a02      	ldr	r2, [pc, #8]	; (4974 <arch_irq_enable+0x1c>)
    496c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    4970:	4770      	bx	lr
    4972:	bf00      	nop
    4974:	e000e100 	.word	0xe000e100

00004978 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    4978:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    497a:	2b00      	cmp	r3, #0
    497c:	db0d      	blt.n	499a <arch_irq_disable+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    497e:	2201      	movs	r2, #1
    4980:	095b      	lsrs	r3, r3, #5
    4982:	f000 001f 	and.w	r0, r0, #31
    4986:	fa02 f000 	lsl.w	r0, r2, r0
    498a:	3320      	adds	r3, #32
    498c:	4a03      	ldr	r2, [pc, #12]	; (499c <arch_irq_disable+0x24>)
    498e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4992:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4996:	f3bf 8f6f 	isb	sy
}
    499a:	4770      	bx	lr
    499c:	e000e100 	.word	0xe000e100

000049a0 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    49a0:	4b05      	ldr	r3, [pc, #20]	; (49b8 <arch_irq_is_enabled+0x18>)
    49a2:	0942      	lsrs	r2, r0, #5
    49a4:	f000 001f 	and.w	r0, r0, #31
    49a8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    49ac:	2301      	movs	r3, #1
    49ae:	fa03 f000 	lsl.w	r0, r3, r0
}
    49b2:	4010      	ands	r0, r2
    49b4:	4770      	bx	lr
    49b6:	bf00      	nop
    49b8:	e000e100 	.word	0xe000e100

000049bc <z_arm_irq_priority_set>:
 * priority levels which are reserved.
 *
 * @return N/A
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, u32_t flags)
{
    49bc:	b570      	push	{r4, r5, r6, lr}
	} else {
		prio += _IRQ_PRIO_OFFSET;
	}
#else
	ARG_UNUSED(flags);
	prio += _IRQ_PRIO_OFFSET;
    49be:	1c4c      	adds	r4, r1, #1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
    49c0:	2c07      	cmp	r4, #7
{
    49c2:	4605      	mov	r5, r0
    49c4:	460e      	mov	r6, r1
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
    49c6:	d90e      	bls.n	49e6 <z_arm_irq_priority_set+0x2a>
    49c8:	4a10      	ldr	r2, [pc, #64]	; (4a0c <z_arm_irq_priority_set+0x50>)
    49ca:	4911      	ldr	r1, [pc, #68]	; (4a10 <z_arm_irq_priority_set+0x54>)
    49cc:	4811      	ldr	r0, [pc, #68]	; (4a14 <z_arm_irq_priority_set+0x58>)
    49ce:	235b      	movs	r3, #91	; 0x5b
    49d0:	f01f fa87 	bl	23ee2 <printk>
    49d4:	4810      	ldr	r0, [pc, #64]	; (4a18 <z_arm_irq_priority_set+0x5c>)
    49d6:	4631      	mov	r1, r6
    49d8:	2207      	movs	r2, #7
    49da:	f01f fa82 	bl	23ee2 <printk>
    49de:	480b      	ldr	r0, [pc, #44]	; (4a0c <z_arm_irq_priority_set+0x50>)
    49e0:	215b      	movs	r1, #91	; 0x5b
    49e2:	f01f fac1 	bl	23f68 <assert_post_action>
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    49e6:	b26b      	sxtb	r3, r5
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    49e8:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    49ea:	bfac      	ite	ge
    49ec:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    49f0:	4b0a      	ldrlt	r3, [pc, #40]	; (4a1c <z_arm_irq_priority_set+0x60>)
    49f2:	ea4f 1444 	mov.w	r4, r4, lsl #5
    49f6:	bfb8      	it	lt
    49f8:	f005 050f 	andlt.w	r5, r5, #15
    49fc:	b2e4      	uxtb	r4, r4
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    49fe:	bfaa      	itet	ge
    4a00:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    4a04:	555c      	strblt	r4, [r3, r5]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    4a06:	f883 4300 	strbge.w	r4, [r3, #768]	; 0x300
}
    4a0a:	bd70      	pop	{r4, r5, r6, pc}
    4a0c:	0002b01f 	.word	0x0002b01f
    4a10:	0002b055 	.word	0x0002b055
    4a14:	0002a5e8 	.word	0x0002a5e8
    4a18:	0002b070 	.word	0x0002b070
    4a1c:	e000ed14 	.word	0xe000ed14

00004a20 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
    4a20:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
    4a22:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
    4a24:	4b04      	ldr	r3, [pc, #16]	; (4a38 <_arch_isr_direct_pm+0x18>)
    4a26:	6a18      	ldr	r0, [r3, #32]
    4a28:	b118      	cbz	r0, 4a32 <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
    4a2a:	2200      	movs	r2, #0
    4a2c:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
    4a2e:	f024 fbbe 	bl	291ae <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
    4a32:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
    4a34:	bd08      	pop	{r3, pc}
    4a36:	bf00      	nop
    4a38:	20001d80 	.word	0x20001d80

00004a3c <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
    4a3c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    4a40:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
	char *pStackMem = Z_THREAD_STACK_BUFFER(stack);
	char *stackEnd;
	/* Offset between the top of stack and the high end of stack area. */
	u32_t top_of_stack_offset = 0U;

	Z_ASSERT_VALID_PRIO(priority, pEntry);
    4a44:	f1b9 0f0f 	cmp.w	r9, #15
{
    4a48:	4605      	mov	r5, r0
    4a4a:	4690      	mov	r8, r2
    4a4c:	461e      	mov	r6, r3
#define K_THREAD_STACK_MEMBER(sym, size) ARCH_THREAD_STACK_MEMBER(sym, size)
#define K_THREAD_STACK_SIZEOF(sym) ARCH_THREAD_STACK_SIZEOF(sym)
#define K_THREAD_STACK_RESERVED ((size_t)ARCH_THREAD_STACK_RESERVED)
static inline char *Z_THREAD_STACK_BUFFER(k_thread_stack_t *sym)
{
	return ARCH_THREAD_STACK_BUFFER(sym);
    4a4e:	f101 0720 	add.w	r7, r1, #32
	Z_ASSERT_VALID_PRIO(priority, pEntry);
    4a52:	d125      	bne.n	4aa0 <arch_new_thread+0x64>
    4a54:	4b1d      	ldr	r3, [pc, #116]	; (4acc <arch_new_thread+0x90>)
    4a56:	429e      	cmp	r6, r3
    4a58:	d126      	bne.n	4aa8 <arch_new_thread+0x6c>
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
    4a5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    4a5c:	9300      	str	r3, [sp, #0]
    4a5e:	4642      	mov	r2, r8
    4a60:	464b      	mov	r3, r9
	stackEnd = pStackMem + stackSize;
    4a62:	eb07 0408 	add.w	r4, r7, r8
	z_new_thread_init(thread, pStackMem, stackSize, priority,
    4a66:	4639      	mov	r1, r7
    4a68:	4628      	mov	r0, r5
    4a6a:	f024 fc4f 	bl	2930c <z_new_thread_init>
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    4a6e:	f1a4 0220 	sub.w	r2, r4, #32
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    4a72:	4b17      	ldr	r3, [pc, #92]	; (4ad0 <arch_new_thread+0x94>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    4a74:	f022 0207 	bic.w	r2, r2, #7
	pInitCtx->basic.pc &= 0xfffffffe;
    4a78:	f023 0301 	bic.w	r3, r3, #1
    4a7c:	6193      	str	r3, [r2, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
    4a7e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4a80:	6053      	str	r3, [r2, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    4a82:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4a84:	6093      	str	r3, [r2, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    4a86:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4a88:	60d3      	str	r3, [r2, #12]
	pInitCtx->basic.xpsr =
    4a8a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    4a8e:	61d3      	str	r3, [r2, #28]
	thread->callee_saved.spsr |= T_BIT;
#endif

	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif /* CONFIG_CPU_CORTEX_R */
	thread->arch.basepri = 0;
    4a90:	2300      	movs	r3, #0
	pInitCtx->basic.a1 = (u32_t)pEntry;
    4a92:	6016      	str	r6, [r2, #0]
	thread->callee_saved.psp = (u32_t)pInitCtx;
    4a94:	652a      	str	r2, [r5, #80]	; 0x50
	thread->arch.basepri = 0;
    4a96:	f8c5 308c 	str.w	r3, [r5, #140]	; 0x8c

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    4a9a:	b003      	add	sp, #12
    4a9c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	Z_ASSERT_VALID_PRIO(priority, pEntry);
    4aa0:	f109 0310 	add.w	r3, r9, #16
    4aa4:	2b1e      	cmp	r3, #30
    4aa6:	d9d8      	bls.n	4a5a <arch_new_thread+0x1e>
    4aa8:	4a0a      	ldr	r2, [pc, #40]	; (4ad4 <arch_new_thread+0x98>)
    4aaa:	490b      	ldr	r1, [pc, #44]	; (4ad8 <arch_new_thread+0x9c>)
    4aac:	480b      	ldr	r0, [pc, #44]	; (4adc <arch_new_thread+0xa0>)
    4aae:	2329      	movs	r3, #41	; 0x29
    4ab0:	f01f fa17 	bl	23ee2 <printk>
    4ab4:	4649      	mov	r1, r9
    4ab6:	480a      	ldr	r0, [pc, #40]	; (4ae0 <arch_new_thread+0xa4>)
    4ab8:	f06f 030f 	mvn.w	r3, #15
    4abc:	220e      	movs	r2, #14
    4abe:	f01f fa10 	bl	23ee2 <printk>
    4ac2:	4804      	ldr	r0, [pc, #16]	; (4ad4 <arch_new_thread+0x98>)
    4ac4:	2129      	movs	r1, #41	; 0x29
    4ac6:	f01f fa4f 	bl	23f68 <assert_post_action>
    4aca:	e7c6      	b.n	4a5a <arch_new_thread+0x1e>
    4acc:	00020531 	.word	0x00020531
    4ad0:	00023f17 	.word	0x00023f17
    4ad4:	0002b0a5 	.word	0x0002b0a5
    4ad8:	0002b0d7 	.word	0x0002b0d7
    4adc:	0002a5e8 	.word	0x0002a5e8
    4ae0:	0002b164 	.word	0x0002b164

00004ae4 <z_check_thread_stack_fail>:
 * @return The lowest allowed stack frame pointer, if error is a
 *         thread stack corruption, otherwise return 0.
 */
u32_t z_check_thread_stack_fail(const u32_t fault_addr, const u32_t psp)
{
	const struct k_thread *thread = _current;
    4ae4:	4a0a      	ldr	r2, [pc, #40]	; (4b10 <z_check_thread_stack_fail+0x2c>)
{
    4ae6:	4603      	mov	r3, r0
	const struct k_thread *thread = _current;
    4ae8:	6890      	ldr	r0, [r2, #8]

	if (!thread) {
    4aea:	b178      	cbz	r0, 4b0c <z_check_thread_stack_fail+0x28>
			/* Supervisor thread stack corruption */
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    4aec:	3316      	adds	r3, #22
    4aee:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
    4af2:	d102      	bne.n	4afa <z_check_thread_stack_fail+0x16>
    4af4:	f110 0f16 	cmn.w	r0, #22
    4af8:	d904      	bls.n	4b04 <z_check_thread_stack_fail+0x20>
    4afa:	4281      	cmp	r1, r0
    4afc:	bf2c      	ite	cs
    4afe:	2100      	movcs	r1, #0
    4b00:	2101      	movcc	r1, #1
    4b02:	e000      	b.n	4b06 <z_check_thread_stack_fail+0x22>
    4b04:	2100      	movs	r1, #0
    4b06:	2900      	cmp	r1, #0
		/* Thread stack corruption */
		return thread->stack_info.start;
	}
#endif /* CONFIG_USERSPACE */

	return 0;
    4b08:	bf08      	it	eq
    4b0a:	2000      	moveq	r0, #0
}
    4b0c:	4770      	bx	lr
    4b0e:	bf00      	nop
    4b10:	20001d80 	.word	0x20001d80

00004b14 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
    4b14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4b16:	4615      	mov	r5, r2
    4b18:	4606      	mov	r6, r0
    4b1a:	460c      	mov	r4, r1
    4b1c:	461f      	mov	r7, r3
#endif

	/* get high address of the stack, i.e. its start (stack grows down) */
	char *start_of_main_stack;

	start_of_main_stack =
    4b1e:	3520      	adds	r5, #32
	z_arm_configure_static_mpu_regions();
    4b20:	f000 fb66 	bl	51f0 <z_arm_configure_static_mpu_regions>
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
    4b24:	4b0a      	ldr	r3, [pc, #40]	; (4b50 <arch_switch_to_main_thread+0x3c>)
	start_of_main_stack =
    4b26:	442c      	add	r4, r5
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    4b28:	4630      	mov	r0, r6
	_current = main_thread;
    4b2a:	609e      	str	r6, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
    4b2c:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
    4b30:	f000 fb7a 	bl	5228 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    4b34:	4638      	mov	r0, r7
    4b36:	f384 8809 	msr	PSP, r4
    4b3a:	2100      	movs	r1, #0
    4b3c:	b663      	cpsie	if
    4b3e:	f381 8811 	msr	BASEPRI, r1
    4b42:	f3bf 8f6f 	isb	sy
    4b46:	2200      	movs	r2, #0
    4b48:	2300      	movs	r3, #0
    4b4a:	f01f f9e4 	bl	23f16 <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    4b4e:	bf00      	nop
    4b50:	20001d80 	.word	0x20001d80

00004b54 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    4b54:	4901      	ldr	r1, [pc, #4]	; (4b5c <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    4b56:	2210      	movs	r2, #16
	str	r2, [r1]
    4b58:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    4b5a:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    4b5c:	e000ed10 	.word	0xe000ed10

00004b60 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    4b60:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    4b62:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    4b64:	f380 8811 	msr	BASEPRI, r0
	isb
    4b68:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    4b6c:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    4b70:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    4b72:	b662      	cpsie	i
	isb
    4b74:	f3bf 8f6f 	isb	sy

	bx	lr
    4b78:	4770      	bx	lr
    4b7a:	bf00      	nop

00004b7c <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
    4b7c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    4b80:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
    4b84:	4672      	mov	r2, lr

	push {r0, lr}
    4b86:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
    4b88:	f000 f9fa 	bl	4f80 <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
    4b8c:	bd01      	pop	{r0, pc}
    4b8e:	bf00      	nop

00004b90 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    4b90:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4b92:	4606      	mov	r6, r0

	if (esf != NULL) {
    4b94:	460c      	mov	r4, r1
    4b96:	b301      	cbz	r1, 4bda <z_arm_fatal_error+0x4a>
    4b98:	4b13      	ldr	r3, [pc, #76]	; (4be8 <z_arm_fatal_error+0x58>)
    4b9a:	4d14      	ldr	r5, [pc, #80]	; (4bec <z_arm_fatal_error+0x5c>)
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    4b9c:	4814      	ldr	r0, [pc, #80]	; (4bf0 <z_arm_fatal_error+0x60>)
    4b9e:	1aed      	subs	r5, r5, r3
    4ba0:	08ed      	lsrs	r5, r5, #3
    4ba2:	01ad      	lsls	r5, r5, #6
    4ba4:	f045 0501 	orr.w	r5, r5, #1
    4ba8:	f8ad 5000 	strh.w	r5, [sp]
    4bac:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
    4bb0:	6809      	ldr	r1, [r1, #0]
    4bb2:	f01f fa41 	bl	24038 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    4bb6:	f8ad 5000 	strh.w	r5, [sp]
    4bba:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    4bbe:	68e1      	ldr	r1, [r4, #12]
    4bc0:	480c      	ldr	r0, [pc, #48]	; (4bf4 <z_arm_fatal_error+0x64>)
    4bc2:	f01f fa39 	bl	24038 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    4bc6:	69e1      	ldr	r1, [r4, #28]
    4bc8:	480b      	ldr	r0, [pc, #44]	; (4bf8 <z_arm_fatal_error+0x68>)
    4bca:	462a      	mov	r2, r5
    4bcc:	f01f fa07 	bl	23fde <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    4bd0:	69a1      	ldr	r1, [r4, #24]
    4bd2:	480a      	ldr	r0, [pc, #40]	; (4bfc <z_arm_fatal_error+0x6c>)
    4bd4:	462a      	mov	r2, r5
    4bd6:	f01f fa02 	bl	23fde <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    4bda:	4621      	mov	r1, r4
    4bdc:	4630      	mov	r0, r6
}
    4bde:	b002      	add	sp, #8
    4be0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
    4be4:	f01b bc34 	b.w	20450 <z_fatal_error>
    4be8:	00029830 	.word	0x00029830
    4bec:	000299c8 	.word	0x000299c8
    4bf0:	0002b195 	.word	0x0002b195
    4bf4:	0002b1c4 	.word	0x0002b1c4
    4bf8:	0002b1f3 	.word	0x0002b1f3
    4bfc:	0002b202 	.word	0x0002b202

00004c00 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    4c00:	bf30      	wfi
    b z_SysNmiOnReset
    4c02:	f7ff bffd 	b.w	4c00 <z_SysNmiOnReset>
    4c06:	bf00      	nop

00004c08 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    4c08:	4a0e      	ldr	r2, [pc, #56]	; (4c44 <z_arm_prep_c+0x3c>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    4c0a:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    4c0c:	4b0e      	ldr	r3, [pc, #56]	; (4c48 <z_arm_prep_c+0x40>)
    4c0e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    4c12:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    4c14:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4c18:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    4c1c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    4c20:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    4c24:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    4c28:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    4c2c:	f023 0304 	bic.w	r3, r3, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    4c30:	f383 8814 	msr	CONTROL, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    4c34:	f01b fc96 	bl	20564 <z_bss_zero>
	z_data_copy();
    4c38:	f01b fc9e 	bl	20578 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    4c3c:	f000 fa8e 	bl	515c <z_arm_interrupt_init>
	z_cstart();
    4c40:	f01b fcd8 	bl	205f4 <z_cstart>
    4c44:	00000000 	.word	0x00000000
    4c48:	e000ed00 	.word	0xe000ed00

00004c4c <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    4c4c:	b501      	push	{r0, lr}
      * FIXME: Remove the Cortex-M conditional compilation checks for `cpsid i`
      *        and `cpsie i` after the Cortex-R port is updated to support
      *        interrupt nesting.  For more details, refer to the issue #21758.
      */
#if defined(CONFIG_CPU_CORTEX_M)
	cpsid i  /* PRIMASK = 1 */
    4c4e:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    4c50:	4a0b      	ldr	r2, [pc, #44]	; (4c80 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    4c52:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    4c54:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    4c56:	bf1e      	ittt	ne
	movne	r1, #0
    4c58:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    4c5a:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    4c5c:	f024 faa7 	blne	291ae <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    4c60:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    4c62:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    4c66:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    4c6a:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	push {r0, r1}
	lsl r0, r0, #3	/* table is 8-byte wide */
#else
#error Unknown ARM architecture
#endif /* CONFIG_CPU_CORTEX_M */
	ldr r1, =_sw_isr_table
    4c6e:	4905      	ldr	r1, [pc, #20]	; (4c84 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    4c70:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    4c72:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    4c74:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    4c76:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    4c7a:	4903      	ldr	r1, [pc, #12]	; (4c88 <_isr_wrapper+0x3c>)
	bx r1
    4c7c:	4708      	bx	r1
    4c7e:	0000      	.short	0x0000
	ldr r2, =_kernel
    4c80:	20001d80 	.word	0x20001d80
	ldr r1, =_sw_isr_table
    4c84:	00029580 	.word	0x00029580
	ldr r1, =z_arm_int_exit
    4c88:	0000488d 	.word	0x0000488d

00004c8c <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    4c8c:	f021 f8e0 	bl	25e50 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    4c90:	2020      	movs	r0, #32
    msr BASEPRI, r0
    4c92:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    4c96:	4808      	ldr	r0, [pc, #32]	; (4cb8 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    4c98:	f44f 6180 	mov.w	r1, #1024	; 0x400
    adds r0, r0, r1
    4c9c:	1840      	adds	r0, r0, r1
    msr PSP, r0
    4c9e:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    4ca2:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    4ca6:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    4ca8:	4308      	orrs	r0, r1
    msr CONTROL, r0
    4caa:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    4cae:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    4cb2:	f7ff ffa9 	bl	4c08 <z_arm_prep_c>
    4cb6:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    4cb8:	20003f80 	.word	0x20003f80

00004cbc <mem_manage_fault>:
 *
 * @return error code to identify the fatal error reason
 */
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
			      bool *recoverable)
{
    4cbc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4cc0:	4b3c      	ldr	r3, [pc, #240]	; (4db4 <mem_manage_fault+0xf8>)
    4cc2:	4c3d      	ldr	r4, [pc, #244]	; (4db8 <mem_manage_fault+0xfc>)
	u32_t reason = K_ERR_CPU_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    4cc4:	4d3d      	ldr	r5, [pc, #244]	; (4dbc <mem_manage_fault+0x100>)
    4cc6:	1ae4      	subs	r4, r4, r3
    4cc8:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
    4cca:	01a4      	lsls	r4, r4, #6
    4ccc:	f044 0901 	orr.w	r9, r4, #1
{
    4cd0:	4607      	mov	r7, r0
    4cd2:	4688      	mov	r8, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
    4cd4:	483a      	ldr	r0, [pc, #232]	; (4dc0 <mem_manage_fault+0x104>)
    4cd6:	4649      	mov	r1, r9
{
    4cd8:	4616      	mov	r6, r2
	PR_FAULT_INFO("***** MPU FAULT *****");
    4cda:	f01f f973 	bl	23fc4 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    4cde:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    4ce0:	06d3      	lsls	r3, r2, #27
    4ce2:	d503      	bpl.n	4cec <mem_manage_fault+0x30>
		PR_FAULT_INFO("  Stacking error (context area might be"
    4ce4:	4837      	ldr	r0, [pc, #220]	; (4dc4 <mem_manage_fault+0x108>)
    4ce6:	4649      	mov	r1, r9
    4ce8:	f01f f96c 	bl	23fc4 <log_0>
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    4cec:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4cee:	071d      	lsls	r5, r3, #28
    4cf0:	d504      	bpl.n	4cfc <mem_manage_fault+0x40>
		PR_FAULT_INFO("  Unstacking error");
    4cf2:	4835      	ldr	r0, [pc, #212]	; (4dc8 <mem_manage_fault+0x10c>)
    4cf4:	f044 0101 	orr.w	r1, r4, #1
    4cf8:	f01f f964 	bl	23fc4 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    4cfc:	4d2f      	ldr	r5, [pc, #188]	; (4dbc <mem_manage_fault+0x100>)
    4cfe:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4d00:	0798      	lsls	r0, r3, #30
    4d02:	d543      	bpl.n	4d8c <mem_manage_fault+0xd0>
		PR_FAULT_INFO("  Data Access Violation");
    4d04:	f044 0a01 	orr.w	sl, r4, #1
    4d08:	4651      	mov	r1, sl
    4d0a:	4830      	ldr	r0, [pc, #192]	; (4dcc <mem_manage_fault+0x110>)
    4d0c:	f01f f95a 	bl	23fc4 <log_0>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
    4d10:	f8d5 9034 	ldr.w	r9, [r5, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    4d14:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4d16:	0619      	lsls	r1, r3, #24
    4d18:	d50b      	bpl.n	4d32 <mem_manage_fault+0x76>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    4d1a:	482d      	ldr	r0, [pc, #180]	; (4dd0 <mem_manage_fault+0x114>)
    4d1c:	4652      	mov	r2, sl
    4d1e:	4649      	mov	r1, r9
    4d20:	f01f f95d 	bl	23fde <log_1>
			if (from_hard_fault) {
    4d24:	f1b8 0f00 	cmp.w	r8, #0
    4d28:	d003      	beq.n	4d32 <mem_manage_fault+0x76>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    4d2a:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4d2c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    4d30:	62ab      	str	r3, [r5, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    4d32:	4d22      	ldr	r5, [pc, #136]	; (4dbc <mem_manage_fault+0x100>)
    4d34:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    4d36:	07d2      	lsls	r2, r2, #31
    4d38:	d504      	bpl.n	4d44 <mem_manage_fault+0x88>
		PR_FAULT_INFO("  Instruction Access Violation");
    4d3a:	4826      	ldr	r0, [pc, #152]	; (4dd4 <mem_manage_fault+0x118>)
    4d3c:	f044 0101 	orr.w	r1, r4, #1
    4d40:	f01f f940 	bl	23fc4 <log_0>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    4d44:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4d46:	069b      	lsls	r3, r3, #26
    4d48:	d504      	bpl.n	4d54 <mem_manage_fault+0x98>
		PR_FAULT_INFO(
    4d4a:	4823      	ldr	r0, [pc, #140]	; (4dd8 <mem_manage_fault+0x11c>)
    4d4c:	f044 0101 	orr.w	r1, r4, #1
    4d50:	f01f f938 	bl	23fc4 <log_0>
	 * if the memory violation error is a stack corruption.
	 *
	 * By design, being a Stacking MemManage fault is a necessary
	 * and sufficient condition for a thread stack corruption.
	 */
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    4d54:	4b19      	ldr	r3, [pc, #100]	; (4dbc <mem_manage_fault+0x100>)
    4d56:	6a9c      	ldr	r4, [r3, #40]	; 0x28
    4d58:	f014 0410 	ands.w	r4, r4, #16
    4d5c:	d00c      	beq.n	4d78 <mem_manage_fault+0xbc>
		 * As we only assess thread stack corruption, we only
		 * process the error further if the stack frame is on
		 * PSP. For always-banked MemManage Fault, this is
		 * equivalent to inspecting the RETTOBASE flag.
		 */
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
    4d5e:	685c      	ldr	r4, [r3, #4]
    4d60:	f414 6400 	ands.w	r4, r4, #2048	; 0x800
    4d64:	d008      	beq.n	4d78 <mem_manage_fault+0xbc>
			u32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
    4d66:	4639      	mov	r1, r7
    4d68:	4648      	mov	r0, r9
    4d6a:	f7ff febb 	bl	4ae4 <z_check_thread_stack_fail>
				((u32_t) &esf[0]));

			if (min_stack_ptr) {
    4d6e:	4604      	mov	r4, r0
    4d70:	b178      	cbz	r0, 4d92 <mem_manage_fault+0xd6>
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
    4d72:	f380 8809 	msr	PSP, r0
				 * fatal error and a thread that corrupted its
				 * stack needs to be aborted.
				 */
				__set_PSP(min_stack_ptr);

				reason = K_ERR_STACK_CHK_FAIL;
    4d76:	2402      	movs	r4, #2
		"Stacking error without stack guard / User-mode support\n");
#endif /* CONFIG_MPU_STACK_GUARD || CONFIG_USERSPACE */
	}

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    4d78:	4a10      	ldr	r2, [pc, #64]	; (4dbc <mem_manage_fault+0x100>)
    4d7a:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4d7c:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    4d80:	6293      	str	r3, [r2, #40]	; 0x28

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
    4d82:	2300      	movs	r3, #0
    4d84:	7033      	strb	r3, [r6, #0]

	return reason;
}
    4d86:	4620      	mov	r0, r4
    4d88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	u32_t mmfar = -EINVAL;
    4d8c:	f06f 0915 	mvn.w	r9, #21
    4d90:	e7cf      	b.n	4d32 <mem_manage_fault+0x76>
				__ASSERT(0,
    4d92:	4a12      	ldr	r2, [pc, #72]	; (4ddc <mem_manage_fault+0x120>)
    4d94:	4912      	ldr	r1, [pc, #72]	; (4de0 <mem_manage_fault+0x124>)
    4d96:	4813      	ldr	r0, [pc, #76]	; (4de4 <mem_manage_fault+0x128>)
    4d98:	f240 132f 	movw	r3, #303	; 0x12f
    4d9c:	f01f f8a1 	bl	23ee2 <printk>
    4da0:	4811      	ldr	r0, [pc, #68]	; (4de8 <mem_manage_fault+0x12c>)
    4da2:	f01f f89e 	bl	23ee2 <printk>
    4da6:	480d      	ldr	r0, [pc, #52]	; (4ddc <mem_manage_fault+0x120>)
    4da8:	f240 112f 	movw	r1, #303	; 0x12f
    4dac:	f01f f8dc 	bl	23f68 <assert_post_action>
    4db0:	e7e2      	b.n	4d78 <mem_manage_fault+0xbc>
    4db2:	bf00      	nop
    4db4:	00029830 	.word	0x00029830
    4db8:	000299c8 	.word	0x000299c8
    4dbc:	e000ed00 	.word	0xe000ed00
    4dc0:	0002b230 	.word	0x0002b230
    4dc4:	0002b246 	.word	0x0002b246
    4dc8:	0002b279 	.word	0x0002b279
    4dcc:	0002b28c 	.word	0x0002b28c
    4dd0:	0002b2a4 	.word	0x0002b2a4
    4dd4:	0002b2ba 	.word	0x0002b2ba
    4dd8:	0002b2d9 	.word	0x0002b2d9
    4ddc:	0002b308 	.word	0x0002b308
    4de0:	0002e3c9 	.word	0x0002e3c9
    4de4:	0002a5e8 	.word	0x0002a5e8
    4de8:	0002b342 	.word	0x0002b342

00004dec <usage_fault.isra.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
    4dec:	b570      	push	{r4, r5, r6, lr}
    4dee:	4b23      	ldr	r3, [pc, #140]	; (4e7c <usage_fault.isra.0+0x90>)
    4df0:	4c23      	ldr	r4, [pc, #140]	; (4e80 <usage_fault.isra.0+0x94>)
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    4df2:	4d24      	ldr	r5, [pc, #144]	; (4e84 <usage_fault.isra.0+0x98>)
	PR_FAULT_INFO("***** USAGE FAULT *****");
    4df4:	4824      	ldr	r0, [pc, #144]	; (4e88 <usage_fault.isra.0+0x9c>)
    4df6:	1ae4      	subs	r4, r4, r3
    4df8:	08e4      	lsrs	r4, r4, #3
    4dfa:	01a4      	lsls	r4, r4, #6
    4dfc:	f044 0601 	orr.w	r6, r4, #1
    4e00:	4631      	mov	r1, r6
    4e02:	f01f f8df 	bl	23fc4 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    4e06:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    4e08:	0193      	lsls	r3, r2, #6
    4e0a:	d503      	bpl.n	4e14 <usage_fault.isra.0+0x28>
		PR_FAULT_INFO("  Division by zero");
    4e0c:	481f      	ldr	r0, [pc, #124]	; (4e8c <usage_fault.isra.0+0xa0>)
    4e0e:	4631      	mov	r1, r6
    4e10:	f01f f8d8 	bl	23fc4 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    4e14:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4e16:	01dd      	lsls	r5, r3, #7
    4e18:	d504      	bpl.n	4e24 <usage_fault.isra.0+0x38>
		PR_FAULT_INFO("  Unaligned memory access");
    4e1a:	481d      	ldr	r0, [pc, #116]	; (4e90 <usage_fault.isra.0+0xa4>)
    4e1c:	f044 0101 	orr.w	r1, r4, #1
    4e20:	f01f f8d0 	bl	23fc4 <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    4e24:	4d17      	ldr	r5, [pc, #92]	; (4e84 <usage_fault.isra.0+0x98>)
    4e26:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    4e28:	0310      	lsls	r0, r2, #12
    4e2a:	d504      	bpl.n	4e36 <usage_fault.isra.0+0x4a>
		PR_FAULT_INFO("  No coprocessor instructions");
    4e2c:	4819      	ldr	r0, [pc, #100]	; (4e94 <usage_fault.isra.0+0xa8>)
    4e2e:	f044 0101 	orr.w	r1, r4, #1
    4e32:	f01f f8c7 	bl	23fc4 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    4e36:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4e38:	0359      	lsls	r1, r3, #13
    4e3a:	d504      	bpl.n	4e46 <usage_fault.isra.0+0x5a>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    4e3c:	4816      	ldr	r0, [pc, #88]	; (4e98 <usage_fault.isra.0+0xac>)
    4e3e:	f044 0101 	orr.w	r1, r4, #1
    4e42:	f01f f8bf 	bl	23fc4 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    4e46:	4d0f      	ldr	r5, [pc, #60]	; (4e84 <usage_fault.isra.0+0x98>)
    4e48:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    4e4a:	0392      	lsls	r2, r2, #14
    4e4c:	d504      	bpl.n	4e58 <usage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    4e4e:	4813      	ldr	r0, [pc, #76]	; (4e9c <usage_fault.isra.0+0xb0>)
    4e50:	f044 0101 	orr.w	r1, r4, #1
    4e54:	f01f f8b6 	bl	23fc4 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    4e58:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4e5a:	03db      	lsls	r3, r3, #15
    4e5c:	d504      	bpl.n	4e68 <usage_fault.isra.0+0x7c>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    4e5e:	4810      	ldr	r0, [pc, #64]	; (4ea0 <usage_fault.isra.0+0xb4>)
    4e60:	f044 0101 	orr.w	r1, r4, #1
    4e64:	f01f f8ae 	bl	23fc4 <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    4e68:	4a06      	ldr	r2, [pc, #24]	; (4e84 <usage_fault.isra.0+0x98>)
    4e6a:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4e6c:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    4e70:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    4e74:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    4e76:	2000      	movs	r0, #0
    4e78:	bd70      	pop	{r4, r5, r6, pc}
    4e7a:	bf00      	nop
    4e7c:	00029830 	.word	0x00029830
    4e80:	000299c8 	.word	0x000299c8
    4e84:	e000ed00 	.word	0xe000ed00
    4e88:	0002b365 	.word	0x0002b365
    4e8c:	0002b37d 	.word	0x0002b37d
    4e90:	0002b390 	.word	0x0002b390
    4e94:	0002b3aa 	.word	0x0002b3aa
    4e98:	0002b3c8 	.word	0x0002b3c8
    4e9c:	0002b3ed 	.word	0x0002b3ed
    4ea0:	0002b407 	.word	0x0002b407

00004ea4 <bus_fault.isra.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    4ea4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4ea8:	4b2a      	ldr	r3, [pc, #168]	; (4f54 <bus_fault.isra.0+0xb0>)
    4eaa:	4c2b      	ldr	r4, [pc, #172]	; (4f58 <bus_fault.isra.0+0xb4>)
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    4eac:	4d2b      	ldr	r5, [pc, #172]	; (4f5c <bus_fault.isra.0+0xb8>)
    4eae:	1ae4      	subs	r4, r4, r3
    4eb0:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
    4eb2:	01a4      	lsls	r4, r4, #6
    4eb4:	f044 0801 	orr.w	r8, r4, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    4eb8:	4607      	mov	r7, r0
    4eba:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
    4ebc:	4828      	ldr	r0, [pc, #160]	; (4f60 <bus_fault.isra.0+0xbc>)
    4ebe:	4641      	mov	r1, r8
    4ec0:	f01f f880 	bl	23fc4 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    4ec4:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    4ec6:	04d1      	lsls	r1, r2, #19
    4ec8:	d503      	bpl.n	4ed2 <bus_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error");
    4eca:	4826      	ldr	r0, [pc, #152]	; (4f64 <bus_fault.isra.0+0xc0>)
    4ecc:	4641      	mov	r1, r8
    4ece:	f01f f879 	bl	23fc4 <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    4ed2:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4ed4:	051a      	lsls	r2, r3, #20
    4ed6:	d504      	bpl.n	4ee2 <bus_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
    4ed8:	4823      	ldr	r0, [pc, #140]	; (4f68 <bus_fault.isra.0+0xc4>)
    4eda:	f044 0101 	orr.w	r1, r4, #1
    4ede:	f01f f871 	bl	23fc4 <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    4ee2:	4d1e      	ldr	r5, [pc, #120]	; (4f5c <bus_fault.isra.0+0xb8>)
    4ee4:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4ee6:	059b      	lsls	r3, r3, #22
    4ee8:	d512      	bpl.n	4f10 <bus_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Precise data bus error");
    4eea:	f044 0801 	orr.w	r8, r4, #1
    4eee:	481f      	ldr	r0, [pc, #124]	; (4f6c <bus_fault.isra.0+0xc8>)
    4ef0:	4641      	mov	r1, r8
    4ef2:	f01f f867 	bl	23fc4 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
    4ef6:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    4ef8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4efa:	0418      	lsls	r0, r3, #16
    4efc:	d508      	bpl.n	4f10 <bus_fault.isra.0+0x6c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    4efe:	481c      	ldr	r0, [pc, #112]	; (4f70 <bus_fault.isra.0+0xcc>)
    4f00:	4642      	mov	r2, r8
    4f02:	f01f f86c 	bl	23fde <log_1>
			if (from_hard_fault) {
    4f06:	b11f      	cbz	r7, 4f10 <bus_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    4f08:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4f0a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    4f0e:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    4f10:	4d12      	ldr	r5, [pc, #72]	; (4f5c <bus_fault.isra.0+0xb8>)
    4f12:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4f14:	0559      	lsls	r1, r3, #21
    4f16:	d504      	bpl.n	4f22 <bus_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Imprecise data bus error");
    4f18:	4816      	ldr	r0, [pc, #88]	; (4f74 <bus_fault.isra.0+0xd0>)
    4f1a:	f044 0101 	orr.w	r1, r4, #1
    4f1e:	f01f f851 	bl	23fc4 <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    4f22:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4f24:	05da      	lsls	r2, r3, #23
    4f26:	d50d      	bpl.n	4f44 <bus_fault.isra.0+0xa0>
		PR_FAULT_INFO("  Instruction bus error");
    4f28:	4813      	ldr	r0, [pc, #76]	; (4f78 <bus_fault.isra.0+0xd4>)
    4f2a:	f044 0101 	orr.w	r1, r4, #1
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    4f2e:	f01f f849 	bl	23fc4 <log_0>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    4f32:	4a0a      	ldr	r2, [pc, #40]	; (4f5c <bus_fault.isra.0+0xb8>)
    4f34:	6a93      	ldr	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    4f36:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    4f38:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    4f3c:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    4f3e:	7030      	strb	r0, [r6, #0]
}
    4f40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    4f44:	6aab      	ldr	r3, [r5, #40]	; 0x28
    4f46:	049b      	lsls	r3, r3, #18
    4f48:	d5f3      	bpl.n	4f32 <bus_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    4f4a:	480c      	ldr	r0, [pc, #48]	; (4f7c <bus_fault.isra.0+0xd8>)
    4f4c:	f044 0101 	orr.w	r1, r4, #1
    4f50:	e7ed      	b.n	4f2e <bus_fault.isra.0+0x8a>
    4f52:	bf00      	nop
    4f54:	00029830 	.word	0x00029830
    4f58:	000299c8 	.word	0x000299c8
    4f5c:	e000ed00 	.word	0xe000ed00
    4f60:	0002b432 	.word	0x0002b432
    4f64:	0002b448 	.word	0x0002b448
    4f68:	0002b279 	.word	0x0002b279
    4f6c:	0002b459 	.word	0x0002b459
    4f70:	0002b472 	.word	0x0002b472
    4f74:	0002b487 	.word	0x0002b487
    4f78:	0002b4a2 	.word	0x0002b4a2
    4f7c:	0002b2d9 	.word	0x0002b2d9

00004f80 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
    4f80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    4f84:	4b5f      	ldr	r3, [pc, #380]	; (5104 <z_arm_fault+0x184>)
    4f86:	685d      	ldr	r5, [r3, #4]
{
    4f88:	b08a      	sub	sp, #40	; 0x28
    4f8a:	460e      	mov	r6, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    4f8c:	f3c5 0408 	ubfx	r4, r5, #0, #9
    4f90:	2700      	movs	r7, #0
    4f92:	f387 8811 	msr	BASEPRI, r7
    4f96:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    4f9a:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    4f9e:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    4fa2:	d10d      	bne.n	4fc0 <z_arm_fault+0x40>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    4fa4:	f002 030c 	and.w	r3, r2, #12
    4fa8:	2b08      	cmp	r3, #8
    4faa:	d11a      	bne.n	4fe2 <z_arm_fault+0x62>
    4fac:	4956      	ldr	r1, [pc, #344]	; (5108 <z_arm_fault+0x188>)
    4fae:	4b57      	ldr	r3, [pc, #348]	; (510c <z_arm_fault+0x18c>)
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    4fb0:	4857      	ldr	r0, [pc, #348]	; (5110 <z_arm_fault+0x190>)
    4fb2:	1ac9      	subs	r1, r1, r3
    4fb4:	08c9      	lsrs	r1, r1, #3
    4fb6:	0189      	lsls	r1, r1, #6
    4fb8:	f041 0101 	orr.w	r1, r1, #1
    4fbc:	f01f f802 	bl	23fc4 <log_0>

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
    4fc0:	4a54      	ldr	r2, [pc, #336]	; (5114 <z_arm_fault+0x194>)
    4fc2:	4955      	ldr	r1, [pc, #340]	; (5118 <z_arm_fault+0x198>)
    4fc4:	4855      	ldr	r0, [pc, #340]	; (511c <z_arm_fault+0x19c>)
    4fc6:	f44f 736c 	mov.w	r3, #944	; 0x3b0
    4fca:	f01e ff8a 	bl	23ee2 <printk>
    4fce:	4854      	ldr	r0, [pc, #336]	; (5120 <z_arm_fault+0x1a0>)
    4fd0:	f01e ff87 	bl	23ee2 <printk>
    4fd4:	484f      	ldr	r0, [pc, #316]	; (5114 <z_arm_fault+0x194>)
    4fd6:	f44f 716c 	mov.w	r1, #944	; 0x3b0
    4fda:	f01e ffc5 	bl	23f68 <assert_post_action>
    4fde:	2600      	movs	r6, #0
    4fe0:	e005      	b.n	4fee <z_arm_fault+0x6e>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    4fe2:	0712      	lsls	r2, r2, #28
			ptr_esf = (z_arch_esf_t *)msp;
    4fe4:	bf5c      	itt	pl
    4fe6:	4606      	movpl	r6, r0
			*nested_exc = true;
    4fe8:	2701      	movpl	r7, #1
	__ASSERT(esf != NULL,
    4fea:	2e00      	cmp	r6, #0
    4fec:	d0e8      	beq.n	4fc0 <z_arm_fault+0x40>
	*recoverable = false;
    4fee:	2300      	movs	r3, #0
    4ff0:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
    4ff4:	1ee3      	subs	r3, r4, #3
    4ff6:	2b09      	cmp	r3, #9
    4ff8:	d86b      	bhi.n	50d2 <z_arm_fault+0x152>
    4ffa:	e8df f003 	tbb	[pc, r3]
    4ffe:	5905      	.short	0x5905
    5000:	6a6a3d5d 	.word	0x6a6a3d5d
    5004:	616a6a6a 	.word	0x616a6a6a
    5008:	4b40      	ldr	r3, [pc, #256]	; (510c <z_arm_fault+0x18c>)
    500a:	4d3f      	ldr	r5, [pc, #252]	; (5108 <z_arm_fault+0x188>)
	PR_FAULT_INFO("***** HARD FAULT *****");
    500c:	4845      	ldr	r0, [pc, #276]	; (5124 <z_arm_fault+0x1a4>)
    500e:	1aed      	subs	r5, r5, r3
    5010:	08ed      	lsrs	r5, r5, #3
    5012:	01ad      	lsls	r5, r5, #6
    5014:	f045 0501 	orr.w	r5, r5, #1
    5018:	4629      	mov	r1, r5
    501a:	f01e ffd3 	bl	23fc4 <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    501e:	4b39      	ldr	r3, [pc, #228]	; (5104 <z_arm_fault+0x184>)
    5020:	6adc      	ldr	r4, [r3, #44]	; 0x2c
	*recoverable = false;
    5022:	f04f 0800 	mov.w	r8, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    5026:	f014 0402 	ands.w	r4, r4, #2
	*recoverable = false;
    502a:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    502e:	d005      	beq.n	503c <z_arm_fault+0xbc>
		PR_EXC("  Bus fault on vector table read");
    5030:	483d      	ldr	r0, [pc, #244]	; (5128 <z_arm_fault+0x1a8>)
    5032:	4629      	mov	r1, r5
	PR_FAULT_INFO(
    5034:	f01e ffc6 	bl	23fc4 <log_0>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    5038:	2400      	movs	r4, #0
}
    503a:	e020      	b.n	507e <z_arm_fault+0xfe>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    503c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    503e:	005b      	lsls	r3, r3, #1
    5040:	d51d      	bpl.n	507e <z_arm_fault+0xfe>
		PR_EXC("  Fault escalation (see below)");
    5042:	483a      	ldr	r0, [pc, #232]	; (512c <z_arm_fault+0x1ac>)
    5044:	4629      	mov	r1, r5
    5046:	f01e ffbd 	bl	23fc4 <log_0>
		if (SCB_MMFSR != 0) {
    504a:	4b39      	ldr	r3, [pc, #228]	; (5130 <z_arm_fault+0x1b0>)
    504c:	781b      	ldrb	r3, [r3, #0]
    504e:	b133      	cbz	r3, 505e <z_arm_fault+0xde>
			reason = mem_manage_fault(esf, 1, recoverable);
    5050:	f10d 0207 	add.w	r2, sp, #7
    5054:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    5056:	4630      	mov	r0, r6
    5058:	f7ff fe30 	bl	4cbc <mem_manage_fault>
    505c:	e00e      	b.n	507c <z_arm_fault+0xfc>
		} else if (SCB_BFSR != 0) {
    505e:	4b35      	ldr	r3, [pc, #212]	; (5134 <z_arm_fault+0x1b4>)
    5060:	781b      	ldrb	r3, [r3, #0]
    5062:	b12b      	cbz	r3, 5070 <z_arm_fault+0xf0>
			reason = bus_fault(esf, 1, recoverable);
    5064:	f10d 0107 	add.w	r1, sp, #7
    5068:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    506a:	f7ff ff1b 	bl	4ea4 <bus_fault.isra.0>
    506e:	e005      	b.n	507c <z_arm_fault+0xfc>
		} else if (SCB_UFSR != 0) {
    5070:	4b31      	ldr	r3, [pc, #196]	; (5138 <z_arm_fault+0x1b8>)
    5072:	881b      	ldrh	r3, [r3, #0]
    5074:	b29b      	uxth	r3, r3
    5076:	b113      	cbz	r3, 507e <z_arm_fault+0xfe>
			reason = usage_fault(esf);
    5078:	f7ff feb8 	bl	4dec <usage_fault.isra.0>
    507c:	4604      	mov	r4, r0
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    507e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5082:	b993      	cbnz	r3, 50aa <z_arm_fault+0x12a>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    5084:	2220      	movs	r2, #32
    5086:	4631      	mov	r1, r6
    5088:	a802      	add	r0, sp, #8
    508a:	f020 fe0d 	bl	25ca8 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    508e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5090:	b39f      	cbz	r7, 50fa <z_arm_fault+0x17a>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    5092:	f3c3 0208 	ubfx	r2, r3, #0, #9
    5096:	b922      	cbnz	r2, 50a2 <z_arm_fault+0x122>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    5098:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    509c:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    50a0:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    50a2:	a902      	add	r1, sp, #8
    50a4:	4620      	mov	r0, r4
    50a6:	f7ff fd73 	bl	4b90 <z_arm_fatal_error>
}
    50aa:	b00a      	add	sp, #40	; 0x28
    50ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    50b0:	f10d 0207 	add.w	r2, sp, #7
    50b4:	2100      	movs	r1, #0
    50b6:	e7ce      	b.n	5056 <z_arm_fault+0xd6>
		reason = bus_fault(esf, 0, recoverable);
    50b8:	f10d 0107 	add.w	r1, sp, #7
    50bc:	2000      	movs	r0, #0
    50be:	e7d4      	b.n	506a <z_arm_fault+0xea>
    50c0:	4911      	ldr	r1, [pc, #68]	; (5108 <z_arm_fault+0x188>)
    50c2:	4b12      	ldr	r3, [pc, #72]	; (510c <z_arm_fault+0x18c>)
	PR_FAULT_INFO(
    50c4:	481d      	ldr	r0, [pc, #116]	; (513c <z_arm_fault+0x1bc>)
    50c6:	1ac9      	subs	r1, r1, r3
    50c8:	08c9      	lsrs	r1, r1, #3
    50ca:	0189      	lsls	r1, r1, #6
    50cc:	f041 0101 	orr.w	r1, r1, #1
    50d0:	e7b0      	b.n	5034 <z_arm_fault+0xb4>
    50d2:	4a0e      	ldr	r2, [pc, #56]	; (510c <z_arm_fault+0x18c>)
    50d4:	4b0c      	ldr	r3, [pc, #48]	; (5108 <z_arm_fault+0x188>)
	PR_FAULT_INFO("***** %s %d) *****",
    50d6:	481a      	ldr	r0, [pc, #104]	; (5140 <z_arm_fault+0x1c0>)
    50d8:	491a      	ldr	r1, [pc, #104]	; (5144 <z_arm_fault+0x1c4>)
    50da:	1a9b      	subs	r3, r3, r2
    50dc:	08db      	lsrs	r3, r3, #3
    50de:	f415 7ff8 	tst.w	r5, #496	; 0x1f0
    50e2:	ea4f 1383 	mov.w	r3, r3, lsl #6
    50e6:	bf18      	it	ne
    50e8:	4601      	movne	r1, r0
    50ea:	f043 0301 	orr.w	r3, r3, #1
    50ee:	4816      	ldr	r0, [pc, #88]	; (5148 <z_arm_fault+0x1c8>)
    50f0:	f1a4 0210 	sub.w	r2, r4, #16
    50f4:	f01e ff87 	bl	24006 <log_2>
    50f8:	e79e      	b.n	5038 <z_arm_fault+0xb8>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    50fa:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    50fe:	f023 0301 	bic.w	r3, r3, #1
    5102:	e7cd      	b.n	50a0 <z_arm_fault+0x120>
    5104:	e000ed00 	.word	0xe000ed00
    5108:	000299c8 	.word	0x000299c8
    510c:	00029830 	.word	0x00029830
    5110:	0002b4ba 	.word	0x0002b4ba
    5114:	0002b308 	.word	0x0002b308
    5118:	0002b4e5 	.word	0x0002b4e5
    511c:	0002a5e8 	.word	0x0002a5e8
    5120:	0002b4f8 	.word	0x0002b4f8
    5124:	0002b536 	.word	0x0002b536
    5128:	0002b54d 	.word	0x0002b54d
    512c:	0002b56e 	.word	0x0002b56e
    5130:	e000ed28 	.word	0xe000ed28
    5134:	e000ed29 	.word	0xe000ed29
    5138:	e000ed2a 	.word	0xe000ed2a
    513c:	0002b58d 	.word	0x0002b58d
    5140:	0002b5d8 	.word	0x0002b5d8
    5144:	0002b5c3 	.word	0x0002b5c3
    5148:	0002b5f1 	.word	0x0002b5f1

0000514c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    514c:	4a02      	ldr	r2, [pc, #8]	; (5158 <z_arm_fault_init+0xc>)
    514e:	6953      	ldr	r3, [r2, #20]
    5150:	f043 0310 	orr.w	r3, r3, #16
    5154:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    5156:	4770      	bx	lr
    5158:	e000ed00 	.word	0xe000ed00

0000515c <z_arm_interrupt_init>:
    515c:	4804      	ldr	r0, [pc, #16]	; (5170 <z_arm_interrupt_init+0x14>)
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    515e:	2300      	movs	r3, #0
    5160:	2120      	movs	r1, #32
    5162:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    5164:	3301      	adds	r3, #1
    5166:	2b30      	cmp	r3, #48	; 0x30
    5168:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    516c:	d1f9      	bne.n	5162 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    516e:	4770      	bx	lr
    5170:	e000e100 	.word	0xe000e100

00005174 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    5174:	b538      	push	{r3, r4, r5, lr}
    5176:	4604      	mov	r4, r0
	__asm__ volatile(
    5178:	f04f 0320 	mov.w	r3, #32
    517c:	f3ef 8511 	mrs	r5, BASEPRI
    5180:	f383 8811 	msr	BASEPRI, r3
    5184:	f3bf 8f6f 	isb	sy
	unsigned int key;

	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
    5188:	7b03      	ldrb	r3, [r0, #12]
    518a:	07db      	lsls	r3, r3, #31
    518c:	d50c      	bpl.n	51a8 <z_impl_k_thread_abort+0x34>
    518e:	4912      	ldr	r1, [pc, #72]	; (51d8 <z_impl_k_thread_abort+0x64>)
    5190:	4a12      	ldr	r2, [pc, #72]	; (51dc <z_impl_k_thread_abort+0x68>)
    5192:	4813      	ldr	r0, [pc, #76]	; (51e0 <z_impl_k_thread_abort+0x6c>)
    5194:	2323      	movs	r3, #35	; 0x23
    5196:	f01e fea4 	bl	23ee2 <printk>
    519a:	4812      	ldr	r0, [pc, #72]	; (51e4 <z_impl_k_thread_abort+0x70>)
    519c:	f01e fea1 	bl	23ee2 <printk>
    51a0:	480e      	ldr	r0, [pc, #56]	; (51dc <z_impl_k_thread_abort+0x68>)
    51a2:	2123      	movs	r1, #35	; 0x23
    51a4:	f01e fee0 	bl	23f68 <assert_post_action>
		 "essential thread aborted");

	z_thread_single_abort(thread);
    51a8:	4620      	mov	r0, r4
    51aa:	f01c fda3 	bl	21cf4 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    51ae:	4b0e      	ldr	r3, [pc, #56]	; (51e8 <z_impl_k_thread_abort+0x74>)
    51b0:	689b      	ldr	r3, [r3, #8]
    51b2:	42a3      	cmp	r3, r4
    51b4:	d10b      	bne.n	51ce <z_impl_k_thread_abort+0x5a>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    51b6:	4b0d      	ldr	r3, [pc, #52]	; (51ec <z_impl_k_thread_abort+0x78>)
    51b8:	685a      	ldr	r2, [r3, #4]
    51ba:	f3c2 0208 	ubfx	r2, r2, #0, #9
    51be:	b912      	cbnz	r2, 51c6 <z_impl_k_thread_abort+0x52>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    51c0:	4628      	mov	r0, r5
    51c2:	f7ff fb71 	bl	48a8 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    51c6:	685a      	ldr	r2, [r3, #4]
    51c8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    51cc:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    51ce:	4628      	mov	r0, r5
}
    51d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    51d4:	f024 b850 	b.w	29278 <z_reschedule_irqlock>
    51d8:	0002b645 	.word	0x0002b645
    51dc:	0002b604 	.word	0x0002b604
    51e0:	0002a5e8 	.word	0x0002a5e8
    51e4:	0002b673 	.word	0x0002b673
    51e8:	20001d80 	.word	0x20001d80
    51ec:	e000ed00 	.word	0xe000ed00

000051f0 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    51f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    51f2:	4b08      	ldr	r3, [pc, #32]	; (5214 <z_arm_configure_static_mpu_regions+0x24>)
    51f4:	9301      	str	r3, [sp, #4]
    51f6:	4b08      	ldr	r3, [pc, #32]	; (5218 <z_arm_configure_static_mpu_regions+0x28>)
    51f8:	9302      	str	r3, [sp, #8]
    51fa:	4b08      	ldr	r3, [pc, #32]	; (521c <z_arm_configure_static_mpu_regions+0x2c>)
    51fc:	9303      	str	r3, [sp, #12]

	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
    51fe:	ab01      	add	r3, sp, #4
    5200:	9300      	str	r3, [sp, #0]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    5202:	4a07      	ldr	r2, [pc, #28]	; (5220 <z_arm_configure_static_mpu_regions+0x30>)
    5204:	4b07      	ldr	r3, [pc, #28]	; (5224 <z_arm_configure_static_mpu_regions+0x34>)
    5206:	2101      	movs	r1, #1
    5208:	4668      	mov	r0, sp
    520a:	f000 f8f3 	bl	53f4 <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    520e:	b005      	add	sp, #20
    5210:	f85d fb04 	ldr.w	pc, [sp], #4
    5214:	20000000 	.word	0x20000000
    5218:	00000000 	.word	0x00000000
    521c:	060b0000 	.word	0x060b0000
    5220:	20000000 	.word	0x20000000
    5224:	20040000 	.word	0x20040000

00005228 <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
    5228:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		__ASSERT((u32_t)thread->stack_obj == guard_start,
		"Guard start (0x%x) not beginning at stack object (0x%x)\n",
		guard_start, (u32_t)thread->stack_obj);
	}
#else
	guard_start = thread->stack_info.start - guard_size;
    522a:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
    522e:	3b20      	subs	r3, #32
#endif /* CONFIG_USERSPACE */

	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");
	guard = (const struct k_mem_partition)
    5230:	9301      	str	r3, [sp, #4]
    5232:	4b06      	ldr	r3, [pc, #24]	; (524c <z_arm_configure_dynamic_mpu_regions+0x24>)
    5234:	2220      	movs	r2, #32
    5236:	e9cd 2302 	strd	r2, r3, [sp, #8]

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
    523a:	2101      	movs	r1, #1
	dynamic_regions[region_num] = &guard;
    523c:	ab01      	add	r3, sp, #4
	arm_core_mpu_configure_dynamic_mpu_regions(
    523e:	4668      	mov	r0, sp
	dynamic_regions[region_num] = &guard;
    5240:	9300      	str	r3, [sp, #0]
	arm_core_mpu_configure_dynamic_mpu_regions(
    5242:	f000 f8fd 	bl	5440 <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
    5246:	b005      	add	sp, #20
    5248:	f85d fb04 	ldr.w	pc, [sp], #4
    524c:	150b0000 	.word	0x150b0000

00005250 <mpu_configure_regions>:
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
    5250:	f8df c0bc 	ldr.w	ip, [pc, #188]	; 5310 <mpu_configure_regions+0xc0>
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
	*regions[], u8_t regions_num, u8_t start_reg_index,
	bool do_sanity_check)
{
    5254:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5256:	4606      	mov	r6, r0
    5258:	460f      	mov	r7, r1
	int i;
	int reg_index = start_reg_index;
    525a:	4610      	mov	r0, r2

	for (i = 0; i < regions_num; i++) {
    525c:	2100      	movs	r1, #0
    525e:	42b9      	cmp	r1, r7
    5260:	da1b      	bge.n	529a <mpu_configure_regions+0x4a>
		if (regions[i]->size == 0U) {
    5262:	f856 e021 	ldr.w	lr, [r6, r1, lsl #2]
    5266:	f8de 4004 	ldr.w	r4, [lr, #4]
    526a:	2c00      	cmp	r4, #0
    526c:	d046      	beq.n	52fc <mpu_configure_regions+0xac>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    526e:	b1ab      	cbz	r3, 529c <mpu_configure_regions+0x4c>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1)) == 0U)
    5270:	1e65      	subs	r5, r4, #1
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    5272:	422c      	tst	r4, r5
    5274:	d105      	bne.n	5282 <mpu_configure_regions+0x32>
		&&
    5276:	2c1f      	cmp	r4, #31
    5278:	d903      	bls.n	5282 <mpu_configure_regions+0x32>
		((part->start & (part->size - 1)) == 0U);
    527a:	f8de 2000 	ldr.w	r2, [lr]
		&&
    527e:	4215      	tst	r5, r2
    5280:	d00c      	beq.n	529c <mpu_configure_regions+0x4c>
    5282:	4a1f      	ldr	r2, [pc, #124]	; (5300 <mpu_configure_regions+0xb0>)
    5284:	4b1f      	ldr	r3, [pc, #124]	; (5304 <mpu_configure_regions+0xb4>)
				(!mpu_partition_is_valid(regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    5286:	4820      	ldr	r0, [pc, #128]	; (5308 <mpu_configure_regions+0xb8>)
    5288:	1ad2      	subs	r2, r2, r3
    528a:	08d2      	lsrs	r2, r2, #3
    528c:	0192      	lsls	r2, r2, #6
    528e:	f042 0201 	orr.w	r2, r2, #1
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    5292:	f01e fea4 	bl	23fde <log_1>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, regions[i]);
    5296:	f06f 0015 	mvn.w	r0, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    529a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * to that power-of-two value.
 */
static inline u32_t size_to_mpu_rasr_size(u32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    529c:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, regions[i]);
    529e:	b2c5      	uxtb	r5, r0
	region_conf.base = new_region->start;
    52a0:	f8de 2000 	ldr.w	r2, [lr]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    52a4:	f8de 0008 	ldr.w	r0, [lr, #8]
    52a8:	d916      	bls.n	52d8 <mpu_configure_regions+0x88>
	/*
	 * A size value greater than 2^31 could not be handled by
	 * round_up_to_next_power_of_two() properly. We handle
	 * it separately here.
	 */
	if (size > (1UL << 31)) {
    52aa:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    52ae:	d815      	bhi.n	52dc <mpu_configure_regions+0x8c>
		return REGION_4G;
	}

	return ((32 - __builtin_clz(size - 1) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    52b0:	3c01      	subs	r4, #1
    52b2:	fab4 f484 	clz	r4, r4
    52b6:	f1c4 041f 	rsb	r4, r4, #31
    52ba:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1)) {
    52bc:	2d07      	cmp	r5, #7
	/* in ARMv7-M MPU the base address is not required
	 * to determine region attributes
	 */
	(void) base;

	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    52be:	ea44 0400 	orr.w	r4, r4, r0
    52c2:	d90d      	bls.n	52e0 <mpu_configure_regions+0x90>
    52c4:	4a0e      	ldr	r2, [pc, #56]	; (5300 <mpu_configure_regions+0xb0>)
    52c6:	4b0f      	ldr	r3, [pc, #60]	; (5304 <mpu_configure_regions+0xb4>)
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    52c8:	4810      	ldr	r0, [pc, #64]	; (530c <mpu_configure_regions+0xbc>)
    52ca:	1ad2      	subs	r2, r2, r3
    52cc:	08d2      	lsrs	r2, r2, #3
    52ce:	0192      	lsls	r2, r2, #6
    52d0:	f042 0201 	orr.w	r2, r2, #1
    52d4:	4629      	mov	r1, r5
    52d6:	e7dc      	b.n	5292 <mpu_configure_regions+0x42>
		return REGION_32B;
    52d8:	2408      	movs	r4, #8
    52da:	e7ef      	b.n	52bc <mpu_configure_regions+0x6c>
		return REGION_4G;
    52dc:	243e      	movs	r4, #62	; 0x3e
    52de:	e7ed      	b.n	52bc <mpu_configure_regions+0x6c>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    52e0:	f022 021f 	bic.w	r2, r2, #31
				| MPU_RBAR_VALID_Msk | index;
    52e4:	432a      	orrs	r2, r5
    52e6:	f042 0210 	orr.w	r2, r2, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    52ea:	f044 0401 	orr.w	r4, r4, #1
	MPU->RNR = index;
    52ee:	f8cc 5008 	str.w	r5, [ip, #8]
		reg_index++;
    52f2:	1c68      	adds	r0, r5, #1
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    52f4:	f8cc 200c 	str.w	r2, [ip, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    52f8:	f8cc 4010 	str.w	r4, [ip, #16]
	for (i = 0; i < regions_num; i++) {
    52fc:	3101      	adds	r1, #1
    52fe:	e7ae      	b.n	525e <mpu_configure_regions+0xe>
    5300:	000299b8 	.word	0x000299b8
    5304:	00029830 	.word	0x00029830
    5308:	0002b692 	.word	0x0002b692
    530c:	0002b6b5 	.word	0x0002b6b5
    5310:	e000ed90 	.word	0xe000ed90

00005314 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    5314:	4b03      	ldr	r3, [pc, #12]	; (5324 <arm_core_mpu_enable+0x10>)
    5316:	2205      	movs	r2, #5
    5318:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    531a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    531e:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    5322:	4770      	bx	lr
    5324:	e000ed90 	.word	0xe000ed90

00005328 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    5328:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    532c:	4b01      	ldr	r3, [pc, #4]	; (5334 <arm_core_mpu_disable+0xc>)
    532e:	2200      	movs	r2, #0
    5330:	605a      	str	r2, [r3, #4]
}
    5332:	4770      	bx	lr
    5334:	e000ed90 	.word	0xe000ed90

00005338 <arm_mpu_init>:
 */
static int arm_mpu_init(struct device *arg)
{
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    5338:	4925      	ldr	r1, [pc, #148]	; (53d0 <arm_mpu_init+0x98>)
{
    533a:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    533c:	680c      	ldr	r4, [r1, #0]
    533e:	2c08      	cmp	r4, #8
    5340:	d913      	bls.n	536a <arm_mpu_init+0x32>
		 * what is supported by hardware. As this operation
		 * is executed during system (pre-kernel) initialization,
		 * we want to ensure we can detect an attempt to
		 * perform invalid configuration.
		 */
		__ASSERT(0,
    5342:	f240 1329 	movw	r3, #297	; 0x129
    5346:	4a23      	ldr	r2, [pc, #140]	; (53d4 <arm_mpu_init+0x9c>)
    5348:	4923      	ldr	r1, [pc, #140]	; (53d8 <arm_mpu_init+0xa0>)
    534a:	4824      	ldr	r0, [pc, #144]	; (53dc <arm_mpu_init+0xa4>)
    534c:	f01e fdc9 	bl	23ee2 <printk>
    5350:	4823      	ldr	r0, [pc, #140]	; (53e0 <arm_mpu_init+0xa8>)
    5352:	2208      	movs	r2, #8
    5354:	4621      	mov	r1, r4
    5356:	f01e fdc4 	bl	23ee2 <printk>
    535a:	481e      	ldr	r0, [pc, #120]	; (53d4 <arm_mpu_init+0x9c>)
    535c:	f240 1129 	movw	r1, #297	; 0x129
    5360:	f01e fe02 	bl	23f68 <assert_post_action>
			"Request to configure: %u regions (supported: %u)\n",
			mpu_config.num_regions,
			get_num_regions()
		);
		return -1;
    5364:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
}
    5368:	bd10      	pop	{r4, pc}
	arm_core_mpu_disable();
    536a:	f7ff ffdd 	bl	5328 <arm_core_mpu_disable>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    536e:	6848      	ldr	r0, [r1, #4]
    5370:	491c      	ldr	r1, [pc, #112]	; (53e4 <arm_mpu_init+0xac>)
    5372:	2200      	movs	r2, #0
    5374:	4294      	cmp	r4, r2
    5376:	f100 000c 	add.w	r0, r0, #12
    537a:	d119      	bne.n	53b0 <arm_mpu_init+0x78>
	static_regions_num = mpu_config.num_regions;
    537c:	4b1a      	ldr	r3, [pc, #104]	; (53e8 <arm_mpu_init+0xb0>)
    537e:	701c      	strb	r4, [r3, #0]
	arm_core_mpu_enable();
    5380:	f7ff ffc8 	bl	5314 <arm_core_mpu_enable>
	__ASSERT(
    5384:	680b      	ldr	r3, [r1, #0]
    5386:	f3c3 2307 	ubfx	r3, r3, #8, #8
    538a:	2b08      	cmp	r3, #8
    538c:	d00e      	beq.n	53ac <arm_mpu_init+0x74>
    538e:	4917      	ldr	r1, [pc, #92]	; (53ec <arm_mpu_init+0xb4>)
    5390:	4a10      	ldr	r2, [pc, #64]	; (53d4 <arm_mpu_init+0x9c>)
    5392:	4812      	ldr	r0, [pc, #72]	; (53dc <arm_mpu_init+0xa4>)
    5394:	f240 1347 	movw	r3, #327	; 0x147
    5398:	f01e fda3 	bl	23ee2 <printk>
    539c:	4814      	ldr	r0, [pc, #80]	; (53f0 <arm_mpu_init+0xb8>)
    539e:	f01e fda0 	bl	23ee2 <printk>
    53a2:	480c      	ldr	r0, [pc, #48]	; (53d4 <arm_mpu_init+0x9c>)
    53a4:	f240 1147 	movw	r1, #327	; 0x147
    53a8:	f01e fdde 	bl	23f68 <assert_post_action>
	return 0;
    53ac:	2000      	movs	r0, #0
    53ae:	e7db      	b.n	5368 <arm_mpu_init+0x30>
	MPU->RNR = index;
    53b0:	608a      	str	r2, [r1, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    53b2:	f850 3c0c 	ldr.w	r3, [r0, #-12]
    53b6:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    53ba:	4313      	orrs	r3, r2
    53bc:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    53c0:	60cb      	str	r3, [r1, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    53c2:	f850 3c04 	ldr.w	r3, [r0, #-4]
    53c6:	f043 0301 	orr.w	r3, r3, #1
    53ca:	610b      	str	r3, [r1, #16]
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    53cc:	3201      	adds	r2, #1
    53ce:	e7d1      	b.n	5374 <arm_mpu_init+0x3c>
    53d0:	00029cd0 	.word	0x00029cd0
    53d4:	0002b6db 	.word	0x0002b6db
    53d8:	0002e3c9 	.word	0x0002e3c9
    53dc:	0002a5e8 	.word	0x0002a5e8
    53e0:	0002b71b 	.word	0x0002b71b
    53e4:	e000ed90 	.word	0xe000ed90
    53e8:	20002356 	.word	0x20002356
    53ec:	0002b74f 	.word	0x0002b74f
    53f0:	0002b79f 	.word	0x0002b79f

000053f4 <arm_core_mpu_configure_static_mpu_regions>:
{
    53f4:	b538      	push	{r3, r4, r5, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    53f6:	4d0d      	ldr	r5, [pc, #52]	; (542c <arm_core_mpu_configure_static_mpu_regions+0x38>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    53f8:	2301      	movs	r3, #1
    53fa:	782a      	ldrb	r2, [r5, #0]
    53fc:	460c      	mov	r4, r1
    53fe:	f7ff ff27 	bl	5250 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    5402:	7028      	strb	r0, [r5, #0]
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
    5404:	3016      	adds	r0, #22
    5406:	d10f      	bne.n	5428 <arm_core_mpu_configure_static_mpu_regions+0x34>
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
    5408:	23f2      	movs	r3, #242	; 0xf2
    540a:	4a09      	ldr	r2, [pc, #36]	; (5430 <arm_core_mpu_configure_static_mpu_regions+0x3c>)
    540c:	4909      	ldr	r1, [pc, #36]	; (5434 <arm_core_mpu_configure_static_mpu_regions+0x40>)
    540e:	480a      	ldr	r0, [pc, #40]	; (5438 <arm_core_mpu_configure_static_mpu_regions+0x44>)
    5410:	f01e fd67 	bl	23ee2 <printk>
    5414:	4621      	mov	r1, r4
    5416:	4809      	ldr	r0, [pc, #36]	; (543c <arm_core_mpu_configure_static_mpu_regions+0x48>)
    5418:	f01e fd63 	bl	23ee2 <printk>
}
    541c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
    5420:	4803      	ldr	r0, [pc, #12]	; (5430 <arm_core_mpu_configure_static_mpu_regions+0x3c>)
    5422:	21f2      	movs	r1, #242	; 0xf2
    5424:	f01e bda0 	b.w	23f68 <assert_post_action>
}
    5428:	bd38      	pop	{r3, r4, r5, pc}
    542a:	bf00      	nop
    542c:	20002356 	.word	0x20002356
    5430:	0002b6db 	.word	0x0002b6db
    5434:	0002e3c9 	.word	0x0002e3c9
    5438:	0002a5e8 	.word	0x0002a5e8
    543c:	0002b7c0 	.word	0x0002b7c0

00005440 <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    5440:	b510      	push	{r4, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    5442:	4a12      	ldr	r2, [pc, #72]	; (548c <arm_core_mpu_configure_dynamic_mpu_regions+0x4c>)
    5444:	2300      	movs	r3, #0
    5446:	7812      	ldrb	r2, [r2, #0]
    5448:	460c      	mov	r4, r1
    544a:	f7ff ff01 	bl	5250 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    544e:	f110 0f16 	cmn.w	r0, #22
    5452:	d008      	beq.n	5466 <arm_core_mpu_configure_dynamic_mpu_regions+0x26>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    5454:	4b0e      	ldr	r3, [pc, #56]	; (5490 <arm_core_mpu_configure_dynamic_mpu_regions+0x50>)
  MPU->RASR = 0U;
    5456:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    5458:	2807      	cmp	r0, #7
    545a:	dd00      	ble.n	545e <arm_core_mpu_configure_dynamic_mpu_regions+0x1e>
}
    545c:	bd10      	pop	{r4, pc}
  MPU->RNR = rnr;
    545e:	6098      	str	r0, [r3, #8]
  MPU->RASR = 0U;
    5460:	611a      	str	r2, [r3, #16]
    5462:	3001      	adds	r0, #1
    5464:	e7f8      	b.n	5458 <arm_core_mpu_configure_dynamic_mpu_regions+0x18>
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
    5466:	4a0b      	ldr	r2, [pc, #44]	; (5494 <arm_core_mpu_configure_dynamic_mpu_regions+0x54>)
    5468:	490b      	ldr	r1, [pc, #44]	; (5498 <arm_core_mpu_configure_dynamic_mpu_regions+0x58>)
    546a:	480c      	ldr	r0, [pc, #48]	; (549c <arm_core_mpu_configure_dynamic_mpu_regions+0x5c>)
    546c:	f240 1311 	movw	r3, #273	; 0x111
    5470:	f01e fd37 	bl	23ee2 <printk>
    5474:	4621      	mov	r1, r4
    5476:	480a      	ldr	r0, [pc, #40]	; (54a0 <arm_core_mpu_configure_dynamic_mpu_regions+0x60>)
    5478:	f01e fd33 	bl	23ee2 <printk>
}
    547c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
    5480:	4804      	ldr	r0, [pc, #16]	; (5494 <arm_core_mpu_configure_dynamic_mpu_regions+0x54>)
    5482:	f240 1111 	movw	r1, #273	; 0x111
    5486:	f01e bd6f 	b.w	23f68 <assert_post_action>
    548a:	bf00      	nop
    548c:	20002356 	.word	0x20002356
    5490:	e000ed90 	.word	0xe000ed90
    5494:	0002b6db 	.word	0x0002b6db
    5498:	0002e3c9 	.word	0x0002e3c9
    549c:	0002a5e8 	.word	0x0002a5e8
    54a0:	0002b7ec 	.word	0x0002b7ec

000054a4 <z_prf>:
	*sptr = p;
	return i;
}

int z_prf(int (*func)(), void *dest, const char *format, va_list vargs)
{
    54a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    54a8:	b0a1      	sub	sp, #132	; 0x84
    54aa:	461e      	mov	r6, r3
	struct zero_padding zero;
	VALTYPE val;

#define PUTC(c)	do { if ((*func)(c, dest) == EOF) return EOF; } while (false)

	count = 0;
    54ac:	2300      	movs	r3, #0
{
    54ae:	9003      	str	r0, [sp, #12]
    54b0:	4689      	mov	r9, r1
	count = 0;
    54b2:	9302      	str	r3, [sp, #8]

	while ((c = *format++)) {
    54b4:	4613      	mov	r3, r2
    54b6:	f813 0b01 	ldrb.w	r0, [r3], #1
    54ba:	9306      	str	r3, [sp, #24]
    54bc:	b158      	cbz	r0, 54d6 <z_prf+0x32>
		if (c != '%') {
    54be:	2825      	cmp	r0, #37	; 0x25
    54c0:	f000 8081 	beq.w	55c6 <z_prf+0x122>
			PUTC(c);
    54c4:	4649      	mov	r1, r9
    54c6:	9b03      	ldr	r3, [sp, #12]
    54c8:	4798      	blx	r3
    54ca:	3001      	adds	r0, #1
    54cc:	f040 844a 	bne.w	5d64 <z_prf+0x8c0>
    54d0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    54d4:	9302      	str	r3, [sp, #8]
		}
	}
	return count;

#undef PUTC
}
    54d6:	9802      	ldr	r0, [sp, #8]
    54d8:	b021      	add	sp, #132	; 0x84
    54da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				switch (c) {
    54de:	2d2b      	cmp	r5, #43	; 0x2b
    54e0:	d065      	beq.n	55ae <z_prf+0x10a>
    54e2:	d85c      	bhi.n	559e <z_prf+0xfa>
    54e4:	2d20      	cmp	r5, #32
    54e6:	d065      	beq.n	55b4 <z_prf+0x110>
    54e8:	2d23      	cmp	r5, #35	; 0x23
    54ea:	d066      	beq.n	55ba <z_prf+0x116>
    54ec:	2d00      	cmp	r5, #0
    54ee:	d0f2      	beq.n	54d6 <z_prf+0x32>
					fzero = true;
    54f0:	f8cd 8018 	str.w	r8, [sp, #24]
			while (strchr("-+ #0", (c = *format++)) != NULL) {
    54f4:	f8dd 8018 	ldr.w	r8, [sp, #24]
    54f8:	48a4      	ldr	r0, [pc, #656]	; (578c <z_prf+0x2e8>)
    54fa:	f818 5b01 	ldrb.w	r5, [r8], #1
    54fe:	4629      	mov	r1, r5
    5500:	f020 fb92 	bl	25c28 <strchr>
    5504:	2800      	cmp	r0, #0
    5506:	d1ea      	bne.n	54de <z_prf+0x3a>
			if (c == '*') {
    5508:	2d2a      	cmp	r5, #42	; 0x2a
    550a:	d163      	bne.n	55d4 <z_prf+0x130>
				width = va_arg(vargs, int);
    550c:	f856 3b04 	ldr.w	r3, [r6], #4
    5510:	9307      	str	r3, [sp, #28]
				if (width < 0) {
    5512:	2b00      	cmp	r3, #0
					width = -width;
    5514:	bfbf      	itttt	lt
    5516:	425b      	neglt	r3, r3
    5518:	9307      	strlt	r3, [sp, #28]
					fminus = true;
    551a:	2301      	movlt	r3, #1
    551c:	930d      	strlt	r3, [sp, #52]	; 0x34
				c = *format++;
    551e:	9b06      	ldr	r3, [sp, #24]
    5520:	f898 5000 	ldrb.w	r5, [r8]
    5524:	f103 0802 	add.w	r8, r3, #2
			if (c == '.') {
    5528:	2d2e      	cmp	r5, #46	; 0x2e
    552a:	d178      	bne.n	561e <z_prf+0x17a>
				if (c == '*') {
    552c:	f898 3000 	ldrb.w	r3, [r8]
    5530:	2b2a      	cmp	r3, #42	; 0x2a
    5532:	d171      	bne.n	5618 <z_prf+0x174>
					precision = va_arg(vargs, int);
    5534:	f856 4b04 	ldr.w	r4, [r6], #4
				c = *format++;
    5538:	f108 0801 	add.w	r8, r8, #1
				c = *format++;
    553c:	f818 5b01 	ldrb.w	r5, [r8], #1
			if (strchr("hlz", c) != NULL) {
    5540:	4893      	ldr	r0, [pc, #588]	; (5790 <z_prf+0x2ec>)
    5542:	4629      	mov	r1, r5
    5544:	462f      	mov	r7, r5
    5546:	f020 fb6f 	bl	25c28 <strchr>
    554a:	2800      	cmp	r0, #0
    554c:	d06a      	beq.n	5624 <z_prf+0x180>
				c = *format++;
    554e:	4643      	mov	r3, r8
				} else if (i == 'h' && c == 'h') {
    5550:	2f68      	cmp	r7, #104	; 0x68
				c = *format++;
    5552:	f813 5b01 	ldrb.w	r5, [r3], #1
    5556:	9306      	str	r3, [sp, #24]
				} else if (i == 'h' && c == 'h') {
    5558:	d107      	bne.n	556a <z_prf+0xc6>
    555a:	2d68      	cmp	r5, #104	; 0x68
    555c:	d105      	bne.n	556a <z_prf+0xc6>
					c = *format++;
    555e:	f108 0302 	add.w	r3, r8, #2
    5562:	f898 5001 	ldrb.w	r5, [r8, #1]
    5566:	9306      	str	r3, [sp, #24]
					i = 'H';
    5568:	2748      	movs	r7, #72	; 0x48
			switch (c) {
    556a:	2d78      	cmp	r5, #120	; 0x78
    556c:	d808      	bhi.n	5580 <z_prf+0xdc>
    556e:	2d57      	cmp	r5, #87	; 0x57
    5570:	d85c      	bhi.n	562c <z_prf+0x188>
    5572:	2d25      	cmp	r5, #37	; 0x25
    5574:	f000 83f2 	beq.w	5d5c <z_prf+0x8b8>
    5578:	f200 80a2 	bhi.w	56c0 <z_prf+0x21c>
    557c:	2d00      	cmp	r5, #0
    557e:	d0aa      	beq.n	54d6 <z_prf+0x32>
				PUTC('%');
    5580:	9b03      	ldr	r3, [sp, #12]
    5582:	4649      	mov	r1, r9
    5584:	2025      	movs	r0, #37	; 0x25
    5586:	4798      	blx	r3
    5588:	3001      	adds	r0, #1
    558a:	d0a1      	beq.n	54d0 <z_prf+0x2c>
				PUTC(c);
    558c:	9b03      	ldr	r3, [sp, #12]
    558e:	4649      	mov	r1, r9
    5590:	4628      	mov	r0, r5
    5592:	4798      	blx	r3
    5594:	3001      	adds	r0, #1
    5596:	d09b      	beq.n	54d0 <z_prf+0x2c>
				count += 2;
    5598:	9b02      	ldr	r3, [sp, #8]
    559a:	3302      	adds	r3, #2
    559c:	e3e4      	b.n	5d68 <z_prf+0x8c4>
				switch (c) {
    559e:	2d2d      	cmp	r5, #45	; 0x2d
    55a0:	d00e      	beq.n	55c0 <z_prf+0x11c>
					fzero = true;
    55a2:	2d30      	cmp	r5, #48	; 0x30
    55a4:	9b08      	ldr	r3, [sp, #32]
    55a6:	bf08      	it	eq
    55a8:	2301      	moveq	r3, #1
    55aa:	9308      	str	r3, [sp, #32]
    55ac:	e7a0      	b.n	54f0 <z_prf+0x4c>
					fplus = true;
    55ae:	2301      	movs	r3, #1
    55b0:	9309      	str	r3, [sp, #36]	; 0x24
    55b2:	e79d      	b.n	54f0 <z_prf+0x4c>
					fspace = true;
    55b4:	2301      	movs	r3, #1
    55b6:	930c      	str	r3, [sp, #48]	; 0x30
    55b8:	e79a      	b.n	54f0 <z_prf+0x4c>
					falt = true;
    55ba:	f04f 0a01 	mov.w	sl, #1
    55be:	e797      	b.n	54f0 <z_prf+0x4c>
				switch (c) {
    55c0:	2301      	movs	r3, #1
    55c2:	930d      	str	r3, [sp, #52]	; 0x34
    55c4:	e794      	b.n	54f0 <z_prf+0x4c>
			fminus = fplus = fspace = falt = fzero = false;
    55c6:	2300      	movs	r3, #0
    55c8:	9308      	str	r3, [sp, #32]
    55ca:	930c      	str	r3, [sp, #48]	; 0x30
    55cc:	9309      	str	r3, [sp, #36]	; 0x24
    55ce:	930d      	str	r3, [sp, #52]	; 0x34
    55d0:	469a      	mov	sl, r3
    55d2:	e78f      	b.n	54f4 <z_prf+0x50>
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    55d4:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
			} else if (!isdigit(c)) {
    55d8:	2b09      	cmp	r3, #9
				width = 0;
    55da:	9007      	str	r0, [sp, #28]
			} else if (!isdigit(c)) {
    55dc:	d8a4      	bhi.n	5528 <z_prf+0x84>
		i = 10 * i + *p++ - '0';
    55de:	220a      	movs	r2, #10
	while (isdigit(*p)) {
    55e0:	f8dd 8018 	ldr.w	r8, [sp, #24]
    55e4:	f818 5b01 	ldrb.w	r5, [r8], #1
    55e8:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
    55ec:	2b09      	cmp	r3, #9
    55ee:	d89b      	bhi.n	5528 <z_prf+0x84>
		i = 10 * i + *p++ - '0';
    55f0:	9b07      	ldr	r3, [sp, #28]
    55f2:	fb02 5503 	mla	r5, r2, r3, r5
    55f6:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
    55fa:	e9cd 8306 	strd	r8, r3, [sp, #24]
    55fe:	e7ef      	b.n	55e0 <z_prf+0x13c>
    5600:	fb01 3404 	mla	r4, r1, r4, r3
    5604:	3c30      	subs	r4, #48	; 0x30
    5606:	4690      	mov	r8, r2
	while (isdigit(*p)) {
    5608:	4642      	mov	r2, r8
    560a:	f812 3b01 	ldrb.w	r3, [r2], #1
    560e:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    5612:	2809      	cmp	r0, #9
    5614:	d9f4      	bls.n	5600 <z_prf+0x15c>
    5616:	e791      	b.n	553c <z_prf+0x98>
	int i = 0;
    5618:	2400      	movs	r4, #0
		i = 10 * i + *p++ - '0';
    561a:	210a      	movs	r1, #10
    561c:	e7f4      	b.n	5608 <z_prf+0x164>
			precision = -1;
    561e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    5622:	e78d      	b.n	5540 <z_prf+0x9c>
    5624:	f8cd 8018 	str.w	r8, [sp, #24]
			i = 0;
    5628:	4607      	mov	r7, r0
    562a:	e79e      	b.n	556a <z_prf+0xc6>
    562c:	f1a5 0358 	sub.w	r3, r5, #88	; 0x58
    5630:	2b20      	cmp	r3, #32
    5632:	d8a5      	bhi.n	5580 <z_prf+0xdc>
    5634:	a201      	add	r2, pc, #4	; (adr r2, 563c <z_prf+0x198>)
    5636:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    563a:	bf00      	nop
    563c:	00005cc1 	.word	0x00005cc1
    5640:	00005581 	.word	0x00005581
    5644:	00005581 	.word	0x00005581
    5648:	00005581 	.word	0x00005581
    564c:	00005581 	.word	0x00005581
    5650:	00005581 	.word	0x00005581
    5654:	00005581 	.word	0x00005581
    5658:	00005581 	.word	0x00005581
    565c:	00005581 	.word	0x00005581
    5660:	00005581 	.word	0x00005581
    5664:	00005581 	.word	0x00005581
    5668:	00005795 	.word	0x00005795
    566c:	0000586b 	.word	0x0000586b
    5670:	000056cd 	.word	0x000056cd
    5674:	000056cd 	.word	0x000056cd
    5678:	000056cd 	.word	0x000056cd
    567c:	00005581 	.word	0x00005581
    5680:	0000586b 	.word	0x0000586b
    5684:	00005581 	.word	0x00005581
    5688:	00005581 	.word	0x00005581
    568c:	00005581 	.word	0x00005581
    5690:	00005581 	.word	0x00005581
    5694:	00005c4d 	.word	0x00005c4d
    5698:	00005cc1 	.word	0x00005cc1
    569c:	00005c77 	.word	0x00005c77
    56a0:	00005581 	.word	0x00005581
    56a4:	00005581 	.word	0x00005581
    56a8:	00005c99 	.word	0x00005c99
    56ac:	00005581 	.word	0x00005581
    56b0:	00005cc1 	.word	0x00005cc1
    56b4:	00005581 	.word	0x00005581
    56b8:	00005581 	.word	0x00005581
    56bc:	00005cc1 	.word	0x00005cc1
			switch (c) {
    56c0:	f1a5 0345 	sub.w	r3, r5, #69	; 0x45
    56c4:	b2db      	uxtb	r3, r3
    56c6:	2b02      	cmp	r3, #2
    56c8:	f63f af5a 	bhi.w	5580 <z_prf+0xdc>
				u.d = va_arg(vargs, double);
    56cc:	3607      	adds	r6, #7
    56ce:	f026 0307 	bic.w	r3, r6, #7
    56d2:	4619      	mov	r1, r3
    56d4:	e8f1 2302 	ldrd	r2, r3, [r1], #8
	fract = (double_temp << 11) & ~HIGHBIT64;
    56d8:	02d8      	lsls	r0, r3, #11
    56da:	ea40 5052 	orr.w	r0, r0, r2, lsr #21
    56de:	02d6      	lsls	r6, r2, #11
    56e0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
    56e4:	9604      	str	r6, [sp, #16]
    56e6:	9005      	str	r0, [sp, #20]
    56e8:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
	if (sign) {
    56ec:	2a00      	cmp	r2, #0
				u.d = va_arg(vargs, double);
    56ee:	9101      	str	r1, [sp, #4]
	exp = double_temp >> 52 & 0x7ff;
    56f0:	f3c3 510a 	ubfx	r1, r3, #20, #11
	if (sign) {
    56f4:	f173 0300 	sbcs.w	r3, r3, #0
	fract = (double_temp << 11) & ~HIGHBIT64;
    56f8:	e9cd 6714 	strd	r6, r7, [sp, #80]	; 0x50
	if (sign) {
    56fc:	f280 80e5 	bge.w	58ca <z_prf+0x426>
		*buf++ = '-';
    5700:	232d      	movs	r3, #45	; 0x2d
		*buf++ = ' ';
    5702:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
    5706:	f10d 0765 	add.w	r7, sp, #101	; 0x65
	if (exp == 0x7ff) {
    570a:	f240 73ff 	movw	r3, #2047	; 0x7ff
    570e:	4299      	cmp	r1, r3
    5710:	f040 80f6 	bne.w	5900 <z_prf+0x45c>
		if (!fract) {
    5714:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
    5718:	430a      	orrs	r2, r1
    571a:	f1a5 0541 	sub.w	r5, r5, #65	; 0x41
    571e:	f107 0303 	add.w	r3, r7, #3
    5722:	f040 80e2 	bne.w	58ea <z_prf+0x446>
			if (isupper(c)) {
    5726:	2d19      	cmp	r5, #25
    5728:	f200 80d9 	bhi.w	58de <z_prf+0x43a>
				*buf++ = 'I';
    572c:	2249      	movs	r2, #73	; 0x49
    572e:	703a      	strb	r2, [r7, #0]
				*buf++ = 'N';
    5730:	224e      	movs	r2, #78	; 0x4e
    5732:	707a      	strb	r2, [r7, #1]
				*buf++ = 'F';
    5734:	2246      	movs	r2, #70	; 0x46
		*buf = 0;
    5736:	2400      	movs	r4, #0
		return buf - start;
    5738:	ae19      	add	r6, sp, #100	; 0x64
				*buf++ = 'n';
    573a:	70ba      	strb	r2, [r7, #2]
		*buf = 0;
    573c:	70fc      	strb	r4, [r7, #3]
		return buf - start;
    573e:	1b9b      	subs	r3, r3, r6
			zero.predot = zero.postdot = zero.trail = 0;
    5740:	46a2      	mov	sl, r4
    5742:	46a3      	mov	fp, r4
				if (fplus || fspace || (buf[0] == '-')) {
    5744:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5746:	2a00      	cmp	r2, #0
    5748:	f040 827d 	bne.w	5c46 <z_prf+0x7a2>
    574c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    574e:	2a00      	cmp	r2, #0
    5750:	f040 8279 	bne.w	5c46 <z_prf+0x7a2>
    5754:	f89d 8064 	ldrb.w	r8, [sp, #100]	; 0x64
    5758:	f1a8 022d 	sub.w	r2, r8, #45	; 0x2d
    575c:	f1d2 0800 	rsbs	r8, r2, #0
    5760:	eb48 0802 	adc.w	r8, r8, r2
				clen += zero.predot + zero.postdot + zero.trail;
    5764:	eb0b 060a 	add.w	r6, fp, sl
    5768:	4433      	add	r3, r6
    576a:	191e      	adds	r6, r3, r4
				if (!isdigit(buf[prefix])) {
    576c:	ab20      	add	r3, sp, #128	; 0x80
    576e:	4443      	add	r3, r8
    5770:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
    5774:	3b30      	subs	r3, #48	; 0x30
    5776:	2b09      	cmp	r3, #9
    5778:	f200 82fe 	bhi.w	5d78 <z_prf+0x8d4>
			} else if (fzero) {
    577c:	9b08      	ldr	r3, [sp, #32]
    577e:	2b00      	cmp	r3, #0
    5780:	f000 82fd 	beq.w	5d7e <z_prf+0x8da>
    5784:	9b07      	ldr	r3, [sp, #28]
    5786:	af19      	add	r7, sp, #100	; 0x64
    5788:	1b9b      	subs	r3, r3, r6
    578a:	e014      	b.n	57b6 <z_prf+0x312>
    578c:	0002b819 	.word	0x0002b819
    5790:	0002b81f 	.word	0x0002b81f
				buf[0] = va_arg(vargs, int);
    5794:	4632      	mov	r2, r6
				break;
    5796:	f04f 0800 	mov.w	r8, #0
				buf[0] = va_arg(vargs, int);
    579a:	f852 3b04 	ldr.w	r3, [r2], #4
    579e:	9201      	str	r2, [sp, #4]
    57a0:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
				clen = 1;
    57a4:	2601      	movs	r6, #1
				break;
    57a6:	4644      	mov	r4, r8
    57a8:	af19      	add	r7, sp, #100	; 0x64
				zero_head = precision - clen + prefix;
    57aa:	eb04 0308 	add.w	r3, r4, r8
			zero.predot = zero.postdot = zero.trail = 0;
    57ae:	2400      	movs	r4, #0
				zero_head = precision - clen + prefix;
    57b0:	1b9b      	subs	r3, r3, r6
			zero.predot = zero.postdot = zero.trail = 0;
    57b2:	46a2      	mov	sl, r4
    57b4:	46a3      	mov	fp, r4
			if (zero_head < 0) {
    57b6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
			width -= clen + zero_head;
    57ba:	199a      	adds	r2, r3, r6
    57bc:	9208      	str	r2, [sp, #32]
    57be:	9a07      	ldr	r2, [sp, #28]
    57c0:	1999      	adds	r1, r3, r6
    57c2:	1a55      	subs	r5, r2, r1
			if (!fminus && width > 0) {
    57c4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    57c6:	b912      	cbnz	r2, 57ce <z_prf+0x32a>
    57c8:	2d00      	cmp	r5, #0
    57ca:	f300 82ed 	bgt.w	5da8 <z_prf+0x904>
			while (prefix-- > 0) {
    57ce:	eb07 0208 	add.w	r2, r7, r8
    57d2:	42ba      	cmp	r2, r7
    57d4:	f040 82ea 	bne.w	5dac <z_prf+0x908>
			while (zero_head-- > 0) {
    57d8:	3b01      	subs	r3, #1
    57da:	f080 82f5 	bcs.w	5dc8 <z_prf+0x924>
			clen -= prefix;
    57de:	eba6 0608 	sub.w	r6, r6, r8
			if (zero.predot) {
    57e2:	f1bb 0f00 	cmp.w	fp, #0
    57e6:	d010      	beq.n	580a <z_prf+0x366>
				c = *cptr;
    57e8:	7838      	ldrb	r0, [r7, #0]
				while (isdigit(c)) {
    57ea:	eb07 0806 	add.w	r8, r7, r6
    57ee:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    57f2:	2b09      	cmp	r3, #9
    57f4:	eba8 0607 	sub.w	r6, r8, r7
    57f8:	f240 82f1 	bls.w	5dde <z_prf+0x93a>
    57fc:	46d8      	mov	r8, fp
				while (zero.predot-- > 0) {
    57fe:	f1b8 0801 	subs.w	r8, r8, #1
    5802:	f080 82f5 	bcs.w	5df0 <z_prf+0x94c>
				clen -= zero.predot;
    5806:	eba6 060b 	sub.w	r6, r6, fp
			if (zero.postdot) {
    580a:	f1ba 0f00 	cmp.w	sl, #0
    580e:	d016      	beq.n	583e <z_prf+0x39a>
    5810:	eb07 0806 	add.w	r8, r7, r6
					c = *cptr++;
    5814:	f817 bb01 	ldrb.w	fp, [r7], #1
					PUTC(c);
    5818:	9b03      	ldr	r3, [sp, #12]
    581a:	4649      	mov	r1, r9
    581c:	4658      	mov	r0, fp
    581e:	4798      	blx	r3
    5820:	3001      	adds	r0, #1
    5822:	f43f ae55 	beq.w	54d0 <z_prf+0x2c>
				} while (c != '.');
    5826:	f1bb 0f2e 	cmp.w	fp, #46	; 0x2e
    582a:	eba8 0607 	sub.w	r6, r8, r7
    582e:	d1f1      	bne.n	5814 <z_prf+0x370>
				while (zero.postdot-- > 0) {
    5830:	46d0      	mov	r8, sl
    5832:	f1b8 0f00 	cmp.w	r8, #0
    5836:	f300 82e4 	bgt.w	5e02 <z_prf+0x95e>
				clen -= zero.postdot;
    583a:	eba6 060a 	sub.w	r6, r6, sl
			if (zero.trail) {
    583e:	b194      	cbz	r4, 5866 <z_prf+0x3c2>
				c = *cptr;
    5840:	7838      	ldrb	r0, [r7, #0]
				while (isdigit(c) || c == '.') {
    5842:	eb07 0806 	add.w	r8, r7, r6
    5846:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    584a:	2b09      	cmp	r3, #9
    584c:	eba8 0607 	sub.w	r6, r8, r7
    5850:	f240 82e2 	bls.w	5e18 <z_prf+0x974>
    5854:	282e      	cmp	r0, #46	; 0x2e
    5856:	f000 82df 	beq.w	5e18 <z_prf+0x974>
				while (zero.trail-- > 0) {
    585a:	46a0      	mov	r8, r4
    585c:	f1b8 0f00 	cmp.w	r8, #0
    5860:	f300 82e3 	bgt.w	5e2a <z_prf+0x986>
				clen -= zero.trail;
    5864:	1b36      	subs	r6, r6, r4
    5866:	443e      	add	r6, r7
    5868:	e2f2      	b.n	5e50 <z_prf+0x9ac>
				switch (i) {
    586a:	6835      	ldr	r5, [r6, #0]
	if (value < 0) {
    586c:	1d33      	adds	r3, r6, #4
    586e:	2d00      	cmp	r5, #0
    5870:	9301      	str	r3, [sp, #4]
    5872:	da1c      	bge.n	58ae <z_prf+0x40a>
		*buf++ = '-';
    5874:	232d      	movs	r3, #45	; 0x2d
    5876:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
		value = -value;
    587a:	4269      	negs	r1, r5
		*buf++ = ' ';
    587c:	f10d 0665 	add.w	r6, sp, #101	; 0x65
	return _to_x(buf, value, 10);
    5880:	4630      	mov	r0, r6
    5882:	220a      	movs	r2, #10
    5884:	f020 fa5e 	bl	25d44 <_to_x>
				if (fplus || fspace || val < 0) {
    5888:	9b09      	ldr	r3, [sp, #36]	; 0x24
	return (buf + _to_udec(buf, value)) - start;
    588a:	4406      	add	r6, r0
    588c:	a819      	add	r0, sp, #100	; 0x64
    588e:	1a36      	subs	r6, r6, r0
				if (fplus || fspace || val < 0) {
    5890:	2b00      	cmp	r3, #0
    5892:	f040 826c 	bne.w	5d6e <z_prf+0x8ca>
    5896:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5898:	2b00      	cmp	r3, #0
    589a:	f040 8268 	bne.w	5d6e <z_prf+0x8ca>
    589e:	ea4f 78d5 	mov.w	r8, r5, lsr #31
			if (precision >= 0) {
    58a2:	2c00      	cmp	r4, #0
    58a4:	da80      	bge.n	57a8 <z_prf+0x304>
			zero.predot = zero.postdot = zero.trail = 0;
    58a6:	2400      	movs	r4, #0
    58a8:	46a2      	mov	sl, r4
    58aa:	46a3      	mov	fp, r4
    58ac:	e766      	b.n	577c <z_prf+0x2d8>
	} else if (fplus) {
    58ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
    58b0:	b123      	cbz	r3, 58bc <z_prf+0x418>
		*buf++ = '+';
    58b2:	232b      	movs	r3, #43	; 0x2b
		*buf++ = ' ';
    58b4:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
    58b8:	4629      	mov	r1, r5
    58ba:	e7df      	b.n	587c <z_prf+0x3d8>
	} else if (fspace) {
    58bc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    58be:	b10b      	cbz	r3, 58c4 <z_prf+0x420>
		*buf++ = ' ';
    58c0:	2320      	movs	r3, #32
    58c2:	e7f7      	b.n	58b4 <z_prf+0x410>
    58c4:	4629      	mov	r1, r5
    58c6:	ae19      	add	r6, sp, #100	; 0x64
    58c8:	e7da      	b.n	5880 <z_prf+0x3dc>
	} else if (fplus) {
    58ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
    58cc:	b10b      	cbz	r3, 58d2 <z_prf+0x42e>
		*buf++ = '+';
    58ce:	232b      	movs	r3, #43	; 0x2b
    58d0:	e717      	b.n	5702 <z_prf+0x25e>
	} else if (fspace) {
    58d2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    58d4:	b10b      	cbz	r3, 58da <z_prf+0x436>
		*buf++ = ' ';
    58d6:	2320      	movs	r3, #32
    58d8:	e713      	b.n	5702 <z_prf+0x25e>
    58da:	af19      	add	r7, sp, #100	; 0x64
    58dc:	e715      	b.n	570a <z_prf+0x266>
				*buf++ = 'i';
    58de:	2269      	movs	r2, #105	; 0x69
    58e0:	703a      	strb	r2, [r7, #0]
				*buf++ = 'n';
    58e2:	226e      	movs	r2, #110	; 0x6e
    58e4:	707a      	strb	r2, [r7, #1]
				*buf++ = 'f';
    58e6:	2266      	movs	r2, #102	; 0x66
    58e8:	e725      	b.n	5736 <z_prf+0x292>
			if (isupper(c)) {
    58ea:	2d19      	cmp	r5, #25
				*buf++ = 'N';
    58ec:	bf99      	ittee	ls
    58ee:	224e      	movls	r2, #78	; 0x4e
				*buf++ = 'A';
    58f0:	2141      	movls	r1, #65	; 0x41
				*buf++ = 'n';
    58f2:	226e      	movhi	r2, #110	; 0x6e
				*buf++ = 'a';
    58f4:	2161      	movhi	r1, #97	; 0x61
				*buf++ = 'N';
    58f6:	bf94      	ite	ls
    58f8:	703a      	strbls	r2, [r7, #0]
				*buf++ = 'n';
    58fa:	703a      	strbhi	r2, [r7, #0]
				*buf++ = 'a';
    58fc:	7079      	strb	r1, [r7, #1]
    58fe:	e71a      	b.n	5736 <z_prf+0x292>
	if ((exp | fract) != 0) {
    5900:	9b04      	ldr	r3, [sp, #16]
    5902:	9805      	ldr	r0, [sp, #20]
    5904:	430b      	orrs	r3, r1
    5906:	930e      	str	r3, [sp, #56]	; 0x38
    5908:	17cb      	asrs	r3, r1, #31
    590a:	4303      	orrs	r3, r0
    590c:	930f      	str	r3, [sp, #60]	; 0x3c
    590e:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
		c = 'f';
    5912:	2d46      	cmp	r5, #70	; 0x46
    5914:	bf08      	it	eq
    5916:	2566      	moveq	r5, #102	; 0x66
	if ((exp | fract) != 0) {
    5918:	4313      	orrs	r3, r2
    591a:	f000 8107 	beq.w	5b2c <z_prf+0x688>
		if (exp == 0) {
    591e:	2900      	cmp	r1, #0
    5920:	f000 809f 	beq.w	5a62 <z_prf+0x5be>
		fract |= HIGHBIT64;
    5924:	9b15      	ldr	r3, [sp, #84]	; 0x54
    5926:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
    592a:	f2a1 38fe 	subw	r8, r1, #1022	; 0x3fe
		fract |= HIGHBIT64;
    592e:	9315      	str	r3, [sp, #84]	; 0x54
    5930:	2600      	movs	r6, #0
	while (exp <= -3) {
    5932:	f118 0f02 	cmn.w	r8, #2
    5936:	f2c0 80a8 	blt.w	5a8a <z_prf+0x5e6>
	while (exp > 0) {
    593a:	f1b8 0f00 	cmp.w	r8, #0
    593e:	f300 80d4 	bgt.w	5aea <z_prf+0x646>
		_rlrshift(&fract);
    5942:	a814      	add	r0, sp, #80	; 0x50
		exp++;
    5944:	f108 0801 	add.w	r8, r8, #1
		_rlrshift(&fract);
    5948:	f020 fa20 	bl	25d8c <_rlrshift>
	while (exp < (0 + 4)) {
    594c:	f1b8 0f04 	cmp.w	r8, #4
    5950:	d1f7      	bne.n	5942 <z_prf+0x49e>
		precision = 6;		/* Default precision if none given */
    5952:	2c00      	cmp	r4, #0
	if ((c == 'g') || (c == 'G')) {
    5954:	f005 03df 	and.w	r3, r5, #223	; 0xdf
		precision = 6;		/* Default precision if none given */
    5958:	bfb8      	it	lt
    595a:	2406      	movlt	r4, #6
	if ((c == 'g') || (c == 'G')) {
    595c:	2b47      	cmp	r3, #71	; 0x47
    595e:	f040 80ee 	bne.w	5b3e <z_prf+0x69a>
		if (decexp < (-4 + 1) || decexp > precision) {
    5962:	1cf1      	adds	r1, r6, #3
    5964:	db02      	blt.n	596c <z_prf+0x4c8>
    5966:	42b4      	cmp	r4, r6
    5968:	f280 80e3 	bge.w	5b32 <z_prf+0x68e>
			c += 'e' - 'g';
    596c:	3d02      	subs	r5, #2
    596e:	b2ed      	uxtb	r5, r5
			if (precision > 0) {
    5970:	2c00      	cmp	r4, #0
    5972:	f000 80ea 	beq.w	5b4a <z_prf+0x6a6>
				precision--;
    5976:	3c01      	subs	r4, #1
		if (!falt && (precision > 0)) {
    5978:	f1ba 0f00 	cmp.w	sl, #0
    597c:	f040 80e5 	bne.w	5b4a <z_prf+0x6a6>
    5980:	2c00      	cmp	r4, #0
    5982:	bfd4      	ite	le
    5984:	f04f 0800 	movle.w	r8, #0
    5988:	f04f 0801 	movgt.w	r8, #1
	if (c == 'f') {
    598c:	2d66      	cmp	r5, #102	; 0x66
    598e:	f040 80de 	bne.w	5b4e <z_prf+0x6aa>
		if (exp < 0) {
    5992:	eb14 0b06 	adds.w	fp, r4, r6
    5996:	f04f 0566 	mov.w	r5, #102	; 0x66
    599a:	f100 80db 	bmi.w	5b54 <z_prf+0x6b0>
	if (exp > 16) {
    599e:	f1bb 0f10 	cmp.w	fp, #16
    59a2:	bfa8      	it	ge
    59a4:	f04f 0b10 	movge.w	fp, #16
    59a8:	2310      	movs	r3, #16
    59aa:	9313      	str	r3, [sp, #76]	; 0x4c
	ltemp = 0x0800000000000000;
    59ac:	2200      	movs	r2, #0
    59ae:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    59b2:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
	while (exp--) {
    59b6:	f1bb 0b01 	subs.w	fp, fp, #1
    59ba:	f080 80ce 	bcs.w	5b5a <z_prf+0x6b6>
	fract += ltemp;
    59be:	9b14      	ldr	r3, [sp, #80]	; 0x50
    59c0:	9a16      	ldr	r2, [sp, #88]	; 0x58
    59c2:	9917      	ldr	r1, [sp, #92]	; 0x5c
    59c4:	189b      	adds	r3, r3, r2
    59c6:	9a15      	ldr	r2, [sp, #84]	; 0x54
    59c8:	eb41 0202 	adc.w	r2, r1, r2
    59cc:	e9cd 3214 	strd	r3, r2, [sp, #80]	; 0x50
	if ((fract >> 32) & 0xF0000000) {
    59d0:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    59d4:	9310      	str	r3, [sp, #64]	; 0x40
    59d6:	2300      	movs	r3, #0
    59d8:	9311      	str	r3, [sp, #68]	; 0x44
    59da:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
    59de:	4313      	orrs	r3, r2
    59e0:	d006      	beq.n	59f0 <z_prf+0x54c>
		_ldiv5(&fract);
    59e2:	a814      	add	r0, sp, #80	; 0x50
    59e4:	f020 f9e4 	bl	25db0 <_ldiv5>
		_rlrshift(&fract);
    59e8:	a814      	add	r0, sp, #80	; 0x50
    59ea:	f020 f9cf 	bl	25d8c <_rlrshift>
		decexp++;
    59ee:	3601      	adds	r6, #1
	if (c == 'f') {
    59f0:	2d66      	cmp	r5, #102	; 0x66
    59f2:	f040 80cf 	bne.w	5b94 <z_prf+0x6f0>
		if (decexp > 0) {
    59f6:	2e00      	cmp	r6, #0
    59f8:	f340 80b6 	ble.w	5b68 <z_prf+0x6c4>
			while (decexp > 0 && digit_count > 0) {
    59fc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    59fe:	2b00      	cmp	r3, #0
    5a00:	dd07      	ble.n	5a12 <z_prf+0x56e>
				*buf++ = _get_digit(&fract, &digit_count);
    5a02:	a913      	add	r1, sp, #76	; 0x4c
    5a04:	a814      	add	r0, sp, #80	; 0x50
    5a06:	f020 f9fc 	bl	25e02 <_get_digit>
			while (decexp > 0 && digit_count > 0) {
    5a0a:	3e01      	subs	r6, #1
				*buf++ = _get_digit(&fract, &digit_count);
    5a0c:	f807 0b01 	strb.w	r0, [r7], #1
			while (decexp > 0 && digit_count > 0) {
    5a10:	d1f4      	bne.n	59fc <z_prf+0x558>
			zp->predot = decexp;
    5a12:	46b3      	mov	fp, r6
    5a14:	463b      	mov	r3, r7
			decexp = 0;
    5a16:	2600      	movs	r6, #0
		if (falt || (precision > 0)) {
    5a18:	f1ba 0f00 	cmp.w	sl, #0
    5a1c:	d101      	bne.n	5a22 <z_prf+0x57e>
    5a1e:	2c00      	cmp	r4, #0
    5a20:	dd15      	ble.n	5a4e <z_prf+0x5aa>
			*buf++ = '.';
    5a22:	222e      	movs	r2, #46	; 0x2e
    5a24:	f803 2b01 	strb.w	r2, [r3], #1
		if (decexp < 0 && precision > 0) {
    5a28:	2e00      	cmp	r6, #0
    5a2a:	f000 80ae 	beq.w	5b8a <z_prf+0x6e6>
    5a2e:	2c00      	cmp	r4, #0
    5a30:	f340 80ad 	ble.w	5b8e <z_prf+0x6ea>
			zp->postdot = -decexp;
    5a34:	f1c6 0a00 	rsb	sl, r6, #0
    5a38:	45a2      	cmp	sl, r4
    5a3a:	bfa8      	it	ge
    5a3c:	46a2      	movge	sl, r4
			precision -= zp->postdot;
    5a3e:	eba4 040a 	sub.w	r4, r4, sl
		while (precision > 0 && digit_count > 0) {
    5a42:	2c00      	cmp	r4, #0
    5a44:	dd03      	ble.n	5a4e <z_prf+0x5aa>
    5a46:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    5a48:	2a00      	cmp	r2, #0
    5a4a:	f300 8094 	bgt.w	5b76 <z_prf+0x6d2>
	if (prune_zero) {
    5a4e:	f1b8 0f00 	cmp.w	r8, #0
    5a52:	f040 80b4 	bne.w	5bbe <z_prf+0x71a>
	*buf = 0;
    5a56:	2200      	movs	r2, #0
	return buf - start;
    5a58:	ae19      	add	r6, sp, #100	; 0x64
	*buf = 0;
    5a5a:	701a      	strb	r2, [r3, #0]
	return buf - start;
    5a5c:	1b9b      	subs	r3, r3, r6
    5a5e:	e671      	b.n	5744 <z_prf+0x2a0>
				exp--;
    5a60:	3901      	subs	r1, #1
			while (((fract <<= 1) & HIGHBIT64) == 0) {
    5a62:	9b04      	ldr	r3, [sp, #16]
    5a64:	18db      	adds	r3, r3, r3
    5a66:	9304      	str	r3, [sp, #16]
    5a68:	9b05      	ldr	r3, [sp, #20]
    5a6a:	415b      	adcs	r3, r3
    5a6c:	9305      	str	r3, [sp, #20]
    5a6e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    5a72:	2a00      	cmp	r2, #0
    5a74:	f173 0300 	sbcs.w	r3, r3, #0
    5a78:	daf2      	bge.n	5a60 <z_prf+0x5bc>
    5a7a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    5a7e:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
    5a82:	e74f      	b.n	5924 <z_prf+0x480>
			_rlrshift(&fract);
    5a84:	a814      	add	r0, sp, #80	; 0x50
    5a86:	f020 f981 	bl	25d8c <_rlrshift>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
    5a8a:	e9dd 2c14 	ldrd	r2, ip, [sp, #80]	; 0x50
    5a8e:	2300      	movs	r3, #0
    5a90:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
    5a94:	930b      	str	r3, [sp, #44]	; 0x2c
    5a96:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    5a9a:	2900      	cmp	r1, #0
    5a9c:	bf08      	it	eq
    5a9e:	f1b0 3f33 	cmpeq.w	r0, #858993459	; 0x33333333
    5aa2:	f108 0801 	add.w	r8, r8, #1
    5aa6:	d2ed      	bcs.n	5a84 <z_prf+0x5e0>
		fract *= 5U;
    5aa8:	2005      	movs	r0, #5
    5aaa:	fba2 2300 	umull	r2, r3, r2, r0
    5aae:	fb00 330c 	mla	r3, r0, ip, r3
    5ab2:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
		decexp--;
    5ab6:	3e01      	subs	r6, #1
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    5ab8:	f04f 0e00 	mov.w	lr, #0
    5abc:	2100      	movs	r1, #0
    5abe:	f04f 0c00 	mov.w	ip, #0
    5ac2:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
    5ac6:	458c      	cmp	ip, r1
    5ac8:	bf08      	it	eq
    5aca:	459b      	cmpeq	fp, r3
    5acc:	d206      	bcs.n	5adc <z_prf+0x638>
    5ace:	f1be 0f00 	cmp.w	lr, #0
    5ad2:	f43f af2e 	beq.w	5932 <z_prf+0x48e>
    5ad6:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
    5ada:	e72a      	b.n	5932 <z_prf+0x48e>
			fract <<= 1;
    5adc:	1892      	adds	r2, r2, r2
    5ade:	415b      	adcs	r3, r3
			exp--;
    5ae0:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    5ae4:	f04f 0e01 	mov.w	lr, #1
    5ae8:	e7e8      	b.n	5abc <z_prf+0x618>
		_ldiv5(&fract);
    5aea:	a814      	add	r0, sp, #80	; 0x50
    5aec:	f020 f960 	bl	25db0 <_ldiv5>
		exp--;
    5af0:	e9dd 1014 	ldrd	r1, r0, [sp, #80]	; 0x50
    5af4:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		decexp++;
    5af8:	3601      	adds	r6, #1
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    5afa:	f04f 0e00 	mov.w	lr, #0
    5afe:	2300      	movs	r3, #0
    5b00:	f04f 0c00 	mov.w	ip, #0
    5b04:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
    5b08:	459c      	cmp	ip, r3
    5b0a:	bf08      	it	eq
    5b0c:	4583      	cmpeq	fp, r0
    5b0e:	d206      	bcs.n	5b1e <z_prf+0x67a>
    5b10:	f1be 0f00 	cmp.w	lr, #0
    5b14:	f43f af11 	beq.w	593a <z_prf+0x496>
    5b18:	e9cd 1014 	strd	r1, r0, [sp, #80]	; 0x50
    5b1c:	e70d      	b.n	593a <z_prf+0x496>
			fract <<= 1;
    5b1e:	1849      	adds	r1, r1, r1
    5b20:	4140      	adcs	r0, r0
			exp--;
    5b22:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    5b26:	f04f 0e01 	mov.w	lr, #1
    5b2a:	e7e8      	b.n	5afe <z_prf+0x65a>
    5b2c:	2600      	movs	r6, #0
    5b2e:	46b0      	mov	r8, r6
    5b30:	e707      	b.n	5942 <z_prf+0x49e>
			precision -= decexp;
    5b32:	1ba4      	subs	r4, r4, r6
		if (!falt && (precision > 0)) {
    5b34:	f1ba 0f00 	cmp.w	sl, #0
    5b38:	d104      	bne.n	5b44 <z_prf+0x6a0>
			c = 'f';
    5b3a:	2566      	movs	r5, #102	; 0x66
    5b3c:	e720      	b.n	5980 <z_prf+0x4dc>
	prune_zero = false;		/* Assume trailing 0's allowed     */
    5b3e:	f04f 0800 	mov.w	r8, #0
    5b42:	e723      	b.n	598c <z_prf+0x4e8>
    5b44:	f04f 0800 	mov.w	r8, #0
    5b48:	e723      	b.n	5992 <z_prf+0x4ee>
    5b4a:	f04f 0800 	mov.w	r8, #0
		exp = precision + 1;
    5b4e:	f104 0b01 	add.w	fp, r4, #1
    5b52:	e724      	b.n	599e <z_prf+0x4fa>
			exp = 0;
    5b54:	f04f 0b00 	mov.w	fp, #0
    5b58:	e726      	b.n	59a8 <z_prf+0x504>
		_ldiv5(&ltemp);
    5b5a:	a816      	add	r0, sp, #88	; 0x58
    5b5c:	f020 f928 	bl	25db0 <_ldiv5>
		_rlrshift(&ltemp);
    5b60:	a816      	add	r0, sp, #88	; 0x58
    5b62:	f020 f913 	bl	25d8c <_rlrshift>
    5b66:	e726      	b.n	59b6 <z_prf+0x512>
			*buf++ = '0';
    5b68:	463b      	mov	r3, r7
    5b6a:	2230      	movs	r2, #48	; 0x30
    5b6c:	f803 2b01 	strb.w	r2, [r3], #1
			zero.predot = zero.postdot = zero.trail = 0;
    5b70:	f04f 0b00 	mov.w	fp, #0
    5b74:	e750      	b.n	5a18 <z_prf+0x574>
			*buf++ = _get_digit(&fract, &digit_count);
    5b76:	a913      	add	r1, sp, #76	; 0x4c
    5b78:	a814      	add	r0, sp, #80	; 0x50
    5b7a:	930a      	str	r3, [sp, #40]	; 0x28
    5b7c:	f020 f941 	bl	25e02 <_get_digit>
    5b80:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			precision--;
    5b82:	3c01      	subs	r4, #1
			*buf++ = _get_digit(&fract, &digit_count);
    5b84:	f803 0b01 	strb.w	r0, [r3], #1
			precision--;
    5b88:	e75b      	b.n	5a42 <z_prf+0x59e>
			zero.predot = zero.postdot = zero.trail = 0;
    5b8a:	46b2      	mov	sl, r6
    5b8c:	e759      	b.n	5a42 <z_prf+0x59e>
    5b8e:	f04f 0a00 	mov.w	sl, #0
    5b92:	e75c      	b.n	5a4e <z_prf+0x5aa>
		*buf = _get_digit(&fract, &digit_count);
    5b94:	a913      	add	r1, sp, #76	; 0x4c
    5b96:	a814      	add	r0, sp, #80	; 0x50
    5b98:	f020 f933 	bl	25e02 <_get_digit>
		if (*buf++ != '0') {
    5b9c:	2830      	cmp	r0, #48	; 0x30
		*buf = _get_digit(&fract, &digit_count);
    5b9e:	7038      	strb	r0, [r7, #0]
			decexp--;
    5ba0:	bf18      	it	ne
    5ba2:	f106 36ff 	addne.w	r6, r6, #4294967295	; 0xffffffff
		if (falt || (precision > 0)) {
    5ba6:	f1ba 0f00 	cmp.w	sl, #0
    5baa:	d137      	bne.n	5c1c <z_prf+0x778>
    5bac:	2c00      	cmp	r4, #0
    5bae:	dc35      	bgt.n	5c1c <z_prf+0x778>
		if (*buf++ != '0') {
    5bb0:	1c7b      	adds	r3, r7, #1
	if (prune_zero) {
    5bb2:	f1b8 0f00 	cmp.w	r8, #0
    5bb6:	d043      	beq.n	5c40 <z_prf+0x79c>
			zero.predot = zero.postdot = zero.trail = 0;
    5bb8:	f04f 0b00 	mov.w	fp, #0
    5bbc:	46da      	mov	sl, fp
		while (*--buf == '0')
    5bbe:	4619      	mov	r1, r3
    5bc0:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    5bc4:	2a30      	cmp	r2, #48	; 0x30
    5bc6:	d0fa      	beq.n	5bbe <z_prf+0x71a>
		if (*buf != '.') {
    5bc8:	2a2e      	cmp	r2, #46	; 0x2e
    5bca:	bf18      	it	ne
    5bcc:	460b      	movne	r3, r1
    5bce:	2400      	movs	r4, #0
	if ((c == 'e') || (c == 'E')) {
    5bd0:	f005 02df 	and.w	r2, r5, #223	; 0xdf
    5bd4:	2a45      	cmp	r2, #69	; 0x45
    5bd6:	f47f af3e 	bne.w	5a56 <z_prf+0x5b2>
		if (decexp < 0) {
    5bda:	2e00      	cmp	r6, #0
		*buf++ = c;
    5bdc:	4619      	mov	r1, r3
			decexp = -decexp;
    5bde:	bfba      	itte	lt
    5be0:	4276      	neglt	r6, r6
			*buf++ = '-';
    5be2:	222d      	movlt	r2, #45	; 0x2d
			*buf++ = '+';
    5be4:	222b      	movge	r2, #43	; 0x2b
		if (decexp >= 100) {
    5be6:	2e63      	cmp	r6, #99	; 0x63
		*buf++ = c;
    5be8:	f801 5b02 	strb.w	r5, [r1], #2
			*buf++ = '-';
    5bec:	705a      	strb	r2, [r3, #1]
		if (decexp >= 100) {
    5bee:	dd08      	ble.n	5c02 <z_prf+0x75e>
			*buf++ = (decexp / 100) + '0';
    5bf0:	2064      	movs	r0, #100	; 0x64
    5bf2:	fb96 f2f0 	sdiv	r2, r6, r0
    5bf6:	f102 0530 	add.w	r5, r2, #48	; 0x30
    5bfa:	1cd9      	adds	r1, r3, #3
    5bfc:	709d      	strb	r5, [r3, #2]
			decexp %= 100;
    5bfe:	fb00 6612 	mls	r6, r0, r2, r6
		*buf++ = (decexp / 10) + '0';
    5c02:	200a      	movs	r0, #10
    5c04:	460b      	mov	r3, r1
    5c06:	fb96 f2f0 	sdiv	r2, r6, r0
		decexp %= 10;
    5c0a:	fb00 6612 	mls	r6, r0, r2, r6
		*buf++ = (decexp / 10) + '0';
    5c0e:	f102 0530 	add.w	r5, r2, #48	; 0x30
		*buf++ = decexp + '0';
    5c12:	3630      	adds	r6, #48	; 0x30
		*buf++ = (decexp / 10) + '0';
    5c14:	f803 5b02 	strb.w	r5, [r3], #2
		*buf++ = decexp + '0';
    5c18:	704e      	strb	r6, [r1, #1]
    5c1a:	e71c      	b.n	5a56 <z_prf+0x5b2>
			*buf++ = '.';
    5c1c:	222e      	movs	r2, #46	; 0x2e
    5c1e:	1cbb      	adds	r3, r7, #2
    5c20:	707a      	strb	r2, [r7, #1]
		while (precision > 0 && digit_count > 0) {
    5c22:	2c00      	cmp	r4, #0
    5c24:	ddc5      	ble.n	5bb2 <z_prf+0x70e>
    5c26:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    5c28:	2a00      	cmp	r2, #0
    5c2a:	ddc2      	ble.n	5bb2 <z_prf+0x70e>
			*buf++ = _get_digit(&fract, &digit_count);
    5c2c:	a913      	add	r1, sp, #76	; 0x4c
    5c2e:	a814      	add	r0, sp, #80	; 0x50
    5c30:	930a      	str	r3, [sp, #40]	; 0x28
    5c32:	f020 f8e6 	bl	25e02 <_get_digit>
    5c36:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			precision--;
    5c38:	3c01      	subs	r4, #1
			*buf++ = _get_digit(&fract, &digit_count);
    5c3a:	f803 0b01 	strb.w	r0, [r3], #1
			precision--;
    5c3e:	e7f0      	b.n	5c22 <z_prf+0x77e>
			zero.predot = zero.postdot = zero.trail = 0;
    5c40:	46c3      	mov	fp, r8
    5c42:	46c2      	mov	sl, r8
    5c44:	e7c4      	b.n	5bd0 <z_prf+0x72c>
					prefix = 1;
    5c46:	f04f 0801 	mov.w	r8, #1
    5c4a:	e58b      	b.n	5764 <z_prf+0x2c0>
				switch (i) {
    5c4c:	4632      	mov	r2, r6
    5c4e:	2f68      	cmp	r7, #104	; 0x68
    5c50:	f852 3b04 	ldr.w	r3, [r2], #4
    5c54:	9201      	str	r2, [sp, #4]
    5c56:	d006      	beq.n	5c66 <z_prf+0x7c2>
    5c58:	2f6c      	cmp	r7, #108	; 0x6c
    5c5a:	d009      	beq.n	5c70 <z_prf+0x7cc>
    5c5c:	2f48      	cmp	r7, #72	; 0x48
    5c5e:	d107      	bne.n	5c70 <z_prf+0x7cc>
					*va_arg(vargs, char *) = count;
    5c60:	9a02      	ldr	r2, [sp, #8]
    5c62:	701a      	strb	r2, [r3, #0]
					break;
    5c64:	e001      	b.n	5c6a <z_prf+0x7c6>
					*va_arg(vargs, short *) = count;
    5c66:	9a02      	ldr	r2, [sp, #8]
    5c68:	801a      	strh	r2, [r3, #0]
				continue;
    5c6a:	9e01      	ldr	r6, [sp, #4]
    5c6c:	9a06      	ldr	r2, [sp, #24]
    5c6e:	e421      	b.n	54b4 <z_prf+0x10>
					*va_arg(vargs, int *) = count;
    5c70:	9a02      	ldr	r2, [sp, #8]
    5c72:	601a      	str	r2, [r3, #0]
					break;
    5c74:	e7f9      	b.n	5c6a <z_prf+0x7c6>
		*buf++ = '0';
    5c76:	f647 0330 	movw	r3, #30768	; 0x7830
    5c7a:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
	len = _to_x(buf, value, 16);
    5c7e:	4633      	mov	r3, r6
    5c80:	2210      	movs	r2, #16
    5c82:	f853 1b04 	ldr.w	r1, [r3], #4
    5c86:	9301      	str	r3, [sp, #4]
    5c88:	f10d 0066 	add.w	r0, sp, #102	; 0x66
    5c8c:	f020 f85a 	bl	25d44 <_to_x>
				prefix = 2;
    5c90:	f04f 0802 	mov.w	r8, #2
	return len + (buf - buf0);
    5c94:	1c86      	adds	r6, r0, #2
				break;
    5c96:	e604      	b.n	58a2 <z_prf+0x3fe>
				cptr = va_arg(vargs, char *);
    5c98:	4633      	mov	r3, r6
					precision = INT_MAX;
    5c9a:	2c00      	cmp	r4, #0
				cptr = va_arg(vargs, char *);
    5c9c:	f853 7b04 	ldr.w	r7, [r3], #4
    5ca0:	9301      	str	r3, [sp, #4]
					precision = INT_MAX;
    5ca2:	bfb8      	it	lt
    5ca4:	f06f 4400 	mvnlt.w	r4, #2147483648	; 0x80000000
				for (clen = 0; clen < precision; clen++) {
    5ca8:	2600      	movs	r6, #0
    5caa:	42b4      	cmp	r4, r6
    5cac:	d103      	bne.n	5cb6 <z_prf+0x812>
    5cae:	4626      	mov	r6, r4
    5cb0:	2400      	movs	r4, #0
    5cb2:	46a0      	mov	r8, r4
    5cb4:	e579      	b.n	57aa <z_prf+0x306>
					if (cptr[clen] == '\0') {
    5cb6:	5dbb      	ldrb	r3, [r7, r6]
    5cb8:	2b00      	cmp	r3, #0
    5cba:	d05b      	beq.n	5d74 <z_prf+0x8d0>
				for (clen = 0; clen < precision; clen++) {
    5cbc:	3601      	adds	r6, #1
    5cbe:	e7f4      	b.n	5caa <z_prf+0x806>
				switch (i) {
    5cc0:	1d33      	adds	r3, r6, #4
				if (c == 'o') {
    5cc2:	2d6f      	cmp	r5, #111	; 0x6f
    5cc4:	6831      	ldr	r1, [r6, #0]
    5cc6:	9301      	str	r3, [sp, #4]
    5cc8:	d119      	bne.n	5cfe <z_prf+0x85a>
	if (alt_form) {
    5cca:	f1ba 0f00 	cmp.w	sl, #0
    5cce:	d008      	beq.n	5ce2 <z_prf+0x83e>
		*buf++ = '0';
    5cd0:	2330      	movs	r3, #48	; 0x30
    5cd2:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
		if (!value) {
    5cd6:	b979      	cbnz	r1, 5cf8 <z_prf+0x854>
			*buf++ = 0;
    5cd8:	f88d 1065 	strb.w	r1, [sp, #101]	; 0x65
			prefix = 0;
    5cdc:	4688      	mov	r8, r1
			return 1;
    5cde:	2601      	movs	r6, #1
    5ce0:	e5df      	b.n	58a2 <z_prf+0x3fe>
    5ce2:	ad19      	add	r5, sp, #100	; 0x64
	return (buf - buf0) + _to_x(buf, value, 8);
    5ce4:	4628      	mov	r0, r5
    5ce6:	2208      	movs	r2, #8
    5ce8:	f020 f82c 	bl	25d44 <_to_x>
    5cec:	ae19      	add	r6, sp, #100	; 0x64
    5cee:	1bad      	subs	r5, r5, r6
    5cf0:	182e      	adds	r6, r5, r0
			prefix = 0;
    5cf2:	f04f 0800 	mov.w	r8, #0
    5cf6:	e5d4      	b.n	58a2 <z_prf+0x3fe>
		*buf++ = '0';
    5cf8:	f10d 0565 	add.w	r5, sp, #101	; 0x65
    5cfc:	e7f2      	b.n	5ce4 <z_prf+0x840>
				} else if (c == 'u') {
    5cfe:	2d75      	cmp	r5, #117	; 0x75
    5d00:	d105      	bne.n	5d0e <z_prf+0x86a>
	return _to_x(buf, value, 10);
    5d02:	220a      	movs	r2, #10
    5d04:	a819      	add	r0, sp, #100	; 0x64
    5d06:	f020 f81d 	bl	25d44 <_to_x>
    5d0a:	4606      	mov	r6, r0
    5d0c:	e7f1      	b.n	5cf2 <z_prf+0x84e>
	if (alt_form) {
    5d0e:	f1ba 0f00 	cmp.w	sl, #0
    5d12:	d011      	beq.n	5d38 <z_prf+0x894>
		*buf++ = '0';
    5d14:	f647 0330 	movw	r3, #30768	; 0x7830
    5d18:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
		*buf++ = 'x';
    5d1c:	f10d 0766 	add.w	r7, sp, #102	; 0x66
	len = _to_x(buf, value, 16);
    5d20:	2210      	movs	r2, #16
    5d22:	4638      	mov	r0, r7
    5d24:	f020 f80e 	bl	25d44 <_to_x>
	if (prefix == 'X') {
    5d28:	2d58      	cmp	r5, #88	; 0x58
    5d2a:	d007      	beq.n	5d3c <z_prf+0x898>
	return len + (buf - buf0);
    5d2c:	ae19      	add	r6, sp, #100	; 0x64
    5d2e:	1bbf      	subs	r7, r7, r6
    5d30:	183e      	adds	r6, r7, r0
						prefix = 2;
    5d32:	ea4f 084a 	mov.w	r8, sl, lsl #1
    5d36:	e5b4      	b.n	58a2 <z_prf+0x3fe>
    5d38:	af19      	add	r7, sp, #100	; 0x64
    5d3a:	e7f1      	b.n	5d20 <z_prf+0x87c>
    5d3c:	aa19      	add	r2, sp, #100	; 0x64
		if (*buf >= 'a' && *buf <= 'z') {
    5d3e:	f812 3b01 	ldrb.w	r3, [r2], #1
    5d42:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
    5d46:	2919      	cmp	r1, #25
    5d48:	d803      	bhi.n	5d52 <z_prf+0x8ae>
			*buf += 'A' - 'a';
    5d4a:	3b20      	subs	r3, #32
    5d4c:	f802 3c01 	strb.w	r3, [r2, #-1]
	} while (*buf++);
    5d50:	e7f5      	b.n	5d3e <z_prf+0x89a>
    5d52:	f812 3c01 	ldrb.w	r3, [r2, #-1]
    5d56:	2b00      	cmp	r3, #0
    5d58:	d1f1      	bne.n	5d3e <z_prf+0x89a>
    5d5a:	e7e7      	b.n	5d2c <z_prf+0x888>
				PUTC('%');
    5d5c:	4649      	mov	r1, r9
    5d5e:	4628      	mov	r0, r5
    5d60:	f7ff bbb1 	b.w	54c6 <z_prf+0x22>
				count++;
    5d64:	9b02      	ldr	r3, [sp, #8]
    5d66:	3301      	adds	r3, #1
				continue;
    5d68:	e9cd 6301 	strd	r6, r3, [sp, #4]
    5d6c:	e77d      	b.n	5c6a <z_prf+0x7c6>
					prefix = 1;
    5d6e:	f04f 0801 	mov.w	r8, #1
    5d72:	e596      	b.n	58a2 <z_prf+0x3fe>
    5d74:	461c      	mov	r4, r3
    5d76:	e79c      	b.n	5cb2 <z_prf+0x80e>
			cptr = buf;
    5d78:	af19      	add	r7, sp, #100	; 0x64
				zero_head = 0;
    5d7a:	2300      	movs	r3, #0
    5d7c:	e51d      	b.n	57ba <z_prf+0x316>
    5d7e:	9b08      	ldr	r3, [sp, #32]
    5d80:	af19      	add	r7, sp, #100	; 0x64
    5d82:	e51a      	b.n	57ba <z_prf+0x316>
    5d84:	9309      	str	r3, [sp, #36]	; 0x24
					PUTC(' ');
    5d86:	4649      	mov	r1, r9
    5d88:	9b03      	ldr	r3, [sp, #12]
    5d8a:	9207      	str	r2, [sp, #28]
    5d8c:	2020      	movs	r0, #32
    5d8e:	4798      	blx	r3
    5d90:	3001      	adds	r0, #1
    5d92:	9a07      	ldr	r2, [sp, #28]
    5d94:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5d96:	f43f ab9b 	beq.w	54d0 <z_prf+0x2c>
				while (width-- > 0) {
    5d9a:	3a01      	subs	r2, #1
    5d9c:	d2f2      	bcs.n	5d84 <z_prf+0x8e0>
				count += width;
    5d9e:	9902      	ldr	r1, [sp, #8]
    5da0:	4429      	add	r1, r5
    5da2:	9102      	str	r1, [sp, #8]
				while (width-- > 0) {
    5da4:	4615      	mov	r5, r2
    5da6:	e512      	b.n	57ce <z_prf+0x32a>
    5da8:	462a      	mov	r2, r5
    5daa:	e7f6      	b.n	5d9a <z_prf+0x8f6>
    5dac:	9309      	str	r3, [sp, #36]	; 0x24
				PUTC(*cptr++);
    5dae:	f817 0b01 	ldrb.w	r0, [r7], #1
    5db2:	9b03      	ldr	r3, [sp, #12]
    5db4:	9207      	str	r2, [sp, #28]
    5db6:	4649      	mov	r1, r9
    5db8:	4798      	blx	r3
    5dba:	3001      	adds	r0, #1
    5dbc:	9a07      	ldr	r2, [sp, #28]
    5dbe:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5dc0:	f47f ad07 	bne.w	57d2 <z_prf+0x32e>
    5dc4:	f7ff bb84 	b.w	54d0 <z_prf+0x2c>
    5dc8:	9307      	str	r3, [sp, #28]
				PUTC('0');
    5dca:	4649      	mov	r1, r9
    5dcc:	9b03      	ldr	r3, [sp, #12]
    5dce:	2030      	movs	r0, #48	; 0x30
    5dd0:	4798      	blx	r3
    5dd2:	3001      	adds	r0, #1
    5dd4:	9b07      	ldr	r3, [sp, #28]
    5dd6:	f47f acff 	bne.w	57d8 <z_prf+0x334>
    5dda:	f7ff bb79 	b.w	54d0 <z_prf+0x2c>
					PUTC(c);
    5dde:	9b03      	ldr	r3, [sp, #12]
    5de0:	4649      	mov	r1, r9
    5de2:	4798      	blx	r3
    5de4:	3001      	adds	r0, #1
    5de6:	f43f ab73 	beq.w	54d0 <z_prf+0x2c>
					c = *++cptr;
    5dea:	f817 0f01 	ldrb.w	r0, [r7, #1]!
    5dee:	e4fe      	b.n	57ee <z_prf+0x34a>
					PUTC('0');
    5df0:	9b03      	ldr	r3, [sp, #12]
    5df2:	4649      	mov	r1, r9
    5df4:	2030      	movs	r0, #48	; 0x30
    5df6:	4798      	blx	r3
    5df8:	3001      	adds	r0, #1
    5dfa:	f47f ad00 	bne.w	57fe <z_prf+0x35a>
    5dfe:	f7ff bb67 	b.w	54d0 <z_prf+0x2c>
					PUTC('0');
    5e02:	9b03      	ldr	r3, [sp, #12]
    5e04:	4649      	mov	r1, r9
    5e06:	2030      	movs	r0, #48	; 0x30
    5e08:	4798      	blx	r3
    5e0a:	3001      	adds	r0, #1
    5e0c:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    5e10:	f47f ad0f 	bne.w	5832 <z_prf+0x38e>
    5e14:	f7ff bb5c 	b.w	54d0 <z_prf+0x2c>
					PUTC(c);
    5e18:	9b03      	ldr	r3, [sp, #12]
    5e1a:	4649      	mov	r1, r9
    5e1c:	4798      	blx	r3
    5e1e:	3001      	adds	r0, #1
    5e20:	f43f ab56 	beq.w	54d0 <z_prf+0x2c>
					c = *++cptr;
    5e24:	f817 0f01 	ldrb.w	r0, [r7, #1]!
    5e28:	e50d      	b.n	5846 <z_prf+0x3a2>
					PUTC('0');
    5e2a:	9b03      	ldr	r3, [sp, #12]
    5e2c:	4649      	mov	r1, r9
    5e2e:	2030      	movs	r0, #48	; 0x30
    5e30:	4798      	blx	r3
    5e32:	3001      	adds	r0, #1
    5e34:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    5e38:	f47f ad10 	bne.w	585c <z_prf+0x3b8>
    5e3c:	f7ff bb48 	b.w	54d0 <z_prf+0x2c>
				PUTC(*cptr++);
    5e40:	f817 0b01 	ldrb.w	r0, [r7], #1
    5e44:	9b03      	ldr	r3, [sp, #12]
    5e46:	4649      	mov	r1, r9
    5e48:	4798      	blx	r3
    5e4a:	3001      	adds	r0, #1
    5e4c:	f43f ab40 	beq.w	54d0 <z_prf+0x2c>
			while (clen-- > 0) {
    5e50:	1bf3      	subs	r3, r6, r7
    5e52:	2b00      	cmp	r3, #0
    5e54:	dcf4      	bgt.n	5e40 <z_prf+0x99c>
			count += clen;
    5e56:	9b02      	ldr	r3, [sp, #8]
    5e58:	9a08      	ldr	r2, [sp, #32]
			if (width > 0) {
    5e5a:	2d00      	cmp	r5, #0
			count += clen;
    5e5c:	4413      	add	r3, r2
    5e5e:	9302      	str	r3, [sp, #8]
			if (width > 0) {
    5e60:	f77f af03 	ble.w	5c6a <z_prf+0x7c6>
    5e64:	462c      	mov	r4, r5
    5e66:	e006      	b.n	5e76 <z_prf+0x9d2>
					PUTC(' ');
    5e68:	9b03      	ldr	r3, [sp, #12]
    5e6a:	4649      	mov	r1, r9
    5e6c:	2020      	movs	r0, #32
    5e6e:	4798      	blx	r3
    5e70:	3001      	adds	r0, #1
    5e72:	f43f ab2d 	beq.w	54d0 <z_prf+0x2c>
				while (width-- > 0) {
    5e76:	3c01      	subs	r4, #1
    5e78:	d2f6      	bcs.n	5e68 <z_prf+0x9c4>
				count += width;
    5e7a:	9b02      	ldr	r3, [sp, #8]
    5e7c:	442b      	add	r3, r5
    5e7e:	9302      	str	r3, [sp, #8]
    5e80:	e6f3      	b.n	5c6a <z_prf+0x7c6>
    5e82:	bf00      	nop

00005e84 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    5e84:	4b01      	ldr	r3, [pc, #4]	; (5e8c <__stdout_hook_install+0x8>)
    5e86:	6018      	str	r0, [r3, #0]
}
    5e88:	4770      	bx	lr
    5e8a:	bf00      	nop
    5e8c:	20006ab4 	.word	0x20006ab4

00005e90 <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *_MLIBC_RESTRICT s, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
    5e90:	b40c      	push	{r2, r3}
    5e92:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    5e94:	b909      	cbnz	r1, 5e9a <snprintf+0xa>
		s = &dummy; /* write final NUL to dummy, can't change *s */
    5e96:	f10d 0003 	add.w	r0, sp, #3
	}

	p.ptr = s;
	p.len = (int) len;
    5e9a:	e9cd 0102 	strd	r0, r1, [sp, #8]

	va_start(vargs, format);
    5e9e:	ab07      	add	r3, sp, #28
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    5ea0:	9a06      	ldr	r2, [sp, #24]
    5ea2:	4806      	ldr	r0, [pc, #24]	; (5ebc <snprintf+0x2c>)
	va_start(vargs, format);
    5ea4:	9301      	str	r3, [sp, #4]
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    5ea6:	a902      	add	r1, sp, #8
    5ea8:	f7ff fafc 	bl	54a4 <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
    5eac:	9b02      	ldr	r3, [sp, #8]
    5eae:	2200      	movs	r2, #0
    5eb0:	701a      	strb	r2, [r3, #0]
	return r;
}
    5eb2:	b005      	add	sp, #20
    5eb4:	f85d eb04 	ldr.w	lr, [sp], #4
    5eb8:	b002      	add	sp, #8
    5eba:	4770      	bx	lr
    5ebc:	00025e37 	.word	0x00025e37

00005ec0 <nordicsemi_nrf52_init>:
    5ec0:	f04f 0320 	mov.w	r3, #32
    5ec4:	f3ef 8211 	mrs	r2, BASEPRI
    5ec8:	f383 8811 	msr	BASEPRI, r3
    5ecc:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    5ed0:	4906      	ldr	r1, [pc, #24]	; (5eec <nordicsemi_nrf52_init+0x2c>)
    5ed2:	2301      	movs	r3, #1
    5ed4:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    5ed8:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    5edc:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
    5ee0:	f382 8811 	msr	BASEPRI, r2
    5ee4:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    5ee8:	2000      	movs	r0, #0
    5eea:	4770      	bx	lr
    5eec:	4001e000 	.word	0x4001e000

00005ef0 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    5ef0:	b120      	cbz	r0, 5efc <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    5ef2:	4b03      	ldr	r3, [pc, #12]	; (5f00 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    5ef4:	0180      	lsls	r0, r0, #6
    5ef6:	f043 0301 	orr.w	r3, r3, #1
    5efa:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    5efc:	4770      	bx	lr
    5efe:	bf00      	nop
    5f00:	00029ac0 	.word	0x00029ac0

00005f04 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const u8_t *b = buf;
	int i;

	len = MIN(len, (sizeof(str) - 1) / 2);
    5f04:	4b0e      	ldr	r3, [pc, #56]	; (5f40 <bt_hex_real+0x3c>)
    5f06:	2940      	cmp	r1, #64	; 0x40
{
    5f08:	b570      	push	{r4, r5, r6, lr}
	len = MIN(len, (sizeof(str) - 1) / 2);
    5f0a:	bf28      	it	cs
    5f0c:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
    5f0e:	4c0d      	ldr	r4, [pc, #52]	; (5f44 <bt_hex_real+0x40>)
    5f10:	1846      	adds	r6, r0, r1
    5f12:	461d      	mov	r5, r3
	for (i = 0; i < len; i++) {
    5f14:	42b0      	cmp	r0, r6
    5f16:	f103 0302 	add.w	r3, r3, #2
    5f1a:	d104      	bne.n	5f26 <bt_hex_real+0x22>
		str[i * 2 + 1] = hex[b[i] & 0xf];
	}

	str[i * 2] = '\0';
    5f1c:	2300      	movs	r3, #0
    5f1e:	f805 3011 	strb.w	r3, [r5, r1, lsl #1]

	return str;
}
    5f22:	4807      	ldr	r0, [pc, #28]	; (5f40 <bt_hex_real+0x3c>)
    5f24:	bd70      	pop	{r4, r5, r6, pc}
		str[i * 2]     = hex[b[i] >> 4];
    5f26:	7802      	ldrb	r2, [r0, #0]
    5f28:	0912      	lsrs	r2, r2, #4
    5f2a:	5ca2      	ldrb	r2, [r4, r2]
    5f2c:	f803 2c02 	strb.w	r2, [r3, #-2]
		str[i * 2 + 1] = hex[b[i] & 0xf];
    5f30:	f810 2b01 	ldrb.w	r2, [r0], #1
    5f34:	f002 020f 	and.w	r2, r2, #15
    5f38:	5ca2      	ldrb	r2, [r4, r2]
    5f3a:	f803 2c01 	strb.w	r2, [r3, #-1]
	for (i = 0; i < len; i++) {
    5f3e:	e7e9      	b.n	5f14 <bt_hex_real+0x10>
    5f40:	20002357 	.word	0x20002357
    5f44:	0002b87b 	.word	0x0002b87b

00005f48 <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
    5f48:	b530      	push	{r4, r5, lr}
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
	char type[10];

	switch (addr->type) {
    5f4a:	7803      	ldrb	r3, [r0, #0]
    5f4c:	b08b      	sub	sp, #44	; 0x2c
    5f4e:	4604      	mov	r4, r0
    5f50:	ad07      	add	r5, sp, #28
    5f52:	2b03      	cmp	r3, #3
    5f54:	d821      	bhi.n	5f9a <bt_addr_le_str_real+0x52>
    5f56:	e8df f003 	tbb	[pc, r3]
    5f5a:	1a02      	.short	0x1a02
    5f5c:	1e1c      	.short	0x1e1c
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
    5f5e:	4912      	ldr	r1, [pc, #72]	; (5fa8 <bt_addr_le_str_real+0x60>)
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
    5f60:	4628      	mov	r0, r5
    5f62:	f01f fe44 	bl	25bee <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    5f66:	7863      	ldrb	r3, [r4, #1]
    5f68:	9304      	str	r3, [sp, #16]
    5f6a:	78a3      	ldrb	r3, [r4, #2]
    5f6c:	9303      	str	r3, [sp, #12]
    5f6e:	78e3      	ldrb	r3, [r4, #3]
    5f70:	9302      	str	r3, [sp, #8]
    5f72:	7923      	ldrb	r3, [r4, #4]
    5f74:	9301      	str	r3, [sp, #4]
    5f76:	7963      	ldrb	r3, [r4, #5]
    5f78:	9300      	str	r3, [sp, #0]
    5f7a:	4a0c      	ldr	r2, [pc, #48]	; (5fac <bt_addr_le_str_real+0x64>)
    5f7c:	79a3      	ldrb	r3, [r4, #6]
    5f7e:	9505      	str	r5, [sp, #20]
    5f80:	211e      	movs	r1, #30
    5f82:	480b      	ldr	r0, [pc, #44]	; (5fb0 <bt_addr_le_str_real+0x68>)
    5f84:	f01d ffba 	bl	23efc <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
    5f88:	4809      	ldr	r0, [pc, #36]	; (5fb0 <bt_addr_le_str_real+0x68>)
    5f8a:	b00b      	add	sp, #44	; 0x2c
    5f8c:	bd30      	pop	{r4, r5, pc}
		strcpy(type, "random");
    5f8e:	4909      	ldr	r1, [pc, #36]	; (5fb4 <bt_addr_le_str_real+0x6c>)
    5f90:	e7e6      	b.n	5f60 <bt_addr_le_str_real+0x18>
		strcpy(type, "public-id");
    5f92:	4909      	ldr	r1, [pc, #36]	; (5fb8 <bt_addr_le_str_real+0x70>)
    5f94:	e7e4      	b.n	5f60 <bt_addr_le_str_real+0x18>
		strcpy(type, "random-id");
    5f96:	4909      	ldr	r1, [pc, #36]	; (5fbc <bt_addr_le_str_real+0x74>)
    5f98:	e7e2      	b.n	5f60 <bt_addr_le_str_real+0x18>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    5f9a:	4a09      	ldr	r2, [pc, #36]	; (5fc0 <bt_addr_le_str_real+0x78>)
    5f9c:	210a      	movs	r1, #10
    5f9e:	4628      	mov	r0, r5
    5fa0:	f01d ffac 	bl	23efc <snprintk>
		break;
    5fa4:	e7df      	b.n	5f66 <bt_addr_le_str_real+0x1e>
    5fa6:	bf00      	nop
    5fa8:	0002b836 	.word	0x0002b836
    5fac:	0002b858 	.word	0x0002b858
    5fb0:	200023d8 	.word	0x200023d8
    5fb4:	0002b83d 	.word	0x0002b83d
    5fb8:	0002b844 	.word	0x0002b844
    5fbc:	0002b84e 	.word	0x0002b84e
    5fc0:	0002fb26 	.word	0x0002fb26

00005fc4 <bt_uuid_str_real>:

const char *bt_uuid_str_real(const struct bt_uuid *uuid)
{
    5fc4:	b510      	push	{r4, lr}
	static char str[BT_UUID_STR_LEN];

	bt_uuid_to_str(uuid, str, sizeof(str));
    5fc6:	4c03      	ldr	r4, [pc, #12]	; (5fd4 <bt_uuid_str_real+0x10>)
    5fc8:	2225      	movs	r2, #37	; 0x25
    5fca:	4621      	mov	r1, r4
    5fcc:	f000 fb64 	bl	6698 <bt_uuid_to_str>

	return str;
}
    5fd0:	4620      	mov	r0, r4
    5fd2:	bd10      	pop	{r4, pc}
    5fd4:	200023f6 	.word	0x200023f6

00005fd8 <sys_memcpy_swap.constprop.0>:
static inline void sys_memcpy_swap(void *dst, const void *src, size_t length)
{
	u8_t *pdst = (u8_t *)dst;
	const u8_t *psrc = (const u8_t *)src;

	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
    5fd8:	4288      	cmp	r0, r1
static inline void sys_memcpy_swap(void *dst, const void *src, size_t length)
    5fda:	b570      	push	{r4, r5, r6, lr}
    5fdc:	4604      	mov	r4, r0
    5fde:	460d      	mov	r5, r1
    5fe0:	f101 0620 	add.w	r6, r1, #32
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
    5fe4:	d919      	bls.n	601a <sys_memcpy_swap.constprop.0+0x42>
    5fe6:	42b0      	cmp	r0, r6
    5fe8:	d20e      	bcs.n	6008 <sys_memcpy_swap.constprop.0+0x30>
    5fea:	490e      	ldr	r1, [pc, #56]	; (6024 <sys_memcpy_swap.constprop.0+0x4c>)
    5fec:	4a0e      	ldr	r2, [pc, #56]	; (6028 <sys_memcpy_swap.constprop.0+0x50>)
    5fee:	480f      	ldr	r0, [pc, #60]	; (602c <sys_memcpy_swap.constprop.0+0x54>)
    5ff0:	f240 2317 	movw	r3, #535	; 0x217
    5ff4:	f01d ff75 	bl	23ee2 <printk>
    5ff8:	480d      	ldr	r0, [pc, #52]	; (6030 <sys_memcpy_swap.constprop.0+0x58>)
    5ffa:	f01d ff72 	bl	23ee2 <printk>
    5ffe:	480a      	ldr	r0, [pc, #40]	; (6028 <sys_memcpy_swap.constprop.0+0x50>)
    6000:	f240 2117 	movw	r1, #535	; 0x217
    6004:	f01d ffb0 	bl	23f68 <assert_post_action>
		  (psrc > pdst && (pdst + length) <= psrc)),
		 "Source and destination buffers must not overlap");

	psrc += length - 1;

	for (; length > 0; length--) {
    6008:	4633      	mov	r3, r6
    600a:	3c01      	subs	r4, #1
		*pdst++ = *psrc--;
    600c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    6010:	f804 2f01 	strb.w	r2, [r4, #1]!
	for (; length > 0; length--) {
    6014:	42ab      	cmp	r3, r5
    6016:	d1f9      	bne.n	600c <sys_memcpy_swap.constprop.0+0x34>
	}
}
    6018:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
    601a:	d0e6      	beq.n	5fea <sys_memcpy_swap.constprop.0+0x12>
    601c:	f100 0320 	add.w	r3, r0, #32
    6020:	4299      	cmp	r1, r3
    6022:	e7e1      	b.n	5fe8 <sys_memcpy_swap.constprop.0+0x10>
    6024:	0002b8b3 	.word	0x0002b8b3
    6028:	0002b88c 	.word	0x0002b88c
    602c:	0002a5e8 	.word	0x0002a5e8
    6030:	0002b90a 	.word	0x0002b90a

00006034 <ecc_thread>:

	bt_recv(buf);
}

static void ecc_thread(void *p1, void *p2, void *p3)
{
    6034:	b580      	push	{r7, lr}
    6036:	4d69      	ldr	r5, [pc, #420]	; (61dc <ecc_thread+0x1a8>)
    6038:	4b69      	ldr	r3, [pc, #420]	; (61e0 <ecc_thread+0x1ac>)
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    603a:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 6210 <ecc_thread+0x1dc>
	return z_impl_k_sem_take(sem, timeout);
    603e:	f8df 91d4 	ldr.w	r9, [pc, #468]	; 6214 <ecc_thread+0x1e0>
    6042:	1aed      	subs	r5, r5, r3
    6044:	08ed      	lsrs	r5, r5, #3
    6046:	4646      	mov	r6, r8
    6048:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    604c:	4648      	mov	r0, r9
    604e:	f01c fb73 	bl	22738 <z_impl_k_sem_take>
    6052:	f3bf 8f5b 	dmb	ish
    6056:	f8d8 4000 	ldr.w	r4, [r8]
    605a:	f3bf 8f5b 	dmb	ish
	while (true) {
		k_sem_take(&cmd_sem, K_FOREVER);

		if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
    605e:	f014 0401 	ands.w	r4, r4, #1
    6062:	d058      	beq.n	6116 <ecc_thread+0xe2>
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
    6064:	f8df a190 	ldr.w	sl, [pc, #400]	; 61f8 <ecc_thread+0x1c4>
    6068:	4c5e      	ldr	r4, [pc, #376]	; (61e4 <ecc_thread+0x1b0>)
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
    606a:	4f5f      	ldr	r7, [pc, #380]	; (61e8 <ecc_thread+0x1b4>)
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
    606c:	485f      	ldr	r0, [pc, #380]	; (61ec <ecc_thread+0x1b8>)
    606e:	4652      	mov	r2, sl
    6070:	4621      	mov	r1, r4
    6072:	f01e fc88 	bl	24986 <uECC_make_key>
		if (rc == TC_CRYPTO_FAIL) {
    6076:	bbd8      	cbnz	r0, 60f0 <ecc_thread+0xbc>
			BT_ERR("Failed to create ECC public/private pair");
    6078:	01a9      	lsls	r1, r5, #6
    607a:	485d      	ldr	r0, [pc, #372]	; (61f0 <ecc_thread+0x1bc>)
    607c:	f041 0101 	orr.w	r1, r1, #1
    6080:	f01d ffa0 	bl	23fc4 <log_0>
			return BT_HCI_ERR_UNSPECIFIED;
    6084:	f04f 0a1f 	mov.w	sl, #31
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    6088:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    608c:	2001      	movs	r0, #1
    608e:	f002 fc67 	bl	8960 <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
    6092:	f100 0708 	add.w	r7, r0, #8
    6096:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    6098:	4604      	mov	r4, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
    609a:	4638      	mov	r0, r7
    609c:	f019 f91c 	bl	1f2d8 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
    60a0:	233e      	movs	r3, #62	; 0x3e
    60a2:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
    60a4:	2342      	movs	r3, #66	; 0x42
    60a6:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
    60a8:	2101      	movs	r1, #1
    60aa:	4638      	mov	r0, r7
    60ac:	f019 f914 	bl	1f2d8 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
    60b0:	2308      	movs	r3, #8
    60b2:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
    60b4:	2141      	movs	r1, #65	; 0x41
    60b6:	4638      	mov	r0, r7
    60b8:	f019 f90e 	bl	1f2d8 <net_buf_simple_add>
    60bc:	4607      	mov	r7, r0
	evt->status = status;
    60be:	f800 ab01 	strb.w	sl, [r0], #1
	if (status) {
    60c2:	f1ba 0f00 	cmp.w	sl, #0
    60c6:	d01d      	beq.n	6104 <ecc_thread+0xd0>
		(void)memset(evt->key, 0, sizeof(evt->key));
    60c8:	2240      	movs	r2, #64	; 0x40
    60ca:	2100      	movs	r1, #0
    60cc:	f01f fe17 	bl	25cfe <memset>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    60d0:	f3bf 8f5b 	dmb	ish
    60d4:	e856 3f00 	ldrex	r3, [r6]
    60d8:	f023 0301 	bic.w	r3, r3, #1
    60dc:	e846 3200 	strex	r2, r3, [r6]
    60e0:	2a00      	cmp	r2, #0
    60e2:	d1f7      	bne.n	60d4 <ecc_thread+0xa0>
    60e4:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
    60e8:	4620      	mov	r0, r4
	bt_recv(buf);
    60ea:	f001 fae9 	bl	76c0 <bt_recv>
}
    60ee:	e7ab      	b.n	6048 <ecc_thread+0x14>
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
    60f0:	2220      	movs	r2, #32
    60f2:	4639      	mov	r1, r7
    60f4:	4620      	mov	r0, r4
    60f6:	f01f fdc7 	bl	25c88 <memcmp>
    60fa:	2800      	cmp	r0, #0
    60fc:	d0b6      	beq.n	606c <ecc_thread+0x38>
	return 0;
    60fe:	f04f 0a00 	mov.w	sl, #0
    6102:	e7c1      	b.n	6088 <ecc_thread+0x54>
		sys_memcpy_swap(evt->key, ecc.pk, 32);
    6104:	4939      	ldr	r1, [pc, #228]	; (61ec <ecc_thread+0x1b8>)
    6106:	f7ff ff67 	bl	5fd8 <sys_memcpy_swap.constprop.0>
		sys_memcpy_swap(&evt->key[32], &ecc.pk[32], 32);
    610a:	493a      	ldr	r1, [pc, #232]	; (61f4 <ecc_thread+0x1c0>)
    610c:	f107 0021 	add.w	r0, r7, #33	; 0x21
    6110:	f7ff ff62 	bl	5fd8 <sys_memcpy_swap.constprop.0>
    6114:	e7dc      	b.n	60d0 <ecc_thread+0x9c>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    6116:	f3bf 8f5b 	dmb	ish
    611a:	f8d8 3000 	ldr.w	r3, [r8]
    611e:	f3bf 8f5b 	dmb	ish
			emulate_le_p256_public_key_cmd();
		} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
    6122:	079b      	lsls	r3, r3, #30
    6124:	d54b      	bpl.n	61be <ecc_thread+0x18a>
	ret = uECC_valid_public_key(ecc.pk, &curve_secp256r1);
    6126:	4934      	ldr	r1, [pc, #208]	; (61f8 <ecc_thread+0x1c4>)
    6128:	4830      	ldr	r0, [pc, #192]	; (61ec <ecc_thread+0x1b8>)
    612a:	f01f fafb 	bl	25724 <uECC_valid_public_key>
	if (ret < 0) {
    612e:	1e01      	subs	r1, r0, #0
    6130:	da36      	bge.n	61a0 <ecc_thread+0x16c>
		BT_ERR("public key is not valid (ret %d)", ret);
    6132:	01aa      	lsls	r2, r5, #6
    6134:	4831      	ldr	r0, [pc, #196]	; (61fc <ecc_thread+0x1c8>)
    6136:	f042 0201 	orr.w	r2, r2, #1
    613a:	f01d ff50 	bl	23fde <log_1>
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    613e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    6142:	2001      	movs	r0, #1
    6144:	f002 fc0c 	bl	8960 <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
    6148:	f100 0a08 	add.w	sl, r0, #8
    614c:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    614e:	4607      	mov	r7, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
    6150:	4650      	mov	r0, sl
    6152:	f019 f8c1 	bl	1f2d8 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
    6156:	233e      	movs	r3, #62	; 0x3e
    6158:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
    615a:	2322      	movs	r3, #34	; 0x22
    615c:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
    615e:	2101      	movs	r1, #1
    6160:	4650      	mov	r0, sl
    6162:	f019 f8b9 	bl	1f2d8 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
    6166:	2309      	movs	r3, #9
    6168:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
    616a:	2121      	movs	r1, #33	; 0x21
    616c:	4650      	mov	r0, sl
    616e:	f019 f8b3 	bl	1f2d8 <net_buf_simple_add>
    6172:	4603      	mov	r3, r0
	if (ret == TC_CRYPTO_FAIL) {
    6174:	3001      	adds	r0, #1
    6176:	b9e4      	cbnz	r4, 61b2 <ecc_thread+0x17e>
		evt->status = BT_HCI_ERR_UNSPECIFIED;
    6178:	221f      	movs	r2, #31
    617a:	701a      	strb	r2, [r3, #0]
		(void)memset(evt->dhkey, 0, sizeof(evt->dhkey));
    617c:	4621      	mov	r1, r4
    617e:	2220      	movs	r2, #32
    6180:	f01f fdbd 	bl	25cfe <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    6184:	f3bf 8f5b 	dmb	ish
    6188:	e856 3f00 	ldrex	r3, [r6]
    618c:	f023 0302 	bic.w	r3, r3, #2
    6190:	e846 3200 	strex	r2, r3, [r6]
    6194:	2a00      	cmp	r2, #0
    6196:	d1f7      	bne.n	6188 <ecc_thread+0x154>
    6198:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
    619c:	4638      	mov	r0, r7
    619e:	e7a4      	b.n	60ea <ecc_thread+0xb6>
		ret = uECC_shared_secret(ecc.pk, ecc.private_key, ecc.dhkey,
    61a0:	4a12      	ldr	r2, [pc, #72]	; (61ec <ecc_thread+0x1b8>)
    61a2:	4b15      	ldr	r3, [pc, #84]	; (61f8 <ecc_thread+0x1c4>)
    61a4:	f1a2 0120 	sub.w	r1, r2, #32
    61a8:	4610      	mov	r0, r2
    61aa:	f01e fc3b 	bl	24a24 <uECC_shared_secret>
    61ae:	4604      	mov	r4, r0
    61b0:	e7c5      	b.n	613e <ecc_thread+0x10a>
		evt->status = 0U;
    61b2:	2200      	movs	r2, #0
		sys_memcpy_swap(evt->dhkey, ecc.dhkey, sizeof(ecc.dhkey));
    61b4:	490d      	ldr	r1, [pc, #52]	; (61ec <ecc_thread+0x1b8>)
		evt->status = 0U;
    61b6:	701a      	strb	r2, [r3, #0]
		sys_memcpy_swap(evt->dhkey, ecc.dhkey, sizeof(ecc.dhkey));
    61b8:	f7ff ff0e 	bl	5fd8 <sys_memcpy_swap.constprop.0>
    61bc:	e7e2      	b.n	6184 <ecc_thread+0x150>
			emulate_le_generate_dhkey();
		} else {
			__ASSERT(0, "Unhandled ECC command");
    61be:	4a10      	ldr	r2, [pc, #64]	; (6200 <ecc_thread+0x1cc>)
    61c0:	4910      	ldr	r1, [pc, #64]	; (6204 <ecc_thread+0x1d0>)
    61c2:	4811      	ldr	r0, [pc, #68]	; (6208 <ecc_thread+0x1d4>)
    61c4:	23d9      	movs	r3, #217	; 0xd9
    61c6:	f01d fe8c 	bl	23ee2 <printk>
    61ca:	4810      	ldr	r0, [pc, #64]	; (620c <ecc_thread+0x1d8>)
    61cc:	f01d fe89 	bl	23ee2 <printk>
    61d0:	480b      	ldr	r0, [pc, #44]	; (6200 <ecc_thread+0x1cc>)
    61d2:	21d9      	movs	r1, #217	; 0xd9
    61d4:	f01d fec8 	bl	23f68 <assert_post_action>
    61d8:	e736      	b.n	6048 <ecc_thread+0x14>
    61da:	bf00      	nop
    61dc:	000298f8 	.word	0x000298f8
    61e0:	00029830 	.word	0x00029830
    61e4:	2000241b 	.word	0x2000241b
    61e8:	00029da0 	.word	0x00029da0
    61ec:	2000243b 	.word	0x2000243b
    61f0:	0002b93c 	.word	0x0002b93c
    61f4:	2000245b 	.word	0x2000245b
    61f8:	00029cf0 	.word	0x00029cf0
    61fc:	0002b965 	.word	0x0002b965
    6200:	0002b986 	.word	0x0002b986
    6204:	0002e3c9 	.word	0x0002e3c9
    6208:	0002a5e8 	.word	0x0002a5e8
    620c:	0002b9b9 	.word	0x0002b9b9
    6210:	20000454 	.word	0x20000454
    6214:	200075c8 	.word	0x200075c8

00006218 <bt_hci_ecc_send>:

	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
}

int bt_hci_ecc_send(struct net_buf *buf)
{
    6218:	b570      	push	{r4, r5, r6, lr}
	 * pointer to an enum causes issues on qemu_x86 because the true
	 * size is 8-bit, but the enum is 32-bit on qemu_x86. So we put in
	 * a temporary cast to 8-bit to ensure only 8 bits are read from
	 * the pointer.
	 */
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    621a:	7d05      	ldrb	r5, [r0, #20]
    621c:	4604      	mov	r4, r0
	if (bt_buf_get_type(buf) == BT_BUF_CMD) {
    621e:	b9ad      	cbnz	r5, 624c <bt_hci_ecc_send+0x34>
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;
    6220:	6883      	ldr	r3, [r0, #8]

		switch (sys_le16_to_cpu(chdr->opcode)) {
    6222:	881a      	ldrh	r2, [r3, #0]
    6224:	f242 0125 	movw	r1, #8229	; 0x2025
    6228:	428a      	cmp	r2, r1
    622a:	d017      	beq.n	625c <bt_hci_ecc_send+0x44>
    622c:	f242 0126 	movw	r1, #8230	; 0x2026
    6230:	428a      	cmp	r2, r1
    6232:	d03c      	beq.n	62ae <bt_hci_ecc_send+0x96>
    6234:	f242 0101 	movw	r1, #8193	; 0x2001
    6238:	428a      	cmp	r2, r1
    623a:	d107      	bne.n	624c <bt_hci_ecc_send+0x34>
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
    623c:	78da      	ldrb	r2, [r3, #3]
    623e:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    6242:	70da      	strb	r2, [r3, #3]
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
    6244:	791a      	ldrb	r2, [r3, #4]
    6246:	f022 0201 	bic.w	r2, r2, #1
    624a:	711a      	strb	r2, [r3, #4]
		default:
			break;
		}
	}

	return bt_dev.drv->send(buf);
    624c:	4b32      	ldr	r3, [pc, #200]	; (6318 <bt_hci_ecc_send+0x100>)
    624e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
    6252:	4620      	mov	r0, r4
    6254:	691b      	ldr	r3, [r3, #16]
}
    6256:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_dev.drv->send(buf);
    625a:	4718      	bx	r3
			net_buf_pull(buf, sizeof(*chdr));
    625c:	2103      	movs	r1, #3
    625e:	3008      	adds	r0, #8
    6260:	f018 fff8 	bl	1f254 <net_buf_simple_pull>
	net_buf_unref(buf);
    6264:	4620      	mov	r0, r4
    6266:	f018 ff2f 	bl	1f0c8 <net_buf_unref>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    626a:	f3bf 8f5b 	dmb	ish
    626e:	4b2b      	ldr	r3, [pc, #172]	; (631c <bt_hci_ecc_send+0x104>)
    6270:	681a      	ldr	r2, [r3, #0]
    6272:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_DHKEY)) {
    6276:	0790      	lsls	r0, r2, #30
    6278:	d507      	bpl.n	628a <bt_hci_ecc_send+0x72>
		status = BT_HCI_ERR_CMD_DISALLOWED;
    627a:	250c      	movs	r5, #12
	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
    627c:	4629      	mov	r1, r5
    627e:	f242 0025 	movw	r0, #8229	; 0x2025
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
    6282:	f01f fde7 	bl	25e54 <send_cmd_status>
}
    6286:	2000      	movs	r0, #0
    6288:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    628a:	f3bf 8f5b 	dmb	ish
    628e:	e853 2f00 	ldrex	r2, [r3]
    6292:	f042 0101 	orr.w	r1, r2, #1
    6296:	e843 1000 	strex	r0, r1, [r3]
    629a:	2800      	cmp	r0, #0
    629c:	d1f7      	bne.n	628e <bt_hci_ecc_send+0x76>
    629e:	f3bf 8f5b 	dmb	ish
	} else if (atomic_test_and_set_bit(flags, PENDING_PUB_KEY)) {
    62a2:	07d1      	lsls	r1, r2, #31
    62a4:	d4e9      	bmi.n	627a <bt_hci_ecc_send+0x62>
	z_impl_k_sem_give(sem);
    62a6:	481e      	ldr	r0, [pc, #120]	; (6320 <bt_hci_ecc_send+0x108>)
    62a8:	f01c fa02 	bl	226b0 <z_impl_k_sem_give>
}
    62ac:	e7e6      	b.n	627c <bt_hci_ecc_send+0x64>
			net_buf_pull(buf, sizeof(*chdr));
    62ae:	2103      	movs	r1, #3
    62b0:	3008      	adds	r0, #8
    62b2:	f018 ffcf 	bl	1f254 <net_buf_simple_pull>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    62b6:	f3bf 8f5b 	dmb	ish
    62ba:	4b18      	ldr	r3, [pc, #96]	; (631c <bt_hci_ecc_send+0x104>)
    62bc:	681a      	ldr	r2, [r3, #0]
    62be:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
    62c2:	07d2      	lsls	r2, r2, #31
    62c4:	d507      	bpl.n	62d6 <bt_hci_ecc_send+0xbe>
		status = BT_HCI_ERR_CMD_DISALLOWED;
    62c6:	250c      	movs	r5, #12
	net_buf_unref(buf);
    62c8:	4620      	mov	r0, r4
    62ca:	f018 fefd 	bl	1f0c8 <net_buf_unref>
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
    62ce:	4629      	mov	r1, r5
    62d0:	f242 0026 	movw	r0, #8230	; 0x2026
    62d4:	e7d5      	b.n	6282 <bt_hci_ecc_send+0x6a>
	if (buf->len < sizeof(struct bt_hci_cp_le_generate_dhkey)) {
    62d6:	89a2      	ldrh	r2, [r4, #12]
    62d8:	2a3f      	cmp	r2, #63	; 0x3f
    62da:	d91b      	bls.n	6314 <bt_hci_ecc_send+0xfc>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    62dc:	f3bf 8f5b 	dmb	ish
    62e0:	e853 2f00 	ldrex	r2, [r3]
    62e4:	f042 0102 	orr.w	r1, r2, #2
    62e8:	e843 1000 	strex	r0, r1, [r3]
    62ec:	2800      	cmp	r0, #0
    62ee:	d1f7      	bne.n	62e0 <bt_hci_ecc_send+0xc8>
    62f0:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(flags, PENDING_DHKEY)) {
    62f4:	0793      	lsls	r3, r2, #30
    62f6:	d4e6      	bmi.n	62c6 <bt_hci_ecc_send+0xae>
	cmd = (void *)buf->data;
    62f8:	68a6      	ldr	r6, [r4, #8]
	sys_memcpy_swap(ecc.pk, cmd->key, 32);
    62fa:	480a      	ldr	r0, [pc, #40]	; (6324 <bt_hci_ecc_send+0x10c>)
    62fc:	4631      	mov	r1, r6
    62fe:	f7ff fe6b 	bl	5fd8 <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(&ecc.pk[32], &cmd->key[32], 32);
    6302:	4809      	ldr	r0, [pc, #36]	; (6328 <bt_hci_ecc_send+0x110>)
    6304:	f106 0120 	add.w	r1, r6, #32
    6308:	f7ff fe66 	bl	5fd8 <sys_memcpy_swap.constprop.0>
	z_impl_k_sem_give(sem);
    630c:	4804      	ldr	r0, [pc, #16]	; (6320 <bt_hci_ecc_send+0x108>)
    630e:	f01c f9cf 	bl	226b0 <z_impl_k_sem_give>
}
    6312:	e7d9      	b.n	62c8 <bt_hci_ecc_send+0xb0>
		status = BT_HCI_ERR_INVALID_PARAM;
    6314:	2512      	movs	r5, #18
    6316:	e7d7      	b.n	62c8 <bt_hci_ecc_send+0xb0>
    6318:	20006860 	.word	0x20006860
    631c:	20000454 	.word	0x20000454
    6320:	200075c8 	.word	0x200075c8
    6324:	2000243b 	.word	0x2000243b
    6328:	2000245b 	.word	0x2000245b

0000632c <bt_hci_ecc_init>:
{
	return !bt_rand(dst, len);
}

void bt_hci_ecc_init(void)
{
    632c:	b510      	push	{r4, lr}
    632e:	b086      	sub	sp, #24
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    6330:	4c0b      	ldr	r4, [pc, #44]	; (6360 <bt_hci_ecc_init+0x34>)
    6332:	490c      	ldr	r1, [pc, #48]	; (6364 <bt_hci_ecc_init+0x38>)
    6334:	2300      	movs	r3, #0
    6336:	220a      	movs	r2, #10
    6338:	e9cd 3202 	strd	r3, r2, [sp, #8]
    633c:	e9cd 3304 	strd	r3, r3, [sp, #16]
    6340:	e9cd 3300 	strd	r3, r3, [sp]
    6344:	f240 424c 	movw	r2, #1100	; 0x44c
    6348:	4b07      	ldr	r3, [pc, #28]	; (6368 <bt_hci_ecc_init+0x3c>)
    634a:	4620      	mov	r0, r4
    634c:	f01c faca 	bl	228e4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    6350:	4906      	ldr	r1, [pc, #24]	; (636c <bt_hci_ecc_init+0x40>)
    6352:	4620      	mov	r0, r4
	k_thread_create(&ecc_thread_data, ecc_thread_stack,
			K_THREAD_STACK_SIZEOF(ecc_thread_stack), ecc_thread,
			NULL, NULL, NULL, K_PRIO_PREEMPT(10), 0, K_NO_WAIT);
	k_thread_name_set(&ecc_thread_data, "BT ECC");
}
    6354:	b006      	add	sp, #24
    6356:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    635a:	f01c ba89 	b.w	22870 <z_impl_k_thread_name_set>
    635e:	bf00      	nop
    6360:	200003c0 	.word	0x200003c0
    6364:	20002800 	.word	0x20002800
    6368:	00006035 	.word	0x00006035
    636c:	0002b9d1 	.word	0x0002b9d1

00006370 <save_id>:
}

#define ID_DATA_LEN(array) (bt_dev.id_count * sizeof(array[0]))

static void save_id(struct k_work *work)
{
    6370:	b510      	push	{r4, lr}
    6372:	4b0d      	ldr	r3, [pc, #52]	; (63a8 <save_id+0x38>)
    6374:	4c0d      	ldr	r4, [pc, #52]	; (63ac <save_id+0x3c>)
	int err;
	BT_INFO("Saving ID");
    6376:	480e      	ldr	r0, [pc, #56]	; (63b0 <save_id+0x40>)
    6378:	1ae4      	subs	r4, r4, r3
    637a:	08e4      	lsrs	r4, r4, #3
    637c:	01a4      	lsls	r4, r4, #6
    637e:	f044 0103 	orr.w	r1, r4, #3
    6382:	f01d fe1f 	bl	23fc4 <log_0>
	err = settings_save_one("bt/id", &bt_dev.id_addr,
				ID_DATA_LEN(bt_dev.id_addr));
    6386:	490b      	ldr	r1, [pc, #44]	; (63b4 <save_id+0x44>)
	err = settings_save_one("bt/id", &bt_dev.id_addr,
    6388:	480b      	ldr	r0, [pc, #44]	; (63b8 <save_id+0x48>)
    638a:	79ca      	ldrb	r2, [r1, #7]
    638c:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
    6390:	f7fd fac4 	bl	391c <settings_save_one>
	if (err) {
    6394:	4601      	mov	r1, r0
    6396:	b130      	cbz	r0, 63a6 <save_id+0x36>
		BT_ERR("Failed to save ID (err %d)", err);
    6398:	f044 0201 	orr.w	r2, r4, #1
    639c:	4807      	ldr	r0, [pc, #28]	; (63bc <save_id+0x4c>)
	err = settings_save_one("bt/irk", bt_dev.irk, ID_DATA_LEN(bt_dev.irk));
	if (err) {
		BT_ERR("Failed to save IRK (err %d)", err);
	}
#endif
}
    639e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_ERR("Failed to save ID (err %d)", err);
    63a2:	f01d be1c 	b.w	23fde <log_1>
}
    63a6:	bd10      	pop	{r4, pc}
    63a8:	00029830 	.word	0x00029830
    63ac:	00029990 	.word	0x00029990
    63b0:	0002b9e3 	.word	0x0002b9e3
    63b4:	20006860 	.word	0x20006860
    63b8:	0002b9ed 	.word	0x0002b9ed
    63bc:	0002b9f3 	.word	0x0002b9f3

000063c0 <set>:
{
    63c0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    63c4:	4605      	mov	r5, r0
    63c6:	4616      	mov	r6, r2
    63c8:	461f      	mov	r7, r3
	if (!name) {
    63ca:	b960      	cbnz	r0, 63e6 <set+0x26>
    63cc:	4934      	ldr	r1, [pc, #208]	; (64a0 <set+0xe0>)
    63ce:	4b35      	ldr	r3, [pc, #212]	; (64a4 <set+0xe4>)
		BT_ERR("Insufficient number of arguments");
    63d0:	4835      	ldr	r0, [pc, #212]	; (64a8 <set+0xe8>)
    63d2:	1ac9      	subs	r1, r1, r3
    63d4:	08c9      	lsrs	r1, r1, #3
    63d6:	0189      	lsls	r1, r1, #6
    63d8:	f041 0101 	orr.w	r1, r1, #1
    63dc:	f01d fdf2 	bl	23fc4 <log_0>
	return -ENOENT;
    63e0:	f06f 0401 	mvn.w	r4, #1
    63e4:	e01c      	b.n	6420 <set+0x60>
	len = settings_name_next(name, &next);
    63e6:	a901      	add	r1, sp, #4
    63e8:	f01e f9c9 	bl	2477e <settings_name_next>
	if (!strncmp(name, "id", len)) {
    63ec:	492f      	ldr	r1, [pc, #188]	; (64ac <set+0xec>)
    63ee:	4602      	mov	r2, r0
	len = settings_name_next(name, &next);
    63f0:	4680      	mov	r8, r0
	if (!strncmp(name, "id", len)) {
    63f2:	4628      	mov	r0, r5
    63f4:	f01f fc39 	bl	25c6a <strncmp>
    63f8:	4604      	mov	r4, r0
    63fa:	bb90      	cbnz	r0, 6462 <set+0xa2>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    63fc:	f3bf 8f5b 	dmb	ish
    6400:	4d2b      	ldr	r5, [pc, #172]	; (64b0 <set+0xf0>)
    6402:	682b      	ldr	r3, [r5, #0]
    6404:	f3bf 8f5b 	dmb	ish
		if (atomic_test_bit(bt_dev.flags, BT_DEV_PRESET_ID)) {
    6408:	075b      	lsls	r3, r3, #29
    640a:	d50d      	bpl.n	6428 <set+0x68>
    640c:	4924      	ldr	r1, [pc, #144]	; (64a0 <set+0xe0>)
    640e:	4b25      	ldr	r3, [pc, #148]	; (64a4 <set+0xe4>)
			BT_WARN("Ignoring identities stored in flash");
    6410:	4828      	ldr	r0, [pc, #160]	; (64b4 <set+0xf4>)
    6412:	1ac9      	subs	r1, r1, r3
    6414:	08c9      	lsrs	r1, r1, #3
    6416:	0189      	lsls	r1, r1, #6
    6418:	f041 0102 	orr.w	r1, r1, #2
    641c:	f01d fdd2 	bl	23fc4 <log_0>
}
    6420:	4620      	mov	r0, r4
    6422:	b002      	add	sp, #8
    6424:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		len = read_cb(cb_arg, &bt_dev.id_addr, sizeof(bt_dev.id_addr));
    6428:	3d8c      	subs	r5, #140	; 0x8c
    642a:	2207      	movs	r2, #7
    642c:	4629      	mov	r1, r5
    642e:	4638      	mov	r0, r7
    6430:	47b0      	blx	r6
		if (len < sizeof(bt_dev.id_addr[0])) {
    6432:	2806      	cmp	r0, #6
    6434:	d810      	bhi.n	6458 <set+0x98>
    6436:	4b1b      	ldr	r3, [pc, #108]	; (64a4 <set+0xe4>)
    6438:	4919      	ldr	r1, [pc, #100]	; (64a0 <set+0xe0>)
				BT_ERR("Invalid length ID address in storage");
    643a:	481f      	ldr	r0, [pc, #124]	; (64b8 <set+0xf8>)
    643c:	1ac9      	subs	r1, r1, r3
    643e:	08c9      	lsrs	r1, r1, #3
    6440:	0189      	lsls	r1, r1, #6
    6442:	f041 0101 	orr.w	r1, r1, #1
    6446:	f01d fdbd 	bl	23fc4 <log_0>
			(void)memset(bt_dev.id_addr, 0,
    644a:	2207      	movs	r2, #7
    644c:	4621      	mov	r1, r4
    644e:	4628      	mov	r0, r5
    6450:	f01f fc55 	bl	25cfe <memset>
			bt_dev.id_count = 0U;
    6454:	71ec      	strb	r4, [r5, #7]
    6456:	e7e3      	b.n	6420 <set+0x60>
			bt_dev.id_count = len / sizeof(bt_dev.id_addr[0]);
    6458:	2307      	movs	r3, #7
    645a:	fbb0 f0f3 	udiv	r0, r0, r3
    645e:	71e8      	strb	r0, [r5, #7]
			for (i = 0; i < bt_dev.id_count; i++) {
    6460:	e7de      	b.n	6420 <set+0x60>
	if (!strncmp(name, "name", len)) {
    6462:	4916      	ldr	r1, [pc, #88]	; (64bc <set+0xfc>)
    6464:	4642      	mov	r2, r8
    6466:	4628      	mov	r0, r5
    6468:	f01f fbff 	bl	25c6a <strncmp>
    646c:	4604      	mov	r4, r0
    646e:	2800      	cmp	r0, #0
    6470:	d1b6      	bne.n	63e0 <set+0x20>
		len = read_cb(cb_arg, &bt_dev.name, sizeof(bt_dev.name) - 1);
    6472:	4913      	ldr	r1, [pc, #76]	; (64c0 <set+0x100>)
    6474:	221c      	movs	r2, #28
    6476:	4638      	mov	r0, r7
    6478:	47b0      	blx	r6
		if (len < 0) {
    647a:	1e01      	subs	r1, r0, #0
    647c:	da0a      	bge.n	6494 <set+0xd4>
    647e:	4b09      	ldr	r3, [pc, #36]	; (64a4 <set+0xe4>)
    6480:	4a07      	ldr	r2, [pc, #28]	; (64a0 <set+0xe0>)
			BT_ERR("Failed to read device name from storage"
    6482:	4810      	ldr	r0, [pc, #64]	; (64c4 <set+0x104>)
    6484:	1ad2      	subs	r2, r2, r3
    6486:	08d2      	lsrs	r2, r2, #3
    6488:	0192      	lsls	r2, r2, #6
    648a:	f042 0201 	orr.w	r2, r2, #1
    648e:	f01d fda6 	bl	23fde <log_1>
    6492:	e7c5      	b.n	6420 <set+0x60>
			bt_dev.name[len] = '\0';
    6494:	480c      	ldr	r0, [pc, #48]	; (64c8 <set+0x108>)
    6496:	4401      	add	r1, r0
    6498:	f881 40f4 	strb.w	r4, [r1, #244]	; 0xf4
			BT_DBG("Name set to %s", log_strdup(bt_dev.name));
    649c:	e7c0      	b.n	6420 <set+0x60>
    649e:	bf00      	nop
    64a0:	00029990 	.word	0x00029990
    64a4:	00029830 	.word	0x00029830
    64a8:	0002ba0e 	.word	0x0002ba0e
    64ac:	0002b84b 	.word	0x0002b84b
    64b0:	200068ec 	.word	0x200068ec
    64b4:	0002ba2f 	.word	0x0002ba2f
    64b8:	0002ba53 	.word	0x0002ba53
    64bc:	0002c185 	.word	0x0002c185
    64c0:	20006954 	.word	0x20006954
    64c4:	0002ba78 	.word	0x0002ba78
    64c8:	20006860 	.word	0x20006860

000064cc <bt_settings_encode_key>:
{
    64cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    64d0:	b088      	sub	sp, #32
    64d2:	799c      	ldrb	r4, [r3, #6]
    64d4:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
    64d8:	795d      	ldrb	r5, [r3, #5]
    64da:	791e      	ldrb	r6, [r3, #4]
    64dc:	78df      	ldrb	r7, [r3, #3]
    64de:	f893 c002 	ldrb.w	ip, [r3, #2]
    64e2:	f893 e001 	ldrb.w	lr, [r3, #1]
    64e6:	781b      	ldrb	r3, [r3, #0]
	if (key) {
    64e8:	f1b8 0f00 	cmp.w	r8, #0
    64ec:	d00e      	beq.n	650c <bt_settings_encode_key+0x40>
		snprintk(path, path_size,
    64ee:	e9cd 3806 	strd	r3, r8, [sp, #24]
    64f2:	e9cd ce04 	strd	ip, lr, [sp, #16]
    64f6:	4613      	mov	r3, r2
    64f8:	e9cd 6702 	strd	r6, r7, [sp, #8]
    64fc:	e9cd 4500 	strd	r4, r5, [sp]
    6500:	4a08      	ldr	r2, [pc, #32]	; (6524 <bt_settings_encode_key+0x58>)
    6502:	f01d fcfb 	bl	23efc <snprintk>
}
    6506:	b008      	add	sp, #32
    6508:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		snprintk(path, path_size,
    650c:	e9cd e305 	strd	lr, r3, [sp, #20]
    6510:	e9cd 7c03 	strd	r7, ip, [sp, #12]
    6514:	4613      	mov	r3, r2
    6516:	e9cd 5601 	strd	r5, r6, [sp, #4]
    651a:	4a03      	ldr	r2, [pc, #12]	; (6528 <bt_settings_encode_key+0x5c>)
    651c:	9400      	str	r4, [sp, #0]
    651e:	f01d fced 	bl	23efc <snprintk>
}
    6522:	e7f0      	b.n	6506 <bt_settings_encode_key+0x3a>
    6524:	0002baaa 	.word	0x0002baaa
    6528:	0002bace 	.word	0x0002bace

0000652c <bt_settings_save_id>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    652c:	4909      	ldr	r1, [pc, #36]	; (6554 <bt_settings_save_id+0x28>)
    652e:	f3bf 8f5b 	dmb	ish
    6532:	e851 3f00 	ldrex	r3, [r1]
    6536:	f043 0201 	orr.w	r2, r3, #1
    653a:	e841 2000 	strex	r0, r2, [r1]
    653e:	2800      	cmp	r0, #0
    6540:	d1f7      	bne.n	6532 <bt_settings_save_id+0x6>
    6542:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    6546:	07db      	lsls	r3, r3, #31
    6548:	d403      	bmi.n	6552 <bt_settings_save_id+0x26>
		k_queue_append(&work_q->queue, work);
    654a:	4803      	ldr	r0, [pc, #12]	; (6558 <bt_settings_save_id+0x2c>)
    654c:	3908      	subs	r1, #8
    654e:	f022 be80 	b.w	29252 <k_queue_append>
K_WORK_DEFINE(save_id_work, save_id);

void bt_settings_save_id(void)
{
	k_work_submit(&save_id_work);
}
    6552:	4770      	bx	lr
    6554:	20006ac0 	.word	0x20006ac0
    6558:	20001dc4 	.word	0x20001dc4

0000655c <commit>:

static int commit(void)
{
    655c:	b538      	push	{r3, r4, r5, lr}
	BT_DBG("");

#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	if (bt_dev.name[0] == '\0') {
    655e:	4c1d      	ldr	r4, [pc, #116]	; (65d4 <commit+0x78>)
    6560:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
    6564:	b913      	cbnz	r3, 656c <commit+0x10>
		bt_set_name(CONFIG_BT_DEVICE_NAME);
    6566:	481c      	ldr	r0, [pc, #112]	; (65d8 <commit+0x7c>)
    6568:	f001 fcda 	bl	7f20 <bt_set_name>
	}
#endif
	if (!bt_dev.id_count) {
    656c:	79e3      	ldrb	r3, [r4, #7]
    656e:	b99b      	cbnz	r3, 6598 <commit+0x3c>
		bt_setup_public_id_addr();
    6570:	f001 fd6e 	bl	8050 <bt_setup_public_id_addr>
	}

	if (!bt_dev.id_count) {
    6574:	79e3      	ldrb	r3, [r4, #7]
    6576:	b97b      	cbnz	r3, 6598 <commit+0x3c>
		int err;

		err = bt_setup_random_id_addr();
    6578:	f001 fe14 	bl	81a4 <bt_setup_random_id_addr>
		if (err) {
    657c:	4604      	mov	r4, r0
    657e:	b158      	cbz	r0, 6598 <commit+0x3c>
    6580:	4916      	ldr	r1, [pc, #88]	; (65dc <commit+0x80>)
    6582:	4b17      	ldr	r3, [pc, #92]	; (65e0 <commit+0x84>)
			BT_ERR("Unable to setup an identity address");
    6584:	4817      	ldr	r0, [pc, #92]	; (65e4 <commit+0x88>)
    6586:	1ac9      	subs	r1, r1, r3
    6588:	08c9      	lsrs	r1, r1, #3
    658a:	0189      	lsls	r1, r1, #6
    658c:	f041 0101 	orr.w	r1, r1, #1
    6590:	f01d fd18 	bl	23fc4 <log_0>
		BT_DBG("Storing Identity Information");
		bt_settings_save_id();
	}

	return 0;
}
    6594:	4620      	mov	r0, r4
    6596:	bd38      	pop	{r3, r4, r5, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    6598:	4d13      	ldr	r5, [pc, #76]	; (65e8 <commit+0x8c>)
    659a:	f3bf 8f5b 	dmb	ish
    659e:	682b      	ldr	r3, [r5, #0]
    65a0:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    65a4:	079b      	lsls	r3, r3, #30
    65a6:	d401      	bmi.n	65ac <commit+0x50>
		bt_finalize_init();
    65a8:	f001 f99e 	bl	78e8 <bt_finalize_init>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    65ac:	f3bf 8f5b 	dmb	ish
    65b0:	e855 4f00 	ldrex	r4, [r5]
    65b4:	f424 1380 	bic.w	r3, r4, #1048576	; 0x100000
    65b8:	e845 3200 	strex	r2, r3, [r5]
    65bc:	2a00      	cmp	r2, #0
    65be:	d1f7      	bne.n	65b0 <commit+0x54>
    65c0:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_STORE_ID)) {
    65c4:	f414 1480 	ands.w	r4, r4, #1048576	; 0x100000
    65c8:	d0e4      	beq.n	6594 <commit+0x38>
		bt_settings_save_id();
    65ca:	f7ff ffaf 	bl	652c <bt_settings_save_id>
	return 0;
    65ce:	2400      	movs	r4, #0
    65d0:	e7e0      	b.n	6594 <commit+0x38>
    65d2:	bf00      	nop
    65d4:	20006860 	.word	0x20006860
    65d8:	0002baef 	.word	0x0002baef
    65dc:	00029990 	.word	0x00029990
    65e0:	00029830 	.word	0x00029830
    65e4:	0002baf6 	.word	0x0002baf6
    65e8:	200068ec 	.word	0x200068ec

000065ec <bt_settings_init>:

SETTINGS_STATIC_HANDLER_DEFINE(bt, "bt", NULL, set, commit, NULL);

int bt_settings_init(void)
{
    65ec:	b510      	push	{r4, lr}
	int err;

	BT_DBG("");

	err = settings_subsys_init();
    65ee:	f7fd fb31 	bl	3c54 <settings_subsys_init>
	if (err) {
    65f2:	4604      	mov	r4, r0
    65f4:	b150      	cbz	r0, 660c <bt_settings_init+0x20>
    65f6:	4a06      	ldr	r2, [pc, #24]	; (6610 <bt_settings_init+0x24>)
    65f8:	4b06      	ldr	r3, [pc, #24]	; (6614 <bt_settings_init+0x28>)
    65fa:	1ad2      	subs	r2, r2, r3
    65fc:	08d2      	lsrs	r2, r2, #3
		BT_ERR("settings_subsys_init failed (err %d)", err);
    65fe:	0192      	lsls	r2, r2, #6
    6600:	4601      	mov	r1, r0
    6602:	f042 0201 	orr.w	r2, r2, #1
    6606:	4804      	ldr	r0, [pc, #16]	; (6618 <bt_settings_init+0x2c>)
    6608:	f01d fce9 	bl	23fde <log_1>
		return err;
	}

	return 0;
}
    660c:	4620      	mov	r0, r4
    660e:	bd10      	pop	{r4, pc}
    6610:	00029990 	.word	0x00029990
    6614:	00029830 	.word	0x00029830
    6618:	0002bb1a 	.word	0x0002bb1a

0000661c <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
    661c:	b4f0      	push	{r4, r5, r6, r7}
	switch (src->type) {
    661e:	7802      	ldrb	r2, [r0, #0]
    6620:	2a01      	cmp	r2, #1
{
    6622:	4604      	mov	r4, r0
    6624:	460b      	mov	r3, r1
	switch (src->type) {
    6626:	d016      	beq.n	6656 <uuid_to_uuid128+0x3a>
    6628:	2a02      	cmp	r2, #2
    662a:	d02c      	beq.n	6686 <uuid_to_uuid128+0x6a>
    662c:	b98a      	cbnz	r2, 6652 <uuid_to_uuid128+0x36>
	case BT_UUID_TYPE_16:
		*dst = uuid128_base;
    662e:	4a19      	ldr	r2, [pc, #100]	; (6694 <uuid_to_uuid128+0x78>)
    6630:	460d      	mov	r5, r1
    6632:	f102 0710 	add.w	r7, r2, #16
    6636:	6810      	ldr	r0, [r2, #0]
    6638:	6851      	ldr	r1, [r2, #4]
    663a:	462e      	mov	r6, r5
    663c:	c603      	stmia	r6!, {r0, r1}
    663e:	3208      	adds	r2, #8
    6640:	42ba      	cmp	r2, r7
    6642:	4635      	mov	r5, r6
    6644:	d1f7      	bne.n	6636 <uuid_to_uuid128+0x1a>
    6646:	7812      	ldrb	r2, [r2, #0]
    6648:	7032      	strb	r2, [r6, #0]
		sys_put_le16(BT_UUID_16(src)->val,
    664a:	8862      	ldrh	r2, [r4, #2]
	dst[0] = val;
    664c:	735a      	strb	r2, [r3, #13]
	dst[1] = val >> 8;
    664e:	0a12      	lsrs	r2, r2, #8
    6650:	739a      	strb	r2, [r3, #14]
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
    6652:	bcf0      	pop	{r4, r5, r6, r7}
    6654:	4770      	bx	lr
		*dst = uuid128_base;
    6656:	4a0f      	ldr	r2, [pc, #60]	; (6694 <uuid_to_uuid128+0x78>)
    6658:	460d      	mov	r5, r1
    665a:	f102 0710 	add.w	r7, r2, #16
    665e:	6810      	ldr	r0, [r2, #0]
    6660:	6851      	ldr	r1, [r2, #4]
    6662:	462e      	mov	r6, r5
    6664:	c603      	stmia	r6!, {r0, r1}
    6666:	3208      	adds	r2, #8
    6668:	42ba      	cmp	r2, r7
    666a:	4635      	mov	r5, r6
    666c:	d1f7      	bne.n	665e <uuid_to_uuid128+0x42>
    666e:	7812      	ldrb	r2, [r2, #0]
    6670:	7032      	strb	r2, [r6, #0]
		sys_put_le32(BT_UUID_32(src)->val,
    6672:	6862      	ldr	r2, [r4, #4]
	dst[0] = val;
    6674:	735a      	strb	r2, [r3, #13]
	dst[1] = val >> 8;
    6676:	f3c2 2107 	ubfx	r1, r2, #8, #8
	sys_put_le16(val >> 16, &dst[2]);
    667a:	0c12      	lsrs	r2, r2, #16
	dst[0] = val;
    667c:	73da      	strb	r2, [r3, #15]
	dst[1] = val >> 8;
    667e:	0a12      	lsrs	r2, r2, #8
    6680:	7399      	strb	r1, [r3, #14]
    6682:	741a      	strb	r2, [r3, #16]
}
    6684:	e7e5      	b.n	6652 <uuid_to_uuid128+0x36>
		memcpy(dst, src, sizeof(*dst));
    6686:	4601      	mov	r1, r0
}
    6688:	bcf0      	pop	{r4, r5, r6, r7}
		memcpy(dst, src, sizeof(*dst));
    668a:	2211      	movs	r2, #17
    668c:	4618      	mov	r0, r3
    668e:	f01f bb0b 	b.w	25ca8 <memcpy>
    6692:	bf00      	nop
    6694:	0002bb76 	.word	0x0002bb76

00006698 <bt_uuid_to_str>:
	}
	return true;
}

void bt_uuid_to_str(const struct bt_uuid *uuid, char *str, size_t len)
{
    6698:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t tmp1, tmp5;
	u16_t tmp0, tmp2, tmp3, tmp4;

	switch (uuid->type) {
    669a:	7805      	ldrb	r5, [r0, #0]
    669c:	2d01      	cmp	r5, #1
{
    669e:	b08b      	sub	sp, #44	; 0x2c
    66a0:	4604      	mov	r4, r0
    66a2:	460e      	mov	r6, r1
    66a4:	4617      	mov	r7, r2
	switch (uuid->type) {
    66a6:	d00b      	beq.n	66c0 <bt_uuid_to_str+0x28>
    66a8:	2d02      	cmp	r5, #2
    66aa:	d00c      	beq.n	66c6 <bt_uuid_to_str+0x2e>
    66ac:	2d00      	cmp	r5, #0
    66ae:	d142      	bne.n	6736 <bt_uuid_to_str+0x9e>
	case BT_UUID_TYPE_16:
		snprintk(str, len, "%04x", BT_UUID_16(uuid)->val);
    66b0:	8843      	ldrh	r3, [r0, #2]
    66b2:	4a23      	ldr	r2, [pc, #140]	; (6740 <bt_uuid_to_str+0xa8>)
		break;
	case BT_UUID_TYPE_32:
		snprintk(str, len, "%08x", BT_UUID_32(uuid)->val);
    66b4:	4639      	mov	r1, r7
    66b6:	4630      	mov	r0, r6
    66b8:	f01d fc20 	bl	23efc <snprintk>
		break;
	default:
		(void)memset(str, 0, len);
		return;
	}
}
    66bc:	b00b      	add	sp, #44	; 0x2c
    66be:	bdf0      	pop	{r4, r5, r6, r7, pc}
		snprintk(str, len, "%08x", BT_UUID_32(uuid)->val);
    66c0:	6843      	ldr	r3, [r0, #4]
    66c2:	4a20      	ldr	r2, [pc, #128]	; (6744 <bt_uuid_to_str+0xac>)
    66c4:	e7f6      	b.n	66b4 <bt_uuid_to_str+0x1c>
		memcpy(&tmp0, &BT_UUID_128(uuid)->val[0], sizeof(tmp0));
    66c6:	462a      	mov	r2, r5
    66c8:	1c41      	adds	r1, r0, #1
    66ca:	a806      	add	r0, sp, #24
    66cc:	f01f faec 	bl	25ca8 <memcpy>
		memcpy(&tmp1, &BT_UUID_128(uuid)->val[2], sizeof(tmp1));
    66d0:	1ce1      	adds	r1, r4, #3
    66d2:	2204      	movs	r2, #4
    66d4:	a808      	add	r0, sp, #32
    66d6:	f01f fae7 	bl	25ca8 <memcpy>
		memcpy(&tmp2, &BT_UUID_128(uuid)->val[6], sizeof(tmp2));
    66da:	462a      	mov	r2, r5
    66dc:	1de1      	adds	r1, r4, #7
    66de:	f10d 001a 	add.w	r0, sp, #26
    66e2:	f01f fae1 	bl	25ca8 <memcpy>
		memcpy(&tmp3, &BT_UUID_128(uuid)->val[8], sizeof(tmp3));
    66e6:	462a      	mov	r2, r5
    66e8:	f104 0109 	add.w	r1, r4, #9
    66ec:	a807      	add	r0, sp, #28
    66ee:	f01f fadb 	bl	25ca8 <memcpy>
		memcpy(&tmp4, &BT_UUID_128(uuid)->val[10], sizeof(tmp4));
    66f2:	462a      	mov	r2, r5
    66f4:	f104 010b 	add.w	r1, r4, #11
    66f8:	f10d 001e 	add.w	r0, sp, #30
    66fc:	f01f fad4 	bl	25ca8 <memcpy>
		memcpy(&tmp5, &BT_UUID_128(uuid)->val[12], sizeof(tmp5));
    6700:	f104 010d 	add.w	r1, r4, #13
    6704:	2204      	movs	r2, #4
    6706:	a809      	add	r0, sp, #36	; 0x24
    6708:	f01f face 	bl	25ca8 <memcpy>
		snprintk(str, len, "%08x-%04x-%04x-%04x-%08x%04x",
    670c:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    6710:	9304      	str	r3, [sp, #16]
    6712:	9b08      	ldr	r3, [sp, #32]
    6714:	9303      	str	r3, [sp, #12]
    6716:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    671a:	9302      	str	r3, [sp, #8]
    671c:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    6720:	9301      	str	r3, [sp, #4]
    6722:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    6726:	9300      	str	r3, [sp, #0]
    6728:	4a07      	ldr	r2, [pc, #28]	; (6748 <bt_uuid_to_str+0xb0>)
    672a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    672c:	4639      	mov	r1, r7
    672e:	4630      	mov	r0, r6
    6730:	f01d fbe4 	bl	23efc <snprintk>
		break;
    6734:	e7c2      	b.n	66bc <bt_uuid_to_str+0x24>
		(void)memset(str, 0, len);
    6736:	2100      	movs	r1, #0
    6738:	4630      	mov	r0, r6
    673a:	f01f fae0 	bl	25cfe <memset>
		return;
    673e:	e7bd      	b.n	66bc <bt_uuid_to_str+0x24>
    6740:	0002ccc0 	.word	0x0002ccc0
    6744:	0002b1bf 	.word	0x0002b1bf
    6748:	0002bb59 	.word	0x0002bb59

0000674c <le_dhkey_complete>:

	pub_key_cb = NULL;
}

static void le_dhkey_complete(struct net_buf *buf)
{
    674c:	b510      	push	{r4, lr}
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;

	BT_DBG("status: 0x%02x", evt->status);

	if (dh_key_cb) {
    674e:	4c06      	ldr	r4, [pc, #24]	; (6768 <le_dhkey_complete+0x1c>)
    6750:	6822      	ldr	r2, [r4, #0]
    6752:	b132      	cbz	r2, 6762 <le_dhkey_complete+0x16>
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;
    6754:	6880      	ldr	r0, [r0, #8]
		dh_key_cb(evt->status ? NULL : evt->dhkey);
    6756:	7803      	ldrb	r3, [r0, #0]
    6758:	b923      	cbnz	r3, 6764 <le_dhkey_complete+0x18>
    675a:	3001      	adds	r0, #1
    675c:	4790      	blx	r2
		dh_key_cb = NULL;
    675e:	2300      	movs	r3, #0
    6760:	6023      	str	r3, [r4, #0]
	}
}
    6762:	bd10      	pop	{r4, pc}
		dh_key_cb(evt->status ? NULL : evt->dhkey);
    6764:	2000      	movs	r0, #0
    6766:	e7f9      	b.n	675c <le_dhkey_complete+0x10>
    6768:	20000470 	.word	0x20000470

0000676c <ver_str>:
	return 1U;
}

#if defined(CONFIG_BT_DEBUG)
static const char *ver_str(u8_t ver)
{
    676c:	b570      	push	{r4, r5, r6, lr}
	const char * const str[] = {
    676e:	4d0b      	ldr	r5, [pc, #44]	; (679c <ver_str+0x30>)
{
    6770:	4606      	mov	r6, r0
	const char * const str[] = {
    6772:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    6774:	b08c      	sub	sp, #48	; 0x30
	const char * const str[] = {
    6776:	466c      	mov	r4, sp
    6778:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    677a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    677c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    677e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    6782:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		"1.0b", "1.1", "1.2", "2.0", "2.1", "3.0", "4.0", "4.1", "4.2",
		"5.0", "5.1", "5.2"
	};

	if (ver < ARRAY_SIZE(str)) {
    6786:	2e0b      	cmp	r6, #11
		return str[ver];
    6788:	bf9b      	ittet	ls
    678a:	ab0c      	addls	r3, sp, #48	; 0x30
    678c:	eb03 0686 	addls.w	r6, r3, r6, lsl #2
	}

	return "unknown";
    6790:	4803      	ldrhi	r0, [pc, #12]	; (67a0 <ver_str+0x34>)
		return str[ver];
    6792:	f856 0c30 	ldrls.w	r0, [r6, #-48]
}
    6796:	b00c      	add	sp, #48	; 0x30
    6798:	bd70      	pop	{r4, r5, r6, pc}
    679a:	bf00      	nop
    679c:	00029a3c 	.word	0x00029a3c
    67a0:	0002bc72 	.word	0x0002bc72

000067a4 <hci_data_buf_overflow>:
    67a4:	4905      	ldr	r1, [pc, #20]	; (67bc <hci_data_buf_overflow+0x18>)
    67a6:	4a06      	ldr	r2, [pc, #24]	; (67c0 <hci_data_buf_overflow+0x1c>)
	struct bt_hci_evt_data_buf_overflow *evt = (void *)buf->data;
    67a8:	6883      	ldr	r3, [r0, #8]
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    67aa:	4806      	ldr	r0, [pc, #24]	; (67c4 <hci_data_buf_overflow+0x20>)
    67ac:	1a52      	subs	r2, r2, r1
    67ae:	08d2      	lsrs	r2, r2, #3
    67b0:	0192      	lsls	r2, r2, #6
    67b2:	7819      	ldrb	r1, [r3, #0]
    67b4:	f042 0202 	orr.w	r2, r2, #2
    67b8:	f01d bc11 	b.w	23fde <log_1>
    67bc:	00029830 	.word	0x00029830
    67c0:	000298f0 	.word	0x000298f0
    67c4:	0002bc7a 	.word	0x0002bc7a

000067c8 <le_pkey_complete>:
{
    67c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_p256_public_key_complete *evt = (void *)buf->data;
    67ca:	6886      	ldr	r6, [r0, #8]
 */
static inline void atomic_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    67cc:	480f      	ldr	r0, [pc, #60]	; (680c <le_pkey_complete+0x44>)
    67ce:	f06f 0110 	mvn.w	r1, #16
    67d2:	f01f fdae 	bl	26332 <atomic_and>
	if (!evt->status) {
    67d6:	7833      	ldrb	r3, [r6, #0]
    67d8:	b943      	cbnz	r3, 67ec <le_pkey_complete+0x24>
		memcpy(pub_key, evt->key, 64);
    67da:	1c71      	adds	r1, r6, #1
    67dc:	480c      	ldr	r0, [pc, #48]	; (6810 <le_pkey_complete+0x48>)
    67de:	2240      	movs	r2, #64	; 0x40
    67e0:	f01f fa62 	bl	25ca8 <memcpy>
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    67e4:	4809      	ldr	r0, [pc, #36]	; (680c <le_pkey_complete+0x44>)
    67e6:	2108      	movs	r1, #8
    67e8:	f01f fd89 	bl	262fe <atomic_or>
	for (cb = pub_key_cb; cb; cb = cb->_next) {
    67ec:	4d09      	ldr	r5, [pc, #36]	; (6814 <le_pkey_complete+0x4c>)
		cb->func(evt->status ? NULL : pub_key);
    67ee:	4f08      	ldr	r7, [pc, #32]	; (6810 <le_pkey_complete+0x48>)
	for (cb = pub_key_cb; cb; cb = cb->_next) {
    67f0:	682c      	ldr	r4, [r5, #0]
    67f2:	b90c      	cbnz	r4, 67f8 <le_pkey_complete+0x30>
	pub_key_cb = NULL;
    67f4:	602c      	str	r4, [r5, #0]
}
    67f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		cb->func(evt->status ? NULL : pub_key);
    67f8:	7832      	ldrb	r2, [r6, #0]
    67fa:	6823      	ldr	r3, [r4, #0]
    67fc:	2a00      	cmp	r2, #0
    67fe:	bf0c      	ite	eq
    6800:	4638      	moveq	r0, r7
    6802:	2000      	movne	r0, #0
    6804:	4798      	blx	r3
	for (cb = pub_key_cb; cb; cb = cb->_next) {
    6806:	6864      	ldr	r4, [r4, #4]
    6808:	e7f3      	b.n	67f2 <le_pkey_complete+0x2a>
    680a:	bf00      	nop
    680c:	200068ec 	.word	0x200068ec
    6810:	2000247b 	.word	0x2000247b
    6814:	20000474 	.word	0x20000474

00006818 <le_conn_update_complete>:
{
    6818:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
    681a:	6885      	ldr	r5, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    681c:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    6820:	4630      	mov	r0, r6
    6822:	f002 fd6d 	bl	9300 <bt_conn_lookup_handle>
	if (!conn) {
    6826:	4604      	mov	r4, r0
    6828:	b960      	cbnz	r0, 6844 <le_conn_update_complete+0x2c>
    682a:	4a1e      	ldr	r2, [pc, #120]	; (68a4 <le_conn_update_complete+0x8c>)
    682c:	4b1e      	ldr	r3, [pc, #120]	; (68a8 <le_conn_update_complete+0x90>)
		BT_ERR("Unable to lookup conn for handle %u", handle);
    682e:	481f      	ldr	r0, [pc, #124]	; (68ac <le_conn_update_complete+0x94>)
    6830:	1ad2      	subs	r2, r2, r3
    6832:	08d2      	lsrs	r2, r2, #3
    6834:	0192      	lsls	r2, r2, #6
    6836:	f042 0201 	orr.w	r2, r2, #1
    683a:	4631      	mov	r1, r6
    683c:	f01d fbcf 	bl	23fde <log_1>
}
    6840:	b002      	add	sp, #8
    6842:	bd70      	pop	{r4, r5, r6, pc}
	if (!evt->status) {
    6844:	782b      	ldrb	r3, [r5, #0]
    6846:	b9bb      	cbnz	r3, 6878 <le_conn_update_complete+0x60>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
    6848:	792a      	ldrb	r2, [r5, #4]
    684a:	78eb      	ldrb	r3, [r5, #3]
    684c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    6850:	f8a0 308a 	strh.w	r3, [r0, #138]	; 0x8a
		conn->le.latency = sys_le16_to_cpu(evt->latency);
    6854:	79aa      	ldrb	r2, [r5, #6]
    6856:	796b      	ldrb	r3, [r5, #5]
    6858:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    685c:	f8a0 3090 	strh.w	r3, [r0, #144]	; 0x90
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    6860:	79eb      	ldrb	r3, [r5, #7]
    6862:	7a2a      	ldrb	r2, [r5, #8]
    6864:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    6868:	f8a0 3092 	strh.w	r3, [r0, #146]	; 0x92
		notify_le_param_updated(conn);
    686c:	f002 faa4 	bl	8db8 <notify_le_param_updated>
	bt_conn_unref(conn);
    6870:	4620      	mov	r0, r4
    6872:	f01f fea0 	bl	265b6 <bt_conn_unref>
    6876:	e7e3      	b.n	6840 <le_conn_update_complete+0x28>
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
    6878:	2b1a      	cmp	r3, #26
    687a:	d1f9      	bne.n	6870 <le_conn_update_complete+0x58>
    687c:	78c3      	ldrb	r3, [r0, #3]
    687e:	2b01      	cmp	r3, #1
    6880:	d1f6      	bne.n	6870 <le_conn_update_complete+0x58>
		   !atomic_test_and_set_bit(conn->flags,
    6882:	210a      	movs	r1, #10
    6884:	3004      	adds	r0, #4
    6886:	f01f fd49 	bl	2631c <atomic_test_and_set_bit>
		   conn->role == BT_HCI_ROLE_SLAVE &&
    688a:	2800      	cmp	r0, #0
    688c:	d1f0      	bne.n	6870 <le_conn_update_complete+0x58>
		param.interval_min = conn->le.interval_min;
    688e:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    6892:	9300      	str	r3, [sp, #0]
		bt_l2cap_update_conn_param(conn, &param);
    6894:	4669      	mov	r1, sp
		param.latency = conn->le.pending_latency;
    6896:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    689a:	9301      	str	r3, [sp, #4]
		bt_l2cap_update_conn_param(conn, &param);
    689c:	4620      	mov	r0, r4
    689e:	f003 f8c9 	bl	9a34 <bt_l2cap_update_conn_param>
    68a2:	e7e5      	b.n	6870 <le_conn_update_complete+0x58>
    68a4:	000298f0 	.word	0x000298f0
    68a8:	00029830 	.word	0x00029830
    68ac:	0002bca2 	.word	0x0002bca2

000068b0 <hci_vendor_event>:
{
    68b0:	b510      	push	{r4, lr}
    68b2:	4a0a      	ldr	r2, [pc, #40]	; (68dc <hci_vendor_event+0x2c>)
    68b4:	4c0a      	ldr	r4, [pc, #40]	; (68e0 <hci_vendor_event+0x30>)
		BT_WARN("Unhandled vendor-specific event: %s",
    68b6:	8981      	ldrh	r1, [r0, #12]
    68b8:	6880      	ldr	r0, [r0, #8]
    68ba:	1aa4      	subs	r4, r4, r2
    68bc:	f7ff fb22 	bl	5f04 <bt_hex_real>
    68c0:	f7fb fe8e 	bl	25e0 <log_strdup>
    68c4:	08e4      	lsrs	r4, r4, #3
    68c6:	01a4      	lsls	r4, r4, #6
    68c8:	f044 0402 	orr.w	r4, r4, #2
    68cc:	4601      	mov	r1, r0
    68ce:	4622      	mov	r2, r4
    68d0:	4804      	ldr	r0, [pc, #16]	; (68e4 <hci_vendor_event+0x34>)
}
    68d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
    68d6:	f01d bb82 	b.w	23fde <log_1>
    68da:	bf00      	nop
    68dc:	00029830 	.word	0x00029830
    68e0:	000298f0 	.word	0x000298f0
    68e4:	0002bcc6 	.word	0x0002bcc6

000068e8 <handle_event>:
{
    68e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    68ea:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    68ee:	4605      	mov	r5, r0
    68f0:	4608      	mov	r0, r1
		if (handler->event != event) {
    68f2:	7811      	ldrb	r1, [r2, #0]
    68f4:	42a9      	cmp	r1, r5
    68f6:	d01a      	beq.n	692e <handle_event+0x46>
	for (i = 0; i < num_handlers; i++) {
    68f8:	3208      	adds	r2, #8
    68fa:	429a      	cmp	r2, r3
    68fc:	d1f9      	bne.n	68f2 <handle_event+0xa>
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    68fe:	8986      	ldrh	r6, [r0, #12]
    6900:	4b16      	ldr	r3, [pc, #88]	; (695c <handle_event+0x74>)
    6902:	4c17      	ldr	r4, [pc, #92]	; (6960 <handle_event+0x78>)
    6904:	6880      	ldr	r0, [r0, #8]
    6906:	4631      	mov	r1, r6
    6908:	1ae4      	subs	r4, r4, r3
    690a:	f7ff fafb 	bl	5f04 <bt_hex_real>
    690e:	f7fb fe67 	bl	25e0 <log_strdup>
    6912:	08e4      	lsrs	r4, r4, #3
    6914:	01a4      	lsls	r4, r4, #6
    6916:	f044 0402 	orr.w	r4, r4, #2
    691a:	4603      	mov	r3, r0
    691c:	f8ad 4000 	strh.w	r4, [sp]
    6920:	4810      	ldr	r0, [pc, #64]	; (6964 <handle_event+0x7c>)
    6922:	4632      	mov	r2, r6
    6924:	4629      	mov	r1, r5
    6926:	f01d fb87 	bl	24038 <log_3>
}
    692a:	b002      	add	sp, #8
    692c:	bd70      	pop	{r4, r5, r6, pc}
		if (buf->len < handler->min_len) {
    692e:	8981      	ldrh	r1, [r0, #12]
    6930:	7853      	ldrb	r3, [r2, #1]
    6932:	428b      	cmp	r3, r1
    6934:	d90d      	bls.n	6952 <handle_event+0x6a>
    6936:	4a09      	ldr	r2, [pc, #36]	; (695c <handle_event+0x74>)
    6938:	4b09      	ldr	r3, [pc, #36]	; (6960 <handle_event+0x78>)
			BT_ERR("Too small (%u bytes) event 0x%02x",
    693a:	480b      	ldr	r0, [pc, #44]	; (6968 <handle_event+0x80>)
    693c:	1a9b      	subs	r3, r3, r2
    693e:	08db      	lsrs	r3, r3, #3
    6940:	019b      	lsls	r3, r3, #6
    6942:	f043 0301 	orr.w	r3, r3, #1
    6946:	462a      	mov	r2, r5
}
    6948:	b002      	add	sp, #8
    694a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			BT_ERR("Too small (%u bytes) event 0x%02x",
    694e:	f01d bb5a 	b.w	24006 <log_2>
		handler->handler(buf);
    6952:	6853      	ldr	r3, [r2, #4]
}
    6954:	b002      	add	sp, #8
    6956:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		handler->handler(buf);
    695a:	4718      	bx	r3
    695c:	00029830 	.word	0x00029830
    6960:	000298f0 	.word	0x000298f0
    6964:	0002bd0c 	.word	0x0002bd0c
    6968:	0002bcea 	.word	0x0002bcea

0000696c <hci_le_meta_event>:
{
    696c:	b510      	push	{r4, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    696e:	2101      	movs	r1, #1
{
    6970:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    6972:	3008      	adds	r0, #8
    6974:	f018 fc8e 	bl	1f294 <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    6978:	4621      	mov	r1, r4
    697a:	4a03      	ldr	r2, [pc, #12]	; (6988 <hci_le_meta_event+0x1c>)
    697c:	7800      	ldrb	r0, [r0, #0]
}
    697e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    6982:	2308      	movs	r3, #8
    6984:	f7ff bfb0 	b.w	68e8 <handle_event>
    6988:	00029dc0 	.word	0x00029dc0

0000698c <hci_cmd_done>:
{
    698c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6990:	4607      	mov	r7, r0
    6992:	b085      	sub	sp, #20
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    6994:	7990      	ldrb	r0, [r2, #6]
    6996:	4e34      	ldr	r6, [pc, #208]	; (6a68 <hci_cmd_done+0xdc>)
{
    6998:	4688      	mov	r8, r1
    699a:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    699c:	f018 f962 	bl	1ec64 <net_buf_pool_get>
    69a0:	4286      	cmp	r6, r0
    69a2:	d016      	beq.n	69d2 <hci_cmd_done+0x46>
    69a4:	4b31      	ldr	r3, [pc, #196]	; (6a6c <hci_cmd_done+0xe0>)
    69a6:	4d32      	ldr	r5, [pc, #200]	; (6a70 <hci_cmd_done+0xe4>)
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    69a8:	79a0      	ldrb	r0, [r4, #6]
    69aa:	9700      	str	r7, [sp, #0]
    69ac:	1aed      	subs	r5, r5, r3
    69ae:	08ed      	lsrs	r5, r5, #3
    69b0:	9001      	str	r0, [sp, #4]
    69b2:	f018 f957 	bl	1ec64 <net_buf_pool_get>
    69b6:	01ad      	lsls	r5, r5, #6
    69b8:	f045 0502 	orr.w	r5, r5, #2
    69bc:	e9cd 0602 	strd	r0, r6, [sp, #8]
    69c0:	462b      	mov	r3, r5
    69c2:	482c      	ldr	r0, [pc, #176]	; (6a74 <hci_cmd_done+0xe8>)
    69c4:	2204      	movs	r2, #4
    69c6:	4669      	mov	r1, sp
    69c8:	f01d fb52 	bl	24070 <log_n>
}
    69cc:	b005      	add	sp, #20
    69ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (cmd(buf)->opcode != opcode) {
    69d2:	4620      	mov	r0, r4
    69d4:	f018 f94e 	bl	1ec74 <net_buf_id>
    69d8:	4d27      	ldr	r5, [pc, #156]	; (6a78 <hci_cmd_done+0xec>)
    69da:	f04f 090c 	mov.w	r9, #12
    69de:	fb09 5300 	mla	r3, r9, r0, r5
    69e2:	885b      	ldrh	r3, [r3, #2]
    69e4:	42bb      	cmp	r3, r7
    69e6:	d011      	beq.n	6a0c <hci_cmd_done+0x80>
    69e8:	4b20      	ldr	r3, [pc, #128]	; (6a6c <hci_cmd_done+0xe0>)
    69ea:	4e21      	ldr	r6, [pc, #132]	; (6a70 <hci_cmd_done+0xe4>)
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    69ec:	4620      	mov	r0, r4
    69ee:	1af6      	subs	r6, r6, r3
    69f0:	f018 f940 	bl	1ec74 <net_buf_id>
    69f4:	08f6      	lsrs	r6, r6, #3
    69f6:	fb09 5000 	mla	r0, r9, r0, r5
    69fa:	01b6      	lsls	r6, r6, #6
    69fc:	f046 0602 	orr.w	r6, r6, #2
    6a00:	8842      	ldrh	r2, [r0, #2]
    6a02:	481e      	ldr	r0, [pc, #120]	; (6a7c <hci_cmd_done+0xf0>)
    6a04:	4633      	mov	r3, r6
    6a06:	4639      	mov	r1, r7
    6a08:	f01d fafd 	bl	24006 <log_2>
	if (cmd(buf)->state && !status) {
    6a0c:	4620      	mov	r0, r4
    6a0e:	f018 f931 	bl	1ec74 <net_buf_id>
    6a12:	260c      	movs	r6, #12
    6a14:	fb06 5000 	mla	r0, r6, r0, r5
    6a18:	6843      	ldr	r3, [r0, #4]
    6a1a:	b16b      	cbz	r3, 6a38 <hci_cmd_done+0xac>
    6a1c:	f1b8 0f00 	cmp.w	r8, #0
    6a20:	d10a      	bne.n	6a38 <hci_cmd_done+0xac>
		struct cmd_state_set *update = cmd(buf)->state;
    6a22:	4620      	mov	r0, r4
    6a24:	f018 f926 	bl	1ec74 <net_buf_id>
    6a28:	fb06 5000 	mla	r0, r6, r0, r5
    6a2c:	6843      	ldr	r3, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
    6a2e:	e9d3 0100 	ldrd	r0, r1, [r3]
    6a32:	7a1a      	ldrb	r2, [r3, #8]
    6a34:	f01f fc8c 	bl	26350 <atomic_set_bit_to>
	if (cmd(buf)->sync) {
    6a38:	4620      	mov	r0, r4
    6a3a:	f018 f91b 	bl	1ec74 <net_buf_id>
    6a3e:	260c      	movs	r6, #12
    6a40:	fb06 5000 	mla	r0, r6, r0, r5
    6a44:	6883      	ldr	r3, [r0, #8]
    6a46:	2b00      	cmp	r3, #0
    6a48:	d0c0      	beq.n	69cc <hci_cmd_done+0x40>
		cmd(buf)->status = status;
    6a4a:	4620      	mov	r0, r4
    6a4c:	f018 f912 	bl	1ec74 <net_buf_id>
    6a50:	4370      	muls	r0, r6
    6a52:	f805 8000 	strb.w	r8, [r5, r0]
		k_sem_give(cmd(buf)->sync);
    6a56:	4620      	mov	r0, r4
    6a58:	f018 f90c 	bl	1ec74 <net_buf_id>
    6a5c:	fb06 5500 	mla	r5, r6, r0, r5
    6a60:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
    6a62:	f01b fe25 	bl	226b0 <z_impl_k_sem_give>
}
    6a66:	e7b1      	b.n	69cc <hci_cmd_done+0x40>
    6a68:	20007748 	.word	0x20007748
    6a6c:	00029830 	.word	0x00029830
    6a70:	000298f0 	.word	0x000298f0
    6a74:	0002bd2e 	.word	0x0002bd2e
    6a78:	20000458 	.word	0x20000458
    6a7c:	0002bd63 	.word	0x0002bd63

00006a80 <find_pending_connect.part.0>:
static struct bt_conn *find_pending_connect(u8_t role, bt_addr_le_t *peer_addr)
    6a80:	b513      	push	{r0, r1, r4, lr}
		conn = bt_conn_lookup_state_le(adv->id, peer_addr,
    6a82:	4c0b      	ldr	r4, [pc, #44]	; (6ab0 <find_pending_connect.part.0+0x30>)
static struct bt_conn *find_pending_connect(u8_t role, bt_addr_le_t *peer_addr)
    6a84:	4601      	mov	r1, r0
		conn = bt_conn_lookup_state_le(adv->id, peer_addr,
    6a86:	2204      	movs	r2, #4
    6a88:	7d20      	ldrb	r0, [r4, #20]
    6a8a:	f002 fc6f 	bl	936c <bt_conn_lookup_state_le>
		if (!conn) {
    6a8e:	b968      	cbnz	r0, 6aac <find_pending_connect.part.0+0x2c>
						       BT_ADDR_LE_NONE,
    6a90:	4b08      	ldr	r3, [pc, #32]	; (6ab4 <find_pending_connect.part.0+0x34>)
    6a92:	6818      	ldr	r0, [r3, #0]
    6a94:	889a      	ldrh	r2, [r3, #4]
    6a96:	9000      	str	r0, [sp, #0]
    6a98:	799b      	ldrb	r3, [r3, #6]
    6a9a:	f8ad 2004 	strh.w	r2, [sp, #4]
			conn = bt_conn_lookup_state_le(adv->id,
    6a9e:	7d20      	ldrb	r0, [r4, #20]
						       BT_ADDR_LE_NONE,
    6aa0:	f88d 3006 	strb.w	r3, [sp, #6]
			conn = bt_conn_lookup_state_le(adv->id,
    6aa4:	2203      	movs	r2, #3
    6aa6:	4669      	mov	r1, sp
    6aa8:	f002 fc60 	bl	936c <bt_conn_lookup_state_le>
}
    6aac:	b002      	add	sp, #8
    6aae:	bd10      	pop	{r4, pc}
    6ab0:	20006860 	.word	0x20006860
    6ab4:	00029a6c 	.word	0x00029a6c

00006ab8 <id_find>:
	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
	*count = to_copy;
}

static int id_find(const bt_addr_le_t *addr)
{
    6ab8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    6aba:	4f0b      	ldr	r7, [pc, #44]	; (6ae8 <id_find+0x30>)
{
    6abc:	4606      	mov	r6, r0
	for (id = 0U; id < bt_dev.id_count; id++) {
    6abe:	2500      	movs	r5, #0
    6ac0:	79fb      	ldrb	r3, [r7, #7]
    6ac2:	b2ec      	uxtb	r4, r5
    6ac4:	42a3      	cmp	r3, r4
    6ac6:	d802      	bhi.n	6ace <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
    6ac8:	f06f 0401 	mvn.w	r4, #1
    6acc:	e009      	b.n	6ae2 <id_find+0x2a>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    6ace:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
}

static inline int bt_addr_le_cmp(const bt_addr_le_t *a, const bt_addr_le_t *b)
{
	return memcmp(a, b, sizeof(*a));
    6ad2:	2207      	movs	r2, #7
    6ad4:	4439      	add	r1, r7
    6ad6:	4630      	mov	r0, r6
    6ad8:	f01f f8d6 	bl	25c88 <memcmp>
    6adc:	3501      	adds	r5, #1
    6ade:	2800      	cmp	r0, #0
    6ae0:	d1ee      	bne.n	6ac0 <id_find+0x8>
}
    6ae2:	4620      	mov	r0, r4
    6ae4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6ae6:	bf00      	nop
    6ae8:	20006860 	.word	0x20006860

00006aec <hci_tx_thread>:
{
    6aec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6af0:	4c4e      	ldr	r4, [pc, #312]	; (6c2c <hci_tx_thread+0x140>)
    6af2:	4b4f      	ldr	r3, [pc, #316]	; (6c30 <hci_tx_thread+0x144>)
		events[0].state = K_POLL_STATE_NOT_READY;
    6af4:	f8df 9140 	ldr.w	r9, [pc, #320]	; 6c38 <hci_tx_thread+0x14c>
		BT_ASSERT(err == 0);
    6af8:	f8df a168 	ldr.w	sl, [pc, #360]	; 6c64 <hci_tx_thread+0x178>
    6afc:	1ae4      	subs	r4, r4, r3
    6afe:	08e4      	lsrs	r4, r4, #3
		events[0].state = K_POLL_STATE_NOT_READY;
    6b00:	f8d9 300c 	ldr.w	r3, [r9, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
    6b04:	484b      	ldr	r0, [pc, #300]	; (6c34 <hci_tx_thread+0x148>)
		events[0].state = K_POLL_STATE_NOT_READY;
    6b06:	f36f 3310 	bfc	r3, #12, #5
    6b0a:	f8c9 300c 	str.w	r3, [r9, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
    6b0e:	f002 fab3 	bl	9078 <bt_conn_prepare_events>
    6b12:	1c47      	adds	r7, r0, #1
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    6b14:	4848      	ldr	r0, [pc, #288]	; (6c38 <hci_tx_thread+0x14c>)
    6b16:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6b1a:	4639      	mov	r1, r7
    6b1c:	f01c febe 	bl	2389c <z_impl_k_poll>
		BT_ASSERT(err == 0);
    6b20:	b160      	cbz	r0, 6b3c <hci_tx_thread+0x50>
    6b22:	4946      	ldr	r1, [pc, #280]	; (6c3c <hci_tx_thread+0x150>)
    6b24:	4846      	ldr	r0, [pc, #280]	; (6c40 <hci_tx_thread+0x154>)
    6b26:	f241 4319 	movw	r3, #5145	; 0x1419
    6b2a:	4652      	mov	r2, sl
    6b2c:	f01d f9d9 	bl	23ee2 <printk>
    6b30:	4040      	eors	r0, r0
    6b32:	f380 8811 	msr	BASEPRI, r0
    6b36:	f04f 0003 	mov.w	r0, #3
    6b3a:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    6b3c:	4d41      	ldr	r5, [pc, #260]	; (6c44 <hci_tx_thread+0x158>)
{
    6b3e:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 6c38 <hci_tx_thread+0x14c>
    6b42:	f105 0bc0 	add.w	fp, r5, #192	; 0xc0
	for (; count; ev++, count--) {
    6b46:	b917      	cbnz	r7, 6b4e <hci_tx_thread+0x62>
	z_impl_k_yield();
    6b48:	f01b fc2c 	bl	223a4 <z_impl_k_yield>
}
    6b4c:	e7d8      	b.n	6b00 <hci_tx_thread+0x14>
		switch (ev->state) {
    6b4e:	f8d8 100c 	ldr.w	r1, [r8, #12]
    6b52:	f3c1 3104 	ubfx	r1, r1, #12, #5
    6b56:	2901      	cmp	r1, #1
    6b58:	d955      	bls.n	6c06 <hci_tx_thread+0x11a>
    6b5a:	2904      	cmp	r1, #4
    6b5c:	d15f      	bne.n	6c1e <hci_tx_thread+0x132>
			if (ev->tag == BT_EVENT_CMD_TX) {
    6b5e:	f898 100c 	ldrb.w	r1, [r8, #12]
    6b62:	2900      	cmp	r1, #0
    6b64:	d153      	bne.n	6c0e <hci_tx_thread+0x122>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    6b66:	4838      	ldr	r0, [pc, #224]	; (6c48 <hci_tx_thread+0x15c>)
    6b68:	f018 f976 	bl	1ee58 <net_buf_get>
	BT_ASSERT(buf);
    6b6c:	4606      	mov	r6, r0
    6b6e:	b960      	cbnz	r0, 6b8a <hci_tx_thread+0x9e>
    6b70:	4936      	ldr	r1, [pc, #216]	; (6c4c <hci_tx_thread+0x160>)
    6b72:	4833      	ldr	r0, [pc, #204]	; (6c40 <hci_tx_thread+0x154>)
    6b74:	f241 33ba 	movw	r3, #5050	; 0x13ba
    6b78:	4652      	mov	r2, sl
    6b7a:	f01d f9b2 	bl	23ee2 <printk>
    6b7e:	4040      	eors	r0, r0
    6b80:	f380 8811 	msr	BASEPRI, r0
    6b84:	f04f 0003 	mov.w	r0, #3
    6b88:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    6b8a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    6b8e:	4658      	mov	r0, fp
    6b90:	f01b fdd2 	bl	22738 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    6b94:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
    6b98:	b163      	cbz	r3, 6bb4 <hci_tx_thread+0xc8>
		BT_ERR("Uncleared pending sent_cmd");
    6b9a:	01a1      	lsls	r1, r4, #6
    6b9c:	482c      	ldr	r0, [pc, #176]	; (6c50 <hci_tx_thread+0x164>)
    6b9e:	f041 0101 	orr.w	r1, r1, #1
    6ba2:	f01d fa0f 	bl	23fc4 <log_0>
		net_buf_unref(bt_dev.sent_cmd);
    6ba6:	f8d5 00d8 	ldr.w	r0, [r5, #216]	; 0xd8
    6baa:	f018 fa8d 	bl	1f0c8 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    6bae:	2300      	movs	r3, #0
    6bb0:	f8c5 30d8 	str.w	r3, [r5, #216]	; 0xd8
	bt_dev.sent_cmd = net_buf_ref(buf);
    6bb4:	4630      	mov	r0, r6
    6bb6:	f018 facf 	bl	1f158 <net_buf_ref>
    6bba:	f8c5 00d8 	str.w	r0, [r5, #216]	; 0xd8
		return bt_hci_ecc_send(buf);
    6bbe:	4630      	mov	r0, r6
    6bc0:	f7ff fb2a 	bl	6218 <bt_hci_ecc_send>
	if (err) {
    6bc4:	4601      	mov	r1, r0
    6bc6:	b1f0      	cbz	r0, 6c06 <hci_tx_thread+0x11a>
		BT_ERR("Unable to send to driver (err %d)", err);
    6bc8:	01a2      	lsls	r2, r4, #6
    6bca:	4822      	ldr	r0, [pc, #136]	; (6c54 <hci_tx_thread+0x168>)
    6bcc:	f042 0201 	orr.w	r2, r2, #1
    6bd0:	f01d fa05 	bl	23fde <log_1>
	z_impl_k_sem_give(sem);
    6bd4:	4820      	ldr	r0, [pc, #128]	; (6c58 <hci_tx_thread+0x16c>)
    6bd6:	f01b fd6b 	bl	226b0 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED,
    6bda:	4630      	mov	r0, r6
    6bdc:	f018 f84a 	bl	1ec74 <net_buf_id>
    6be0:	4b1e      	ldr	r3, [pc, #120]	; (6c5c <hci_tx_thread+0x170>)
    6be2:	220c      	movs	r2, #12
    6be4:	fb02 3000 	mla	r0, r2, r0, r3
    6be8:	211f      	movs	r1, #31
    6bea:	8840      	ldrh	r0, [r0, #2]
    6bec:	2200      	movs	r2, #0
    6bee:	f7ff fecd 	bl	698c <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
    6bf2:	f8d5 00d8 	ldr.w	r0, [r5, #216]	; 0xd8
    6bf6:	f018 fa67 	bl	1f0c8 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    6bfa:	2300      	movs	r3, #0
		net_buf_unref(buf);
    6bfc:	4630      	mov	r0, r6
		bt_dev.sent_cmd = NULL;
    6bfe:	f8c5 30d8 	str.w	r3, [r5, #216]	; 0xd8
		net_buf_unref(buf);
    6c02:	f018 fa61 	bl	1f0c8 <net_buf_unref>
	for (; count; ev++, count--) {
    6c06:	f108 0814 	add.w	r8, r8, #20
    6c0a:	3f01      	subs	r7, #1
    6c0c:	e79b      	b.n	6b46 <hci_tx_thread+0x5a>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
    6c0e:	2901      	cmp	r1, #1
    6c10:	d1f9      	bne.n	6c06 <hci_tx_thread+0x11a>
					conn = CONTAINER_OF(ev->fifo,
    6c12:	f8d8 0010 	ldr.w	r0, [r8, #16]
					bt_conn_process_tx(conn);
    6c16:	3834      	subs	r0, #52	; 0x34
    6c18:	f002 fcd0 	bl	95bc <bt_conn_process_tx>
    6c1c:	e7f3      	b.n	6c06 <hci_tx_thread+0x11a>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    6c1e:	01a2      	lsls	r2, r4, #6
    6c20:	480f      	ldr	r0, [pc, #60]	; (6c60 <hci_tx_thread+0x174>)
    6c22:	f042 0202 	orr.w	r2, r2, #2
    6c26:	f01d f9da 	bl	23fde <log_1>
    6c2a:	e7ec      	b.n	6c06 <hci_tx_thread+0x11a>
    6c2c:	000298f0 	.word	0x000298f0
    6c30:	00029830 	.word	0x00029830
    6c34:	20006ad8 	.word	0x20006ad8
    6c38:	20006ac4 	.word	0x20006ac4
    6c3c:	0002bdca 	.word	0x0002bdca
    6c40:	0002a5e8 	.word	0x0002a5e8
    6c44:	20006860 	.word	0x20006860
    6c48:	2000693c 	.word	0x2000693c
    6c4c:	00030dcd 	.word	0x00030dcd
    6c50:	0002bdd3 	.word	0x0002bdd3
    6c54:	0002bdee 	.word	0x0002bdee
    6c58:	20006920 	.word	0x20006920
    6c5c:	20000458 	.word	0x20000458
    6c60:	0002be10 	.word	0x0002be10
    6c64:	0002bd96 	.word	0x0002bd96

00006c68 <hci_num_completed_packets>:
{
    6c68:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6c6c:	4b46      	ldr	r3, [pc, #280]	; (6d88 <hci_num_completed_packets+0x120>)
    6c6e:	4d47      	ldr	r5, [pc, #284]	; (6d8c <hci_num_completed_packets+0x124>)
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
    6c70:	f8d0 8008 	ldr.w	r8, [r0, #8]
    6c74:	f8df a120 	ldr.w	sl, [pc, #288]	; 6d98 <hci_num_completed_packets+0x130>
    6c78:	1aed      	subs	r5, r5, r3
	for (i = 0; i < evt->num_handles; i++) {
    6c7a:	2600      	movs	r6, #0
    6c7c:	08ed      	lsrs	r5, r5, #3
			tx->pending_no_cb = 0U;
    6c7e:	46b1      	mov	r9, r6
	for (i = 0; i < evt->num_handles; i++) {
    6c80:	f898 3000 	ldrb.w	r3, [r8]
    6c84:	429e      	cmp	r6, r3
    6c86:	db02      	blt.n	6c8e <hci_num_completed_packets+0x26>
}
    6c88:	b003      	add	sp, #12
    6c8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		handle = sys_le16_to_cpu(evt->h[i].handle);
    6c8e:	eb08 0386 	add.w	r3, r8, r6, lsl #2
    6c92:	f8b3 1001 	ldrh.w	r1, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
    6c96:	f8b3 7003 	ldrh.w	r7, [r3, #3]
	__asm__ volatile(
    6c9a:	f04f 0320 	mov.w	r3, #32
    6c9e:	f3ef 8b11 	mrs	fp, BASEPRI
    6ca2:	f383 8811 	msr	BASEPRI, r3
    6ca6:	f3bf 8f6f 	isb	sy
		conn = bt_conn_lookup_handle(handle);
    6caa:	4608      	mov	r0, r1
    6cac:	9101      	str	r1, [sp, #4]
    6cae:	f002 fb27 	bl	9300 <bt_conn_lookup_handle>
		if (!conn) {
    6cb2:	9901      	ldr	r1, [sp, #4]
    6cb4:	4604      	mov	r4, r0
    6cb6:	b958      	cbnz	r0, 6cd0 <hci_num_completed_packets+0x68>
	__asm__ volatile(
    6cb8:	f38b 8811 	msr	BASEPRI, fp
    6cbc:	f3bf 8f6f 	isb	sy
			BT_ERR("No connection for handle %u", handle);
    6cc0:	01aa      	lsls	r2, r5, #6
    6cc2:	4833      	ldr	r0, [pc, #204]	; (6d90 <hci_num_completed_packets+0x128>)
    6cc4:	f042 0201 	orr.w	r2, r2, #1
    6cc8:	f01d f989 	bl	23fde <log_1>
	for (i = 0; i < evt->num_handles; i++) {
    6ccc:	3601      	adds	r6, #1
    6cce:	e7d7      	b.n	6c80 <hci_num_completed_packets+0x18>
    6cd0:	f38b 8811 	msr	BASEPRI, fp
    6cd4:	f3bf 8f6f 	isb	sy
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    6cd8:	f100 0b28 	add.w	fp, r0, #40	; 0x28
		while (count--) {
    6cdc:	b357      	cbz	r7, 6d34 <hci_num_completed_packets+0xcc>
	__asm__ volatile(
    6cde:	f04f 0320 	mov.w	r3, #32
    6ce2:	f3ef 8211 	mrs	r2, BASEPRI
    6ce6:	f383 8811 	msr	BASEPRI, r3
    6cea:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
    6cee:	69e3      	ldr	r3, [r4, #28]
    6cf0:	b16b      	cbz	r3, 6d0e <hci_num_completed_packets+0xa6>
				conn->pending_no_cb--;
    6cf2:	3b01      	subs	r3, #1
    6cf4:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
    6cf6:	f382 8811 	msr	BASEPRI, r2
    6cfa:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
    6cfe:	4620      	mov	r0, r4
    6d00:	f002 f856 	bl	8db0 <bt_conn_get_pkts>
    6d04:	3f01      	subs	r7, #1
    6d06:	f01b fcd3 	bl	226b0 <z_impl_k_sem_give>
    6d0a:	b2bf      	uxth	r7, r7
    6d0c:	e7e6      	b.n	6cdc <hci_num_completed_packets+0x74>
Z_GENLIST_IS_EMPTY(slist)
    6d0e:	6963      	ldr	r3, [r4, #20]
Z_GENLIST_GET(slist, snode)
    6d10:	b12b      	cbz	r3, 6d1e <hci_num_completed_packets+0xb6>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    6d12:	69a1      	ldr	r1, [r4, #24]
    6d14:	6818      	ldr	r0, [r3, #0]
	list->head = node;
    6d16:	6160      	str	r0, [r4, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    6d18:	428b      	cmp	r3, r1
	list->tail = node;
    6d1a:	bf08      	it	eq
    6d1c:	61a0      	streq	r0, [r4, #24]
    6d1e:	f382 8811 	msr	BASEPRI, r2
    6d22:	f3bf 8f6f 	isb	sy
			if (!node) {
    6d26:	b94b      	cbnz	r3, 6d3c <hci_num_completed_packets+0xd4>
				BT_ERR("packets count mismatch");
    6d28:	01a9      	lsls	r1, r5, #6
    6d2a:	481a      	ldr	r0, [pc, #104]	; (6d94 <hci_num_completed_packets+0x12c>)
    6d2c:	f041 0101 	orr.w	r1, r1, #1
    6d30:	f01d f948 	bl	23fc4 <log_0>
		bt_conn_unref(conn);
    6d34:	4620      	mov	r0, r4
    6d36:	f01f fc3e 	bl	265b6 <bt_conn_unref>
    6d3a:	e7c7      	b.n	6ccc <hci_num_completed_packets+0x64>
	__asm__ volatile(
    6d3c:	f04f 0220 	mov.w	r2, #32
    6d40:	f3ef 8111 	mrs	r1, BASEPRI
    6d44:	f382 8811 	msr	BASEPRI, r2
    6d48:	f3bf 8f6f 	isb	sy
			conn->pending_no_cb = tx->pending_no_cb;
    6d4c:	68da      	ldr	r2, [r3, #12]
    6d4e:	61e2      	str	r2, [r4, #28]
	parent->next = child;
    6d50:	f8c3 9000 	str.w	r9, [r3]
Z_GENLIST_APPEND(slist, snode)
    6d54:	6a62      	ldr	r2, [r4, #36]	; 0x24
			tx->pending_no_cb = 0U;
    6d56:	f8c3 900c 	str.w	r9, [r3, #12]
    6d5a:	b98a      	cbnz	r2, 6d80 <hci_num_completed_packets+0x118>
	list->head = node;
    6d5c:	e9c4 3308 	strd	r3, r3, [r4, #32]
	__asm__ volatile(
    6d60:	f381 8811 	msr	BASEPRI, r1
    6d64:	f3bf 8f6f 	isb	sy
    6d68:	2100      	movs	r1, #0
    6d6a:	f104 0030 	add.w	r0, r4, #48	; 0x30
    6d6e:	f01f fad5 	bl	2631c <atomic_test_and_set_bit>
    6d72:	2800      	cmp	r0, #0
    6d74:	d1c3      	bne.n	6cfe <hci_num_completed_packets+0x96>
		k_queue_append(&work_q->queue, work);
    6d76:	4659      	mov	r1, fp
    6d78:	4650      	mov	r0, sl
    6d7a:	f022 fa6a 	bl	29252 <k_queue_append>
    6d7e:	e7be      	b.n	6cfe <hci_num_completed_packets+0x96>
	parent->next = child;
    6d80:	6013      	str	r3, [r2, #0]
	list->tail = node;
    6d82:	6263      	str	r3, [r4, #36]	; 0x24
}
    6d84:	e7ec      	b.n	6d60 <hci_num_completed_packets+0xf8>
    6d86:	bf00      	nop
    6d88:	00029830 	.word	0x00029830
    6d8c:	000298f0 	.word	0x000298f0
    6d90:	0002be31 	.word	0x0002be31
    6d94:	0002be4d 	.word	0x0002be4d
    6d98:	20001dc4 	.word	0x20001dc4

00006d9c <le_adv_report>:
{
    6d9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t num_reports = net_buf_pull_u8(buf);
    6da0:	f100 0708 	add.w	r7, r0, #8
{
    6da4:	b08b      	sub	sp, #44	; 0x2c
    6da6:	4604      	mov	r4, r0
	u8_t num_reports = net_buf_pull_u8(buf);
    6da8:	4638      	mov	r0, r7
    6daa:	f021 ffd4 	bl	28d56 <net_buf_simple_pull_u8>
	if (scan_dev_found_cb) {
    6dae:	f8df a154 	ldr.w	sl, [pc, #340]	; 6f04 <le_adv_report+0x168>
	u8_t num_reports = net_buf_pull_u8(buf);
    6db2:	9000      	str	r0, [sp, #0]
	while (num_reports--) {
    6db4:	9b00      	ldr	r3, [sp, #0]
    6db6:	b163      	cbz	r3, 6dd2 <le_adv_report+0x36>
		if (buf->len < sizeof(*evt)) {
    6db8:	89a3      	ldrh	r3, [r4, #12]
    6dba:	2b08      	cmp	r3, #8
    6dbc:	d80c      	bhi.n	6dd8 <le_adv_report+0x3c>
    6dbe:	494b      	ldr	r1, [pc, #300]	; (6eec <le_adv_report+0x150>)
    6dc0:	4b4b      	ldr	r3, [pc, #300]	; (6ef0 <le_adv_report+0x154>)
			BT_ERR("Unexpected end of buffer");
    6dc2:	484c      	ldr	r0, [pc, #304]	; (6ef4 <le_adv_report+0x158>)
    6dc4:	1ac9      	subs	r1, r1, r3
    6dc6:	08c9      	lsrs	r1, r1, #3
    6dc8:	0189      	lsls	r1, r1, #6
    6dca:	f041 0101 	orr.w	r1, r1, #1
    6dce:	f01d f8f9 	bl	23fc4 <log_0>
}
    6dd2:	b00b      	add	sp, #44	; 0x2c
    6dd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		evt = net_buf_pull_mem(buf, sizeof(*evt));
    6dd8:	2109      	movs	r1, #9
    6dda:	4638      	mov	r0, r7
    6ddc:	f018 fa5a 	bl	1f294 <net_buf_simple_pull_mem>
		adv_info.rssi = evt->data[evt->length];
    6de0:	f890 9008 	ldrb.w	r9, [r0, #8]
    6de4:	eb00 0309 	add.w	r3, r0, r9
		le_adv_recv(&evt->addr, &adv_info, buf, evt->length);
    6de8:	1c41      	adds	r1, r0, #1
		adv_info.rssi = evt->data[evt->length];
    6dea:	7a5b      	ldrb	r3, [r3, #9]
    6dec:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		adv_info.primary_phy = BT_GAP_LE_PHY_1M;
    6df0:	2301      	movs	r3, #1
    6df2:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
		adv_info.tx_power = BT_GAP_TX_POWER_INVALID;
    6df6:	237f      	movs	r3, #127	; 0x7f
    6df8:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
		adv_info.sid = BT_GAP_SID_INVALID;
    6dfc:	23ff      	movs	r3, #255	; 0xff
    6dfe:	f88d 3020 	strb.w	r3, [sp, #32]
		adv_info.adv_type = evt->evt_type;
    6e02:	7803      	ldrb	r3, [r0, #0]
    6e04:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    6e08:	2b04      	cmp	r3, #4
    6e0a:	bf96      	itet	ls
    6e0c:	4a3a      	ldrls	r2, [pc, #232]	; (6ef8 <le_adv_report+0x15c>)
    6e0e:	2300      	movhi	r3, #0
    6e10:	5cd3      	ldrbls	r3, [r2, r3]
		adv_info.adv_props = get_adv_props(evt->evt_type);
    6e12:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
		evt = net_buf_pull_mem(buf, sizeof(*evt));
    6e16:	4606      	mov	r6, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    6e18:	4838      	ldr	r0, [pc, #224]	; (6efc <le_adv_report+0x160>)
    6e1a:	f01f fa67 	bl	262ec <atomic_get>
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) &&
    6e1e:	0502      	lsls	r2, r0, #20
    6e20:	d50d      	bpl.n	6e3e <le_adv_report+0xa2>
	    atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN) &&
    6e22:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    6e26:	075b      	lsls	r3, r3, #29
    6e28:	d509      	bpl.n	6e3e <le_adv_report+0xa2>
		net_buf_pull(buf, evt->length + sizeof(adv_info.rssi));
    6e2a:	7a31      	ldrb	r1, [r6, #8]
    6e2c:	4638      	mov	r0, r7
    6e2e:	3101      	adds	r1, #1
    6e30:	f018 fa10 	bl	1f254 <net_buf_simple_pull>
    6e34:	9b00      	ldr	r3, [sp, #0]
    6e36:	1e58      	subs	r0, r3, #1
    6e38:	b2c3      	uxtb	r3, r0
    6e3a:	9300      	str	r3, [sp, #0]
    6e3c:	e7ba      	b.n	6db4 <le_adv_report+0x18>
	if (addr->type == BT_ADDR_LE_PUBLIC_ID ||
    6e3e:	7873      	ldrb	r3, [r6, #1]
    6e40:	1e9a      	subs	r2, r3, #2
    6e42:	2a01      	cmp	r2, #1
    6e44:	f10d 0b0c 	add.w	fp, sp, #12
    6e48:	d843      	bhi.n	6ed2 <le_adv_report+0x136>
		bt_addr_le_copy(&id_addr, addr);
    6e4a:	4658      	mov	r0, fp
    6e4c:	f01f fa54 	bl	262f8 <bt_addr_le_copy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    6e50:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6e54:	3b02      	subs	r3, #2
    6e56:	f88d 300c 	strb.w	r3, [sp, #12]
	if (scan_dev_found_cb) {
    6e5a:	f8da 3000 	ldr.w	r3, [sl]
	info->addr = &id_addr;
    6e5e:	f8cd b01c 	str.w	fp, [sp, #28]
	if (scan_dev_found_cb) {
    6e62:	b1b3      	cbz	r3, 6e92 <le_adv_report+0xf6>
 * @param state Storage for the state.
 */
static inline void net_buf_simple_save(struct net_buf_simple *buf,
				       struct net_buf_simple_state *state)
{
	state->offset = net_buf_simple_headroom(buf);
    6e64:	4638      	mov	r0, r7
    6e66:	f021 ff9a 	bl	28d9e <net_buf_simple_headroom>
	state->len = buf->len;
    6e6a:	89a3      	ldrh	r3, [r4, #12]
    6e6c:	9301      	str	r3, [sp, #4]
	state->offset = net_buf_simple_headroom(buf);
    6e6e:	4680      	mov	r8, r0
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type,
    6e70:	463b      	mov	r3, r7
    6e72:	4658      	mov	r0, fp
    6e74:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    6e78:	f99d 1021 	ldrsb.w	r1, [sp, #33]	; 0x21
    6e7c:	f8da 5000 	ldr.w	r5, [sl]
		buf->len = len;
    6e80:	f8a4 900c 	strh.w	r9, [r4, #12]
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type,
    6e84:	47a8      	blx	r5
 * @param state Stored state.
 */
static inline void net_buf_simple_restore(struct net_buf_simple *buf,
					  struct net_buf_simple_state *state)
{
	buf->data = buf->__buf + state->offset;
    6e86:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    6e88:	9b01      	ldr	r3, [sp, #4]
    6e8a:	81a3      	strh	r3, [r4, #12]
	buf->data = buf->__buf + state->offset;
    6e8c:	fa10 f088 	uxtah	r0, r0, r8
    6e90:	60a0      	str	r0, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&scan_cbs, listener, node) {
    6e92:	4b1b      	ldr	r3, [pc, #108]	; (6f00 <le_adv_report+0x164>)
    6e94:	681d      	ldr	r5, [r3, #0]
    6e96:	2d00      	cmp	r5, #0
    6e98:	d0c7      	beq.n	6e2a <le_adv_report+0x8e>
    6e9a:	3d08      	subs	r5, #8
    6e9c:	2d00      	cmp	r5, #0
    6e9e:	d0c4      	beq.n	6e2a <le_adv_report+0x8e>
	state->offset = net_buf_simple_headroom(buf);
    6ea0:	4638      	mov	r0, r7
    6ea2:	f021 ff7c 	bl	28d9e <net_buf_simple_headroom>
		listener->recv(info, &buf->b);
    6ea6:	46ab      	mov	fp, r5
	state->len = buf->len;
    6ea8:	89a3      	ldrh	r3, [r4, #12]
    6eaa:	f85b 2b08 	ldr.w	r2, [fp], #8
		buf->len = len;
    6eae:	f8a4 900c 	strh.w	r9, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
    6eb2:	4680      	mov	r8, r0
		listener->recv(info, &buf->b);
    6eb4:	4639      	mov	r1, r7
    6eb6:	a807      	add	r0, sp, #28
	state->len = buf->len;
    6eb8:	9301      	str	r3, [sp, #4]
    6eba:	4790      	blx	r2
	buf->data = buf->__buf + state->offset;
    6ebc:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    6ebe:	9b01      	ldr	r3, [sp, #4]
    6ec0:	81a3      	strh	r3, [r4, #12]
	buf->data = buf->__buf + state->offset;
    6ec2:	fa10 f088 	uxtah	r0, r0, r8
    6ec6:	60a0      	str	r0, [r4, #8]
Z_GENLIST_PEEK_NEXT(slist, snode)
    6ec8:	f1bb 0f00 	cmp.w	fp, #0
    6ecc:	d0ad      	beq.n	6e2a <le_adv_report+0x8e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    6ece:	68ad      	ldr	r5, [r5, #8]
    6ed0:	e7e1      	b.n	6e96 <le_adv_report+0xfa>
	} else if (addr->type == BT_HCI_PEER_ADDR_ANONYMOUS) {
    6ed2:	2bff      	cmp	r3, #255	; 0xff
		bt_addr_le_copy(&id_addr, BT_ADDR_LE_ANY);
    6ed4:	bf04      	itt	eq
    6ed6:	2300      	moveq	r3, #0
    6ed8:	a905      	addeq	r1, sp, #20
		bt_addr_le_copy(&id_addr,
    6eda:	4658      	mov	r0, fp
		bt_addr_le_copy(&id_addr, BT_ADDR_LE_ANY);
    6edc:	bf04      	itt	eq
    6ede:	9305      	streq	r3, [sp, #20]
    6ee0:	f8cd 3017 	streq.w	r3, [sp, #23]
		bt_addr_le_copy(&id_addr,
    6ee4:	f01f fa08 	bl	262f8 <bt_addr_le_copy>
    6ee8:	e7b7      	b.n	6e5a <le_adv_report+0xbe>
    6eea:	bf00      	nop
    6eec:	000298f0 	.word	0x000298f0
    6ef0:	00029830 	.word	0x00029830
    6ef4:	0002be64 	.word	0x0002be64
    6ef8:	0002c3b9 	.word	0x0002c3b9
    6efc:	200068ec 	.word	0x200068ec
    6f00:	2000047c 	.word	0x2000047c
    6f04:	20000484 	.word	0x20000484

00006f08 <hci_cmd_status>:
{
    6f08:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    6f0a:	2104      	movs	r1, #4
{
    6f0c:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    6f0e:	3008      	adds	r0, #8
    6f10:	f018 f9c0 	bl	1f294 <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    6f14:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    6f16:	7801      	ldrb	r1, [r0, #0]
    6f18:	8840      	ldrh	r0, [r0, #2]
    6f1a:	4622      	mov	r2, r4
    6f1c:	f7ff fd36 	bl	698c <hci_cmd_done>
	if (ncmd) {
    6f20:	b125      	cbz	r5, 6f2c <hci_cmd_status+0x24>
    6f22:	4803      	ldr	r0, [pc, #12]	; (6f30 <hci_cmd_status+0x28>)
}
    6f24:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    6f28:	f01b bbc2 	b.w	226b0 <z_impl_k_sem_give>
    6f2c:	bd38      	pop	{r3, r4, r5, pc}
    6f2e:	bf00      	nop
    6f30:	20006920 	.word	0x20006920

00006f34 <valid_adv_param>:
		return false;
	}
}

static bool valid_adv_param(const struct bt_le_adv_param *param, bool dir_adv)
{
    6f34:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (param->id >= bt_dev.id_count ||
    6f36:	4d19      	ldr	r5, [pc, #100]	; (6f9c <valid_adv_param+0x68>)
    6f38:	7803      	ldrb	r3, [r0, #0]
    6f3a:	79ea      	ldrb	r2, [r5, #7]
    6f3c:	429a      	cmp	r2, r3
{
    6f3e:	4606      	mov	r6, r0
    6f40:	460c      	mov	r4, r1
	if (param->id >= bt_dev.id_count ||
    6f42:	d801      	bhi.n	6f48 <valid_adv_param+0x14>

	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) || !dir_adv) {
		if (param->interval_min > param->interval_max ||
		    param->interval_min < 0x0020 ||
		    param->interval_max > 0x4000) {
			return false;
    6f44:	2400      	movs	r4, #0
    6f46:	e025      	b.n	6f94 <valid_adv_param+0x60>
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    6f48:	2200      	movs	r2, #0
    6f4a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    6f4e:	9200      	str	r2, [sp, #0]
    6f50:	4669      	mov	r1, sp
    6f52:	f8cd 2003 	str.w	r2, [sp, #3]
    6f56:	18e8      	adds	r0, r5, r3
    6f58:	2207      	movs	r2, #7
    6f5a:	f01e fe95 	bl	25c88 <memcmp>
	if (param->id >= bt_dev.id_count ||
    6f5e:	2800      	cmp	r0, #0
    6f60:	d0f0      	beq.n	6f44 <valid_adv_param+0x10>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    6f62:	6873      	ldr	r3, [r6, #4]
    6f64:	f013 0201 	ands.w	r2, r3, #1
    6f68:	d106      	bne.n	6f78 <valid_adv_param+0x44>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    6f6a:	f895 102b 	ldrb.w	r1, [r5, #43]	; 0x2b
    6f6e:	2908      	cmp	r1, #8
    6f70:	d802      	bhi.n	6f78 <valid_adv_param+0x44>
    6f72:	68b1      	ldr	r1, [r6, #8]
    6f74:	299f      	cmp	r1, #159	; 0x9f
    6f76:	d9e5      	bls.n	6f44 <valid_adv_param+0x10>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) || !dir_adv) {
    6f78:	06db      	lsls	r3, r3, #27
    6f7a:	d400      	bmi.n	6f7e <valid_adv_param+0x4a>
    6f7c:	b954      	cbnz	r4, 6f94 <valid_adv_param+0x60>
		if (param->interval_min > param->interval_max ||
    6f7e:	e9d6 3402 	ldrd	r3, r4, [r6, #8]
    6f82:	42a3      	cmp	r3, r4
    6f84:	d8de      	bhi.n	6f44 <valid_adv_param+0x10>
    6f86:	2b1f      	cmp	r3, #31
    6f88:	d9dc      	bls.n	6f44 <valid_adv_param+0x10>
		    param->interval_min < 0x0020 ||
    6f8a:	f5b4 4f80 	cmp.w	r4, #16384	; 0x4000
    6f8e:	bf8c      	ite	hi
    6f90:	2400      	movhi	r4, #0
    6f92:	2401      	movls	r4, #1
		}
	}

	return true;
}
    6f94:	4620      	mov	r0, r4
    6f96:	b002      	add	sp, #8
    6f98:	bd70      	pop	{r4, r5, r6, pc}
    6f9a:	bf00      	nop
    6f9c:	20006860 	.word	0x20006860

00006fa0 <hci_cmd_complete>:
{
    6fa0:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    6fa2:	2103      	movs	r1, #3
{
    6fa4:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
    6fa6:	3008      	adds	r0, #8
    6fa8:	f018 f974 	bl	1f294 <net_buf_simple_pull_mem>
	status = buf->data[0];
    6fac:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
    6fae:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
    6fb0:	7819      	ldrb	r1, [r3, #0]
    6fb2:	f8b0 0001 	ldrh.w	r0, [r0, #1]
    6fb6:	4622      	mov	r2, r4
    6fb8:	f7ff fce8 	bl	698c <hci_cmd_done>
	if (ncmd) {
    6fbc:	b125      	cbz	r5, 6fc8 <hci_cmd_complete+0x28>
    6fbe:	4803      	ldr	r0, [pc, #12]	; (6fcc <hci_cmd_complete+0x2c>)
}
    6fc0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    6fc4:	f01b bb74 	b.w	226b0 <z_impl_k_sem_give>
    6fc8:	bd38      	pop	{r3, r4, r5, pc}
    6fca:	bf00      	nop
    6fcc:	20006920 	.word	0x20006920

00006fd0 <bt_hci_cmd_create>:
{
    6fd0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6fd4:	4605      	mov	r5, r0
    6fd6:	460e      	mov	r6, r1
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
    6fd8:	481c      	ldr	r0, [pc, #112]	; (704c <bt_hci_cmd_create+0x7c>)
    6fda:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    6fde:	f021 fe8c 	bl	28cfa <net_buf_alloc_fixed>
	__ASSERT_NO_MSG(buf);
    6fe2:	4604      	mov	r4, r0
    6fe4:	b958      	cbnz	r0, 6ffe <bt_hci_cmd_create+0x2e>
    6fe6:	491a      	ldr	r1, [pc, #104]	; (7050 <bt_hci_cmd_create+0x80>)
    6fe8:	481a      	ldr	r0, [pc, #104]	; (7054 <bt_hci_cmd_create+0x84>)
    6fea:	4a1b      	ldr	r2, [pc, #108]	; (7058 <bt_hci_cmd_create+0x88>)
    6fec:	f240 1325 	movw	r3, #293	; 0x125
    6ff0:	f01c ff77 	bl	23ee2 <printk>
    6ff4:	4818      	ldr	r0, [pc, #96]	; (7058 <bt_hci_cmd_create+0x88>)
    6ff6:	f240 1125 	movw	r1, #293	; 0x125
    6ffa:	f01c ffb5 	bl	23f68 <assert_post_action>
	net_buf_reserve(buf, BT_BUF_RESERVE);
    6ffe:	f104 0b08 	add.w	fp, r4, #8
    7002:	2100      	movs	r1, #0
	*(u8_t *)net_buf_user_data(buf) = type;
    7004:	2700      	movs	r7, #0
    7006:	4658      	mov	r0, fp
    7008:	f017 ff5a 	bl	1eec0 <net_buf_simple_reserve>
    700c:	7527      	strb	r7, [r4, #20]
	cmd(buf)->opcode = opcode;
    700e:	4620      	mov	r0, r4
    7010:	f017 fe30 	bl	1ec74 <net_buf_id>
    7014:	f8df 8044 	ldr.w	r8, [pc, #68]	; 705c <bt_hci_cmd_create+0x8c>
    7018:	f04f 0a0c 	mov.w	sl, #12
    701c:	fb0a 8000 	mla	r0, sl, r0, r8
    7020:	8045      	strh	r5, [r0, #2]
	cmd(buf)->sync = NULL;
    7022:	4620      	mov	r0, r4
    7024:	f017 fe26 	bl	1ec74 <net_buf_id>
    7028:	fb0a 8000 	mla	r0, sl, r0, r8
    702c:	6087      	str	r7, [r0, #8]
	cmd(buf)->state = NULL;
    702e:	4620      	mov	r0, r4
    7030:	f017 fe20 	bl	1ec74 <net_buf_id>
    7034:	fb0a 8000 	mla	r0, sl, r0, r8
	hdr = net_buf_add(buf, sizeof(*hdr));
    7038:	2103      	movs	r1, #3
	cmd(buf)->state = NULL;
    703a:	6047      	str	r7, [r0, #4]
	hdr = net_buf_add(buf, sizeof(*hdr));
    703c:	4658      	mov	r0, fp
    703e:	f018 f94b 	bl	1f2d8 <net_buf_simple_add>
	hdr->param_len = param_len;
    7042:	7086      	strb	r6, [r0, #2]
	hdr->opcode = sys_cpu_to_le16(opcode);
    7044:	8005      	strh	r5, [r0, #0]
}
    7046:	4620      	mov	r0, r4
    7048:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    704c:	20007748 	.word	0x20007748
    7050:	00030dcd 	.word	0x00030dcd
    7054:	0002a5e8 	.word	0x0002a5e8
    7058:	0002bd96 	.word	0x0002bd96
    705c:	20000458 	.word	0x20000458

00007060 <bt_hci_cmd_send>:
{
    7060:	b538      	push	{r3, r4, r5, lr}
    7062:	4605      	mov	r5, r0
	if (!buf) {
    7064:	460c      	mov	r4, r1
    7066:	b919      	cbnz	r1, 7070 <bt_hci_cmd_send+0x10>
		buf = bt_hci_cmd_create(opcode, 0);
    7068:	f7ff ffb2 	bl	6fd0 <bt_hci_cmd_create>
		if (!buf) {
    706c:	4604      	mov	r4, r0
    706e:	b1f0      	cbz	r0, 70ae <bt_hci_cmd_send+0x4e>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
    7070:	f640 4335 	movw	r3, #3125	; 0xc35
    7074:	429d      	cmp	r5, r3
    7076:	d114      	bne.n	70a2 <bt_hci_cmd_send+0x42>
		return bt_hci_ecc_send(buf);
    7078:	4620      	mov	r0, r4
    707a:	f7ff f8cd 	bl	6218 <bt_hci_ecc_send>
		if (err) {
    707e:	4605      	mov	r5, r0
    7080:	b168      	cbz	r0, 709e <bt_hci_cmd_send+0x3e>
    7082:	4b0c      	ldr	r3, [pc, #48]	; (70b4 <bt_hci_cmd_send+0x54>)
    7084:	4a0c      	ldr	r2, [pc, #48]	; (70b8 <bt_hci_cmd_send+0x58>)
    7086:	1ad2      	subs	r2, r2, r3
    7088:	08d2      	lsrs	r2, r2, #3
			BT_ERR("Unable to send to driver (err %d)", err);
    708a:	0192      	lsls	r2, r2, #6
    708c:	4601      	mov	r1, r0
    708e:	f042 0201 	orr.w	r2, r2, #1
    7092:	480a      	ldr	r0, [pc, #40]	; (70bc <bt_hci_cmd_send+0x5c>)
    7094:	f01c ffa3 	bl	23fde <log_1>
			net_buf_unref(buf);
    7098:	4620      	mov	r0, r4
    709a:	f018 f815 	bl	1f0c8 <net_buf_unref>
}
    709e:	4628      	mov	r0, r5
    70a0:	bd38      	pop	{r3, r4, r5, pc}
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    70a2:	4807      	ldr	r0, [pc, #28]	; (70c0 <bt_hci_cmd_send+0x60>)
    70a4:	4621      	mov	r1, r4
    70a6:	f017 ffdb 	bl	1f060 <net_buf_put>
	return 0;
    70aa:	2500      	movs	r5, #0
    70ac:	e7f7      	b.n	709e <bt_hci_cmd_send+0x3e>
			return -ENOBUFS;
    70ae:	f06f 0536 	mvn.w	r5, #54	; 0x36
    70b2:	e7f4      	b.n	709e <bt_hci_cmd_send+0x3e>
    70b4:	00029830 	.word	0x00029830
    70b8:	000298f0 	.word	0x000298f0
    70bc:	0002bdee 	.word	0x0002bdee
    70c0:	2000693c 	.word	0x2000693c

000070c4 <le_conn_param_neg_reply>:
{
    70c4:	b570      	push	{r4, r5, r6, lr}
    70c6:	4606      	mov	r6, r0
    70c8:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
    70ca:	f242 0021 	movw	r0, #8225	; 0x2021
    70ce:	2103      	movs	r1, #3
    70d0:	f7ff ff7e 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    70d4:	4604      	mov	r4, r0
    70d6:	b958      	cbnz	r0, 70f0 <le_conn_param_neg_reply+0x2c>
    70d8:	490c      	ldr	r1, [pc, #48]	; (710c <le_conn_param_neg_reply+0x48>)
    70da:	4b0d      	ldr	r3, [pc, #52]	; (7110 <le_conn_param_neg_reply+0x4c>)
		BT_ERR("Unable to allocate buffer");
    70dc:	480d      	ldr	r0, [pc, #52]	; (7114 <le_conn_param_neg_reply+0x50>)
    70de:	1ac9      	subs	r1, r1, r3
    70e0:	08c9      	lsrs	r1, r1, #3
    70e2:	0189      	lsls	r1, r1, #6
}
    70e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to allocate buffer");
    70e8:	f041 0101 	orr.w	r1, r1, #1
    70ec:	f01c bf6a 	b.w	23fc4 <log_0>
	cp = net_buf_add(buf, sizeof(*cp));
    70f0:	2103      	movs	r1, #3
    70f2:	3008      	adds	r0, #8
    70f4:	f018 f8f0 	bl	1f2d8 <net_buf_simple_add>
	cp->reason = sys_cpu_to_le16(reason);
    70f8:	7085      	strb	r5, [r0, #2]
	cp->handle = sys_cpu_to_le16(handle);
    70fa:	8006      	strh	r6, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    70fc:	4621      	mov	r1, r4
    70fe:	f242 0021 	movw	r0, #8225	; 0x2021
}
    7102:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    7106:	f7ff bfab 	b.w	7060 <bt_hci_cmd_send>
    710a:	bf00      	nop
    710c:	000298f0 	.word	0x000298f0
    7110:	00029830 	.word	0x00029830
    7114:	0002be7d 	.word	0x0002be7d

00007118 <le_conn_param_req>:
{
    7118:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
    711a:	6883      	ldr	r3, [r0, #8]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    711c:	78d9      	ldrb	r1, [r3, #3]
    711e:	789a      	ldrb	r2, [r3, #2]
	handle = sys_le16_to_cpu(evt->handle);
    7120:	881f      	ldrh	r7, [r3, #0]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    7122:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    7126:	f8ad 2000 	strh.w	r2, [sp]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
    712a:	7959      	ldrb	r1, [r3, #5]
    712c:	791a      	ldrb	r2, [r3, #4]
    712e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    7132:	f8ad 2002 	strh.w	r2, [sp, #2]
	param.latency = sys_le16_to_cpu(evt->latency);
    7136:	799a      	ldrb	r2, [r3, #6]
    7138:	79d9      	ldrb	r1, [r3, #7]
    713a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    713e:	f8ad 2004 	strh.w	r2, [sp, #4]
	param.timeout = sys_le16_to_cpu(evt->timeout);
    7142:	7a1a      	ldrb	r2, [r3, #8]
    7144:	7a5b      	ldrb	r3, [r3, #9]
	handle = sys_le16_to_cpu(evt->handle);
    7146:	b2bc      	uxth	r4, r7
	param.timeout = sys_le16_to_cpu(evt->timeout);
    7148:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	conn = bt_conn_lookup_handle(handle);
    714c:	4620      	mov	r0, r4
	param.timeout = sys_le16_to_cpu(evt->timeout);
    714e:	f8ad 3006 	strh.w	r3, [sp, #6]
	conn = bt_conn_lookup_handle(handle);
    7152:	f002 f8d5 	bl	9300 <bt_conn_lookup_handle>
	if (!conn) {
    7156:	4606      	mov	r6, r0
    7158:	b980      	cbnz	r0, 717c <le_conn_param_req+0x64>
    715a:	4b20      	ldr	r3, [pc, #128]	; (71dc <le_conn_param_req+0xc4>)
    715c:	4a20      	ldr	r2, [pc, #128]	; (71e0 <le_conn_param_req+0xc8>)
		BT_ERR("Unable to lookup conn for handle %u", handle);
    715e:	4821      	ldr	r0, [pc, #132]	; (71e4 <le_conn_param_req+0xcc>)
    7160:	1ad2      	subs	r2, r2, r3
    7162:	08d2      	lsrs	r2, r2, #3
    7164:	0192      	lsls	r2, r2, #6
    7166:	4621      	mov	r1, r4
    7168:	f042 0201 	orr.w	r2, r2, #1
    716c:	f01c ff37 	bl	23fde <log_1>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
    7170:	2102      	movs	r1, #2
    7172:	4620      	mov	r0, r4
    7174:	f7ff ffa6 	bl	70c4 <le_conn_param_neg_reply>
}
    7178:	b003      	add	sp, #12
    717a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!le_param_req(conn, &param)) {
    717c:	4669      	mov	r1, sp
    717e:	f001 fe4f 	bl	8e20 <le_param_req>
    7182:	b938      	cbnz	r0, 7194 <le_conn_param_req+0x7c>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
    7184:	211e      	movs	r1, #30
    7186:	4620      	mov	r0, r4
    7188:	f7ff ff9c 	bl	70c4 <le_conn_param_neg_reply>
	bt_conn_unref(conn);
    718c:	4630      	mov	r0, r6
    718e:	f01f fa12 	bl	265b6 <bt_conn_unref>
    7192:	e7f1      	b.n	7178 <le_conn_param_req+0x60>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
    7194:	210e      	movs	r1, #14
    7196:	f242 0020 	movw	r0, #8224	; 0x2020
    719a:	f7ff ff19 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    719e:	4605      	mov	r5, r0
    71a0:	2800      	cmp	r0, #0
    71a2:	d0f3      	beq.n	718c <le_conn_param_req+0x74>
	cp = net_buf_add(buf, sizeof(*cp));
    71a4:	210e      	movs	r1, #14
    71a6:	3008      	adds	r0, #8
    71a8:	f018 f896 	bl	1f2d8 <net_buf_simple_add>
	(void)memset(cp, 0, sizeof(*cp));
    71ac:	220e      	movs	r2, #14
	cp = net_buf_add(buf, sizeof(*cp));
    71ae:	4604      	mov	r4, r0
	(void)memset(cp, 0, sizeof(*cp));
    71b0:	2100      	movs	r1, #0
    71b2:	f01e fda4 	bl	25cfe <memset>
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
    71b6:	f8bd 3000 	ldrh.w	r3, [sp]
    71ba:	8063      	strh	r3, [r4, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
    71bc:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    71c0:	80a3      	strh	r3, [r4, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
    71c2:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    71c6:	80e3      	strh	r3, [r4, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
    71c8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
	cp->handle = sys_cpu_to_le16(handle);
    71cc:	8027      	strh	r7, [r4, #0]
	cp->timeout = sys_cpu_to_le16(param->timeout);
    71ce:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
    71d0:	4629      	mov	r1, r5
    71d2:	f242 0020 	movw	r0, #8224	; 0x2020
    71d6:	f7ff ff43 	bl	7060 <bt_hci_cmd_send>
    71da:	e7d7      	b.n	718c <le_conn_param_req+0x74>
    71dc:	00029830 	.word	0x00029830
    71e0:	000298f0 	.word	0x000298f0
    71e4:	0002bca2 	.word	0x0002bca2

000071e8 <conn_auto_initiate>:
{
    71e8:	b570      	push	{r4, r5, r6, lr}
	if (conn->state != BT_CONN_CONNECTED) {
    71ea:	7a83      	ldrb	r3, [r0, #10]
    71ec:	2b06      	cmp	r3, #6
{
    71ee:	4604      	mov	r4, r0
	if (conn->state != BT_CONN_CONNECTED) {
    71f0:	d131      	bne.n	7256 <conn_auto_initiate+0x6e>
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
    71f2:	1d06      	adds	r6, r0, #4
    71f4:	4630      	mov	r0, r6
    71f6:	f01f f879 	bl	262ec <atomic_get>
    71fa:	0481      	lsls	r1, r0, #18
    71fc:	d41a      	bmi.n	7234 <conn_auto_initiate+0x4c>
    71fe:	78e3      	ldrb	r3, [r4, #3]
    7200:	b123      	cbz	r3, 720c <conn_auto_initiate+0x24>
	     BT_FEAT_LE_SLAVE_FEATURE_XCHG(bt_dev.le.features))) {
    7202:	4b15      	ldr	r3, [pc, #84]	; (7258 <conn_auto_initiate+0x70>)
	    ((conn->role == BT_HCI_ROLE_MASTER) ||
    7204:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
    7208:	071a      	lsls	r2, r3, #28
    720a:	d513      	bpl.n	7234 <conn_auto_initiate+0x4c>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
    720c:	2102      	movs	r1, #2
    720e:	f242 0016 	movw	r0, #8214	; 0x2016
    7212:	f7ff fedd 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    7216:	4605      	mov	r5, r0
    7218:	b160      	cbz	r0, 7234 <conn_auto_initiate+0x4c>
	cp = net_buf_add(buf, sizeof(*cp));
    721a:	2102      	movs	r1, #2
    721c:	3008      	adds	r0, #8
    721e:	f018 f85b 	bl	1f2d8 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    7222:	8823      	ldrh	r3, [r4, #0]
    7224:	8003      	strh	r3, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    7226:	4629      	mov	r1, r5
    7228:	f242 0016 	movw	r0, #8214	; 0x2016
}
    722c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    7230:	f7ff bf16 	b.w	7060 <bt_hci_cmd_send>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    7234:	78e3      	ldrb	r3, [r4, #3]
    7236:	2b01      	cmp	r3, #1
    7238:	d10d      	bne.n	7256 <conn_auto_initiate+0x6e>
    723a:	4630      	mov	r0, r6
    723c:	f01f f856 	bl	262ec <atomic_get>
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_UPDATE)) {
    7240:	05c3      	lsls	r3, r0, #23
    7242:	d408      	bmi.n	7256 <conn_auto_initiate+0x6e>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    7244:	f104 0154 	add.w	r1, r4, #84	; 0x54
    7248:	4804      	ldr	r0, [pc, #16]	; (725c <conn_auto_initiate+0x74>)
}
    724a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    724e:	f241 3288 	movw	r2, #5000	; 0x1388
    7252:	f01b bc85 	b.w	22b60 <k_delayed_work_submit_to_queue>
    7256:	bd70      	pop	{r4, r5, r6, pc}
    7258:	20006860 	.word	0x20006860
    725c:	20001dc4 	.word	0x20001dc4

00007260 <le_remote_feat_complete>:
{
    7260:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
    7262:	6885      	ldr	r5, [r0, #8]
	u16_t handle = sys_le16_to_cpu(evt->handle);
    7264:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    7268:	4630      	mov	r0, r6
    726a:	f002 f849 	bl	9300 <bt_conn_lookup_handle>
	if (!conn) {
    726e:	4604      	mov	r4, r0
    7270:	b960      	cbnz	r0, 728c <le_remote_feat_complete+0x2c>
    7272:	4a10      	ldr	r2, [pc, #64]	; (72b4 <le_remote_feat_complete+0x54>)
    7274:	4b10      	ldr	r3, [pc, #64]	; (72b8 <le_remote_feat_complete+0x58>)
		BT_ERR("Unable to lookup conn for handle %u", handle);
    7276:	4811      	ldr	r0, [pc, #68]	; (72bc <le_remote_feat_complete+0x5c>)
    7278:	1ad2      	subs	r2, r2, r3
    727a:	08d2      	lsrs	r2, r2, #3
    727c:	0192      	lsls	r2, r2, #6
    727e:	4631      	mov	r1, r6
    7280:	f042 0201 	orr.w	r2, r2, #1
}
    7284:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    7288:	f01c bea9 	b.w	23fde <log_1>
	if (!evt->status) {
    728c:	782b      	ldrb	r3, [r5, #0]
    728e:	b923      	cbnz	r3, 729a <le_remote_feat_complete+0x3a>
		memcpy(conn->le.features, evt->features,
    7290:	2208      	movs	r2, #8
    7292:	1ce9      	adds	r1, r5, #3
    7294:	3098      	adds	r0, #152	; 0x98
    7296:	f01e fd07 	bl	25ca8 <memcpy>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    729a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    729e:	1d20      	adds	r0, r4, #4
    72a0:	f01f f82d 	bl	262fe <atomic_or>
	conn_auto_initiate(conn);
    72a4:	4620      	mov	r0, r4
    72a6:	f7ff ff9f 	bl	71e8 <conn_auto_initiate>
	bt_conn_unref(conn);
    72aa:	4620      	mov	r0, r4
}
    72ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
    72b0:	f01f b981 	b.w	265b6 <bt_conn_unref>
    72b4:	000298f0 	.word	0x000298f0
    72b8:	00029830 	.word	0x00029830
    72bc:	0002bca2 	.word	0x0002bca2

000072c0 <bt_hci_cmd_send_sync>:
{
    72c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    72c2:	4615      	mov	r5, r2
    72c4:	b087      	sub	sp, #28
	if (!buf) {
    72c6:	460c      	mov	r4, r1
    72c8:	b921      	cbnz	r1, 72d4 <bt_hci_cmd_send_sync+0x14>
		buf = bt_hci_cmd_create(opcode, 0);
    72ca:	f7ff fe81 	bl	6fd0 <bt_hci_cmd_create>
		if (!buf) {
    72ce:	4604      	mov	r4, r0
    72d0:	2800      	cmp	r0, #0
    72d2:	d048      	beq.n	7366 <bt_hci_cmd_send_sync+0xa6>
	return z_impl_k_sem_init(sem, initial_count, limit);
    72d4:	2201      	movs	r2, #1
    72d6:	2100      	movs	r1, #0
    72d8:	4668      	mov	r0, sp
    72da:	f021 fffd 	bl	292d8 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    72de:	4620      	mov	r0, r4
    72e0:	f017 fcc8 	bl	1ec74 <net_buf_id>
    72e4:	4e21      	ldr	r6, [pc, #132]	; (736c <bt_hci_cmd_send_sync+0xac>)
    72e6:	230c      	movs	r3, #12
    72e8:	fb03 6000 	mla	r0, r3, r0, r6
    72ec:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_ref(buf);
    72f0:	4620      	mov	r0, r4
    72f2:	f017 ff31 	bl	1f158 <net_buf_ref>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    72f6:	481e      	ldr	r0, [pc, #120]	; (7370 <bt_hci_cmd_send_sync+0xb0>)
    72f8:	4621      	mov	r1, r4
    72fa:	f017 feb1 	bl	1f060 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    72fe:	f242 7110 	movw	r1, #10000	; 0x2710
    7302:	4668      	mov	r0, sp
    7304:	f01b fa18 	bl	22738 <z_impl_k_sem_take>
	__ASSERT(err == 0, "k_sem_take failed with err %d", err);
    7308:	4607      	mov	r7, r0
    730a:	b178      	cbz	r0, 732c <bt_hci_cmd_send_sync+0x6c>
    730c:	4a19      	ldr	r2, [pc, #100]	; (7374 <bt_hci_cmd_send_sync+0xb4>)
    730e:	491a      	ldr	r1, [pc, #104]	; (7378 <bt_hci_cmd_send_sync+0xb8>)
    7310:	481a      	ldr	r0, [pc, #104]	; (737c <bt_hci_cmd_send_sync+0xbc>)
    7312:	f240 136f 	movw	r3, #367	; 0x16f
    7316:	f01c fde4 	bl	23ee2 <printk>
    731a:	4819      	ldr	r0, [pc, #100]	; (7380 <bt_hci_cmd_send_sync+0xc0>)
    731c:	4639      	mov	r1, r7
    731e:	f01c fde0 	bl	23ee2 <printk>
    7322:	4814      	ldr	r0, [pc, #80]	; (7374 <bt_hci_cmd_send_sync+0xb4>)
    7324:	f240 116f 	movw	r1, #367	; 0x16f
    7328:	f01c fe1e 	bl	23f68 <assert_post_action>
	if (cmd(buf)->status) {
    732c:	4620      	mov	r0, r4
    732e:	f017 fca1 	bl	1ec74 <net_buf_id>
    7332:	270c      	movs	r7, #12
    7334:	4378      	muls	r0, r7
    7336:	5c32      	ldrb	r2, [r6, r0]
    7338:	b172      	cbz	r2, 7358 <bt_hci_cmd_send_sync+0x98>
		switch (cmd(buf)->status) {
    733a:	4620      	mov	r0, r4
    733c:	f017 fc9a 	bl	1ec74 <net_buf_id>
    7340:	4347      	muls	r7, r0
    7342:	5df3      	ldrb	r3, [r6, r7]
			err = -EIO;
    7344:	2b09      	cmp	r3, #9
    7346:	bf0c      	ite	eq
    7348:	f06f 053c 	mvneq.w	r5, #60	; 0x3c
    734c:	f06f 0504 	mvnne.w	r5, #4
			net_buf_unref(buf);
    7350:	4620      	mov	r0, r4
    7352:	f017 feb9 	bl	1f0c8 <net_buf_unref>
    7356:	e003      	b.n	7360 <bt_hci_cmd_send_sync+0xa0>
		if (rsp) {
    7358:	2d00      	cmp	r5, #0
    735a:	d0f9      	beq.n	7350 <bt_hci_cmd_send_sync+0x90>
			*rsp = buf;
    735c:	602c      	str	r4, [r5, #0]
		err = 0;
    735e:	4615      	mov	r5, r2
}
    7360:	4628      	mov	r0, r5
    7362:	b007      	add	sp, #28
    7364:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return -ENOBUFS;
    7366:	f06f 0536 	mvn.w	r5, #54	; 0x36
    736a:	e7f9      	b.n	7360 <bt_hci_cmd_send_sync+0xa0>
    736c:	20000458 	.word	0x20000458
    7370:	2000693c 	.word	0x2000693c
    7374:	0002bd96 	.word	0x0002bd96
    7378:	0002bdca 	.word	0x0002bdca
    737c:	0002a5e8 	.word	0x0002a5e8
    7380:	0002be97 	.word	0x0002be97

00007384 <set_le_scan_enable_legacy>:
{
    7384:	b530      	push	{r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
    7386:	2102      	movs	r1, #2
{
    7388:	b085      	sub	sp, #20
    738a:	4604      	mov	r4, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
    738c:	f242 000c 	movw	r0, #8204	; 0x200c
    7390:	f7ff fe1e 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    7394:	4605      	mov	r5, r0
    7396:	b348      	cbz	r0, 73ec <set_le_scan_enable_legacy+0x68>
	cp = net_buf_add(buf, sizeof(*cp));
    7398:	2102      	movs	r1, #2
    739a:	3008      	adds	r0, #8
    739c:	f017 ff9c 	bl	1f2d8 <net_buf_simple_add>
	if (enable == BT_HCI_LE_SCAN_ENABLE) {
    73a0:	2c01      	cmp	r4, #1
	cp = net_buf_add(buf, sizeof(*cp));
    73a2:	4603      	mov	r3, r0
	if (enable == BT_HCI_LE_SCAN_ENABLE) {
    73a4:	d11f      	bne.n	73e6 <set_le_scan_enable_legacy+0x62>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    73a6:	4813      	ldr	r0, [pc, #76]	; (73f4 <set_le_scan_enable_legacy+0x70>)
    73a8:	f01e ffa0 	bl	262ec <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    73ac:	f3c0 3040 	ubfx	r0, r0, #13, #1
    73b0:	7058      	strb	r0, [r3, #1]
	cp->enable = enable;
    73b2:	701c      	strb	r4, [r3, #0]
	state->target = target;
    73b4:	4b0f      	ldr	r3, [pc, #60]	; (73f4 <set_le_scan_enable_legacy+0x70>)
    73b6:	9301      	str	r3, [sp, #4]
	cmd_state_set_init(&state, bt_dev.flags, BT_DEV_SCANNING,
    73b8:	f004 0401 	and.w	r4, r4, #1
	state->bit = bit;
    73bc:	230a      	movs	r3, #10
	cmd(buf)->state = &state;
    73be:	4628      	mov	r0, r5
	state->bit = bit;
    73c0:	9302      	str	r3, [sp, #8]
	cmd_state_set_init(&state, bt_dev.flags, BT_DEV_SCANNING,
    73c2:	f88d 400c 	strb.w	r4, [sp, #12]
	cmd(buf)->state = &state;
    73c6:	f017 fc55 	bl	1ec74 <net_buf_id>
    73ca:	4b0b      	ldr	r3, [pc, #44]	; (73f8 <set_le_scan_enable_legacy+0x74>)
    73cc:	220c      	movs	r2, #12
    73ce:	fb02 3000 	mla	r0, r2, r0, r3
    73d2:	ab01      	add	r3, sp, #4
    73d4:	6043      	str	r3, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_ENABLE, buf, NULL);
    73d6:	2200      	movs	r2, #0
    73d8:	4629      	mov	r1, r5
    73da:	f242 000c 	movw	r0, #8204	; 0x200c
    73de:	f7ff ff6f 	bl	72c0 <bt_hci_cmd_send_sync>
}
    73e2:	b005      	add	sp, #20
    73e4:	bd30      	pop	{r4, r5, pc}
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
    73e6:	2200      	movs	r2, #0
    73e8:	7042      	strb	r2, [r0, #1]
    73ea:	e7e2      	b.n	73b2 <set_le_scan_enable_legacy+0x2e>
		return -ENOBUFS;
    73ec:	f06f 0036 	mvn.w	r0, #54	; 0x36
    73f0:	e7f7      	b.n	73e2 <set_le_scan_enable_legacy+0x5e>
    73f2:	bf00      	nop
    73f4:	200068ec 	.word	0x200068ec
    73f8:	20000458 	.word	0x20000458

000073fc <hci_set_ad>:
{
    73fc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7400:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    7402:	2120      	movs	r1, #32
{
    7404:	4682      	mov	sl, r0
    7406:	4615      	mov	r5, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    7408:	f7ff fde2 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    740c:	4606      	mov	r6, r0
    740e:	2800      	cmp	r0, #0
    7410:	d05b      	beq.n	74ca <hci_set_ad+0xce>
	set_data = net_buf_add(buf, sizeof(*set_data));
    7412:	2120      	movs	r1, #32
    7414:	3008      	adds	r0, #8
    7416:	f017 ff5f 	bl	1f2d8 <net_buf_simple_add>
	(void)memset(set_data, 0, sizeof(*set_data));
    741a:	2220      	movs	r2, #32
    741c:	2100      	movs	r1, #0
	set_data = net_buf_add(buf, sizeof(*set_data));
    741e:	4681      	mov	r9, r0
	(void)memset(set_data, 0, sizeof(*set_data));
    7420:	f01e fc6d 	bl	25cfe <memset>
	err = set_data_add(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
    7424:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
    7428:	f109 0b01 	add.w	fp, r9, #1
	for (size_t i = 0; i < ad_len; i++) {
    742c:	9300      	str	r3, [sp, #0]
	u8_t set_data_len = 0;
    742e:	2500      	movs	r5, #0
		for (size_t j = 0; j < ad[i].len; j++) {
    7430:	f8d4 8000 	ldr.w	r8, [r4]
    7434:	2300      	movs	r3, #0
    7436:	6862      	ldr	r2, [r4, #4]
    7438:	4293      	cmp	r3, r2
    743a:	d30d      	bcc.n	7458 <hci_set_ad+0x5c>
	for (size_t i = 0; i < ad_len; i++) {
    743c:	9b00      	ldr	r3, [sp, #0]
    743e:	3408      	adds	r4, #8
    7440:	429c      	cmp	r4, r3
    7442:	d1f5      	bne.n	7430 <hci_set_ad+0x34>
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    7444:	2200      	movs	r2, #0
    7446:	4631      	mov	r1, r6
    7448:	4650      	mov	r0, sl
	*data_len = set_data_len;
    744a:	f889 5000 	strb.w	r5, [r9]
}
    744e:	b003      	add	sp, #12
    7450:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    7454:	f7ff bf34 	b.w	72c0 <bt_hci_cmd_send_sync>
			size_t len = data[j].data_len;
    7458:	f898 2001 	ldrb.w	r2, [r8, #1]
			u8_t type = data[j].type;
    745c:	f898 c000 	ldrb.w	ip, [r8]
			if ((set_data_len + len + 2) > set_data_len_max) {
    7460:	1ca8      	adds	r0, r5, #2
    7462:	1881      	adds	r1, r0, r2
    7464:	291f      	cmp	r1, #31
    7466:	d919      	bls.n	749c <hci_set_ad+0xa0>
				if (type != BT_DATA_NAME_COMPLETE || !len) {
    7468:	f1bc 0f09 	cmp.w	ip, #9
				len = set_data_len_max - (set_data_len + 2);
    746c:	f1c5 021d 	rsb	r2, r5, #29
				if (type != BT_DATA_NAME_COMPLETE || !len) {
    7470:	d100      	bne.n	7474 <hci_set_ad+0x78>
    7472:	b98a      	cbnz	r2, 7498 <hci_set_ad+0x9c>
    7474:	4b16      	ldr	r3, [pc, #88]	; (74d0 <hci_set_ad+0xd4>)
    7476:	4917      	ldr	r1, [pc, #92]	; (74d4 <hci_set_ad+0xd8>)
					BT_ERR("Too big advertising data");
    7478:	4817      	ldr	r0, [pc, #92]	; (74d8 <hci_set_ad+0xdc>)
    747a:	1ac9      	subs	r1, r1, r3
    747c:	08c9      	lsrs	r1, r1, #3
    747e:	0189      	lsls	r1, r1, #6
    7480:	f041 0101 	orr.w	r1, r1, #1
    7484:	f01c fd9e 	bl	23fc4 <log_0>
		net_buf_unref(buf);
    7488:	4630      	mov	r0, r6
    748a:	f017 fe1d 	bl	1f0c8 <net_buf_unref>
					return -EINVAL;
    748e:	f06f 0015 	mvn.w	r0, #21
}
    7492:	b003      	add	sp, #12
    7494:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				type = BT_DATA_NAME_SHORTENED;
    7498:	f04f 0c08 	mov.w	ip, #8
			set_data[set_data_len++] = len + 1;
    749c:	b2d7      	uxtb	r7, r2
    749e:	1c79      	adds	r1, r7, #1
    74a0:	f80b 1005 	strb.w	r1, [fp, r5]
    74a4:	1c69      	adds	r1, r5, #1
			set_data[set_data_len++] = type;
    74a6:	b2c9      	uxtb	r1, r1
			memcpy(&set_data[set_data_len], data[j].data, len);
    74a8:	fa5b f080 	uxtab	r0, fp, r0
			set_data[set_data_len++] = type;
    74ac:	f80b c001 	strb.w	ip, [fp, r1]
			memcpy(&set_data[set_data_len], data[j].data, len);
    74b0:	f8d8 1004 	ldr.w	r1, [r8, #4]
    74b4:	9301      	str	r3, [sp, #4]
			set_data_len += len;
    74b6:	3702      	adds	r7, #2
			memcpy(&set_data[set_data_len], data[j].data, len);
    74b8:	f01e fbf6 	bl	25ca8 <memcpy>
		for (size_t j = 0; j < ad[i].len; j++) {
    74bc:	9b01      	ldr	r3, [sp, #4]
			set_data_len += len;
    74be:	443d      	add	r5, r7
    74c0:	b2ed      	uxtb	r5, r5
		for (size_t j = 0; j < ad[i].len; j++) {
    74c2:	3301      	adds	r3, #1
    74c4:	f108 0808 	add.w	r8, r8, #8
    74c8:	e7b5      	b.n	7436 <hci_set_ad+0x3a>
		return -ENOBUFS;
    74ca:	f06f 0036 	mvn.w	r0, #54	; 0x36
    74ce:	e7e0      	b.n	7492 <hci_set_ad+0x96>
    74d0:	00029830 	.word	0x00029830
    74d4:	000298f0 	.word	0x000298f0
    74d8:	0002beb7 	.word	0x0002beb7

000074dc <le_adv_update.isra.0>:
	}

	return false;
}

static int le_adv_update(struct bt_le_ext_adv *adv,
    74dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    74e0:	b086      	sub	sp, #24
	struct bt_ad d[2] = {};
	struct bt_data data;
	int err;

	d[0].data = ad;
	d[0].len = ad_len;
    74e2:	e9cd 0102 	strd	r0, r1, [sp, #8]
static int le_adv_update(struct bt_le_ext_adv *adv,
    74e6:	4615      	mov	r5, r2
    74e8:	461e      	mov	r6, r3
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
    74ea:	2201      	movs	r2, #1
	struct bt_ad d[2] = {};
    74ec:	2300      	movs	r3, #0
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
    74ee:	a902      	add	r1, sp, #8
    74f0:	f242 0008 	movw	r0, #8200	; 0x2008
	struct bt_ad d[2] = {};
    74f4:	e9cd 3304 	strd	r3, r3, [sp, #16]
static int le_adv_update(struct bt_le_ext_adv *adv,
    74f8:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
    74fc:	f89d 8034 	ldrb.w	r8, [sp, #52]	; 0x34
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
    7500:	f7ff ff7c 	bl	73fc <hci_set_ad>

	err = set_ad(adv, d, 1);
	if (err) {
    7504:	4604      	mov	r4, r0
    7506:	bb10      	cbnz	r0, 754e <le_adv_update.isra.0+0x72>
		return err;
	}

	d[0].data = sd;
	d[0].len = sd_len;
    7508:	e9cd 5602 	strd	r5, r6, [sp, #8]

	if (use_name) {
    750c:	f1b8 0f00 	cmp.w	r8, #0
    7510:	d011      	beq.n	7536 <le_adv_update.isra.0+0x5a>
		const char *name;

		if (sd) {
    7512:	b115      	cbz	r5, 751a <le_adv_update.isra.0+0x3e>
	for (i = 0; i < ad_len; i++) {
    7514:	4602      	mov	r2, r0
    7516:	4296      	cmp	r6, r2
    7518:	d11d      	bne.n	7556 <le_adv_update.isra.0+0x7a>
				return -EINVAL;
			}
		}

		name = bt_get_name();
		data = (struct bt_data)BT_DATA(
    751a:	4d14      	ldr	r5, [pc, #80]	; (756c <le_adv_update.isra.0+0x90>)
    751c:	4628      	mov	r0, r5
    751e:	f01e fb91 	bl	25c44 <strlen>
    7522:	2309      	movs	r3, #9
    7524:	f88d 3000 	strb.w	r3, [sp]
			BT_DATA_NAME_COMPLETE,
			name, strlen(name));

		d[1].data = &data;
		d[1].len = 1;
    7528:	2301      	movs	r3, #1
		data = (struct bt_data)BT_DATA(
    752a:	f88d 0001 	strb.w	r0, [sp, #1]
    752e:	9501      	str	r5, [sp, #4]
		d[1].data = &data;
    7530:	f8cd d010 	str.w	sp, [sp, #16]
		d[1].len = 1;
    7534:	9305      	str	r3, [sp, #20]
	 * by previous calls.
	 * Clearing sd is done by calling set_sd() with NULL data and
	 * zero len.
	 * So following condition check is unusual but correct.
	 */
	if (d[0].data || d[1].data || connectable) {
    7536:	9b02      	ldr	r3, [sp, #8]
    7538:	b913      	cbnz	r3, 7540 <le_adv_update.isra.0+0x64>
    753a:	9b04      	ldr	r3, [sp, #16]
    753c:	b903      	cbnz	r3, 7540 <le_adv_update.isra.0+0x64>
    753e:	b137      	cbz	r7, 754e <le_adv_update.isra.0+0x72>
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    7540:	2202      	movs	r2, #2
    7542:	a902      	add	r1, sp, #8
    7544:	f242 0009 	movw	r0, #8201	; 0x2009
    7548:	f7ff ff58 	bl	73fc <hci_set_ad>
    754c:	4604      	mov	r4, r0
			return err;
		}
	}

	return 0;
}
    754e:	4620      	mov	r0, r4
    7550:	b006      	add	sp, #24
    7552:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
    7556:	f815 3032 	ldrb.w	r3, [r5, r2, lsl #3]
    755a:	3b08      	subs	r3, #8
    755c:	2b01      	cmp	r3, #1
    755e:	d901      	bls.n	7564 <le_adv_update.isra.0+0x88>
	for (i = 0; i < ad_len; i++) {
    7560:	3201      	adds	r2, #1
    7562:	e7d8      	b.n	7516 <le_adv_update.isra.0+0x3a>
				return -EINVAL;
    7564:	f06f 0415 	mvn.w	r4, #21
    7568:	e7f1      	b.n	754e <le_adv_update.isra.0+0x72>
    756a:	bf00      	nop
    756c:	20006954 	.word	0x20006954

00007570 <set_random_address>:
{
    7570:	b570      	push	{r4, r5, r6, lr}
	return memcmp(a, b, sizeof(*a));
    7572:	4e15      	ldr	r6, [pc, #84]	; (75c8 <set_random_address+0x58>)
    7574:	2206      	movs	r2, #6
    7576:	f106 0125 	add.w	r1, r6, #37	; 0x25
    757a:	4605      	mov	r5, r0
    757c:	f01e fb84 	bl	25c88 <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    7580:	4604      	mov	r4, r0
    7582:	b1e0      	cbz	r0, 75be <set_random_address+0x4e>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    7584:	2106      	movs	r1, #6
    7586:	f242 0005 	movw	r0, #8197	; 0x2005
    758a:	f7ff fd21 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    758e:	4604      	mov	r4, r0
    7590:	b1b8      	cbz	r0, 75c2 <set_random_address+0x52>
	net_buf_add_mem(buf, addr, sizeof(*addr));
    7592:	2206      	movs	r2, #6
    7594:	4629      	mov	r1, r5
    7596:	3008      	adds	r0, #8
    7598:	f021 fc0d 	bl	28db6 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    759c:	4621      	mov	r1, r4
    759e:	2200      	movs	r2, #0
    75a0:	f242 0005 	movw	r0, #8197	; 0x2005
    75a4:	f7ff fe8c 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    75a8:	4604      	mov	r4, r0
    75aa:	b940      	cbnz	r0, 75be <set_random_address+0x4e>
}

static inline void bt_addr_copy(bt_addr_t *dst, const bt_addr_t *src)
{
	memcpy(dst, src, sizeof(*dst));
    75ac:	2206      	movs	r2, #6
    75ae:	4629      	mov	r1, r5
    75b0:	f106 0025 	add.w	r0, r6, #37	; 0x25
    75b4:	f01e fb78 	bl	25ca8 <memcpy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    75b8:	2301      	movs	r3, #1
    75ba:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
}
    75be:	4620      	mov	r0, r4
    75c0:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
    75c2:	f06f 0436 	mvn.w	r4, #54	; 0x36
    75c6:	e7fa      	b.n	75be <set_random_address+0x4e>
    75c8:	20006860 	.word	0x20006860

000075cc <set_le_adv_enable_legacy>:
{
    75cc:	b530      	push	{r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    75ce:	2101      	movs	r1, #1
{
    75d0:	b085      	sub	sp, #20
    75d2:	4605      	mov	r5, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    75d4:	f242 000a 	movw	r0, #8202	; 0x200a
    75d8:	f7ff fcfa 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    75dc:	4604      	mov	r4, r0
    75de:	b1e8      	cbz	r0, 761c <set_le_adv_enable_legacy+0x50>
	if (enable) {
    75e0:	3008      	adds	r0, #8
    75e2:	b1cd      	cbz	r5, 7618 <set_le_adv_enable_legacy+0x4c>
		net_buf_add_u8(buf, BT_HCI_LE_ADV_ENABLE);
    75e4:	2101      	movs	r1, #1
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    75e6:	f021 fbf2 	bl	28dce <net_buf_simple_add_u8>
	state->target = target;
    75ea:	4b0e      	ldr	r3, [pc, #56]	; (7624 <set_le_adv_enable_legacy+0x58>)
    75ec:	9301      	str	r3, [sp, #4]
	cmd(buf)->state = &state;
    75ee:	4620      	mov	r0, r4
	state->bit = bit;
    75f0:	2305      	movs	r3, #5
    75f2:	9302      	str	r3, [sp, #8]
	state->val = val;
    75f4:	f88d 500c 	strb.w	r5, [sp, #12]
	cmd(buf)->state = &state;
    75f8:	f017 fb3c 	bl	1ec74 <net_buf_id>
    75fc:	4b0a      	ldr	r3, [pc, #40]	; (7628 <set_le_adv_enable_legacy+0x5c>)
    75fe:	220c      	movs	r2, #12
    7600:	fb02 3000 	mla	r0, r2, r0, r3
    7604:	ab01      	add	r3, sp, #4
    7606:	6043      	str	r3, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
    7608:	2200      	movs	r2, #0
    760a:	4621      	mov	r1, r4
    760c:	f242 000a 	movw	r0, #8202	; 0x200a
    7610:	f7ff fe56 	bl	72c0 <bt_hci_cmd_send_sync>
}
    7614:	b005      	add	sp, #20
    7616:	bd30      	pop	{r4, r5, pc}
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
    7618:	4629      	mov	r1, r5
    761a:	e7e4      	b.n	75e6 <set_le_adv_enable_legacy+0x1a>
		return -ENOBUFS;
    761c:	f06f 0036 	mvn.w	r0, #54	; 0x36
    7620:	e7f8      	b.n	7614 <set_le_adv_enable_legacy+0x48>
    7622:	bf00      	nop
    7624:	200068ec 	.word	0x200068ec
    7628:	20000458 	.word	0x20000458

0000762c <bt_le_scan_update>:
{
    762c:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    762e:	4809      	ldr	r0, [pc, #36]	; (7654 <bt_le_scan_update+0x28>)
    7630:	f01e fe5c 	bl	262ec <atomic_get>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    7634:	0501      	lsls	r1, r0, #20
    7636:	f3c0 23c0 	ubfx	r3, r0, #11, #1
    763a:	d409      	bmi.n	7650 <bt_le_scan_update+0x24>
    763c:	4805      	ldr	r0, [pc, #20]	; (7654 <bt_le_scan_update+0x28>)
    763e:	f01e fe55 	bl	262ec <atomic_get>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    7642:	0542      	lsls	r2, r0, #21
    7644:	d504      	bpl.n	7650 <bt_le_scan_update+0x24>
	return set_le_scan_enable_legacy(enable);
    7646:	4618      	mov	r0, r3
}
    7648:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return set_le_scan_enable_legacy(enable);
    764c:	f7ff be9a 	b.w	7384 <set_le_scan_enable_legacy>
}
    7650:	2000      	movs	r0, #0
    7652:	bd08      	pop	{r3, pc}
    7654:	200068ec 	.word	0x200068ec

00007658 <id_create.isra.0>:
static void id_create(u8_t id, bt_addr_le_t *addr, u8_t *irk)
    7658:	b530      	push	{r4, r5, lr}
    765a:	4d17      	ldr	r5, [pc, #92]	; (76b8 <id_create.isra.0+0x60>)
    765c:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    7660:	b085      	sub	sp, #20
    7662:	4405      	add	r5, r0
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    7664:	460c      	mov	r4, r1
    7666:	b1b1      	cbz	r1, 7696 <id_create.isra.0+0x3e>
    7668:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    766a:	2207      	movs	r2, #7
    766c:	a902      	add	r1, sp, #8
    766e:	4620      	mov	r0, r4
    7670:	9302      	str	r3, [sp, #8]
    7672:	f8cd 300b 	str.w	r3, [sp, #11]
    7676:	f01e fb07 	bl	25c88 <memcmp>
    767a:	b160      	cbz	r0, 7696 <id_create.isra.0+0x3e>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    767c:	4621      	mov	r1, r4
    767e:	4628      	mov	r0, r5
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    7680:	f01e fe3a 	bl	262f8 <bt_addr_le_copy>
    7684:	480d      	ldr	r0, [pc, #52]	; (76bc <id_create.isra.0+0x64>)
    7686:	f01e fe31 	bl	262ec <atomic_get>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    768a:	0783      	lsls	r3, r0, #30
    768c:	d501      	bpl.n	7692 <id_create.isra.0+0x3a>
		bt_settings_save_id();
    768e:	f7fe ff4d 	bl	652c <bt_settings_save_id>
}
    7692:	b005      	add	sp, #20
    7694:	bd30      	pop	{r4, r5, pc}
			bt_addr_le_create_static(&new_addr);
    7696:	4668      	mov	r0, sp
    7698:	f01e feb7 	bl	2640a <bt_addr_le_create_static>
		} while (id_find(&new_addr) >= 0);
    769c:	4668      	mov	r0, sp
    769e:	f7ff fa0b 	bl	6ab8 <id_find>
    76a2:	2800      	cmp	r0, #0
    76a4:	daf7      	bge.n	7696 <id_create.isra.0+0x3e>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    76a6:	4669      	mov	r1, sp
    76a8:	4628      	mov	r0, r5
    76aa:	f01e fe25 	bl	262f8 <bt_addr_le_copy>
		if (addr) {
    76ae:	2c00      	cmp	r4, #0
    76b0:	d0e8      	beq.n	7684 <id_create.isra.0+0x2c>
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    76b2:	4629      	mov	r1, r5
    76b4:	4620      	mov	r0, r4
    76b6:	e7e3      	b.n	7680 <id_create.isra.0+0x28>
    76b8:	20006860 	.word	0x20006860
    76bc:	200068ec 	.word	0x200068ec

000076c0 <bt_recv>:
{
    76c0:	b570      	push	{r4, r5, r6, lr}
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
    76c2:	7d01      	ldrb	r1, [r0, #20]
	switch (bt_buf_get_type(buf)) {
    76c4:	2901      	cmp	r1, #1
{
    76c6:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
    76c8:	d04b      	beq.n	7762 <bt_recv+0xa2>
    76ca:	2903      	cmp	r1, #3
    76cc:	d17b      	bne.n	77c6 <bt_recv+0x106>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    76ce:	8983      	ldrh	r3, [r0, #12]
    76d0:	2b03      	cmp	r3, #3
    76d2:	d80c      	bhi.n	76ee <bt_recv+0x2e>
    76d4:	4a44      	ldr	r2, [pc, #272]	; (77e8 <bt_recv+0x128>)
    76d6:	4945      	ldr	r1, [pc, #276]	; (77ec <bt_recv+0x12c>)
    76d8:	4845      	ldr	r0, [pc, #276]	; (77f0 <bt_recv+0x130>)
    76da:	f240 4377 	movw	r3, #1143	; 0x477
    76de:	f01c fc00 	bl	23ee2 <printk>
    76e2:	4040      	eors	r0, r0
    76e4:	f380 8811 	msr	BASEPRI, r0
    76e8:	f04f 0003 	mov.w	r0, #3
    76ec:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    76ee:	2104      	movs	r1, #4
    76f0:	f104 0008 	add.w	r0, r4, #8
    76f4:	f017 fdce 	bl	1f294 <net_buf_simple_pull_mem>
	if (buf->len != len) {
    76f8:	89a1      	ldrh	r1, [r4, #12]
	len = sys_le16_to_cpu(hdr->len);
    76fa:	8842      	ldrh	r2, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
    76fc:	8806      	ldrh	r6, [r0, #0]
	acl(buf)->index = BT_CONN_INDEX_INVALID;
    76fe:	23ff      	movs	r3, #255	; 0xff
	acl(buf)->handle = bt_acl_handle(handle);
    7700:	f3c6 000b 	ubfx	r0, r6, #0, #12
	if (buf->len != len) {
    7704:	428a      	cmp	r2, r1
	acl(buf)->handle = bt_acl_handle(handle);
    7706:	82e0      	strh	r0, [r4, #22]
	acl(buf)->index = BT_CONN_INDEX_INVALID;
    7708:	7563      	strb	r3, [r4, #21]
	if (buf->len != len) {
    770a:	d00d      	beq.n	7728 <bt_recv+0x68>
    770c:	4839      	ldr	r0, [pc, #228]	; (77f4 <bt_recv+0x134>)
    770e:	4b3a      	ldr	r3, [pc, #232]	; (77f8 <bt_recv+0x138>)
    7710:	1a1b      	subs	r3, r3, r0
    7712:	08db      	lsrs	r3, r3, #3
		BT_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
    7714:	019b      	lsls	r3, r3, #6
    7716:	4839      	ldr	r0, [pc, #228]	; (77fc <bt_recv+0x13c>)
    7718:	f043 0301 	orr.w	r3, r3, #1
    771c:	f01c fc73 	bl	24006 <log_2>
	net_buf_unref(buf);
    7720:	4620      	mov	r0, r4
    7722:	f017 fcd1 	bl	1f0c8 <net_buf_unref>
    7726:	e01a      	b.n	775e <bt_recv+0x9e>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
    7728:	f001 fdea 	bl	9300 <bt_conn_lookup_handle>
	if (!conn) {
    772c:	4605      	mov	r5, r0
    772e:	b958      	cbnz	r0, 7748 <bt_recv+0x88>
    7730:	4b30      	ldr	r3, [pc, #192]	; (77f4 <bt_recv+0x134>)
    7732:	4a31      	ldr	r2, [pc, #196]	; (77f8 <bt_recv+0x138>)
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
    7734:	8ae1      	ldrh	r1, [r4, #22]
    7736:	4832      	ldr	r0, [pc, #200]	; (7800 <bt_recv+0x140>)
    7738:	1ad2      	subs	r2, r2, r3
    773a:	08d2      	lsrs	r2, r2, #3
    773c:	0192      	lsls	r2, r2, #6
    773e:	f042 0201 	orr.w	r2, r2, #1
    7742:	f01c fc4c 	bl	23fde <log_1>
		net_buf_unref(buf);
    7746:	e7eb      	b.n	7720 <bt_recv+0x60>
	acl(buf)->index = bt_conn_index(conn);
    7748:	f001 ffa0 	bl	968c <bt_conn_index>
	bt_conn_recv(conn, buf, flags);
    774c:	0b32      	lsrs	r2, r6, #12
	acl(buf)->index = bt_conn_index(conn);
    774e:	7560      	strb	r0, [r4, #21]
	bt_conn_recv(conn, buf, flags);
    7750:	4621      	mov	r1, r4
    7752:	4628      	mov	r0, r5
    7754:	f001 fb8c 	bl	8e70 <bt_conn_recv>
	bt_conn_unref(conn);
    7758:	4628      	mov	r0, r5
    775a:	f01e ff2c 	bl	265b6 <bt_conn_unref>
		return 0;
    775e:	2000      	movs	r0, #0
}
    7760:	bd70      	pop	{r4, r5, r6, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
    7762:	8983      	ldrh	r3, [r0, #12]
    7764:	2b01      	cmp	r3, #1
    7766:	d80c      	bhi.n	7782 <bt_recv+0xc2>
    7768:	4a1f      	ldr	r2, [pc, #124]	; (77e8 <bt_recv+0x128>)
    776a:	4920      	ldr	r1, [pc, #128]	; (77ec <bt_recv+0x12c>)
    776c:	4820      	ldr	r0, [pc, #128]	; (77f0 <bt_recv+0x130>)
    776e:	f241 33a7 	movw	r3, #5031	; 0x13a7
    7772:	f01c fbb6 	bl	23ee2 <printk>
    7776:	4040      	eors	r0, r0
    7778:	f380 8811 	msr	BASEPRI, r0
    777c:	f04f 0003 	mov.w	r0, #3
    7780:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    7782:	2102      	movs	r1, #2
    7784:	f104 0008 	add.w	r0, r4, #8
    7788:	f017 fd84 	bl	1f294 <net_buf_simple_pull_mem>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
    778c:	7802      	ldrb	r2, [r0, #0]
    778e:	2a1a      	cmp	r2, #26
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    7790:	4605      	mov	r5, r0
 * @return true if the event can be processed in the RX thread, false
 *         if it cannot.
 */
static inline bool bt_hci_evt_is_prio(u8_t evt)
{
	switch (evt) {
    7792:	d811      	bhi.n	77b8 <bt_recv+0xf8>
    7794:	2301      	movs	r3, #1
    7796:	4093      	lsls	r3, r2
    7798:	4a1a      	ldr	r2, [pc, #104]	; (7804 <bt_recv+0x144>)
    779a:	4213      	tst	r3, r2
    779c:	d00c      	beq.n	77b8 <bt_recv+0xf8>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
    779e:	4a12      	ldr	r2, [pc, #72]	; (77e8 <bt_recv+0x128>)
    77a0:	4919      	ldr	r1, [pc, #100]	; (7808 <bt_recv+0x148>)
    77a2:	4813      	ldr	r0, [pc, #76]	; (77f0 <bt_recv+0x130>)
    77a4:	f241 33ab 	movw	r3, #5035	; 0x13ab
    77a8:	f01c fb9b 	bl	23ee2 <printk>
    77ac:	4040      	eors	r0, r0
    77ae:	f380 8811 	msr	BASEPRI, r0
    77b2:	f04f 0003 	mov.w	r0, #3
    77b6:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    77b8:	4a14      	ldr	r2, [pc, #80]	; (780c <bt_recv+0x14c>)
    77ba:	7828      	ldrb	r0, [r5, #0]
    77bc:	2303      	movs	r3, #3
    77be:	4621      	mov	r1, r4
    77c0:	f7ff f892 	bl	68e8 <handle_event>
    77c4:	e7ac      	b.n	7720 <bt_recv+0x60>
    77c6:	4b0b      	ldr	r3, [pc, #44]	; (77f4 <bt_recv+0x134>)
    77c8:	4a0b      	ldr	r2, [pc, #44]	; (77f8 <bt_recv+0x138>)
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    77ca:	4811      	ldr	r0, [pc, #68]	; (7810 <bt_recv+0x150>)
    77cc:	1ad2      	subs	r2, r2, r3
    77ce:	08d2      	lsrs	r2, r2, #3
    77d0:	0192      	lsls	r2, r2, #6
    77d2:	f042 0201 	orr.w	r2, r2, #1
    77d6:	f01c fc02 	bl	23fde <log_1>
		net_buf_unref(buf);
    77da:	4620      	mov	r0, r4
    77dc:	f017 fc74 	bl	1f0c8 <net_buf_unref>
		return -EINVAL;
    77e0:	f06f 0015 	mvn.w	r0, #21
    77e4:	e7bc      	b.n	7760 <bt_recv+0xa0>
    77e6:	bf00      	nop
    77e8:	0002bd96 	.word	0x0002bd96
    77ec:	0002bed0 	.word	0x0002bed0
    77f0:	0002a5e8 	.word	0x0002a5e8
    77f4:	00029830 	.word	0x00029830
    77f8:	000298f0 	.word	0x000298f0
    77fc:	0002bee9 	.word	0x0002bee9
    7800:	0002bf0d 	.word	0x0002bf0d
    7804:	0408c000 	.word	0x0408c000
    7808:	0002bf2f 	.word	0x0002bf2f
    780c:	00029e50 	.word	0x00029e50
    7810:	0002bf4d 	.word	0x0002bf4d

00007814 <bt_recv_prio>:
{
    7814:	b538      	push	{r3, r4, r5, lr}
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    7816:	7d03      	ldrb	r3, [r0, #20]
    7818:	2b01      	cmp	r3, #1
{
    781a:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    781c:	d00c      	beq.n	7838 <bt_recv_prio+0x24>
    781e:	4a21      	ldr	r2, [pc, #132]	; (78a4 <bt_recv_prio+0x90>)
    7820:	4921      	ldr	r1, [pc, #132]	; (78a8 <bt_recv_prio+0x94>)
    7822:	4822      	ldr	r0, [pc, #136]	; (78ac <bt_recv_prio+0x98>)
    7824:	f641 032b 	movw	r3, #6187	; 0x182b
    7828:	f01c fb5b 	bl	23ee2 <printk>
    782c:	4040      	eors	r0, r0
    782e:	f380 8811 	msr	BASEPRI, r0
    7832:	f04f 0003 	mov.w	r0, #3
    7836:	df02      	svc	2
	BT_ASSERT(buf->len >= sizeof(*hdr));
    7838:	89a3      	ldrh	r3, [r4, #12]
    783a:	2b01      	cmp	r3, #1
    783c:	d80c      	bhi.n	7858 <bt_recv_prio+0x44>
    783e:	4a19      	ldr	r2, [pc, #100]	; (78a4 <bt_recv_prio+0x90>)
    7840:	491b      	ldr	r1, [pc, #108]	; (78b0 <bt_recv_prio+0x9c>)
    7842:	481a      	ldr	r0, [pc, #104]	; (78ac <bt_recv_prio+0x98>)
    7844:	f641 032c 	movw	r3, #6188	; 0x182c
    7848:	f01c fb4b 	bl	23ee2 <printk>
    784c:	4040      	eors	r0, r0
    784e:	f380 8811 	msr	BASEPRI, r0
    7852:	f04f 0003 	mov.w	r0, #3
    7856:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    7858:	2102      	movs	r1, #2
    785a:	f104 0008 	add.w	r0, r4, #8
    785e:	f017 fd19 	bl	1f294 <net_buf_simple_pull_mem>
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
    7862:	7802      	ldrb	r2, [r0, #0]
    7864:	2a1a      	cmp	r2, #26
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    7866:	4605      	mov	r5, r0
    7868:	d804      	bhi.n	7874 <bt_recv_prio+0x60>
    786a:	2301      	movs	r3, #1
    786c:	4093      	lsls	r3, r2
    786e:	4a11      	ldr	r2, [pc, #68]	; (78b4 <bt_recv_prio+0xa0>)
    7870:	4213      	tst	r3, r2
    7872:	d10c      	bne.n	788e <bt_recv_prio+0x7a>
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
    7874:	4a0b      	ldr	r2, [pc, #44]	; (78a4 <bt_recv_prio+0x90>)
    7876:	4910      	ldr	r1, [pc, #64]	; (78b8 <bt_recv_prio+0xa4>)
    7878:	480c      	ldr	r0, [pc, #48]	; (78ac <bt_recv_prio+0x98>)
    787a:	f641 032f 	movw	r3, #6191	; 0x182f
    787e:	f01c fb30 	bl	23ee2 <printk>
    7882:	4040      	eors	r0, r0
    7884:	f380 8811 	msr	BASEPRI, r0
    7888:	f04f 0003 	mov.w	r0, #3
    788c:	df02      	svc	2
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    788e:	4a0b      	ldr	r2, [pc, #44]	; (78bc <bt_recv_prio+0xa8>)
    7890:	7828      	ldrb	r0, [r5, #0]
    7892:	2304      	movs	r3, #4
    7894:	4621      	mov	r1, r4
    7896:	f7ff f827 	bl	68e8 <handle_event>
	net_buf_unref(buf);
    789a:	4620      	mov	r0, r4
    789c:	f017 fc14 	bl	1f0c8 <net_buf_unref>
}
    78a0:	2000      	movs	r0, #0
    78a2:	bd38      	pop	{r3, r4, r5, pc}
    78a4:	0002bd96 	.word	0x0002bd96
    78a8:	0002bf61 	.word	0x0002bf61
    78ac:	0002a5e8 	.word	0x0002a5e8
    78b0:	0002bed0 	.word	0x0002bed0
    78b4:	0408c000 	.word	0x0408c000
    78b8:	0002bf30 	.word	0x0002bf30
    78bc:	00029e78 	.word	0x00029e78

000078c0 <bt_hci_driver_register>:
	if (bt_dev.drv) {
    78c0:	4a08      	ldr	r2, [pc, #32]	; (78e4 <bt_hci_driver_register+0x24>)
{
    78c2:	4603      	mov	r3, r0
	if (bt_dev.drv) {
    78c4:	f8d2 00f0 	ldr.w	r0, [r2, #240]	; 0xf0
    78c8:	b930      	cbnz	r0, 78d8 <bt_hci_driver_register+0x18>
	if (!drv->open || !drv->send) {
    78ca:	68d9      	ldr	r1, [r3, #12]
    78cc:	b139      	cbz	r1, 78de <bt_hci_driver_register+0x1e>
    78ce:	6919      	ldr	r1, [r3, #16]
    78d0:	b129      	cbz	r1, 78de <bt_hci_driver_register+0x1e>
	bt_dev.drv = drv;
    78d2:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
	return 0;
    78d6:	4770      	bx	lr
		return -EALREADY;
    78d8:	f06f 0044 	mvn.w	r0, #68	; 0x44
    78dc:	4770      	bx	lr
		return -EINVAL;
    78de:	f06f 0015 	mvn.w	r0, #21
}
    78e2:	4770      	bx	lr
    78e4:	20006860 	.word	0x20006860

000078e8 <bt_finalize_init>:
{
    78e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    78ec:	4c2d      	ldr	r4, [pc, #180]	; (79a4 <bt_finalize_init+0xbc>)
    78ee:	4d2e      	ldr	r5, [pc, #184]	; (79a8 <bt_finalize_init+0xc0>)
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    78f0:	4e2e      	ldr	r6, [pc, #184]	; (79ac <bt_finalize_init+0xc4>)
		BT_INFO("Identity[%d]: %s",
    78f2:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 79c4 <bt_finalize_init+0xdc>
{
    78f6:	b087      	sub	sp, #28
    78f8:	2102      	movs	r1, #2
    78fa:	f104 008c 	add.w	r0, r4, #140	; 0x8c
    78fe:	f01e fcfe 	bl	262fe <atomic_or>
		bt_le_scan_update(false);
    7902:	2000      	movs	r0, #0
    7904:	f7ff fe92 	bl	762c <bt_le_scan_update>
    7908:	4b29      	ldr	r3, [pc, #164]	; (79b0 <bt_finalize_init+0xc8>)
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    790a:	492a      	ldr	r1, [pc, #168]	; (79b4 <bt_finalize_init+0xcc>)
    790c:	1aed      	subs	r5, r5, r3
    790e:	79e3      	ldrb	r3, [r4, #7]
    7910:	4620      	mov	r0, r4
    7912:	2b01      	cmp	r3, #1
    7914:	bf88      	it	hi
    7916:	460e      	movhi	r6, r1
    7918:	f7fe fb16 	bl	5f48 <bt_addr_le_str_real>
    791c:	f7fa fe60 	bl	25e0 <log_strdup>
    7920:	08ed      	lsrs	r5, r5, #3
    7922:	01ad      	lsls	r5, r5, #6
    7924:	f045 0703 	orr.w	r7, r5, #3
    7928:	4602      	mov	r2, r0
    792a:	4631      	mov	r1, r6
    792c:	4822      	ldr	r0, [pc, #136]	; (79b8 <bt_finalize_init+0xd0>)
    792e:	463b      	mov	r3, r7
    7930:	f01c fb69 	bl	24006 <log_2>
	for (i = 1; i < bt_dev.id_count; i++) {
    7934:	46a0      	mov	r8, r4
    7936:	2601      	movs	r6, #1
    7938:	79e3      	ldrb	r3, [r4, #7]
    793a:	429e      	cmp	r6, r3
    793c:	f108 0807 	add.w	r8, r8, #7
    7940:	db22      	blt.n	7988 <bt_finalize_init+0xa0>
	BT_INFO("HCI: version %s (0x%02x) revision 0x%04x, manufacturer 0x%04x",
    7942:	f894 602b 	ldrb.w	r6, [r4, #43]	; 0x2b
    7946:	4630      	mov	r0, r6
    7948:	f7fe ff10 	bl	676c <ver_str>
    794c:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    794e:	9304      	str	r3, [sp, #16]
    7950:	f045 0503 	orr.w	r5, r5, #3
    7954:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    7956:	9305      	str	r3, [sp, #20]
    7958:	e9cd 0602 	strd	r0, r6, [sp, #8]
    795c:	462b      	mov	r3, r5
    795e:	a902      	add	r1, sp, #8
    7960:	2204      	movs	r2, #4
    7962:	4816      	ldr	r0, [pc, #88]	; (79bc <bt_finalize_init+0xd4>)
    7964:	f01c fb84 	bl	24070 <log_n>
	BT_INFO("LMP: version %s (0x%02x) subver 0x%04x",
    7968:	f894 602c 	ldrb.w	r6, [r4, #44]	; 0x2c
    796c:	4630      	mov	r0, r6
    796e:	f7fe fefd 	bl	676c <ver_str>
    7972:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    7974:	f8ad 5000 	strh.w	r5, [sp]
    7978:	4601      	mov	r1, r0
    797a:	4632      	mov	r2, r6
    797c:	4810      	ldr	r0, [pc, #64]	; (79c0 <bt_finalize_init+0xd8>)
    797e:	f01c fb5b 	bl	24038 <log_3>
}
    7982:	b007      	add	sp, #28
    7984:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_INFO("Identity[%d]: %s",
    7988:	4640      	mov	r0, r8
    798a:	f7fe fadd 	bl	5f48 <bt_addr_le_str_real>
    798e:	f7fa fe27 	bl	25e0 <log_strdup>
    7992:	4631      	mov	r1, r6
    7994:	4602      	mov	r2, r0
    7996:	463b      	mov	r3, r7
    7998:	4648      	mov	r0, r9
    799a:	f01c fb34 	bl	24006 <log_2>
	for (i = 1; i < bt_dev.id_count; i++) {
    799e:	3601      	adds	r6, #1
    79a0:	e7ca      	b.n	7938 <bt_finalize_init+0x50>
    79a2:	bf00      	nop
    79a4:	20006860 	.word	0x20006860
    79a8:	000298f0 	.word	0x000298f0
    79ac:	0002d7aa 	.word	0x0002d7aa
    79b0:	00029830 	.word	0x00029830
    79b4:	0002bf84 	.word	0x0002bf84
    79b8:	0002bf88 	.word	0x0002bf88
    79bc:	0002bfa8 	.word	0x0002bfa8
    79c0:	0002bfe6 	.word	0x0002bfe6
    79c4:	0002bf97 	.word	0x0002bf97

000079c8 <bt_init>:
{
    79c8:	b570      	push	{r4, r5, r6, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    79ca:	4db8      	ldr	r5, [pc, #736]	; (7cac <bt_init+0x2e4>)
    79cc:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
    79d0:	6899      	ldr	r1, [r3, #8]
    79d2:	f011 0101 	ands.w	r1, r1, #1
{
    79d6:	b086      	sub	sp, #24
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    79d8:	d121      	bne.n	7a1e <bt_init+0x56>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    79da:	aa01      	add	r2, sp, #4
    79dc:	f640 4003 	movw	r0, #3075	; 0xc03
    79e0:	f7ff fc6e 	bl	72c0 <bt_hci_cmd_send_sync>
		if (err) {
    79e4:	4604      	mov	r4, r0
    79e6:	2800      	cmp	r0, #0
    79e8:	d176      	bne.n	7ad8 <bt_init+0x110>
		hci_reset_complete(rsp);
    79ea:	9b01      	ldr	r3, [sp, #4]
	u8_t status = buf->data[0];
    79ec:	689b      	ldr	r3, [r3, #8]
	if (status) {
    79ee:	781b      	ldrb	r3, [r3, #0]
    79f0:	b993      	cbnz	r3, 7a18 <bt_init+0x50>
	scan_dev_found_cb = NULL;
    79f2:	4aaf      	ldr	r2, [pc, #700]	; (7cb0 <bt_init+0x2e8>)
    79f4:	6013      	str	r3, [r2, #0]
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    79f6:	f105 038c 	add.w	r3, r5, #140	; 0x8c
    79fa:	4618      	mov	r0, r3
    79fc:	f01e fc76 	bl	262ec <atomic_get>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    7a00:	f3bf 8f5b 	dmb	ish
    7a04:	f000 0005 	and.w	r0, r0, #5
    7a08:	e853 2f00 	ldrex	r2, [r3]
    7a0c:	e843 0100 	strex	r1, r0, [r3]
    7a10:	2900      	cmp	r1, #0
    7a12:	d1f9      	bne.n	7a08 <bt_init+0x40>
    7a14:	f3bf 8f5b 	dmb	ish
		net_buf_unref(rsp);
    7a18:	9801      	ldr	r0, [sp, #4]
    7a1a:	f017 fb55 	bl	1f0c8 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    7a1e:	aa01      	add	r2, sp, #4
    7a20:	2100      	movs	r1, #0
    7a22:	f241 0003 	movw	r0, #4099	; 0x1003
    7a26:	f7ff fc4b 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7a2a:	4604      	mov	r4, r0
    7a2c:	2800      	cmp	r0, #0
    7a2e:	d153      	bne.n	7ad8 <bt_init+0x110>
	read_local_features_complete(rsp);
    7a30:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
    7a32:	48a0      	ldr	r0, [pc, #640]	; (7cb4 <bt_init+0x2ec>)
    7a34:	6899      	ldr	r1, [r3, #8]
    7a36:	2208      	movs	r2, #8
    7a38:	3101      	adds	r1, #1
    7a3a:	f01e f935 	bl	25ca8 <memcpy>
	net_buf_unref(rsp);
    7a3e:	9801      	ldr	r0, [sp, #4]
    7a40:	f017 fb42 	bl	1f0c8 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    7a44:	4621      	mov	r1, r4
    7a46:	aa01      	add	r2, sp, #4
    7a48:	f241 0001 	movw	r0, #4097	; 0x1001
    7a4c:	f7ff fc38 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7a50:	4604      	mov	r4, r0
    7a52:	2800      	cmp	r0, #0
    7a54:	d140      	bne.n	7ad8 <bt_init+0x110>
	read_local_ver_complete(rsp);
    7a56:	9801      	ldr	r0, [sp, #4]
    7a58:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
    7a5a:	785a      	ldrb	r2, [r3, #1]
    7a5c:	f885 202b 	strb.w	r2, [r5, #43]	; 0x2b
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    7a60:	78d9      	ldrb	r1, [r3, #3]
    7a62:	789a      	ldrb	r2, [r3, #2]
    7a64:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    7a68:	85ea      	strh	r2, [r5, #46]	; 0x2e
	bt_dev.lmp_version = rp->lmp_version;
    7a6a:	791a      	ldrb	r2, [r3, #4]
    7a6c:	f885 202c 	strb.w	r2, [r5, #44]	; 0x2c
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    7a70:	7a19      	ldrb	r1, [r3, #8]
    7a72:	79da      	ldrb	r2, [r3, #7]
    7a74:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    7a78:	862a      	strh	r2, [r5, #48]	; 0x30
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    7a7a:	795a      	ldrb	r2, [r3, #5]
    7a7c:	799b      	ldrb	r3, [r3, #6]
    7a7e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    7a82:	866b      	strh	r3, [r5, #50]	; 0x32
	net_buf_unref(rsp);
    7a84:	f017 fb20 	bl	1f0c8 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    7a88:	4621      	mov	r1, r4
    7a8a:	aa01      	add	r2, sp, #4
    7a8c:	f241 0002 	movw	r0, #4098	; 0x1002
    7a90:	f7ff fc16 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7a94:	4604      	mov	r4, r0
    7a96:	b9f8      	cbnz	r0, 7ad8 <bt_init+0x110>
	read_supported_commands_complete(rsp);
    7a98:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.supported_commands, rp->commands,
    7a9a:	4887      	ldr	r0, [pc, #540]	; (7cb8 <bt_init+0x2f0>)
    7a9c:	6899      	ldr	r1, [r3, #8]
    7a9e:	2240      	movs	r2, #64	; 0x40
    7aa0:	3101      	adds	r1, #1
    7aa2:	f01e f901 	bl	25ca8 <memcpy>
		bt_dev.supported_commands[34] |= 0x04;
    7aa6:	f895 305e 	ldrb.w	r3, [r5, #94]	; 0x5e
	net_buf_unref(rsp);
    7aaa:	9801      	ldr	r0, [sp, #4]
		bt_dev.supported_commands[34] |= 0x04;
    7aac:	f043 0306 	orr.w	r3, r3, #6
    7ab0:	f885 305e 	strb.w	r3, [r5, #94]	; 0x5e
	net_buf_unref(rsp);
    7ab4:	f017 fb08 	bl	1f0c8 <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
    7ab8:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    7abc:	0658      	lsls	r0, r3, #25
    7abe:	d40e      	bmi.n	7ade <bt_init+0x116>
    7ac0:	4b7e      	ldr	r3, [pc, #504]	; (7cbc <bt_init+0x2f4>)
    7ac2:	497f      	ldr	r1, [pc, #508]	; (7cc0 <bt_init+0x2f8>)
		BT_ERR("Non-LE capable controller detected!");
    7ac4:	487f      	ldr	r0, [pc, #508]	; (7cc4 <bt_init+0x2fc>)
    7ac6:	1ac9      	subs	r1, r1, r3
    7ac8:	08c9      	lsrs	r1, r1, #3
    7aca:	0189      	lsls	r1, r1, #6
    7acc:	f041 0101 	orr.w	r1, r1, #1
    7ad0:	f01c fa78 	bl	23fc4 <log_0>
		return -ENODEV;
    7ad4:	f06f 0412 	mvn.w	r4, #18
}
    7ad8:	4620      	mov	r0, r4
    7ada:	b006      	add	sp, #24
    7adc:	bd70      	pop	{r4, r5, r6, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    7ade:	4621      	mov	r1, r4
    7ae0:	aa01      	add	r2, sp, #4
    7ae2:	f242 0003 	movw	r0, #8195	; 0x2003
    7ae6:	f7ff fbeb 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7aea:	4604      	mov	r4, r0
    7aec:	2800      	cmp	r0, #0
    7aee:	d1f3      	bne.n	7ad8 <bt_init+0x110>
	read_le_features_complete(rsp);
    7af0:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
    7af2:	4875      	ldr	r0, [pc, #468]	; (7cc8 <bt_init+0x300>)
    7af4:	6899      	ldr	r1, [r3, #8]
    7af6:	2208      	movs	r2, #8
    7af8:	3101      	adds	r1, #1
    7afa:	f01e f8d5 	bl	25ca8 <memcpy>
	net_buf_unref(rsp);
    7afe:	9801      	ldr	r0, [sp, #4]
    7b00:	f017 fae2 	bl	1f0c8 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
    7b04:	4621      	mov	r1, r4
    7b06:	aa01      	add	r2, sp, #4
    7b08:	f242 0002 	movw	r0, #8194	; 0x2002
    7b0c:	f7ff fbd8 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7b10:	4604      	mov	r4, r0
    7b12:	2800      	cmp	r0, #0
    7b14:	d1e0      	bne.n	7ad8 <bt_init+0x110>
	le_read_buffer_size_complete(rsp);
    7b16:	9b01      	ldr	r3, [sp, #4]
    7b18:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.mtu = sys_le16_to_cpu(rp->le_max_len);
    7b1a:	f8b3 2001 	ldrh.w	r2, [r3, #1]
    7b1e:	f8a5 20a0 	strh.w	r2, [r5, #160]	; 0xa0
    7b22:	b291      	uxth	r1, r2
	if (!bt_dev.le.mtu) {
    7b24:	b121      	cbz	r1, 7b30 <bt_init+0x168>
	k_sem_init(&bt_dev.le.pkts, rp->le_max_num, rp->le_max_num);
    7b26:	78da      	ldrb	r2, [r3, #3]
	return z_impl_k_sem_init(sem, initial_count, limit);
    7b28:	4868      	ldr	r0, [pc, #416]	; (7ccc <bt_init+0x304>)
    7b2a:	4611      	mov	r1, r2
    7b2c:	f021 fbd4 	bl	292d8 <z_impl_k_sem_init>
	net_buf_unref(rsp);
    7b30:	9801      	ldr	r0, [sp, #4]
    7b32:	f017 fac9 	bl	1f0c8 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    7b36:	f895 6038 	ldrb.w	r6, [r5, #56]	; 0x38
    7b3a:	f016 0620 	ands.w	r6, r6, #32
    7b3e:	f000 8099 	beq.w	7c74 <bt_init+0x2ac>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    7b42:	f895 3058 	ldrb.w	r3, [r5, #88]	; 0x58
    7b46:	0719      	lsls	r1, r3, #28
    7b48:	f100 80c6 	bmi.w	7cd8 <bt_init+0x310>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    7b4c:	2108      	movs	r1, #8
    7b4e:	f242 0001 	movw	r0, #8193	; 0x2001
    7b52:	f7ff fa3d 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    7b56:	4604      	mov	r4, r0
    7b58:	2800      	cmp	r0, #0
    7b5a:	f000 8092 	beq.w	7c82 <bt_init+0x2ba>
	cp_mask = net_buf_add(buf, sizeof(*cp_mask));
    7b5e:	2108      	movs	r1, #8
    7b60:	4408      	add	r0, r1
    7b62:	f017 fbb9 	bl	1f2d8 <net_buf_simple_add>
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
    7b66:	f895 3090 	ldrb.w	r3, [r5, #144]	; 0x90
	if (IS_ENABLED(CONFIG_BT_ECC) &&
    7b6a:	f895 205e 	ldrb.w	r2, [r5, #94]	; 0x5e
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
    7b6e:	f013 0f02 	tst.w	r3, #2
	if (IS_ENABLED(CONFIG_BT_ECC) &&
    7b72:	f002 0206 	and.w	r2, r2, #6
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
    7b76:	bf0c      	ite	eq
    7b78:	230f      	moveq	r3, #15
    7b7a:	232f      	movne	r3, #47	; 0x2f
	if (IS_ENABLED(CONFIG_BT_ECC) &&
    7b7c:	2a06      	cmp	r2, #6
		mask |= BT_EVT_MASK_LE_GENERATE_DHKEY_COMPLETE;
    7b7e:	bf08      	it	eq
    7b80:	f443 73c0 	orreq.w	r3, r3, #384	; 0x180
	dst[0] = val;
    7b84:	2200      	movs	r2, #0
    7b86:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
    7b88:	0a1b      	lsrs	r3, r3, #8
    7b8a:	7043      	strb	r3, [r0, #1]
	dst[0] = val;
    7b8c:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
    7b8e:	70c2      	strb	r2, [r0, #3]
	dst[0] = val;
    7b90:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    7b92:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    7b94:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    7b96:	71c2      	strb	r2, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    7b98:	4621      	mov	r1, r4
    7b9a:	f242 0001 	movw	r0, #8193	; 0x2001
    7b9e:	f7ff fb8f 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7ba2:	4604      	mov	r4, r0
    7ba4:	2800      	cmp	r0, #0
    7ba6:	d197      	bne.n	7ad8 <bt_init+0x110>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    7ba8:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    7bac:	069a      	lsls	r2, r3, #26
    7bae:	d41d      	bmi.n	7bec <bt_init+0x224>
	if (bt_dev.le.mtu) {
    7bb0:	f8b5 10a0 	ldrh.w	r1, [r5, #160]	; 0xa0
    7bb4:	b9d1      	cbnz	r1, 7bec <bt_init+0x224>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
    7bb6:	aa01      	add	r2, sp, #4
    7bb8:	f241 0005 	movw	r0, #4101	; 0x1005
    7bbc:	f7ff fb80 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7bc0:	4604      	mov	r4, r0
    7bc2:	2800      	cmp	r0, #0
    7bc4:	d188      	bne.n	7ad8 <bt_init+0x110>
	if (bt_dev.le.mtu) {
    7bc6:	f8b5 30a0 	ldrh.w	r3, [r5, #160]	; 0xa0
    7bca:	b963      	cbnz	r3, 7be6 <bt_init+0x21e>
	read_buffer_size_complete(rsp);
    7bcc:	9b01      	ldr	r3, [sp, #4]
    7bce:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.mtu = sys_le16_to_cpu(rp->acl_max_len);
    7bd0:	785a      	ldrb	r2, [r3, #1]
    7bd2:	7899      	ldrb	r1, [r3, #2]
    7bd4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    7bd8:	f8a5 20a0 	strh.w	r2, [r5, #160]	; 0xa0
	k_sem_init(&bt_dev.le.pkts, pkts, pkts);
    7bdc:	889a      	ldrh	r2, [r3, #4]
    7bde:	483b      	ldr	r0, [pc, #236]	; (7ccc <bt_init+0x304>)
    7be0:	4611      	mov	r1, r2
    7be2:	f021 fb79 	bl	292d8 <z_impl_k_sem_init>
	net_buf_unref(rsp);
    7be6:	9801      	ldr	r0, [sp, #4]
    7be8:	f017 fa6e 	bl	1f0c8 <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    7bec:	2108      	movs	r1, #8
    7bee:	f640 4001 	movw	r0, #3073	; 0xc01
    7bf2:	f7ff f9ed 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    7bf6:	4604      	mov	r4, r0
    7bf8:	2800      	cmp	r0, #0
    7bfa:	d042      	beq.n	7c82 <bt_init+0x2ba>
	ev = net_buf_add(buf, sizeof(*ev));
    7bfc:	2108      	movs	r1, #8
    7bfe:	4408      	add	r0, r1
    7c00:	f017 fb6a 	bl	1f2d8 <net_buf_simple_add>
	dst[0] = val;
    7c04:	2310      	movs	r3, #16
    7c06:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
    7c08:	2388      	movs	r3, #136	; 0x88
    7c0a:	7043      	strb	r3, [r0, #1]
    7c0c:	2302      	movs	r3, #2
	dst[0] = val;
    7c0e:	2200      	movs	r2, #0
	dst[1] = val >> 8;
    7c10:	70c3      	strb	r3, [r0, #3]
    7c12:	2320      	movs	r3, #32
	dst[0] = val;
    7c14:	7082      	strb	r2, [r0, #2]
    7c16:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    7c18:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    7c1a:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    7c1c:	71c3      	strb	r3, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    7c1e:	4621      	mov	r1, r4
    7c20:	f640 4001 	movw	r0, #3073	; 0xc01
    7c24:	f7ff fb4c 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7c28:	4604      	mov	r4, r0
    7c2a:	2800      	cmp	r0, #0
    7c2c:	f47f af54 	bne.w	7ad8 <bt_init+0x110>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
    7c30:	4601      	mov	r1, r0
    7c32:	466a      	mov	r2, sp
    7c34:	f64f 4001 	movw	r0, #64513	; 0xfc01
    7c38:	f7ff fb42 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7c3c:	4e20      	ldr	r6, [pc, #128]	; (7cc0 <bt_init+0x2f8>)
    7c3e:	4b1f      	ldr	r3, [pc, #124]	; (7cbc <bt_init+0x2f4>)
    7c40:	1af6      	subs	r6, r6, r3
    7c42:	08f6      	lsrs	r6, r6, #3
    7c44:	01b6      	lsls	r6, r6, #6
    7c46:	2800      	cmp	r0, #0
    7c48:	d05a      	beq.n	7d00 <bt_init+0x338>
		BT_WARN("Vendor HCI extensions not available");
    7c4a:	4821      	ldr	r0, [pc, #132]	; (7cd0 <bt_init+0x308>)
    7c4c:	f046 0102 	orr.w	r1, r6, #2
			BT_WARN("Failed to read supported vendor features");
    7c50:	f01c f9b8 	bl	23fc4 <log_0>
		err = bt_conn_init();
    7c54:	f001 fd40 	bl	96d8 <bt_conn_init>
		if (err) {
    7c58:	4604      	mov	r4, r0
    7c5a:	2800      	cmp	r0, #0
    7c5c:	f47f af3c 	bne.w	7ad8 <bt_init+0x110>
		if (!bt_dev.id_count) {
    7c60:	79eb      	ldrb	r3, [r5, #7]
    7c62:	2b00      	cmp	r3, #0
    7c64:	f040 80b9 	bne.w	7dda <bt_init+0x412>
			BT_INFO("No ID address. App must call settings_load()");
    7c68:	481a      	ldr	r0, [pc, #104]	; (7cd4 <bt_init+0x30c>)
    7c6a:	f046 0103 	orr.w	r1, r6, #3
    7c6e:	f01c f9a9 	bl	23fc4 <log_0>
			return 0;
    7c72:	e731      	b.n	7ad8 <bt_init+0x110>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    7c74:	2102      	movs	r1, #2
    7c76:	f640 406d 	movw	r0, #3181	; 0xc6d
    7c7a:	f7ff f9a9 	bl	6fd0 <bt_hci_cmd_create>
		if (!buf) {
    7c7e:	4604      	mov	r4, r0
    7c80:	b910      	cbnz	r0, 7c88 <bt_init+0x2c0>
		return -ENOBUFS;
    7c82:	f06f 0436 	mvn.w	r4, #54	; 0x36
    7c86:	e727      	b.n	7ad8 <bt_init+0x110>
		cp_le = net_buf_add(buf, sizeof(*cp_le));
    7c88:	2102      	movs	r1, #2
    7c8a:	3008      	adds	r0, #8
    7c8c:	f017 fb24 	bl	1f2d8 <net_buf_simple_add>
		cp_le->le = 0x01;
    7c90:	2301      	movs	r3, #1
    7c92:	7003      	strb	r3, [r0, #0]
		cp_le->simul = 0x00;
    7c94:	7046      	strb	r6, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    7c96:	4621      	mov	r1, r4
    7c98:	4632      	mov	r2, r6
    7c9a:	f640 406d 	movw	r0, #3181	; 0xc6d
    7c9e:	f7ff fb0f 	bl	72c0 <bt_hci_cmd_send_sync>
		if (err) {
    7ca2:	4604      	mov	r4, r0
    7ca4:	2800      	cmp	r0, #0
    7ca6:	f43f af4c 	beq.w	7b42 <bt_init+0x17a>
    7caa:	e715      	b.n	7ad8 <bt_init+0x110>
    7cac:	20006860 	.word	0x20006860
    7cb0:	20000484 	.word	0x20000484
    7cb4:	20006894 	.word	0x20006894
    7cb8:	2000689c 	.word	0x2000689c
    7cbc:	00029830 	.word	0x00029830
    7cc0:	000298f0 	.word	0x000298f0
    7cc4:	0002c00d 	.word	0x0002c00d
    7cc8:	200068f0 	.word	0x200068f0
    7ccc:	20006904 	.word	0x20006904
    7cd0:	0002c031 	.word	0x0002c031
    7cd4:	0002c105 	.word	0x0002c105
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    7cd8:	aa01      	add	r2, sp, #4
    7cda:	2100      	movs	r1, #0
    7cdc:	f242 001c 	movw	r0, #8220	; 0x201c
    7ce0:	f7ff faee 	bl	72c0 <bt_hci_cmd_send_sync>
		if (err) {
    7ce4:	4604      	mov	r4, r0
    7ce6:	2800      	cmp	r0, #0
    7ce8:	f47f aef6 	bne.w	7ad8 <bt_init+0x110>
		le_read_supp_states_complete(rsp);
    7cec:	9801      	ldr	r0, [sp, #4]
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
    7cee:	6883      	ldr	r3, [r0, #8]
    7cf0:	f853 2f01 	ldr.w	r2, [r3, #1]!
    7cf4:	685b      	ldr	r3, [r3, #4]
	bt_dev.le.states = sys_get_le64(rp->le_states);
    7cf6:	e9c5 2326 	strd	r2, r3, [r5, #152]	; 0x98
		net_buf_unref(rsp);
    7cfa:	f017 f9e5 	bl	1f0c8 <net_buf_unref>
    7cfe:	e725      	b.n	7b4c <bt_init+0x184>
	rp.info = (void *)rsp->data;
    7d00:	9b00      	ldr	r3, [sp, #0]
	BT_INFO("HW Platform: %s (0x%04x)",
    7d02:	4839      	ldr	r0, [pc, #228]	; (7de8 <bt_init+0x420>)
	rp.info = (void *)rsp->data;
    7d04:	689c      	ldr	r4, [r3, #8]
	BT_INFO("HW Platform: %s (0x%04x)",
    7d06:	f8b4 2001 	ldrh.w	r2, [r4, #1]
	if (platform < ARRAY_SIZE(plat_str)) {
    7d0a:	2a03      	cmp	r2, #3
		return plat_str[platform];
    7d0c:	bf96      	itet	ls
    7d0e:	4937      	ldrls	r1, [pc, #220]	; (7dec <bt_init+0x424>)
	return "unknown";
    7d10:	4937      	ldrhi	r1, [pc, #220]	; (7df0 <bt_init+0x428>)
		return plat_str[platform];
    7d12:	f851 1022 	ldrls.w	r1, [r1, r2, lsl #2]
	BT_INFO("HW Platform: %s (0x%04x)",
    7d16:	f046 0303 	orr.w	r3, r6, #3
    7d1a:	f01c f974 	bl	24006 <log_2>
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    7d1e:	f8b4 1001 	ldrh.w	r1, [r4, #1]
	BT_INFO("HW Variant: %s (0x%04x)",
    7d22:	f8b4 2003 	ldrh.w	r2, [r4, #3]
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    7d26:	2902      	cmp	r1, #2
	BT_INFO("HW Variant: %s (0x%04x)",
    7d28:	f046 0303 	orr.w	r3, r6, #3
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    7d2c:	d12e      	bne.n	7d8c <bt_init+0x3c4>
	if (variant < ARRAY_SIZE(nordic_str)) {
    7d2e:	2a03      	cmp	r2, #3
    7d30:	d82c      	bhi.n	7d8c <bt_init+0x3c4>
		return nordic_str[variant];
    7d32:	4930      	ldr	r1, [pc, #192]	; (7df4 <bt_init+0x42c>)
    7d34:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
	BT_INFO("HW Variant: %s (0x%04x)",
    7d38:	482f      	ldr	r0, [pc, #188]	; (7df8 <bt_init+0x430>)
    7d3a:	f01c f964 	bl	24006 <log_2>
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    7d3e:	7962      	ldrb	r2, [r4, #5]
    7d40:	482e      	ldr	r0, [pc, #184]	; (7dfc <bt_init+0x434>)
	if (variant < ARRAY_SIZE(var_str)) {
    7d42:	2a03      	cmp	r2, #3
		return var_str[variant];
    7d44:	bf96      	itet	ls
    7d46:	492e      	ldrls	r1, [pc, #184]	; (7e00 <bt_init+0x438>)
	return "unknown";
    7d48:	4929      	ldrhi	r1, [pc, #164]	; (7df0 <bt_init+0x428>)
		return var_str[variant];
    7d4a:	f851 1022 	ldrls.w	r1, [r1, r2, lsl #2]
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    7d4e:	e9cd 1201 	strd	r1, r2, [sp, #4]
    7d52:	79a2      	ldrb	r2, [r4, #6]
    7d54:	9203      	str	r2, [sp, #12]
    7d56:	f8b4 2007 	ldrh.w	r2, [r4, #7]
    7d5a:	9204      	str	r2, [sp, #16]
    7d5c:	f8d4 2009 	ldr.w	r2, [r4, #9]
    7d60:	9205      	str	r2, [sp, #20]
    7d62:	f046 0303 	orr.w	r3, r6, #3
    7d66:	2205      	movs	r2, #5
    7d68:	a901      	add	r1, sp, #4
    7d6a:	f01c f981 	bl	24070 <log_n>
	net_buf_unref(rsp);
    7d6e:	9800      	ldr	r0, [sp, #0]
    7d70:	f017 f9aa 	bl	1f0c8 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
    7d74:	466a      	mov	r2, sp
    7d76:	2100      	movs	r1, #0
    7d78:	f64f 4002 	movw	r0, #64514	; 0xfc02
    7d7c:	f7ff faa0 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    7d80:	4604      	mov	r4, r0
    7d82:	b128      	cbz	r0, 7d90 <bt_init+0x3c8>
		BT_WARN("Failed to read supported vendor commands");
    7d84:	481f      	ldr	r0, [pc, #124]	; (7e04 <bt_init+0x43c>)
    7d86:	f046 0102 	orr.w	r1, r6, #2
    7d8a:	e761      	b.n	7c50 <bt_init+0x288>
		return "unknown";
    7d8c:	4918      	ldr	r1, [pc, #96]	; (7df0 <bt_init+0x428>)
    7d8e:	e7d3      	b.n	7d38 <bt_init+0x370>
	rp.cmds = (void *)rsp->data;
    7d90:	9b00      	ldr	r3, [sp, #0]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
    7d92:	481d      	ldr	r0, [pc, #116]	; (7e08 <bt_init+0x440>)
    7d94:	6899      	ldr	r1, [r3, #8]
    7d96:	2202      	movs	r2, #2
    7d98:	3101      	adds	r1, #1
    7d9a:	f01d ff85 	bl	25ca8 <memcpy>
	net_buf_unref(rsp);
    7d9e:	9800      	ldr	r0, [sp, #0]
    7da0:	f017 f992 	bl	1f0c8 <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
    7da4:	f895 307d 	ldrb.w	r3, [r5, #125]	; 0x7d
    7da8:	075b      	lsls	r3, r3, #29
    7daa:	f57f af53 	bpl.w	7c54 <bt_init+0x28c>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
    7dae:	466a      	mov	r2, sp
    7db0:	4621      	mov	r1, r4
    7db2:	f64f 4003 	movw	r0, #64515	; 0xfc03
    7db6:	f7ff fa83 	bl	72c0 <bt_hci_cmd_send_sync>
		if (err) {
    7dba:	b118      	cbz	r0, 7dc4 <bt_init+0x3fc>
			BT_WARN("Failed to read supported vendor features");
    7dbc:	4813      	ldr	r0, [pc, #76]	; (7e0c <bt_init+0x444>)
    7dbe:	f046 0102 	orr.w	r1, r6, #2
    7dc2:	e745      	b.n	7c50 <bt_init+0x288>
		rp.feat = (void *)rsp->data;
    7dc4:	9b00      	ldr	r3, [sp, #0]
		memcpy(bt_dev.vs_features, rp.feat->features,
    7dc6:	4812      	ldr	r0, [pc, #72]	; (7e10 <bt_init+0x448>)
    7dc8:	6899      	ldr	r1, [r3, #8]
    7dca:	2201      	movs	r2, #1
    7dcc:	4411      	add	r1, r2
    7dce:	f01d ff6b 	bl	25ca8 <memcpy>
		net_buf_unref(rsp);
    7dd2:	9800      	ldr	r0, [sp, #0]
    7dd4:	f017 f978 	bl	1f0c8 <net_buf_unref>
    7dd8:	e73c      	b.n	7c54 <bt_init+0x28c>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    7dda:	2104      	movs	r1, #4
    7ddc:	480d      	ldr	r0, [pc, #52]	; (7e14 <bt_init+0x44c>)
    7dde:	f01e fa8e 	bl	262fe <atomic_or>
	bt_finalize_init();
    7de2:	f7ff fd81 	bl	78e8 <bt_finalize_init>
	return 0;
    7de6:	e677      	b.n	7ad8 <bt_init+0x110>
    7de8:	0002c055 	.word	0x0002c055
    7dec:	00029e68 	.word	0x00029e68
    7df0:	0002bc72 	.word	0x0002bc72
    7df4:	00029e40 	.word	0x00029e40
    7df8:	0002c06e 	.word	0x0002c06e
    7dfc:	0002c086 	.word	0x0002c086
    7e00:	00029e98 	.word	0x00029e98
    7e04:	0002c0b3 	.word	0x0002c0b3
    7e08:	200068dd 	.word	0x200068dd
    7e0c:	0002c0dc 	.word	0x0002c0dc
    7e10:	200068dc 	.word	0x200068dc
    7e14:	200068ec 	.word	0x200068ec

00007e18 <init_work>:
{
    7e18:	b510      	push	{r4, lr}
	err = bt_init();
    7e1a:	f7ff fdd5 	bl	79c8 <bt_init>
	if (ready_cb) {
    7e1e:	4b03      	ldr	r3, [pc, #12]	; (7e2c <init_work+0x14>)
    7e20:	681b      	ldr	r3, [r3, #0]
    7e22:	b113      	cbz	r3, 7e2a <init_work+0x12>
}
    7e24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
    7e28:	4718      	bx	r3
}
    7e2a:	bd10      	pop	{r4, pc}
    7e2c:	20000478 	.word	0x20000478

00007e30 <bt_enable>:
{
    7e30:	b570      	push	{r4, r5, r6, lr}
	if (!bt_dev.drv) {
    7e32:	4d30      	ldr	r5, [pc, #192]	; (7ef4 <bt_enable+0xc4>)
    7e34:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
{
    7e38:	b086      	sub	sp, #24
    7e3a:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
    7e3c:	b973      	cbnz	r3, 7e5c <bt_enable+0x2c>
    7e3e:	4b2e      	ldr	r3, [pc, #184]	; (7ef8 <bt_enable+0xc8>)
    7e40:	492e      	ldr	r1, [pc, #184]	; (7efc <bt_enable+0xcc>)
		BT_ERR("No HCI driver registered");
    7e42:	482f      	ldr	r0, [pc, #188]	; (7f00 <bt_enable+0xd0>)
    7e44:	1ac9      	subs	r1, r1, r3
    7e46:	08c9      	lsrs	r1, r1, #3
    7e48:	0189      	lsls	r1, r1, #6
    7e4a:	f041 0101 	orr.w	r1, r1, #1
    7e4e:	f01c f8b9 	bl	23fc4 <log_0>
		return -ENODEV;
    7e52:	f06f 0412 	mvn.w	r4, #18
}
    7e56:	4620      	mov	r0, r4
    7e58:	b006      	add	sp, #24
    7e5a:	bd70      	pop	{r4, r5, r6, pc}
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    7e5c:	2100      	movs	r1, #0
    7e5e:	f105 008c 	add.w	r0, r5, #140	; 0x8c
    7e62:	f01e fa5b 	bl	2631c <atomic_test_and_set_bit>
    7e66:	2800      	cmp	r0, #0
    7e68:	d140      	bne.n	7eec <bt_enable+0xbc>
		err = bt_settings_init();
    7e6a:	f7fe fbbf 	bl	65ec <bt_settings_init>
		if (err) {
    7e6e:	4604      	mov	r4, r0
    7e70:	2800      	cmp	r0, #0
    7e72:	d1f0      	bne.n	7e56 <bt_enable+0x26>
	ready_cb = cb;
    7e74:	4b23      	ldr	r3, [pc, #140]	; (7f04 <bt_enable+0xd4>)
    7e76:	601e      	str	r6, [r3, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    7e78:	f06f 0308 	mvn.w	r3, #8
    7e7c:	e9cd 0302 	strd	r0, r3, [sp, #8]
    7e80:	e9cd 0004 	strd	r0, r0, [sp, #16]
    7e84:	e9cd 0000 	strd	r0, r0, [sp]
    7e88:	4b1f      	ldr	r3, [pc, #124]	; (7f08 <bt_enable+0xd8>)
    7e8a:	4920      	ldr	r1, [pc, #128]	; (7f0c <bt_enable+0xdc>)
    7e8c:	4820      	ldr	r0, [pc, #128]	; (7f10 <bt_enable+0xe0>)
    7e8e:	f44f 7220 	mov.w	r2, #640	; 0x280
    7e92:	f01a fd27 	bl	228e4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    7e96:	491f      	ldr	r1, [pc, #124]	; (7f14 <bt_enable+0xe4>)
    7e98:	481d      	ldr	r0, [pc, #116]	; (7f10 <bt_enable+0xe0>)
    7e9a:	f01a fce9 	bl	22870 <z_impl_k_thread_name_set>
		bt_hci_ecc_init();
    7e9e:	f7fe fa45 	bl	632c <bt_hci_ecc_init>
	err = bt_dev.drv->open();
    7ea2:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
    7ea6:	68db      	ldr	r3, [r3, #12]
    7ea8:	4798      	blx	r3
	if (err) {
    7eaa:	4604      	mov	r4, r0
    7eac:	b158      	cbz	r0, 7ec6 <bt_enable+0x96>
    7eae:	4b12      	ldr	r3, [pc, #72]	; (7ef8 <bt_enable+0xc8>)
    7eb0:	4a12      	ldr	r2, [pc, #72]	; (7efc <bt_enable+0xcc>)
    7eb2:	1ad2      	subs	r2, r2, r3
    7eb4:	08d2      	lsrs	r2, r2, #3
		BT_ERR("HCI driver open failed (%d)", err);
    7eb6:	0192      	lsls	r2, r2, #6
    7eb8:	4601      	mov	r1, r0
    7eba:	f042 0201 	orr.w	r2, r2, #1
    7ebe:	4816      	ldr	r0, [pc, #88]	; (7f18 <bt_enable+0xe8>)
    7ec0:	f01c f88d 	bl	23fde <log_1>
		return err;
    7ec4:	e7c7      	b.n	7e56 <bt_enable+0x26>
	if (!cb) {
    7ec6:	b926      	cbnz	r6, 7ed2 <bt_enable+0xa2>
}
    7ec8:	b006      	add	sp, #24
    7eca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_init();
    7ece:	f7ff bd7b 	b.w	79c8 <bt_init>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    7ed2:	4601      	mov	r1, r0
    7ed4:	f105 0088 	add.w	r0, r5, #136	; 0x88
    7ed8:	f01e fa20 	bl	2631c <atomic_test_and_set_bit>
    7edc:	2800      	cmp	r0, #0
    7ede:	d1ba      	bne.n	7e56 <bt_enable+0x26>
		k_queue_append(&work_q->queue, work);
    7ee0:	480e      	ldr	r0, [pc, #56]	; (7f1c <bt_enable+0xec>)
    7ee2:	f105 0180 	add.w	r1, r5, #128	; 0x80
    7ee6:	f021 f9b4 	bl	29252 <k_queue_append>
    7eea:	e7b4      	b.n	7e56 <bt_enable+0x26>
		return -EALREADY;
    7eec:	f06f 0444 	mvn.w	r4, #68	; 0x44
    7ef0:	e7b1      	b.n	7e56 <bt_enable+0x26>
    7ef2:	bf00      	nop
    7ef4:	20006860 	.word	0x20006860
    7ef8:	00029830 	.word	0x00029830
    7efc:	000298f0 	.word	0x000298f0
    7f00:	0002c132 	.word	0x0002c132
    7f04:	20000478 	.word	0x20000478
    7f08:	00006aed 	.word	0x00006aed
    7f0c:	20002c80 	.word	0x20002c80
    7f10:	20000488 	.word	0x20000488
    7f14:	0002c14b 	.word	0x0002c14b
    7f18:	0002c151 	.word	0x0002c151
    7f1c:	20001dc4 	.word	0x20001dc4

00007f20 <bt_set_name>:
{
    7f20:	b530      	push	{r4, r5, lr}
    7f22:	b085      	sub	sp, #20
    7f24:	4604      	mov	r4, r0
	size_t len = strlen(name);
    7f26:	f01d fe8d 	bl	25c44 <strlen>
	if (len >= sizeof(bt_dev.name)) {
    7f2a:	281c      	cmp	r0, #28
	size_t len = strlen(name);
    7f2c:	4605      	mov	r5, r0
	if (len >= sizeof(bt_dev.name)) {
    7f2e:	d835      	bhi.n	7f9c <bt_set_name+0x7c>
	if (!strcmp(bt_dev.name, name)) {
    7f30:	481c      	ldr	r0, [pc, #112]	; (7fa4 <bt_set_name+0x84>)
    7f32:	4621      	mov	r1, r4
    7f34:	f01d fe8d 	bl	25c52 <strcmp>
    7f38:	b910      	cbnz	r0, 7f40 <bt_set_name+0x20>
	return 0;
    7f3a:	2000      	movs	r0, #0
}
    7f3c:	b005      	add	sp, #20
    7f3e:	bd30      	pop	{r4, r5, pc}
	strncpy(bt_dev.name, name, sizeof(bt_dev.name));
    7f40:	221d      	movs	r2, #29
    7f42:	4621      	mov	r1, r4
    7f44:	4817      	ldr	r0, [pc, #92]	; (7fa4 <bt_set_name+0x84>)
    7f46:	f01d fe5c 	bl	25c02 <strncpy>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    7f4a:	4817      	ldr	r0, [pc, #92]	; (7fa8 <bt_set_name+0x88>)
    7f4c:	f01e f9ce 	bl	262ec <atomic_get>
	if (adv && atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING_NAME)) {
    7f50:	0643      	lsls	r3, r0, #25
    7f52:	d511      	bpl.n	7f78 <bt_set_name+0x58>
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    7f54:	2309      	movs	r3, #9
    7f56:	4620      	mov	r0, r4
    7f58:	f88d 3000 	strb.w	r3, [sp]
    7f5c:	f01d fe72 	bl	25c44 <strlen>
		struct bt_ad sd = { data, ARRAY_SIZE(data) };
    7f60:	2201      	movs	r2, #1
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    7f62:	f88d 0001 	strb.w	r0, [sp, #1]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    7f66:	a902      	add	r1, sp, #8
    7f68:	f242 0009 	movw	r0, #8201	; 0x2009
		struct bt_data data[] = { BT_DATA(BT_DATA_NAME_COMPLETE, name,
    7f6c:	9401      	str	r4, [sp, #4]
		struct bt_ad sd = { data, ARRAY_SIZE(data) };
    7f6e:	f8cd d008 	str.w	sp, [sp, #8]
    7f72:	9203      	str	r2, [sp, #12]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    7f74:	f7ff fa42 	bl	73fc <hci_set_ad>
		err = settings_save_one("bt/name", bt_dev.name, len);
    7f78:	490a      	ldr	r1, [pc, #40]	; (7fa4 <bt_set_name+0x84>)
    7f7a:	480c      	ldr	r0, [pc, #48]	; (7fac <bt_set_name+0x8c>)
    7f7c:	462a      	mov	r2, r5
    7f7e:	f7fb fccd 	bl	391c <settings_save_one>
		if (err) {
    7f82:	2800      	cmp	r0, #0
    7f84:	d0d9      	beq.n	7f3a <bt_set_name+0x1a>
    7f86:	4b0a      	ldr	r3, [pc, #40]	; (7fb0 <bt_set_name+0x90>)
    7f88:	490a      	ldr	r1, [pc, #40]	; (7fb4 <bt_set_name+0x94>)
			BT_WARN("Unable to store name");
    7f8a:	480b      	ldr	r0, [pc, #44]	; (7fb8 <bt_set_name+0x98>)
    7f8c:	1ac9      	subs	r1, r1, r3
    7f8e:	08c9      	lsrs	r1, r1, #3
    7f90:	0189      	lsls	r1, r1, #6
    7f92:	f041 0102 	orr.w	r1, r1, #2
    7f96:	f01c f815 	bl	23fc4 <log_0>
    7f9a:	e7ce      	b.n	7f3a <bt_set_name+0x1a>
		return -ENOMEM;
    7f9c:	f06f 000b 	mvn.w	r0, #11
    7fa0:	e7cc      	b.n	7f3c <bt_set_name+0x1c>
    7fa2:	bf00      	nop
    7fa4:	20006954 	.word	0x20006954
    7fa8:	200068ec 	.word	0x200068ec
    7fac:	0002c16d 	.word	0x0002c16d
    7fb0:	00029830 	.word	0x00029830
    7fb4:	000298f0 	.word	0x000298f0
    7fb8:	0002c175 	.word	0x0002c175

00007fbc <bt_get_name>:
}
    7fbc:	4800      	ldr	r0, [pc, #0]	; (7fc0 <bt_get_name+0x4>)
    7fbe:	4770      	bx	lr
    7fc0:	20006954 	.word	0x20006954

00007fc4 <bt_id_create>:
{
    7fc4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7fc6:	460c      	mov	r4, r1
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    7fc8:	4605      	mov	r5, r0
    7fca:	b918      	cbnz	r0, 7fd4 <bt_id_create+0x10>
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
    7fcc:	b34c      	cbz	r4, 8022 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x22>
		return -EINVAL;
    7fce:	f06f 0415 	mvn.w	r4, #21
    7fd2:	e023      	b.n	801c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1c>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    7fd4:	2300      	movs	r3, #0
    7fd6:	2207      	movs	r2, #7
    7fd8:	4669      	mov	r1, sp
    7fda:	9300      	str	r3, [sp, #0]
    7fdc:	f8cd 3003 	str.w	r3, [sp, #3]
    7fe0:	f01d fe52 	bl	25c88 <memcmp>
    7fe4:	2800      	cmp	r0, #0
    7fe6:	d0f1      	beq.n	7fcc <bt_id_create+0x8>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    7fe8:	782b      	ldrb	r3, [r5, #0]
    7fea:	2b01      	cmp	r3, #1
    7fec:	d104      	bne.n	7ff8 <bt_id_create+0x34>
    7fee:	79ab      	ldrb	r3, [r5, #6]
    7ff0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    7ff4:	2bc0      	cmp	r3, #192	; 0xc0
    7ff6:	d00a      	beq.n	800e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xe>
    7ff8:	4b11      	ldr	r3, [pc, #68]	; (8040 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x40>)
    7ffa:	4912      	ldr	r1, [pc, #72]	; (8044 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x44>)
			BT_ERR("Only static random identity address supported");
    7ffc:	4812      	ldr	r0, [pc, #72]	; (8048 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x48>)
    7ffe:	1ac9      	subs	r1, r1, r3
    8000:	08c9      	lsrs	r1, r1, #3
    8002:	0189      	lsls	r1, r1, #6
    8004:	f041 0101 	orr.w	r1, r1, #1
    8008:	f01b ffdc 	bl	23fc4 <log_0>
			return -EINVAL;
    800c:	e7df      	b.n	7fce <bt_id_create+0xa>
		if (id_find(addr) >= 0) {
    800e:	4628      	mov	r0, r5
    8010:	f7fe fd52 	bl	6ab8 <id_find>
    8014:	2800      	cmp	r0, #0
    8016:	dbd9      	blt.n	7fcc <bt_id_create+0x8>
			return -EALREADY;
    8018:	f06f 0444 	mvn.w	r4, #68	; 0x44
}
    801c:	4620      	mov	r0, r4
    801e:	b003      	add	sp, #12
    8020:	bd30      	pop	{r4, r5, pc}
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    8022:	4b0a      	ldr	r3, [pc, #40]	; (804c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4c>)
    8024:	79dc      	ldrb	r4, [r3, #7]
    8026:	2c01      	cmp	r4, #1
    8028:	d006      	beq.n	8038 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x38>
	new_id = bt_dev.id_count++;
    802a:	1c62      	adds	r2, r4, #1
	id_create(new_id, addr, irk);
    802c:	4629      	mov	r1, r5
    802e:	4620      	mov	r0, r4
	new_id = bt_dev.id_count++;
    8030:	71da      	strb	r2, [r3, #7]
	id_create(new_id, addr, irk);
    8032:	f7ff fb11 	bl	7658 <id_create.isra.0>
	return new_id;
    8036:	e7f1      	b.n	801c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1c>
		return -ENOMEM;
    8038:	f06f 040b 	mvn.w	r4, #11
    803c:	e7ee      	b.n	801c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1c>
    803e:	bf00      	nop
    8040:	00029830 	.word	0x00029830
    8044:	000298f0 	.word	0x000298f0
    8048:	0002c18a 	.word	0x0002c18a
    804c:	20006860 	.word	0x20006860

00008050 <bt_setup_public_id_addr>:
{
    8050:	b570      	push	{r4, r5, r6, lr}
    8052:	b086      	sub	sp, #24
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    8054:	aa01      	add	r2, sp, #4
    8056:	2100      	movs	r1, #0
    8058:	f241 0009 	movw	r0, #4105	; 0x1009
    805c:	f7ff f930 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    8060:	4e1f      	ldr	r6, [pc, #124]	; (80e0 <bt_setup_public_id_addr+0x90>)
    8062:	4604      	mov	r4, r0
    8064:	b168      	cbz	r0, 8082 <bt_setup_public_id_addr+0x32>
    8066:	491f      	ldr	r1, [pc, #124]	; (80e4 <bt_setup_public_id_addr+0x94>)
    8068:	4b1f      	ldr	r3, [pc, #124]	; (80e8 <bt_setup_public_id_addr+0x98>)
		BT_WARN("Failed to read public address");
    806a:	4820      	ldr	r0, [pc, #128]	; (80ec <bt_setup_public_id_addr+0x9c>)
    806c:	1ac9      	subs	r1, r1, r3
    806e:	08c9      	lsrs	r1, r1, #3
    8070:	0189      	lsls	r1, r1, #6
    8072:	f041 0102 	orr.w	r1, r1, #2
    8076:	f01b ffa5 	bl	23fc4 <log_0>
	bt_dev.id_count = bt_read_public_addr(&addr);
    807a:	2300      	movs	r3, #0
    807c:	71f3      	strb	r3, [r6, #7]
}
    807e:	b006      	add	sp, #24
    8080:	bd70      	pop	{r4, r5, r6, pc}
	rp = (void *)rsp->data;
    8082:	9b01      	ldr	r3, [sp, #4]
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    8084:	689d      	ldr	r5, [r3, #8]
    8086:	9004      	str	r0, [sp, #16]
    8088:	3501      	adds	r5, #1
    808a:	f8ad 0014 	strh.w	r0, [sp, #20]
	return memcmp(a, b, sizeof(*a));
    808e:	2206      	movs	r2, #6
    8090:	a904      	add	r1, sp, #16
    8092:	4628      	mov	r0, r5
    8094:	f01d fdf8 	bl	25c88 <memcmp>
    8098:	b918      	cbnz	r0, 80a2 <bt_setup_public_id_addr+0x52>
		net_buf_unref(rsp);
    809a:	9801      	ldr	r0, [sp, #4]
    809c:	f017 f814 	bl	1f0c8 <net_buf_unref>
    80a0:	e7eb      	b.n	807a <bt_setup_public_id_addr+0x2a>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    80a2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    80a6:	2206      	movs	r2, #6
    80a8:	a902      	add	r1, sp, #8
    80aa:	4628      	mov	r0, r5
    80ac:	9302      	str	r3, [sp, #8]
    80ae:	f8ad 300c 	strh.w	r3, [sp, #12]
    80b2:	f01d fde9 	bl	25c88 <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    80b6:	2800      	cmp	r0, #0
    80b8:	d0ef      	beq.n	809a <bt_setup_public_id_addr+0x4a>
	memcpy(dst, src, sizeof(*dst));
    80ba:	4629      	mov	r1, r5
    80bc:	2206      	movs	r2, #6
    80be:	f10d 0011 	add.w	r0, sp, #17
    80c2:	f01d fdf1 	bl	25ca8 <memcpy>
	net_buf_unref(rsp);
    80c6:	9801      	ldr	r0, [sp, #4]
	addr->type = BT_ADDR_LE_PUBLIC;
    80c8:	f88d 4010 	strb.w	r4, [sp, #16]
	net_buf_unref(rsp);
    80cc:	f016 fffc 	bl	1f0c8 <net_buf_unref>
	bt_dev.id_count = bt_read_public_addr(&addr);
    80d0:	2301      	movs	r3, #1
	id_create(BT_ID_DEFAULT, &addr, irk);
    80d2:	a904      	add	r1, sp, #16
    80d4:	4620      	mov	r0, r4
	bt_dev.id_count = bt_read_public_addr(&addr);
    80d6:	71f3      	strb	r3, [r6, #7]
	id_create(BT_ID_DEFAULT, &addr, irk);
    80d8:	f7ff fabe 	bl	7658 <id_create.isra.0>
    80dc:	e7cf      	b.n	807e <bt_setup_public_id_addr+0x2e>
    80de:	bf00      	nop
    80e0:	20006860 	.word	0x20006860
    80e4:	000298f0 	.word	0x000298f0
    80e8:	00029830 	.word	0x00029830
    80ec:	0002c1b8 	.word	0x0002c1b8

000080f0 <bt_read_static_addr>:
{
    80f0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    80f4:	4b25      	ldr	r3, [pc, #148]	; (818c <bt_read_static_addr+0x9c>)
    80f6:	f893 407e 	ldrb.w	r4, [r3, #126]	; 0x7e
    80fa:	f014 0401 	ands.w	r4, r4, #1
{
    80fe:	4607      	mov	r7, r0
    8100:	460e      	mov	r6, r1
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    8102:	d10a      	bne.n	811a <bt_read_static_addr+0x2a>
    8104:	4922      	ldr	r1, [pc, #136]	; (8190 <bt_read_static_addr+0xa0>)
    8106:	4b23      	ldr	r3, [pc, #140]	; (8194 <bt_read_static_addr+0xa4>)
		BT_WARN("Read Static Addresses command not available");
    8108:	4823      	ldr	r0, [pc, #140]	; (8198 <bt_read_static_addr+0xa8>)
    810a:	1ac9      	subs	r1, r1, r3
    810c:	08c9      	lsrs	r1, r1, #3
    810e:	0189      	lsls	r1, r1, #6
    8110:	f041 0102 	orr.w	r1, r1, #2
		BT_WARN("No static addresses stored in controller");
    8114:	f01b ff56 	bl	23fc4 <log_0>
    8118:	e012      	b.n	8140 <bt_read_static_addr+0x50>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    811a:	aa01      	add	r2, sp, #4
    811c:	2100      	movs	r1, #0
    811e:	f64f 4009 	movw	r0, #64521	; 0xfc09
    8122:	f7ff f8cd 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    8126:	4605      	mov	r5, r0
    8128:	b170      	cbz	r0, 8148 <bt_read_static_addr+0x58>
    812a:	4b1a      	ldr	r3, [pc, #104]	; (8194 <bt_read_static_addr+0xa4>)
    812c:	4918      	ldr	r1, [pc, #96]	; (8190 <bt_read_static_addr+0xa0>)
		BT_WARN("Failed to read static addresses");
    812e:	481b      	ldr	r0, [pc, #108]	; (819c <bt_read_static_addr+0xac>)
    8130:	1ac9      	subs	r1, r1, r3
    8132:	08c9      	lsrs	r1, r1, #3
    8134:	0189      	lsls	r1, r1, #6
    8136:	f041 0102 	orr.w	r1, r1, #2
    813a:	f01b ff43 	bl	23fc4 <log_0>
		return 0;
    813e:	2400      	movs	r4, #0
}
    8140:	4620      	mov	r0, r4
    8142:	b002      	add	sp, #8
    8144:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	rp = (void *)rsp->data;
    8148:	9b01      	ldr	r3, [sp, #4]
    814a:	689b      	ldr	r3, [r3, #8]
	cnt = MIN(rp->num_addrs, size);
    814c:	785c      	ldrb	r4, [r3, #1]
    814e:	42b4      	cmp	r4, r6
    8150:	bf28      	it	cs
    8152:	4634      	movcs	r4, r6
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    8154:	f04f 0816 	mov.w	r8, #22
    8158:	1c9e      	adds	r6, r3, #2
	for (i = 0; i < cnt; i++) {
    815a:	42a5      	cmp	r5, r4
    815c:	db0d      	blt.n	817a <bt_read_static_addr+0x8a>
	net_buf_unref(rsp);
    815e:	9801      	ldr	r0, [sp, #4]
    8160:	f016 ffb2 	bl	1f0c8 <net_buf_unref>
	if (!cnt) {
    8164:	2c00      	cmp	r4, #0
    8166:	d1eb      	bne.n	8140 <bt_read_static_addr+0x50>
    8168:	4909      	ldr	r1, [pc, #36]	; (8190 <bt_read_static_addr+0xa0>)
    816a:	4b0a      	ldr	r3, [pc, #40]	; (8194 <bt_read_static_addr+0xa4>)
		BT_WARN("No static addresses stored in controller");
    816c:	480c      	ldr	r0, [pc, #48]	; (81a0 <bt_read_static_addr+0xb0>)
    816e:	1ac9      	subs	r1, r1, r3
    8170:	08c9      	lsrs	r1, r1, #3
    8172:	0189      	lsls	r1, r1, #6
    8174:	f041 0102 	orr.w	r1, r1, #2
    8178:	e7cc      	b.n	8114 <bt_read_static_addr+0x24>
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    817a:	fb08 7005 	mla	r0, r8, r5, r7
    817e:	2216      	movs	r2, #22
    8180:	4631      	mov	r1, r6
    8182:	f01d fd91 	bl	25ca8 <memcpy>
	for (i = 0; i < cnt; i++) {
    8186:	3501      	adds	r5, #1
    8188:	e7e7      	b.n	815a <bt_read_static_addr+0x6a>
    818a:	bf00      	nop
    818c:	20006860 	.word	0x20006860
    8190:	000298f0 	.word	0x000298f0
    8194:	00029830 	.word	0x00029830
    8198:	0002c1d6 	.word	0x0002c1d6
    819c:	0002c202 	.word	0x0002c202
    81a0:	0002c222 	.word	0x0002c222

000081a4 <bt_setup_random_id_addr>:
{
    81a4:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!bt_dev.id_count) {
    81a6:	4d14      	ldr	r5, [pc, #80]	; (81f8 <bt_setup_random_id_addr+0x54>)
    81a8:	79ec      	ldrb	r4, [r5, #7]
{
    81aa:	b089      	sub	sp, #36	; 0x24
	if (!bt_dev.id_count) {
    81ac:	b9f4      	cbnz	r4, 81ec <bt_setup_random_id_addr+0x48>
		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
    81ae:	2101      	movs	r1, #1
    81b0:	a802      	add	r0, sp, #8
    81b2:	f7ff ff9d 	bl	80f0 <bt_read_static_addr>
    81b6:	71e8      	strb	r0, [r5, #7]
		if (bt_dev.id_count) {
    81b8:	b1c0      	cbz	r0, 81ec <bt_setup_random_id_addr+0x48>
				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
    81ba:	2716      	movs	r7, #22
    81bc:	e00f      	b.n	81de <bt_setup_random_id_addr+0x3a>
    81be:	ab02      	add	r3, sp, #8
    81c0:	fb07 3106 	mla	r1, r7, r6, r3
    81c4:	2206      	movs	r2, #6
    81c6:	f10d 0001 	add.w	r0, sp, #1
    81ca:	f01d fd6d 	bl	25ca8 <memcpy>
				addr.type = BT_ADDR_LE_RANDOM;
    81ce:	2301      	movs	r3, #1
				id_create(i, &addr, irk);
    81d0:	4669      	mov	r1, sp
    81d2:	4630      	mov	r0, r6
				addr.type = BT_ADDR_LE_RANDOM;
    81d4:	f88d 3000 	strb.w	r3, [sp]
				id_create(i, &addr, irk);
    81d8:	f7ff fa3e 	bl	7658 <id_create.isra.0>
			for (u8_t i = 0; i < bt_dev.id_count; i++) {
    81dc:	3401      	adds	r4, #1
    81de:	79eb      	ldrb	r3, [r5, #7]
    81e0:	b2e6      	uxtb	r6, r4
    81e2:	42b3      	cmp	r3, r6
    81e4:	d8eb      	bhi.n	81be <bt_setup_random_id_addr+0x1a>
			return 0;
    81e6:	2000      	movs	r0, #0
}
    81e8:	b009      	add	sp, #36	; 0x24
    81ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return bt_id_create(NULL, NULL);
    81ec:	2100      	movs	r1, #0
    81ee:	4608      	mov	r0, r1
    81f0:	f7ff fee8 	bl	7fc4 <bt_id_create>
    81f4:	e7f8      	b.n	81e8 <bt_setup_random_id_addr+0x44>
    81f6:	bf00      	nop
    81f8:	20006860 	.word	0x20006860

000081fc <le_adv_set_random_addr>:
	}
}

int le_adv_set_random_addr(struct bt_le_ext_adv *adv, u32_t options,
			   bool dir_adv, u8_t *own_addr_type)
{
    81fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int err = 0;

	/* Set which local identity address we're advertising with */
	id_addr = &bt_dev.id_addr[adv->id];

	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    8200:	f011 0401 	ands.w	r4, r1, #1
	id_addr = &bt_dev.id_addr[adv->id];
    8204:	7805      	ldrb	r5, [r0, #0]
{
    8206:	461e      	mov	r6, r3
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    8208:	d019      	beq.n	823e <le_adv_set_random_addr+0x42>
			 * If Static Random address is used as Identity
			 * address we need to restore it before advertising
			 * is enabled. Otherwise NRPA used for active scan
			 * could be used for advertising.
			 */
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    820a:	4f26      	ldr	r7, [pc, #152]	; (82a4 <le_adv_set_random_addr+0xa8>)
    820c:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
    8210:	ea4f 08c5 	mov.w	r8, r5, lsl #3
    8214:	5cfb      	ldrb	r3, [r7, r3]
    8216:	2b01      	cmp	r3, #1
    8218:	d007      	beq.n	822a <le_adv_set_random_addr+0x2e>
				if (err) {
					return err;
				}
			}

			*own_addr_type = id_addr->type;
    821a:	eba8 0505 	sub.w	r5, r8, r5
		if (err) {
			return err;
		}
	}

	return 0;
    821e:	2400      	movs	r4, #0
			*own_addr_type = id_addr->type;
    8220:	5d7b      	ldrb	r3, [r7, r5]
    8222:	7033      	strb	r3, [r6, #0]
}
    8224:	4620      	mov	r0, r4
    8226:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				err = set_adv_random_address(adv, &id_addr->a);
    822a:	2007      	movs	r0, #7
    822c:	fb10 3005 	smlabb	r0, r0, r5, r3
		return set_random_address(addr);
    8230:	4438      	add	r0, r7
    8232:	f7ff f99d 	bl	7570 <set_random_address>
				if (err) {
    8236:	4604      	mov	r4, r0
    8238:	2800      	cmp	r0, #0
    823a:	d0ee      	beq.n	821a <le_adv_set_random_addr+0x1e>
    823c:	e7f2      	b.n	8224 <le_adv_set_random_addr+0x28>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
    823e:	f011 0104 	ands.w	r1, r1, #4
    8242:	d013      	beq.n	826c <le_adv_set_random_addr+0x70>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    8244:	4f17      	ldr	r7, [pc, #92]	; (82a4 <le_adv_set_random_addr+0xa8>)
    8246:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
    824a:	ea4f 08c5 	mov.w	r8, r5, lsl #3
    824e:	5cfb      	ldrb	r3, [r7, r3]
    8250:	2b01      	cmp	r3, #1
    8252:	d106      	bne.n	8262 <le_adv_set_random_addr+0x66>
				err = set_adv_random_address(adv, &id_addr->a);
    8254:	2007      	movs	r0, #7
    8256:	fb10 3005 	smlabb	r0, r0, r5, r3
		return set_random_address(addr);
    825a:	4438      	add	r0, r7
    825c:	f7ff f988 	bl	7570 <set_random_address>
    8260:	4604      	mov	r4, r0
			*own_addr_type = id_addr->type;
    8262:	eba8 0505 	sub.w	r5, r8, r5
    8266:	5d7b      	ldrb	r3, [r7, r5]
    8268:	7033      	strb	r3, [r6, #0]
    826a:	e7db      	b.n	8224 <le_adv_set_random_addr+0x28>
    826c:	480e      	ldr	r0, [pc, #56]	; (82a8 <le_adv_set_random_addr+0xac>)
    826e:	f01e f83d 	bl	262ec <atomic_get>
			if (!IS_ENABLED(CONFIG_BT_PRIVACY) &&
    8272:	0542      	lsls	r2, r0, #21
    8274:	d40a      	bmi.n	828c <le_adv_set_random_addr+0x90>
			bool scan_enabled = false;
    8276:	2500      	movs	r5, #0
			err = le_adv_set_private_addr(adv);
    8278:	f01e f87b 	bl	26372 <le_adv_set_private_addr.isra.0>
    827c:	4604      	mov	r4, r0
			*own_addr_type = BT_ADDR_LE_RANDOM;
    827e:	2001      	movs	r0, #1
    8280:	7030      	strb	r0, [r6, #0]
			if (scan_enabled) {
    8282:	2d00      	cmp	r5, #0
    8284:	d0ce      	beq.n	8224 <le_adv_set_random_addr+0x28>
	return set_le_scan_enable_legacy(enable);
    8286:	f7ff f87d 	bl	7384 <set_le_scan_enable_legacy>
		if (err) {
    828a:	e7cb      	b.n	8224 <le_adv_set_random_addr+0x28>
    828c:	4806      	ldr	r0, [pc, #24]	; (82a8 <le_adv_set_random_addr+0xac>)
    828e:	f01e f82d 	bl	262ec <atomic_get>
			    atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) &&
    8292:	04c3      	lsls	r3, r0, #19
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    8294:	f3c0 3500 	ubfx	r5, r0, #12, #1
    8298:	d5ed      	bpl.n	8276 <le_adv_set_random_addr+0x7a>
	return set_le_scan_enable_legacy(enable);
    829a:	4608      	mov	r0, r1
    829c:	f7ff f872 	bl	7384 <set_le_scan_enable_legacy>
    82a0:	e7ea      	b.n	8278 <le_adv_set_random_addr+0x7c>
    82a2:	bf00      	nop
    82a4:	20006860 	.word	0x20006860
    82a8:	200068ec 	.word	0x200068ec

000082ac <bt_le_adv_start_legacy>:

int bt_le_adv_start_legacy(const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len,
			   const bt_addr_le_t *peer)
{
    82ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    82b0:	b088      	sub	sp, #32
    82b2:	4605      	mov	r5, r0
    82b4:	9e11      	ldr	r6, [sp, #68]	; 0x44
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    82b6:	487a      	ldr	r0, [pc, #488]	; (84a0 <bt_le_adv_start_legacy+0x1f4>)
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
	struct net_buf *buf;
	bool dir_adv = (peer != NULL);
    82b8:	f1b6 0a00 	subs.w	sl, r6, #0
{
    82bc:	461f      	mov	r7, r3
	bool dir_adv = (peer != NULL);
    82be:	bf18      	it	ne
    82c0:	f04f 0a01 	movne.w	sl, #1
{
    82c4:	4688      	mov	r8, r1
    82c6:	4691      	mov	r9, r2
    82c8:	f01e f810 	bl	262ec <atomic_get>
	int err;
	struct bt_le_ext_adv *adv;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    82cc:	0783      	lsls	r3, r0, #30
    82ce:	f140 80db 	bpl.w	8488 <bt_le_adv_start_legacy+0x1dc>
		return -EAGAIN;
	}

	if (!valid_adv_param(param, dir_adv)) {
    82d2:	4651      	mov	r1, sl
    82d4:	4628      	mov	r0, r5
    82d6:	f7fe fe2d 	bl	6f34 <valid_adv_param>
    82da:	2800      	cmp	r0, #0
    82dc:	f000 80d7 	beq.w	848e <bt_le_adv_start_legacy+0x1e2>
    82e0:	486f      	ldr	r0, [pc, #444]	; (84a0 <bt_le_adv_start_legacy+0x1f4>)
    82e2:	f01e f803 	bl	262ec <atomic_get>
		return -EINVAL;
	}

	if (atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    82e6:	0684      	lsls	r4, r0, #26
    82e8:	f100 80d4 	bmi.w	8494 <bt_le_adv_start_legacy+0x1e8>
    82ec:	486c      	ldr	r0, [pc, #432]	; (84a0 <bt_le_adv_start_legacy+0x1f4>)
    82ee:	f01d fffd 	bl	262ec <atomic_get>
	if (!IS_ENABLED(CONFIG_BT_OBSERVER) ||
    82f2:	03c0      	lsls	r0, r0, #15
    82f4:	d402      	bmi.n	82fc <bt_le_adv_start_legacy+0x50>
    82f6:	486a      	ldr	r0, [pc, #424]	; (84a0 <bt_le_adv_start_legacy+0x1f4>)
    82f8:	f01d fff8 	bl	262ec <atomic_get>

	if (!bt_le_adv_random_addr_check(param)) {
		return -EINVAL;
	}

	(void)memset(&set_param, 0, sizeof(set_param));
    82fc:	220f      	movs	r2, #15
    82fe:	2100      	movs	r1, #0
    8300:	a804      	add	r0, sp, #16
    8302:	f01d fcfc 	bl	25cfe <memset>

	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
    8306:	68ab      	ldr	r3, [r5, #8]
    8308:	f8ad 3010 	strh.w	r3, [sp, #16]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    830c:	68eb      	ldr	r3, [r5, #12]
	if (!adv) {
		BT_ERR("Legacy advertiser has no adv context");
		return -ENOMEM;
	}

	if (adv->id != param->id) {
    830e:	4c65      	ldr	r4, [pc, #404]	; (84a4 <bt_le_adv_start_legacy+0x1f8>)
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    8310:	f8ad 3012 	strh.w	r3, [sp, #18]
	set_param.channel_map  = 0x07;
    8314:	2307      	movs	r3, #7
    8316:	f88d 301d 	strb.w	r3, [sp, #29]
	set_param.filter_policy = get_filter_policy(param->options);
    831a:	2300      	movs	r3, #0
	if (adv->id != param->id) {
    831c:	7d22      	ldrb	r2, [r4, #20]
	set_param.filter_policy = get_filter_policy(param->options);
    831e:	f88d 301e 	strb.w	r3, [sp, #30]
	if (adv->id != param->id) {
    8322:	782b      	ldrb	r3, [r5, #0]
    8324:	429a      	cmp	r2, r3
    8326:	d005      	beq.n	8334 <bt_le_adv_start_legacy+0x88>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    8328:	f46f 3100 	mvn.w	r1, #131072	; 0x20000
    832c:	f104 008c 	add.w	r0, r4, #140	; 0x8c
    8330:	f01d ffff 	bl	26332 <atomic_and>
		atomic_clear_bit(bt_dev.flags, BT_DEV_RPA_VALID);
	}

	adv->id = param->id;
    8334:	782b      	ldrb	r3, [r5, #0]
    8336:	7523      	strb	r3, [r4, #20]
	err = le_adv_set_random_addr(adv, param->options, dir_adv,
    8338:	6869      	ldr	r1, [r5, #4]
    833a:	485b      	ldr	r0, [pc, #364]	; (84a8 <bt_le_adv_start_legacy+0x1fc>)
    833c:	f10d 0315 	add.w	r3, sp, #21
    8340:	4652      	mov	r2, sl
    8342:	f7ff ff5b 	bl	81fc <le_adv_set_random_addr>
				     &set_param.own_addr_type);
	if (err) {
    8346:	4604      	mov	r4, r0
    8348:	2800      	cmp	r0, #0
    834a:	d172      	bne.n	8432 <bt_le_adv_start_legacy+0x186>
		return err;
	}

	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    834c:	686b      	ldr	r3, [r5, #4]
    834e:	07d9      	lsls	r1, r3, #31
    8350:	d543      	bpl.n	83da <bt_le_adv_start_legacy+0x12e>
		if (dir_adv) {
    8352:	2e00      	cmp	r6, #0
    8354:	d03e      	beq.n	83d4 <bt_le_adv_start_legacy+0x128>
			if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
				set_param.type = BT_HCI_ADV_DIRECT_IND_LOW_DUTY;
			} else {
				set_param.type = BT_HCI_ADV_DIRECT_IND;
    8356:	f013 0f10 	tst.w	r3, #16
    835a:	bf14      	ite	ne
    835c:	2304      	movne	r3, #4
    835e:	2301      	moveq	r3, #1
			}

			bt_addr_le_copy(&set_param.direct_addr, peer);
    8360:	4631      	mov	r1, r6
    8362:	f10d 0016 	add.w	r0, sp, #22
    8366:	f88d 3014 	strb.w	r3, [sp, #20]
    836a:	f01d ffc5 	bl	262f8 <bt_addr_le_copy>
		} else {
			set_param.type = BT_HCI_ADV_NONCONN_IND;
		}
	}

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
    836e:	210f      	movs	r1, #15
    8370:	f242 0006 	movw	r0, #8198	; 0x2006
    8374:	f7fe fe2c 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    8378:	4604      	mov	r4, r0
    837a:	2800      	cmp	r0, #0
    837c:	f000 808d 	beq.w	849a <bt_le_adv_start_legacy+0x1ee>
		return -ENOBUFS;
	}

	net_buf_add_mem(buf, &set_param, sizeof(set_param));
    8380:	220f      	movs	r2, #15
    8382:	a904      	add	r1, sp, #16
    8384:	3008      	adds	r0, #8
    8386:	f020 fd16 	bl	28db6 <net_buf_simple_add_mem>

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
    838a:	4621      	mov	r1, r4
    838c:	2200      	movs	r2, #0
    838e:	f242 0006 	movw	r0, #8198	; 0x2006
    8392:	f7fe ff95 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    8396:	4604      	mov	r4, r0
    8398:	2800      	cmp	r0, #0
    839a:	d14a      	bne.n	8432 <bt_le_adv_start_legacy+0x186>
		return err;
	}

	if (!dir_adv) {
    839c:	b336      	cbz	r6, 83ec <bt_le_adv_start_legacy+0x140>
	struct bt_conn *conn = NULL;
    839e:	2600      	movs	r6, #0
	return set_le_adv_enable_legacy(enable);
    83a0:	2001      	movs	r0, #1
    83a2:	f7ff f913 	bl	75cc <set_le_adv_enable_legacy>
			bt_conn_set_state(conn, BT_CONN_CONNECT_ADV);
		}
	}

	err = set_le_adv_enable(adv, true);
	if (err) {
    83a6:	4604      	mov	r4, r0
    83a8:	2800      	cmp	r0, #0
    83aa:	d04a      	beq.n	8442 <bt_le_adv_start_legacy+0x196>
    83ac:	493f      	ldr	r1, [pc, #252]	; (84ac <bt_le_adv_start_legacy+0x200>)
    83ae:	4b40      	ldr	r3, [pc, #256]	; (84b0 <bt_le_adv_start_legacy+0x204>)
		BT_ERR("Failed to start advertiser");
    83b0:	4840      	ldr	r0, [pc, #256]	; (84b4 <bt_le_adv_start_legacy+0x208>)
    83b2:	1ac9      	subs	r1, r1, r3
    83b4:	08c9      	lsrs	r1, r1, #3
    83b6:	0189      	lsls	r1, r1, #6
    83b8:	f041 0101 	orr.w	r1, r1, #1
    83bc:	f01b fe02 	bl	23fc4 <log_0>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    83c0:	2e00      	cmp	r6, #0
    83c2:	d036      	beq.n	8432 <bt_le_adv_start_legacy+0x186>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    83c4:	4630      	mov	r0, r6
    83c6:	2100      	movs	r1, #0
    83c8:	f000 fed0 	bl	916c <bt_conn_set_state>
			bt_conn_unref(conn);
    83cc:	4630      	mov	r0, r6
    83ce:	f01e f8f2 	bl	265b6 <bt_conn_unref>
    83d2:	e02e      	b.n	8432 <bt_le_adv_start_legacy+0x186>
			set_param.type = BT_HCI_ADV_IND;
    83d4:	f88d 6014 	strb.w	r6, [sp, #20]
    83d8:	e7c9      	b.n	836e <bt_le_adv_start_legacy+0xc2>
		if (sd || (param->options & BT_LE_ADV_OPT_USE_NAME)) {
    83da:	b90f      	cbnz	r7, 83e0 <bt_le_adv_start_legacy+0x134>
    83dc:	071a      	lsls	r2, r3, #28
    83de:	d503      	bpl.n	83e8 <bt_le_adv_start_legacy+0x13c>
			set_param.type = BT_HCI_ADV_SCAN_IND;
    83e0:	2302      	movs	r3, #2
			set_param.type = BT_HCI_ADV_NONCONN_IND;
    83e2:	f88d 3014 	strb.w	r3, [sp, #20]
    83e6:	e7c2      	b.n	836e <bt_le_adv_start_legacy+0xc2>
    83e8:	2303      	movs	r3, #3
    83ea:	e7fa      	b.n	83e2 <bt_le_adv_start_legacy+0x136>
				    param->options & BT_LE_ADV_OPT_CONNECTABLE,
    83ec:	686b      	ldr	r3, [r5, #4]
		err = le_adv_update(adv, ad, ad_len, sd, sd_len,
    83ee:	f3c3 02c0 	ubfx	r2, r3, #3, #1
    83f2:	f003 0301 	and.w	r3, r3, #1
    83f6:	9201      	str	r2, [sp, #4]
    83f8:	9300      	str	r3, [sp, #0]
    83fa:	463a      	mov	r2, r7
    83fc:	9b10      	ldr	r3, [sp, #64]	; 0x40
    83fe:	4649      	mov	r1, r9
    8400:	4640      	mov	r0, r8
    8402:	f7ff f86b 	bl	74dc <le_adv_update.isra.0>
		if (err) {
    8406:	4604      	mov	r4, r0
    8408:	b998      	cbnz	r0, 8432 <bt_le_adv_start_legacy+0x186>
		    param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    840a:	686b      	ldr	r3, [r5, #4]
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    840c:	07db      	lsls	r3, r3, #31
    840e:	d5c6      	bpl.n	839e <bt_le_adv_start_legacy+0xf2>
			conn = bt_conn_add_le(param->id, BT_ADDR_LE_NONE);
    8410:	f06f 03ff 	mvn.w	r3, #255	; 0xff
    8414:	9302      	str	r3, [sp, #8]
    8416:	7828      	ldrb	r0, [r5, #0]
    8418:	f64f 73ff 	movw	r3, #65535	; 0xffff
    841c:	a902      	add	r1, sp, #8
    841e:	f8ad 300c 	strh.w	r3, [sp, #12]
    8422:	f88d 300e 	strb.w	r3, [sp, #14]
    8426:	f000 fe63 	bl	90f0 <bt_conn_add_le>
			if (!conn) {
    842a:	4606      	mov	r6, r0
    842c:	b928      	cbnz	r0, 843a <bt_le_adv_start_legacy+0x18e>
				return -ENOMEM;
    842e:	f06f 040b 	mvn.w	r4, #11

	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_IDENTITY,
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);

	return 0;
}
    8432:	4620      	mov	r0, r4
    8434:	b008      	add	sp, #32
    8436:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			bt_conn_set_state(conn, BT_CONN_CONNECT_ADV);
    843a:	2103      	movs	r1, #3
    843c:	f000 fe96 	bl	916c <bt_conn_set_state>
    8440:	e7ae      	b.n	83a0 <bt_le_adv_start_legacy+0xf4>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    8442:	b116      	cbz	r6, 844a <bt_le_adv_start_legacy+0x19e>
		bt_conn_unref(conn);
    8444:	4630      	mov	r0, r6
    8446:	f01e f8b6 	bl	265b6 <bt_conn_unref>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_KEEP_ADVERTISING,
    844a:	686a      	ldr	r2, [r5, #4]
    844c:	4814      	ldr	r0, [pc, #80]	; (84a0 <bt_le_adv_start_legacy+0x1f4>)
    844e:	f082 0202 	eor.w	r2, r2, #2
    8452:	f3c2 0240 	ubfx	r2, r2, #1, #1
    8456:	2109      	movs	r1, #9
    8458:	f01d ff7a 	bl	26350 <atomic_set_bit_to>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_NAME,
    845c:	686a      	ldr	r2, [r5, #4]
    845e:	4810      	ldr	r0, [pc, #64]	; (84a0 <bt_le_adv_start_legacy+0x1f4>)
    8460:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    8464:	2106      	movs	r1, #6
    8466:	f01d ff73 	bl	26350 <atomic_set_bit_to>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_CONNECTABLE,
    846a:	686a      	ldr	r2, [r5, #4]
    846c:	480c      	ldr	r0, [pc, #48]	; (84a0 <bt_le_adv_start_legacy+0x1f4>)
    846e:	f002 0201 	and.w	r2, r2, #1
    8472:	2107      	movs	r1, #7
    8474:	f01d ff6c 	bl	26350 <atomic_set_bit_to>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_IDENTITY,
    8478:	686a      	ldr	r2, [r5, #4]
    847a:	4809      	ldr	r0, [pc, #36]	; (84a0 <bt_le_adv_start_legacy+0x1f4>)
    847c:	f3c2 0280 	ubfx	r2, r2, #2, #1
    8480:	2108      	movs	r1, #8
    8482:	f01d ff65 	bl	26350 <atomic_set_bit_to>
	return 0;
    8486:	e7d4      	b.n	8432 <bt_le_adv_start_legacy+0x186>
		return -EAGAIN;
    8488:	f06f 040a 	mvn.w	r4, #10
    848c:	e7d1      	b.n	8432 <bt_le_adv_start_legacy+0x186>
		return -EINVAL;
    848e:	f06f 0415 	mvn.w	r4, #21
    8492:	e7ce      	b.n	8432 <bt_le_adv_start_legacy+0x186>
		return -EALREADY;
    8494:	f06f 0444 	mvn.w	r4, #68	; 0x44
    8498:	e7cb      	b.n	8432 <bt_le_adv_start_legacy+0x186>
		return -ENOBUFS;
    849a:	f06f 0436 	mvn.w	r4, #54	; 0x36
    849e:	e7c8      	b.n	8432 <bt_le_adv_start_legacy+0x186>
    84a0:	200068ec 	.word	0x200068ec
    84a4:	20006860 	.word	0x20006860
    84a8:	20006874 	.word	0x20006874
    84ac:	000298f0 	.word	0x000298f0
    84b0:	00029830 	.word	0x00029830
    84b4:	0002c24b 	.word	0x0002c24b

000084b8 <bt_le_adv_stop>:

	return bt_le_adv_start_internal(param, ad, ad_len, sd, sd_len, NULL);
}

int bt_le_adv_stop(void)
{
    84b8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    84ba:	4c24      	ldr	r4, [pc, #144]	; (854c <bt_le_adv_stop+0x94>)
    84bc:	f46f 7100 	mvn.w	r1, #512	; 0x200
    84c0:	f104 008c 	add.w	r0, r4, #140	; 0x8c
    84c4:	f01d ff35 	bl	26332 <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    84c8:	f104 008c 	add.w	r0, r4, #140	; 0x8c
    84cc:	f01d ff0e 	bl	262ec <atomic_get>
	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING);

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
    84d0:	0682      	lsls	r2, r0, #26
    84d2:	d403      	bmi.n	84dc <bt_le_adv_stop+0x24>
		adv_delete_legacy();
		return 0;
    84d4:	2400      	movs	r4, #0
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
    84d6:	4620      	mov	r0, r4
    84d8:	b003      	add	sp, #12
    84da:	bd30      	pop	{r4, r5, pc}
		conn = bt_conn_lookup_state_le(adv->id, BT_ADDR_LE_NONE,
    84dc:	4b1c      	ldr	r3, [pc, #112]	; (8550 <bt_le_adv_stop+0x98>)
    84de:	6818      	ldr	r0, [r3, #0]
    84e0:	889a      	ldrh	r2, [r3, #4]
    84e2:	9000      	str	r0, [sp, #0]
    84e4:	799b      	ldrb	r3, [r3, #6]
    84e6:	f8ad 2004 	strh.w	r2, [sp, #4]
    84ea:	7d20      	ldrb	r0, [r4, #20]
    84ec:	f88d 3006 	strb.w	r3, [sp, #6]
    84f0:	2203      	movs	r2, #3
    84f2:	4669      	mov	r1, sp
    84f4:	f000 ff3a 	bl	936c <bt_conn_lookup_state_le>
		if (conn) {
    84f8:	4605      	mov	r5, r0
    84fa:	b128      	cbz	r0, 8508 <bt_le_adv_stop+0x50>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    84fc:	2100      	movs	r1, #0
    84fe:	f000 fe35 	bl	916c <bt_conn_set_state>
			bt_conn_unref(conn);
    8502:	4628      	mov	r0, r5
    8504:	f01e f857 	bl	265b6 <bt_conn_unref>
		conn = bt_conn_lookup_state_le(adv->id, NULL,
    8508:	7d20      	ldrb	r0, [r4, #20]
    850a:	2204      	movs	r2, #4
    850c:	2100      	movs	r1, #0
    850e:	f000 ff2d 	bl	936c <bt_conn_lookup_state_le>
		if (conn) {
    8512:	4604      	mov	r4, r0
    8514:	b128      	cbz	r0, 8522 <bt_le_adv_stop+0x6a>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    8516:	2100      	movs	r1, #0
    8518:	f000 fe28 	bl	916c <bt_conn_set_state>
			bt_conn_unref(conn);
    851c:	4620      	mov	r0, r4
    851e:	f01e f84a 	bl	265b6 <bt_conn_unref>
		err = set_le_adv_enable_legacy(false);
    8522:	2000      	movs	r0, #0
    8524:	f7ff f852 	bl	75cc <set_le_adv_enable_legacy>
		if (err) {
    8528:	4604      	mov	r4, r0
    852a:	2800      	cmp	r0, #0
    852c:	d1d3      	bne.n	84d6 <bt_le_adv_stop+0x1e>
    852e:	4809      	ldr	r0, [pc, #36]	; (8554 <bt_le_adv_stop+0x9c>)
    8530:	f01d fedc 	bl	262ec <atomic_get>
		if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    8534:	0543      	lsls	r3, r0, #21
    8536:	d5cd      	bpl.n	84d4 <bt_le_adv_stop+0x1c>
	return set_le_scan_enable_legacy(enable);
    8538:	4620      	mov	r0, r4
    853a:	f7fe ff23 	bl	7384 <set_le_scan_enable_legacy>
			le_set_private_addr(BT_ID_DEFAULT);
    853e:	f01d ff18 	bl	26372 <le_adv_set_private_addr.isra.0>
	return set_le_scan_enable_legacy(enable);
    8542:	2001      	movs	r0, #1
    8544:	f7fe ff1e 	bl	7384 <set_le_scan_enable_legacy>
    8548:	e7c5      	b.n	84d6 <bt_le_adv_stop+0x1e>
    854a:	bf00      	nop
    854c:	20006860 	.word	0x20006860
    8550:	00029a6c 	.word	0x00029a6c
    8554:	200068ec 	.word	0x200068ec

00008558 <bt_le_adv_resume>:

#if defined(CONFIG_BT_PERIPHERAL)
void bt_le_adv_resume(void)
{
    8558:	b513      	push	{r0, r1, r4, lr}
    855a:	4819      	ldr	r0, [pc, #100]	; (85c0 <bt_le_adv_resume+0x68>)
    855c:	f01d fec6 	bl	262ec <atomic_get>
	if (!adv) {
		BT_WARN("Not legacy advertiser");
		return;
	}

	BT_ASSERT(atomic_test_bit(bt_dev.flags,
    8560:	0603      	lsls	r3, r0, #24
    8562:	d40c      	bmi.n	857e <bt_le_adv_resume+0x26>
    8564:	4a17      	ldr	r2, [pc, #92]	; (85c4 <bt_le_adv_resume+0x6c>)
    8566:	4918      	ldr	r1, [pc, #96]	; (85c8 <bt_le_adv_resume+0x70>)
    8568:	4818      	ldr	r0, [pc, #96]	; (85cc <bt_le_adv_resume+0x74>)
    856a:	f641 53bf 	movw	r3, #7615	; 0x1dbf
    856e:	f01b fcb8 	bl	23ee2 <printk>
    8572:	4040      	eors	r0, r0
    8574:	f380 8811 	msr	BASEPRI, r0
    8578:	f04f 0003 	mov.w	r0, #3
    857c:	df02      	svc	2
				  BT_DEV_ADVERTISING_CONNECTABLE));

	adv_conn = bt_conn_add_le(adv->id, BT_ADDR_LE_NONE);
    857e:	f06f 03ff 	mvn.w	r3, #255	; 0xff
    8582:	9300      	str	r3, [sp, #0]
    8584:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8588:	f8ad 3004 	strh.w	r3, [sp, #4]
    858c:	f88d 3006 	strb.w	r3, [sp, #6]
    8590:	4b0f      	ldr	r3, [pc, #60]	; (85d0 <bt_le_adv_resume+0x78>)
    8592:	4669      	mov	r1, sp
    8594:	7d18      	ldrb	r0, [r3, #20]
    8596:	f000 fdab 	bl	90f0 <bt_conn_add_le>
	if (!adv_conn) {
    859a:	4604      	mov	r4, r0
    859c:	b168      	cbz	r0, 85ba <bt_le_adv_resume+0x62>
		return;
	}

	bt_conn_set_state(adv_conn, BT_CONN_CONNECT_ADV);
    859e:	2103      	movs	r1, #3
    85a0:	f000 fde4 	bl	916c <bt_conn_set_state>
	return set_le_adv_enable_legacy(enable);
    85a4:	2001      	movs	r0, #1
    85a6:	f7ff f811 	bl	75cc <set_le_adv_enable_legacy>
	    !atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING_IDENTITY)) {
		le_adv_set_private_addr(adv);
	}

	err = set_le_adv_enable(adv, true);
	if (err) {
    85aa:	b118      	cbz	r0, 85b4 <bt_le_adv_resume+0x5c>
		bt_conn_set_state(adv_conn, BT_CONN_DISCONNECTED);
    85ac:	2100      	movs	r1, #0
    85ae:	4620      	mov	r0, r4
    85b0:	f000 fddc 	bl	916c <bt_conn_set_state>
	}

	/* Since we don't give the application a reference to manage in
	 * this case, we need to release this reference here.
	 */
	bt_conn_unref(adv_conn);
    85b4:	4620      	mov	r0, r4
    85b6:	f01d fffe 	bl	265b6 <bt_conn_unref>
}
    85ba:	b002      	add	sp, #8
    85bc:	bd10      	pop	{r4, pc}
    85be:	bf00      	nop
    85c0:	200068ec 	.word	0x200068ec
    85c4:	0002bd96 	.word	0x0002bd96
    85c8:	0002c266 	.word	0x0002c266
    85cc:	0002a5e8 	.word	0x0002a5e8
    85d0:	20006860 	.word	0x20006860

000085d4 <hci_disconn_complete>:
{
    85d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
    85d6:	6886      	ldr	r6, [r0, #8]
	if (evt->status) {
    85d8:	7835      	ldrb	r5, [r6, #0]
    85da:	bb85      	cbnz	r5, 863e <hci_disconn_complete+0x6a>
	u16_t handle = sys_le16_to_cpu(evt->handle);
    85dc:	f8b6 7001 	ldrh.w	r7, [r6, #1]
	conn = bt_conn_lookup_handle(handle);
    85e0:	4638      	mov	r0, r7
    85e2:	f000 fe8d 	bl	9300 <bt_conn_lookup_handle>
	if (!conn) {
    85e6:	4604      	mov	r4, r0
    85e8:	b9c0      	cbnz	r0, 861c <hci_disconn_complete+0x48>
    85ea:	4a15      	ldr	r2, [pc, #84]	; (8640 <hci_disconn_complete+0x6c>)
    85ec:	4b15      	ldr	r3, [pc, #84]	; (8644 <hci_disconn_complete+0x70>)
		BT_ERR("Unable to look up conn with handle %u", handle);
    85ee:	4816      	ldr	r0, [pc, #88]	; (8648 <hci_disconn_complete+0x74>)
    85f0:	1ad2      	subs	r2, r2, r3
    85f2:	08d2      	lsrs	r2, r2, #3
    85f4:	0192      	lsls	r2, r2, #6
    85f6:	f042 0201 	orr.w	r2, r2, #1
    85fa:	4639      	mov	r1, r7
    85fc:	f01b fcef 	bl	23fde <log_1>
    8600:	4812      	ldr	r0, [pc, #72]	; (864c <hci_disconn_complete+0x78>)
    8602:	f01d fe73 	bl	262ec <atomic_get>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    8606:	0582      	lsls	r2, r0, #22
    8608:	d519      	bpl.n	863e <hci_disconn_complete+0x6a>
    860a:	4810      	ldr	r0, [pc, #64]	; (864c <hci_disconn_complete+0x78>)
    860c:	f01d fe6e 	bl	262ec <atomic_get>
	    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    8610:	0683      	lsls	r3, r0, #26
    8612:	d414      	bmi.n	863e <hci_disconn_complete+0x6a>
}
    8614:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_le_adv_resume();
    8618:	f7ff bf9e 	b.w	8558 <bt_le_adv_resume>
	conn->err = evt->reason;
    861c:	78f3      	ldrb	r3, [r6, #3]
    861e:	7243      	strb	r3, [r0, #9]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    8620:	4629      	mov	r1, r5
    8622:	f000 fda3 	bl	916c <bt_conn_set_state>
	if (conn->type != BT_CONN_TYPE_LE) {
    8626:	78a3      	ldrb	r3, [r4, #2]
	conn->handle = 0U;
    8628:	8025      	strh	r5, [r4, #0]
	if (conn->type != BT_CONN_TYPE_LE) {
    862a:	2b01      	cmp	r3, #1
		bt_conn_unref(conn);
    862c:	4620      	mov	r0, r4
	if (conn->type != BT_CONN_TYPE_LE) {
    862e:	d003      	beq.n	8638 <hci_disconn_complete+0x64>
}
    8630:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_conn_unref(conn);
    8634:	f01d bfbf 	b.w	265b6 <bt_conn_unref>
	bt_conn_unref(conn);
    8638:	f01d ffbd 	bl	265b6 <bt_conn_unref>
    863c:	e7e0      	b.n	8600 <hci_disconn_complete+0x2c>
}
    863e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8640:	000298f0 	.word	0x000298f0
    8644:	00029830 	.word	0x00029830
    8648:	0002c2a4 	.word	0x0002c2a4
    864c:	200068ec 	.word	0x200068ec

00008650 <enh_conn_complete>:
{
    8650:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (evt->status) {
    8652:	7801      	ldrb	r1, [r0, #0]
{
    8654:	b085      	sub	sp, #20
    8656:	4605      	mov	r5, r0
	if (evt->status) {
    8658:	b359      	cbz	r1, 86b2 <enh_conn_complete+0x62>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    865a:	293c      	cmp	r1, #60	; 0x3c
    865c:	d11e      	bne.n	869c <enh_conn_complete+0x4c>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    865e:	f06f 0120 	mvn.w	r1, #32
    8662:	4856      	ldr	r0, [pc, #344]	; (87bc <enh_conn_complete+0x16c>)
    8664:	f01d fe65 	bl	26332 <atomic_and>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_SLAVE) {
    8668:	2000      	movs	r0, #0
    866a:	f7fe fa09 	bl	6a80 <find_pending_connect.part.0>
			if (!conn) {
    866e:	4604      	mov	r4, r0
    8670:	b958      	cbnz	r0, 868a <enh_conn_complete+0x3a>
    8672:	4953      	ldr	r1, [pc, #332]	; (87c0 <enh_conn_complete+0x170>)
    8674:	4b53      	ldr	r3, [pc, #332]	; (87c4 <enh_conn_complete+0x174>)
				BT_ERR("No pending slave connection");
    8676:	4854      	ldr	r0, [pc, #336]	; (87c8 <enh_conn_complete+0x178>)
    8678:	1ac9      	subs	r1, r1, r3
    867a:	08c9      	lsrs	r1, r1, #3
    867c:	0189      	lsls	r1, r1, #6
    867e:	f041 0101 	orr.w	r1, r1, #1
    8682:	f01b fc9f 	bl	23fc4 <log_0>
}
    8686:	b005      	add	sp, #20
    8688:	bdf0      	pop	{r4, r5, r6, r7, pc}
			conn->err = evt->status;
    868a:	782b      	ldrb	r3, [r5, #0]
    868c:	7243      	strb	r3, [r0, #9]
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    868e:	2100      	movs	r1, #0
    8690:	f000 fd6c 	bl	916c <bt_conn_set_state>
	bt_conn_unref(conn);
    8694:	4620      	mov	r0, r4
    8696:	f01d ff8e 	bl	265b6 <bt_conn_unref>
	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
    869a:	e7f4      	b.n	8686 <enh_conn_complete+0x36>
    869c:	4b49      	ldr	r3, [pc, #292]	; (87c4 <enh_conn_complete+0x174>)
    869e:	4a48      	ldr	r2, [pc, #288]	; (87c0 <enh_conn_complete+0x170>)
		BT_WARN("Unexpected status 0x%02x", evt->status);
    86a0:	484a      	ldr	r0, [pc, #296]	; (87cc <enh_conn_complete+0x17c>)
    86a2:	1ad2      	subs	r2, r2, r3
    86a4:	08d2      	lsrs	r2, r2, #3
    86a6:	0192      	lsls	r2, r2, #6
    86a8:	f042 0202 	orr.w	r2, r2, #2
    86ac:	f01b fc97 	bl	23fde <log_1>
		return;
    86b0:	e7e9      	b.n	8686 <enh_conn_complete+0x36>
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    86b2:	7903      	ldrb	r3, [r0, #4]
	u16_t handle = sys_le16_to_cpu(evt->handle);
    86b4:	f8b0 7001 	ldrh.w	r7, [r0, #1]
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    86b8:	3b02      	subs	r3, #2
    86ba:	1d04      	adds	r4, r0, #4
    86bc:	2b01      	cmp	r3, #1
	u16_t handle = sys_le16_to_cpu(evt->handle);
    86be:	b2be      	uxth	r6, r7
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
    86c0:	4621      	mov	r1, r4
    86c2:	a802      	add	r0, sp, #8
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    86c4:	d830      	bhi.n	8728 <enh_conn_complete+0xd8>
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
    86c6:	f01d fe17 	bl	262f8 <bt_addr_le_copy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    86ca:	f89d 3008 	ldrb.w	r3, [sp, #8]
    86ce:	2206      	movs	r2, #6
    86d0:	3b02      	subs	r3, #2
    86d2:	f105 0111 	add.w	r1, r5, #17
    86d6:	f10d 0001 	add.w	r0, sp, #1
    86da:	f88d 3008 	strb.w	r3, [sp, #8]
    86de:	f01d fae3 	bl	25ca8 <memcpy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
    86e2:	2301      	movs	r3, #1
    86e4:	f88d 3000 	strb.w	r3, [sp]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_SLAVE) {
    86e8:	78eb      	ldrb	r3, [r5, #3]
    86ea:	2b01      	cmp	r3, #1
    86ec:	d10c      	bne.n	8708 <enh_conn_complete+0xb8>
    86ee:	a802      	add	r0, sp, #8
    86f0:	f7fe f9c6 	bl	6a80 <find_pending_connect.part.0>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    86f4:	78eb      	ldrb	r3, [r5, #3]
    86f6:	2b01      	cmp	r3, #1
    86f8:	4604      	mov	r4, r0
    86fa:	d104      	bne.n	8706 <enh_conn_complete+0xb6>
    86fc:	482f      	ldr	r0, [pc, #188]	; (87bc <enh_conn_complete+0x16c>)
    86fe:	f06f 0120 	mvn.w	r1, #32
    8702:	f01d fe16 	bl	26332 <atomic_and>
	if (!conn) {
    8706:	b9b4      	cbnz	r4, 8736 <enh_conn_complete+0xe6>
    8708:	4b2e      	ldr	r3, [pc, #184]	; (87c4 <enh_conn_complete+0x174>)
    870a:	4a2d      	ldr	r2, [pc, #180]	; (87c0 <enh_conn_complete+0x170>)
		BT_ERR("Unable to add new conn for handle %u", handle);
    870c:	4830      	ldr	r0, [pc, #192]	; (87d0 <enh_conn_complete+0x180>)
    870e:	1ad2      	subs	r2, r2, r3
    8710:	08d2      	lsrs	r2, r2, #3
    8712:	0192      	lsls	r2, r2, #6
    8714:	4631      	mov	r1, r6
    8716:	f042 0201 	orr.w	r2, r2, #1
    871a:	f01b fc60 	bl	23fde <log_1>
		bt_hci_disconnect(handle, BT_HCI_ERR_MEM_CAPACITY_EXCEEDED);
    871e:	2107      	movs	r1, #7
    8720:	4630      	mov	r0, r6
    8722:	f01d fe38 	bl	26396 <bt_hci_disconnect>
		return;
    8726:	e7ae      	b.n	8686 <enh_conn_complete+0x36>
		bt_addr_le_copy(&id_addr,
    8728:	f01d fde6 	bl	262f8 <bt_addr_le_copy>
		bt_addr_le_copy(&peer_addr, &evt->peer_addr);
    872c:	4621      	mov	r1, r4
    872e:	4668      	mov	r0, sp
    8730:	f01d fde2 	bl	262f8 <bt_addr_le_copy>
    8734:	e7d8      	b.n	86e8 <enh_conn_complete+0x98>
	conn->handle = handle;
    8736:	4620      	mov	r0, r4
	bt_addr_le_copy(&conn->le.dst, &id_addr);
    8738:	a902      	add	r1, sp, #8
	conn->handle = handle;
    873a:	f820 7b74 	strh.w	r7, [r0], #116
	bt_addr_le_copy(&conn->le.dst, &id_addr);
    873e:	f01d fddb 	bl	262f8 <bt_addr_le_copy>
	conn->le.interval = sys_le16_to_cpu(evt->interval);
    8742:	7e2a      	ldrb	r2, [r5, #24]
    8744:	7deb      	ldrb	r3, [r5, #23]
    8746:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    874a:	f8a4 308a 	strh.w	r3, [r4, #138]	; 0x8a
	conn->le.latency = sys_le16_to_cpu(evt->latency);
    874e:	7eaa      	ldrb	r2, [r5, #26]
    8750:	7e6b      	ldrb	r3, [r5, #25]
    8752:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    8756:	f8a4 3090 	strh.w	r3, [r4, #144]	; 0x90
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    875a:	7eeb      	ldrb	r3, [r5, #27]
    875c:	7f2a      	ldrb	r2, [r5, #28]
    875e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    8762:	f8a4 3092 	strh.w	r3, [r4, #146]	; 0x92
	conn->role = evt->role;
    8766:	78eb      	ldrb	r3, [r5, #3]
    8768:	70e3      	strb	r3, [r4, #3]
	conn->err = 0U;
    876a:	2600      	movs	r6, #0
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    876c:	2b01      	cmp	r3, #1
	conn->err = 0U;
    876e:	7266      	strb	r6, [r4, #9]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    8770:	d11c      	bne.n	87ac <enh_conn_complete+0x15c>
		bt_addr_le_copy(&conn->le.init_addr, &peer_addr);
    8772:	4669      	mov	r1, sp
    8774:	f104 007b 	add.w	r0, r4, #123	; 0x7b
    8778:	f01d fdbe 	bl	262f8 <bt_addr_le_copy>
					&bt_dev.id_addr[conn->id]);
    877c:	7a21      	ldrb	r1, [r4, #8]
    877e:	4d15      	ldr	r5, [pc, #84]	; (87d4 <enh_conn_complete+0x184>)
    8780:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
			bt_addr_le_copy(&conn->le.resp_addr,
    8784:	4429      	add	r1, r5
    8786:	f104 0082 	add.w	r0, r4, #130	; 0x82
    878a:	f01d fdb5 	bl	262f8 <bt_addr_le_copy>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    878e:	f105 008c 	add.w	r0, r5, #140	; 0x8c
    8792:	f01d fdab 	bl	262ec <atomic_get>
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    8796:	0583      	lsls	r3, r0, #22
    8798:	d508      	bpl.n	87ac <enh_conn_complete+0x15c>
		    BT_LE_STATES_SLAVE_CONN_ADV(bt_dev.le.states)) {
    879a:	f8d5 109c 	ldr.w	r1, [r5, #156]	; 0x9c
    879e:	4632      	mov	r2, r6
    87a0:	f001 0340 	and.w	r3, r1, #64	; 0x40
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    87a4:	4313      	orrs	r3, r2
    87a6:	d001      	beq.n	87ac <enh_conn_complete+0x15c>
			bt_le_adv_resume();
    87a8:	f7ff fed6 	bl	8558 <bt_le_adv_resume>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
    87ac:	4620      	mov	r0, r4
    87ae:	2106      	movs	r1, #6
    87b0:	f000 fcdc 	bl	916c <bt_conn_set_state>
	conn_auto_initiate(conn);
    87b4:	4620      	mov	r0, r4
    87b6:	f7fe fd17 	bl	71e8 <conn_auto_initiate>
    87ba:	e76b      	b.n	8694 <enh_conn_complete+0x44>
    87bc:	200068ec 	.word	0x200068ec
    87c0:	000298f0 	.word	0x000298f0
    87c4:	00029830 	.word	0x00029830
    87c8:	0002c2ca 	.word	0x0002c2ca
    87cc:	0002c2e6 	.word	0x0002c2e6
    87d0:	0002c2ff 	.word	0x0002c2ff
    87d4:	20006860 	.word	0x20006860

000087d8 <bt_le_scan_start>:

	return true;
}

int bt_le_scan_start(const struct bt_le_scan_param *param, bt_le_scan_cb_t cb)
{
    87d8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    87dc:	4605      	mov	r5, r0
    87de:	4852      	ldr	r0, [pc, #328]	; (8928 <bt_le_scan_start+0x150>)
    87e0:	460e      	mov	r6, r1
    87e2:	f01d fd83 	bl	262ec <atomic_get>
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    87e6:	0780      	lsls	r0, r0, #30
    87e8:	f140 8091 	bpl.w	890e <bt_le_scan_start+0x136>
	if (param->type != BT_HCI_LE_SCAN_PASSIVE &&
    87ec:	782a      	ldrb	r2, [r5, #0]
    87ee:	2a01      	cmp	r2, #1
    87f0:	f200 8090 	bhi.w	8914 <bt_le_scan_start+0x13c>
	if (param->options & ~(BT_LE_SCAN_OPT_FILTER_DUPLICATE |
    87f4:	686b      	ldr	r3, [r5, #4]
    87f6:	f033 030f 	bics.w	r3, r3, #15
    87fa:	f040 808b 	bne.w	8914 <bt_le_scan_start+0x13c>
	if (param->interval < 0x0004 || param->interval > 0x4000) {
    87fe:	8928      	ldrh	r0, [r5, #8]
    8800:	1f03      	subs	r3, r0, #4
    8802:	b29b      	uxth	r3, r3
    8804:	f643 74fc 	movw	r4, #16380	; 0x3ffc
    8808:	42a3      	cmp	r3, r4
    880a:	f200 8083 	bhi.w	8914 <bt_le_scan_start+0x13c>
	if (param->window < 0x0004 || param->window > 0x4000) {
    880e:	8969      	ldrh	r1, [r5, #10]
    8810:	1f0b      	subs	r3, r1, #4
    8812:	b29b      	uxth	r3, r3
    8814:	42a3      	cmp	r3, r4
    8816:	d87d      	bhi.n	8914 <bt_le_scan_start+0x13c>
	if (param->window > param->interval) {
    8818:	4288      	cmp	r0, r1
    881a:	d37b      	bcc.n	8914 <bt_le_scan_start+0x13c>
	/* Check that the parameters have valid values */
	if (!valid_le_scan_param(param)) {
		return -EINVAL;
	}

	if (param->type && !bt_le_scan_random_addr_check()) {
    881c:	b112      	cbz	r2, 8824 <bt_le_scan_start+0x4c>
    881e:	4842      	ldr	r0, [pc, #264]	; (8928 <bt_le_scan_start+0x150>)
    8820:	f01d fd64 	bl	262ec <atomic_get>
		return -EINVAL;
	}

	/* Return if active scan is already enabled */
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    8824:	4840      	ldr	r0, [pc, #256]	; (8928 <bt_le_scan_start+0x150>)
    8826:	210b      	movs	r1, #11
    8828:	f01d fd78 	bl	2631c <atomic_test_and_set_bit>
    882c:	4603      	mov	r3, r0
    882e:	2800      	cmp	r0, #0
    8830:	d173      	bne.n	891a <bt_le_scan_start+0x142>
    8832:	483d      	ldr	r0, [pc, #244]	; (8928 <bt_le_scan_start+0x150>)
    8834:	f01d fd5a 	bl	262ec <atomic_get>
		return -EALREADY;
	}

	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    8838:	0541      	lsls	r1, r0, #21
    883a:	d50a      	bpl.n	8852 <bt_le_scan_start+0x7a>
	return set_le_scan_enable_legacy(enable);
    883c:	4618      	mov	r0, r3
    883e:	f7fe fda1 	bl	7384 <set_le_scan_enable_legacy>
		err = set_le_scan_enable(BT_HCI_LE_SCAN_DISABLE);
		if (err) {
    8842:	4604      	mov	r4, r0
    8844:	b128      	cbz	r0, 8852 <bt_le_scan_start+0x7a>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    8846:	f46f 6100 	mvn.w	r1, #2048	; 0x800
    884a:	4837      	ldr	r0, [pc, #220]	; (8928 <bt_le_scan_start+0x150>)
    884c:	f01d fd71 	bl	26332 <atomic_and>
					   param->window);
	}

	if (err) {
		atomic_clear_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN);
		return err;
    8850:	e056      	b.n	8900 <bt_le_scan_start+0x128>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_SCAN_FILTER_DUP,
    8852:	686a      	ldr	r2, [r5, #4]
    8854:	4f35      	ldr	r7, [pc, #212]	; (892c <bt_le_scan_start+0x154>)
    8856:	f002 0201 	and.w	r2, r2, #1
    885a:	210d      	movs	r1, #13
    885c:	f107 008c 	add.w	r0, r7, #140	; 0x8c
    8860:	f01d fd76 	bl	26350 <atomic_set_bit_to>
		if (param->timeout) {
    8864:	89ac      	ldrh	r4, [r5, #12]
    8866:	2c00      	cmp	r4, #0
    8868:	d15a      	bne.n	8920 <bt_le_scan_start+0x148>
		err = start_le_scan_legacy(param->type, param->interval,
    886a:	f895 8000 	ldrb.w	r8, [r5]
    886e:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    8872:	896d      	ldrh	r5, [r5, #10]
	(void)memset(&set_param, 0, sizeof(set_param));
    8874:	2207      	movs	r2, #7
    8876:	4621      	mov	r1, r4
    8878:	4668      	mov	r0, sp
    887a:	f01d fa40 	bl	25cfe <memset>
	active_scan = scan_type == BT_HCI_LE_SCAN_ACTIVE;
    887e:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
		*own_addr_type = bt_dev.id_addr[0].type;
    8882:	4638      	mov	r0, r7
	set_param.scan_type = scan_type;
    8884:	f88d 8000 	strb.w	r8, [sp]
	active_scan = scan_type == BT_HCI_LE_SCAN_ACTIVE;
    8888:	f1d3 0800 	rsbs	r8, r3, #0
    888c:	eb48 0803 	adc.w	r8, r8, r3
		*own_addr_type = bt_dev.id_addr[0].type;
    8890:	f810 3b8c 	ldrb.w	r3, [r0], #140
	set_param.interval = sys_cpu_to_le16(interval);
    8894:	f8ad 9001 	strh.w	r9, [sp, #1]
	set_param.window = sys_cpu_to_le16(window);
    8898:	f8ad 5003 	strh.w	r5, [sp, #3]
		set_param.filter_policy = BT_HCI_LE_SCAN_FP_NO_WHITELIST;
    889c:	f88d 4006 	strb.w	r4, [sp, #6]
		*own_addr_type = bt_dev.id_addr[0].type;
    88a0:	f88d 3005 	strb.w	r3, [sp, #5]
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    88a4:	f01d fd22 	bl	262ec <atomic_get>
		if (!IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) &&
    88a8:	0682      	lsls	r2, r0, #26
    88aa:	d407      	bmi.n	88bc <bt_le_scan_start+0xe4>
			err = le_set_private_addr(BT_ID_DEFAULT);
    88ac:	f01d fd61 	bl	26372 <le_adv_set_private_addr.isra.0>
			if (err) {
    88b0:	4604      	mov	r4, r0
    88b2:	2800      	cmp	r0, #0
    88b4:	d1c7      	bne.n	8846 <bt_le_scan_start+0x6e>
			*own_addr_type = BT_ADDR_LE_RANDOM;
    88b6:	2301      	movs	r3, #1
    88b8:	f88d 3005 	strb.w	r3, [sp, #5]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_PARAM, sizeof(set_param));
    88bc:	2107      	movs	r1, #7
    88be:	f242 000b 	movw	r0, #8203	; 0x200b
    88c2:	f7fe fb85 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    88c6:	4604      	mov	r4, r0
    88c8:	b1f0      	cbz	r0, 8908 <bt_le_scan_start+0x130>
	net_buf_add_mem(buf, &set_param, sizeof(set_param));
    88ca:	2207      	movs	r2, #7
    88cc:	4669      	mov	r1, sp
    88ce:	3008      	adds	r0, #8
    88d0:	f020 fa71 	bl	28db6 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_PARAM, buf, NULL);
    88d4:	4621      	mov	r1, r4
    88d6:	2200      	movs	r2, #0
    88d8:	f242 000b 	movw	r0, #8203	; 0x200b
    88dc:	f7fe fcf0 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    88e0:	4604      	mov	r4, r0
    88e2:	2800      	cmp	r0, #0
    88e4:	d1af      	bne.n	8846 <bt_le_scan_start+0x6e>
	return set_le_scan_enable_legacy(enable);
    88e6:	2001      	movs	r0, #1
    88e8:	f7fe fd4c 	bl	7384 <set_le_scan_enable_legacy>
	if (err) {
    88ec:	4604      	mov	r4, r0
    88ee:	2800      	cmp	r0, #0
    88f0:	d1a9      	bne.n	8846 <bt_le_scan_start+0x6e>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ACTIVE_SCAN, active_scan);
    88f2:	480d      	ldr	r0, [pc, #52]	; (8928 <bt_le_scan_start+0x150>)
    88f4:	4642      	mov	r2, r8
    88f6:	210c      	movs	r1, #12
    88f8:	f01d fd2a 	bl	26350 <atomic_set_bit_to>
	}

	scan_dev_found_cb = cb;
    88fc:	4b0c      	ldr	r3, [pc, #48]	; (8930 <bt_le_scan_start+0x158>)
    88fe:	601e      	str	r6, [r3, #0]

	return 0;
}
    8900:	4620      	mov	r0, r4
    8902:	b003      	add	sp, #12
    8904:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return -ENOBUFS;
    8908:	f06f 0436 	mvn.w	r4, #54	; 0x36
    890c:	e79b      	b.n	8846 <bt_le_scan_start+0x6e>
		return -EAGAIN;
    890e:	f06f 040a 	mvn.w	r4, #10
    8912:	e7f5      	b.n	8900 <bt_le_scan_start+0x128>
		return -EINVAL;
    8914:	f06f 0415 	mvn.w	r4, #21
    8918:	e7f2      	b.n	8900 <bt_le_scan_start+0x128>
		return -EALREADY;
    891a:	f06f 0444 	mvn.w	r4, #68	; 0x44
    891e:	e7ef      	b.n	8900 <bt_le_scan_start+0x128>
			return -ENOTSUP;
    8920:	f06f 0422 	mvn.w	r4, #34	; 0x22
    8924:	e7ec      	b.n	8900 <bt_le_scan_start+0x128>
    8926:	bf00      	nop
    8928:	200068ec 	.word	0x200068ec
    892c:	20006860 	.word	0x20006860
    8930:	20000484 	.word	0x20000484

00008934 <bt_le_scan_stop>:

int bt_le_scan_stop(void)
{
    8934:	b508      	push	{r3, lr}
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    8936:	4808      	ldr	r0, [pc, #32]	; (8958 <bt_le_scan_stop+0x24>)
    8938:	f46f 6100 	mvn.w	r1, #2048	; 0x800
    893c:	f01d fcf9 	bl	26332 <atomic_and>
	/* Return if active scanning is already disabled */
	if (!atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    8940:	0503      	lsls	r3, r0, #20
    8942:	d506      	bpl.n	8952 <bt_le_scan_stop+0x1e>
		return -EALREADY;
	}

	scan_dev_found_cb = NULL;
    8944:	4b05      	ldr	r3, [pc, #20]	; (895c <bt_le_scan_stop+0x28>)
    8946:	2000      	movs	r0, #0
    8948:	6018      	str	r0, [r3, #0]
		pending_id_keys_update();
#endif
	}

	return bt_le_scan_update(false);
}
    894a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return bt_le_scan_update(false);
    894e:	f7fe be6d 	b.w	762c <bt_le_scan_update>
}
    8952:	f06f 0044 	mvn.w	r0, #68	; 0x44
    8956:	bd08      	pop	{r3, pc}
    8958:	200068ec 	.word	0x200068ec
    895c:	20000484 	.word	0x20000484

00008960 <bt_buf_get_rx>:
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF,
				    buf, NULL);
}

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, s32_t timeout)
{
    8960:	b538      	push	{r3, r4, r5, lr}
	struct net_buf *buf;

	__ASSERT(type == BT_BUF_EVT || type == BT_BUF_ACL_IN,
    8962:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    8966:	2b01      	cmp	r3, #1
{
    8968:	4605      	mov	r5, r0
    896a:	460c      	mov	r4, r1
	__ASSERT(type == BT_BUF_EVT || type == BT_BUF_ACL_IN,
    896c:	d00e      	beq.n	898c <bt_buf_get_rx+0x2c>
    896e:	490e      	ldr	r1, [pc, #56]	; (89a8 <bt_buf_get_rx+0x48>)
    8970:	4a0e      	ldr	r2, [pc, #56]	; (89ac <bt_buf_get_rx+0x4c>)
    8972:	480f      	ldr	r0, [pc, #60]	; (89b0 <bt_buf_get_rx+0x50>)
    8974:	f641 739c 	movw	r3, #8092	; 0x1f9c
    8978:	f01b fab3 	bl	23ee2 <printk>
    897c:	480d      	ldr	r0, [pc, #52]	; (89b4 <bt_buf_get_rx+0x54>)
    897e:	f01b fab0 	bl	23ee2 <printk>
    8982:	480a      	ldr	r0, [pc, #40]	; (89ac <bt_buf_get_rx+0x4c>)
    8984:	f641 719c 	movw	r1, #8092	; 0x1f9c
    8988:	f01b faee 	bl	23f68 <assert_post_action>
		buf = net_buf_alloc(&hci_rx_pool, timeout);
	} else {
		buf = net_buf_alloc(&acl_in_pool, timeout);
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
    898c:	4621      	mov	r1, r4
    898e:	480a      	ldr	r0, [pc, #40]	; (89b8 <bt_buf_get_rx+0x58>)
    8990:	f020 f9b3 	bl	28cfa <net_buf_alloc_fixed>
#endif

	if (buf) {
    8994:	4604      	mov	r4, r0
    8996:	b120      	cbz	r0, 89a2 <bt_buf_get_rx+0x42>
		net_buf_reserve(buf, BT_BUF_RESERVE);
    8998:	2100      	movs	r1, #0
    899a:	3008      	adds	r0, #8
    899c:	f016 fa90 	bl	1eec0 <net_buf_simple_reserve>
	*(u8_t *)net_buf_user_data(buf) = type;
    89a0:	7525      	strb	r5, [r4, #20]
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    89a2:	4620      	mov	r0, r4
    89a4:	bd38      	pop	{r3, r4, r5, pc}
    89a6:	bf00      	nop
    89a8:	0002c324 	.word	0x0002c324
    89ac:	0002bd96 	.word	0x0002bd96
    89b0:	0002a5e8 	.word	0x0002a5e8
    89b4:	0002c350 	.word	0x0002c350
    89b8:	2000776c 	.word	0x2000776c

000089bc <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(s32_t timeout)
{
    89bc:	b510      	push	{r4, lr}
	__asm__ volatile(
    89be:	f04f 0320 	mov.w	r3, #32
    89c2:	f3ef 8211 	mrs	r2, BASEPRI
    89c6:	f383 8811 	msr	BASEPRI, r3
    89ca:	f3bf 8f6f 	isb	sy
	struct net_buf *buf;
	unsigned int key;

	key = irq_lock();
	buf = bt_dev.sent_cmd;
    89ce:	4b0d      	ldr	r3, [pc, #52]	; (8a04 <bt_buf_get_cmd_complete+0x48>)
	bt_dev.sent_cmd = NULL;
    89d0:	2100      	movs	r1, #0
	buf = bt_dev.sent_cmd;
    89d2:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
	bt_dev.sent_cmd = NULL;
    89d6:	f8c3 10d8 	str.w	r1, [r3, #216]	; 0xd8
	__asm__ volatile(
    89da:	f382 8811 	msr	BASEPRI, r2
    89de:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	BT_DBG("sent_cmd %p", buf);

	if (buf) {
    89e2:	b92c      	cbnz	r4, 89f0 <bt_buf_get_cmd_complete+0x34>
		net_buf_reserve(buf, BT_BUF_RESERVE);

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    89e4:	4601      	mov	r1, r0
}
    89e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    89ea:	2001      	movs	r0, #1
    89ec:	f7ff bfb8 	b.w	8960 <bt_buf_get_rx>
    89f0:	2301      	movs	r3, #1
		net_buf_reserve(buf, BT_BUF_RESERVE);
    89f2:	f104 0008 	add.w	r0, r4, #8
    89f6:	7523      	strb	r3, [r4, #20]
		buf->len = 0U;
    89f8:	81a1      	strh	r1, [r4, #12]
		net_buf_reserve(buf, BT_BUF_RESERVE);
    89fa:	f016 fa61 	bl	1eec0 <net_buf_simple_reserve>
}
    89fe:	4620      	mov	r0, r4
    8a00:	bd10      	pop	{r4, pc}
    8a02:	bf00      	nop
    8a04:	20006860 	.word	0x20006860

00008a08 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(u8_t evt, bool discardable, s32_t timeout)
{
	switch (evt) {
    8a08:	280f      	cmp	r0, #15
{
    8a0a:	460b      	mov	r3, r1
    8a0c:	b510      	push	{r4, lr}
    8a0e:	4611      	mov	r1, r2
	switch (evt) {
    8a10:	d806      	bhi.n	8a20 <bt_buf_get_evt+0x18>
    8a12:	280d      	cmp	r0, #13
    8a14:	d913      	bls.n	8a3e <bt_buf_get_evt+0x36>
		}
#endif /* CONFIG_BT_DISCARDABLE_BUF_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
    8a16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_cmd_complete(timeout);
    8a1a:	4610      	mov	r0, r2
    8a1c:	f7ff bfce 	b.w	89bc <bt_buf_get_cmd_complete>
	switch (evt) {
    8a20:	2813      	cmp	r0, #19
    8a22:	d10c      	bne.n	8a3e <bt_buf_get_evt+0x36>
			buf = net_buf_alloc(&num_complete_pool, timeout);
    8a24:	480a      	ldr	r0, [pc, #40]	; (8a50 <bt_buf_get_evt+0x48>)
			buf = net_buf_alloc(&discardable_pool, timeout);
    8a26:	f020 f968 	bl	28cfa <net_buf_alloc_fixed>
			if (buf) {
    8a2a:	4604      	mov	r4, r0
    8a2c:	b128      	cbz	r0, 8a3a <bt_buf_get_evt+0x32>
				net_buf_reserve(buf, BT_BUF_RESERVE);
    8a2e:	2100      	movs	r1, #0
    8a30:	3008      	adds	r0, #8
    8a32:	f016 fa45 	bl	1eec0 <net_buf_simple_reserve>
    8a36:	2301      	movs	r3, #1
    8a38:	7523      	strb	r3, [r4, #20]
}
    8a3a:	4620      	mov	r0, r4
    8a3c:	bd10      	pop	{r4, pc}
		if (discardable) {
    8a3e:	b10b      	cbz	r3, 8a44 <bt_buf_get_evt+0x3c>
			buf = net_buf_alloc(&discardable_pool, timeout);
    8a40:	4804      	ldr	r0, [pc, #16]	; (8a54 <bt_buf_get_evt+0x4c>)
    8a42:	e7f0      	b.n	8a26 <bt_buf_get_evt+0x1e>
}
    8a44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    8a48:	2001      	movs	r0, #1
    8a4a:	f7ff bf89 	b.w	8960 <bt_buf_get_rx>
    8a4e:	bf00      	nop
    8a50:	20007790 	.word	0x20007790
    8a54:	200076dc 	.word	0x200076dc

00008a58 <bt_pub_key_gen>:
}
#endif /* CONFIG_BT_BREDR */

#if defined(CONFIG_BT_ECC)
int bt_pub_key_gen(struct bt_pub_key_cb *new_cb)
{
    8a58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	 * We check for both "LE Read Local P-256 Public Key" and
	 * "LE Generate DH Key" support here since both commands are needed for
	 * ECC support. If "LE Generate DH Key" is not supported then there
	 * is no point in reading local public key.
	 */
	if (!BT_CMD_TEST(bt_dev.supported_commands, 34, 1) ||
    8a5a:	4d21      	ldr	r5, [pc, #132]	; (8ae0 <bt_pub_key_gen+0x88>)
    8a5c:	f895 305e 	ldrb.w	r3, [r5, #94]	; 0x5e
    8a60:	f003 0306 	and.w	r3, r3, #6
    8a64:	2b06      	cmp	r3, #6
    8a66:	d00d      	beq.n	8a84 <bt_pub_key_gen+0x2c>
    8a68:	4b1e      	ldr	r3, [pc, #120]	; (8ae4 <bt_pub_key_gen+0x8c>)
    8a6a:	491f      	ldr	r1, [pc, #124]	; (8ae8 <bt_pub_key_gen+0x90>)
	    !BT_CMD_TEST(bt_dev.supported_commands, 34, 2)) {
		BT_WARN("ECC HCI commands not available");
    8a6c:	481f      	ldr	r0, [pc, #124]	; (8aec <bt_pub_key_gen+0x94>)
    8a6e:	1ac9      	subs	r1, r1, r3
    8a70:	08c9      	lsrs	r1, r1, #3
    8a72:	0189      	lsls	r1, r1, #6
    8a74:	f041 0102 	orr.w	r1, r1, #2
    8a78:	f01b faa4 	bl	23fc4 <log_0>
		return -ENOTSUP;
    8a7c:	f06f 0422 	mvn.w	r4, #34	; 0x22
		pub_key_cb = NULL;
		return err;
	}

	return 0;
}
    8a80:	4620      	mov	r0, r4
    8a82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	new_cb->_next = pub_key_cb;
    8a84:	4e1a      	ldr	r6, [pc, #104]	; (8af0 <bt_pub_key_gen+0x98>)
    8a86:	6833      	ldr	r3, [r6, #0]
    8a88:	6043      	str	r3, [r0, #4]
	pub_key_cb = new_cb;
    8a8a:	6030      	str	r0, [r6, #0]
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    8a8c:	2104      	movs	r1, #4
    8a8e:	f105 008c 	add.w	r0, r5, #140	; 0x8c
    8a92:	f01d fc43 	bl	2631c <atomic_test_and_set_bit>
    8a96:	4607      	mov	r7, r0
    8a98:	bb00      	cbnz	r0, 8adc <bt_pub_key_gen+0x84>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    8a9a:	f06f 0108 	mvn.w	r1, #8
    8a9e:	f105 008c 	add.w	r0, r5, #140	; 0x8c
    8aa2:	f01d fc46 	bl	26332 <atomic_and>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
    8aa6:	463a      	mov	r2, r7
    8aa8:	4639      	mov	r1, r7
    8aaa:	f242 0025 	movw	r0, #8229	; 0x2025
    8aae:	f7fe fc07 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    8ab2:	4604      	mov	r4, r0
    8ab4:	2800      	cmp	r0, #0
    8ab6:	d0e3      	beq.n	8a80 <bt_pub_key_gen+0x28>
    8ab8:	4b0a      	ldr	r3, [pc, #40]	; (8ae4 <bt_pub_key_gen+0x8c>)
    8aba:	490b      	ldr	r1, [pc, #44]	; (8ae8 <bt_pub_key_gen+0x90>)
		BT_ERR("Sending LE P256 Public Key command failed");
    8abc:	480d      	ldr	r0, [pc, #52]	; (8af4 <bt_pub_key_gen+0x9c>)
    8abe:	1ac9      	subs	r1, r1, r3
    8ac0:	08c9      	lsrs	r1, r1, #3
    8ac2:	0189      	lsls	r1, r1, #6
    8ac4:	f041 0101 	orr.w	r1, r1, #1
    8ac8:	f01b fa7c 	bl	23fc4 <log_0>
    8acc:	f06f 0110 	mvn.w	r1, #16
    8ad0:	f105 008c 	add.w	r0, r5, #140	; 0x8c
    8ad4:	f01d fc2d 	bl	26332 <atomic_and>
		pub_key_cb = NULL;
    8ad8:	6037      	str	r7, [r6, #0]
		return err;
    8ada:	e7d1      	b.n	8a80 <bt_pub_key_gen+0x28>
		return 0;
    8adc:	2400      	movs	r4, #0
    8ade:	e7cf      	b.n	8a80 <bt_pub_key_gen+0x28>
    8ae0:	20006860 	.word	0x20006860
    8ae4:	00029830 	.word	0x00029830
    8ae8:	000298f0 	.word	0x000298f0
    8aec:	0002c370 	.word	0x0002c370
    8af0:	20000474 	.word	0x20000474
    8af4:	0002c38f 	.word	0x0002c38f

00008af8 <bt_pub_key_get>:

const u8_t *bt_pub_key_get(void)
{
    8af8:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    8afa:	4804      	ldr	r0, [pc, #16]	; (8b0c <bt_pub_key_get+0x14>)
    8afc:	f01d fbf6 	bl	262ec <atomic_get>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
    8b00:	f010 0f08 	tst.w	r0, #8
		return pub_key;
	}

	return NULL;
}
    8b04:	4802      	ldr	r0, [pc, #8]	; (8b10 <bt_pub_key_get+0x18>)
    8b06:	bf08      	it	eq
    8b08:	2000      	moveq	r0, #0
    8b0a:	bd08      	pop	{r3, pc}
    8b0c:	200068ec 	.word	0x200068ec
    8b10:	2000247b 	.word	0x2000247b

00008b14 <bt_dh_key_gen>:

int bt_dh_key_gen(const u8_t remote_pk[64], bt_dh_key_cb_t cb)
{
    8b14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_cp_le_generate_dhkey *cp;
	struct net_buf *buf;
	int err;

	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    8b16:	4d1a      	ldr	r5, [pc, #104]	; (8b80 <bt_dh_key_gen+0x6c>)
    8b18:	682b      	ldr	r3, [r5, #0]
{
    8b1a:	4606      	mov	r6, r0
	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    8b1c:	b113      	cbz	r3, 8b24 <bt_dh_key_gen+0x10>
		return -EBUSY;
    8b1e:	f06f 000f 	mvn.w	r0, #15
		dh_key_cb = NULL;
		return err;
	}

	return 0;
}
    8b22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8b24:	4817      	ldr	r0, [pc, #92]	; (8b84 <bt_dh_key_gen+0x70>)
    8b26:	f01d fbe1 	bl	262ec <atomic_get>
	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    8b2a:	06c2      	lsls	r2, r0, #27
    8b2c:	f3c0 1700 	ubfx	r7, r0, #4, #1
    8b30:	d4f5      	bmi.n	8b1e <bt_dh_key_gen+0xa>
    8b32:	4814      	ldr	r0, [pc, #80]	; (8b84 <bt_dh_key_gen+0x70>)
    8b34:	f01d fbda 	bl	262ec <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
    8b38:	0703      	lsls	r3, r0, #28
    8b3a:	d51d      	bpl.n	8b78 <bt_dh_key_gen+0x64>
	dh_key_cb = cb;
    8b3c:	6029      	str	r1, [r5, #0]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_GENERATE_DHKEY, sizeof(*cp));
    8b3e:	f242 0026 	movw	r0, #8230	; 0x2026
    8b42:	2140      	movs	r1, #64	; 0x40
    8b44:	f7fe fa44 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
    8b48:	4604      	mov	r4, r0
    8b4a:	b918      	cbnz	r0, 8b54 <bt_dh_key_gen+0x40>
		dh_key_cb = NULL;
    8b4c:	6028      	str	r0, [r5, #0]
		return -ENOBUFS;
    8b4e:	f06f 0036 	mvn.w	r0, #54	; 0x36
    8b52:	e7e6      	b.n	8b22 <bt_dh_key_gen+0xe>
	cp = net_buf_add(buf, sizeof(*cp));
    8b54:	2140      	movs	r1, #64	; 0x40
    8b56:	3008      	adds	r0, #8
    8b58:	f016 fbbe 	bl	1f2d8 <net_buf_simple_add>
	memcpy(cp->key, remote_pk, sizeof(cp->key));
    8b5c:	2240      	movs	r2, #64	; 0x40
    8b5e:	4631      	mov	r1, r6
    8b60:	f01d f8a2 	bl	25ca8 <memcpy>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY, buf, NULL);
    8b64:	463a      	mov	r2, r7
    8b66:	4621      	mov	r1, r4
    8b68:	f242 0026 	movw	r0, #8230	; 0x2026
    8b6c:	f7fe fba8 	bl	72c0 <bt_hci_cmd_send_sync>
	if (err) {
    8b70:	2800      	cmp	r0, #0
    8b72:	d0d6      	beq.n	8b22 <bt_dh_key_gen+0xe>
		dh_key_cb = NULL;
    8b74:	602f      	str	r7, [r5, #0]
		return err;
    8b76:	e7d4      	b.n	8b22 <bt_dh_key_gen+0xe>
		return -EADDRNOTAVAIL;
    8b78:	f06f 0030 	mvn.w	r0, #48	; 0x30
    8b7c:	e7d1      	b.n	8b22 <bt_dh_key_gen+0xe>
    8b7e:	bf00      	nop
    8b80:	20000470 	.word	0x20000470
    8b84:	200068ec 	.word	0x200068ec

00008b88 <tx_free>:
	return bt_l2cap_update_conn_param(conn, param);
}

static void tx_free(struct bt_conn_tx *tx)
{
	tx->cb = NULL;
    8b88:	2300      	movs	r3, #0
	tx->user_data = NULL;
    8b8a:	e9c0 3301 	strd	r3, r3, [r0, #4]
{
    8b8e:	4601      	mov	r1, r0
	tx->pending_no_cb = 0U;
    8b90:	60c3      	str	r3, [r0, #12]
	k_fifo_put(&free_tx, tx);
    8b92:	4801      	ldr	r0, [pc, #4]	; (8b98 <tx_free+0x10>)
    8b94:	f020 bb5d 	b.w	29252 <k_queue_append>
    8b98:	20007634 	.word	0x20007634

00008b9c <notify_connected>:
{
    8b9c:	b538      	push	{r3, r4, r5, lr}
	for (cb = callback_list; cb; cb = cb->_next) {
    8b9e:	4b09      	ldr	r3, [pc, #36]	; (8bc4 <notify_connected+0x28>)
    8ba0:	681d      	ldr	r5, [r3, #0]
{
    8ba2:	4604      	mov	r4, r0
	for (cb = callback_list; cb; cb = cb->_next) {
    8ba4:	7a61      	ldrb	r1, [r4, #9]
    8ba6:	b92d      	cbnz	r5, 8bb4 <notify_connected+0x18>
	if (!conn->err) {
    8ba8:	b951      	cbnz	r1, 8bc0 <notify_connected+0x24>
		bt_gatt_connected(conn);
    8baa:	4620      	mov	r0, r4
}
    8bac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_gatt_connected(conn);
    8bb0:	f003 b812 	b.w	bbd8 <bt_gatt_connected>
		if (cb->connected) {
    8bb4:	682b      	ldr	r3, [r5, #0]
    8bb6:	b10b      	cbz	r3, 8bbc <notify_connected+0x20>
			cb->connected(conn, conn->err);
    8bb8:	4620      	mov	r0, r4
    8bba:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    8bbc:	692d      	ldr	r5, [r5, #16]
    8bbe:	e7f1      	b.n	8ba4 <notify_connected+0x8>
}
    8bc0:	bd38      	pop	{r3, r4, r5, pc}
    8bc2:	bf00      	nop
    8bc4:	2000051c 	.word	0x2000051c

00008bc8 <send_frag>:
	return 0;
}

static bool send_frag(struct bt_conn *conn, struct net_buf *buf, u8_t flags,
		      bool always_consume)
{
    8bc8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn_tx *tx = tx_data(buf)->tx;
    8bcc:	694d      	ldr	r5, [r1, #20]
{
    8bce:	4604      	mov	r4, r0
    8bd0:	460e      	mov	r6, r1
    8bd2:	4691      	mov	r9, r2
    8bd4:	461f      	mov	r7, r3
	return z_impl_k_sem_take(sem, timeout);
    8bd6:	484b      	ldr	r0, [pc, #300]	; (8d04 <send_frag+0x13c>)
    8bd8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    8bdc:	f019 fdac 	bl	22738 <z_impl_k_sem_take>

	/* Wait until the controller can accept ACL packets */
	k_sem_take(bt_conn_get_pkts(conn), K_FOREVER);

	/* Check for disconnection while waiting for pkts_sem */
	if (conn->state != BT_CONN_CONNECTED) {
    8be0:	7aa3      	ldrb	r3, [r4, #10]
    8be2:	2b06      	cmp	r3, #6
    8be4:	d14e      	bne.n	8c84 <send_frag+0xbc>
		goto fail;
	}

	hdr = net_buf_push(buf, sizeof(*hdr));
    8be6:	2104      	movs	r1, #4
    8be8:	f106 0008 	add.w	r0, r6, #8
    8bec:	f016 fb10 	bl	1f210 <net_buf_simple_push>
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    8bf0:	8822      	ldrh	r2, [r4, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    8bf2:	89b3      	ldrh	r3, [r6, #12]
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    8bf4:	ea42 3209 	orr.w	r2, r2, r9, lsl #12
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    8bf8:	3b04      	subs	r3, #4
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    8bfa:	8002      	strh	r2, [r0, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    8bfc:	8043      	strh	r3, [r0, #2]
	__asm__ volatile(
    8bfe:	f04f 0320 	mov.w	r3, #32
    8c02:	f3ef 8211 	mrs	r2, BASEPRI
    8c06:	f383 8811 	msr	BASEPRI, r3
    8c0a:	f3bf 8f6f 	isb	sy

	/* Add to pending, it must be done before bt_buf_set_type */
	key = irq_lock();
	if (tx) {
    8c0e:	2d00      	cmp	r5, #0
    8c10:	d04a      	beq.n	8ca8 <send_frag+0xe0>
	parent->next = child;
    8c12:	2300      	movs	r3, #0
    8c14:	602b      	str	r3, [r5, #0]
Z_GENLIST_APPEND(slist, snode)
    8c16:	69a3      	ldr	r3, [r4, #24]
    8c18:	2b00      	cmp	r3, #0
    8c1a:	d142      	bne.n	8ca2 <send_frag+0xda>
	list->head = node;
    8c1c:	e9c4 5505 	strd	r5, r5, [r4, #20]
	__asm__ volatile(
    8c20:	f382 8811 	msr	BASEPRI, r2
    8c24:	f3bf 8f6f 	isb	sy
    8c28:	2302      	movs	r3, #2
    8c2a:	7533      	strb	r3, [r6, #20]
	}
	irq_unlock(key);

	bt_buf_set_type(buf, BT_BUF_ACL_OUT);

	err = bt_send(buf);
    8c2c:	4630      	mov	r0, r6
    8c2e:	f01d fbfa 	bl	26426 <bt_send>
	if (err) {
    8c32:	4601      	mov	r1, r0
    8c34:	2800      	cmp	r0, #0
    8c36:	d062      	beq.n	8cfe <send_frag+0x136>
    8c38:	4b33      	ldr	r3, [pc, #204]	; (8d08 <send_frag+0x140>)
    8c3a:	4a34      	ldr	r2, [pc, #208]	; (8d0c <send_frag+0x144>)
		BT_ERR("Unable to send to driver (err %d)", err);
    8c3c:	4834      	ldr	r0, [pc, #208]	; (8d10 <send_frag+0x148>)
    8c3e:	1ad2      	subs	r2, r2, r3
    8c40:	08d2      	lsrs	r2, r2, #3
    8c42:	0192      	lsls	r2, r2, #6
    8c44:	f042 0201 	orr.w	r2, r2, #1
    8c48:	f01b f9c9 	bl	23fde <log_1>
	__asm__ volatile(
    8c4c:	f04f 0320 	mov.w	r3, #32
    8c50:	f3ef 8911 	mrs	r9, BASEPRI
    8c54:	f383 8811 	msr	BASEPRI, r3
    8c58:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		/* Roll back the pending TX info */
		if (tx) {
    8c5c:	2d00      	cmp	r5, #0
    8c5e:	d039      	beq.n	8cd4 <send_frag+0x10c>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    8c60:	6963      	ldr	r3, [r4, #20]
    8c62:	2200      	movs	r2, #0
    8c64:	b153      	cbz	r3, 8c7c <send_frag+0xb4>
    8c66:	429d      	cmp	r5, r3
    8c68:	d131      	bne.n	8cce <send_frag+0x106>
Z_GENLIST_REMOVE(slist, snode)
    8c6a:	682b      	ldr	r3, [r5, #0]
    8c6c:	bb4a      	cbnz	r2, 8cc2 <send_frag+0xfa>
    8c6e:	69a2      	ldr	r2, [r4, #24]
	list->head = node;
    8c70:	6163      	str	r3, [r4, #20]
Z_GENLIST_REMOVE(slist, snode)
    8c72:	4295      	cmp	r5, r2
    8c74:	d100      	bne.n	8c78 <send_frag+0xb0>
	list->tail = node;
    8c76:	61a3      	str	r3, [r4, #24]
	parent->next = child;
    8c78:	2300      	movs	r3, #0
    8c7a:	602b      	str	r3, [r5, #0]
	__asm__ volatile(
    8c7c:	f389 8811 	msr	BASEPRI, r9
    8c80:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
    8c84:	481f      	ldr	r0, [pc, #124]	; (8d04 <send_frag+0x13c>)
    8c86:	f019 fd13 	bl	226b0 <z_impl_k_sem_give>

	return true;

fail:
	k_sem_give(bt_conn_get_pkts(conn));
	if (tx) {
    8c8a:	b115      	cbz	r5, 8c92 <send_frag+0xca>
		tx_free(tx);
    8c8c:	4628      	mov	r0, r5
    8c8e:	f7ff ff7b 	bl	8b88 <tx_free>
	}

	if (always_consume) {
    8c92:	b11f      	cbz	r7, 8c9c <send_frag+0xd4>
		net_buf_unref(buf);
    8c94:	4630      	mov	r0, r6
    8c96:	f016 fa17 	bl	1f0c8 <net_buf_unref>
	}
	return false;
    8c9a:	2700      	movs	r7, #0
}
    8c9c:	4638      	mov	r0, r7
    8c9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8ca2:	601d      	str	r5, [r3, #0]
	list->tail = node;
    8ca4:	61a5      	str	r5, [r4, #24]
}
    8ca6:	e7bb      	b.n	8c20 <send_frag+0x58>
		tail_tx = (void *)sys_slist_peek_tail(&conn->tx_pending);
    8ca8:	69a3      	ldr	r3, [r4, #24]
		if (tail_tx) {
    8caa:	b133      	cbz	r3, 8cba <send_frag+0xf2>
			pending_no_cb = &tail_tx->pending_no_cb;
    8cac:	f103 080c 	add.w	r8, r3, #12
    8cb0:	68db      	ldr	r3, [r3, #12]
		(*pending_no_cb)++;
    8cb2:	3301      	adds	r3, #1
    8cb4:	f8c8 3000 	str.w	r3, [r8]
    8cb8:	e7b2      	b.n	8c20 <send_frag+0x58>
			pending_no_cb = &conn->pending_no_cb;
    8cba:	69e3      	ldr	r3, [r4, #28]
    8cbc:	f104 081c 	add.w	r8, r4, #28
    8cc0:	e7f7      	b.n	8cb2 <send_frag+0xea>
	parent->next = child;
    8cc2:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
    8cc4:	69a3      	ldr	r3, [r4, #24]
    8cc6:	429d      	cmp	r5, r3
	list->tail = node;
    8cc8:	bf08      	it	eq
    8cca:	61a2      	streq	r2, [r4, #24]
}
    8ccc:	e7d4      	b.n	8c78 <send_frag+0xb0>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    8cce:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    8cd0:	681b      	ldr	r3, [r3, #0]
    8cd2:	e7c7      	b.n	8c64 <send_frag+0x9c>
			__ASSERT_NO_MSG(*pending_no_cb > 0);
    8cd4:	f8d8 3000 	ldr.w	r3, [r8]
    8cd8:	b95b      	cbnz	r3, 8cf2 <send_frag+0x12a>
    8cda:	490e      	ldr	r1, [pc, #56]	; (8d14 <send_frag+0x14c>)
    8cdc:	480e      	ldr	r0, [pc, #56]	; (8d18 <send_frag+0x150>)
    8cde:	4a0f      	ldr	r2, [pc, #60]	; (8d1c <send_frag+0x154>)
    8ce0:	f240 536f 	movw	r3, #1391	; 0x56f
    8ce4:	f01b f8fd 	bl	23ee2 <printk>
    8ce8:	480c      	ldr	r0, [pc, #48]	; (8d1c <send_frag+0x154>)
    8cea:	f240 516f 	movw	r1, #1391	; 0x56f
    8cee:	f01b f93b 	bl	23f68 <assert_post_action>
			(*pending_no_cb)--;
    8cf2:	f8d8 3000 	ldr.w	r3, [r8]
    8cf6:	3b01      	subs	r3, #1
    8cf8:	f8c8 3000 	str.w	r3, [r8]
    8cfc:	e7be      	b.n	8c7c <send_frag+0xb4>
	return true;
    8cfe:	2701      	movs	r7, #1
    8d00:	e7cc      	b.n	8c9c <send_frag+0xd4>
    8d02:	bf00      	nop
    8d04:	20006904 	.word	0x20006904
    8d08:	00029830 	.word	0x00029830
    8d0c:	00029840 	.word	0x00029840
    8d10:	0002bdee 	.word	0x0002bdee
    8d14:	0002c3ee 	.word	0x0002c3ee
    8d18:	0002a5e8 	.word	0x0002a5e8
    8d1c:	0002c3be 	.word	0x0002c3be

00008d20 <conn_cleanup>:

static struct k_poll_signal conn_change =
		K_POLL_SIGNAL_INITIALIZER(conn_change);

static void conn_cleanup(struct bt_conn *conn)
{
    8d20:	b570      	push	{r4, r5, r6, lr}
    8d22:	4604      	mov	r4, r0
	struct net_buf *buf;

	/* Give back any allocated buffers */
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
    8d24:	f100 0634 	add.w	r6, r0, #52	; 0x34
    8d28:	2100      	movs	r1, #0
    8d2a:	4630      	mov	r0, r6
    8d2c:	f016 f894 	bl	1ee58 <net_buf_get>
    8d30:	4605      	mov	r5, r0
    8d32:	bb48      	cbnz	r0, 8d88 <conn_cleanup+0x68>
		}

		net_buf_unref(buf);
	}

	__ASSERT(sys_slist_is_empty(&conn->tx_pending), "Pending TX packets");
    8d34:	6963      	ldr	r3, [r4, #20]
    8d36:	b173      	cbz	r3, 8d56 <conn_cleanup+0x36>
    8d38:	4917      	ldr	r1, [pc, #92]	; (8d98 <conn_cleanup+0x78>)
    8d3a:	4a18      	ldr	r2, [pc, #96]	; (8d9c <conn_cleanup+0x7c>)
    8d3c:	4818      	ldr	r0, [pc, #96]	; (8da0 <conn_cleanup+0x80>)
    8d3e:	f240 53dd 	movw	r3, #1501	; 0x5dd
    8d42:	f01b f8ce 	bl	23ee2 <printk>
    8d46:	4817      	ldr	r0, [pc, #92]	; (8da4 <conn_cleanup+0x84>)
    8d48:	f01b f8cb 	bl	23ee2 <printk>
    8d4c:	4813      	ldr	r0, [pc, #76]	; (8d9c <conn_cleanup+0x7c>)
    8d4e:	f240 51dd 	movw	r1, #1501	; 0x5dd
    8d52:	f01b f909 	bl	23f68 <assert_post_action>
	__ASSERT_NO_MSG(conn->pending_no_cb == 0);
    8d56:	69e3      	ldr	r3, [r4, #28]
    8d58:	b15b      	cbz	r3, 8d72 <conn_cleanup+0x52>
    8d5a:	4913      	ldr	r1, [pc, #76]	; (8da8 <conn_cleanup+0x88>)
    8d5c:	4810      	ldr	r0, [pc, #64]	; (8da0 <conn_cleanup+0x80>)
    8d5e:	4a0f      	ldr	r2, [pc, #60]	; (8d9c <conn_cleanup+0x7c>)
    8d60:	f240 53de 	movw	r3, #1502	; 0x5de
    8d64:	f01b f8bd 	bl	23ee2 <printk>
    8d68:	480c      	ldr	r0, [pc, #48]	; (8d9c <conn_cleanup+0x7c>)
    8d6a:	f240 51de 	movw	r1, #1502	; 0x5de
    8d6e:	f01b f8fb 	bl	23f68 <assert_post_action>

	bt_conn_reset_rx_state(conn);
    8d72:	4620      	mov	r0, r4
    8d74:	f01d fbab 	bl	264ce <bt_conn_reset_rx_state>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    8d78:	f104 0154 	add.w	r1, r4, #84	; 0x54
    8d7c:	480b      	ldr	r0, [pc, #44]	; (8dac <conn_cleanup+0x8c>)

	k_delayed_work_submit(&conn->update_work, K_NO_WAIT);
}
    8d7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    8d82:	2200      	movs	r2, #0
    8d84:	f019 beec 	b.w	22b60 <k_delayed_work_submit_to_queue>
		if (tx_data(buf)->tx) {
    8d88:	6968      	ldr	r0, [r5, #20]
    8d8a:	b108      	cbz	r0, 8d90 <conn_cleanup+0x70>
			tx_free(tx_data(buf)->tx);
    8d8c:	f7ff fefc 	bl	8b88 <tx_free>
		net_buf_unref(buf);
    8d90:	4628      	mov	r0, r5
    8d92:	f016 f999 	bl	1f0c8 <net_buf_unref>
    8d96:	e7c7      	b.n	8d28 <conn_cleanup+0x8>
    8d98:	0002c401 	.word	0x0002c401
    8d9c:	0002c3be 	.word	0x0002c3be
    8da0:	0002a5e8 	.word	0x0002a5e8
    8da4:	0002c427 	.word	0x0002c427
    8da8:	0002c43c 	.word	0x0002c43c
    8dac:	20001dc4 	.word	0x20001dc4

00008db0 <bt_conn_get_pkts>:
}
    8db0:	4800      	ldr	r0, [pc, #0]	; (8db4 <bt_conn_get_pkts+0x4>)
    8db2:	4770      	bx	lr
    8db4:	20006904 	.word	0x20006904

00008db8 <notify_le_param_updated>:
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    8db8:	1d03      	adds	r3, r0, #4
{
    8dba:	b570      	push	{r4, r5, r6, lr}
    8dbc:	4604      	mov	r4, r0
    8dbe:	4618      	mov	r0, r3
    8dc0:	f01d fb7f 	bl	264c2 <atomic_get>
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    8dc4:	0582      	lsls	r2, r0, #22
    8dc6:	d519      	bpl.n	8dfc <notify_le_param_updated+0x44>
	    conn->le.interval >= conn->le.interval_min &&
    8dc8:	f8b4 208a 	ldrh.w	r2, [r4, #138]	; 0x8a
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    8dcc:	f8b4 108c 	ldrh.w	r1, [r4, #140]	; 0x8c
    8dd0:	4291      	cmp	r1, r2
    8dd2:	d813      	bhi.n	8dfc <notify_le_param_updated+0x44>
	    conn->le.interval >= conn->le.interval_min &&
    8dd4:	f8b4 108e 	ldrh.w	r1, [r4, #142]	; 0x8e
    8dd8:	4291      	cmp	r1, r2
    8dda:	d30f      	bcc.n	8dfc <notify_le_param_updated+0x44>
	    conn->le.latency == conn->le.pending_latency &&
    8ddc:	e9d4 1224 	ldrd	r1, r2, [r4, #144]	; 0x90
    8de0:	4291      	cmp	r1, r2
    8de2:	d10b      	bne.n	8dfc <notify_le_param_updated+0x44>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    8de4:	f3bf 8f5b 	dmb	ish
    8de8:	e853 2f00 	ldrex	r2, [r3]
    8dec:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    8df0:	e843 2100 	strex	r1, r2, [r3]
    8df4:	2900      	cmp	r1, #0
    8df6:	d1f7      	bne.n	8de8 <notify_le_param_updated+0x30>
    8df8:	f3bf 8f5b 	dmb	ish
	for (cb = callback_list; cb; cb = cb->_next) {
    8dfc:	4b07      	ldr	r3, [pc, #28]	; (8e1c <notify_le_param_updated+0x64>)
    8dfe:	681d      	ldr	r5, [r3, #0]
    8e00:	b905      	cbnz	r5, 8e04 <notify_le_param_updated+0x4c>
}
    8e02:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->le_param_updated) {
    8e04:	68ee      	ldr	r6, [r5, #12]
    8e06:	b13e      	cbz	r6, 8e18 <notify_le_param_updated+0x60>
			cb->le_param_updated(conn, conn->le.interval,
    8e08:	f8b4 3092 	ldrh.w	r3, [r4, #146]	; 0x92
    8e0c:	f8b4 2090 	ldrh.w	r2, [r4, #144]	; 0x90
    8e10:	f8b4 108a 	ldrh.w	r1, [r4, #138]	; 0x8a
    8e14:	4620      	mov	r0, r4
    8e16:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
    8e18:	692d      	ldr	r5, [r5, #16]
    8e1a:	e7f1      	b.n	8e00 <notify_le_param_updated+0x48>
    8e1c:	2000051c 	.word	0x2000051c

00008e20 <le_param_req>:
{
    8e20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8e22:	4607      	mov	r7, r0
	if (!bt_le_conn_params_valid(param)) {
    8e24:	4608      	mov	r0, r1
{
    8e26:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
    8e28:	f01d facf 	bl	263ca <bt_le_conn_params_valid>
    8e2c:	4604      	mov	r4, r0
    8e2e:	b910      	cbnz	r0, 8e36 <le_param_req+0x16>
		return false;
    8e30:	2400      	movs	r4, #0
}
    8e32:	4620      	mov	r0, r4
    8e34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (cb = callback_list; cb; cb = cb->_next) {
    8e36:	4b09      	ldr	r3, [pc, #36]	; (8e5c <le_param_req+0x3c>)
    8e38:	681e      	ldr	r6, [r3, #0]
    8e3a:	2e00      	cmp	r6, #0
    8e3c:	d0f9      	beq.n	8e32 <le_param_req+0x12>
		if (!cb->le_param_req) {
    8e3e:	68b3      	ldr	r3, [r6, #8]
    8e40:	b90b      	cbnz	r3, 8e46 <le_param_req+0x26>
	for (cb = callback_list; cb; cb = cb->_next) {
    8e42:	6936      	ldr	r6, [r6, #16]
    8e44:	e7f9      	b.n	8e3a <le_param_req+0x1a>
		if (!cb->le_param_req(conn, param)) {
    8e46:	4629      	mov	r1, r5
    8e48:	4638      	mov	r0, r7
    8e4a:	4798      	blx	r3
    8e4c:	2800      	cmp	r0, #0
    8e4e:	d0ef      	beq.n	8e30 <le_param_req+0x10>
		if (!bt_le_conn_params_valid(param)) {
    8e50:	4628      	mov	r0, r5
    8e52:	f01d faba 	bl	263ca <bt_le_conn_params_valid>
    8e56:	2800      	cmp	r0, #0
    8e58:	d1f3      	bne.n	8e42 <le_param_req+0x22>
    8e5a:	e7e9      	b.n	8e30 <le_param_req+0x10>
    8e5c:	2000051c 	.word	0x2000051c

00008e60 <bt_conn_cb_register>:
	cb->_next = callback_list;
    8e60:	4b02      	ldr	r3, [pc, #8]	; (8e6c <bt_conn_cb_register+0xc>)
    8e62:	681a      	ldr	r2, [r3, #0]
    8e64:	6102      	str	r2, [r0, #16]
	callback_list = cb;
    8e66:	6018      	str	r0, [r3, #0]
}
    8e68:	4770      	bx	lr
    8e6a:	bf00      	nop
    8e6c:	2000051c 	.word	0x2000051c

00008e70 <bt_conn_recv>:
{
    8e70:	b570      	push	{r4, r5, r6, lr}
    8e72:	4616      	mov	r6, r2
    8e74:	4604      	mov	r4, r0
    8e76:	460d      	mov	r5, r1
	tx_notify(conn);
    8e78:	f01d fb4e 	bl	26518 <tx_notify>
	switch (flags) {
    8e7c:	2e01      	cmp	r6, #1
    8e7e:	d01b      	beq.n	8eb8 <bt_conn_recv+0x48>
    8e80:	2e02      	cmp	r6, #2
    8e82:	d16c      	bne.n	8f5e <bt_conn_recv+0xee>
		len = sys_le16_to_cpu(hdr->len);
    8e84:	68ab      	ldr	r3, [r5, #8]
    8e86:	881e      	ldrh	r6, [r3, #0]
		if (conn->rx_len) {
    8e88:	89a3      	ldrh	r3, [r4, #12]
    8e8a:	b163      	cbz	r3, 8ea6 <bt_conn_recv+0x36>
    8e8c:	4b3d      	ldr	r3, [pc, #244]	; (8f84 <bt_conn_recv+0x114>)
    8e8e:	493e      	ldr	r1, [pc, #248]	; (8f88 <bt_conn_recv+0x118>)
			BT_ERR("Unexpected first L2CAP frame");
    8e90:	483e      	ldr	r0, [pc, #248]	; (8f8c <bt_conn_recv+0x11c>)
    8e92:	1ac9      	subs	r1, r1, r3
    8e94:	08c9      	lsrs	r1, r1, #3
    8e96:	0189      	lsls	r1, r1, #6
    8e98:	f041 0101 	orr.w	r1, r1, #1
    8e9c:	f01b f892 	bl	23fc4 <log_0>
			bt_conn_reset_rx_state(conn);
    8ea0:	4620      	mov	r0, r4
    8ea2:	f01d fb14 	bl	264ce <bt_conn_reset_rx_state>
		conn->rx_len = (sizeof(*hdr) + len) - buf->len;
    8ea6:	89ab      	ldrh	r3, [r5, #12]
    8ea8:	1af3      	subs	r3, r6, r3
    8eaa:	3304      	adds	r3, #4
    8eac:	b29b      	uxth	r3, r3
    8eae:	81a3      	strh	r3, [r4, #12]
		if (conn->rx_len) {
    8eb0:	2b00      	cmp	r3, #0
    8eb2:	d043      	beq.n	8f3c <bt_conn_recv+0xcc>
			conn->rx = buf;
    8eb4:	6125      	str	r5, [r4, #16]
}
    8eb6:	bd70      	pop	{r4, r5, r6, pc}
		if (!conn->rx_len) {
    8eb8:	89a3      	ldrh	r3, [r4, #12]
    8eba:	b98b      	cbnz	r3, 8ee0 <bt_conn_recv+0x70>
    8ebc:	4932      	ldr	r1, [pc, #200]	; (8f88 <bt_conn_recv+0x118>)
    8ebe:	4b31      	ldr	r3, [pc, #196]	; (8f84 <bt_conn_recv+0x114>)
			BT_ERR("Unexpected L2CAP continuation");
    8ec0:	4833      	ldr	r0, [pc, #204]	; (8f90 <bt_conn_recv+0x120>)
    8ec2:	1ac9      	subs	r1, r1, r3
    8ec4:	08c9      	lsrs	r1, r1, #3
    8ec6:	0189      	lsls	r1, r1, #6
    8ec8:	f041 0101 	orr.w	r1, r1, #1
			BT_ERR("L2CAP data overflow");
    8ecc:	f01b f87a 	bl	23fc4 <log_0>
			bt_conn_reset_rx_state(conn);
    8ed0:	4620      	mov	r0, r4
    8ed2:	f01d fafc 	bl	264ce <bt_conn_reset_rx_state>
			net_buf_unref(buf);
    8ed6:	4628      	mov	r0, r5
}
    8ed8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			net_buf_unref(buf);
    8edc:	f016 b8f4 	b.w	1f0c8 <net_buf_unref>
		if (buf->len > conn->rx_len) {
    8ee0:	89ae      	ldrh	r6, [r5, #12]
    8ee2:	42b3      	cmp	r3, r6
    8ee4:	d208      	bcs.n	8ef8 <bt_conn_recv+0x88>
    8ee6:	4928      	ldr	r1, [pc, #160]	; (8f88 <bt_conn_recv+0x118>)
    8ee8:	4b26      	ldr	r3, [pc, #152]	; (8f84 <bt_conn_recv+0x114>)
			BT_ERR("L2CAP data overflow");
    8eea:	482a      	ldr	r0, [pc, #168]	; (8f94 <bt_conn_recv+0x124>)
    8eec:	1ac9      	subs	r1, r1, r3
    8eee:	08c9      	lsrs	r1, r1, #3
    8ef0:	0189      	lsls	r1, r1, #6
    8ef2:	f041 0101 	orr.w	r1, r1, #1
    8ef6:	e7e9      	b.n	8ecc <bt_conn_recv+0x5c>
		if (buf->len > net_buf_tailroom(conn->rx)) {
    8ef8:	6920      	ldr	r0, [r4, #16]
    8efa:	3008      	adds	r0, #8
    8efc:	f01f ff53 	bl	28da6 <net_buf_simple_tailroom>
    8f00:	4286      	cmp	r6, r0
    8f02:	d908      	bls.n	8f16 <bt_conn_recv+0xa6>
    8f04:	4920      	ldr	r1, [pc, #128]	; (8f88 <bt_conn_recv+0x118>)
    8f06:	4b1f      	ldr	r3, [pc, #124]	; (8f84 <bt_conn_recv+0x114>)
			BT_ERR("Not enough buffer space for L2CAP data");
    8f08:	4823      	ldr	r0, [pc, #140]	; (8f98 <bt_conn_recv+0x128>)
    8f0a:	1ac9      	subs	r1, r1, r3
    8f0c:	08c9      	lsrs	r1, r1, #3
    8f0e:	0189      	lsls	r1, r1, #6
    8f10:	f041 0101 	orr.w	r1, r1, #1
    8f14:	e7da      	b.n	8ecc <bt_conn_recv+0x5c>
		net_buf_add_mem(conn->rx, buf->data, buf->len);
    8f16:	6920      	ldr	r0, [r4, #16]
    8f18:	89aa      	ldrh	r2, [r5, #12]
    8f1a:	68a9      	ldr	r1, [r5, #8]
    8f1c:	3008      	adds	r0, #8
    8f1e:	f01f ff4a 	bl	28db6 <net_buf_simple_add_mem>
		conn->rx_len -= buf->len;
    8f22:	89a3      	ldrh	r3, [r4, #12]
    8f24:	89aa      	ldrh	r2, [r5, #12]
    8f26:	1a9b      	subs	r3, r3, r2
    8f28:	81a3      	strh	r3, [r4, #12]
		net_buf_unref(buf);
    8f2a:	4628      	mov	r0, r5
    8f2c:	f016 f8cc 	bl	1f0c8 <net_buf_unref>
		if (conn->rx_len) {
    8f30:	89a3      	ldrh	r3, [r4, #12]
    8f32:	2b00      	cmp	r3, #0
    8f34:	d1bf      	bne.n	8eb6 <bt_conn_recv+0x46>
		buf = conn->rx;
    8f36:	6925      	ldr	r5, [r4, #16]
		conn->rx_len = 0U;
    8f38:	81a3      	strh	r3, [r4, #12]
		conn->rx = NULL;
    8f3a:	6123      	str	r3, [r4, #16]
	len = sys_le16_to_cpu(hdr->len);
    8f3c:	68ab      	ldr	r3, [r5, #8]
	if (sizeof(*hdr) + len != buf->len) {
    8f3e:	89aa      	ldrh	r2, [r5, #12]
    8f40:	8819      	ldrh	r1, [r3, #0]
    8f42:	1d0b      	adds	r3, r1, #4
    8f44:	4293      	cmp	r3, r2
    8f46:	d016      	beq.n	8f76 <bt_conn_recv+0x106>
    8f48:	480e      	ldr	r0, [pc, #56]	; (8f84 <bt_conn_recv+0x114>)
    8f4a:	4b0f      	ldr	r3, [pc, #60]	; (8f88 <bt_conn_recv+0x118>)
    8f4c:	1a1b      	subs	r3, r3, r0
    8f4e:	08db      	lsrs	r3, r3, #3
		BT_ERR("ACL len mismatch (%u != %u)", len, buf->len);
    8f50:	019b      	lsls	r3, r3, #6
    8f52:	4812      	ldr	r0, [pc, #72]	; (8f9c <bt_conn_recv+0x12c>)
    8f54:	f043 0301 	orr.w	r3, r3, #1
    8f58:	f01b f855 	bl	24006 <log_2>
		net_buf_unref(buf);
    8f5c:	e7bb      	b.n	8ed6 <bt_conn_recv+0x66>
    8f5e:	4a09      	ldr	r2, [pc, #36]	; (8f84 <bt_conn_recv+0x114>)
    8f60:	4b09      	ldr	r3, [pc, #36]	; (8f88 <bt_conn_recv+0x118>)
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
    8f62:	480f      	ldr	r0, [pc, #60]	; (8fa0 <bt_conn_recv+0x130>)
    8f64:	1a9b      	subs	r3, r3, r2
    8f66:	08db      	lsrs	r3, r3, #3
    8f68:	019b      	lsls	r3, r3, #6
    8f6a:	f043 0201 	orr.w	r2, r3, #1
    8f6e:	4631      	mov	r1, r6
    8f70:	f01b f835 	bl	23fde <log_1>
		bt_conn_reset_rx_state(conn);
    8f74:	e7ac      	b.n	8ed0 <bt_conn_recv+0x60>
	bt_l2cap_recv(conn, buf);
    8f76:	4629      	mov	r1, r5
    8f78:	4620      	mov	r0, r4
}
    8f7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_l2cap_recv(conn, buf);
    8f7e:	f000 bd21 	b.w	99c4 <bt_l2cap_recv>
    8f82:	bf00      	nop
    8f84:	00029830 	.word	0x00029830
    8f88:	00029840 	.word	0x00029840
    8f8c:	0002c455 	.word	0x0002c455
    8f90:	0002c472 	.word	0x0002c472
    8f94:	0002c490 	.word	0x0002c490
    8f98:	0002c4a4 	.word	0x0002c4a4
    8f9c:	0002c4e9 	.word	0x0002c4e9
    8fa0:	0002c4cb 	.word	0x0002c4cb

00008fa4 <bt_conn_send_cb>:
{
    8fa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8fa8:	4698      	mov	r8, r3
	if (conn->state != BT_CONN_CONNECTED) {
    8faa:	7a83      	ldrb	r3, [r0, #10]
    8fac:	2b06      	cmp	r3, #6
{
    8fae:	4606      	mov	r6, r0
    8fb0:	460d      	mov	r5, r1
    8fb2:	4617      	mov	r7, r2
	if (conn->state != BT_CONN_CONNECTED) {
    8fb4:	d00f      	beq.n	8fd6 <bt_conn_send_cb+0x32>
    8fb6:	4b29      	ldr	r3, [pc, #164]	; (905c <bt_conn_send_cb+0xb8>)
    8fb8:	4929      	ldr	r1, [pc, #164]	; (9060 <bt_conn_send_cb+0xbc>)
		BT_ERR("not connected!");
    8fba:	482a      	ldr	r0, [pc, #168]	; (9064 <bt_conn_send_cb+0xc0>)
    8fbc:	1ac9      	subs	r1, r1, r3
    8fbe:	08c9      	lsrs	r1, r1, #3
    8fc0:	0189      	lsls	r1, r1, #6
    8fc2:	f041 0101 	orr.w	r1, r1, #1
    8fc6:	f01a fffd 	bl	23fc4 <log_0>
		net_buf_unref(buf);
    8fca:	4628      	mov	r0, r5
    8fcc:	f016 f87c 	bl	1f0c8 <net_buf_unref>
			return -ENOTCONN;
    8fd0:	f06f 0038 	mvn.w	r0, #56	; 0x38
    8fd4:	e01d      	b.n	9012 <bt_conn_send_cb+0x6e>
	if (cb) {
    8fd6:	2a00      	cmp	r2, #0
    8fd8:	d03d      	beq.n	9056 <bt_conn_send_cb+0xb2>
	return z_impl_k_current_get();
    8fda:	f019 fb63 	bl	226a4 <z_impl_k_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
    8fde:	4b22      	ldr	r3, [pc, #136]	; (9068 <bt_conn_send_cb+0xc4>)
    8fe0:	4283      	cmp	r3, r0
	return z_impl_k_queue_get(queue, timeout);
    8fe2:	4822      	ldr	r0, [pc, #136]	; (906c <bt_conn_send_cb+0xc8>)
    8fe4:	bf0c      	ite	eq
    8fe6:	2100      	moveq	r1, #0
    8fe8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    8fec:	f018 f83a 	bl	21064 <z_impl_k_queue_get>
    8ff0:	4604      	mov	r4, r0
		if (!tx) {
    8ff2:	b980      	cbnz	r0, 9016 <bt_conn_send_cb+0x72>
    8ff4:	4b19      	ldr	r3, [pc, #100]	; (905c <bt_conn_send_cb+0xb8>)
    8ff6:	491a      	ldr	r1, [pc, #104]	; (9060 <bt_conn_send_cb+0xbc>)
			BT_ERR("Unable to allocate TX context");
    8ff8:	481d      	ldr	r0, [pc, #116]	; (9070 <bt_conn_send_cb+0xcc>)
    8ffa:	1ac9      	subs	r1, r1, r3
    8ffc:	08c9      	lsrs	r1, r1, #3
    8ffe:	0189      	lsls	r1, r1, #6
    9000:	f041 0101 	orr.w	r1, r1, #1
    9004:	f01a ffde 	bl	23fc4 <log_0>
			net_buf_unref(buf);
    9008:	4628      	mov	r0, r5
    900a:	f016 f85d 	bl	1f0c8 <net_buf_unref>
			return -ENOBUFS;
    900e:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
    9012:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (conn->state != BT_CONN_CONNECTED) {
    9016:	7ab3      	ldrb	r3, [r6, #10]
    9018:	2b06      	cmp	r3, #6
    901a:	d010      	beq.n	903e <bt_conn_send_cb+0x9a>
    901c:	4b0f      	ldr	r3, [pc, #60]	; (905c <bt_conn_send_cb+0xb8>)
    901e:	4910      	ldr	r1, [pc, #64]	; (9060 <bt_conn_send_cb+0xbc>)
			BT_WARN("Disconnected while allocating context");
    9020:	4814      	ldr	r0, [pc, #80]	; (9074 <bt_conn_send_cb+0xd0>)
    9022:	1ac9      	subs	r1, r1, r3
    9024:	08c9      	lsrs	r1, r1, #3
    9026:	0189      	lsls	r1, r1, #6
    9028:	f041 0102 	orr.w	r1, r1, #2
    902c:	f01a ffca 	bl	23fc4 <log_0>
			net_buf_unref(buf);
    9030:	4628      	mov	r0, r5
    9032:	f016 f849 	bl	1f0c8 <net_buf_unref>
			tx_free(tx);
    9036:	4620      	mov	r0, r4
    9038:	f7ff fda6 	bl	8b88 <tx_free>
    903c:	e7c8      	b.n	8fd0 <bt_conn_send_cb+0x2c>
		tx->pending_no_cb = 0U;
    903e:	2300      	movs	r3, #0
		tx->user_data = user_data;
    9040:	e9c0 7801 	strd	r7, r8, [r0, #4]
		tx->pending_no_cb = 0U;
    9044:	60c3      	str	r3, [r0, #12]
		tx_data(buf)->tx = tx;
    9046:	6168      	str	r0, [r5, #20]
	net_buf_put(&conn->tx_queue, buf);
    9048:	f106 0034 	add.w	r0, r6, #52	; 0x34
    904c:	4629      	mov	r1, r5
    904e:	f016 f807 	bl	1f060 <net_buf_put>
	return 0;
    9052:	2000      	movs	r0, #0
    9054:	e7dd      	b.n	9012 <bt_conn_send_cb+0x6e>
		tx_data(buf)->tx = NULL;
    9056:	614a      	str	r2, [r1, #20]
    9058:	e7f6      	b.n	9048 <bt_conn_send_cb+0xa4>
    905a:	bf00      	nop
    905c:	00029830 	.word	0x00029830
    9060:	00029840 	.word	0x00029840
    9064:	0002c505 	.word	0x0002c505
    9068:	20001dd8 	.word	0x20001dd8
    906c:	20007634 	.word	0x20007634
    9070:	0002c514 	.word	0x0002c514
    9074:	0002c532 	.word	0x0002c532

00009078 <bt_conn_prepare_events>:
{
	int i, ev_count = 0;

	BT_DBG("");

	conn_change.signaled = 0U;
    9078:	4b1a      	ldr	r3, [pc, #104]	; (90e4 <bt_conn_prepare_events+0x6c>)
{
    907a:	b510      	push	{r4, lr}
	conn_change.signaled = 0U;
    907c:	2200      	movs	r2, #0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    907e:	2101      	movs	r1, #1
	conn_change.signaled = 0U;
    9080:	609a      	str	r2, [r3, #8]
{
    9082:	4604      	mov	r4, r0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    9084:	f01a fbbc 	bl	23800 <k_poll_event_init>
			  K_POLL_MODE_NOTIFY_ONLY, &conn_change);

	for (i = 0; i < ARRAY_SIZE(conns); i++) {
		struct bt_conn *conn = &conns[i];

		if (!atomic_get(&conn->ref)) {
    9088:	4b17      	ldr	r3, [pc, #92]	; (90e8 <bt_conn_prepare_events+0x70>)
    908a:	f103 0050 	add.w	r0, r3, #80	; 0x50
    908e:	f01d fa18 	bl	264c2 <atomic_get>
    9092:	4619      	mov	r1, r3
    9094:	b908      	cbnz	r0, 909a <bt_conn_prepare_events+0x22>
		}

		if (conn->state == BT_CONN_DISCONNECTED &&
		    atomic_test_and_clear_bit(conn->flags, BT_CONN_CLEANUP)) {
			conn_cleanup(conn);
			continue;
    9096:	2001      	movs	r0, #1
				  &conn->tx_queue);
		events[ev_count++].tag = BT_EVENT_CONN_TX_QUEUE;
	}

	return ev_count;
}
    9098:	bd10      	pop	{r4, pc}
		if (conn->state == BT_CONN_DISCONNECTED &&
    909a:	7a9a      	ldrb	r2, [r3, #10]
    909c:	b99a      	cbnz	r2, 90c6 <bt_conn_prepare_events+0x4e>
    909e:	f3bf 8f5b 	dmb	ish
    90a2:	1d1a      	adds	r2, r3, #4
    90a4:	e852 0f00 	ldrex	r0, [r2]
    90a8:	f020 0c40 	bic.w	ip, r0, #64	; 0x40
    90ac:	e842 ce00 	strex	lr, ip, [r2]
    90b0:	f1be 0f00 	cmp.w	lr, #0
    90b4:	d1f6      	bne.n	90a4 <bt_conn_prepare_events+0x2c>
    90b6:	f3bf 8f5b 	dmb	ish
    90ba:	0642      	lsls	r2, r0, #25
    90bc:	d503      	bpl.n	90c6 <bt_conn_prepare_events+0x4e>
			conn_cleanup(conn);
    90be:	4618      	mov	r0, r3
    90c0:	f7ff fe2e 	bl	8d20 <conn_cleanup>
    90c4:	e7e7      	b.n	9096 <bt_conn_prepare_events+0x1e>
		if (conn->state != BT_CONN_CONNECTED) {
    90c6:	7a8b      	ldrb	r3, [r1, #10]
    90c8:	2b06      	cmp	r3, #6
    90ca:	d1e4      	bne.n	9096 <bt_conn_prepare_events+0x1e>
		k_poll_event_init(&events[ev_count],
    90cc:	4b07      	ldr	r3, [pc, #28]	; (90ec <bt_conn_prepare_events+0x74>)
    90ce:	f104 0014 	add.w	r0, r4, #20
    90d2:	2200      	movs	r2, #0
    90d4:	2104      	movs	r1, #4
    90d6:	f01a fb93 	bl	23800 <k_poll_event_init>
		events[ev_count++].tag = BT_EVENT_CONN_TX_QUEUE;
    90da:	2301      	movs	r3, #1
    90dc:	f884 3020 	strb.w	r3, [r4, #32]
    90e0:	2002      	movs	r0, #2
	return ev_count;
    90e2:	e7d9      	b.n	9098 <bt_conn_prepare_events+0x20>
    90e4:	20006b00 	.word	0x20006b00
    90e8:	20000560 	.word	0x20000560
    90ec:	20000594 	.word	0x20000594

000090f0 <bt_conn_add_le>:
		net_buf_unref(buf);
	}
}

struct bt_conn *bt_conn_add_le(u8_t id, const bt_addr_le_t *peer)
{
    90f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (!atomic_get(&conns[i].ref)) {
    90f4:	4c19      	ldr	r4, [pc, #100]	; (915c <bt_conn_add_le+0x6c>)
    90f6:	f104 0850 	add.w	r8, r4, #80	; 0x50
{
    90fa:	4607      	mov	r7, r0
		if (!atomic_get(&conns[i].ref)) {
    90fc:	4640      	mov	r0, r8
{
    90fe:	460e      	mov	r6, r1
		if (!atomic_get(&conns[i].ref)) {
    9100:	f01d f9df 	bl	264c2 <atomic_get>
    9104:	4605      	mov	r5, r0
    9106:	b110      	cbz	r0, 910e <bt_conn_add_le+0x1e>
	struct bt_conn *conn = conn_new();

	if (!conn) {
		return NULL;
    9108:	2000      	movs	r0, #0
	conn->type = BT_CONN_TYPE_LE;
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;

	return conn;
}
    910a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	(void)memset(conn, 0, sizeof(*conn));
    910e:	4601      	mov	r1, r0
    9110:	22a4      	movs	r2, #164	; 0xa4
    9112:	4620      	mov	r0, r4
    9114:	f01c fdf3 	bl	25cfe <memset>
	k_delayed_work_init(&conn->update_work, conn_update_timeout);
    9118:	4911      	ldr	r1, [pc, #68]	; (9160 <bt_conn_add_le+0x70>)
    911a:	f104 0054 	add.w	r0, r4, #84	; 0x54
    911e:	f020 f96c 	bl	293fa <k_delayed_work_init>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    9122:	4b10      	ldr	r3, [pc, #64]	; (9164 <bt_conn_add_le+0x74>)
    9124:	62a5      	str	r5, [r4, #40]	; 0x28
    9126:	e9c4 350b 	strd	r3, r5, [r4, #44]	; 0x2c
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    912a:	2501      	movs	r5, #1
    912c:	f3bf 8f5b 	dmb	ish
    9130:	e858 3f00 	ldrex	r3, [r8]
    9134:	e848 5200 	strex	r2, r5, [r8]
    9138:	2a00      	cmp	r2, #0
    913a:	d1f9      	bne.n	9130 <bt_conn_add_le+0x40>
    913c:	f3bf 8f5b 	dmb	ish
}

static inline void bt_addr_le_copy(bt_addr_le_t *dst, const bt_addr_le_t *src)
{
	memcpy(dst, src, sizeof(*dst));
    9140:	2207      	movs	r2, #7
    9142:	4631      	mov	r1, r6
    9144:	f104 0074 	add.w	r0, r4, #116	; 0x74
	conn->id = id;
    9148:	7227      	strb	r7, [r4, #8]
    914a:	f01c fdad 	bl	25ca8 <memcpy>
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
    914e:	4b06      	ldr	r3, [pc, #24]	; (9168 <bt_conn_add_le+0x78>)
	conn->type = BT_CONN_TYPE_LE;
    9150:	70a5      	strb	r5, [r4, #2]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
    9152:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
			conn = &conns[i];
    9156:	4620      	mov	r0, r4
	return conn;
    9158:	e7d7      	b.n	910a <bt_conn_add_le+0x1a>
    915a:	bf00      	nop
    915c:	20000560 	.word	0x20000560
    9160:	00009415 	.word	0x00009415
    9164:	0002655f 	.word	0x0002655f
    9168:	00280018 	.word	0x00280018

0000916c <bt_conn_set_state>:
		k_sem_give(bt_conn_get_pkts(conn));
	}
}

void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state)
{
    916c:	b570      	push	{r4, r5, r6, lr}
	bt_conn_state_t old_state;

	BT_DBG("%s -> %s", state2str(conn->state), state2str(state));

	if (conn->state == state) {
    916e:	7a85      	ldrb	r5, [r0, #10]
    9170:	428d      	cmp	r5, r1
{
    9172:	4604      	mov	r4, r0
    9174:	460e      	mov	r6, r1
	if (conn->state == state) {
    9176:	d10b      	bne.n	9190 <bt_conn_set_state+0x24>
    9178:	495b      	ldr	r1, [pc, #364]	; (92e8 <bt_conn_set_state+0x17c>)
    917a:	4b5c      	ldr	r3, [pc, #368]	; (92ec <bt_conn_set_state+0x180>)
		BT_WARN("no transition");
    917c:	485c      	ldr	r0, [pc, #368]	; (92f0 <bt_conn_set_state+0x184>)
    917e:	1ac9      	subs	r1, r1, r3
    9180:	08c9      	lsrs	r1, r1, #3
    9182:	0189      	lsls	r1, r1, #6
	default:
		BT_WARN("no valid (%u) state was set", state);

		break;
	}
}
    9184:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("no transition");
    9188:	f041 0102 	orr.w	r1, r1, #2
    918c:	f01a bf1a 	b.w	23fc4 <log_0>
	conn->state = state;
    9190:	7281      	strb	r1, [r0, #10]
	switch (old_state) {
    9192:	b915      	cbnz	r5, 919a <bt_conn_set_state+0x2e>
#endif /* defined(CONFIG_BT_BREDR) */
}

struct bt_conn *bt_conn_ref(struct bt_conn *conn)
{
	atomic_val_t old = atomic_inc(&conn->ref);
    9194:	3050      	adds	r0, #80	; 0x50
    9196:	f01d f9b2 	bl	264fe <atomic_inc>
	switch (conn->state) {
    919a:	7aa3      	ldrb	r3, [r4, #10]
    919c:	2b07      	cmp	r3, #7
    919e:	f200 8094 	bhi.w	92ca <bt_conn_set_state+0x15e>
    91a2:	e8df f003 	tbb	[pc, r3]
    91a6:	9f1b      	.short	0x9f1b
    91a8:	9f9f9f9f 	.word	0x9f9f9f9f
    91ac:	9f04      	.short	0x9f04
		if (conn->type == BT_CONN_TYPE_SCO) {
    91ae:	78a3      	ldrb	r3, [r4, #2]
    91b0:	2b04      	cmp	r3, #4
    91b2:	f000 8097 	beq.w	92e4 <bt_conn_set_state+0x178>
	z_impl_k_queue_init(queue);
    91b6:	f104 0034 	add.w	r0, r4, #52	; 0x34
    91ba:	f020 f841 	bl	29240 <z_impl_k_queue_init>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&signal, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(signal, result);
    91be:	2100      	movs	r1, #0
    91c0:	484c      	ldr	r0, [pc, #304]	; (92f4 <bt_conn_set_state+0x188>)
    91c2:	f01a fc73 	bl	23aac <z_impl_k_poll_signal_raise>
	list->head = NULL;
    91c6:	2300      	movs	r3, #0
		bt_l2cap_connected(conn);
    91c8:	4620      	mov	r0, r4
	list->tail = NULL;
    91ca:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
    91ce:	f000 fb13 	bl	97f8 <bt_l2cap_connected>
		notify_connected(conn);
    91d2:	4620      	mov	r0, r4
}
    91d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify_connected(conn);
    91d8:	f7ff bce0 	b.w	8b9c <notify_connected>
		if (conn->type == BT_CONN_TYPE_SCO) {
    91dc:	78a3      	ldrb	r3, [r4, #2]
    91de:	2b04      	cmp	r3, #4
    91e0:	d105      	bne.n	91ee <bt_conn_set_state+0x82>
	return conn;
}

void bt_conn_unref(struct bt_conn *conn)
{
	atomic_val_t old = atomic_dec(&conn->ref);
    91e2:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
    91e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	atomic_val_t old = atomic_dec(&conn->ref);
    91ea:	f01d b97b 	b.w	264e4 <atomic_dec>
		switch (old_state) {
    91ee:	3d01      	subs	r5, #1
    91f0:	2d06      	cmp	r5, #6
    91f2:	d877      	bhi.n	92e4 <bt_conn_set_state+0x178>
    91f4:	a301      	add	r3, pc, #4	; (adr r3, 91fc <bt_conn_set_state+0x90>)
    91f6:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
    91fa:	bf00      	nop
    91fc:	000092bd 	.word	0x000092bd
    9200:	000091e3 	.word	0x000091e3
    9204:	000091e3 	.word	0x000091e3
    9208:	000092bd 	.word	0x000092bd
    920c:	000092bd 	.word	0x000092bd
    9210:	00009219 	.word	0x00009219
    9214:	00009219 	.word	0x00009219
	z_impl_k_sem_give(sem);
    9218:	4d37      	ldr	r5, [pc, #220]	; (92f8 <bt_conn_set_state+0x18c>)
		tx->pending_no_cb = 0U;
    921a:	2600      	movs	r6, #0
	__asm__ volatile(
    921c:	f04f 0320 	mov.w	r3, #32
    9220:	f3ef 8211 	mrs	r2, BASEPRI
    9224:	f383 8811 	msr	BASEPRI, r3
    9228:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
    922c:	69e3      	ldr	r3, [r4, #28]
    922e:	b14b      	cbz	r3, 9244 <bt_conn_set_state+0xd8>
			conn->pending_no_cb--;
    9230:	3b01      	subs	r3, #1
    9232:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
    9234:	f382 8811 	msr	BASEPRI, r2
    9238:	f3bf 8f6f 	isb	sy
    923c:	4628      	mov	r0, r5
    923e:	f019 fa37 	bl	226b0 <z_impl_k_sem_give>
}
    9242:	e7eb      	b.n	921c <bt_conn_set_state+0xb0>
Z_GENLIST_IS_EMPTY(slist)
    9244:	6960      	ldr	r0, [r4, #20]
Z_GENLIST_GET(slist, snode)
    9246:	b128      	cbz	r0, 9254 <bt_conn_set_state+0xe8>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    9248:	69a1      	ldr	r1, [r4, #24]
    924a:	6803      	ldr	r3, [r0, #0]
	list->head = node;
    924c:	6163      	str	r3, [r4, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    924e:	4288      	cmp	r0, r1
	list->tail = node;
    9250:	bf08      	it	eq
    9252:	61a3      	streq	r3, [r4, #24]
    9254:	f382 8811 	msr	BASEPRI, r2
    9258:	f3bf 8f6f 	isb	sy
		if (!node) {
    925c:	b188      	cbz	r0, 9282 <bt_conn_set_state+0x116>
	__asm__ volatile(
    925e:	f04f 0220 	mov.w	r2, #32
    9262:	f3ef 8311 	mrs	r3, BASEPRI
    9266:	f382 8811 	msr	BASEPRI, r2
    926a:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
    926e:	68c2      	ldr	r2, [r0, #12]
    9270:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
    9272:	60c6      	str	r6, [r0, #12]
	__asm__ volatile(
    9274:	f383 8811 	msr	BASEPRI, r3
    9278:	f3bf 8f6f 	isb	sy
		tx_free(tx);
    927c:	f7ff fc84 	bl	8b88 <tx_free>
    9280:	e7dc      	b.n	923c <bt_conn_set_state+0xd0>
			tx_notify(conn);
    9282:	4620      	mov	r0, r4
    9284:	f01d f948 	bl	26518 <tx_notify>
			if (conn->type == BT_CONN_TYPE_LE) {
    9288:	78a3      	ldrb	r3, [r4, #2]
    928a:	2b01      	cmp	r3, #1
    928c:	d103      	bne.n	9296 <bt_conn_set_state+0x12a>
				k_delayed_work_cancel(&conn->update_work);
    928e:	f104 0054 	add.w	r0, r4, #84	; 0x54
    9292:	f019 fcf5 	bl	22c80 <k_delayed_work_cancel>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    9296:	f3bf 8f5b 	dmb	ish
    929a:	3404      	adds	r4, #4
    929c:	e854 3f00 	ldrex	r3, [r4]
    92a0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    92a4:	e844 3200 	strex	r2, r3, [r4]
    92a8:	2a00      	cmp	r2, #0
    92aa:	d1f7      	bne.n	929c <bt_conn_set_state+0x130>
    92ac:	f3bf 8f5b 	dmb	ish
	return z_impl_k_poll_signal_raise(signal, result);
    92b0:	4810      	ldr	r0, [pc, #64]	; (92f4 <bt_conn_set_state+0x188>)
}
    92b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    92b6:	2100      	movs	r1, #0
    92b8:	f01a bbf8 	b.w	23aac <z_impl_k_poll_signal_raise>
			if (conn->err) {
    92bc:	7a63      	ldrb	r3, [r4, #9]
    92be:	2b00      	cmp	r3, #0
    92c0:	d08f      	beq.n	91e2 <bt_conn_set_state+0x76>
				notify_connected(conn);
    92c2:	4620      	mov	r0, r4
    92c4:	f7ff fc6a 	bl	8b9c <notify_connected>
    92c8:	e78b      	b.n	91e2 <bt_conn_set_state+0x76>
    92ca:	4a07      	ldr	r2, [pc, #28]	; (92e8 <bt_conn_set_state+0x17c>)
    92cc:	4b07      	ldr	r3, [pc, #28]	; (92ec <bt_conn_set_state+0x180>)
		BT_WARN("no valid (%u) state was set", state);
    92ce:	480b      	ldr	r0, [pc, #44]	; (92fc <bt_conn_set_state+0x190>)
    92d0:	1ad2      	subs	r2, r2, r3
    92d2:	08d2      	lsrs	r2, r2, #3
    92d4:	0192      	lsls	r2, r2, #6
    92d6:	4631      	mov	r1, r6
    92d8:	f042 0202 	orr.w	r2, r2, #2
}
    92dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("no valid (%u) state was set", state);
    92e0:	f01a be7d 	b.w	23fde <log_1>
}
    92e4:	bd70      	pop	{r4, r5, r6, pc}
    92e6:	bf00      	nop
    92e8:	00029840 	.word	0x00029840
    92ec:	00029830 	.word	0x00029830
    92f0:	0002c558 	.word	0x0002c558
    92f4:	20006b00 	.word	0x20006b00
    92f8:	20006904 	.word	0x20006904
    92fc:	0002c566 	.word	0x0002c566

00009300 <bt_conn_lookup_handle>:
{
    9300:	b510      	push	{r4, lr}
		if (!atomic_get(&conns[i].ref)) {
    9302:	4c0b      	ldr	r4, [pc, #44]	; (9330 <bt_conn_lookup_handle+0x30>)
{
    9304:	4603      	mov	r3, r0
		if (!atomic_get(&conns[i].ref)) {
    9306:	f104 0050 	add.w	r0, r4, #80	; 0x50
    930a:	f01d f8da 	bl	264c2 <atomic_get>
    930e:	b158      	cbz	r0, 9328 <bt_conn_lookup_handle+0x28>
		if (conns[i].state != BT_CONN_CONNECTED &&
    9310:	7aa2      	ldrb	r2, [r4, #10]
    9312:	3a06      	subs	r2, #6
    9314:	2a01      	cmp	r2, #1
    9316:	d808      	bhi.n	932a <bt_conn_lookup_handle+0x2a>
		if (conns[i].handle == handle) {
    9318:	8822      	ldrh	r2, [r4, #0]
    931a:	429a      	cmp	r2, r3
    931c:	d105      	bne.n	932a <bt_conn_lookup_handle+0x2a>
	atomic_val_t old = atomic_inc(&conn->ref);
    931e:	f104 0050 	add.w	r0, r4, #80	; 0x50
    9322:	f01d f8ec 	bl	264fe <atomic_inc>
			return bt_conn_ref(&conns[i]);
    9326:	4620      	mov	r0, r4
}
    9328:	bd10      	pop	{r4, pc}
	return NULL;
    932a:	2000      	movs	r0, #0
    932c:	e7fc      	b.n	9328 <bt_conn_lookup_handle+0x28>
    932e:	bf00      	nop
    9330:	20000560 	.word	0x20000560

00009334 <bt_conn_lookup_addr_le>:
{
    9334:	b510      	push	{r4, lr}
		if (!atomic_get(&conns[i].ref)) {
    9336:	4c0c      	ldr	r4, [pc, #48]	; (9368 <bt_conn_lookup_addr_le+0x34>)
{
    9338:	4603      	mov	r3, r0
		if (!atomic_get(&conns[i].ref)) {
    933a:	f104 0050 	add.w	r0, r4, #80	; 0x50
{
    933e:	460a      	mov	r2, r1
		if (!atomic_get(&conns[i].ref)) {
    9340:	f01d f8bf 	bl	264c2 <atomic_get>
    9344:	b908      	cbnz	r0, 934a <bt_conn_lookup_addr_le+0x16>
	return NULL;
    9346:	2000      	movs	r0, #0
}
    9348:	bd10      	pop	{r4, pc}
		if (conns[i].type != BT_CONN_TYPE_LE) {
    934a:	78a1      	ldrb	r1, [r4, #2]
    934c:	2901      	cmp	r1, #1
    934e:	d1fa      	bne.n	9346 <bt_conn_lookup_addr_le+0x12>
		if (bt_conn_is_peer_addr_le(&conns[i], id, peer)) {
    9350:	4619      	mov	r1, r3
    9352:	4620      	mov	r0, r4
    9354:	f01d f908 	bl	26568 <bt_conn_is_peer_addr_le>
    9358:	2800      	cmp	r0, #0
    935a:	d0f4      	beq.n	9346 <bt_conn_lookup_addr_le+0x12>
	atomic_val_t old = atomic_inc(&conn->ref);
    935c:	f104 0050 	add.w	r0, r4, #80	; 0x50
    9360:	f01d f8cd 	bl	264fe <atomic_inc>
		if (bt_conn_is_peer_addr_le(&conns[i], id, peer)) {
    9364:	4620      	mov	r0, r4
			return bt_conn_ref(&conns[i]);
    9366:	e7ef      	b.n	9348 <bt_conn_lookup_addr_le+0x14>
    9368:	20000560 	.word	0x20000560

0000936c <bt_conn_lookup_state_le>:
{
    936c:	b570      	push	{r4, r5, r6, lr}
		if (!atomic_get(&conns[i].ref)) {
    936e:	4c10      	ldr	r4, [pc, #64]	; (93b0 <bt_conn_lookup_state_le+0x44>)
{
    9370:	4605      	mov	r5, r0
		if (!atomic_get(&conns[i].ref)) {
    9372:	f104 0050 	add.w	r0, r4, #80	; 0x50
{
    9376:	4616      	mov	r6, r2
		if (!atomic_get(&conns[i].ref)) {
    9378:	f01d f8a3 	bl	264c2 <atomic_get>
    937c:	b908      	cbnz	r0, 9382 <bt_conn_lookup_state_le+0x16>
	return NULL;
    937e:	2000      	movs	r0, #0
}
    9380:	bd70      	pop	{r4, r5, r6, pc}
		if (conns[i].type != BT_CONN_TYPE_LE) {
    9382:	78a3      	ldrb	r3, [r4, #2]
    9384:	2b01      	cmp	r3, #1
    9386:	d1fa      	bne.n	937e <bt_conn_lookup_state_le+0x12>
		if (peer && !bt_conn_is_peer_addr_le(&conns[i], id, peer)) {
    9388:	b951      	cbnz	r1, 93a0 <bt_conn_lookup_state_le+0x34>
		if (conns[i].state == state && conns[i].id == id) {
    938a:	7aa3      	ldrb	r3, [r4, #10]
    938c:	42b3      	cmp	r3, r6
    938e:	d1f6      	bne.n	937e <bt_conn_lookup_state_le+0x12>
    9390:	7a23      	ldrb	r3, [r4, #8]
    9392:	42ab      	cmp	r3, r5
    9394:	d1f3      	bne.n	937e <bt_conn_lookup_state_le+0x12>
	atomic_val_t old = atomic_inc(&conn->ref);
    9396:	4807      	ldr	r0, [pc, #28]	; (93b4 <bt_conn_lookup_state_le+0x48>)
    9398:	f01d f8b1 	bl	264fe <atomic_inc>
			return bt_conn_ref(&conns[i]);
    939c:	4804      	ldr	r0, [pc, #16]	; (93b0 <bt_conn_lookup_state_le+0x44>)
    939e:	e7ef      	b.n	9380 <bt_conn_lookup_state_le+0x14>
		if (peer && !bt_conn_is_peer_addr_le(&conns[i], id, peer)) {
    93a0:	460a      	mov	r2, r1
    93a2:	4620      	mov	r0, r4
    93a4:	4629      	mov	r1, r5
    93a6:	f01d f8df 	bl	26568 <bt_conn_is_peer_addr_le>
    93aa:	2800      	cmp	r0, #0
    93ac:	d1ed      	bne.n	938a <bt_conn_lookup_state_le+0x1e>
    93ae:	e7e6      	b.n	937e <bt_conn_lookup_state_le+0x12>
    93b0:	20000560 	.word	0x20000560
    93b4:	200005b0 	.word	0x200005b0

000093b8 <send_conn_le_param_update>:
{
    93b8:	b538      	push	{r3, r4, r5, lr}
    93ba:	4604      	mov	r4, r0
	if (!bt_le_conn_params_valid(param)) {
    93bc:	4608      	mov	r0, r1
{
    93be:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
    93c0:	f01d f803 	bl	263ca <bt_le_conn_params_valid>
    93c4:	b308      	cbz	r0, 940a <send_conn_le_param_update+0x52>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    93c6:	4b12      	ldr	r3, [pc, #72]	; (9410 <send_conn_le_param_update+0x58>)
    93c8:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
    93cc:	0799      	lsls	r1, r3, #30
    93ce:	d407      	bmi.n	93e0 <send_conn_le_param_update+0x28>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
    93d0:	78e3      	ldrb	r3, [r4, #3]
    93d2:	b173      	cbz	r3, 93f2 <send_conn_le_param_update+0x3a>
	return bt_l2cap_update_conn_param(conn, param);
    93d4:	4629      	mov	r1, r5
    93d6:	4620      	mov	r0, r4
}
    93d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_l2cap_update_conn_param(conn, param);
    93dc:	f000 bb2a 	b.w	9a34 <bt_l2cap_update_conn_param>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    93e0:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
    93e4:	079a      	lsls	r2, r3, #30
    93e6:	d5f3      	bpl.n	93d0 <send_conn_le_param_update+0x18>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    93e8:	1d20      	adds	r0, r4, #4
    93ea:	f01d f86a 	bl	264c2 <atomic_get>
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
    93ee:	0543      	lsls	r3, r0, #21
    93f0:	d4ee      	bmi.n	93d0 <send_conn_le_param_update+0x18>
		rc = bt_conn_le_conn_update(conn, param);
    93f2:	4629      	mov	r1, r5
    93f4:	4620      	mov	r0, r4
    93f6:	f01d f90a 	bl	2660e <bt_conn_le_conn_update>
		if (rc == 0) {
    93fa:	b928      	cbnz	r0, 9408 <send_conn_le_param_update+0x50>
			conn->le.pending_latency = param->latency;
    93fc:	88ab      	ldrh	r3, [r5, #4]
    93fe:	f8a4 3094 	strh.w	r3, [r4, #148]	; 0x94
			conn->le.pending_timeout = param->timeout;
    9402:	88eb      	ldrh	r3, [r5, #6]
    9404:	f8a4 3096 	strh.w	r3, [r4, #150]	; 0x96
}
    9408:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    940a:	f06f 0015 	mvn.w	r0, #21
    940e:	e7fb      	b.n	9408 <send_conn_le_param_update+0x50>
    9410:	20006860 	.word	0x20006860

00009414 <conn_update_timeout>:
{
    9414:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (conn->state == BT_CONN_DISCONNECTED) {
    9416:	f810 3c4a 	ldrb.w	r3, [r0, #-74]
{
    941a:	4604      	mov	r4, r0
	struct bt_conn *conn = CONTAINER_OF(work, struct bt_conn, update_work);
    941c:	f1a0 0654 	sub.w	r6, r0, #84	; 0x54
	if (conn->state == BT_CONN_DISCONNECTED) {
    9420:	b9f3      	cbnz	r3, 9460 <conn_update_timeout+0x4c>
		bt_l2cap_disconnected(conn);
    9422:	4630      	mov	r0, r6
    9424:	f01d f950 	bl	266c8 <bt_l2cap_disconnected>
	for (cb = callback_list; cb; cb = cb->_next) {
    9428:	4b25      	ldr	r3, [pc, #148]	; (94c0 <conn_update_timeout+0xac>)
    942a:	681d      	ldr	r5, [r3, #0]
    942c:	b985      	cbnz	r5, 9450 <conn_update_timeout+0x3c>
	atomic_val_t old = atomic_dec(&conn->ref);
    942e:	1f20      	subs	r0, r4, #4
    9430:	f01d f858 	bl	264e4 <atomic_dec>
    9434:	4823      	ldr	r0, [pc, #140]	; (94c4 <conn_update_timeout+0xb0>)
    9436:	f01d f844 	bl	264c2 <atomic_get>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    943a:	0581      	lsls	r1, r0, #22
    943c:	d506      	bpl.n	944c <conn_update_timeout+0x38>
    943e:	4821      	ldr	r0, [pc, #132]	; (94c4 <conn_update_timeout+0xb0>)
    9440:	f01d f83f 	bl	264c2 <atomic_get>
		    atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
    9444:	0682      	lsls	r2, r0, #26
    9446:	d401      	bmi.n	944c <conn_update_timeout+0x38>
			bt_le_adv_resume();
    9448:	f7ff f886 	bl	8558 <bt_le_adv_resume>
}
    944c:	b002      	add	sp, #8
    944e:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->disconnected) {
    9450:	686b      	ldr	r3, [r5, #4]
    9452:	b11b      	cbz	r3, 945c <conn_update_timeout+0x48>
			cb->disconnected(conn, conn->err);
    9454:	f814 1c4b 	ldrb.w	r1, [r4, #-75]
    9458:	4630      	mov	r0, r6
    945a:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    945c:	692d      	ldr	r5, [r5, #16]
    945e:	e7e5      	b.n	942c <conn_update_timeout+0x18>
	if (conn->type != BT_CONN_TYPE_LE) {
    9460:	f810 3c52 	ldrb.w	r3, [r0, #-82]
    9464:	2b01      	cmp	r3, #1
    9466:	d1f1      	bne.n	944c <conn_update_timeout+0x38>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    9468:	f3bf 8f5b 	dmb	ish
		if (atomic_test_and_clear_bit(conn->flags,
    946c:	f1a0 0550 	sub.w	r5, r0, #80	; 0x50
    9470:	e855 3f00 	ldrex	r3, [r5]
    9474:	f423 7200 	bic.w	r2, r3, #512	; 0x200
    9478:	e845 2100 	strex	r1, r2, [r5]
    947c:	2900      	cmp	r1, #0
    947e:	d1f7      	bne.n	9470 <conn_update_timeout+0x5c>
    9480:	f3bf 8f5b 	dmb	ish
    9484:	059b      	lsls	r3, r3, #22
    9486:	d514      	bpl.n	94b2 <conn_update_timeout+0x9e>
			param = BT_LE_CONN_PARAM(conn->le.interval_min,
    9488:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    948a:	9300      	str	r3, [sp, #0]
    948c:	6c23      	ldr	r3, [r4, #64]	; 0x40
    948e:	9301      	str	r3, [sp, #4]
			send_conn_le_param_update(conn, param);
    9490:	4669      	mov	r1, sp
    9492:	4630      	mov	r0, r6
    9494:	f7ff ff90 	bl	93b8 <send_conn_le_param_update>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    9498:	f3bf 8f5b 	dmb	ish
    949c:	e855 3f00 	ldrex	r3, [r5]
    94a0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    94a4:	e845 3200 	strex	r2, r3, [r5]
    94a8:	2a00      	cmp	r2, #0
    94aa:	d1f7      	bne.n	949c <conn_update_timeout+0x88>
    94ac:	f3bf 8f5b 	dmb	ish
    94b0:	e7cc      	b.n	944c <conn_update_timeout+0x38>
			param = BT_LE_CONN_PARAM(
    94b2:	4a05      	ldr	r2, [pc, #20]	; (94c8 <conn_update_timeout+0xb4>)
    94b4:	6810      	ldr	r0, [r2, #0]
    94b6:	6851      	ldr	r1, [r2, #4]
    94b8:	466b      	mov	r3, sp
    94ba:	c303      	stmia	r3!, {r0, r1}
    94bc:	e7e8      	b.n	9490 <conn_update_timeout+0x7c>
    94be:	bf00      	nop
    94c0:	2000051c 	.word	0x2000051c
    94c4:	200068ec 	.word	0x200068ec
    94c8:	00029a94 	.word	0x00029a94

000094cc <bt_conn_create_pdu_timeout>:
						 const char *func, int line)
#else
struct net_buf *bt_conn_create_pdu_timeout(struct net_buf_pool *pool,
					   size_t reserve, s32_t timeout)
#endif
{
    94cc:	b570      	push	{r4, r5, r6, lr}
    94ce:	4604      	mov	r4, r0
    94d0:	460e      	mov	r6, r1
    94d2:	4615      	mov	r5, r2

	/*
	 * PDU must not be allocated from ISR as we block with 'K_FOREVER'
	 * during the allocation
	 */
	__ASSERT_NO_MSG(!k_is_in_isr());
    94d4:	f01f ff10 	bl	292f8 <k_is_in_isr>
    94d8:	b158      	cbz	r0, 94f2 <bt_conn_create_pdu_timeout+0x26>
    94da:	4913      	ldr	r1, [pc, #76]	; (9528 <bt_conn_create_pdu_timeout+0x5c>)
    94dc:	4813      	ldr	r0, [pc, #76]	; (952c <bt_conn_create_pdu_timeout+0x60>)
    94de:	4a14      	ldr	r2, [pc, #80]	; (9530 <bt_conn_create_pdu_timeout+0x64>)
    94e0:	f640 13b1 	movw	r3, #2481	; 0x9b1
    94e4:	f01a fcfd 	bl	23ee2 <printk>
    94e8:	4811      	ldr	r0, [pc, #68]	; (9530 <bt_conn_create_pdu_timeout+0x64>)
    94ea:	f640 11b1 	movw	r1, #2481	; 0x9b1
    94ee:	f01a fd3b 	bl	23f68 <assert_post_action>
	} else {
#if defined(CONFIG_NET_BUF_LOG)
		buf = net_buf_alloc_fixed_debug(pool, timeout, func,
							line);
#else
		buf = net_buf_alloc(pool, timeout);
    94f2:	4810      	ldr	r0, [pc, #64]	; (9534 <bt_conn_create_pdu_timeout+0x68>)
    94f4:	4629      	mov	r1, r5
    94f6:	2c00      	cmp	r4, #0
    94f8:	bf18      	it	ne
    94fa:	4620      	movne	r0, r4
    94fc:	f01f fbfd 	bl	28cfa <net_buf_alloc_fixed>
#endif
	}

	if (!buf) {
    9500:	4604      	mov	r4, r0
    9502:	b960      	cbnz	r0, 951e <bt_conn_create_pdu_timeout+0x52>
    9504:	4a0c      	ldr	r2, [pc, #48]	; (9538 <bt_conn_create_pdu_timeout+0x6c>)
    9506:	4b0d      	ldr	r3, [pc, #52]	; (953c <bt_conn_create_pdu_timeout+0x70>)
		BT_WARN("Unable to allocate buffer: timeout %d", timeout);
    9508:	480d      	ldr	r0, [pc, #52]	; (9540 <bt_conn_create_pdu_timeout+0x74>)
    950a:	1a9b      	subs	r3, r3, r2
    950c:	08db      	lsrs	r3, r3, #3
    950e:	019b      	lsls	r3, r3, #6
    9510:	f043 0202 	orr.w	r2, r3, #2
    9514:	4629      	mov	r1, r5
    9516:	f01a fd62 	bl	23fde <log_1>

	reserve += sizeof(struct bt_hci_acl_hdr) + BT_BUF_RESERVE;
	net_buf_reserve(buf, reserve);

	return buf;
}
    951a:	4620      	mov	r0, r4
    951c:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_reserve(buf, reserve);
    951e:	1d31      	adds	r1, r6, #4
    9520:	3008      	adds	r0, #8
    9522:	f015 fccd 	bl	1eec0 <net_buf_simple_reserve>
	return buf;
    9526:	e7f8      	b.n	951a <bt_conn_create_pdu_timeout+0x4e>
    9528:	0002c582 	.word	0x0002c582
    952c:	0002a5e8 	.word	0x0002a5e8
    9530:	0002c3be 	.word	0x0002c3be
    9534:	20007670 	.word	0x20007670
    9538:	00029830 	.word	0x00029830
    953c:	00029840 	.word	0x00029840
    9540:	0002c591 	.word	0x0002c591

00009544 <bt_conn_create_frag_timeout>:
{
    9544:	460a      	mov	r2, r1
	return bt_conn_create_pdu_timeout(pool, reserve, timeout);
    9546:	4601      	mov	r1, r0
    9548:	4801      	ldr	r0, [pc, #4]	; (9550 <bt_conn_create_frag_timeout+0xc>)
    954a:	f7ff bfbf 	b.w	94cc <bt_conn_create_pdu_timeout>
    954e:	bf00      	nop
    9550:	20007700 	.word	0x20007700

00009554 <create_frag.isra.0>:
static struct net_buf *create_frag(struct bt_conn *conn, struct net_buf *buf)
    9554:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9558:	4606      	mov	r6, r0
    955a:	460c      	mov	r4, r1
	frag = bt_conn_create_frag(0);
    955c:	2000      	movs	r0, #0
    955e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    9562:	f7ff ffef 	bl	9544 <bt_conn_create_frag_timeout>
	if (conn->state != BT_CONN_CONNECTED) {
    9566:	7833      	ldrb	r3, [r6, #0]
    9568:	2b06      	cmp	r3, #6
	frag = bt_conn_create_frag(0);
    956a:	4605      	mov	r5, r0
	if (conn->state != BT_CONN_CONNECTED) {
    956c:	f04f 0600 	mov.w	r6, #0
    9570:	d005      	beq.n	957e <create_frag.isra.0+0x2a>
		net_buf_unref(frag);
    9572:	f015 fda9 	bl	1f0c8 <net_buf_unref>
		return NULL;
    9576:	4635      	mov	r5, r6
}
    9578:	4628      	mov	r0, r5
    957a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tx_data(frag)->tx = NULL;
    957e:	6146      	str	r6, [r0, #20]
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    9580:	f100 0708 	add.w	r7, r0, #8
	return bt_dev.le.mtu;
    9584:	4e0c      	ldr	r6, [pc, #48]	; (95b8 <create_frag.isra.0+0x64>)
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    9586:	4638      	mov	r0, r7
    9588:	f8b6 80a0 	ldrh.w	r8, [r6, #160]	; 0xa0
    958c:	f01f fc0b 	bl	28da6 <net_buf_simple_tailroom>
    9590:	4580      	cmp	r8, r0
    9592:	d20c      	bcs.n	95ae <create_frag.isra.0+0x5a>
	return bt_dev.le.mtu;
    9594:	f8b6 60a0 	ldrh.w	r6, [r6, #160]	; 0xa0
	net_buf_add_mem(frag, buf->data, frag_len);
    9598:	f854 1f08 	ldr.w	r1, [r4, #8]!
    959c:	4632      	mov	r2, r6
    959e:	4638      	mov	r0, r7
    95a0:	f01f fc09 	bl	28db6 <net_buf_simple_add_mem>
	net_buf_pull(buf, frag_len);
    95a4:	4631      	mov	r1, r6
    95a6:	4620      	mov	r0, r4
    95a8:	f015 fe54 	bl	1f254 <net_buf_simple_pull>
	return frag;
    95ac:	e7e4      	b.n	9578 <create_frag.isra.0+0x24>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    95ae:	4638      	mov	r0, r7
    95b0:	f01f fbf9 	bl	28da6 <net_buf_simple_tailroom>
    95b4:	b286      	uxth	r6, r0
    95b6:	e7ef      	b.n	9598 <create_frag.isra.0+0x44>
    95b8:	20006860 	.word	0x20006860

000095bc <bt_conn_process_tx>:
{
    95bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (conn->state == BT_CONN_DISCONNECTED &&
    95be:	7a83      	ldrb	r3, [r0, #10]
{
    95c0:	4605      	mov	r5, r0
	if (conn->state == BT_CONN_DISCONNECTED &&
    95c2:	b993      	cbnz	r3, 95ea <bt_conn_process_tx+0x2e>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    95c4:	f3bf 8f5b 	dmb	ish
    95c8:	1d03      	adds	r3, r0, #4
    95ca:	e853 2f00 	ldrex	r2, [r3]
    95ce:	f022 0140 	bic.w	r1, r2, #64	; 0x40
    95d2:	e843 1400 	strex	r4, r1, [r3]
    95d6:	2c00      	cmp	r4, #0
    95d8:	d1f7      	bne.n	95ca <bt_conn_process_tx+0xe>
    95da:	f3bf 8f5b 	dmb	ish
    95de:	0653      	lsls	r3, r2, #25
    95e0:	d503      	bpl.n	95ea <bt_conn_process_tx+0x2e>
}
    95e2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		conn_cleanup(conn);
    95e6:	f7ff bb9b 	b.w	8d20 <conn_cleanup>
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
    95ea:	2100      	movs	r1, #0
    95ec:	f105 0034 	add.w	r0, r5, #52	; 0x34
    95f0:	f015 fc32 	bl	1ee58 <net_buf_get>
	BT_ASSERT(buf);
    95f4:	4604      	mov	r4, r0
    95f6:	b960      	cbnz	r0, 9612 <bt_conn_process_tx+0x56>
    95f8:	4a20      	ldr	r2, [pc, #128]	; (967c <bt_conn_process_tx+0xc0>)
    95fa:	4921      	ldr	r1, [pc, #132]	; (9680 <bt_conn_process_tx+0xc4>)
    95fc:	4821      	ldr	r0, [pc, #132]	; (9684 <bt_conn_process_tx+0xc8>)
    95fe:	f240 631b 	movw	r3, #1563	; 0x61b
    9602:	f01a fc6e 	bl	23ee2 <printk>
    9606:	4040      	eors	r0, r0
    9608:	f380 8811 	msr	BASEPRI, r0
    960c:	f04f 0003 	mov.w	r0, #3
    9610:	df02      	svc	2
	return bt_dev.le.mtu;
    9612:	4f1d      	ldr	r7, [pc, #116]	; (9688 <bt_conn_process_tx+0xcc>)
	if (buf->len <= conn_mtu(conn)) {
    9614:	89a1      	ldrh	r1, [r4, #12]
    9616:	f8b7 20a0 	ldrh.w	r2, [r7, #160]	; 0xa0
    961a:	4291      	cmp	r1, r2
    961c:	d807      	bhi.n	962e <bt_conn_process_tx+0x72>
		return send_frag(conn, buf, BT_ACL_START_NO_FLUSH, false);
    961e:	2300      	movs	r3, #0
    9620:	461a      	mov	r2, r3
	return send_frag(conn, buf, BT_ACL_CONT, false);
    9622:	4621      	mov	r1, r4
    9624:	4628      	mov	r0, r5
    9626:	f7ff facf 	bl	8bc8 <send_frag>
	if (!send_buf(conn, buf)) {
    962a:	b140      	cbz	r0, 963e <bt_conn_process_tx+0x82>
}
    962c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	frag = create_frag(conn, buf);
    962e:	f105 060a 	add.w	r6, r5, #10
    9632:	4621      	mov	r1, r4
    9634:	4630      	mov	r0, r6
    9636:	f7ff ff8d 	bl	9554 <create_frag.isra.0>
	if (!frag) {
    963a:	4601      	mov	r1, r0
    963c:	b920      	cbnz	r0, 9648 <bt_conn_process_tx+0x8c>
		net_buf_unref(buf);
    963e:	4620      	mov	r0, r4
}
    9640:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		net_buf_unref(buf);
    9644:	f015 bd40 	b.w	1f0c8 <net_buf_unref>
	if (!send_frag(conn, frag, BT_ACL_START_NO_FLUSH, true)) {
    9648:	2301      	movs	r3, #1
    964a:	2200      	movs	r2, #0
		if (!send_frag(conn, frag, BT_ACL_CONT, true)) {
    964c:	4628      	mov	r0, r5
    964e:	f7ff fabb 	bl	8bc8 <send_frag>
    9652:	2800      	cmp	r0, #0
    9654:	d0f3      	beq.n	963e <bt_conn_process_tx+0x82>
	while (buf->len > conn_mtu(conn)) {
    9656:	89a2      	ldrh	r2, [r4, #12]
    9658:	f8b7 30a0 	ldrh.w	r3, [r7, #160]	; 0xa0
    965c:	429a      	cmp	r2, r3
    965e:	d802      	bhi.n	9666 <bt_conn_process_tx+0xaa>
	return send_frag(conn, buf, BT_ACL_CONT, false);
    9660:	2300      	movs	r3, #0
    9662:	2201      	movs	r2, #1
    9664:	e7dd      	b.n	9622 <bt_conn_process_tx+0x66>
		frag = create_frag(conn, buf);
    9666:	4621      	mov	r1, r4
    9668:	4630      	mov	r0, r6
    966a:	f7ff ff73 	bl	9554 <create_frag.isra.0>
		if (!frag) {
    966e:	4601      	mov	r1, r0
    9670:	2800      	cmp	r0, #0
    9672:	d0e4      	beq.n	963e <bt_conn_process_tx+0x82>
		if (!send_frag(conn, frag, BT_ACL_CONT, true)) {
    9674:	2301      	movs	r3, #1
    9676:	461a      	mov	r2, r3
    9678:	e7e8      	b.n	964c <bt_conn_process_tx+0x90>
    967a:	bf00      	nop
    967c:	0002c3be 	.word	0x0002c3be
    9680:	00030dcd 	.word	0x00030dcd
    9684:	0002a5e8 	.word	0x0002a5e8
    9688:	20006860 	.word	0x20006860

0000968c <bt_conn_index>:
}
#endif /* CONFIG_BT_SMP || CONFIG_BT_BREDR */

u8_t bt_conn_index(struct bt_conn *conn)
{
	u8_t index = conn - conns;
    968c:	4b0c      	ldr	r3, [pc, #48]	; (96c0 <bt_conn_index+0x34>)
    968e:	1ac0      	subs	r0, r0, r3
    9690:	1083      	asrs	r3, r0, #2
    9692:	480c      	ldr	r0, [pc, #48]	; (96c4 <bt_conn_index+0x38>)
    9694:	4358      	muls	r0, r3
{
    9696:	b510      	push	{r4, lr}

	__ASSERT(index < CONFIG_BT_MAX_CONN, "Invalid bt_conn pointer");
    9698:	f010 04ff 	ands.w	r4, r0, #255	; 0xff
    969c:	d00e      	beq.n	96bc <bt_conn_index+0x30>
    969e:	490a      	ldr	r1, [pc, #40]	; (96c8 <bt_conn_index+0x3c>)
    96a0:	4a0a      	ldr	r2, [pc, #40]	; (96cc <bt_conn_index+0x40>)
    96a2:	480b      	ldr	r0, [pc, #44]	; (96d0 <bt_conn_index+0x44>)
    96a4:	f640 2368 	movw	r3, #2664	; 0xa68
    96a8:	f01a fc1b 	bl	23ee2 <printk>
    96ac:	4809      	ldr	r0, [pc, #36]	; (96d4 <bt_conn_index+0x48>)
    96ae:	f01a fc18 	bl	23ee2 <printk>
    96b2:	4806      	ldr	r0, [pc, #24]	; (96cc <bt_conn_index+0x40>)
    96b4:	f640 2168 	movw	r1, #2664	; 0xa68
    96b8:	f01a fc56 	bl	23f68 <assert_post_action>
	return index;
}
    96bc:	4620      	mov	r0, r4
    96be:	bd10      	pop	{r4, pc}
    96c0:	20000560 	.word	0x20000560
    96c4:	c18f9c19 	.word	0xc18f9c19
    96c8:	0002c5b7 	.word	0x0002c5b7
    96cc:	0002c3be 	.word	0x0002c3be
    96d0:	0002a5e8 	.word	0x0002a5e8
    96d4:	0002c5c1 	.word	0x0002c5c1

000096d8 <bt_conn_init>:

	return bt_conn_ref(conn);
}

int bt_conn_init(void)
{
    96d8:	b510      	push	{r4, lr}
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
		k_fifo_put(&free_tx, &conn_tx[i]);
    96da:	490d      	ldr	r1, [pc, #52]	; (9710 <bt_conn_init+0x38>)
    96dc:	480d      	ldr	r0, [pc, #52]	; (9714 <bt_conn_init+0x3c>)
    96de:	f01f fdb8 	bl	29252 <k_queue_append>
    96e2:	490d      	ldr	r1, [pc, #52]	; (9718 <bt_conn_init+0x40>)
    96e4:	480b      	ldr	r0, [pc, #44]	; (9714 <bt_conn_init+0x3c>)
    96e6:	f01f fdb4 	bl	29252 <k_queue_append>
    96ea:	490c      	ldr	r1, [pc, #48]	; (971c <bt_conn_init+0x44>)
    96ec:	4809      	ldr	r0, [pc, #36]	; (9714 <bt_conn_init+0x3c>)
    96ee:	f01f fdb0 	bl	29252 <k_queue_append>
    96f2:	490b      	ldr	r1, [pc, #44]	; (9720 <bt_conn_init+0x48>)
    96f4:	4807      	ldr	r0, [pc, #28]	; (9714 <bt_conn_init+0x3c>)
    96f6:	f01f fdac 	bl	29252 <k_queue_append>
	}

	bt_att_init();
    96fa:	f01d fa60 	bl	26bbe <bt_att_init>

	err = bt_smp_init();
    96fe:	f01d fc67 	bl	26fd0 <bt_smp_init>
	if (err) {
    9702:	4604      	mov	r4, r0
    9704:	b908      	cbnz	r0, 970a <bt_conn_init+0x32>
		return err;
	}

	bt_l2cap_init();
    9706:	f01d f830 	bl	2676a <bt_l2cap_init>
#endif /* !defined(CONFIG_BT_WHITELIST) */
		}
	}

	return 0;
}
    970a:	4620      	mov	r0, r4
    970c:	bd10      	pop	{r4, pc}
    970e:	bf00      	nop
    9710:	20000520 	.word	0x20000520
    9714:	20007634 	.word	0x20007634
    9718:	20000530 	.word	0x20000530
    971c:	20000540 	.word	0x20000540
    9720:	20000550 	.word	0x20000550

00009724 <l2cap_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
		struct bt_l2cap *l2cap = &bt_l2cap_pool[i];

		if (l2cap->chan.chan.conn) {
    9724:	4a0b      	ldr	r2, [pc, #44]	; (9754 <l2cap_accept+0x30>)
{
    9726:	b508      	push	{r3, lr}
    9728:	4603      	mov	r3, r0
		if (l2cap->chan.chan.conn) {
    972a:	6810      	ldr	r0, [r2, #0]
    972c:	b918      	cbnz	r0, 9736 <l2cap_accept+0x12>
			continue;
		}

		l2cap->chan.chan.ops = &ops;
    972e:	4b0a      	ldr	r3, [pc, #40]	; (9758 <l2cap_accept+0x34>)
    9730:	6053      	str	r3, [r2, #4]
		*chan = &l2cap->chan.chan;
    9732:	600a      	str	r2, [r1, #0]
	}

	BT_ERR("No available L2CAP context for conn %p", conn);

	return -ENOMEM;
}
    9734:	bd08      	pop	{r3, pc}
    9736:	4909      	ldr	r1, [pc, #36]	; (975c <l2cap_accept+0x38>)
    9738:	4a09      	ldr	r2, [pc, #36]	; (9760 <l2cap_accept+0x3c>)
	BT_ERR("No available L2CAP context for conn %p", conn);
    973a:	480a      	ldr	r0, [pc, #40]	; (9764 <l2cap_accept+0x40>)
    973c:	1a52      	subs	r2, r2, r1
    973e:	08d2      	lsrs	r2, r2, #3
    9740:	0192      	lsls	r2, r2, #6
    9742:	f042 0201 	orr.w	r2, r2, #1
    9746:	4619      	mov	r1, r3
    9748:	f01a fc49 	bl	23fde <log_1>
	return -ENOMEM;
    974c:	f06f 000b 	mvn.w	r0, #11
    9750:	e7f0      	b.n	9734 <l2cap_accept+0x10>
    9752:	bf00      	nop
    9754:	20000604 	.word	0x20000604
    9758:	00029ed8 	.word	0x00029ed8
    975c:	00029830 	.word	0x00029830
    9760:	00029900 	.word	0x00029900
    9764:	0002c624 	.word	0x0002c624

00009768 <l2cap_create_le_sig_pdu.isra.0>:
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
    9768:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    976a:	4605      	mov	r5, r0
    976c:	460f      	mov	r7, r1
    976e:	4616      	mov	r6, r2
	return bt_conn_create_pdu_timeout(pool,
    9770:	2104      	movs	r1, #4
    9772:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
    9776:	2000      	movs	r0, #0
    9778:	f7ff fea8 	bl	94cc <bt_conn_create_pdu_timeout>
	if (!buf) {
    977c:	4604      	mov	r4, r0
    977e:	b960      	cbnz	r0, 979a <l2cap_create_le_sig_pdu.isra.0+0x32>
    9780:	4a0a      	ldr	r2, [pc, #40]	; (97ac <l2cap_create_le_sig_pdu.isra.0+0x44>)
    9782:	4b0b      	ldr	r3, [pc, #44]	; (97b0 <l2cap_create_le_sig_pdu.isra.0+0x48>)
		BT_ERR("Unable to allocate buffer for op 0x%02x", code);
    9784:	480b      	ldr	r0, [pc, #44]	; (97b4 <l2cap_create_le_sig_pdu.isra.0+0x4c>)
    9786:	1ad2      	subs	r2, r2, r3
    9788:	08d2      	lsrs	r2, r2, #3
    978a:	0192      	lsls	r2, r2, #6
    978c:	f042 0201 	orr.w	r2, r2, #1
    9790:	4629      	mov	r1, r5
    9792:	f01a fc24 	bl	23fde <log_1>
}
    9796:	4620      	mov	r0, r4
    9798:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_add(buf, sizeof(*hdr));
    979a:	2104      	movs	r1, #4
    979c:	3008      	adds	r0, #8
    979e:	f015 fd9b 	bl	1f2d8 <net_buf_simple_add>
	hdr->code = code;
    97a2:	7005      	strb	r5, [r0, #0]
	hdr->ident = ident;
    97a4:	7047      	strb	r7, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
    97a6:	8046      	strh	r6, [r0, #2]
	return buf;
    97a8:	e7f5      	b.n	9796 <l2cap_create_le_sig_pdu.isra.0+0x2e>
    97aa:	bf00      	nop
    97ac:	00029900 	.word	0x00029900
    97b0:	00029830 	.word	0x00029830
    97b4:	0002c64b 	.word	0x0002c64b

000097b8 <l2cap_rtx_timeout>:
{
    97b8:	b538      	push	{r3, r4, r5, lr}
    97ba:	4a0c      	ldr	r2, [pc, #48]	; (97ec <l2cap_rtx_timeout+0x34>)
    97bc:	4b0c      	ldr	r3, [pc, #48]	; (97f0 <l2cap_rtx_timeout+0x38>)
    97be:	1ad2      	subs	r2, r2, r3
    97c0:	08d2      	lsrs	r2, r2, #3
	struct bt_l2cap_le_chan *chan = LE_CHAN_RTX(work);
    97c2:	f1a0 0510 	sub.w	r5, r0, #16
{
    97c6:	4604      	mov	r4, r0
	BT_ERR("chan %p timeout", chan);
    97c8:	0192      	lsls	r2, r2, #6
    97ca:	4629      	mov	r1, r5
    97cc:	4809      	ldr	r0, [pc, #36]	; (97f4 <l2cap_rtx_timeout+0x3c>)
    97ce:	f042 0201 	orr.w	r2, r2, #1
    97d2:	f01a fc04 	bl	23fde <log_1>
	bt_l2cap_chan_remove(chan->chan.conn, &chan->chan);
    97d6:	f854 0c10 	ldr.w	r0, [r4, #-16]
    97da:	4629      	mov	r1, r5
    97dc:	f01c ff41 	bl	26662 <bt_l2cap_chan_remove>
	bt_l2cap_chan_del(&chan->chan);
    97e0:	4628      	mov	r0, r5
}
    97e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_l2cap_chan_del(&chan->chan);
    97e6:	f01c bf5e 	b.w	266a6 <bt_l2cap_chan_del>
    97ea:	bf00      	nop
    97ec:	00029900 	.word	0x00029900
    97f0:	00029830 	.word	0x00029830
    97f4:	0002c673 	.word	0x0002c673

000097f8 <bt_l2cap_connected>:
{
    97f8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    97fc:	4f31      	ldr	r7, [pc, #196]	; (98c4 <bt_l2cap_connected+0xcc>)
    97fe:	4e32      	ldr	r6, [pc, #200]	; (98c8 <bt_l2cap_connected+0xd0>)
    9800:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 98dc <bt_l2cap_connected+0xe4>
{
    9804:	4604      	mov	r4, r0
    9806:	46b9      	mov	r9, r7
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    9808:	42be      	cmp	r6, r7
    980a:	d90e      	bls.n	982a <bt_l2cap_connected+0x32>
    980c:	492f      	ldr	r1, [pc, #188]	; (98cc <bt_l2cap_connected+0xd4>)
    980e:	4830      	ldr	r0, [pc, #192]	; (98d0 <bt_l2cap_connected+0xd8>)
    9810:	f44f 73ab 	mov.w	r3, #342	; 0x156
    9814:	4642      	mov	r2, r8
    9816:	f01a fb64 	bl	23ee2 <printk>
    981a:	482e      	ldr	r0, [pc, #184]	; (98d4 <bt_l2cap_connected+0xdc>)
    981c:	f01a fb61 	bl	23ee2 <printk>
    9820:	f44f 71ab 	mov.w	r1, #342	; 0x156
    9824:	4640      	mov	r0, r8
    9826:	f01a fb9f 	bl	23f68 <assert_post_action>
    982a:	454e      	cmp	r6, r9
    982c:	d302      	bcc.n	9834 <bt_l2cap_connected+0x3c>
}
    982e:	b002      	add	sp, #8
    9830:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (fchan->accept(conn, &chan) < 0) {
    9834:	6873      	ldr	r3, [r6, #4]
    9836:	a901      	add	r1, sp, #4
    9838:	4620      	mov	r0, r4
    983a:	4798      	blx	r3
    983c:	2800      	cmp	r0, #0
    983e:	db3c      	blt.n	98ba <bt_l2cap_connected+0xc2>
		ch = BT_L2CAP_LE_CHAN(chan);
    9840:	9d01      	ldr	r5, [sp, #4]
		ch->rx.cid = fchan->cid;
    9842:	8833      	ldrh	r3, [r6, #0]
    9844:	86ab      	strh	r3, [r5, #52]	; 0x34
		ch->tx.cid = fchan->cid;
    9846:	f8a5 3040 	strh.w	r3, [r5, #64]	; 0x40
	k_delayed_work_init(&chan->rtx_work, l2cap_rtx_timeout);
    984a:	4923      	ldr	r1, [pc, #140]	; (98d8 <bt_l2cap_connected+0xe0>)
		if (!l2cap_chan_add(conn, chan, fchan->destroy)) {
    984c:	f8d6 a008 	ldr.w	sl, [r6, #8]
	k_delayed_work_init(&chan->rtx_work, l2cap_rtx_timeout);
    9850:	f105 0010 	add.w	r0, r5, #16
    9854:	f01f fdd1 	bl	293fa <k_delayed_work_init>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    9858:	f3bf 8f5b 	dmb	ish
    985c:	f105 0330 	add.w	r3, r5, #48	; 0x30
    9860:	2200      	movs	r2, #0
    9862:	e853 1f00 	ldrex	r1, [r3]
    9866:	e843 2000 	strex	r0, r2, [r3]
    986a:	2800      	cmp	r0, #0
    986c:	d1f9      	bne.n	9862 <bt_l2cap_connected+0x6a>
    986e:	f3bf 8f5b 	dmb	ish
	parent->next = child;
    9872:	60aa      	str	r2, [r5, #8]
Z_GENLIST_APPEND(slist, snode)
    9874:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
	sys_slist_append(&conn->channels, &chan->node);
    9876:	f105 0308 	add.w	r3, r5, #8
    987a:	bb02      	cbnz	r2, 98be <bt_l2cap_connected+0xc6>
	list->head = node;
    987c:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
		if (chan->ops->connected) {
    9880:	9801      	ldr	r0, [sp, #4]
	chan->conn = conn;
    9882:	602c      	str	r4, [r5, #0]
		if (chan->ops->connected) {
    9884:	6843      	ldr	r3, [r0, #4]
	chan->destroy = destroy;
    9886:	f8c5 a00c 	str.w	sl, [r5, #12]
		if (chan->ops->connected) {
    988a:	681b      	ldr	r3, [r3, #0]
    988c:	b103      	cbz	r3, 9890 <bt_l2cap_connected+0x98>
			chan->ops->connected(chan);
    988e:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    9890:	9b01      	ldr	r3, [sp, #4]
    9892:	f3bf 8f5b 	dmb	ish
    9896:	3330      	adds	r3, #48	; 0x30
    9898:	e853 2f00 	ldrex	r2, [r3]
    989c:	f042 0201 	orr.w	r2, r2, #1
    98a0:	e843 2100 	strex	r1, r2, [r3]
    98a4:	2900      	cmp	r1, #0
    98a6:	d1f7      	bne.n	9898 <bt_l2cap_connected+0xa0>
    98a8:	f3bf 8f5b 	dmb	ish
		if (chan->ops->status) {
    98ac:	9801      	ldr	r0, [sp, #4]
    98ae:	6843      	ldr	r3, [r0, #4]
    98b0:	699b      	ldr	r3, [r3, #24]
    98b2:	b113      	cbz	r3, 98ba <bt_l2cap_connected+0xc2>
			chan->ops->status(chan, chan->status);
    98b4:	f100 0130 	add.w	r1, r0, #48	; 0x30
    98b8:	4798      	blx	r3
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    98ba:	360c      	adds	r6, #12
    98bc:	e7a4      	b.n	9808 <bt_l2cap_connected+0x10>
	parent->next = child;
    98be:	6013      	str	r3, [r2, #0]
	list->tail = node;
    98c0:	64e3      	str	r3, [r4, #76]	; 0x4c
}
    98c2:	e7dd      	b.n	9880 <bt_l2cap_connected+0x88>
    98c4:	000297e4 	.word	0x000297e4
    98c8:	000297c0 	.word	0x000297c0
    98cc:	0002c6b4 	.word	0x0002c6b4
    98d0:	0002a5e8 	.word	0x0002a5e8
    98d4:	0002ad2b 	.word	0x0002ad2b
    98d8:	000097b9 	.word	0x000097b9
    98dc:	0002c683 	.word	0x0002c683

000098e0 <l2cap_recv>:
	if (buf->len < sizeof(*hdr)) {
    98e0:	898b      	ldrh	r3, [r1, #12]
    98e2:	2b03      	cmp	r3, #3
{
    98e4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    98e6:	4606      	mov	r6, r0
    98e8:	460d      	mov	r5, r1
	if (buf->len < sizeof(*hdr)) {
    98ea:	d80a      	bhi.n	9902 <l2cap_recv+0x22>
    98ec:	492e      	ldr	r1, [pc, #184]	; (99a8 <l2cap_recv+0xc8>)
    98ee:	4b2f      	ldr	r3, [pc, #188]	; (99ac <l2cap_recv+0xcc>)
		BT_ERR("Too small L2CAP signaling PDU");
    98f0:	482f      	ldr	r0, [pc, #188]	; (99b0 <l2cap_recv+0xd0>)
    98f2:	1ac9      	subs	r1, r1, r3
    98f4:	08c9      	lsrs	r1, r1, #3
    98f6:	0189      	lsls	r1, r1, #6
    98f8:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Invalid ident value in L2CAP PDU");
    98fc:	f01a fb62 	bl	23fc4 <log_0>
		return 0;
    9900:	e013      	b.n	992a <l2cap_recv+0x4a>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    9902:	2104      	movs	r1, #4
    9904:	f105 0008 	add.w	r0, r5, #8
    9908:	f015 fcc4 	bl	1f294 <net_buf_simple_pull_mem>
	if (buf->len != len) {
    990c:	89a9      	ldrh	r1, [r5, #12]
	len = sys_le16_to_cpu(hdr->len);
    990e:	8842      	ldrh	r2, [r0, #2]
	if (buf->len != len) {
    9910:	428a      	cmp	r2, r1
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    9912:	4604      	mov	r4, r0
	if (buf->len != len) {
    9914:	d00c      	beq.n	9930 <l2cap_recv+0x50>
    9916:	4825      	ldr	r0, [pc, #148]	; (99ac <l2cap_recv+0xcc>)
    9918:	4b23      	ldr	r3, [pc, #140]	; (99a8 <l2cap_recv+0xc8>)
    991a:	1a1b      	subs	r3, r3, r0
    991c:	08db      	lsrs	r3, r3, #3
		BT_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
    991e:	019b      	lsls	r3, r3, #6
    9920:	4824      	ldr	r0, [pc, #144]	; (99b4 <l2cap_recv+0xd4>)
    9922:	f043 0301 	orr.w	r3, r3, #1
    9926:	f01a fb6e 	bl	24006 <log_2>
}
    992a:	2000      	movs	r0, #0
    992c:	b002      	add	sp, #8
    992e:	bd70      	pop	{r4, r5, r6, pc}
	if (!hdr->ident) {
    9930:	7843      	ldrb	r3, [r0, #1]
    9932:	b943      	cbnz	r3, 9946 <l2cap_recv+0x66>
    9934:	491c      	ldr	r1, [pc, #112]	; (99a8 <l2cap_recv+0xc8>)
    9936:	4b1d      	ldr	r3, [pc, #116]	; (99ac <l2cap_recv+0xcc>)
		BT_ERR("Invalid ident value in L2CAP PDU");
    9938:	481f      	ldr	r0, [pc, #124]	; (99b8 <l2cap_recv+0xd8>)
    993a:	1ac9      	subs	r1, r1, r3
    993c:	08c9      	lsrs	r1, r1, #3
    993e:	0189      	lsls	r1, r1, #6
    9940:	f041 0101 	orr.w	r1, r1, #1
    9944:	e7da      	b.n	98fc <l2cap_recv+0x1c>
	switch (hdr->code) {
    9946:	7801      	ldrb	r1, [r0, #0]
    9948:	2901      	cmp	r1, #1
    994a:	d0ee      	beq.n	992a <l2cap_recv+0x4a>
    994c:	2913      	cmp	r1, #19
    994e:	d10a      	bne.n	9966 <l2cap_recv+0x86>
	if (buf->len < sizeof(*rsp)) {
    9950:	2a01      	cmp	r2, #1
    9952:	d8ea      	bhi.n	992a <l2cap_recv+0x4a>
    9954:	4914      	ldr	r1, [pc, #80]	; (99a8 <l2cap_recv+0xc8>)
    9956:	4b15      	ldr	r3, [pc, #84]	; (99ac <l2cap_recv+0xcc>)
		BT_ERR("Too small LE conn param rsp");
    9958:	4818      	ldr	r0, [pc, #96]	; (99bc <l2cap_recv+0xdc>)
    995a:	1ac9      	subs	r1, r1, r3
    995c:	08c9      	lsrs	r1, r1, #3
    995e:	0189      	lsls	r1, r1, #6
    9960:	f041 0101 	orr.w	r1, r1, #1
    9964:	e7ca      	b.n	98fc <l2cap_recv+0x1c>
    9966:	4b11      	ldr	r3, [pc, #68]	; (99ac <l2cap_recv+0xcc>)
    9968:	4a0f      	ldr	r2, [pc, #60]	; (99a8 <l2cap_recv+0xc8>)
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
    996a:	4815      	ldr	r0, [pc, #84]	; (99c0 <l2cap_recv+0xe0>)
    996c:	1ad2      	subs	r2, r2, r3
    996e:	08d2      	lsrs	r2, r2, #3
    9970:	0192      	lsls	r2, r2, #6
    9972:	f042 0202 	orr.w	r2, r2, #2
    9976:	f01a fb32 	bl	23fde <log_1>
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
    997a:	7861      	ldrb	r1, [r4, #1]
		l2cap_send_reject(chan->conn, hdr->ident,
    997c:	6835      	ldr	r5, [r6, #0]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
    997e:	2202      	movs	r2, #2
    9980:	2001      	movs	r0, #1
    9982:	f7ff fef1 	bl	9768 <l2cap_create_le_sig_pdu.isra.0>
	if (!buf) {
    9986:	4604      	mov	r4, r0
    9988:	2800      	cmp	r0, #0
    998a:	d0ce      	beq.n	992a <l2cap_recv+0x4a>
	rej = net_buf_add(buf, sizeof(*rej));
    998c:	2102      	movs	r1, #2
    998e:	3008      	adds	r0, #8
    9990:	f015 fca2 	bl	1f2d8 <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
    9994:	2300      	movs	r3, #0
    9996:	7003      	strb	r3, [r0, #0]
    9998:	7043      	strb	r3, [r0, #1]
		     bt_conn_tx_cb_t cb, void *user_data);

static inline void bt_l2cap_send(struct bt_conn *conn, u16_t cid,
				 struct net_buf *buf)
{
	bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
    999a:	4622      	mov	r2, r4
    999c:	9300      	str	r3, [sp, #0]
    999e:	2105      	movs	r1, #5
    99a0:	4628      	mov	r0, r5
    99a2:	f01c feaa 	bl	266fa <bt_l2cap_send_cb>
}
    99a6:	e7c0      	b.n	992a <l2cap_recv+0x4a>
    99a8:	00029900 	.word	0x00029900
    99ac:	00029830 	.word	0x00029830
    99b0:	0002c6db 	.word	0x0002c6db
    99b4:	0002c6f9 	.word	0x0002c6f9
    99b8:	0002c71a 	.word	0x0002c71a
    99bc:	0002c73b 	.word	0x0002c73b
    99c0:	0002c757 	.word	0x0002c757

000099c4 <bt_l2cap_recv>:
{
    99c4:	b538      	push	{r3, r4, r5, lr}
	if (buf->len < sizeof(*hdr)) {
    99c6:	898b      	ldrh	r3, [r1, #12]
    99c8:	2b03      	cmp	r3, #3
{
    99ca:	4605      	mov	r5, r0
    99cc:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
    99ce:	d80e      	bhi.n	99ee <bt_l2cap_recv+0x2a>
    99d0:	4914      	ldr	r1, [pc, #80]	; (9a24 <bt_l2cap_recv+0x60>)
    99d2:	4b15      	ldr	r3, [pc, #84]	; (9a28 <bt_l2cap_recv+0x64>)
		BT_ERR("Too small L2CAP PDU received");
    99d4:	4815      	ldr	r0, [pc, #84]	; (9a2c <bt_l2cap_recv+0x68>)
    99d6:	1ac9      	subs	r1, r1, r3
    99d8:	08c9      	lsrs	r1, r1, #3
    99da:	0189      	lsls	r1, r1, #6
    99dc:	f041 0101 	orr.w	r1, r1, #1
    99e0:	f01a faf0 	bl	23fc4 <log_0>
	net_buf_unref(buf);
    99e4:	4620      	mov	r0, r4
}
    99e6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	net_buf_unref(buf);
    99ea:	f015 bb6d 	b.w	1f0c8 <net_buf_unref>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    99ee:	2104      	movs	r1, #4
    99f0:	f104 0008 	add.w	r0, r4, #8
    99f4:	f015 fc4e 	bl	1f294 <net_buf_simple_pull_mem>
	cid = sys_le16_to_cpu(hdr->cid);
    99f8:	8841      	ldrh	r1, [r0, #2]
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
    99fa:	4628      	mov	r0, r5
    99fc:	f01c fea6 	bl	2674c <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    9a00:	b950      	cbnz	r0, 9a18 <bt_l2cap_recv+0x54>
    9a02:	4b09      	ldr	r3, [pc, #36]	; (9a28 <bt_l2cap_recv+0x64>)
    9a04:	4a07      	ldr	r2, [pc, #28]	; (9a24 <bt_l2cap_recv+0x60>)
		BT_WARN("Ignoring data for unknown CID 0x%04x", cid);
    9a06:	480a      	ldr	r0, [pc, #40]	; (9a30 <bt_l2cap_recv+0x6c>)
    9a08:	1ad2      	subs	r2, r2, r3
    9a0a:	08d2      	lsrs	r2, r2, #3
    9a0c:	0192      	lsls	r2, r2, #6
    9a0e:	f042 0202 	orr.w	r2, r2, #2
    9a12:	f01a fae4 	bl	23fde <log_1>
		net_buf_unref(buf);
    9a16:	e7e5      	b.n	99e4 <bt_l2cap_recv+0x20>
	chan->ops->recv(chan, buf);
    9a18:	6843      	ldr	r3, [r0, #4]
    9a1a:	4621      	mov	r1, r4
    9a1c:	691b      	ldr	r3, [r3, #16]
    9a1e:	4798      	blx	r3
    9a20:	e7e0      	b.n	99e4 <bt_l2cap_recv+0x20>
    9a22:	bf00      	nop
    9a24:	00029900 	.word	0x00029900
    9a28:	00029830 	.word	0x00029830
    9a2c:	0002c775 	.word	0x0002c775
    9a30:	0002c792 	.word	0x0002c792

00009a34 <bt_l2cap_update_conn_param>:
{
    9a34:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ident++;
    9a36:	4b15      	ldr	r3, [pc, #84]	; (9a8c <bt_l2cap_update_conn_param+0x58>)
    9a38:	781a      	ldrb	r2, [r3, #0]
    9a3a:	3201      	adds	r2, #1
	if (!ident) {
    9a3c:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
		ident++;
    9a40:	bf08      	it	eq
    9a42:	2201      	moveq	r2, #1
    9a44:	701a      	strb	r2, [r3, #0]
{
    9a46:	4605      	mov	r5, r0
    9a48:	460c      	mov	r4, r1
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
    9a4a:	2208      	movs	r2, #8
    9a4c:	7819      	ldrb	r1, [r3, #0]
    9a4e:	2012      	movs	r0, #18
    9a50:	f7ff fe8a 	bl	9768 <l2cap_create_le_sig_pdu.isra.0>
	if (!buf) {
    9a54:	4606      	mov	r6, r0
    9a56:	b1b0      	cbz	r0, 9a86 <bt_l2cap_update_conn_param+0x52>
	req = net_buf_add(buf, sizeof(*req));
    9a58:	2108      	movs	r1, #8
    9a5a:	4408      	add	r0, r1
    9a5c:	f015 fc3c 	bl	1f2d8 <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
    9a60:	8822      	ldrh	r2, [r4, #0]
    9a62:	8002      	strh	r2, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
    9a64:	8862      	ldrh	r2, [r4, #2]
    9a66:	8042      	strh	r2, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
    9a68:	88a2      	ldrh	r2, [r4, #4]
    9a6a:	8082      	strh	r2, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
    9a6c:	88e2      	ldrh	r2, [r4, #6]
    9a6e:	80c2      	strh	r2, [r0, #6]
	bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
    9a70:	2400      	movs	r4, #0
    9a72:	9400      	str	r4, [sp, #0]
    9a74:	4623      	mov	r3, r4
    9a76:	4632      	mov	r2, r6
    9a78:	2105      	movs	r1, #5
    9a7a:	4628      	mov	r0, r5
    9a7c:	f01c fe3d 	bl	266fa <bt_l2cap_send_cb>
	return 0;
    9a80:	4620      	mov	r0, r4
}
    9a82:	b002      	add	sp, #8
    9a84:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
    9a86:	f06f 000b 	mvn.w	r0, #11
    9a8a:	e7fa      	b.n	9a82 <bt_l2cap_update_conn_param+0x4e>
    9a8c:	200024bb 	.word	0x200024bb

00009a90 <bt_att_destroy>:

	return 0;
}

void bt_att_destroy(struct bt_l2cap_chan *chan)
{
    9a90:	b507      	push	{r0, r1, r2, lr}
	struct bt_att *att = ATT_CHAN(chan);
    9a92:	9001      	str	r0, [sp, #4]

	BT_DBG("chan %p", chan);

	k_mem_slab_free(&att_slab, (void **)&att);
    9a94:	a901      	add	r1, sp, #4
    9a96:	4803      	ldr	r0, [pc, #12]	; (9aa4 <bt_att_destroy+0x14>)
    9a98:	f016 fed6 	bl	20848 <k_mem_slab_free>
}
    9a9c:	b003      	add	sp, #12
    9a9e:	f85d fb04 	ldr.w	pc, [sp], #4
    9aa2:	bf00      	nop
    9aa4:	2000755c 	.word	0x2000755c

00009aa8 <find_type_cb>:
{
    9aa8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_att *att = data->att;
    9aac:	680e      	ldr	r6, [r1, #0]
{
    9aae:	b090      	sub	sp, #64	; 0x40
    9ab0:	4605      	mov	r5, r0
    9ab2:	460c      	mov	r4, r1
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    9ab4:	f04f 0800 	mov.w	r8, #0
    9ab8:	f642 0301 	movw	r3, #10241	; 0x2801
    9abc:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = att->chan.chan.conn;
    9abe:	6837      	ldr	r7, [r6, #0]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    9ac0:	f88d 802c 	strb.w	r8, [sp, #44]	; 0x2c
    9ac4:	a90b      	add	r1, sp, #44	; 0x2c
    9ac6:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
    9aca:	f01c fbbd 	bl	26248 <bt_uuid_cmp>
    9ace:	2800      	cmp	r0, #0
    9ad0:	d039      	beq.n	9b46 <find_type_cb+0x9e>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
    9ad2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    9ad6:	6828      	ldr	r0, [r5, #0]
    9ad8:	f88d 802c 	strb.w	r8, [sp, #44]	; 0x2c
    9adc:	a90b      	add	r1, sp, #44	; 0x2c
    9ade:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
    9ae2:	f01c fbb1 	bl	26248 <bt_uuid_cmp>
    9ae6:	b150      	cbz	r0, 9afe <find_type_cb+0x56>
		if (data->group &&
    9ae8:	68a3      	ldr	r3, [r4, #8]
    9aea:	b123      	cbz	r3, 9af6 <find_type_cb+0x4e>
		    attr->handle > sys_le16_to_cpu(data->group->end_handle)) {
    9aec:	8a2a      	ldrh	r2, [r5, #16]
		if (data->group &&
    9aee:	8859      	ldrh	r1, [r3, #2]
    9af0:	4291      	cmp	r1, r2
    9af2:	d200      	bcs.n	9af6 <find_type_cb+0x4e>
			data->group->end_handle = sys_cpu_to_le16(attr->handle);
    9af4:	805a      	strh	r2, [r3, #2]
	return BT_GATT_ITER_CONTINUE;
    9af6:	2001      	movs	r0, #1
}
    9af8:	b010      	add	sp, #64	; 0x40
    9afa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (att->chan.tx.mtu - data->buf->len < sizeof(*data->group)) {
    9afe:	6862      	ldr	r2, [r4, #4]
    9b00:	f8b6 3042 	ldrh.w	r3, [r6, #66]	; 0x42
    9b04:	8992      	ldrh	r2, [r2, #12]
    9b06:	1a9b      	subs	r3, r3, r2
    9b08:	2b03      	cmp	r3, #3
    9b0a:	d9f5      	bls.n	9af8 <find_type_cb+0x50>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
    9b0c:	686e      	ldr	r6, [r5, #4]
    9b0e:	9000      	str	r0, [sp, #0]
    9b10:	2310      	movs	r3, #16
    9b12:	aa02      	add	r2, sp, #8
    9b14:	4629      	mov	r1, r5
    9b16:	4638      	mov	r0, r7
    9b18:	47b0      	blx	r6
	if (read < 0) {
    9b1a:	1e06      	subs	r6, r0, #0
    9b1c:	db13      	blt.n	9b46 <find_type_cb+0x9e>
	if (read != data->value_len) {
    9b1e:	7c22      	ldrb	r2, [r4, #16]
    9b20:	68e0      	ldr	r0, [r4, #12]
    9b22:	4296      	cmp	r6, r2
    9b24:	d034      	beq.n	9b90 <find_type_cb+0xe8>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
    9b26:	4601      	mov	r1, r0
    9b28:	a80b      	add	r0, sp, #44	; 0x2c
    9b2a:	f01c fbb7 	bl	2629c <bt_uuid_create>
    9b2e:	b968      	cbnz	r0, 9b4c <find_type_cb+0xa4>
    9b30:	4a1a      	ldr	r2, [pc, #104]	; (9b9c <find_type_cb+0xf4>)
    9b32:	4b1b      	ldr	r3, [pc, #108]	; (9ba0 <find_type_cb+0xf8>)
			BT_WARN("Unable to create UUID: size %u", data->value_len);
    9b34:	7c21      	ldrb	r1, [r4, #16]
    9b36:	481b      	ldr	r0, [pc, #108]	; (9ba4 <find_type_cb+0xfc>)
    9b38:	1ad2      	subs	r2, r2, r3
    9b3a:	08d2      	lsrs	r2, r2, #3
    9b3c:	0192      	lsls	r2, r2, #6
    9b3e:	f042 0202 	orr.w	r2, r2, #2
			BT_WARN("Unable to create UUID: size %d", read);
    9b42:	f01a fa4c 	bl	23fde <log_1>
	data->group = NULL;
    9b46:	2300      	movs	r3, #0
    9b48:	60a3      	str	r3, [r4, #8]
    9b4a:	e7d4      	b.n	9af6 <find_type_cb+0x4e>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
    9b4c:	b2f2      	uxtb	r2, r6
    9b4e:	a902      	add	r1, sp, #8
    9b50:	a806      	add	r0, sp, #24
    9b52:	f01c fba3 	bl	2629c <bt_uuid_create>
    9b56:	b948      	cbnz	r0, 9b6c <find_type_cb+0xc4>
    9b58:	4a10      	ldr	r2, [pc, #64]	; (9b9c <find_type_cb+0xf4>)
    9b5a:	4b11      	ldr	r3, [pc, #68]	; (9ba0 <find_type_cb+0xf8>)
			BT_WARN("Unable to create UUID: size %d", read);
    9b5c:	4812      	ldr	r0, [pc, #72]	; (9ba8 <find_type_cb+0x100>)
    9b5e:	1ad2      	subs	r2, r2, r3
    9b60:	08d2      	lsrs	r2, r2, #3
    9b62:	0192      	lsls	r2, r2, #6
    9b64:	f042 0202 	orr.w	r2, r2, #2
    9b68:	4631      	mov	r1, r6
    9b6a:	e7ea      	b.n	9b42 <find_type_cb+0x9a>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
    9b6c:	a906      	add	r1, sp, #24
    9b6e:	a80b      	add	r0, sp, #44	; 0x2c
    9b70:	f01c fb6a 	bl	26248 <bt_uuid_cmp>
	} else if (memcmp(data->value, uuid, read)) {
    9b74:	2800      	cmp	r0, #0
    9b76:	d1e6      	bne.n	9b46 <find_type_cb+0x9e>
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    9b78:	6860      	ldr	r0, [r4, #4]
	data->err = 0x00;
    9b7a:	2300      	movs	r3, #0
    9b7c:	7463      	strb	r3, [r4, #17]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    9b7e:	2104      	movs	r1, #4
    9b80:	3008      	adds	r0, #8
    9b82:	f015 fba9 	bl	1f2d8 <net_buf_simple_add>
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
    9b86:	8a2b      	ldrh	r3, [r5, #16]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    9b88:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
    9b8a:	8003      	strh	r3, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(attr->handle);
    9b8c:	8043      	strh	r3, [r0, #2]
	return BT_GATT_ITER_CONTINUE;
    9b8e:	e7b2      	b.n	9af6 <find_type_cb+0x4e>
	} else if (memcmp(data->value, uuid, read)) {
    9b90:	4632      	mov	r2, r6
    9b92:	a902      	add	r1, sp, #8
    9b94:	f01c f878 	bl	25c88 <memcmp>
    9b98:	e7ec      	b.n	9b74 <find_type_cb+0xcc>
    9b9a:	bf00      	nop
    9b9c:	00029838 	.word	0x00029838
    9ba0:	00029830 	.word	0x00029830
    9ba4:	0002c7c7 	.word	0x0002c7c7
    9ba8:	0002c7e6 	.word	0x0002c7e6

00009bac <bt_att_connected>:
{
    9bac:	b510      	push	{r4, lr}
    9bae:	4604      	mov	r4, r0
	z_impl_k_queue_init(queue);
    9bb0:	30e0      	adds	r0, #224	; 0xe0
    9bb2:	f01f fb45 	bl	29240 <z_impl_k_queue_init>
	ch->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
    9bb6:	2317      	movs	r3, #23
    9bb8:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
	ch->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
    9bbc:	86e3      	strh	r3, [r4, #54]	; 0x36
	k_delayed_work_init(&att->timeout_work, att_timeout);
    9bbe:	4904      	ldr	r1, [pc, #16]	; (9bd0 <bt_att_connected+0x24>)
    9bc0:	f104 00a8 	add.w	r0, r4, #168	; 0xa8
    9bc4:	f01f fc19 	bl	293fa <k_delayed_work_init>
	list->head = NULL;
    9bc8:	2300      	movs	r3, #0
	list->tail = NULL;
    9bca:	e9c4 3328 	strd	r3, r3, [r4, #160]	; 0xa0
}
    9bce:	bd10      	pop	{r4, pc}
    9bd0:	0000a799 	.word	0x0000a799

00009bd4 <att_send>:
{
    9bd4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    9bd8:	4698      	mov	r8, r3
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    9bda:	688b      	ldr	r3, [r1, #8]
    9bdc:	781b      	ldrb	r3, [r3, #0]
    9bde:	2bd2      	cmp	r3, #210	; 0xd2
{
    9be0:	4607      	mov	r7, r0
    9be2:	460d      	mov	r5, r1
    9be4:	4616      	mov	r6, r2
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    9be6:	d114      	bne.n	9c12 <att_send+0x3e>
		err = bt_smp_sign(conn, buf);
    9be8:	f01d f9ef 	bl	26fca <bt_smp_sign>
		if (err) {
    9bec:	4604      	mov	r4, r0
    9bee:	b180      	cbz	r0, 9c12 <att_send+0x3e>
    9bf0:	4913      	ldr	r1, [pc, #76]	; (9c40 <att_send+0x6c>)
    9bf2:	4b14      	ldr	r3, [pc, #80]	; (9c44 <att_send+0x70>)
			BT_ERR("Error signing data");
    9bf4:	4814      	ldr	r0, [pc, #80]	; (9c48 <att_send+0x74>)
    9bf6:	1a5b      	subs	r3, r3, r1
    9bf8:	08db      	lsrs	r3, r3, #3
    9bfa:	019b      	lsls	r3, r3, #6
    9bfc:	f043 0101 	orr.w	r1, r3, #1
    9c00:	f01a f9e0 	bl	23fc4 <log_0>
			net_buf_unref(buf);
    9c04:	4628      	mov	r0, r5
    9c06:	f015 fa5f 	bl	1f0c8 <net_buf_unref>
}
    9c0a:	4620      	mov	r0, r4
    9c0c:	b002      	add	sp, #8
    9c0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf,
    9c12:	b95e      	cbnz	r6, 9c2c <att_send+0x58>
	switch (att_op_get_type(buf->data[0])) {
    9c14:	68ab      	ldr	r3, [r5, #8]
    9c16:	7818      	ldrb	r0, [r3, #0]
    9c18:	f01c fdaa 	bl	26770 <att_op_get_type>
    9c1c:	1e42      	subs	r2, r0, #1
    9c1e:	b2d2      	uxtb	r2, r2
    9c20:	2a04      	cmp	r2, #4
    9c22:	bf96      	itet	ls
    9c24:	4b09      	ldrls	r3, [pc, #36]	; (9c4c <att_send+0x78>)
    9c26:	4e0a      	ldrhi	r6, [pc, #40]	; (9c50 <att_send+0x7c>)
    9c28:	f853 6022 	ldrls.w	r6, [r3, r2, lsl #2]
	return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf,
    9c2c:	f8cd 8000 	str.w	r8, [sp]
    9c30:	4633      	mov	r3, r6
    9c32:	462a      	mov	r2, r5
    9c34:	2104      	movs	r1, #4
    9c36:	4638      	mov	r0, r7
    9c38:	f01c fd5f 	bl	266fa <bt_l2cap_send_cb>
    9c3c:	4604      	mov	r4, r0
    9c3e:	e7e4      	b.n	9c0a <att_send+0x36>
    9c40:	00029830 	.word	0x00029830
    9c44:	00029838 	.word	0x00029838
    9c48:	0002c805 	.word	0x0002c805
    9c4c:	00029ef4 	.word	0x00029ef4
    9c50:	00026a03 	.word	0x00026a03

00009c54 <att_get>:
{
    9c54:	b510      	push	{r4, lr}
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
    9c56:	2104      	movs	r1, #4
    9c58:	f01c fd68 	bl	2672c <bt_l2cap_le_lookup_tx_cid>
	__ASSERT(chan, "No ATT channel found");
    9c5c:	4604      	mov	r4, r0
    9c5e:	b960      	cbnz	r0, 9c7a <att_get+0x26>
    9c60:	4907      	ldr	r1, [pc, #28]	; (9c80 <att_get+0x2c>)
    9c62:	4a08      	ldr	r2, [pc, #32]	; (9c84 <att_get+0x30>)
    9c64:	4808      	ldr	r0, [pc, #32]	; (9c88 <att_get+0x34>)
    9c66:	2371      	movs	r3, #113	; 0x71
    9c68:	f01a f93b 	bl	23ee2 <printk>
    9c6c:	4807      	ldr	r0, [pc, #28]	; (9c8c <att_get+0x38>)
    9c6e:	f01a f938 	bl	23ee2 <printk>
    9c72:	4804      	ldr	r0, [pc, #16]	; (9c84 <att_get+0x30>)
    9c74:	2171      	movs	r1, #113	; 0x71
    9c76:	f01a f977 	bl	23f68 <assert_post_action>
}
    9c7a:	4620      	mov	r0, r4
    9c7c:	bd10      	pop	{r4, pc}
    9c7e:	bf00      	nop
    9c80:	000304ad 	.word	0x000304ad
    9c84:	0002c818 	.word	0x0002c818
    9c88:	0002a5e8 	.word	0x0002a5e8
    9c8c:	0002c847 	.word	0x0002c847

00009c90 <bt_att_accept>:
{
    9c90:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    9c92:	2200      	movs	r2, #0
{
    9c94:	4606      	mov	r6, r0
    9c96:	460d      	mov	r5, r1
	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    9c98:	4812      	ldr	r0, [pc, #72]	; (9ce4 <bt_att_accept+0x54>)
    9c9a:	a901      	add	r1, sp, #4
    9c9c:	f016 fd70 	bl	20780 <k_mem_slab_alloc>
    9ca0:	4604      	mov	r4, r0
    9ca2:	b178      	cbz	r0, 9cc4 <bt_att_accept+0x34>
    9ca4:	4b10      	ldr	r3, [pc, #64]	; (9ce8 <bt_att_accept+0x58>)
    9ca6:	4a11      	ldr	r2, [pc, #68]	; (9cec <bt_att_accept+0x5c>)
		BT_ERR("No available ATT context for conn %p", conn);
    9ca8:	4811      	ldr	r0, [pc, #68]	; (9cf0 <bt_att_accept+0x60>)
    9caa:	1ad2      	subs	r2, r2, r3
    9cac:	08d2      	lsrs	r2, r2, #3
    9cae:	0192      	lsls	r2, r2, #6
    9cb0:	f042 0201 	orr.w	r2, r2, #1
    9cb4:	4631      	mov	r1, r6
    9cb6:	f01a f992 	bl	23fde <log_1>
		return -ENOMEM;
    9cba:	f06f 040b 	mvn.w	r4, #11
}
    9cbe:	4620      	mov	r0, r4
    9cc0:	b002      	add	sp, #8
    9cc2:	bd70      	pop	{r4, r5, r6, pc}
	(void)memset(att, 0, sizeof(*att));
    9cc4:	4601      	mov	r1, r0
    9cc6:	22f4      	movs	r2, #244	; 0xf4
    9cc8:	9801      	ldr	r0, [sp, #4]
    9cca:	f01c f818 	bl	25cfe <memset>
	att->chan.chan.ops = &ops;
    9cce:	9801      	ldr	r0, [sp, #4]
    9cd0:	4b08      	ldr	r3, [pc, #32]	; (9cf4 <bt_att_accept+0x64>)
    9cd2:	6043      	str	r3, [r0, #4]
	return z_impl_k_sem_init(sem, initial_count, limit);
    9cd4:	2204      	movs	r2, #4
    9cd6:	4611      	mov	r1, r2
    9cd8:	30c8      	adds	r0, #200	; 0xc8
    9cda:	f01f fafd 	bl	292d8 <z_impl_k_sem_init>
	*chan = &att->chan.chan;
    9cde:	9b01      	ldr	r3, [sp, #4]
    9ce0:	602b      	str	r3, [r5, #0]
	return 0;
    9ce2:	e7ec      	b.n	9cbe <bt_att_accept+0x2e>
    9ce4:	2000755c 	.word	0x2000755c
    9ce8:	00029830 	.word	0x00029830
    9cec:	00029838 	.word	0x00029838
    9cf0:	0002c85e 	.word	0x0002c85e
    9cf4:	00029f70 	.word	0x00029f70

00009cf8 <att_chan_get>:
{
    9cf8:	b510      	push	{r4, lr}
	if (conn->state != BT_CONN_CONNECTED) {
    9cfa:	7a83      	ldrb	r3, [r0, #10]
    9cfc:	2b06      	cmp	r3, #6
    9cfe:	d00b      	beq.n	9d18 <att_chan_get+0x20>
    9d00:	4916      	ldr	r1, [pc, #88]	; (9d5c <att_chan_get+0x64>)
    9d02:	4b17      	ldr	r3, [pc, #92]	; (9d60 <att_chan_get+0x68>)
		BT_WARN("Not connected");
    9d04:	4817      	ldr	r0, [pc, #92]	; (9d64 <att_chan_get+0x6c>)
    9d06:	1ac9      	subs	r1, r1, r3
    9d08:	08c9      	lsrs	r1, r1, #3
    9d0a:	0189      	lsls	r1, r1, #6
    9d0c:	f041 0102 	orr.w	r1, r1, #2
		BT_WARN("ATT context flagged as disconnected");
    9d10:	f01a f958 	bl	23fc4 <log_0>
		return NULL;
    9d14:	2400      	movs	r4, #0
    9d16:	e00e      	b.n	9d36 <att_chan_get+0x3e>
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
    9d18:	2104      	movs	r1, #4
    9d1a:	f01c fd17 	bl	2674c <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    9d1e:	4604      	mov	r4, r0
    9d20:	b958      	cbnz	r0, 9d3a <att_chan_get+0x42>
    9d22:	490e      	ldr	r1, [pc, #56]	; (9d5c <att_chan_get+0x64>)
    9d24:	4b0e      	ldr	r3, [pc, #56]	; (9d60 <att_chan_get+0x68>)
		BT_ERR("Unable to find ATT channel");
    9d26:	4810      	ldr	r0, [pc, #64]	; (9d68 <att_chan_get+0x70>)
    9d28:	1ac9      	subs	r1, r1, r3
    9d2a:	08c9      	lsrs	r1, r1, #3
    9d2c:	0189      	lsls	r1, r1, #6
    9d2e:	f041 0101 	orr.w	r1, r1, #1
    9d32:	f01a f947 	bl	23fc4 <log_0>
}
    9d36:	4620      	mov	r0, r4
    9d38:	bd10      	pop	{r4, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    9d3a:	f3bf 8f5b 	dmb	ish
    9d3e:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
    9d42:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(att->flags, ATT_DISCONNECTED)) {
    9d46:	075b      	lsls	r3, r3, #29
    9d48:	d5f5      	bpl.n	9d36 <att_chan_get+0x3e>
    9d4a:	4904      	ldr	r1, [pc, #16]	; (9d5c <att_chan_get+0x64>)
    9d4c:	4b04      	ldr	r3, [pc, #16]	; (9d60 <att_chan_get+0x68>)
		BT_WARN("ATT context flagged as disconnected");
    9d4e:	4807      	ldr	r0, [pc, #28]	; (9d6c <att_chan_get+0x74>)
    9d50:	1ac9      	subs	r1, r1, r3
    9d52:	08c9      	lsrs	r1, r1, #3
    9d54:	0189      	lsls	r1, r1, #6
    9d56:	f041 0102 	orr.w	r1, r1, #2
    9d5a:	e7d9      	b.n	9d10 <att_chan_get+0x18>
    9d5c:	00029838 	.word	0x00029838
    9d60:	00029830 	.word	0x00029830
    9d64:	0002c883 	.word	0x0002c883
    9d68:	0002c891 	.word	0x0002c891
    9d6c:	0002c8ac 	.word	0x0002c8ac

00009d70 <att_req_sent>:
{
    9d70:	b538      	push	{r3, r4, r5, lr}
    9d72:	4604      	mov	r4, r0
    9d74:	460d      	mov	r5, r1
	struct bt_att *att = att_get(conn);
    9d76:	f7ff ff6d 	bl	9c54 <att_get>
	if (att->req) {
    9d7a:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    9d7e:	b133      	cbz	r3, 9d8e <att_req_sent+0x1e>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    9d80:	f100 01a8 	add.w	r1, r0, #168	; 0xa8
    9d84:	f247 5230 	movw	r2, #30000	; 0x7530
    9d88:	4804      	ldr	r0, [pc, #16]	; (9d9c <att_req_sent+0x2c>)
    9d8a:	f018 fee9 	bl	22b60 <k_delayed_work_submit_to_queue>
	att_pdu_sent(conn, user_data);
    9d8e:	4629      	mov	r1, r5
    9d90:	4620      	mov	r0, r4
}
    9d92:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
    9d96:	f01c be34 	b.w	26a02 <att_pdu_sent>
    9d9a:	bf00      	nop
    9d9c:	20001dc4 	.word	0x20001dc4

00009da0 <att_send_req>:
{
    9da0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9da2:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(req);
    9da4:	460c      	mov	r4, r1
    9da6:	b959      	cbnz	r1, 9dc0 <att_send_req+0x20>
    9da8:	4931      	ldr	r1, [pc, #196]	; (9e70 <att_send_req+0xd0>)
    9daa:	4832      	ldr	r0, [pc, #200]	; (9e74 <att_send_req+0xd4>)
    9dac:	4a32      	ldr	r2, [pc, #200]	; (9e78 <att_send_req+0xd8>)
    9dae:	f44f 7397 	mov.w	r3, #302	; 0x12e
    9db2:	f01a f896 	bl	23ee2 <printk>
    9db6:	4830      	ldr	r0, [pc, #192]	; (9e78 <att_send_req+0xd8>)
    9db8:	f44f 7197 	mov.w	r1, #302	; 0x12e
    9dbc:	f01a f8d4 	bl	23f68 <assert_post_action>
	__ASSERT_NO_MSG(req->func);
    9dc0:	6863      	ldr	r3, [r4, #4]
    9dc2:	b95b      	cbnz	r3, 9ddc <att_send_req+0x3c>
    9dc4:	492d      	ldr	r1, [pc, #180]	; (9e7c <att_send_req+0xdc>)
    9dc6:	482b      	ldr	r0, [pc, #172]	; (9e74 <att_send_req+0xd4>)
    9dc8:	4a2b      	ldr	r2, [pc, #172]	; (9e78 <att_send_req+0xd8>)
    9dca:	f240 132f 	movw	r3, #303	; 0x12f
    9dce:	f01a f888 	bl	23ee2 <printk>
    9dd2:	4829      	ldr	r0, [pc, #164]	; (9e78 <att_send_req+0xd8>)
    9dd4:	f240 112f 	movw	r1, #303	; 0x12f
    9dd8:	f01a f8c6 	bl	23f68 <assert_post_action>
	__ASSERT_NO_MSG(!att->req);
    9ddc:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
    9de0:	b15b      	cbz	r3, 9dfa <att_send_req+0x5a>
    9de2:	4927      	ldr	r1, [pc, #156]	; (9e80 <att_send_req+0xe0>)
    9de4:	4823      	ldr	r0, [pc, #140]	; (9e74 <att_send_req+0xd4>)
    9de6:	4a24      	ldr	r2, [pc, #144]	; (9e78 <att_send_req+0xd8>)
    9de8:	f44f 7398 	mov.w	r3, #304	; 0x130
    9dec:	f01a f879 	bl	23ee2 <printk>
    9df0:	4821      	ldr	r0, [pc, #132]	; (9e78 <att_send_req+0xd8>)
    9df2:	f44f 7198 	mov.w	r1, #304	; 0x130
    9df6:	f01a f8b7 	bl	23f68 <assert_post_action>
	att->req = req;
    9dfa:	f8c5 409c 	str.w	r4, [r5, #156]	; 0x9c
	return z_impl_k_sem_take(sem, timeout);
    9dfe:	2100      	movs	r1, #0
    9e00:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
    9e04:	f018 fc98 	bl	22738 <z_impl_k_sem_take>
	if (k_sem_take(&att->tx_sem, K_NO_WAIT) < 0) {
    9e08:	2800      	cmp	r0, #0
    9e0a:	da08      	bge.n	9e1e <att_send_req+0x7e>
		k_fifo_put(&att->tx_queue, req->buf);
    9e0c:	f105 00e0 	add.w	r0, r5, #224	; 0xe0
    9e10:	6921      	ldr	r1, [r4, #16]
    9e12:	f01f fa1e 	bl	29252 <k_queue_append>
		return 0;
    9e16:	2500      	movs	r5, #0
}
    9e18:	4628      	mov	r0, r5
    9e1a:	b002      	add	sp, #8
    9e1c:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_simple_save(&req->buf->b, &req->state);
    9e1e:	6926      	ldr	r6, [r4, #16]
	state->offset = net_buf_simple_headroom(buf);
    9e20:	f106 0008 	add.w	r0, r6, #8
    9e24:	f01e ffbb 	bl	28d9e <net_buf_simple_headroom>
	state->len = buf->len;
    9e28:	89b3      	ldrh	r3, [r6, #12]
	state->offset = net_buf_simple_headroom(buf);
    9e2a:	81a0      	strh	r0, [r4, #12]
	state->len = buf->len;
    9e2c:	81e3      	strh	r3, [r4, #14]
	err = bt_l2cap_send_cb(att->chan.chan.conn, BT_L2CAP_CID_ATT,
    9e2e:	6920      	ldr	r0, [r4, #16]
    9e30:	682d      	ldr	r5, [r5, #0]
    9e32:	f015 f991 	bl	1f158 <net_buf_ref>
    9e36:	6923      	ldr	r3, [r4, #16]
	switch (att_op_get_type(buf->data[0])) {
    9e38:	689b      	ldr	r3, [r3, #8]
	err = bt_l2cap_send_cb(att->chan.chan.conn, BT_L2CAP_CID_ATT,
    9e3a:	4601      	mov	r1, r0
	switch (att_op_get_type(buf->data[0])) {
    9e3c:	7818      	ldrb	r0, [r3, #0]
    9e3e:	f01c fc97 	bl	26770 <att_op_get_type>
    9e42:	1e43      	subs	r3, r0, #1
    9e44:	b2db      	uxtb	r3, r3
    9e46:	2b04      	cmp	r3, #4
    9e48:	bf96      	itet	ls
    9e4a:	4a0e      	ldrls	r2, [pc, #56]	; (9e84 <att_send_req+0xe4>)
    9e4c:	4b0e      	ldrhi	r3, [pc, #56]	; (9e88 <att_send_req+0xe8>)
    9e4e:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
	err = bt_l2cap_send_cb(att->chan.chan.conn, BT_L2CAP_CID_ATT,
    9e52:	2600      	movs	r6, #0
    9e54:	460a      	mov	r2, r1
    9e56:	4628      	mov	r0, r5
    9e58:	9600      	str	r6, [sp, #0]
    9e5a:	2104      	movs	r1, #4
    9e5c:	f01c fc4d 	bl	266fa <bt_l2cap_send_cb>
	if (err) {
    9e60:	4605      	mov	r5, r0
    9e62:	2800      	cmp	r0, #0
    9e64:	d0d8      	beq.n	9e18 <att_send_req+0x78>
		net_buf_unref(req->buf);
    9e66:	6920      	ldr	r0, [r4, #16]
    9e68:	f015 f92e 	bl	1f0c8 <net_buf_unref>
		req->buf = NULL;
    9e6c:	6126      	str	r6, [r4, #16]
		return err;
    9e6e:	e7d3      	b.n	9e18 <att_send_req+0x78>
    9e70:	0002c8e0 	.word	0x0002c8e0
    9e74:	0002a5e8 	.word	0x0002a5e8
    9e78:	0002c818 	.word	0x0002c818
    9e7c:	0002c8d0 	.word	0x0002c8d0
    9e80:	0002c8da 	.word	0x0002c8da
    9e84:	00029ef4 	.word	0x00029ef4
    9e88:	00026a03 	.word	0x00026a03

00009e8c <att_write_cmd>:
{
    9e8c:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    9e8e:	6806      	ldr	r6, [r0, #0]
{
    9e90:	b089      	sub	sp, #36	; 0x24
	handle = net_buf_pull_le16(buf);
    9e92:	f101 0008 	add.w	r0, r1, #8
{
    9e96:	460c      	mov	r4, r1
	handle = net_buf_pull_le16(buf);
    9e98:	f01e ff65 	bl	28d66 <net_buf_simple_pull_le16>
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    9e9c:	2100      	movs	r1, #0
	handle = net_buf_pull_le16(buf);
    9e9e:	4605      	mov	r5, r0
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    9ea0:	4630      	mov	r0, r6
	return att_write_rsp(conn, 0, 0, handle, 0, buf->data, buf->len);
    9ea2:	68a7      	ldr	r7, [r4, #8]
    9ea4:	89a4      	ldrh	r4, [r4, #12]
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    9ea6:	f01d f86d 	bl	26f84 <bt_gatt_change_aware>
    9eaa:	b328      	cbz	r0, 9ef8 <att_write_cmd+0x6c>
	if (!handle) {
    9eac:	b335      	cbz	r5, 9efc <att_write_cmd+0x70>
	(void)memset(&data, 0, sizeof(data));
    9eae:	2218      	movs	r2, #24
    9eb0:	2100      	movs	r1, #0
    9eb2:	a802      	add	r0, sp, #8
    9eb4:	f01b ff23 	bl	25cfe <memset>
	data.req = req;
    9eb8:	2300      	movs	r3, #0
    9eba:	f88d 3010 	strb.w	r3, [sp, #16]
	data.offset = offset;
    9ebe:	f8ad 301a 	strh.w	r3, [sp, #26]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    9ec2:	2301      	movs	r3, #1
    9ec4:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    9ec8:	4a0d      	ldr	r2, [pc, #52]	; (9f00 <att_write_cmd+0x74>)
	data.conn = conn;
    9eca:	9602      	str	r6, [sp, #8]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    9ecc:	ab02      	add	r3, sp, #8
    9ece:	4629      	mov	r1, r5
    9ed0:	4628      	mov	r0, r5
	data.value = value;
    9ed2:	9705      	str	r7, [sp, #20]
	data.len = len;
    9ed4:	f8ad 4018 	strh.w	r4, [sp, #24]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    9ed8:	f01c fc77 	bl	267ca <bt_gatt_foreach_attr>
	if (data.err) {
    9edc:	f89d 301c 	ldrb.w	r3, [sp, #28]
    9ee0:	b93b      	cbnz	r3, 9ef2 <att_write_cmd+0x66>
	if (data.buf) {
    9ee2:	9a03      	ldr	r2, [sp, #12]
    9ee4:	b12a      	cbz	r2, 9ef2 <att_write_cmd+0x66>
		(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf,
    9ee6:	9300      	str	r3, [sp, #0]
    9ee8:	2104      	movs	r1, #4
    9eea:	4b06      	ldr	r3, [pc, #24]	; (9f04 <att_write_cmd+0x78>)
    9eec:	4630      	mov	r0, r6
    9eee:	f01c fc04 	bl	266fa <bt_l2cap_send_cb>
    9ef2:	2000      	movs	r0, #0
}
    9ef4:	b009      	add	sp, #36	; 0x24
    9ef6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    9ef8:	2012      	movs	r0, #18
    9efa:	e7fb      	b.n	9ef4 <att_write_cmd+0x68>
		return BT_ATT_ERR_INVALID_HANDLE;
    9efc:	2001      	movs	r0, #1
    9efe:	e7f9      	b.n	9ef4 <att_write_cmd+0x68>
    9f00:	00026abd 	.word	0x00026abd
    9f04:	00026a8b 	.word	0x00026a8b

00009f08 <bt_att_create_pdu>:
{
    9f08:	b570      	push	{r4, r5, r6, lr}
    9f0a:	460e      	mov	r6, r1
    9f0c:	4615      	mov	r5, r2
	att = att_chan_get(conn);
    9f0e:	f7ff fef3 	bl	9cf8 <att_chan_get>
	if (!att) {
    9f12:	4604      	mov	r4, r0
    9f14:	b178      	cbz	r0, 9f36 <bt_att_create_pdu+0x2e>
	if (len + sizeof(op) > att->chan.tx.mtu) {
    9f16:	f8b0 1042 	ldrh.w	r1, [r0, #66]	; 0x42
    9f1a:	1c6a      	adds	r2, r5, #1
    9f1c:	428a      	cmp	r2, r1
    9f1e:	d90c      	bls.n	9f3a <bt_att_create_pdu+0x32>
    9f20:	4818      	ldr	r0, [pc, #96]	; (9f84 <bt_att_create_pdu+0x7c>)
    9f22:	4b19      	ldr	r3, [pc, #100]	; (9f88 <bt_att_create_pdu+0x80>)
    9f24:	1a1b      	subs	r3, r3, r0
    9f26:	08db      	lsrs	r3, r3, #3
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
    9f28:	019b      	lsls	r3, r3, #6
    9f2a:	4818      	ldr	r0, [pc, #96]	; (9f8c <bt_att_create_pdu+0x84>)
    9f2c:	f043 0302 	orr.w	r3, r3, #2
    9f30:	f01a f869 	bl	24006 <log_2>
		return NULL;
    9f34:	2400      	movs	r4, #0
}
    9f36:	4620      	mov	r0, r4
    9f38:	bd70      	pop	{r4, r5, r6, pc}
	switch (att_op_get_type(op)) {
    9f3a:	4630      	mov	r0, r6
    9f3c:	f01c fc18 	bl	26770 <att_op_get_type>
    9f40:	2802      	cmp	r0, #2
    9f42:	d001      	beq.n	9f48 <bt_att_create_pdu+0x40>
    9f44:	2804      	cmp	r0, #4
    9f46:	d113      	bne.n	9f70 <bt_att_create_pdu+0x68>
		buf = bt_l2cap_create_pdu_timeout(NULL, 0, BT_ATT_TIMEOUT);
    9f48:	f247 5230 	movw	r2, #30000	; 0x7530
		buf = bt_l2cap_create_pdu(NULL, 0);
    9f4c:	2100      	movs	r1, #0
    9f4e:	4608      	mov	r0, r1
    9f50:	f01c fbd0 	bl	266f4 <bt_l2cap_create_pdu_timeout>
    9f54:	4604      	mov	r4, r0
	if (!buf) {
    9f56:	b970      	cbnz	r0, 9f76 <bt_att_create_pdu+0x6e>
    9f58:	4b0a      	ldr	r3, [pc, #40]	; (9f84 <bt_att_create_pdu+0x7c>)
    9f5a:	4a0b      	ldr	r2, [pc, #44]	; (9f88 <bt_att_create_pdu+0x80>)
		BT_ERR("Unable to allocate buffer for op 0x%02x", op);
    9f5c:	480c      	ldr	r0, [pc, #48]	; (9f90 <bt_att_create_pdu+0x88>)
    9f5e:	1ad2      	subs	r2, r2, r3
    9f60:	08d2      	lsrs	r2, r2, #3
    9f62:	0192      	lsls	r2, r2, #6
    9f64:	f042 0201 	orr.w	r2, r2, #1
    9f68:	4631      	mov	r1, r6
    9f6a:	f01a f838 	bl	23fde <log_1>
		return NULL;
    9f6e:	e7e2      	b.n	9f36 <bt_att_create_pdu+0x2e>
		buf = bt_l2cap_create_pdu(NULL, 0);
    9f70:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9f74:	e7ea      	b.n	9f4c <bt_att_create_pdu+0x44>
	hdr = net_buf_add(buf, sizeof(*hdr));
    9f76:	2101      	movs	r1, #1
    9f78:	3008      	adds	r0, #8
    9f7a:	f015 f9ad 	bl	1f2d8 <net_buf_simple_add>
	hdr->code = op;
    9f7e:	7006      	strb	r6, [r0, #0]
	return buf;
    9f80:	e7d9      	b.n	9f36 <bt_att_create_pdu+0x2e>
    9f82:	bf00      	nop
    9f84:	00029830 	.word	0x00029830
    9f88:	00029838 	.word	0x00029838
    9f8c:	0002c8e4 	.word	0x0002c8e4
    9f90:	0002c64b 	.word	0x0002c64b

00009f94 <att_mtu_req>:
	mtu_client = sys_le16_to_cpu(req->mtu);
    9f94:	688b      	ldr	r3, [r1, #8]
{
    9f96:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	mtu_client = sys_le16_to_cpu(req->mtu);
    9f9a:	881e      	ldrh	r6, [r3, #0]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
    9f9c:	2e16      	cmp	r6, #22
{
    9f9e:	4605      	mov	r5, r0
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
    9fa0:	d921      	bls.n	9fe6 <att_mtu_req+0x52>
	struct bt_conn *conn = att->chan.chan.conn;
    9fa2:	f8d0 8000 	ldr.w	r8, [r0]
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
    9fa6:	2202      	movs	r2, #2
    9fa8:	2103      	movs	r1, #3
    9faa:	4640      	mov	r0, r8
    9fac:	f7ff ffac 	bl	9f08 <bt_att_create_pdu>
	if (!pdu) {
    9fb0:	4607      	mov	r7, r0
    9fb2:	b1d0      	cbz	r0, 9fea <att_mtu_req+0x56>
	rsp = net_buf_add(pdu, sizeof(*rsp));
    9fb4:	2102      	movs	r1, #2
    9fb6:	3008      	adds	r0, #8
    9fb8:	f015 f98e 	bl	1f2d8 <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
    9fbc:	2400      	movs	r4, #0
    9fbe:	2345      	movs	r3, #69	; 0x45
    9fc0:	7003      	strb	r3, [r0, #0]
    9fc2:	7044      	strb	r4, [r0, #1]
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, pdu, att_rsp_sent, NULL);
    9fc4:	4b0a      	ldr	r3, [pc, #40]	; (9ff0 <att_mtu_req+0x5c>)
    9fc6:	9400      	str	r4, [sp, #0]
    9fc8:	463a      	mov	r2, r7
    9fca:	2104      	movs	r1, #4
    9fcc:	4640      	mov	r0, r8
    9fce:	f01c fb94 	bl	266fa <bt_l2cap_send_cb>
	att->chan.rx.mtu = MIN(mtu_client, mtu_server);
    9fd2:	2e45      	cmp	r6, #69	; 0x45
    9fd4:	bf28      	it	cs
    9fd6:	2645      	movcs	r6, #69	; 0x45
    9fd8:	86ee      	strh	r6, [r5, #54]	; 0x36
	att->chan.tx.mtu = att->chan.rx.mtu;
    9fda:	f8a5 6042 	strh.w	r6, [r5, #66]	; 0x42
	return 0;
    9fde:	4620      	mov	r0, r4
}
    9fe0:	b002      	add	sp, #8
    9fe2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_ATT_ERR_INVALID_PDU;
    9fe6:	2004      	movs	r0, #4
    9fe8:	e7fa      	b.n	9fe0 <att_mtu_req+0x4c>
		return BT_ATT_ERR_UNLIKELY;
    9fea:	200e      	movs	r0, #14
    9fec:	e7f8      	b.n	9fe0 <att_mtu_req+0x4c>
    9fee:	bf00      	nop
    9ff0:	00026a8b 	.word	0x00026a8b

00009ff4 <send_err_rsp.part.0>:
static void send_err_rsp(struct bt_conn *conn, u8_t req, u16_t handle,
    9ff4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    9ff8:	4688      	mov	r8, r1
    9ffa:	4617      	mov	r7, r2
	buf = bt_att_create_pdu(conn, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
    9ffc:	2101      	movs	r1, #1
    9ffe:	2204      	movs	r2, #4
static void send_err_rsp(struct bt_conn *conn, u8_t req, u16_t handle,
    a000:	4605      	mov	r5, r0
    a002:	461e      	mov	r6, r3
	buf = bt_att_create_pdu(conn, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
    a004:	f7ff ff80 	bl	9f08 <bt_att_create_pdu>
	if (!buf) {
    a008:	4604      	mov	r4, r0
    a00a:	b180      	cbz	r0, a02e <send_err_rsp.part.0+0x3a>
	rsp = net_buf_add(buf, sizeof(*rsp));
    a00c:	2104      	movs	r1, #4
    a00e:	3008      	adds	r0, #8
    a010:	f015 f962 	bl	1f2d8 <net_buf_simple_add>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
    a014:	2300      	movs	r3, #0
	rsp->request = req;
    a016:	f880 8000 	strb.w	r8, [r0]
	rsp->handle = sys_cpu_to_le16(handle);
    a01a:	f8a0 7001 	strh.w	r7, [r0, #1]
	rsp->error = err;
    a01e:	70c6      	strb	r6, [r0, #3]
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
    a020:	4622      	mov	r2, r4
    a022:	9300      	str	r3, [sp, #0]
    a024:	2104      	movs	r1, #4
    a026:	4b03      	ldr	r3, [pc, #12]	; (a034 <send_err_rsp.part.0+0x40>)
    a028:	4628      	mov	r0, r5
    a02a:	f01c fb66 	bl	266fa <bt_l2cap_send_cb>
}
    a02e:	b002      	add	sp, #8
    a030:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a034:	00026a8b 	.word	0x00026a8b

0000a038 <bt_att_recv>:
{
    a038:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buf->len < sizeof(*hdr)) {
    a03a:	898b      	ldrh	r3, [r1, #12]
{
    a03c:	4604      	mov	r4, r0
    a03e:	460e      	mov	r6, r1
	if (buf->len < sizeof(*hdr)) {
    a040:	b95b      	cbnz	r3, a05a <bt_att_recv+0x22>
    a042:	494b      	ldr	r1, [pc, #300]	; (a170 <bt_att_recv+0x138>)
    a044:	4b4b      	ldr	r3, [pc, #300]	; (a174 <bt_att_recv+0x13c>)
		BT_ERR("Too small ATT PDU received");
    a046:	484c      	ldr	r0, [pc, #304]	; (a178 <bt_att_recv+0x140>)
    a048:	1ac9      	subs	r1, r1, r3
    a04a:	08c9      	lsrs	r1, r1, #3
    a04c:	0189      	lsls	r1, r1, #6
    a04e:	f041 0101 	orr.w	r1, r1, #1
			BT_WARN("Ignoring unexpected indication");
    a052:	f019 ffb7 	bl	23fc4 <log_0>
}
    a056:	2000      	movs	r0, #0
    a058:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    a05a:	2101      	movs	r1, #1
    a05c:	f106 0008 	add.w	r0, r6, #8
    a060:	f015 f918 	bl	1f294 <net_buf_simple_pull_mem>
		if (hdr->code == handlers[i].op) {
    a064:	4a45      	ldr	r2, [pc, #276]	; (a17c <bt_att_recv+0x144>)
    a066:	7801      	ldrb	r1, [r0, #0]
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
    a068:	4605      	mov	r5, r0
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    a06a:	2300      	movs	r3, #0
    a06c:	4610      	mov	r0, r2
		if (hdr->code == handlers[i].op) {
    a06e:	f812 7033 	ldrb.w	r7, [r2, r3, lsl #3]
    a072:	428f      	cmp	r7, r1
    a074:	d120      	bne.n	a0b8 <bt_att_recv+0x80>
		if (handler->type == ATT_REQUEST &&
    a076:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
    a07a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    a07e:	789f      	ldrb	r7, [r3, #2]
    a080:	2f01      	cmp	r7, #1
    a082:	d134      	bne.n	a0ee <bt_att_recv+0xb6>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    a084:	f3bf 8f5b 	dmb	ish
    a088:	f104 0298 	add.w	r2, r4, #152	; 0x98
    a08c:	e852 3f00 	ldrex	r3, [r2]
    a090:	f043 0101 	orr.w	r1, r3, #1
    a094:	e842 1e00 	strex	lr, r1, [r2]
    a098:	f1be 0f00 	cmp.w	lr, #0
    a09c:	d1f6      	bne.n	a08c <bt_att_recv+0x54>
    a09e:	f3bf 8f5b 	dmb	ish
    a0a2:	07da      	lsls	r2, r3, #31
    a0a4:	d53f      	bpl.n	a126 <bt_att_recv+0xee>
    a0a6:	4932      	ldr	r1, [pc, #200]	; (a170 <bt_att_recv+0x138>)
    a0a8:	4b32      	ldr	r3, [pc, #200]	; (a174 <bt_att_recv+0x13c>)
			BT_WARN("Ignoring unexpected request");
    a0aa:	4835      	ldr	r0, [pc, #212]	; (a180 <bt_att_recv+0x148>)
    a0ac:	1ac9      	subs	r1, r1, r3
    a0ae:	08c9      	lsrs	r1, r1, #3
    a0b0:	0189      	lsls	r1, r1, #6
    a0b2:	f041 0102 	orr.w	r1, r1, #2
    a0b6:	e7cc      	b.n	a052 <bt_att_recv+0x1a>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    a0b8:	3301      	adds	r3, #1
    a0ba:	2b0d      	cmp	r3, #13
    a0bc:	d1d7      	bne.n	a06e <bt_att_recv+0x36>
    a0be:	4b2d      	ldr	r3, [pc, #180]	; (a174 <bt_att_recv+0x13c>)
    a0c0:	4a2b      	ldr	r2, [pc, #172]	; (a170 <bt_att_recv+0x138>)
		BT_WARN("Unhandled ATT code 0x%02x", hdr->code);
    a0c2:	4830      	ldr	r0, [pc, #192]	; (a184 <bt_att_recv+0x14c>)
    a0c4:	1ad2      	subs	r2, r2, r3
    a0c6:	08d2      	lsrs	r2, r2, #3
    a0c8:	0192      	lsls	r2, r2, #6
    a0ca:	f042 0202 	orr.w	r2, r2, #2
    a0ce:	f019 ff86 	bl	23fde <log_1>
		if (att_op_get_type(hdr->code) != ATT_COMMAND) {
    a0d2:	7829      	ldrb	r1, [r5, #0]
    a0d4:	4608      	mov	r0, r1
    a0d6:	f01c fb4b 	bl	26770 <att_op_get_type>
    a0da:	2800      	cmp	r0, #0
    a0dc:	d0bb      	beq.n	a056 <bt_att_recv+0x1e>
	if (!req) {
    a0de:	2900      	cmp	r1, #0
    a0e0:	d0b9      	beq.n	a056 <bt_att_recv+0x1e>
    a0e2:	2306      	movs	r3, #6
    a0e4:	6820      	ldr	r0, [r4, #0]
    a0e6:	2200      	movs	r2, #0
    a0e8:	f7ff ff84 	bl	9ff4 <send_err_rsp.part.0>
    a0ec:	e7b3      	b.n	a056 <bt_att_recv+0x1e>
		} else if (handler->type == ATT_INDICATION &&
    a0ee:	2f05      	cmp	r7, #5
    a0f0:	d119      	bne.n	a126 <bt_att_recv+0xee>
    a0f2:	f3bf 8f5b 	dmb	ish
    a0f6:	f104 0298 	add.w	r2, r4, #152	; 0x98
    a0fa:	e852 3f00 	ldrex	r3, [r2]
    a0fe:	f043 0102 	orr.w	r1, r3, #2
    a102:	e842 1e00 	strex	lr, r1, [r2]
    a106:	f1be 0f00 	cmp.w	lr, #0
    a10a:	d1f6      	bne.n	a0fa <bt_att_recv+0xc2>
    a10c:	f3bf 8f5b 	dmb	ish
    a110:	079b      	lsls	r3, r3, #30
    a112:	d508      	bpl.n	a126 <bt_att_recv+0xee>
    a114:	4916      	ldr	r1, [pc, #88]	; (a170 <bt_att_recv+0x138>)
    a116:	4b17      	ldr	r3, [pc, #92]	; (a174 <bt_att_recv+0x13c>)
			BT_WARN("Ignoring unexpected indication");
    a118:	481b      	ldr	r0, [pc, #108]	; (a188 <bt_att_recv+0x150>)
    a11a:	1ac9      	subs	r1, r1, r3
    a11c:	08c9      	lsrs	r1, r1, #3
    a11e:	0189      	lsls	r1, r1, #6
    a120:	f041 0102 	orr.w	r1, r1, #2
    a124:	e795      	b.n	a052 <bt_att_recv+0x1a>
	if (buf->len < handler->expect_len) {
    a126:	eb00 030c 	add.w	r3, r0, ip
    a12a:	89b1      	ldrh	r1, [r6, #12]
    a12c:	785a      	ldrb	r2, [r3, #1]
    a12e:	428a      	cmp	r2, r1
    a130:	d90e      	bls.n	a150 <bt_att_recv+0x118>
    a132:	4a10      	ldr	r2, [pc, #64]	; (a174 <bt_att_recv+0x13c>)
    a134:	4b0e      	ldr	r3, [pc, #56]	; (a170 <bt_att_recv+0x138>)
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
    a136:	4815      	ldr	r0, [pc, #84]	; (a18c <bt_att_recv+0x154>)
    a138:	1a9b      	subs	r3, r3, r2
    a13a:	08db      	lsrs	r3, r3, #3
    a13c:	019b      	lsls	r3, r3, #6
    a13e:	782a      	ldrb	r2, [r5, #0]
    a140:	f043 0301 	orr.w	r3, r3, #1
    a144:	f019 ff5f 	bl	24006 <log_2>
	if (handler->type == ATT_REQUEST && err) {
    a148:	2f01      	cmp	r7, #1
    a14a:	d184      	bne.n	a056 <bt_att_recv+0x1e>
		err = BT_ATT_ERR_INVALID_PDU;
    a14c:	2304      	movs	r3, #4
    a14e:	e00a      	b.n	a166 <bt_att_recv+0x12e>
		err = handler->func(att, buf);
    a150:	685b      	ldr	r3, [r3, #4]
    a152:	4631      	mov	r1, r6
    a154:	4620      	mov	r0, r4
    a156:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
    a158:	2f01      	cmp	r7, #1
		err = handler->func(att, buf);
    a15a:	4603      	mov	r3, r0
	if (handler->type == ATT_REQUEST && err) {
    a15c:	f47f af7b 	bne.w	a056 <bt_att_recv+0x1e>
    a160:	2800      	cmp	r0, #0
    a162:	f43f af78 	beq.w	a056 <bt_att_recv+0x1e>
		send_err_rsp(chan->conn, hdr->code, 0, err);
    a166:	7829      	ldrb	r1, [r5, #0]
	if (!req) {
    a168:	2900      	cmp	r1, #0
    a16a:	f43f af74 	beq.w	a056 <bt_att_recv+0x1e>
    a16e:	e7b9      	b.n	a0e4 <bt_att_recv+0xac>
    a170:	00029838 	.word	0x00029838
    a174:	00029830 	.word	0x00029830
    a178:	0002c909 	.word	0x0002c909
    a17c:	00029f08 	.word	0x00029f08
    a180:	0002c924 	.word	0x0002c924
    a184:	0002c97e 	.word	0x0002c97e
    a188:	0002c940 	.word	0x0002c940
    a18c:	0002c95f 	.word	0x0002c95f

0000a190 <att_read_group_req>:
{
    a190:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t uuid_len = buf->len - sizeof(*req);
    a194:	7b0c      	ldrb	r4, [r1, #12]
    a196:	3c04      	subs	r4, #4
    a198:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    a19a:	2c02      	cmp	r4, #2
{
    a19c:	4606      	mov	r6, r0
    a19e:	b08f      	sub	sp, #60	; 0x3c
    a1a0:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
    a1a2:	d001      	beq.n	a1a8 <att_read_group_req+0x18>
    a1a4:	2c10      	cmp	r4, #16
    a1a6:	d16f      	bne.n	a288 <att_read_group_req+0xf8>
	req = net_buf_pull_mem(buf, sizeof(*req));
    a1a8:	2104      	movs	r1, #4
    a1aa:	3008      	adds	r0, #8
	struct bt_conn *conn = att->chan.chan.conn;
    a1ac:	f8d6 9000 	ldr.w	r9, [r6]
	req = net_buf_pull_mem(buf, sizeof(*req));
    a1b0:	f015 f870 	bl	1f294 <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    a1b4:	f10d 0810 	add.w	r8, sp, #16
	start_handle = sys_le16_to_cpu(req->start_handle);
    a1b8:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    a1ba:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    a1bc:	1d01      	adds	r1, r0, #4
    a1be:	4622      	mov	r2, r4
    a1c0:	4640      	mov	r0, r8
    a1c2:	f01c f86b 	bl	2629c <bt_uuid_create>
    a1c6:	2800      	cmp	r0, #0
    a1c8:	d060      	beq.n	a28c <att_read_group_req+0xfc>
	if (!start || !end) {
    a1ca:	2d00      	cmp	r5, #0
    a1cc:	d036      	beq.n	a23c <att_read_group_req+0xac>
    a1ce:	2400      	movs	r4, #0
    a1d0:	b39f      	cbz	r7, a23a <att_read_group_req+0xaa>
	if (start > end) {
    a1d2:	42bd      	cmp	r5, r7
    a1d4:	d832      	bhi.n	a23c <att_read_group_req+0xac>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    a1d6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    a1da:	a903      	add	r1, sp, #12
    a1dc:	4640      	mov	r0, r8
    a1de:	f88d 400c 	strb.w	r4, [sp, #12]
    a1e2:	f8ad 300e 	strh.w	r3, [sp, #14]
    a1e6:	f01c f82f 	bl	26248 <bt_uuid_cmp>
    a1ea:	bb90      	cbnz	r0, a252 <att_read_group_req+0xc2>
	struct bt_conn *conn = att->chan.chan.conn;
    a1ec:	f8d6 9000 	ldr.w	r9, [r6]
	(void)memset(&data, 0, sizeof(data));
    a1f0:	2214      	movs	r2, #20
    a1f2:	2100      	movs	r1, #0
    a1f4:	a809      	add	r0, sp, #36	; 0x24
    a1f6:	f01b fd82 	bl	25cfe <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
    a1fa:	2201      	movs	r2, #1
    a1fc:	2111      	movs	r1, #17
    a1fe:	4648      	mov	r0, r9
    a200:	f7ff fe82 	bl	9f08 <bt_att_create_pdu>
    a204:	900b      	str	r0, [sp, #44]	; 0x2c
	if (!data.buf) {
    a206:	2800      	cmp	r0, #0
    a208:	d040      	beq.n	a28c <att_read_group_req+0xfc>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    a20a:	2101      	movs	r1, #1
    a20c:	3008      	adds	r0, #8
	data.uuid = uuid;
    a20e:	e9cd 6809 	strd	r6, r8, [sp, #36]	; 0x24
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    a212:	f015 f861 	bl	1f2d8 <net_buf_simple_add>
	data.rsp->len = 0U;
    a216:	2600      	movs	r6, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    a218:	900c      	str	r0, [sp, #48]	; 0x30
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    a21a:	ab09      	add	r3, sp, #36	; 0x24
	data.rsp->len = 0U;
    a21c:	7006      	strb	r6, [r0, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    a21e:	4a1c      	ldr	r2, [pc, #112]	; (a290 <att_read_group_req+0x100>)
	data.group = NULL;
    a220:	960d      	str	r6, [sp, #52]	; 0x34
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    a222:	4639      	mov	r1, r7
    a224:	4628      	mov	r0, r5
    a226:	f01c fad0 	bl	267ca <bt_gatt_foreach_attr>
	if (!data.rsp->len) {
    a22a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a22c:	781c      	ldrb	r4, [r3, #0]
    a22e:	bb1c      	cbnz	r4, a278 <att_read_group_req+0xe8>
		net_buf_unref(data.buf);
    a230:	980b      	ldr	r0, [sp, #44]	; 0x2c
    a232:	f014 ff49 	bl	1f0c8 <net_buf_unref>
	if (!req) {
    a236:	230a      	movs	r3, #10
    a238:	e018      	b.n	a26c <att_read_group_req+0xdc>
			*err = 0U;
    a23a:	463d      	mov	r5, r7
	if (!req) {
    a23c:	2301      	movs	r3, #1
    a23e:	462a      	mov	r2, r5
    a240:	2110      	movs	r1, #16
    a242:	4648      	mov	r0, r9
    a244:	f7ff fed6 	bl	9ff4 <send_err_rsp.part.0>
		return 0;
    a248:	2400      	movs	r4, #0
}
    a24a:	4620      	mov	r0, r4
    a24c:	b00f      	add	sp, #60	; 0x3c
    a24e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
    a252:	f642 0301 	movw	r3, #10241	; 0x2801
    a256:	a909      	add	r1, sp, #36	; 0x24
    a258:	4640      	mov	r0, r8
    a25a:	f88d 4024 	strb.w	r4, [sp, #36]	; 0x24
    a25e:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
    a262:	f01b fff1 	bl	26248 <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    a266:	2800      	cmp	r0, #0
    a268:	d0c0      	beq.n	a1ec <att_read_group_req+0x5c>
	if (!req) {
    a26a:	2310      	movs	r3, #16
    a26c:	462a      	mov	r2, r5
    a26e:	2110      	movs	r1, #16
    a270:	4648      	mov	r0, r9
    a272:	f7ff febf 	bl	9ff4 <send_err_rsp.part.0>
		return 0;
    a276:	e7e8      	b.n	a24a <att_read_group_req+0xba>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    a278:	4b06      	ldr	r3, [pc, #24]	; (a294 <att_read_group_req+0x104>)
    a27a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    a27c:	9600      	str	r6, [sp, #0]
    a27e:	2104      	movs	r1, #4
    a280:	4648      	mov	r0, r9
    a282:	f01c fa3a 	bl	266fa <bt_l2cap_send_cb>
	return 0;
    a286:	e7df      	b.n	a248 <att_read_group_req+0xb8>
		return BT_ATT_ERR_INVALID_PDU;
    a288:	2404      	movs	r4, #4
    a28a:	e7de      	b.n	a24a <att_read_group_req+0xba>
		return BT_ATT_ERR_UNLIKELY;
    a28c:	240e      	movs	r4, #14
    a28e:	e7dc      	b.n	a24a <att_read_group_req+0xba>
    a290:	000267e1 	.word	0x000267e1
    a294:	00026a8b 	.word	0x00026a8b

0000a298 <att_read_mult_req>:
{
    a298:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    a29c:	6806      	ldr	r6, [r0, #0]
{
    a29e:	b089      	sub	sp, #36	; 0x24
	(void)memset(&data, 0, sizeof(data));
    a2a0:	2214      	movs	r2, #20
{
    a2a2:	4605      	mov	r5, r0
    a2a4:	460c      	mov	r4, r1
	(void)memset(&data, 0, sizeof(data));
    a2a6:	a803      	add	r0, sp, #12
    a2a8:	2100      	movs	r1, #0
    a2aa:	f01b fd28 	bl	25cfe <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
    a2ae:	2200      	movs	r2, #0
    a2b0:	210f      	movs	r1, #15
    a2b2:	4630      	mov	r0, r6
    a2b4:	f7ff fe28 	bl	9f08 <bt_att_create_pdu>
    a2b8:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
    a2ba:	b378      	cbz	r0, a31c <att_read_mult_req+0x84>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    a2bc:	f8df 9064 	ldr.w	r9, [pc, #100]	; a324 <att_read_mult_req+0x8c>
	data.att = att;
    a2c0:	9503      	str	r5, [sp, #12]
		handle = net_buf_pull_le16(buf);
    a2c2:	f104 0708 	add.w	r7, r4, #8
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    a2c6:	f04f 0801 	mov.w	r8, #1
	while (buf->len >= sizeof(u16_t)) {
    a2ca:	89a3      	ldrh	r3, [r4, #12]
    a2cc:	2b01      	cmp	r3, #1
    a2ce:	d808      	bhi.n	a2e2 <att_read_mult_req+0x4a>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    a2d0:	2400      	movs	r4, #0
    a2d2:	4b13      	ldr	r3, [pc, #76]	; (a320 <att_read_mult_req+0x88>)
    a2d4:	9a05      	ldr	r2, [sp, #20]
    a2d6:	9400      	str	r4, [sp, #0]
    a2d8:	2104      	movs	r1, #4
    a2da:	4630      	mov	r0, r6
    a2dc:	f01c fa0d 	bl	266fa <bt_l2cap_send_cb>
	return 0;
    a2e0:	e018      	b.n	a314 <att_read_mult_req+0x7c>
		handle = net_buf_pull_le16(buf);
    a2e2:	4638      	mov	r0, r7
    a2e4:	f01e fd3f 	bl	28d66 <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    a2e8:	ab03      	add	r3, sp, #12
    a2ea:	464a      	mov	r2, r9
    a2ec:	4601      	mov	r1, r0
		handle = net_buf_pull_le16(buf);
    a2ee:	4605      	mov	r5, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    a2f0:	f88d 801c 	strb.w	r8, [sp, #28]
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    a2f4:	f01c fa69 	bl	267ca <bt_gatt_foreach_attr>
		if (data.err) {
    a2f8:	f89d 301c 	ldrb.w	r3, [sp, #28]
    a2fc:	2b00      	cmp	r3, #0
    a2fe:	d0e4      	beq.n	a2ca <att_read_mult_req+0x32>
			net_buf_unref(data.buf);
    a300:	9805      	ldr	r0, [sp, #20]
    a302:	f014 fee1 	bl	1f0c8 <net_buf_unref>
	if (!req) {
    a306:	f89d 301c 	ldrb.w	r3, [sp, #28]
    a30a:	462a      	mov	r2, r5
    a30c:	210e      	movs	r1, #14
    a30e:	4630      	mov	r0, r6
    a310:	f7ff fe70 	bl	9ff4 <send_err_rsp.part.0>
			return 0;
    a314:	2000      	movs	r0, #0
}
    a316:	b009      	add	sp, #36	; 0x24
    a318:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_ATT_ERR_UNLIKELY;
    a31c:	200e      	movs	r0, #14
    a31e:	e7fa      	b.n	a316 <att_read_mult_req+0x7e>
    a320:	00026a8b 	.word	0x00026a8b
    a324:	00026b19 	.word	0x00026b19

0000a328 <att_read_rsp>:
{
    a328:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    a32c:	6806      	ldr	r6, [r0, #0]
{
    a32e:	b088      	sub	sp, #32
    a330:	4604      	mov	r4, r0
    a332:	460f      	mov	r7, r1
	if (!bt_gatt_change_aware(conn, true)) {
    a334:	4630      	mov	r0, r6
    a336:	2101      	movs	r1, #1
{
    a338:	4690      	mov	r8, r2
    a33a:	461d      	mov	r5, r3
	if (!bt_gatt_change_aware(conn, true)) {
    a33c:	f01c fe22 	bl	26f84 <bt_gatt_change_aware>
    a340:	b3a0      	cbz	r0, a3ac <att_read_rsp+0x84>
	if (!handle) {
    a342:	b3ad      	cbz	r5, a3b0 <att_read_rsp+0x88>
	(void)memset(&data, 0, sizeof(data));
    a344:	2214      	movs	r2, #20
    a346:	2100      	movs	r1, #0
    a348:	a803      	add	r0, sp, #12
    a34a:	f01b fcd8 	bl	25cfe <memset>
	data.buf = bt_att_create_pdu(conn, rsp, 0);
    a34e:	2200      	movs	r2, #0
    a350:	4641      	mov	r1, r8
    a352:	4630      	mov	r0, r6
    a354:	f7ff fdd8 	bl	9f08 <bt_att_create_pdu>
    a358:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
    a35a:	b358      	cbz	r0, a3b4 <att_read_rsp+0x8c>
	data.offset = offset;
    a35c:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
    a360:	f8ad 3010 	strh.w	r3, [sp, #16]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    a364:	2301      	movs	r3, #1
    a366:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    a36a:	4a13      	ldr	r2, [pc, #76]	; (a3b8 <att_read_rsp+0x90>)
	data.att = att;
    a36c:	9403      	str	r4, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    a36e:	ab03      	add	r3, sp, #12
    a370:	4629      	mov	r1, r5
    a372:	4628      	mov	r0, r5
    a374:	f01c fa29 	bl	267ca <bt_gatt_foreach_attr>
	if (data.err) {
    a378:	f89d 401c 	ldrb.w	r4, [sp, #28]
    a37c:	b174      	cbz	r4, a39c <att_read_rsp+0x74>
		net_buf_unref(data.buf);
    a37e:	9805      	ldr	r0, [sp, #20]
    a380:	f014 fea2 	bl	1f0c8 <net_buf_unref>
	if (!req) {
    a384:	f89d 301c 	ldrb.w	r3, [sp, #28]
    a388:	462a      	mov	r2, r5
    a38a:	4639      	mov	r1, r7
    a38c:	4630      	mov	r0, r6
    a38e:	f7ff fe31 	bl	9ff4 <send_err_rsp.part.0>
		return 0;
    a392:	2400      	movs	r4, #0
}
    a394:	4620      	mov	r0, r4
    a396:	b008      	add	sp, #32
    a398:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    a39c:	4b07      	ldr	r3, [pc, #28]	; (a3bc <att_read_rsp+0x94>)
    a39e:	9a05      	ldr	r2, [sp, #20]
    a3a0:	9400      	str	r4, [sp, #0]
    a3a2:	2104      	movs	r1, #4
    a3a4:	4630      	mov	r0, r6
    a3a6:	f01c f9a8 	bl	266fa <bt_l2cap_send_cb>
	return 0;
    a3aa:	e7f3      	b.n	a394 <att_read_rsp+0x6c>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    a3ac:	2412      	movs	r4, #18
    a3ae:	e7f1      	b.n	a394 <att_read_rsp+0x6c>
		return BT_ATT_ERR_INVALID_HANDLE;
    a3b0:	2401      	movs	r4, #1
    a3b2:	e7ef      	b.n	a394 <att_read_rsp+0x6c>
		return BT_ATT_ERR_UNLIKELY;
    a3b4:	240e      	movs	r4, #14
    a3b6:	e7ed      	b.n	a394 <att_read_rsp+0x6c>
    a3b8:	00026b19 	.word	0x00026b19
    a3bc:	00026a8b 	.word	0x00026a8b

0000a3c0 <att_read_type_req>:
{
    a3c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t uuid_len = buf->len - sizeof(*req);
    a3c4:	7b0c      	ldrb	r4, [r1, #12]
    a3c6:	3c04      	subs	r4, #4
    a3c8:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    a3ca:	2c02      	cmp	r4, #2
{
    a3cc:	4606      	mov	r6, r0
    a3ce:	b08f      	sub	sp, #60	; 0x3c
    a3d0:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
    a3d2:	d001      	beq.n	a3d8 <att_read_type_req+0x18>
    a3d4:	2c10      	cmp	r4, #16
    a3d6:	d152      	bne.n	a47e <att_read_type_req+0xbe>
	req = net_buf_pull_mem(buf, sizeof(*req));
    a3d8:	2104      	movs	r1, #4
    a3da:	3008      	adds	r0, #8
	struct bt_conn *conn = att->chan.chan.conn;
    a3dc:	f8d6 9000 	ldr.w	r9, [r6]
	req = net_buf_pull_mem(buf, sizeof(*req));
    a3e0:	f014 ff58 	bl	1f294 <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    a3e4:	f10d 080c 	add.w	r8, sp, #12
	start_handle = sys_le16_to_cpu(req->start_handle);
    a3e8:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    a3ea:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    a3ec:	1d01      	adds	r1, r0, #4
    a3ee:	4622      	mov	r2, r4
    a3f0:	4640      	mov	r0, r8
    a3f2:	f01b ff53 	bl	2629c <bt_uuid_create>
    a3f6:	b188      	cbz	r0, a41c <att_read_type_req+0x5c>
	if (!start || !end) {
    a3f8:	b19d      	cbz	r5, a422 <att_read_type_req+0x62>
    a3fa:	b18f      	cbz	r7, a420 <att_read_type_req+0x60>
	if (start > end) {
    a3fc:	42bd      	cmp	r5, r7
    a3fe:	d810      	bhi.n	a422 <att_read_type_req+0x62>
	struct bt_conn *conn = att->chan.chan.conn;
    a400:	f8d6 9000 	ldr.w	r9, [r6]
	(void)memset(&data, 0, sizeof(data));
    a404:	2218      	movs	r2, #24
    a406:	2100      	movs	r1, #0
    a408:	a808      	add	r0, sp, #32
    a40a:	f01b fc78 	bl	25cfe <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
    a40e:	2201      	movs	r2, #1
    a410:	2109      	movs	r1, #9
    a412:	4648      	mov	r0, r9
    a414:	f7ff fd78 	bl	9f08 <bt_att_create_pdu>
    a418:	900a      	str	r0, [sp, #40]	; 0x28
	if (!data.buf) {
    a41a:	b968      	cbnz	r0, a438 <att_read_type_req+0x78>
		return BT_ATT_ERR_UNLIKELY;
    a41c:	240e      	movs	r4, #14
    a41e:	e007      	b.n	a430 <att_read_type_req+0x70>
			*err = 0U;
    a420:	463d      	mov	r5, r7
	if (!req) {
    a422:	2301      	movs	r3, #1
    a424:	462a      	mov	r2, r5
    a426:	2108      	movs	r1, #8
    a428:	4648      	mov	r0, r9
    a42a:	f7ff fde3 	bl	9ff4 <send_err_rsp.part.0>
		return 0;
    a42e:	2400      	movs	r4, #0
}
    a430:	4620      	mov	r0, r4
    a432:	b00f      	add	sp, #60	; 0x3c
    a434:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    a438:	2101      	movs	r1, #1
    a43a:	3008      	adds	r0, #8
	data.uuid = uuid;
    a43c:	e9cd 6808 	strd	r6, r8, [sp, #32]
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    a440:	f014 ff4a 	bl	1f2d8 <net_buf_simple_add>
	data.rsp->len = 0U;
    a444:	2600      	movs	r6, #0
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    a446:	230a      	movs	r3, #10
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    a448:	900b      	str	r0, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    a44a:	4a0e      	ldr	r2, [pc, #56]	; (a484 <att_read_type_req+0xc4>)
	data.rsp->len = 0U;
    a44c:	7006      	strb	r6, [r0, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    a44e:	4639      	mov	r1, r7
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    a450:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    a454:	4628      	mov	r0, r5
    a456:	ab08      	add	r3, sp, #32
    a458:	f01c f9b7 	bl	267ca <bt_gatt_foreach_attr>
	if (data.err) {
    a45c:	f89d 4034 	ldrb.w	r4, [sp, #52]	; 0x34
    a460:	b12c      	cbz	r4, a46e <att_read_type_req+0xae>
		net_buf_unref(data.buf);
    a462:	980a      	ldr	r0, [sp, #40]	; 0x28
    a464:	f014 fe30 	bl	1f0c8 <net_buf_unref>
	if (!req) {
    a468:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
    a46c:	e7da      	b.n	a424 <att_read_type_req+0x64>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    a46e:	4b06      	ldr	r3, [pc, #24]	; (a488 <att_read_type_req+0xc8>)
    a470:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    a472:	9400      	str	r4, [sp, #0]
    a474:	2104      	movs	r1, #4
    a476:	4648      	mov	r0, r9
    a478:	f01c f93f 	bl	266fa <bt_l2cap_send_cb>
	return 0;
    a47c:	e7d8      	b.n	a430 <att_read_type_req+0x70>
		return BT_ATT_ERR_INVALID_PDU;
    a47e:	2404      	movs	r4, #4
    a480:	e7d6      	b.n	a430 <att_read_type_req+0x70>
    a482:	bf00      	nop
    a484:	000268ad 	.word	0x000268ad
    a488:	00026a8b 	.word	0x00026a8b

0000a48c <att_find_type_req>:
{
    a48c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a490:	4688      	mov	r8, r1
	struct bt_conn *conn = att->chan.chan.conn;
    a492:	f8d0 9000 	ldr.w	r9, [r0]
{
    a496:	b089      	sub	sp, #36	; 0x24
    a498:	4607      	mov	r7, r0
	req = net_buf_pull_mem(buf, sizeof(*req));
    a49a:	2106      	movs	r1, #6
    a49c:	f108 0008 	add.w	r0, r8, #8
    a4a0:	f014 fef8 	bl	1f294 <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
    a4a4:	8806      	ldrh	r6, [r0, #0]
	if (!start || !end) {
    a4a6:	b316      	cbz	r6, a4ee <att_find_type_req+0x62>
	end_handle = sys_le16_to_cpu(req->end_handle);
    a4a8:	f8b0 a002 	ldrh.w	sl, [r0, #2]
	if (!start || !end) {
    a4ac:	f1ba 0f00 	cmp.w	sl, #0
    a4b0:	d01c      	beq.n	a4ec <att_find_type_req+0x60>
	if (start > end) {
    a4b2:	45b2      	cmp	sl, r6
    a4b4:	d31b      	bcc.n	a4ee <att_find_type_req+0x62>
	type = sys_le16_to_cpu(req->type);
    a4b6:	8883      	ldrh	r3, [r0, #4]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    a4b8:	f8ad 300a 	strh.w	r3, [sp, #10]
    a4bc:	2400      	movs	r4, #0
    a4be:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    a4c2:	a903      	add	r1, sp, #12
    a4c4:	a802      	add	r0, sp, #8
	value = buf->data;
    a4c6:	f8d8 b008 	ldr.w	fp, [r8, #8]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    a4ca:	f88d 4008 	strb.w	r4, [sp, #8]
    a4ce:	f88d 400c 	strb.w	r4, [sp, #12]
    a4d2:	f8ad 300e 	strh.w	r3, [sp, #14]
    a4d6:	f01b feb7 	bl	26248 <bt_uuid_cmp>
    a4da:	4605      	mov	r5, r0
    a4dc:	b190      	cbz	r0, a504 <att_find_type_req+0x78>
	if (!req) {
    a4de:	230a      	movs	r3, #10
    a4e0:	4632      	mov	r2, r6
    a4e2:	2106      	movs	r1, #6
    a4e4:	4648      	mov	r0, r9
    a4e6:	f7ff fd85 	bl	9ff4 <send_err_rsp.part.0>
		return 0;
    a4ea:	e007      	b.n	a4fc <att_find_type_req+0x70>
			*err = 0U;
    a4ec:	4656      	mov	r6, sl
	if (!req) {
    a4ee:	2301      	movs	r3, #1
    a4f0:	4632      	mov	r2, r6
    a4f2:	2106      	movs	r1, #6
    a4f4:	4648      	mov	r0, r9
    a4f6:	f7ff fd7d 	bl	9ff4 <send_err_rsp.part.0>
		return 0;
    a4fa:	2400      	movs	r4, #0
}
    a4fc:	4620      	mov	r0, r4
    a4fe:	b009      	add	sp, #36	; 0x24
    a500:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return att_find_type_rsp(att, start_handle, end_handle, value,
    a504:	f898 400c 	ldrb.w	r4, [r8, #12]
	struct bt_conn *conn = att->chan.chan.conn;
    a508:	f8d7 8000 	ldr.w	r8, [r7]
	(void)memset(&data, 0, sizeof(data));
    a50c:	4601      	mov	r1, r0
    a50e:	2214      	movs	r2, #20
    a510:	a803      	add	r0, sp, #12
    a512:	f01b fbf4 	bl	25cfe <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
    a516:	462a      	mov	r2, r5
    a518:	2107      	movs	r1, #7
    a51a:	4640      	mov	r0, r8
    a51c:	f7ff fcf4 	bl	9f08 <bt_att_create_pdu>
    a520:	9004      	str	r0, [sp, #16]
	if (!data.buf) {
    a522:	b308      	cbz	r0, a568 <att_find_type_req+0xdc>
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    a524:	230a      	movs	r3, #10
    a526:	f88d 301d 	strb.w	r3, [sp, #29]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    a52a:	4a10      	ldr	r2, [pc, #64]	; (a56c <att_find_type_req+0xe0>)
	data.value_len = value_len;
    a52c:	f88d 401c 	strb.w	r4, [sp, #28]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    a530:	ab03      	add	r3, sp, #12
    a532:	4651      	mov	r1, sl
    a534:	4630      	mov	r0, r6
	data.value = value;
    a536:	e9cd 5b05 	strd	r5, fp, [sp, #20]
	data.att = att;
    a53a:	9703      	str	r7, [sp, #12]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    a53c:	f01c f945 	bl	267ca <bt_gatt_foreach_attr>
	if (data.err) {
    a540:	f89d 401d 	ldrb.w	r4, [sp, #29]
    a544:	b144      	cbz	r4, a558 <att_find_type_req+0xcc>
		net_buf_unref(data.buf);
    a546:	9804      	ldr	r0, [sp, #16]
    a548:	f014 fdbe 	bl	1f0c8 <net_buf_unref>
	if (!req) {
    a54c:	f89d 301d 	ldrb.w	r3, [sp, #29]
    a550:	4632      	mov	r2, r6
    a552:	2106      	movs	r1, #6
    a554:	4640      	mov	r0, r8
    a556:	e7ce      	b.n	a4f6 <att_find_type_req+0x6a>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    a558:	4b05      	ldr	r3, [pc, #20]	; (a570 <att_find_type_req+0xe4>)
    a55a:	9a04      	ldr	r2, [sp, #16]
    a55c:	9400      	str	r4, [sp, #0]
    a55e:	2104      	movs	r1, #4
    a560:	4640      	mov	r0, r8
    a562:	f01c f8ca 	bl	266fa <bt_l2cap_send_cb>
	return 0;
    a566:	e7c9      	b.n	a4fc <att_find_type_req+0x70>
		return BT_ATT_ERR_UNLIKELY;
    a568:	240e      	movs	r4, #14
	return att_find_type_rsp(att, start_handle, end_handle, value,
    a56a:	e7c7      	b.n	a4fc <att_find_type_req+0x70>
    a56c:	00009aa9 	.word	0x00009aa9
    a570:	00026a8b 	.word	0x00026a8b

0000a574 <att_find_info_req>:
{
    a574:	b5f0      	push	{r4, r5, r6, r7, lr}
	req = (void *)buf->data;
    a576:	688b      	ldr	r3, [r1, #8]
	struct bt_conn *conn = att->chan.chan.conn;
    a578:	6806      	ldr	r6, [r0, #0]
	start_handle = sys_le16_to_cpu(req->start_handle);
    a57a:	881d      	ldrh	r5, [r3, #0]
{
    a57c:	b087      	sub	sp, #28
    a57e:	4607      	mov	r7, r0
	if (!start || !end) {
    a580:	b195      	cbz	r5, a5a8 <att_find_info_req+0x34>
	end_handle = sys_le16_to_cpu(req->end_handle);
    a582:	885c      	ldrh	r4, [r3, #2]
	if (!start || !end) {
    a584:	b17c      	cbz	r4, a5a6 <att_find_info_req+0x32>
	if (start > end) {
    a586:	42ac      	cmp	r4, r5
    a588:	d30e      	bcc.n	a5a8 <att_find_info_req+0x34>
	(void)memset(&data, 0, sizeof(data));
    a58a:	2210      	movs	r2, #16
    a58c:	2100      	movs	r1, #0
    a58e:	a802      	add	r0, sp, #8
    a590:	f01b fbb5 	bl	25cfe <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
    a594:	2200      	movs	r2, #0
    a596:	2105      	movs	r1, #5
    a598:	4630      	mov	r0, r6
    a59a:	f7ff fcb5 	bl	9f08 <bt_att_create_pdu>
    a59e:	9003      	str	r0, [sp, #12]
	if (!data.buf) {
    a5a0:	b958      	cbnz	r0, a5ba <att_find_info_req+0x46>
		return BT_ATT_ERR_UNLIKELY;
    a5a2:	200e      	movs	r0, #14
	return att_find_info_rsp(att, start_handle, end_handle);
    a5a4:	e007      	b.n	a5b6 <att_find_info_req+0x42>
			*err = 0U;
    a5a6:	4625      	mov	r5, r4
	if (!req) {
    a5a8:	2301      	movs	r3, #1
    a5aa:	462a      	mov	r2, r5
    a5ac:	2104      	movs	r1, #4
    a5ae:	4630      	mov	r0, r6
    a5b0:	f7ff fd20 	bl	9ff4 <send_err_rsp.part.0>
		return 0;
    a5b4:	2000      	movs	r0, #0
}
    a5b6:	b007      	add	sp, #28
    a5b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    a5ba:	4621      	mov	r1, r4
    a5bc:	4a0a      	ldr	r2, [pc, #40]	; (a5e8 <att_find_info_req+0x74>)
	data.att = att;
    a5be:	9702      	str	r7, [sp, #8]
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    a5c0:	ab02      	add	r3, sp, #8
    a5c2:	4628      	mov	r0, r5
    a5c4:	f01c f901 	bl	267ca <bt_gatt_foreach_attr>
	if (!data.rsp) {
    a5c8:	9c04      	ldr	r4, [sp, #16]
    a5ca:	b924      	cbnz	r4, a5d6 <att_find_info_req+0x62>
		net_buf_unref(data.buf);
    a5cc:	9803      	ldr	r0, [sp, #12]
    a5ce:	f014 fd7b 	bl	1f0c8 <net_buf_unref>
	if (!req) {
    a5d2:	230a      	movs	r3, #10
    a5d4:	e7e9      	b.n	a5aa <att_find_info_req+0x36>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
    a5d6:	2400      	movs	r4, #0
    a5d8:	4b04      	ldr	r3, [pc, #16]	; (a5ec <att_find_info_req+0x78>)
    a5da:	9a03      	ldr	r2, [sp, #12]
    a5dc:	9400      	str	r4, [sp, #0]
    a5de:	2104      	movs	r1, #4
    a5e0:	4630      	mov	r0, r6
    a5e2:	f01c f88a 	bl	266fa <bt_l2cap_send_cb>
	return 0;
    a5e6:	e7e5      	b.n	a5b4 <att_find_info_req+0x40>
    a5e8:	00026965 	.word	0x00026965
    a5ec:	00026a8b 	.word	0x00026a8b

0000a5f0 <att_write_req>:
{
    a5f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = att->chan.chan.conn;
    a5f4:	6806      	ldr	r6, [r0, #0]
{
    a5f6:	b089      	sub	sp, #36	; 0x24
	handle = net_buf_pull_le16(buf);
    a5f8:	f101 0008 	add.w	r0, r1, #8
{
    a5fc:	460c      	mov	r4, r1
	handle = net_buf_pull_le16(buf);
    a5fe:	f01e fbb2 	bl	28d66 <net_buf_simple_pull_le16>
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    a602:	2101      	movs	r1, #1
	handle = net_buf_pull_le16(buf);
    a604:	4605      	mov	r5, r0
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    a606:	4630      	mov	r0, r6
			     handle, 0, buf->data, buf->len);
    a608:	f8d4 9008 	ldr.w	r9, [r4, #8]
	return att_write_rsp(conn, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
    a60c:	89a4      	ldrh	r4, [r4, #12]
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
    a60e:	f01c fcb9 	bl	26f84 <bt_gatt_change_aware>
    a612:	2800      	cmp	r0, #0
    a614:	d040      	beq.n	a698 <att_write_req+0xa8>
	if (!handle) {
    a616:	2d00      	cmp	r5, #0
    a618:	d040      	beq.n	a69c <att_write_req+0xac>
	(void)memset(&data, 0, sizeof(data));
    a61a:	2218      	movs	r2, #24
    a61c:	2100      	movs	r1, #0
    a61e:	a802      	add	r0, sp, #8
    a620:	f01b fb6d 	bl	25cfe <memset>
		data.buf = bt_att_create_pdu(conn, rsp, 0);
    a624:	2200      	movs	r2, #0
    a626:	2113      	movs	r1, #19
    a628:	4630      	mov	r0, r6
    a62a:	f7ff fc6d 	bl	9f08 <bt_att_create_pdu>
    a62e:	9003      	str	r0, [sp, #12]
		if (!data.buf) {
    a630:	b380      	cbz	r0, a694 <att_write_req+0xa4>
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    a632:	2301      	movs	r3, #1
    a634:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    a638:	4a19      	ldr	r2, [pc, #100]	; (a6a0 <att_write_req+0xb0>)
	data.len = len;
    a63a:	f8ad 4018 	strh.w	r4, [sp, #24]
	data.req = req;
    a63e:	f04f 0812 	mov.w	r8, #18
	data.offset = offset;
    a642:	2700      	movs	r7, #0
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    a644:	ab02      	add	r3, sp, #8
    a646:	4629      	mov	r1, r5
    a648:	4628      	mov	r0, r5
	data.conn = conn;
    a64a:	9602      	str	r6, [sp, #8]
	data.req = req;
    a64c:	f88d 8010 	strb.w	r8, [sp, #16]
	data.offset = offset;
    a650:	f8ad 701a 	strh.w	r7, [sp, #26]
	data.value = value;
    a654:	f8cd 9014 	str.w	r9, [sp, #20]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    a658:	f01c f8b7 	bl	267ca <bt_gatt_foreach_attr>
	if (data.err) {
    a65c:	f89d 401c 	ldrb.w	r4, [sp, #28]
    a660:	b174      	cbz	r4, a680 <att_write_req+0x90>
			net_buf_unref(data.buf);
    a662:	9803      	ldr	r0, [sp, #12]
    a664:	f014 fd30 	bl	1f0c8 <net_buf_unref>
	if (!req) {
    a668:	f89d 301c 	ldrb.w	r3, [sp, #28]
    a66c:	462a      	mov	r2, r5
    a66e:	4641      	mov	r1, r8
    a670:	4630      	mov	r0, r6
    a672:	f7ff fcbf 	bl	9ff4 <send_err_rsp.part.0>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
    a676:	463c      	mov	r4, r7
}
    a678:	4620      	mov	r0, r4
    a67a:	b009      	add	sp, #36	; 0x24
    a67c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (data.buf) {
    a680:	9a03      	ldr	r2, [sp, #12]
    a682:	2a00      	cmp	r2, #0
    a684:	d0f8      	beq.n	a678 <att_write_req+0x88>
		(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf,
    a686:	4b07      	ldr	r3, [pc, #28]	; (a6a4 <att_write_req+0xb4>)
    a688:	9400      	str	r4, [sp, #0]
    a68a:	2104      	movs	r1, #4
    a68c:	4630      	mov	r0, r6
    a68e:	f01c f834 	bl	266fa <bt_l2cap_send_cb>
    a692:	e7f1      	b.n	a678 <att_write_req+0x88>
			return BT_ATT_ERR_UNLIKELY;
    a694:	240e      	movs	r4, #14
    a696:	e7ef      	b.n	a678 <att_write_req+0x88>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    a698:	2412      	movs	r4, #18
    a69a:	e7ed      	b.n	a678 <att_write_req+0x88>
		return BT_ATT_ERR_INVALID_HANDLE;
    a69c:	2401      	movs	r4, #1
    a69e:	e7eb      	b.n	a678 <att_write_req+0x88>
    a6a0:	00026abd 	.word	0x00026abd
    a6a4:	00026a8b 	.word	0x00026a8b

0000a6a8 <bt_att_req_alloc>:
	/* tx and rx MTU shall be symmetric */
	return att->chan.tx.mtu;
}

struct bt_att_req *bt_att_req_alloc(s32_t timeout)
{
    a6a8:	b513      	push	{r0, r1, r4, lr}
    a6aa:	4602      	mov	r2, r0
	struct bt_att_req *req = NULL;

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    a6ac:	a901      	add	r1, sp, #4
    a6ae:	4808      	ldr	r0, [pc, #32]	; (a6d0 <bt_att_req_alloc+0x28>)
	struct bt_att_req *req = NULL;
    a6b0:	2400      	movs	r4, #0
    a6b2:	9401      	str	r4, [sp, #4]
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    a6b4:	f016 f864 	bl	20780 <k_mem_slab_alloc>
    a6b8:	4601      	mov	r1, r0
    a6ba:	b930      	cbnz	r0, a6ca <bt_att_req_alloc+0x22>
		return NULL;
	}

	BT_DBG("req %p", req);

	memset(req, 0, sizeof(*req));
    a6bc:	9801      	ldr	r0, [sp, #4]
    a6be:	2218      	movs	r2, #24
    a6c0:	f01b fb1d 	bl	25cfe <memset>

	return req;
    a6c4:	9801      	ldr	r0, [sp, #4]
}
    a6c6:	b002      	add	sp, #8
    a6c8:	bd10      	pop	{r4, pc}
		return NULL;
    a6ca:	4620      	mov	r0, r4
    a6cc:	e7fb      	b.n	a6c6 <bt_att_req_alloc+0x1e>
    a6ce:	bf00      	nop
    a6d0:	20007578 	.word	0x20007578

0000a6d4 <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
    a6d4:	b507      	push	{r0, r1, r2, lr}
    a6d6:	9001      	str	r0, [sp, #4]
	BT_DBG("req %p", req);

	k_mem_slab_free(&req_slab, (void **)&req);
    a6d8:	a901      	add	r1, sp, #4
    a6da:	4803      	ldr	r0, [pc, #12]	; (a6e8 <bt_att_req_free+0x14>)
    a6dc:	f016 f8b4 	bl	20848 <k_mem_slab_free>
}
    a6e0:	b003      	add	sp, #12
    a6e2:	f85d fb04 	ldr.w	pc, [sp], #4
    a6e6:	bf00      	nop
    a6e8:	20007578 	.word	0x20007578

0000a6ec <att_handle_rsp>:
{
    a6ec:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    a6f0:	4604      	mov	r4, r0
	k_delayed_work_cancel(&att->timeout_work);
    a6f2:	30a8      	adds	r0, #168	; 0xa8
{
    a6f4:	460e      	mov	r6, r1
    a6f6:	4617      	mov	r7, r2
    a6f8:	4698      	mov	r8, r3
	k_delayed_work_cancel(&att->timeout_work);
    a6fa:	f018 fac1 	bl	22c80 <k_delayed_work_cancel>
	if (!att->req) {
    a6fe:	f8d4 509c 	ldr.w	r5, [r4, #156]	; 0x9c
    a702:	bb25      	cbnz	r5, a74e <att_handle_rsp+0x62>
    a704:	4920      	ldr	r1, [pc, #128]	; (a788 <att_handle_rsp+0x9c>)
    a706:	4821      	ldr	r0, [pc, #132]	; (a78c <att_handle_rsp+0xa0>)
    a708:	1a40      	subs	r0, r0, r1
    a70a:	08c0      	lsrs	r0, r0, #3
		BT_WARN("No pending ATT request");
    a70c:	0180      	lsls	r0, r0, #6
    a70e:	f040 0102 	orr.w	r1, r0, #2
    a712:	481f      	ldr	r0, [pc, #124]	; (a790 <att_handle_rsp+0xa4>)
    a714:	f019 fc56 	bl	23fc4 <log_0>
Z_GENLIST_IS_EMPTY(slist)
    a718:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
Z_GENLIST_GET(slist, snode)
    a71c:	b159      	cbz	r1, a736 <att_handle_rsp+0x4a>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    a71e:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
    a722:	680b      	ldr	r3, [r1, #0]
	list->head = node;
    a724:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    a728:	4291      	cmp	r1, r2
    a72a:	d101      	bne.n	a730 <att_handle_rsp+0x44>
	list->tail = node;
    a72c:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
	att_send_req(att, ATT_REQ(node));
    a730:	4620      	mov	r0, r4
    a732:	f7ff fb35 	bl	9da0 <att_send_req>
	if (func) {
    a736:	b135      	cbz	r5, a746 <att_handle_rsp+0x5a>
		func(att->chan.chan.conn, err, pdu, len, params);
    a738:	6820      	ldr	r0, [r4, #0]
    a73a:	f8cd 9000 	str.w	r9, [sp]
    a73e:	463b      	mov	r3, r7
    a740:	4632      	mov	r2, r6
    a742:	4641      	mov	r1, r8
    a744:	47a8      	blx	r5
}
    a746:	2000      	movs	r0, #0
    a748:	b002      	add	sp, #8
    a74a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (att->req == &cancel) {
    a74e:	4b11      	ldr	r3, [pc, #68]	; (a794 <att_handle_rsp+0xa8>)
    a750:	429d      	cmp	r5, r3
    a752:	d103      	bne.n	a75c <att_handle_rsp+0x70>
		att->req = NULL;
    a754:	2500      	movs	r5, #0
    a756:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
		goto process;
    a75a:	e7dd      	b.n	a718 <att_handle_rsp+0x2c>
	if (att->req->buf) {
    a75c:	6928      	ldr	r0, [r5, #16]
    a75e:	b128      	cbz	r0, a76c <att_handle_rsp+0x80>
		net_buf_unref(att->req->buf);
    a760:	f014 fcb2 	bl	1f0c8 <net_buf_unref>
		att->req->buf = NULL;
    a764:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    a768:	2200      	movs	r2, #0
    a76a:	611a      	str	r2, [r3, #16]
	func = att->req->func;
    a76c:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
	att->req->func = NULL;
    a770:	f04f 0a00 	mov.w	sl, #0
	func = att->req->func;
    a774:	6845      	ldr	r5, [r0, #4]
	att->req->func = NULL;
    a776:	f8c0 a004 	str.w	sl, [r0, #4]
	params = att->req->user_data;
    a77a:	f8d0 9014 	ldr.w	r9, [r0, #20]
	att_req_destroy(att->req);
    a77e:	f01c fa27 	bl	26bd0 <att_req_destroy>
	att->req = NULL;
    a782:	f8c4 a09c 	str.w	sl, [r4, #156]	; 0x9c
    a786:	e7c7      	b.n	a718 <att_handle_rsp+0x2c>
    a788:	00029830 	.word	0x00029830
    a78c:	00029838 	.word	0x00029838
    a790:	0002c998 	.word	0x0002c998
    a794:	2000069c 	.word	0x2000069c

0000a798 <att_timeout>:
    a798:	4b0b      	ldr	r3, [pc, #44]	; (a7c8 <att_timeout+0x30>)
    a79a:	490c      	ldr	r1, [pc, #48]	; (a7cc <att_timeout+0x34>)
    a79c:	1ac9      	subs	r1, r1, r3
    a79e:	08c9      	lsrs	r1, r1, #3
{
    a7a0:	b510      	push	{r4, lr}
	BT_ERR("ATT Timeout");
    a7a2:	0189      	lsls	r1, r1, #6
{
    a7a4:	4604      	mov	r4, r0
	BT_ERR("ATT Timeout");
    a7a6:	f041 0101 	orr.w	r1, r1, #1
    a7aa:	4809      	ldr	r0, [pc, #36]	; (a7d0 <att_timeout+0x38>)
    a7ac:	f019 fc0a 	bl	23fc4 <log_0>
	att_reset(att);
    a7b0:	f1a4 00a8 	sub.w	r0, r4, #168	; 0xa8
    a7b4:	f01c fa20 	bl	26bf8 <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
    a7b8:	f854 0ca8 	ldr.w	r0, [r4, #-168]
    a7bc:	f001 fa82 	bl	bcc4 <bt_gatt_disconnected>
	ch->chan.conn = NULL;
    a7c0:	2300      	movs	r3, #0
    a7c2:	f844 3ca8 	str.w	r3, [r4, #-168]
}
    a7c6:	bd10      	pop	{r4, pc}
    a7c8:	00029830 	.word	0x00029830
    a7cc:	00029838 	.word	0x00029838
    a7d0:	0002c9af 	.word	0x0002c9af

0000a7d4 <bt_att_send>:

int bt_att_send(struct bt_conn *conn, struct net_buf *buf, bt_conn_tx_cb_t cb,
		void *user_data)
{
    a7d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a7d8:	460d      	mov	r5, r1
    a7da:	4614      	mov	r4, r2
    a7dc:	4698      	mov	r8, r3
	struct bt_att *att;
	int err;

	__ASSERT_NO_MSG(conn);
    a7de:	4607      	mov	r7, r0
    a7e0:	b958      	cbnz	r0, a7fa <bt_att_send+0x26>
    a7e2:	4922      	ldr	r1, [pc, #136]	; (a86c <bt_att_send+0x98>)
    a7e4:	4822      	ldr	r0, [pc, #136]	; (a870 <bt_att_send+0x9c>)
    a7e6:	4a23      	ldr	r2, [pc, #140]	; (a874 <bt_att_send+0xa0>)
    a7e8:	f640 03f8 	movw	r3, #2296	; 0x8f8
    a7ec:	f019 fb79 	bl	23ee2 <printk>
    a7f0:	4820      	ldr	r0, [pc, #128]	; (a874 <bt_att_send+0xa0>)
    a7f2:	f640 01f8 	movw	r1, #2296	; 0x8f8
    a7f6:	f019 fbb7 	bl	23f68 <assert_post_action>
	__ASSERT_NO_MSG(buf);
    a7fa:	b95d      	cbnz	r5, a814 <bt_att_send+0x40>
    a7fc:	491e      	ldr	r1, [pc, #120]	; (a878 <bt_att_send+0xa4>)
    a7fe:	481c      	ldr	r0, [pc, #112]	; (a870 <bt_att_send+0x9c>)
    a800:	4a1c      	ldr	r2, [pc, #112]	; (a874 <bt_att_send+0xa0>)
    a802:	f640 03f9 	movw	r3, #2297	; 0x8f9
    a806:	f019 fb6c 	bl	23ee2 <printk>
    a80a:	481a      	ldr	r0, [pc, #104]	; (a874 <bt_att_send+0xa0>)
    a80c:	f640 01f9 	movw	r1, #2297	; 0x8f9
    a810:	f019 fbaa 	bl	23f68 <assert_post_action>

	att = att_chan_get(conn);
    a814:	4638      	mov	r0, r7
    a816:	f7ff fa6f 	bl	9cf8 <att_chan_get>
	if (!att) {
    a81a:	4606      	mov	r6, r0
    a81c:	b938      	cbnz	r0, a82e <bt_att_send+0x5a>
		net_buf_unref(buf);
    a81e:	4628      	mov	r0, r5
    a820:	f014 fc52 	bl	1f0c8 <net_buf_unref>
		return -ENOTCONN;
    a824:	f06f 0538 	mvn.w	r5, #56	; 0x38
		}
		return err;
	}

	return 0;
}
    a828:	4628      	mov	r0, r5
    a82a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!cb) {
    a82e:	b964      	cbnz	r4, a84a <bt_att_send+0x76>
    a830:	4621      	mov	r1, r4
    a832:	30c8      	adds	r0, #200	; 0xc8
    a834:	f017 ff80 	bl	22738 <z_impl_k_sem_take>
		if (k_sem_take(&att->tx_sem, K_NO_WAIT) < 0) {
    a838:	2800      	cmp	r0, #0
    a83a:	da06      	bge.n	a84a <bt_att_send+0x76>
			k_fifo_put(&att->tx_queue, buf);
    a83c:	4629      	mov	r1, r5
    a83e:	f106 00e0 	add.w	r0, r6, #224	; 0xe0
    a842:	f01e fd06 	bl	29252 <k_queue_append>
			return 0;
    a846:	4625      	mov	r5, r4
    a848:	e7ee      	b.n	a828 <bt_att_send+0x54>
	err = att_send(conn, buf, cb, user_data);
    a84a:	4629      	mov	r1, r5
    a84c:	4643      	mov	r3, r8
    a84e:	4622      	mov	r2, r4
    a850:	4638      	mov	r0, r7
    a852:	f7ff f9bf 	bl	9bd4 <att_send>
	if (err) {
    a856:	4605      	mov	r5, r0
    a858:	2800      	cmp	r0, #0
    a85a:	d0e5      	beq.n	a828 <bt_att_send+0x54>
		if (!cb) {
    a85c:	2c00      	cmp	r4, #0
    a85e:	d1e3      	bne.n	a828 <bt_att_send+0x54>
	z_impl_k_sem_give(sem);
    a860:	f106 00c8 	add.w	r0, r6, #200	; 0xc8
    a864:	f017 ff24 	bl	226b0 <z_impl_k_sem_give>
}
    a868:	e7de      	b.n	a828 <bt_att_send+0x54>
    a86a:	bf00      	nop
    a86c:	00030710 	.word	0x00030710
    a870:	0002a5e8 	.word	0x0002a5e8
    a874:	0002c818 	.word	0x0002c818
    a878:	00030dcd 	.word	0x00030dcd

0000a87c <bt_att_req_send>:

int bt_att_req_send(struct bt_conn *conn, struct bt_att_req *req)
{
    a87c:	b538      	push	{r3, r4, r5, lr}
    a87e:	460c      	mov	r4, r1
	struct bt_att *att;

	BT_DBG("conn %p req %p", conn, req);

	__ASSERT_NO_MSG(conn);
    a880:	4605      	mov	r5, r0
    a882:	b958      	cbnz	r0, a89c <bt_att_req_send+0x20>
    a884:	491c      	ldr	r1, [pc, #112]	; (a8f8 <bt_att_req_send+0x7c>)
    a886:	481d      	ldr	r0, [pc, #116]	; (a8fc <bt_att_req_send+0x80>)
    a888:	4a1d      	ldr	r2, [pc, #116]	; (a900 <bt_att_req_send+0x84>)
    a88a:	f640 131b 	movw	r3, #2331	; 0x91b
    a88e:	f019 fb28 	bl	23ee2 <printk>
    a892:	481b      	ldr	r0, [pc, #108]	; (a900 <bt_att_req_send+0x84>)
    a894:	f640 111b 	movw	r1, #2331	; 0x91b
    a898:	f019 fb66 	bl	23f68 <assert_post_action>
	__ASSERT_NO_MSG(req);
    a89c:	b95c      	cbnz	r4, a8b6 <bt_att_req_send+0x3a>
    a89e:	4919      	ldr	r1, [pc, #100]	; (a904 <bt_att_req_send+0x88>)
    a8a0:	4816      	ldr	r0, [pc, #88]	; (a8fc <bt_att_req_send+0x80>)
    a8a2:	4a17      	ldr	r2, [pc, #92]	; (a900 <bt_att_req_send+0x84>)
    a8a4:	f640 131c 	movw	r3, #2332	; 0x91c
    a8a8:	f019 fb1b 	bl	23ee2 <printk>
    a8ac:	4814      	ldr	r0, [pc, #80]	; (a900 <bt_att_req_send+0x84>)
    a8ae:	f640 111c 	movw	r1, #2332	; 0x91c
    a8b2:	f019 fb59 	bl	23f68 <assert_post_action>

	att = att_chan_get(conn);
    a8b6:	4628      	mov	r0, r5
    a8b8:	f7ff fa1e 	bl	9cf8 <att_chan_get>
	if (!att) {
    a8bc:	4605      	mov	r5, r0
    a8be:	b930      	cbnz	r0, a8ce <bt_att_req_send+0x52>
		net_buf_unref(req->buf);
    a8c0:	6920      	ldr	r0, [r4, #16]
    a8c2:	f014 fc01 	bl	1f0c8 <net_buf_unref>
		req->buf = NULL;
    a8c6:	6125      	str	r5, [r4, #16]
		return -ENOTCONN;
    a8c8:	f06f 0038 	mvn.w	r0, #56	; 0x38
		sys_slist_append(&att->reqs, &req->node);
		return 0;
	}

	return att_send_req(att, req);
}
    a8cc:	bd38      	pop	{r3, r4, r5, pc}
	if (att->req) {
    a8ce:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    a8d2:	b163      	cbz	r3, a8ee <bt_att_req_send+0x72>
	parent->next = child;
    a8d4:	2000      	movs	r0, #0
    a8d6:	6020      	str	r0, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
    a8d8:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
    a8dc:	b91b      	cbnz	r3, a8e6 <bt_att_req_send+0x6a>
	list->head = node;
    a8de:	e9c5 4428 	strd	r4, r4, [r5, #160]	; 0xa0
		return 0;
    a8e2:	4618      	mov	r0, r3
}
    a8e4:	e7f2      	b.n	a8cc <bt_att_req_send+0x50>
	parent->next = child;
    a8e6:	601c      	str	r4, [r3, #0]
	list->tail = node;
    a8e8:	f8c5 40a4 	str.w	r4, [r5, #164]	; 0xa4
}
    a8ec:	e7ee      	b.n	a8cc <bt_att_req_send+0x50>
	return att_send_req(att, req);
    a8ee:	4621      	mov	r1, r4
}
    a8f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return att_send_req(att, req);
    a8f4:	f7ff ba54 	b.w	9da0 <att_send_req>
    a8f8:	00030710 	.word	0x00030710
    a8fc:	0002a5e8 	.word	0x0002a5e8
    a900:	0002c818 	.word	0x0002c818
    a904:	0002c8e0 	.word	0x0002c8e0

0000a908 <sc_store>:

	return NULL;
}

static void sc_store(struct gatt_sc_cfg *cfg)
{
    a908:	b570      	push	{r4, r5, r6, lr}
	char key[BT_SETTINGS_KEY_MAX];
	int err;

	if (cfg->id) {
    a90a:	4605      	mov	r5, r0
{
    a90c:	b08c      	sub	sp, #48	; 0x30
	if (cfg->id) {
    a90e:	f815 2b01 	ldrb.w	r2, [r5], #1
{
    a912:	4604      	mov	r4, r0
	if (cfg->id) {
    a914:	b1fa      	cbz	r2, a956 <sc_store+0x4e>
		char id_str[4];

		u8_to_dec(id_str, sizeof(id_str), cfg->id);
    a916:	ae02      	add	r6, sp, #8
    a918:	2104      	movs	r1, #4
    a91a:	4630      	mov	r0, r6
    a91c:	f019 f925 	bl	23b6a <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "sc",
    a920:	9600      	str	r6, [sp, #0]
				       &cfg->peer, id_str);
	} else {
		bt_settings_encode_key(key, sizeof(key), "sc",
    a922:	4a0e      	ldr	r2, [pc, #56]	; (a95c <sc_store+0x54>)
    a924:	462b      	mov	r3, r5
    a926:	2124      	movs	r1, #36	; 0x24
    a928:	a803      	add	r0, sp, #12
    a92a:	f7fb fdcf 	bl	64cc <bt_settings_encode_key>
				       &cfg->peer, NULL);
	}

	err = settings_save_one(key, (char *)&cfg->data, sizeof(cfg->data));
    a92e:	f104 0108 	add.w	r1, r4, #8
    a932:	2204      	movs	r2, #4
    a934:	a803      	add	r0, sp, #12
    a936:	f7f8 fff1 	bl	391c <settings_save_one>
	if (err) {
    a93a:	4601      	mov	r1, r0
    a93c:	b148      	cbz	r0, a952 <sc_store+0x4a>
    a93e:	4a08      	ldr	r2, [pc, #32]	; (a960 <sc_store+0x58>)
    a940:	4b08      	ldr	r3, [pc, #32]	; (a964 <sc_store+0x5c>)
		BT_ERR("failed to store SC (err %d)", err);
    a942:	4809      	ldr	r0, [pc, #36]	; (a968 <sc_store+0x60>)
    a944:	1ad2      	subs	r2, r2, r3
    a946:	08d2      	lsrs	r2, r2, #3
    a948:	0192      	lsls	r2, r2, #6
    a94a:	f042 0201 	orr.w	r2, r2, #1
    a94e:	f019 fb46 	bl	23fde <log_1>
	}

	BT_DBG("stored SC for %s (%s, 0x%04x-0x%04x)",
	       bt_addr_le_str(&cfg->peer), log_strdup(key), cfg->data.start,
	       cfg->data.end);
}
    a952:	b00c      	add	sp, #48	; 0x30
    a954:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "sc",
    a956:	9200      	str	r2, [sp, #0]
    a958:	e7e3      	b.n	a922 <sc_store+0x1a>
    a95a:	bf00      	nop
    a95c:	0002cc76 	.word	0x0002cc76
    a960:	000298e8 	.word	0x000298e8
    a964:	00029830 	.word	0x00029830
    a968:	0002c9c2 	.word	0x0002c9c2

0000a96c <sc_clear>:

static void sc_clear(struct gatt_sc_cfg *cfg)
{
    a96c:	b570      	push	{r4, r5, r6, lr}
	BT_DBG("peer %s", bt_addr_le_str(&cfg->peer));

	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		bool modified = false;

		if (cfg->data.start || cfg->data.end) {
    a96e:	8903      	ldrh	r3, [r0, #8]
{
    a970:	b08c      	sub	sp, #48	; 0x30
    a972:	4604      	mov	r4, r0
		if (cfg->data.start || cfg->data.end) {
    a974:	b90b      	cbnz	r3, a97a <sc_clear+0xe>
    a976:	8943      	ldrh	r3, [r0, #10]
    a978:	b31b      	cbz	r3, a9c2 <sc_clear+0x56>
			modified = true;
		}

		if (modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
    a97a:	4625      	mov	r5, r4
    a97c:	f815 0b01 	ldrb.w	r0, [r5], #1
    a980:	4629      	mov	r1, r5
    a982:	f01b fd52 	bl	2642a <bt_addr_le_is_bonded>
    a986:	b1e0      	cbz	r0, a9c2 <sc_clear+0x56>
			char key[BT_SETTINGS_KEY_MAX];
			int err;

			if (cfg->id) {
    a988:	7822      	ldrb	r2, [r4, #0]
    a98a:	b30a      	cbz	r2, a9d0 <sc_clear+0x64>
				char id_str[4];

				u8_to_dec(id_str, sizeof(id_str), cfg->id);
    a98c:	ae02      	add	r6, sp, #8
    a98e:	2104      	movs	r1, #4
    a990:	4630      	mov	r0, r6
    a992:	f019 f8ea 	bl	23b6a <u8_to_dec>
				bt_settings_encode_key(key, sizeof(key), "sc",
    a996:	9600      	str	r6, [sp, #0]
						       &cfg->peer, id_str);
			} else {
				bt_settings_encode_key(key, sizeof(key), "sc",
    a998:	2124      	movs	r1, #36	; 0x24
    a99a:	4a0e      	ldr	r2, [pc, #56]	; (a9d4 <sc_clear+0x68>)
    a99c:	462b      	mov	r3, r5
    a99e:	a803      	add	r0, sp, #12
    a9a0:	f7fb fd94 	bl	64cc <bt_settings_encode_key>
						       &cfg->peer, NULL);
			}

			err = settings_delete(key);
    a9a4:	a803      	add	r0, sp, #12
    a9a6:	f019 fec3 	bl	24730 <settings_delete>
			if (err) {
    a9aa:	4601      	mov	r1, r0
    a9ac:	b148      	cbz	r0, a9c2 <sc_clear+0x56>
    a9ae:	4a0a      	ldr	r2, [pc, #40]	; (a9d8 <sc_clear+0x6c>)
    a9b0:	4b0a      	ldr	r3, [pc, #40]	; (a9dc <sc_clear+0x70>)
				BT_ERR("failed to delete SC (err %d)", err);
    a9b2:	480b      	ldr	r0, [pc, #44]	; (a9e0 <sc_clear+0x74>)
    a9b4:	1ad2      	subs	r2, r2, r3
    a9b6:	08d2      	lsrs	r2, r2, #3
    a9b8:	0192      	lsls	r2, r2, #6
    a9ba:	f042 0201 	orr.w	r2, r2, #1
    a9be:	f019 fb0e 	bl	23fde <log_1>
				       log_strdup(key));
			}
		}
	}

	memset(cfg, 0, sizeof(*cfg));
    a9c2:	220c      	movs	r2, #12
    a9c4:	2100      	movs	r1, #0
    a9c6:	4620      	mov	r0, r4
    a9c8:	f01b f999 	bl	25cfe <memset>
}
    a9cc:	b00c      	add	sp, #48	; 0x30
    a9ce:	bd70      	pop	{r4, r5, r6, pc}
				bt_settings_encode_key(key, sizeof(key), "sc",
    a9d0:	9200      	str	r2, [sp, #0]
    a9d2:	e7e1      	b.n	a998 <sc_clear+0x2c>
    a9d4:	0002cc76 	.word	0x0002cc76
    a9d8:	000298e8 	.word	0x000298e8
    a9dc:	00029830 	.word	0x00029830
    a9e0:	0002c9de 	.word	0x0002c9de

0000a9e4 <find_static_attr>:

	return BT_GATT_ITER_CONTINUE;
}

static u16_t find_static_attr(const struct bt_gatt_attr *attr)
{
    a9e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u16_t handle = 1;

	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    a9e8:	4f18      	ldr	r7, [pc, #96]	; (aa4c <find_static_attr+0x68>)
    a9ea:	4c19      	ldr	r4, [pc, #100]	; (aa50 <find_static_attr+0x6c>)
    a9ec:	f8df 9070 	ldr.w	r9, [pc, #112]	; aa60 <find_static_attr+0x7c>
{
    a9f0:	4605      	mov	r5, r0
	u16_t handle = 1;
    a9f2:	2601      	movs	r6, #1
    a9f4:	46b8      	mov	r8, r7
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    a9f6:	f1a4 0a08 	sub.w	sl, r4, #8
    a9fa:	45ba      	cmp	sl, r7
    a9fc:	d90e      	bls.n	aa1c <find_static_attr+0x38>
    a9fe:	4915      	ldr	r1, [pc, #84]	; (aa54 <find_static_attr+0x70>)
    aa00:	4815      	ldr	r0, [pc, #84]	; (aa58 <find_static_attr+0x74>)
    aa02:	f240 438c 	movw	r3, #1164	; 0x48c
    aa06:	464a      	mov	r2, r9
    aa08:	f019 fa6b 	bl	23ee2 <printk>
    aa0c:	4813      	ldr	r0, [pc, #76]	; (aa5c <find_static_attr+0x78>)
    aa0e:	f019 fa68 	bl	23ee2 <printk>
    aa12:	f240 418c 	movw	r1, #1164	; 0x48c
    aa16:	4648      	mov	r0, r9
    aa18:	f019 faa6 	bl	23f68 <assert_post_action>
    aa1c:	45c2      	cmp	sl, r8
    aa1e:	d212      	bcs.n	aa46 <find_static_attr+0x62>
    aa20:	f854 cc04 	ldr.w	ip, [r4, #-4]
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
    aa24:	2100      	movs	r1, #0
			if (attr == &static_svc->attrs[i]) {
    aa26:	2214      	movs	r2, #20
    aa28:	e006      	b.n	aa38 <find_static_attr+0x54>
    aa2a:	f854 3c08 	ldr.w	r3, [r4, #-8]
    aa2e:	fb02 3301 	mla	r3, r2, r1, r3
    aa32:	429d      	cmp	r5, r3
    aa34:	d008      	beq.n	aa48 <find_static_attr+0x64>
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
    aa36:	3101      	adds	r1, #1
    aa38:	1873      	adds	r3, r6, r1
    aa3a:	4561      	cmp	r1, ip
    aa3c:	b298      	uxth	r0, r3
    aa3e:	d1f4      	bne.n	aa2a <find_static_attr+0x46>
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    aa40:	3408      	adds	r4, #8
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
    aa42:	4606      	mov	r6, r0
    aa44:	e7d7      	b.n	a9f6 <find_static_attr+0x12>
				return handle;
			}
		}
	}

	return 0;
    aa46:	2000      	movs	r0, #0
}
    aa48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    aa4c:	000297f4 	.word	0x000297f4
    aa50:	000297ec 	.word	0x000297ec
    aa54:	0002ca2b 	.word	0x0002ca2b
    aa58:	0002a5e8 	.word	0x0002a5e8
    aa5c:	0002ad2b 	.word	0x0002ad2b
    aa60:	0002c9fb 	.word	0x0002c9fb

0000aa64 <gatt_notify>:
	};
};

static int gatt_notify(struct bt_conn *conn, u16_t handle,
		       struct bt_gatt_notify_params *params)
{
    aa64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    aa68:	4614      	mov	r4, r2
		return -EAGAIN;
	}
#endif

	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
				sizeof(*nfy) + params->len);
    aa6a:	8992      	ldrh	r2, [r2, #12]
{
    aa6c:	4688      	mov	r8, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
    aa6e:	3202      	adds	r2, #2
    aa70:	211b      	movs	r1, #27
{
    aa72:	4607      	mov	r7, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
    aa74:	f7ff fa48 	bl	9f08 <bt_att_create_pdu>
	if (!buf) {
    aa78:	4605      	mov	r5, r0
    aa7a:	b1c8      	cbz	r0, aab0 <gatt_notify+0x4c>
		return -ENOMEM;
	}

	BT_DBG("conn %p handle 0x%04x", conn, handle);

	nfy = net_buf_add(buf, sizeof(*nfy));
    aa7c:	f100 0908 	add.w	r9, r0, #8
    aa80:	2102      	movs	r1, #2
    aa82:	4648      	mov	r0, r9
    aa84:	f014 fc28 	bl	1f2d8 <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
    aa88:	4606      	mov	r6, r0

	net_buf_add(buf, params->len);
    aa8a:	89a1      	ldrh	r1, [r4, #12]
	nfy->handle = sys_cpu_to_le16(handle);
    aa8c:	f826 8b02 	strh.w	r8, [r6], #2
	net_buf_add(buf, params->len);
    aa90:	4648      	mov	r0, r9
    aa92:	f014 fc21 	bl	1f2d8 <net_buf_simple_add>
	memcpy(nfy->value, params->data, params->len);
    aa96:	89a2      	ldrh	r2, [r4, #12]
    aa98:	68a1      	ldr	r1, [r4, #8]
    aa9a:	4630      	mov	r0, r6
    aa9c:	f01b f904 	bl	25ca8 <memcpy>

	return bt_att_send(conn, buf, params->func, params->user_data);
    aaa0:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    aaa4:	4629      	mov	r1, r5
    aaa6:	4638      	mov	r0, r7
}
    aaa8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_att_send(conn, buf, params->func, params->user_data);
    aaac:	f7ff be92 	b.w	a7d4 <bt_att_send>
    aab0:	4b06      	ldr	r3, [pc, #24]	; (aacc <gatt_notify+0x68>)
    aab2:	4907      	ldr	r1, [pc, #28]	; (aad0 <gatt_notify+0x6c>)
		BT_WARN("No buffer available to send notification");
    aab4:	4807      	ldr	r0, [pc, #28]	; (aad4 <gatt_notify+0x70>)
    aab6:	1ac9      	subs	r1, r1, r3
    aab8:	08c9      	lsrs	r1, r1, #3
    aaba:	0189      	lsls	r1, r1, #6
    aabc:	f041 0102 	orr.w	r1, r1, #2
    aac0:	f019 fa80 	bl	23fc4 <log_0>
}
    aac4:	f06f 000b 	mvn.w	r0, #11
    aac8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    aacc:	00029830 	.word	0x00029830
    aad0:	000298e8 	.word	0x000298e8
    aad4:	0002ca5a 	.word	0x0002ca5a

0000aad8 <gatt_send.constprop.0>:
	struct bt_gatt_indicate_params *params = user_data;

	params->func(conn, params->attr, err);
}

static int gatt_send(struct bt_conn *conn, struct net_buf *buf,
    aad8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    aadc:	4606      	mov	r6, r0
    aade:	4688      	mov	r8, r1
    aae0:	4617      	mov	r7, r2
		     bt_att_func_t func, void *params,
		     bt_att_destroy_t destroy)
{
	int err;

	if (params) {
    aae2:	461c      	mov	r4, r3
    aae4:	b323      	cbz	r3, ab30 <gatt_send.constprop.0+0x58>
		struct bt_att_req *req;

		/* Allocate new request */
		req = bt_att_req_alloc(BT_ATT_TIMEOUT);
    aae6:	f247 5030 	movw	r0, #30000	; 0x7530
    aaea:	f7ff fddd 	bl	a6a8 <bt_att_req_alloc>
		if (!req) {
    aaee:	4605      	mov	r5, r0
    aaf0:	b328      	cbz	r0, ab3e <gatt_send.constprop.0+0x66>
			return -ENOMEM;
		}

		req->buf = buf;
		req->func = func;
		req->destroy = destroy;
    aaf2:	2300      	movs	r3, #0
		req->user_data = params;
    aaf4:	6144      	str	r4, [r0, #20]
		req->buf = buf;
    aaf6:	f8c0 8010 	str.w	r8, [r0, #16]
		req->func = func;
    aafa:	6047      	str	r7, [r0, #4]
		req->destroy = destroy;
    aafc:	6083      	str	r3, [r0, #8]

		err = bt_att_req_send(conn, req);
    aafe:	4601      	mov	r1, r0
    ab00:	4630      	mov	r0, r6
    ab02:	f7ff febb 	bl	a87c <bt_att_req_send>
		if (err) {
    ab06:	4604      	mov	r4, r0
    ab08:	b918      	cbnz	r0, ab12 <gatt_send.constprop.0+0x3a>
static int gatt_send(struct bt_conn *conn, struct net_buf *buf,
    ab0a:	2400      	movs	r4, #0
	if (err) {
		BT_ERR("Error sending ATT PDU: %d", err);
	}

	return err;
}
    ab0c:	4620      	mov	r0, r4
    ab0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bt_att_req_free(req);
    ab12:	4628      	mov	r0, r5
    ab14:	f7ff fdde 	bl	a6d4 <bt_att_req_free>
    ab18:	4b0a      	ldr	r3, [pc, #40]	; (ab44 <gatt_send.constprop.0+0x6c>)
    ab1a:	4a0b      	ldr	r2, [pc, #44]	; (ab48 <gatt_send.constprop.0+0x70>)
		BT_ERR("Error sending ATT PDU: %d", err);
    ab1c:	480b      	ldr	r0, [pc, #44]	; (ab4c <gatt_send.constprop.0+0x74>)
    ab1e:	1ad2      	subs	r2, r2, r3
    ab20:	08d2      	lsrs	r2, r2, #3
    ab22:	0192      	lsls	r2, r2, #6
    ab24:	f042 0201 	orr.w	r2, r2, #1
    ab28:	4621      	mov	r1, r4
    ab2a:	f019 fa58 	bl	23fde <log_1>
    ab2e:	e7ed      	b.n	ab0c <gatt_send.constprop.0+0x34>
		err = bt_att_send(conn, buf, NULL, NULL);
    ab30:	461a      	mov	r2, r3
    ab32:	f7ff fe4f 	bl	a7d4 <bt_att_send>
	if (err) {
    ab36:	4604      	mov	r4, r0
    ab38:	2800      	cmp	r0, #0
    ab3a:	d0e6      	beq.n	ab0a <gatt_send.constprop.0+0x32>
    ab3c:	e7ec      	b.n	ab18 <gatt_send.constprop.0+0x40>
			return -ENOMEM;
    ab3e:	f06f 040b 	mvn.w	r4, #11
    ab42:	e7e3      	b.n	ab0c <gatt_send.constprop.0+0x34>
    ab44:	00029830 	.word	0x00029830
    ab48:	000298e8 	.word	0x000298e8
    ab4c:	0002ca83 	.word	0x0002ca83

0000ab50 <gatt_indicate>:

static int gatt_indicate(struct bt_conn *conn, u16_t handle,
			 struct bt_gatt_indicate_params *params)
{
    ab50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ab54:	4614      	mov	r4, r2
		return -EAGAIN;
	}
#endif

	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
				sizeof(*ind) + params->len);
    ab56:	8a12      	ldrh	r2, [r2, #16]
{
    ab58:	4689      	mov	r9, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
    ab5a:	3202      	adds	r2, #2
    ab5c:	211d      	movs	r1, #29
{
    ab5e:	4607      	mov	r7, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
    ab60:	f7ff f9d2 	bl	9f08 <bt_att_create_pdu>
	if (!buf) {
    ab64:	4605      	mov	r5, r0
    ab66:	b1e8      	cbz	r0, aba4 <gatt_indicate+0x54>
		return -ENOMEM;
	}

	BT_DBG("conn %p handle 0x%04x", conn, handle);

	ind = net_buf_add(buf, sizeof(*ind));
    ab68:	f100 0808 	add.w	r8, r0, #8
    ab6c:	2102      	movs	r1, #2
    ab6e:	4640      	mov	r0, r8
    ab70:	f014 fbb2 	bl	1f2d8 <net_buf_simple_add>
	ind->handle = sys_cpu_to_le16(handle);
    ab74:	4606      	mov	r6, r0

	net_buf_add(buf, params->len);
    ab76:	8a21      	ldrh	r1, [r4, #16]
	ind->handle = sys_cpu_to_le16(handle);
    ab78:	f826 9b02 	strh.w	r9, [r6], #2
	net_buf_add(buf, params->len);
    ab7c:	4640      	mov	r0, r8
    ab7e:	f014 fbab 	bl	1f2d8 <net_buf_simple_add>
	memcpy(ind->value, params->data, params->len);
    ab82:	8a22      	ldrh	r2, [r4, #16]
    ab84:	68e1      	ldr	r1, [r4, #12]
    ab86:	4630      	mov	r0, r6
    ab88:	f01b f88e 	bl	25ca8 <memcpy>

	if (!params->func) {
    ab8c:	68a3      	ldr	r3, [r4, #8]
    ab8e:	b933      	cbnz	r3, ab9e <gatt_indicate+0x4e>
		return gatt_send(conn, buf, NULL, NULL, NULL);
    ab90:	461a      	mov	r2, r3
	}

	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
    ab92:	4629      	mov	r1, r5
    ab94:	4638      	mov	r0, r7
}
    ab96:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
    ab9a:	f7ff bf9d 	b.w	aad8 <gatt_send.constprop.0>
    ab9e:	4a08      	ldr	r2, [pc, #32]	; (abc0 <gatt_indicate+0x70>)
    aba0:	4623      	mov	r3, r4
    aba2:	e7f6      	b.n	ab92 <gatt_indicate+0x42>
    aba4:	4b07      	ldr	r3, [pc, #28]	; (abc4 <gatt_indicate+0x74>)
    aba6:	4908      	ldr	r1, [pc, #32]	; (abc8 <gatt_indicate+0x78>)
		BT_WARN("No buffer available to send indication");
    aba8:	4808      	ldr	r0, [pc, #32]	; (abcc <gatt_indicate+0x7c>)
    abaa:	1ac9      	subs	r1, r1, r3
    abac:	08c9      	lsrs	r1, r1, #3
    abae:	0189      	lsls	r1, r1, #6
    abb0:	f041 0102 	orr.w	r1, r1, #2
    abb4:	f019 fa06 	bl	23fc4 <log_0>
}
    abb8:	f06f 000b 	mvn.w	r0, #11
    abbc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    abc0:	00026cbf 	.word	0x00026cbf
    abc4:	00029830 	.word	0x00029830
    abc8:	000298e8 	.word	0x000298e8
    abcc:	0002ca9d 	.word	0x0002ca9d

0000abd0 <ccc_save>:
	struct ccc_store store[CCC_STORE_MAX];
	size_t count;
};

static u8_t ccc_save(const struct bt_gatt_attr *attr, void *user_data)
{
    abd0:	b538      	push	{r3, r4, r5, lr}
	struct ccc_save *save = user_data;
	struct _bt_gatt_ccc *ccc;
	struct bt_gatt_ccc_cfg *cfg;

	/* Check if attribute is a CCC */
	if (attr->write != bt_gatt_attr_write_ccc) {
    abd2:	6882      	ldr	r2, [r0, #8]
    abd4:	4b0b      	ldr	r3, [pc, #44]	; (ac04 <ccc_save+0x34>)
    abd6:	429a      	cmp	r2, r3
{
    abd8:	4605      	mov	r5, r0
    abda:	460c      	mov	r4, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    abdc:	d110      	bne.n	ac00 <ccc_save+0x30>
	}

	ccc = attr->user_data;

	/* Check if there is a cfg for the peer */
	cfg = ccc_find_cfg(ccc, save->addr_with_id.addr, save->addr_with_id.id);
    abde:	790a      	ldrb	r2, [r1, #4]
    abe0:	68c0      	ldr	r0, [r0, #12]
    abe2:	6809      	ldr	r1, [r1, #0]
    abe4:	f01c f897 	bl	26d16 <ccc_find_cfg>
	if (!cfg) {
    abe8:	b150      	cbz	r0, ac00 <ccc_save+0x30>
	}

	BT_DBG("Storing CCCs handle 0x%04x value 0x%04x", attr->handle,
	       cfg->value);

	save->store[save->count].handle = attr->handle;
    abea:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
    abee:	8a29      	ldrh	r1, [r5, #16]
    abf0:	eb04 0283 	add.w	r2, r4, r3, lsl #2
	save->store[save->count].value = cfg->value;
	save->count++;
    abf4:	3301      	adds	r3, #1
	save->store[save->count].handle = attr->handle;
    abf6:	8111      	strh	r1, [r2, #8]
	save->store[save->count].value = cfg->value;
    abf8:	8901      	ldrh	r1, [r0, #8]
    abfa:	8151      	strh	r1, [r2, #10]
	save->count++;
    abfc:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8

	return BT_GATT_ITER_CONTINUE;
}
    ac00:	2001      	movs	r0, #1
    ac02:	bd38      	pop	{r3, r4, r5, pc}
    ac04:	0000af09 	.word	0x0000af09

0000ac08 <find_sc_cfg>:
{
    ac08:	b510      	push	{r4, lr}
		if (id == sc_cfg[i].id &&
    ac0a:	4c06      	ldr	r4, [pc, #24]	; (ac24 <find_sc_cfg+0x1c>)
    ac0c:	7823      	ldrb	r3, [r4, #0]
    ac0e:	4283      	cmp	r3, r0
    ac10:	d104      	bne.n	ac1c <find_sc_cfg+0x14>
	return memcmp(a, b, sizeof(*a));
    ac12:	2207      	movs	r2, #7
    ac14:	1c60      	adds	r0, r4, #1
    ac16:	f01b f837 	bl	25c88 <memcmp>
    ac1a:	b108      	cbz	r0, ac20 <find_sc_cfg+0x18>
	return NULL;
    ac1c:	2000      	movs	r0, #0
}
    ac1e:	bd10      	pop	{r4, pc}
			return &sc_cfg[i];
    ac20:	4620      	mov	r0, r4
    ac22:	e7fc      	b.n	ac1e <find_sc_cfg+0x16>
    ac24:	20001e7e 	.word	0x20001e7e

0000ac28 <ccc_load>:
{
    ac28:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    ac2a:	4a22      	ldr	r2, [pc, #136]	; (acb4 <ccc_load+0x8c>)
{
    ac2c:	460c      	mov	r4, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    ac2e:	6881      	ldr	r1, [r0, #8]
    ac30:	4291      	cmp	r1, r2
{
    ac32:	4603      	mov	r3, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
    ac34:	d002      	beq.n	ac3c <ccc_load+0x14>
		return BT_GATT_ITER_CONTINUE;
    ac36:	2001      	movs	r0, #1
}
    ac38:	b002      	add	sp, #8
    ac3a:	bd70      	pop	{r4, r5, r6, pc}
	if (!load->entry) {
    ac3c:	68a2      	ldr	r2, [r4, #8]
	ccc = attr->user_data;
    ac3e:	68c6      	ldr	r6, [r0, #12]
	if (!load->entry) {
    ac40:	b94a      	cbnz	r2, ac56 <ccc_load+0x2e>
	cfg = ccc_find_cfg(ccc, addr, id);
    ac42:	7922      	ldrb	r2, [r4, #4]
    ac44:	6821      	ldr	r1, [r4, #0]
    ac46:	4630      	mov	r0, r6
    ac48:	f01c f865 	bl	26d16 <ccc_find_cfg>
	if (!cfg) {
    ac4c:	2800      	cmp	r0, #0
    ac4e:	d0f2      	beq.n	ac36 <ccc_load+0xe>
	clear_ccc_cfg(cfg);
    ac50:	f01c f896 	bl	26d80 <clear_ccc_cfg>
    ac54:	e7ef      	b.n	ac36 <ccc_load+0xe>
	} else if (!load->count) {
    ac56:	68e0      	ldr	r0, [r4, #12]
    ac58:	2800      	cmp	r0, #0
    ac5a:	d0ed      	beq.n	ac38 <ccc_load+0x10>
	if (load->entry->handle != attr->handle) {
    ac5c:	8812      	ldrh	r2, [r2, #0]
    ac5e:	8a1b      	ldrh	r3, [r3, #16]
    ac60:	429a      	cmp	r2, r3
    ac62:	d00a      	beq.n	ac7a <ccc_load+0x52>
		if (load->entry->handle < attr->handle) {
    ac64:	d2e7      	bcs.n	ac36 <ccc_load+0xe>
	load->count--;
    ac66:	68e0      	ldr	r0, [r4, #12]
	load->entry++;
    ac68:	68a3      	ldr	r3, [r4, #8]
	load->count--;
    ac6a:	3801      	subs	r0, #1
	load->entry++;
    ac6c:	3304      	adds	r3, #4
	load->count--;
    ac6e:	60e0      	str	r0, [r4, #12]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    ac70:	3800      	subs	r0, #0
	load->entry++;
    ac72:	60a3      	str	r3, [r4, #8]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    ac74:	bf18      	it	ne
    ac76:	2001      	movne	r0, #1
    ac78:	e7de      	b.n	ac38 <ccc_load+0x10>
	cfg = ccc_find_cfg(ccc, load->addr_with_id.addr, load->addr_with_id.id);
    ac7a:	7922      	ldrb	r2, [r4, #4]
    ac7c:	6821      	ldr	r1, [r4, #0]
    ac7e:	4630      	mov	r0, r6
    ac80:	f01c f849 	bl	26d16 <ccc_find_cfg>
	if (!cfg) {
    ac84:	4605      	mov	r5, r0
    ac86:	b988      	cbnz	r0, acac <ccc_load+0x84>
		cfg = ccc_find_cfg(ccc, BT_ADDR_LE_ANY, 0);
    ac88:	9000      	str	r0, [sp, #0]
    ac8a:	4602      	mov	r2, r0
    ac8c:	f8cd 0003 	str.w	r0, [sp, #3]
    ac90:	4669      	mov	r1, sp
    ac92:	4630      	mov	r0, r6
    ac94:	f01c f83f 	bl	26d16 <ccc_find_cfg>
		if (!cfg) {
    ac98:	4605      	mov	r5, r0
    ac9a:	2800      	cmp	r0, #0
    ac9c:	d0e3      	beq.n	ac66 <ccc_load+0x3e>
	memcpy(dst, src, sizeof(*dst));
    ac9e:	6821      	ldr	r1, [r4, #0]
    aca0:	2207      	movs	r2, #7
    aca2:	3001      	adds	r0, #1
    aca4:	f01b f800 	bl	25ca8 <memcpy>
		cfg->id = load->addr_with_id.id;
    aca8:	7923      	ldrb	r3, [r4, #4]
    acaa:	702b      	strb	r3, [r5, #0]
	cfg->value = load->entry->value;
    acac:	68a3      	ldr	r3, [r4, #8]
    acae:	885b      	ldrh	r3, [r3, #2]
    acb0:	812b      	strh	r3, [r5, #8]
    acb2:	e7d8      	b.n	ac66 <ccc_load+0x3e>
    acb4:	0000af09 	.word	0x0000af09

0000acb8 <sc_indicate_rsp>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    acb8:	490d      	ldr	r1, [pc, #52]	; (acf0 <sc_indicate_rsp+0x38>)
    acba:	f3bf 8f5b 	dmb	ish
    acbe:	f101 0338 	add.w	r3, r1, #56	; 0x38
    acc2:	e853 2f00 	ldrex	r2, [r3]
    acc6:	f022 0202 	bic.w	r2, r2, #2
    acca:	e843 2000 	strex	r0, r2, [r3]
    acce:	2800      	cmp	r0, #0
    acd0:	d1f7      	bne.n	acc2 <sc_indicate_rsp+0xa>
    acd2:	f3bf 8f5b 	dmb	ish
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    acd6:	f3bf 8f5b 	dmb	ish
    acda:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    acdc:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    ace0:	07db      	lsls	r3, r3, #31
    ace2:	d504      	bpl.n	acee <sc_indicate_rsp+0x36>
    ace4:	4803      	ldr	r0, [pc, #12]	; (acf4 <sc_indicate_rsp+0x3c>)
    ace6:	2200      	movs	r2, #0
    ace8:	3118      	adds	r1, #24
    acea:	f017 bf39 	b.w	22b60 <k_delayed_work_submit_to_queue>
}
    acee:	4770      	bx	lr
    acf0:	200006bc 	.word	0x200006bc
    acf4:	20001dc4 	.word	0x20001dc4

0000acf8 <read_ppcp>:
{
    acf8:	b513      	push	{r0, r1, r4, lr}
    acfa:	f8bd 1010 	ldrh.w	r1, [sp, #16]
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
    acfe:	4c0b      	ldr	r4, [pc, #44]	; (ad2c <read_ppcp+0x34>)
{
    ad00:	4610      	mov	r0, r2
	if (offset > value_len) {
    ad02:	2908      	cmp	r1, #8
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
    ad04:	f44f 1228 	mov.w	r2, #2752512	; 0x2a0000
    ad08:	e9cd 4200 	strd	r4, r2, [sp]
	if (offset > value_len) {
    ad0c:	d80b      	bhi.n	ad26 <read_ppcp+0x2e>
	len = MIN(buf_len, value_len - offset);
    ad0e:	f1c1 0408 	rsb	r4, r1, #8
    ad12:	429c      	cmp	r4, r3
    ad14:	bfa8      	it	ge
    ad16:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
    ad18:	4622      	mov	r2, r4
    ad1a:	4469      	add	r1, sp
    ad1c:	f01a ffc4 	bl	25ca8 <memcpy>
}
    ad20:	4620      	mov	r0, r4
    ad22:	b002      	add	sp, #8
    ad24:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    ad26:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
    ad2a:	e7f9      	b.n	ad20 <read_ppcp+0x28>
    ad2c:	00280018 	.word	0x00280018

0000ad30 <disconnected_cb>:
	if (attr->write != bt_gatt_attr_write_ccc) {
    ad30:	6882      	ldr	r2, [r0, #8]
    ad32:	4b20      	ldr	r3, [pc, #128]	; (adb4 <disconnected_cb+0x84>)
    ad34:	429a      	cmp	r2, r3
{
    ad36:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ad3a:	4606      	mov	r6, r0
    ad3c:	460d      	mov	r5, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    ad3e:	d102      	bne.n	ad46 <disconnected_cb+0x16>
	ccc = attr->user_data;
    ad40:	68c4      	ldr	r4, [r0, #12]
	if (!ccc->value) {
    ad42:	8963      	ldrh	r3, [r4, #10]
    ad44:	b9cb      	cbnz	r3, ad7a <disconnected_cb+0x4a>
}
    ad46:	2001      	movs	r0, #1
    ad48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    ad4c:	f105 0874 	add.w	r8, r5, #116	; 0x74
    ad50:	7a28      	ldrb	r0, [r5, #8]
    ad52:	4641      	mov	r1, r8
    ad54:	f01b fb69 	bl	2642a <bt_addr_le_is_bonded>
    ad58:	b948      	cbnz	r0, ad6e <disconnected_cb+0x3e>
				if (ccc == &sc_ccc) {
    ad5a:	4b17      	ldr	r3, [pc, #92]	; (adb8 <disconnected_cb+0x88>)
    ad5c:	429c      	cmp	r4, r3
    ad5e:	d102      	bne.n	ad66 <disconnected_cb+0x36>
					sc_clear_by_conn(conn);
    ad60:	4628      	mov	r0, r5
    ad62:	f01b ffe7 	bl	26d34 <sc_clear_by_conn>
				clear_ccc_cfg(cfg);
    ad66:	4620      	mov	r0, r4
    ad68:	f01c f80a 	bl	26d80 <clear_ccc_cfg>
	if (!value_used) {
    ad6c:	e01a      	b.n	ada4 <disconnected_cb+0x74>
    ad6e:	2207      	movs	r2, #7
    ad70:	4641      	mov	r1, r8
    ad72:	4638      	mov	r0, r7
    ad74:	f01a ff98 	bl	25ca8 <memcpy>
    ad78:	e014      	b.n	ada4 <disconnected_cb+0x74>
		if (!cfg->value) {
    ad7a:	8923      	ldrh	r3, [r4, #8]
    ad7c:	b193      	cbz	r3, ada4 <disconnected_cb+0x74>
		if (!bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    ad7e:	4627      	mov	r7, r4
    ad80:	4628      	mov	r0, r5
    ad82:	f817 1b01 	ldrb.w	r1, [r7], #1
    ad86:	463a      	mov	r2, r7
    ad88:	f01b fbee 	bl	26568 <bt_conn_is_peer_addr_le>
    ad8c:	2800      	cmp	r0, #0
    ad8e:	d1dd      	bne.n	ad4c <disconnected_cb+0x1c>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    ad90:	7820      	ldrb	r0, [r4, #0]
    ad92:	4639      	mov	r1, r7
    ad94:	f7fe face 	bl	9334 <bt_conn_lookup_addr_le>
			if (tmp) {
    ad98:	b120      	cbz	r0, ada4 <disconnected_cb+0x74>
				if (tmp->state == BT_CONN_CONNECTED) {
    ad9a:	7a85      	ldrb	r5, [r0, #10]
				bt_conn_unref(tmp);
    ad9c:	f01b fc0b 	bl	265b6 <bt_conn_unref>
	if (!value_used) {
    ada0:	2d06      	cmp	r5, #6
    ada2:	d0d0      	beq.n	ad46 <disconnected_cb+0x16>
		if (ccc->cfg_changed) {
    ada4:	68e3      	ldr	r3, [r4, #12]
		ccc->value = 0U;
    ada6:	2100      	movs	r1, #0
    ada8:	8161      	strh	r1, [r4, #10]
		if (ccc->cfg_changed) {
    adaa:	2b00      	cmp	r3, #0
    adac:	d0cb      	beq.n	ad46 <disconnected_cb+0x16>
			ccc->cfg_changed(attr, ccc->value);
    adae:	4630      	mov	r0, r6
    adb0:	4798      	blx	r3
    adb2:	e7c8      	b.n	ad46 <disconnected_cb+0x16>
    adb4:	0000af09 	.word	0x0000af09
    adb8:	20006b30 	.word	0x20006b30

0000adbc <sc_save>:
{
    adbc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    adc0:	4680      	mov	r8, r0
    adc2:	460f      	mov	r7, r1
    adc4:	4616      	mov	r6, r2
    adc6:	461d      	mov	r5, r3
	cfg = find_sc_cfg(id, peer);
    adc8:	f7ff ff1e 	bl	ac08 <find_sc_cfg>
	if (!cfg) {
    adcc:	4604      	mov	r4, r0
    adce:	b9d0      	cbnz	r0, ae06 <sc_save+0x4a>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
    add0:	4669      	mov	r1, sp
    add2:	9000      	str	r0, [sp, #0]
    add4:	f8cd 0003 	str.w	r0, [sp, #3]
    add8:	f7ff ff16 	bl	ac08 <find_sc_cfg>
		if (!cfg) {
    addc:	4604      	mov	r4, r0
    adde:	b960      	cbnz	r0, adfa <sc_save+0x3e>
    ade0:	4916      	ldr	r1, [pc, #88]	; (ae3c <sc_save+0x80>)
    ade2:	4b17      	ldr	r3, [pc, #92]	; (ae40 <sc_save+0x84>)
			BT_ERR("unable to save SC: no cfg left");
    ade4:	4817      	ldr	r0, [pc, #92]	; (ae44 <sc_save+0x88>)
    ade6:	1ac9      	subs	r1, r1, r3
    ade8:	08c9      	lsrs	r1, r1, #3
    adea:	0189      	lsls	r1, r1, #6
    adec:	f041 0101 	orr.w	r1, r1, #1
    adf0:	f019 f8e8 	bl	23fc4 <log_0>
}
    adf4:	b002      	add	sp, #8
    adf6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg->id = id;
    adfa:	f800 8b01 	strb.w	r8, [r0], #1
    adfe:	2207      	movs	r2, #7
    ae00:	4639      	mov	r1, r7
    ae02:	f01a ff51 	bl	25ca8 <memcpy>
	if (!(cfg->data.start || cfg->data.end)) {
    ae06:	8922      	ldrh	r2, [r4, #8]
    ae08:	8963      	ldrh	r3, [r4, #10]
    ae0a:	b96a      	cbnz	r2, ae28 <sc_save+0x6c>
    ae0c:	b973      	cbnz	r3, ae2c <sc_save+0x70>
		cfg->data.start = start;
    ae0e:	8126      	strh	r6, [r4, #8]
		*end = new_end;
    ae10:	8165      	strh	r5, [r4, #10]
	    modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
    ae12:	4621      	mov	r1, r4
    ae14:	f811 0b01 	ldrb.w	r0, [r1], #1
    ae18:	f01b fb07 	bl	2642a <bt_addr_le_is_bonded>
    ae1c:	2800      	cmp	r0, #0
    ae1e:	d0e9      	beq.n	adf4 <sc_save+0x38>
		sc_store(cfg);
    ae20:	4620      	mov	r0, r4
    ae22:	f7ff fd71 	bl	a908 <sc_store>
    ae26:	e7e5      	b.n	adf4 <sc_save+0x38>
	if (new_start >= *start && new_end <= *end) {
    ae28:	4296      	cmp	r6, r2
    ae2a:	d302      	bcc.n	ae32 <sc_save+0x76>
    ae2c:	429d      	cmp	r5, r3
    ae2e:	d8ef      	bhi.n	ae10 <sc_save+0x54>
    ae30:	e7e0      	b.n	adf4 <sc_save+0x38>
	if (*end < new_end) {
    ae32:	429d      	cmp	r5, r3
		*start = new_start;
    ae34:	8126      	strh	r6, [r4, #8]
	if (*end < new_end) {
    ae36:	d9ec      	bls.n	ae12 <sc_save+0x56>
    ae38:	e7ea      	b.n	ae10 <sc_save+0x54>
    ae3a:	bf00      	nop
    ae3c:	000298e8 	.word	0x000298e8
    ae40:	00029830 	.word	0x00029830
    ae44:	0002cac4 	.word	0x0002cac4

0000ae48 <notify_cb>:
{
    ae48:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    ae4a:	4b2c      	ldr	r3, [pc, #176]	; (aefc <notify_cb+0xb4>)
    ae4c:	6882      	ldr	r2, [r0, #8]
    ae4e:	429a      	cmp	r2, r3
{
    ae50:	4606      	mov	r6, r0
    ae52:	460d      	mov	r5, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    ae54:	d12e      	bne.n	aeb4 <notify_cb+0x6c>
	ccc = attr->user_data;
    ae56:	68c7      	ldr	r7, [r0, #12]
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
    ae58:	4b29      	ldr	r3, [pc, #164]	; (af00 <notify_cb+0xb8>)
    ae5a:	429f      	cmp	r7, r3
    ae5c:	d11a      	bne.n	ae94 <notify_cb+0x4c>
	return memcmp(a, b, sizeof(*a));
    ae5e:	4c29      	ldr	r4, [pc, #164]	; (af04 <notify_cb+0xbc>)
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    ae60:	2300      	movs	r3, #0
    ae62:	2207      	movs	r2, #7
    ae64:	4669      	mov	r1, sp
    ae66:	1c60      	adds	r0, r4, #1
    ae68:	9300      	str	r3, [sp, #0]
    ae6a:	f8cd 3003 	str.w	r3, [sp, #3]
    ae6e:	f01a ff0b 	bl	25c88 <memcmp>
    ae72:	b178      	cbz	r0, ae94 <notify_cb+0x4c>
			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer,
    ae74:	4621      	mov	r1, r4
    ae76:	2206      	movs	r2, #6
    ae78:	f811 0b01 	ldrb.w	r0, [r1], #1
    ae7c:	f7fe fa76 	bl	936c <bt_conn_lookup_state_le>
			if (!conn) {
    ae80:	b9d8      	cbnz	r0, aeba <notify_cb+0x72>
				sc = (struct sc_data *)data->ind_params->data;
    ae82:	68ab      	ldr	r3, [r5, #8]
				sc_save(cfg->id, &cfg->peer,
    ae84:	4621      	mov	r1, r4
				sc = (struct sc_data *)data->ind_params->data;
    ae86:	68da      	ldr	r2, [r3, #12]
				sc_save(cfg->id, &cfg->peer,
    ae88:	f811 0b01 	ldrb.w	r0, [r1], #1
    ae8c:	8853      	ldrh	r3, [r2, #2]
    ae8e:	8812      	ldrh	r2, [r2, #0]
    ae90:	f7ff ff94 	bl	adbc <sc_save>
		if (cfg->value != data->type) {
    ae94:	893a      	ldrh	r2, [r7, #8]
    ae96:	88ab      	ldrh	r3, [r5, #4]
    ae98:	429a      	cmp	r2, r3
    ae9a:	d10b      	bne.n	aeb4 <notify_cb+0x6c>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    ae9c:	4639      	mov	r1, r7
    ae9e:	f811 0b01 	ldrb.w	r0, [r1], #1
    aea2:	f7fe fa47 	bl	9334 <bt_conn_lookup_addr_le>
		if (!conn) {
    aea6:	4604      	mov	r4, r0
    aea8:	b120      	cbz	r0, aeb4 <notify_cb+0x6c>
		if (conn->state != BT_CONN_CONNECTED) {
    aeaa:	7a83      	ldrb	r3, [r0, #10]
    aeac:	2b06      	cmp	r3, #6
    aeae:	d007      	beq.n	aec0 <notify_cb+0x78>
			bt_conn_unref(conn);
    aeb0:	f01b fb81 	bl	265b6 <bt_conn_unref>
	return BT_GATT_ITER_CONTINUE;
    aeb4:	2001      	movs	r0, #1
}
    aeb6:	b003      	add	sp, #12
    aeb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
			bt_conn_unref(conn);
    aeba:	f01b fb7c 	bl	265b6 <bt_conn_unref>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    aebe:	e7e9      	b.n	ae94 <notify_cb+0x4c>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
    aec0:	697b      	ldr	r3, [r7, #20]
    aec2:	b123      	cbz	r3, aece <notify_cb+0x86>
    aec4:	4631      	mov	r1, r6
    aec6:	4798      	blx	r3
    aec8:	b908      	cbnz	r0, aece <notify_cb+0x86>
			bt_conn_unref(conn);
    aeca:	4620      	mov	r0, r4
    aecc:	e7f0      	b.n	aeb0 <notify_cb+0x68>
		if (data->type == BT_GATT_CCC_INDICATE) {
    aece:	8a31      	ldrh	r1, [r6, #16]
    aed0:	88ab      	ldrh	r3, [r5, #4]
    aed2:	68aa      	ldr	r2, [r5, #8]
    aed4:	3901      	subs	r1, #1
    aed6:	2b02      	cmp	r3, #2
    aed8:	b289      	uxth	r1, r1
			err = gatt_indicate(conn, attr->handle - 1,
    aeda:	4620      	mov	r0, r4
		if (data->type == BT_GATT_CCC_INDICATE) {
    aedc:	d10b      	bne.n	aef6 <notify_cb+0xae>
			err = gatt_indicate(conn, attr->handle - 1,
    aede:	f7ff fe37 	bl	ab50 <gatt_indicate>
			err = gatt_notify(conn, attr->handle - 1,
    aee2:	4606      	mov	r6, r0
		bt_conn_unref(conn);
    aee4:	4620      	mov	r0, r4
    aee6:	f01b fb66 	bl	265b6 <bt_conn_unref>
		if (err < 0) {
    aeea:	2e00      	cmp	r6, #0
    aeec:	f04f 0000 	mov.w	r0, #0
    aef0:	dbe1      	blt.n	aeb6 <notify_cb+0x6e>
		data->err = 0;
    aef2:	6028      	str	r0, [r5, #0]
    aef4:	e7de      	b.n	aeb4 <notify_cb+0x6c>
			err = gatt_notify(conn, attr->handle - 1,
    aef6:	f7ff fdb5 	bl	aa64 <gatt_notify>
    aefa:	e7f2      	b.n	aee2 <notify_cb+0x9a>
    aefc:	0000af09 	.word	0x0000af09
    af00:	20006b30 	.word	0x20006b30
    af04:	20001e7e 	.word	0x20001e7e

0000af08 <bt_gatt_attr_write_ccc>:
{
    af08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    af0c:	461f      	mov	r7, r3
    af0e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	struct _bt_gatt_ccc *ccc = attr->user_data;
    af12:	f8d1 900c 	ldr.w	r9, [r1, #12]
{
    af16:	4606      	mov	r6, r0
    af18:	4688      	mov	r8, r1
	if (offset) {
    af1a:	2b00      	cmp	r3, #0
    af1c:	d14b      	bne.n	afb6 <bt_gatt_attr_write_ccc+0xae>
	if (!len || len > sizeof(u16_t)) {
    af1e:	1e7b      	subs	r3, r7, #1
    af20:	2b01      	cmp	r3, #1
    af22:	d84b      	bhi.n	afbc <bt_gatt_attr_write_ccc+0xb4>
	if (len < sizeof(u16_t)) {
    af24:	2f01      	cmp	r7, #1
		value = *(u8_t *)buf;
    af26:	7815      	ldrb	r5, [r2, #0]
	return ((u16_t)src[1] << 8) | src[0];
    af28:	bf18      	it	ne
    af2a:	7853      	ldrbne	r3, [r2, #1]
	cfg = find_ccc_cfg(conn, ccc);
    af2c:	4649      	mov	r1, r9
		value = *(u8_t *)buf;
    af2e:	bf0c      	ite	eq
    af30:	b2ad      	uxtheq	r5, r5
    af32:	ea45 2503 	orrne.w	r5, r5, r3, lsl #8
	cfg = find_ccc_cfg(conn, ccc);
    af36:	f01b ff09 	bl	26d4c <find_ccc_cfg>
	if (!cfg) {
    af3a:	4604      	mov	r4, r0
    af3c:	b9e8      	cbnz	r0, af7a <bt_gatt_attr_write_ccc+0x72>
		if (!value) {
    af3e:	b915      	cbnz	r5, af46 <bt_gatt_attr_write_ccc+0x3e>
			return len;
    af40:	4638      	mov	r0, r7
}
    af42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		cfg = find_ccc_cfg(NULL, ccc);
    af46:	4649      	mov	r1, r9
    af48:	f01b ff00 	bl	26d4c <find_ccc_cfg>
		if (!cfg) {
    af4c:	4604      	mov	r4, r0
    af4e:	b960      	cbnz	r0, af6a <bt_gatt_attr_write_ccc+0x62>
    af50:	4b1c      	ldr	r3, [pc, #112]	; (afc4 <bt_gatt_attr_write_ccc+0xbc>)
    af52:	491d      	ldr	r1, [pc, #116]	; (afc8 <bt_gatt_attr_write_ccc+0xc0>)
			BT_WARN("No space to store CCC cfg");
    af54:	481d      	ldr	r0, [pc, #116]	; (afcc <bt_gatt_attr_write_ccc+0xc4>)
    af56:	1ac9      	subs	r1, r1, r3
    af58:	08c9      	lsrs	r1, r1, #3
    af5a:	0189      	lsls	r1, r1, #6
    af5c:	f041 0102 	orr.w	r1, r1, #2
    af60:	f019 f830 	bl	23fc4 <log_0>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
    af64:	f06f 0010 	mvn.w	r0, #16
    af68:	e7eb      	b.n	af42 <bt_gatt_attr_write_ccc+0x3a>
	memcpy(dst, src, sizeof(*dst));
    af6a:	2207      	movs	r2, #7
    af6c:	f106 0174 	add.w	r1, r6, #116	; 0x74
    af70:	3001      	adds	r0, #1
    af72:	f01a fe99 	bl	25ca8 <memcpy>
		cfg->id = conn->id;
    af76:	7a33      	ldrb	r3, [r6, #8]
    af78:	7023      	strb	r3, [r4, #0]
	if (ccc->cfg_write) {
    af7a:	f8d9 3010 	ldr.w	r3, [r9, #16]
    af7e:	b973      	cbnz	r3, af9e <bt_gatt_attr_write_ccc+0x96>
	if (cfg->value != ccc->value) {
    af80:	f8b9 300a 	ldrh.w	r3, [r9, #10]
	cfg->value = value;
    af84:	8125      	strh	r5, [r4, #8]
	if (cfg->value != ccc->value) {
    af86:	42ab      	cmp	r3, r5
    af88:	d003      	beq.n	af92 <bt_gatt_attr_write_ccc+0x8a>
		gatt_ccc_changed(attr, ccc);
    af8a:	4649      	mov	r1, r9
    af8c:	4640      	mov	r0, r8
    af8e:	f01b fe8c 	bl	26caa <gatt_ccc_changed>
	if (!value) {
    af92:	2d00      	cmp	r5, #0
    af94:	d1d4      	bne.n	af40 <bt_gatt_attr_write_ccc+0x38>
		clear_ccc_cfg(cfg);
    af96:	4620      	mov	r0, r4
    af98:	f01b fef2 	bl	26d80 <clear_ccc_cfg>
    af9c:	e7d0      	b.n	af40 <bt_gatt_attr_write_ccc+0x38>
		ssize_t write = ccc->cfg_write(conn, attr, value);
    af9e:	462a      	mov	r2, r5
    afa0:	4641      	mov	r1, r8
    afa2:	4630      	mov	r0, r6
    afa4:	4798      	blx	r3
		if (write < 0) {
    afa6:	2800      	cmp	r0, #0
    afa8:	dbcb      	blt.n	af42 <bt_gatt_attr_write_ccc+0x3a>
		if (write != sizeof(value) && write != 1) {
    afaa:	1e42      	subs	r2, r0, #1
    afac:	2a01      	cmp	r2, #1
    afae:	d9e7      	bls.n	af80 <bt_gatt_attr_write_ccc+0x78>
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
    afb0:	f06f 000d 	mvn.w	r0, #13
    afb4:	e7c5      	b.n	af42 <bt_gatt_attr_write_ccc+0x3a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    afb6:	f06f 0006 	mvn.w	r0, #6
    afba:	e7c2      	b.n	af42 <bt_gatt_attr_write_ccc+0x3a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    afbc:	f06f 000c 	mvn.w	r0, #12
    afc0:	e7bf      	b.n	af42 <bt_gatt_attr_write_ccc+0x3a>
    afc2:	bf00      	nop
    afc4:	00029830 	.word	0x00029830
    afc8:	000298e8 	.word	0x000298e8
    afcc:	0002cae3 	.word	0x0002cae3

0000afd0 <sc_set>:
}

#if defined(CONFIG_BT_GATT_SERVICE_CHANGED)
static int sc_set(const char *name, size_t len_rd, settings_read_cb read_cb,
		  void *cb_arg)
{
    afd0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    afd4:	460e      	mov	r6, r1
    afd6:	b087      	sub	sp, #28
    afd8:	4690      	mov	r8, r2
    afda:	4699      	mov	r9, r3
	u8_t id;
	bt_addr_le_t addr;
	int len, err;
	const char *next;

	if (!name) {
    afdc:	4607      	mov	r7, r0
    afde:	b978      	cbnz	r0, b000 <sc_set+0x30>
    afe0:	4937      	ldr	r1, [pc, #220]	; (b0c0 <sc_set+0xf0>)
    afe2:	4b38      	ldr	r3, [pc, #224]	; (b0c4 <sc_set+0xf4>)
		BT_ERR("Insufficient number of arguments");
    afe4:	4838      	ldr	r0, [pc, #224]	; (b0c8 <sc_set+0xf8>)
    afe6:	1ac9      	subs	r1, r1, r3
    afe8:	08c9      	lsrs	r1, r1, #3
    afea:	0189      	lsls	r1, r1, #6
    afec:	f041 0101 	orr.w	r1, r1, #1
    aff0:	f018 ffe8 	bl	23fc4 <log_0>
	}

	err = bt_settings_decode_key(name, &addr);
	if (err) {
		BT_ERR("Unable to decode address %s", log_strdup(name));
		return -EINVAL;
    aff4:	f06f 0515 	mvn.w	r5, #21

		BT_DBG("Removed SC for %s", bt_addr_le_str(&addr));
	}

	return 0;
}
    aff8:	4628      	mov	r0, r5
    affa:	b007      	add	sp, #28
    affc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	err = bt_settings_decode_key(name, &addr);
    b000:	a902      	add	r1, sp, #8
    b002:	f01a ff50 	bl	25ea6 <bt_settings_decode_key>
	if (err) {
    b006:	4605      	mov	r5, r0
    b008:	b178      	cbz	r0, b02a <sc_set+0x5a>
    b00a:	4a2e      	ldr	r2, [pc, #184]	; (b0c4 <sc_set+0xf4>)
    b00c:	4c2c      	ldr	r4, [pc, #176]	; (b0c0 <sc_set+0xf0>)
		BT_ERR("Unable to decode address %s", log_strdup(name));
    b00e:	4638      	mov	r0, r7
    b010:	1aa4      	subs	r4, r4, r2
    b012:	08e4      	lsrs	r4, r4, #3
    b014:	f7f7 fae4 	bl	25e0 <log_strdup>
    b018:	01a4      	lsls	r4, r4, #6
    b01a:	f044 0401 	orr.w	r4, r4, #1
    b01e:	4601      	mov	r1, r0
    b020:	4622      	mov	r2, r4
    b022:	482a      	ldr	r0, [pc, #168]	; (b0cc <sc_set+0xfc>)
    b024:	f018 ffdb 	bl	23fde <log_1>
    b028:	e7e4      	b.n	aff4 <sc_set+0x24>
	settings_name_next(name, &next);
    b02a:	a901      	add	r1, sp, #4
    b02c:	4638      	mov	r0, r7
    b02e:	f019 fba6 	bl	2477e <settings_name_next>
	if (!next) {
    b032:	9801      	ldr	r0, [sp, #4]
    b034:	b308      	cbz	r0, b07a <sc_set+0xaa>
		id = strtol(next, NULL, 10);
    b036:	220a      	movs	r2, #10
    b038:	4629      	mov	r1, r5
    b03a:	f01a fd62 	bl	25b02 <strtol>
    b03e:	b2c7      	uxtb	r7, r0
	cfg = find_sc_cfg(id, &addr);
    b040:	a902      	add	r1, sp, #8
    b042:	4638      	mov	r0, r7
    b044:	f7ff fde0 	bl	ac08 <find_sc_cfg>
	if (!cfg && len_rd) {
    b048:	4604      	mov	r4, r0
    b04a:	bb90      	cbnz	r0, b0b2 <sc_set+0xe2>
    b04c:	2e00      	cmp	r6, #0
    b04e:	d0d3      	beq.n	aff8 <sc_set+0x28>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
    b050:	a904      	add	r1, sp, #16
    b052:	9004      	str	r0, [sp, #16]
    b054:	f8cd 0013 	str.w	r0, [sp, #19]
    b058:	f7ff fdd6 	bl	ac08 <find_sc_cfg>
		if (!cfg) {
    b05c:	4604      	mov	r4, r0
    b05e:	b970      	cbnz	r0, b07e <sc_set+0xae>
    b060:	4b18      	ldr	r3, [pc, #96]	; (b0c4 <sc_set+0xf4>)
    b062:	4917      	ldr	r1, [pc, #92]	; (b0c0 <sc_set+0xf0>)
			BT_ERR("Unable to restore SC: no cfg left");
    b064:	481a      	ldr	r0, [pc, #104]	; (b0d0 <sc_set+0x100>)
    b066:	1ac9      	subs	r1, r1, r3
    b068:	08c9      	lsrs	r1, r1, #3
    b06a:	0189      	lsls	r1, r1, #6
    b06c:	f041 0101 	orr.w	r1, r1, #1
    b070:	f018 ffa8 	bl	23fc4 <log_0>
			return -ENOMEM;
    b074:	f06f 050b 	mvn.w	r5, #11
    b078:	e7be      	b.n	aff8 <sc_set+0x28>
		id = BT_ID_DEFAULT;
    b07a:	462f      	mov	r7, r5
    b07c:	e7e0      	b.n	b040 <sc_set+0x70>
		cfg->id = id;
    b07e:	f800 7b01 	strb.w	r7, [r0], #1
    b082:	2207      	movs	r2, #7
    b084:	a902      	add	r1, sp, #8
    b086:	f01a fe0f 	bl	25ca8 <memcpy>
		len = read_cb(cb_arg, &cfg->data, sizeof(cfg->data));
    b08a:	f104 0108 	add.w	r1, r4, #8
    b08e:	2204      	movs	r2, #4
    b090:	4648      	mov	r0, r9
    b092:	47c0      	blx	r8
		if (len < 0) {
    b094:	1e04      	subs	r4, r0, #0
    b096:	daaf      	bge.n	aff8 <sc_set+0x28>
    b098:	4b0a      	ldr	r3, [pc, #40]	; (b0c4 <sc_set+0xf4>)
    b09a:	4a09      	ldr	r2, [pc, #36]	; (b0c0 <sc_set+0xf0>)
			BT_ERR("Failed to decode value (err %d)", len);
    b09c:	480d      	ldr	r0, [pc, #52]	; (b0d4 <sc_set+0x104>)
    b09e:	1ad2      	subs	r2, r2, r3
    b0a0:	08d2      	lsrs	r2, r2, #3
    b0a2:	0192      	lsls	r2, r2, #6
    b0a4:	f042 0201 	orr.w	r2, r2, #1
    b0a8:	4621      	mov	r1, r4
    b0aa:	f018 ff98 	bl	23fde <log_1>
			return len;
    b0ae:	4625      	mov	r5, r4
    b0b0:	e7a2      	b.n	aff8 <sc_set+0x28>
	if (len_rd) {
    b0b2:	2e00      	cmp	r6, #0
    b0b4:	d1e9      	bne.n	b08a <sc_set+0xba>
		memset(cfg, 0, sizeof(*cfg));
    b0b6:	220c      	movs	r2, #12
    b0b8:	4631      	mov	r1, r6
    b0ba:	f01a fe20 	bl	25cfe <memset>
		BT_DBG("Removed SC for %s", bt_addr_le_str(&addr));
    b0be:	e79b      	b.n	aff8 <sc_set+0x28>
    b0c0:	000298e8 	.word	0x000298e8
    b0c4:	00029830 	.word	0x00029830
    b0c8:	0002ba0e 	.word	0x0002ba0e
    b0cc:	0002cafd 	.word	0x0002cafd
    b0d0:	0002cb19 	.word	0x0002cb19
    b0d4:	0002cb3b 	.word	0x0002cb3b

0000b0d8 <sc_commit>:

static int sc_commit(void)
{
    b0d8:	b508      	push	{r3, lr}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    b0da:	490e      	ldr	r1, [pc, #56]	; (b114 <sc_commit+0x3c>)
    b0dc:	f3bf 8f5b 	dmb	ish
    b0e0:	f101 0338 	add.w	r3, r1, #56	; 0x38
    b0e4:	e853 2f00 	ldrex	r2, [r3]
    b0e8:	f022 0202 	bic.w	r2, r2, #2
    b0ec:	e843 2000 	strex	r0, r2, [r3]
    b0f0:	2800      	cmp	r0, #0
    b0f2:	d1f7      	bne.n	b0e4 <sc_commit+0xc>
    b0f4:	f3bf 8f5b 	dmb	ish
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    b0f8:	f3bf 8f5b 	dmb	ish
    b0fc:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    b0fe:	f3bf 8f5b 	dmb	ish
	atomic_clear_bit(gatt_sc.flags, SC_INDICATE_PENDING);

	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    b102:	07db      	lsls	r3, r3, #31
    b104:	d504      	bpl.n	b110 <sc_commit+0x38>
    b106:	4804      	ldr	r0, [pc, #16]	; (b118 <sc_commit+0x40>)
    b108:	220a      	movs	r2, #10
    b10a:	3118      	adds	r1, #24
    b10c:	f017 fd28 	bl	22b60 <k_delayed_work_submit_to_queue>
		/* Schedule SC indication since the range has changed */
		k_delayed_work_submit(&gatt_sc.work, SC_TIMEOUT);
	}

	return 0;
}
    b110:	2000      	movs	r0, #0
    b112:	bd08      	pop	{r3, pc}
    b114:	200006bc 	.word	0x200006bc
    b118:	20001dc4 	.word	0x20001dc4

0000b11c <sc_indicate>:
{
    b11c:	b510      	push	{r4, lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    b11e:	4b16      	ldr	r3, [pc, #88]	; (b178 <sc_indicate+0x5c>)
    b120:	f3bf 8f5b 	dmb	ish
    b124:	f103 0238 	add.w	r2, r3, #56	; 0x38
    b128:	e852 4f00 	ldrex	r4, [r2]
    b12c:	f044 0c01 	orr.w	ip, r4, #1
    b130:	e842 ce00 	strex	lr, ip, [r2]
    b134:	f1be 0f00 	cmp.w	lr, #0
    b138:	d1f6      	bne.n	b128 <sc_indicate+0xc>
    b13a:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    b13e:	07e2      	lsls	r2, r4, #31
    b140:	d40f      	bmi.n	b162 <sc_indicate+0x46>
		gatt_sc.start = start;
    b142:	8298      	strh	r0, [r3, #20]
		*end = new_end;
    b144:	82d9      	strh	r1, [r3, #22]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    b146:	f3bf 8f5b 	dmb	ish
    b14a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    b14c:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(gatt_sc.flags, SC_INDICATE_PENDING)) {
    b150:	079b      	lsls	r3, r3, #30
    b152:	d40c      	bmi.n	b16e <sc_indicate+0x52>
}
    b154:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b158:	4908      	ldr	r1, [pc, #32]	; (b17c <sc_indicate+0x60>)
    b15a:	4809      	ldr	r0, [pc, #36]	; (b180 <sc_indicate+0x64>)
    b15c:	220a      	movs	r2, #10
    b15e:	f017 bcff 	b.w	22b60 <k_delayed_work_submit_to_queue>
	if (new_start >= *start && new_end <= *end) {
    b162:	8a9c      	ldrh	r4, [r3, #20]
    b164:	8ada      	ldrh	r2, [r3, #22]
    b166:	4284      	cmp	r4, r0
    b168:	d802      	bhi.n	b170 <sc_indicate+0x54>
    b16a:	4291      	cmp	r1, r2
    b16c:	d8ea      	bhi.n	b144 <sc_indicate+0x28>
}
    b16e:	bd10      	pop	{r4, pc}
	if (*end < new_end) {
    b170:	4291      	cmp	r1, r2
		*start = new_start;
    b172:	8298      	strh	r0, [r3, #20]
	if (*end < new_end) {
    b174:	d9e7      	bls.n	b146 <sc_indicate+0x2a>
    b176:	e7e5      	b.n	b144 <sc_indicate+0x28>
    b178:	200006bc 	.word	0x200006bc
    b17c:	200006d4 	.word	0x200006d4
    b180:	20001dc4 	.word	0x20001dc4

0000b184 <bt_gatt_init>:
{
    b184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    b186:	4b20      	ldr	r3, [pc, #128]	; (b208 <bt_gatt_init+0x84>)
    b188:	f3bf 8f5b 	dmb	ish
    b18c:	2201      	movs	r2, #1
    b18e:	e853 1f00 	ldrex	r1, [r3]
    b192:	2900      	cmp	r1, #0
    b194:	d103      	bne.n	b19e <bt_gatt_init+0x1a>
    b196:	e843 2000 	strex	r0, r2, [r3]
    b19a:	2800      	cmp	r0, #0
    b19c:	d1f7      	bne.n	b18e <bt_gatt_init+0xa>
    b19e:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&init, 0, 1)) {
    b1a2:	d02b      	beq.n	b1fc <bt_gatt_init+0x78>
}
    b1a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		last_static_handle += svc->attr_count;
    b1a6:	4a19      	ldr	r2, [pc, #100]	; (b20c <bt_gatt_init+0x88>)
    b1a8:	6863      	ldr	r3, [r4, #4]
    b1aa:	8811      	ldrh	r1, [r2, #0]
    b1ac:	440b      	add	r3, r1
    b1ae:	8013      	strh	r3, [r2, #0]
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    b1b0:	3408      	adds	r4, #8
    b1b2:	42ac      	cmp	r4, r5
    b1b4:	d90e      	bls.n	b1d4 <bt_gatt_init+0x50>
    b1b6:	4916      	ldr	r1, [pc, #88]	; (b210 <bt_gatt_init+0x8c>)
    b1b8:	4816      	ldr	r0, [pc, #88]	; (b214 <bt_gatt_init+0x90>)
    b1ba:	f240 33c7 	movw	r3, #967	; 0x3c7
    b1be:	4632      	mov	r2, r6
    b1c0:	f018 fe8f 	bl	23ee2 <printk>
    b1c4:	4814      	ldr	r0, [pc, #80]	; (b218 <bt_gatt_init+0x94>)
    b1c6:	f018 fe8c 	bl	23ee2 <printk>
    b1ca:	f240 31c7 	movw	r1, #967	; 0x3c7
    b1ce:	4630      	mov	r0, r6
    b1d0:	f018 feca 	bl	23f68 <assert_post_action>
    b1d4:	42bc      	cmp	r4, r7
    b1d6:	d3e6      	bcc.n	b1a6 <bt_gatt_init+0x22>
		k_delayed_work_init(&gatt_sc.work, sc_process);
    b1d8:	4910      	ldr	r1, [pc, #64]	; (b21c <bt_gatt_init+0x98>)
    b1da:	4811      	ldr	r0, [pc, #68]	; (b220 <bt_gatt_init+0x9c>)
    b1dc:	f01e f90d 	bl	293fa <k_delayed_work_init>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    b1e0:	f3bf 8f5b 	dmb	ish
    b1e4:	4b0f      	ldr	r3, [pc, #60]	; (b224 <bt_gatt_init+0xa0>)
    b1e6:	e853 2f00 	ldrex	r2, [r3]
    b1ea:	f042 0202 	orr.w	r2, r2, #2
    b1ee:	e843 2100 	strex	r1, r2, [r3]
    b1f2:	2900      	cmp	r1, #0
    b1f4:	d1f7      	bne.n	b1e6 <bt_gatt_init+0x62>
    b1f6:	f3bf 8f5b 	dmb	ish
    b1fa:	e7d3      	b.n	b1a4 <bt_gatt_init+0x20>
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    b1fc:	4d0a      	ldr	r5, [pc, #40]	; (b228 <bt_gatt_init+0xa4>)
    b1fe:	4c0b      	ldr	r4, [pc, #44]	; (b22c <bt_gatt_init+0xa8>)
    b200:	4e0b      	ldr	r6, [pc, #44]	; (b230 <bt_gatt_init+0xac>)
    b202:	462f      	mov	r7, r5
    b204:	e7d5      	b.n	b1b2 <bt_gatt_init+0x2e>
    b206:	bf00      	nop
    b208:	200006f8 	.word	0x200006f8
    b20c:	20001e7c 	.word	0x20001e7c
    b210:	0002ca32 	.word	0x0002ca32
    b214:	0002a5e8 	.word	0x0002a5e8
    b218:	0002ad2b 	.word	0x0002ad2b
    b21c:	0000ba2d 	.word	0x0000ba2d
    b220:	200006d4 	.word	0x200006d4
    b224:	200006f4 	.word	0x200006f4
    b228:	000297f4 	.word	0x000297f4
    b22c:	000297e4 	.word	0x000297e4
    b230:	0002c9fb 	.word	0x0002c9fb

0000b234 <bt_gatt_service_unregister>:
{
    b234:	b538      	push	{r3, r4, r5, lr}
	__ASSERT(svc, "invalid parameters\n");
    b236:	4604      	mov	r4, r0
    b238:	b970      	cbnz	r0, b258 <bt_gatt_service_unregister+0x24>
    b23a:	491c      	ldr	r1, [pc, #112]	; (b2ac <bt_gatt_service_unregister+0x78>)
    b23c:	4a1c      	ldr	r2, [pc, #112]	; (b2b0 <bt_gatt_service_unregister+0x7c>)
    b23e:	481d      	ldr	r0, [pc, #116]	; (b2b4 <bt_gatt_service_unregister+0x80>)
    b240:	f240 433e 	movw	r3, #1086	; 0x43e
    b244:	f018 fe4d 	bl	23ee2 <printk>
    b248:	481b      	ldr	r0, [pc, #108]	; (b2b8 <bt_gatt_service_unregister+0x84>)
    b24a:	f018 fe4a 	bl	23ee2 <printk>
    b24e:	4818      	ldr	r0, [pc, #96]	; (b2b0 <bt_gatt_service_unregister+0x7c>)
    b250:	f240 413e 	movw	r1, #1086	; 0x43e
    b254:	f018 fe88 	bl	23f68 <assert_post_action>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    b258:	4b18      	ldr	r3, [pc, #96]	; (b2bc <bt_gatt_service_unregister+0x88>)
    b25a:	681a      	ldr	r2, [r3, #0]
	if (!sys_slist_find_and_remove(&db, &svc->node)) {
    b25c:	f104 0008 	add.w	r0, r4, #8
    b260:	2100      	movs	r1, #0
    b262:	b912      	cbnz	r2, b26a <bt_gatt_service_unregister+0x36>
		return -ENOENT;
    b264:	f06f 0001 	mvn.w	r0, #1
    b268:	e015      	b.n	b296 <bt_gatt_service_unregister+0x62>
    b26a:	4290      	cmp	r0, r2
    b26c:	d11a      	bne.n	b2a4 <bt_gatt_service_unregister+0x70>
Z_GENLIST_REMOVE(slist, snode)
    b26e:	68a2      	ldr	r2, [r4, #8]
    b270:	b991      	cbnz	r1, b298 <bt_gatt_service_unregister+0x64>
    b272:	6859      	ldr	r1, [r3, #4]
	list->head = node;
    b274:	601a      	str	r2, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
    b276:	4288      	cmp	r0, r1
    b278:	d100      	bne.n	b27c <bt_gatt_service_unregister+0x48>
	list->tail = node;
    b27a:	605a      	str	r2, [r3, #4]
		    svc->attrs[svc->attr_count - 1].handle);
    b27c:	e9d4 2300 	ldrd	r2, r3, [r4]
	sc_indicate(svc->attrs[0].handle,
    b280:	2114      	movs	r1, #20
    b282:	fb01 2303 	mla	r3, r1, r3, r2
	parent->next = child;
    b286:	2500      	movs	r5, #0
    b288:	8a10      	ldrh	r0, [r2, #16]
    b28a:	f833 1c04 	ldrh.w	r1, [r3, #-4]
    b28e:	60a5      	str	r5, [r4, #8]
    b290:	f7ff ff44 	bl	b11c <sc_indicate>
	return 0;
    b294:	4628      	mov	r0, r5
}
    b296:	bd38      	pop	{r3, r4, r5, pc}
    b298:	600a      	str	r2, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
    b29a:	685a      	ldr	r2, [r3, #4]
    b29c:	4290      	cmp	r0, r2
	list->tail = node;
    b29e:	bf08      	it	eq
    b2a0:	6059      	streq	r1, [r3, #4]
}
    b2a2:	e7eb      	b.n	b27c <bt_gatt_service_unregister+0x48>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    b2a4:	4611      	mov	r1, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    b2a6:	6812      	ldr	r2, [r2, #0]
    b2a8:	e7db      	b.n	b262 <bt_gatt_service_unregister+0x2e>
    b2aa:	bf00      	nop
    b2ac:	0002cb5b 	.word	0x0002cb5b
    b2b0:	0002c9fb 	.word	0x0002c9fb
    b2b4:	0002a5e8 	.word	0x0002a5e8
    b2b8:	0002cb5f 	.word	0x0002cb5f
    b2bc:	200006b4 	.word	0x200006b4

0000b2c0 <bt_gatt_attr_value_handle>:
{
    b2c0:	b508      	push	{r3, lr}
	if ((attr != NULL)
    b2c2:	b180      	cbz	r0, b2e6 <bt_gatt_attr_value_handle+0x26>
	    && (attr->read == bt_gatt_attr_read_chrc)) {
    b2c4:	6841      	ldr	r1, [r0, #4]
    b2c6:	4b09      	ldr	r3, [pc, #36]	; (b2ec <bt_gatt_attr_value_handle+0x2c>)
    b2c8:	4299      	cmp	r1, r3
    b2ca:	d10c      	bne.n	b2e6 <bt_gatt_attr_value_handle+0x26>
		handle = chrc->value_handle;
    b2cc:	68c3      	ldr	r3, [r0, #12]
    b2ce:	889b      	ldrh	r3, [r3, #4]
		if (handle == 0) {
    b2d0:	b91b      	cbnz	r3, b2da <bt_gatt_attr_value_handle+0x1a>
			handle = (attr->handle ? : find_static_attr(attr)) + 1U;
    b2d2:	8a03      	ldrh	r3, [r0, #16]
    b2d4:	b11b      	cbz	r3, b2de <bt_gatt_attr_value_handle+0x1e>
    b2d6:	3301      	adds	r3, #1
    b2d8:	b29b      	uxth	r3, r3
}
    b2da:	4618      	mov	r0, r3
    b2dc:	bd08      	pop	{r3, pc}
			handle = (attr->handle ? : find_static_attr(attr)) + 1U;
    b2de:	f7ff fb81 	bl	a9e4 <find_static_attr>
    b2e2:	1c43      	adds	r3, r0, #1
    b2e4:	e7f8      	b.n	b2d8 <bt_gatt_attr_value_handle+0x18>
	u16_t handle = 0;
    b2e6:	2300      	movs	r3, #0
    b2e8:	e7f7      	b.n	b2da <bt_gatt_attr_value_handle+0x1a>
    b2ea:	bf00      	nop
    b2ec:	00026ec3 	.word	0x00026ec3

0000b2f0 <bt_gatt_foreach_attr_type>:
{
    b2f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b2f4:	b089      	sub	sp, #36	; 0x24
    b2f6:	4698      	mov	r8, r3
    b2f8:	f8bd 4048 	ldrh.w	r4, [sp, #72]	; 0x48
    b2fc:	9100      	str	r1, [sp, #0]
		num_matches = UINT16_MAX;
    b2fe:	f64f 73ff 	movw	r3, #65535	; 0xffff
    b302:	2c00      	cmp	r4, #0
    b304:	bf08      	it	eq
    b306:	461c      	moveq	r4, r3
	if (start_handle <= last_static_handle) {
    b308:	4b56      	ldr	r3, [pc, #344]	; (b464 <bt_gatt_foreach_attr_type+0x174>)
    b30a:	881b      	ldrh	r3, [r3, #0]
    b30c:	4283      	cmp	r3, r0
{
    b30e:	4606      	mov	r6, r0
    b310:	4617      	mov	r7, r2
	if (start_handle <= last_static_handle) {
    b312:	d31b      	bcc.n	b34c <bt_gatt_foreach_attr_type+0x5c>
    b314:	f8df 9164 	ldr.w	r9, [pc, #356]	; b47c <bt_gatt_foreach_attr_type+0x18c>
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    b318:	f8df b164 	ldr.w	fp, [pc, #356]	; b480 <bt_gatt_foreach_attr_type+0x190>
		u16_t handle = 1;
    b31c:	2501      	movs	r5, #1
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    b31e:	4b52      	ldr	r3, [pc, #328]	; (b468 <bt_gatt_foreach_attr_type+0x178>)
    b320:	f1a9 0a08 	sub.w	sl, r9, #8
    b324:	459a      	cmp	sl, r3
    b326:	d90e      	bls.n	b346 <bt_gatt_foreach_attr_type+0x56>
    b328:	4950      	ldr	r1, [pc, #320]	; (b46c <bt_gatt_foreach_attr_type+0x17c>)
    b32a:	4851      	ldr	r0, [pc, #324]	; (b470 <bt_gatt_foreach_attr_type+0x180>)
    b32c:	f240 5349 	movw	r3, #1353	; 0x549
    b330:	465a      	mov	r2, fp
    b332:	f018 fdd6 	bl	23ee2 <printk>
    b336:	484f      	ldr	r0, [pc, #316]	; (b474 <bt_gatt_foreach_attr_type+0x184>)
    b338:	f018 fdd3 	bl	23ee2 <printk>
    b33c:	f240 5149 	movw	r1, #1353	; 0x549
    b340:	4658      	mov	r0, fp
    b342:	f018 fe11 	bl	23f68 <assert_post_action>
    b346:	4b48      	ldr	r3, [pc, #288]	; (b468 <bt_gatt_foreach_attr_type+0x178>)
    b348:	459a      	cmp	sl, r3
    b34a:	d323      	bcc.n	b394 <bt_gatt_foreach_attr_type+0xa4>
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
    b34c:	4b4a      	ldr	r3, [pc, #296]	; (b478 <bt_gatt_foreach_attr_type+0x188>)
    b34e:	681d      	ldr	r5, [r3, #0]
    b350:	2d00      	cmp	r5, #0
    b352:	d052      	beq.n	b3fa <bt_gatt_foreach_attr_type+0x10a>
    b354:	3d08      	subs	r5, #8
			struct bt_gatt_attr *attr = &svc->attrs[i];
    b356:	f04f 0a14 	mov.w	sl, #20
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
    b35a:	2d00      	cmp	r5, #0
    b35c:	d04d      	beq.n	b3fa <bt_gatt_foreach_attr_type+0x10a>
Z_GENLIST_PEEK_NEXT(slist, snode)
    b35e:	f115 0908 	adds.w	r9, r5, #8
    b362:	d00a      	beq.n	b37a <bt_gatt_foreach_attr_type+0x8a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    b364:	68ab      	ldr	r3, [r5, #8]
		next = SYS_SLIST_PEEK_NEXT_CONTAINER(svc, node);
    b366:	2b00      	cmp	r3, #0
    b368:	d07a      	beq.n	b460 <bt_gatt_foreach_attr_type+0x170>
		if (next) {
    b36a:	f1b3 0b08 	subs.w	fp, r3, #8
    b36e:	d006      	beq.n	b37e <bt_gatt_foreach_attr_type+0x8e>
			if (next->attrs[0].handle <= start_handle) {
    b370:	f853 3c08 	ldr.w	r3, [r3, #-8]
    b374:	8a1b      	ldrh	r3, [r3, #16]
    b376:	42b3      	cmp	r3, r6
    b378:	d907      	bls.n	b38a <bt_gatt_foreach_attr_type+0x9a>
    b37a:	f04f 0b00 	mov.w	fp, #0
		for (i = 0; i < svc->attr_count; i++) {
    b37e:	686b      	ldr	r3, [r5, #4]
    b380:	455b      	cmp	r3, fp
    b382:	d844      	bhi.n	b40e <bt_gatt_foreach_attr_type+0x11e>
Z_GENLIST_PEEK_NEXT(slist, snode)
    b384:	f1b9 0f00 	cmp.w	r9, #0
    b388:	d037      	beq.n	b3fa <bt_gatt_foreach_attr_type+0x10a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    b38a:	68ad      	ldr	r5, [r5, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
    b38c:	2d00      	cmp	r5, #0
    b38e:	d034      	beq.n	b3fa <bt_gatt_foreach_attr_type+0x10a>
    b390:	3d08      	subs	r5, #8
    b392:	e7e2      	b.n	b35a <bt_gatt_foreach_attr_type+0x6a>
			if (handle + static_svc->attr_count < start_handle) {
    b394:	f859 3c04 	ldr.w	r3, [r9, #-4]
    b398:	442b      	add	r3, r5
    b39a:	42b3      	cmp	r3, r6
    b39c:	d234      	bcs.n	b408 <bt_gatt_foreach_attr_type+0x118>
				handle += static_svc->attr_count;
    b39e:	b29d      	uxth	r5, r3
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    b3a0:	f109 0908 	add.w	r9, r9, #8
    b3a4:	e7bb      	b.n	b31e <bt_gatt_foreach_attr_type+0x2e>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    b3a6:	9903      	ldr	r1, [sp, #12]
    b3a8:	4638      	mov	r0, r7
    b3aa:	f01a ff4d 	bl	26248 <bt_uuid_cmp>
    b3ae:	b1c0      	cbz	r0, b3e2 <bt_gatt_foreach_attr_type+0xf2>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    b3b0:	3501      	adds	r5, #1
    b3b2:	f10a 0a01 	add.w	sl, sl, #1
    b3b6:	b2ad      	uxth	r5, r5
    b3b8:	f859 3c04 	ldr.w	r3, [r9, #-4]
    b3bc:	4553      	cmp	r3, sl
    b3be:	d9ef      	bls.n	b3a0 <bt_gatt_foreach_attr_type+0xb0>
				memcpy(&attr, &static_svc->attrs[i],
    b3c0:	f859 1c08 	ldr.w	r1, [r9, #-8]
    b3c4:	2214      	movs	r2, #20
    b3c6:	fb02 110a 	mla	r1, r2, sl, r1
    b3ca:	a803      	add	r0, sp, #12
    b3cc:	f01a fc6c 	bl	25ca8 <memcpy>
	if (attr->handle > end_handle) {
    b3d0:	9b00      	ldr	r3, [sp, #0]
				attr.handle = handle;
    b3d2:	f8ad 501c 	strh.w	r5, [sp, #28]
	if (attr->handle > end_handle) {
    b3d6:	429d      	cmp	r5, r3
    b3d8:	d80f      	bhi.n	b3fa <bt_gatt_foreach_attr_type+0x10a>
	if (attr->handle < start_handle) {
    b3da:	42b5      	cmp	r5, r6
    b3dc:	d3e8      	bcc.n	b3b0 <bt_gatt_foreach_attr_type+0xc0>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    b3de:	2f00      	cmp	r7, #0
    b3e0:	d1e1      	bne.n	b3a6 <bt_gatt_foreach_attr_type+0xb6>
	if (attr_data && attr_data != attr->user_data) {
    b3e2:	f1b8 0f00 	cmp.w	r8, #0
    b3e6:	d10b      	bne.n	b400 <bt_gatt_foreach_attr_type+0x110>
	*num_matches -= 1;
    b3e8:	3c01      	subs	r4, #1
    b3ea:	b2a4      	uxth	r4, r4
	result = func(attr, user_data);
    b3ec:	9914      	ldr	r1, [sp, #80]	; 0x50
    b3ee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    b3f0:	a803      	add	r0, sp, #12
    b3f2:	4798      	blx	r3
	if (!*num_matches) {
    b3f4:	b10c      	cbz	r4, b3fa <bt_gatt_foreach_attr_type+0x10a>
				if (gatt_foreach_iter(&attr, start_handle,
    b3f6:	2800      	cmp	r0, #0
    b3f8:	d1da      	bne.n	b3b0 <bt_gatt_foreach_attr_type+0xc0>
}
    b3fa:	b009      	add	sp, #36	; 0x24
    b3fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (attr_data && attr_data != attr->user_data) {
    b400:	9b06      	ldr	r3, [sp, #24]
    b402:	4598      	cmp	r8, r3
    b404:	d1d4      	bne.n	b3b0 <bt_gatt_foreach_attr_type+0xc0>
    b406:	e7ef      	b.n	b3e8 <bt_gatt_foreach_attr_type+0xf8>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    b408:	f04f 0a00 	mov.w	sl, #0
    b40c:	e7d4      	b.n	b3b8 <bt_gatt_foreach_attr_type+0xc8>
			struct bt_gatt_attr *attr = &svc->attrs[i];
    b40e:	6829      	ldr	r1, [r5, #0]
	if (attr->handle > end_handle) {
    b410:	9a00      	ldr	r2, [sp, #0]
			struct bt_gatt_attr *attr = &svc->attrs[i];
    b412:	fb0a fc0b 	mul.w	ip, sl, fp
    b416:	eb01 030c 	add.w	r3, r1, ip
	if (attr->handle > end_handle) {
    b41a:	8a18      	ldrh	r0, [r3, #16]
    b41c:	4282      	cmp	r2, r0
    b41e:	d3ec      	bcc.n	b3fa <bt_gatt_foreach_attr_type+0x10a>
	if (attr->handle < start_handle) {
    b420:	4286      	cmp	r6, r0
    b422:	d816      	bhi.n	b452 <bt_gatt_foreach_attr_type+0x162>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    b424:	b967      	cbnz	r7, b440 <bt_gatt_foreach_attr_type+0x150>
	if (attr_data && attr_data != attr->user_data) {
    b426:	f1b8 0f00 	cmp.w	r8, #0
    b42a:	d115      	bne.n	b458 <bt_gatt_foreach_attr_type+0x168>
	*num_matches -= 1;
    b42c:	3c01      	subs	r4, #1
    b42e:	b2a4      	uxth	r4, r4
	result = func(attr, user_data);
    b430:	4618      	mov	r0, r3
    b432:	9914      	ldr	r1, [sp, #80]	; 0x50
    b434:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    b436:	4798      	blx	r3
	if (!*num_matches) {
    b438:	2c00      	cmp	r4, #0
    b43a:	d0de      	beq.n	b3fa <bt_gatt_foreach_attr_type+0x10a>
			if (gatt_foreach_iter(attr,
    b43c:	b948      	cbnz	r0, b452 <bt_gatt_foreach_attr_type+0x162>
    b43e:	e7dc      	b.n	b3fa <bt_gatt_foreach_attr_type+0x10a>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    b440:	f851 100c 	ldr.w	r1, [r1, ip]
    b444:	9301      	str	r3, [sp, #4]
    b446:	4638      	mov	r0, r7
    b448:	f01a fefe 	bl	26248 <bt_uuid_cmp>
    b44c:	9b01      	ldr	r3, [sp, #4]
    b44e:	2800      	cmp	r0, #0
    b450:	d0e9      	beq.n	b426 <bt_gatt_foreach_attr_type+0x136>
		for (i = 0; i < svc->attr_count; i++) {
    b452:	f10b 0b01 	add.w	fp, fp, #1
    b456:	e792      	b.n	b37e <bt_gatt_foreach_attr_type+0x8e>
	if (attr_data && attr_data != attr->user_data) {
    b458:	68da      	ldr	r2, [r3, #12]
    b45a:	4590      	cmp	r8, r2
    b45c:	d1f9      	bne.n	b452 <bt_gatt_foreach_attr_type+0x162>
    b45e:	e7e5      	b.n	b42c <bt_gatt_foreach_attr_type+0x13c>
    b460:	469b      	mov	fp, r3
    b462:	e78c      	b.n	b37e <bt_gatt_foreach_attr_type+0x8e>
    b464:	20001e7c 	.word	0x20001e7c
    b468:	000297f4 	.word	0x000297f4
    b46c:	0002ca2b 	.word	0x0002ca2b
    b470:	0002a5e8 	.word	0x0002a5e8
    b474:	0002ad2b 	.word	0x0002ad2b
    b478:	200006b4 	.word	0x200006b4
    b47c:	000297ec 	.word	0x000297ec
    b480:	0002c9fb 	.word	0x0002c9fb

0000b484 <bt_gatt_service_register>:
{
    b484:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__ASSERT(svc, "invalid parameters\n");
    b488:	4605      	mov	r5, r0
    b48a:	b970      	cbnz	r0, b4aa <bt_gatt_service_register+0x26>
    b48c:	4970      	ldr	r1, [pc, #448]	; (b650 <bt_gatt_service_register+0x1cc>)
    b48e:	4a71      	ldr	r2, [pc, #452]	; (b654 <bt_gatt_service_register+0x1d0>)
    b490:	4871      	ldr	r0, [pc, #452]	; (b658 <bt_gatt_service_register+0x1d4>)
    b492:	f240 4322 	movw	r3, #1058	; 0x422
    b496:	f018 fd24 	bl	23ee2 <printk>
    b49a:	4870      	ldr	r0, [pc, #448]	; (b65c <bt_gatt_service_register+0x1d8>)
    b49c:	f018 fd21 	bl	23ee2 <printk>
    b4a0:	486c      	ldr	r0, [pc, #432]	; (b654 <bt_gatt_service_register+0x1d0>)
    b4a2:	f240 4122 	movw	r1, #1058	; 0x422
    b4a6:	f018 fd5f 	bl	23f68 <assert_post_action>
	__ASSERT(svc->attrs, "invalid parameters\n");
    b4aa:	682b      	ldr	r3, [r5, #0]
    b4ac:	b973      	cbnz	r3, b4cc <bt_gatt_service_register+0x48>
    b4ae:	496c      	ldr	r1, [pc, #432]	; (b660 <bt_gatt_service_register+0x1dc>)
    b4b0:	4a68      	ldr	r2, [pc, #416]	; (b654 <bt_gatt_service_register+0x1d0>)
    b4b2:	4869      	ldr	r0, [pc, #420]	; (b658 <bt_gatt_service_register+0x1d4>)
    b4b4:	f240 4323 	movw	r3, #1059	; 0x423
    b4b8:	f018 fd13 	bl	23ee2 <printk>
    b4bc:	4867      	ldr	r0, [pc, #412]	; (b65c <bt_gatt_service_register+0x1d8>)
    b4be:	f018 fd10 	bl	23ee2 <printk>
    b4c2:	4864      	ldr	r0, [pc, #400]	; (b654 <bt_gatt_service_register+0x1d0>)
    b4c4:	f240 4123 	movw	r1, #1059	; 0x423
    b4c8:	f018 fd4e 	bl	23f68 <assert_post_action>
	__ASSERT(svc->attr_count, "invalid parameters\n");
    b4cc:	686b      	ldr	r3, [r5, #4]
    b4ce:	b973      	cbnz	r3, b4ee <bt_gatt_service_register+0x6a>
    b4d0:	4964      	ldr	r1, [pc, #400]	; (b664 <bt_gatt_service_register+0x1e0>)
    b4d2:	4a60      	ldr	r2, [pc, #384]	; (b654 <bt_gatt_service_register+0x1d0>)
    b4d4:	4860      	ldr	r0, [pc, #384]	; (b658 <bt_gatt_service_register+0x1d4>)
    b4d6:	f240 4324 	movw	r3, #1060	; 0x424
    b4da:	f018 fd02 	bl	23ee2 <printk>
    b4de:	485f      	ldr	r0, [pc, #380]	; (b65c <bt_gatt_service_register+0x1d8>)
    b4e0:	f018 fcff 	bl	23ee2 <printk>
    b4e4:	485b      	ldr	r0, [pc, #364]	; (b654 <bt_gatt_service_register+0x1d0>)
    b4e6:	f240 4124 	movw	r1, #1060	; 0x424
    b4ea:	f018 fd3d 	bl	23f68 <assert_post_action>
	bt_gatt_init();
    b4ee:	f7ff fe49 	bl	b184 <bt_gatt_init>
	if (!bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GAP) ||
    b4f2:	682b      	ldr	r3, [r5, #0]
    b4f4:	2400      	movs	r4, #0
    b4f6:	6818      	ldr	r0, [r3, #0]
    b4f8:	f88d 4000 	strb.w	r4, [sp]
    b4fc:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
    b500:	4669      	mov	r1, sp
    b502:	f8ad 3002 	strh.w	r3, [sp, #2]
    b506:	f01a fe9f 	bl	26248 <bt_uuid_cmp>
    b50a:	b920      	cbnz	r0, b516 <bt_gatt_service_register+0x92>
		return -EALREADY;
    b50c:	f06f 0044 	mvn.w	r0, #68	; 0x44
}
    b510:	b003      	add	sp, #12
    b512:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    !bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GATT)) {
    b516:	682b      	ldr	r3, [r5, #0]
    b518:	a901      	add	r1, sp, #4
    b51a:	6818      	ldr	r0, [r3, #0]
    b51c:	f88d 4004 	strb.w	r4, [sp, #4]
    b520:	f641 0301 	movw	r3, #6145	; 0x1801
    b524:	f8ad 3006 	strh.w	r3, [sp, #6]
    b528:	f01a fe8e 	bl	26248 <bt_uuid_cmp>
	if (!bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GAP) ||
    b52c:	2800      	cmp	r0, #0
    b52e:	d0ed      	beq.n	b50c <bt_gatt_service_register+0x88>
Z_GENLIST_IS_EMPTY(slist)
    b530:	4c4d      	ldr	r4, [pc, #308]	; (b668 <bt_gatt_service_register+0x1e4>)
	struct bt_gatt_attr *attrs = svc->attrs;
    b532:	f8d5 8000 	ldr.w	r8, [r5]
	if (sys_slist_is_empty(&db)) {
    b536:	6826      	ldr	r6, [r4, #0]
	u16_t count = svc->attr_count;
    b538:	f8b5 9004 	ldrh.w	r9, [r5, #4]
	if (sys_slist_is_empty(&db)) {
    b53c:	b936      	cbnz	r6, b54c <bt_gatt_service_register+0xc8>
		handle = last_static_handle;
    b53e:	4b4b      	ldr	r3, [pc, #300]	; (b66c <bt_gatt_service_register+0x1e8>)
    b540:	881f      	ldrh	r7, [r3, #0]
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
    b542:	f8df b138 	ldr.w	fp, [pc, #312]	; b67c <bt_gatt_service_register+0x1f8>
	const struct bt_gatt_attr *attr = NULL;
    b546:	f04f 0a00 	mov.w	sl, #0
    b54a:	e019      	b.n	b580 <bt_gatt_service_register+0xfc>
	last = SYS_SLIST_PEEK_TAIL_CONTAINER(&db, last, node);
    b54c:	6863      	ldr	r3, [r4, #4]
    b54e:	2b00      	cmp	r3, #0
    b550:	d07b      	beq.n	b64a <bt_gatt_service_register+0x1c6>
	handle = last->attrs[last->attr_count - 1].handle;
    b552:	e953 3202 	ldrd	r3, r2, [r3, #-8]
    b556:	2114      	movs	r1, #20
    b558:	fb01 3302 	mla	r3, r1, r2, r3
    b55c:	f833 7c04 	ldrh.w	r7, [r3, #-4]
    b560:	463e      	mov	r6, r7
    b562:	e7ee      	b.n	b542 <bt_gatt_service_register+0xbe>
		if (!attrs->handle) {
    b564:	f8b8 1010 	ldrh.w	r1, [r8, #16]
    b568:	bb41      	cbnz	r1, b5bc <bt_gatt_service_register+0x138>
			attrs->handle = ++handle;
    b56a:	1c79      	adds	r1, r7, #1
    b56c:	b289      	uxth	r1, r1
    b56e:	f8a8 1010 	strh.w	r1, [r8, #16]
	for (; attrs && count; attrs++, count--) {
    b572:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    b576:	f108 0814 	add.w	r8, r8, #20
    b57a:	fa1f f989 	uxth.w	r9, r9
    b57e:	460f      	mov	r7, r1
    b580:	f1b8 0f00 	cmp.w	r8, #0
    b584:	d002      	beq.n	b58c <bt_gatt_service_register+0x108>
    b586:	f1b9 0f00 	cmp.w	r9, #0
    b58a:	d1eb      	bne.n	b564 <bt_gatt_service_register+0xe0>
	if (last_handle == 0 || svc->attrs[0].handle > last_handle) {
    b58c:	682f      	ldr	r7, [r5, #0]
    b58e:	8a38      	ldrh	r0, [r7, #16]
    b590:	b10e      	cbz	r6, b596 <bt_gatt_service_register+0x112>
    b592:	42b0      	cmp	r0, r6
    b594:	d92e      	bls.n	b5f4 <bt_gatt_service_register+0x170>
	parent->next = child;
    b596:	2200      	movs	r2, #0
		sys_slist_append(&db, &svc->node);
    b598:	f105 0308 	add.w	r3, r5, #8
    b59c:	60aa      	str	r2, [r5, #8]
Z_GENLIST_APPEND(slist, snode)
    b59e:	6862      	ldr	r2, [r4, #4]
    b5a0:	2a00      	cmp	r2, #0
    b5a2:	d145      	bne.n	b630 <bt_gatt_service_register+0x1ac>
	list->head = node;
    b5a4:	e9c4 3300 	strd	r3, r3, [r4]
		    svc->attrs[svc->attr_count - 1].handle);
    b5a8:	686b      	ldr	r3, [r5, #4]
	sc_indicate(svc->attrs[0].handle,
    b5aa:	2214      	movs	r2, #20
    b5ac:	fb02 7303 	mla	r3, r2, r3, r7
    b5b0:	f833 1c04 	ldrh.w	r1, [r3, #-4]
    b5b4:	f7ff fdb2 	bl	b11c <sc_indicate>
	return 0;
    b5b8:	2000      	movs	r0, #0
    b5ba:	e7a9      	b.n	b510 <bt_gatt_service_register+0x8c>
		} else if (attrs->handle > handle) {
    b5bc:	42b9      	cmp	r1, r7
    b5be:	d8d8      	bhi.n	b572 <bt_gatt_service_register+0xee>
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
    b5c0:	ab01      	add	r3, sp, #4
    b5c2:	465a      	mov	r2, fp
    b5c4:	4608      	mov	r0, r1
	const struct bt_gatt_attr *attr = NULL;
    b5c6:	f8cd a004 	str.w	sl, [sp, #4]
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
    b5ca:	f01b fcab 	bl	26f24 <bt_gatt_foreach_attr>
	return attr;
    b5ce:	9b01      	ldr	r3, [sp, #4]
		} else if (find_attr(attrs->handle)) {
    b5d0:	b173      	cbz	r3, b5f0 <bt_gatt_service_register+0x16c>
    b5d2:	4b27      	ldr	r3, [pc, #156]	; (b670 <bt_gatt_service_register+0x1ec>)
    b5d4:	4a27      	ldr	r2, [pc, #156]	; (b674 <bt_gatt_service_register+0x1f0>)
			BT_ERR("Unable to register handle 0x%04x",
    b5d6:	4828      	ldr	r0, [pc, #160]	; (b678 <bt_gatt_service_register+0x1f4>)
    b5d8:	f8b8 1010 	ldrh.w	r1, [r8, #16]
    b5dc:	1ad2      	subs	r2, r2, r3
    b5de:	08d2      	lsrs	r2, r2, #3
    b5e0:	0192      	lsls	r2, r2, #6
    b5e2:	f042 0201 	orr.w	r2, r2, #1
    b5e6:	f018 fcfa 	bl	23fde <log_1>
			return -EINVAL;
    b5ea:	f06f 0015 	mvn.w	r0, #21
    b5ee:	e78f      	b.n	b510 <bt_gatt_service_register+0x8c>
    b5f0:	4639      	mov	r1, r7
    b5f2:	e7be      	b.n	b572 <bt_gatt_service_register+0xee>
	SYS_SLIST_FOR_EACH_CONTAINER(&db, tmp, node) {
    b5f4:	6821      	ldr	r1, [r4, #0]
    b5f6:	2900      	cmp	r1, #0
    b5f8:	d0d6      	beq.n	b5a8 <bt_gatt_service_register+0x124>
    b5fa:	f1a1 0308 	sub.w	r3, r1, #8
    b5fe:	2200      	movs	r2, #0
    b600:	2b00      	cmp	r3, #0
    b602:	d0d1      	beq.n	b5a8 <bt_gatt_service_register+0x124>
		if (tmp->attrs[0].handle > svc->attrs[0].handle) {
    b604:	681e      	ldr	r6, [r3, #0]
    b606:	8a36      	ldrh	r6, [r6, #16]
    b608:	4286      	cmp	r6, r0
    b60a:	d914      	bls.n	b636 <bt_gatt_service_register+0x1b2>
			if (prev) {
    b60c:	f105 0308 	add.w	r3, r5, #8
    b610:	b112      	cbz	r2, b618 <bt_gatt_service_register+0x194>
Z_GENLIST_INSERT(slist, snode)
    b612:	f112 0f08 	cmn.w	r2, #8
    b616:	d105      	bne.n	b624 <bt_gatt_service_register+0x1a0>
Z_GENLIST_PREPEND(slist, snode)
    b618:	6862      	ldr	r2, [r4, #4]
	parent->next = child;
    b61a:	60a9      	str	r1, [r5, #8]
	list->head = node;
    b61c:	6023      	str	r3, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
    b61e:	2a00      	cmp	r2, #0
    b620:	d1c2      	bne.n	b5a8 <bt_gatt_service_register+0x124>
    b622:	e006      	b.n	b632 <bt_gatt_service_register+0x1ae>
Z_GENLIST_INSERT(slist, snode)
    b624:	6891      	ldr	r1, [r2, #8]
	parent->next = child;
    b626:	60a9      	str	r1, [r5, #8]
Z_GENLIST_INSERT(slist, snode)
    b628:	2900      	cmp	r1, #0
    b62a:	d0b8      	beq.n	b59e <bt_gatt_service_register+0x11a>
	parent->next = child;
    b62c:	6093      	str	r3, [r2, #8]
	if (err < 0) {
    b62e:	e7bb      	b.n	b5a8 <bt_gatt_service_register+0x124>
    b630:	6013      	str	r3, [r2, #0]
	list->tail = node;
    b632:	6063      	str	r3, [r4, #4]
    b634:	e7b8      	b.n	b5a8 <bt_gatt_service_register+0x124>
Z_GENLIST_PEEK_NEXT(slist, snode)
    b636:	f113 0f08 	cmn.w	r3, #8
    b63a:	d0b5      	beq.n	b5a8 <bt_gatt_service_register+0x124>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    b63c:	689e      	ldr	r6, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, tmp, node) {
    b63e:	2e00      	cmp	r6, #0
    b640:	d0b2      	beq.n	b5a8 <bt_gatt_service_register+0x124>
    b642:	461a      	mov	r2, r3
    b644:	f1a6 0308 	sub.w	r3, r6, #8
    b648:	e7da      	b.n	b600 <bt_gatt_service_register+0x17c>
	handle = last->attrs[last->attr_count - 1].handle;
    b64a:	681b      	ldr	r3, [r3, #0]
    b64c:	deff      	udf	#255	; 0xff
    b64e:	bf00      	nop
    b650:	0002cb5b 	.word	0x0002cb5b
    b654:	0002c9fb 	.word	0x0002c9fb
    b658:	0002a5e8 	.word	0x0002a5e8
    b65c:	0002cb5f 	.word	0x0002cb5f
    b660:	0002cb75 	.word	0x0002cb75
    b664:	0002cb80 	.word	0x0002cb80
    b668:	200006b4 	.word	0x200006b4
    b66c:	20001e7c 	.word	0x20001e7c
    b670:	00029830 	.word	0x00029830
    b674:	000298e8 	.word	0x000298e8
    b678:	0002cb90 	.word	0x0002cb90
    b67c:	00026ca5 	.word	0x00026ca5

0000b680 <ccc_set_direct>:
{
    b680:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    b684:	b0b9      	sub	sp, #228	; 0xe4
    b686:	4688      	mov	r8, r1
    b688:	4614      	mov	r4, r2
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
    b68a:	4939      	ldr	r1, [pc, #228]	; (b770 <ccc_set_direct+0xf0>)
    b68c:	9840      	ldr	r0, [sp, #256]	; 0x100
    b68e:	466a      	mov	r2, sp
{
    b690:	461f      	mov	r7, r3
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
    b692:	f019 f851 	bl	24738 <settings_name_steq>
    b696:	b978      	cbnz	r0, b6b8 <ccc_set_direct+0x38>
    b698:	4b36      	ldr	r3, [pc, #216]	; (b774 <ccc_set_direct+0xf4>)
    b69a:	4937      	ldr	r1, [pc, #220]	; (b778 <ccc_set_direct+0xf8>)
			BT_ERR("Invalid key");
    b69c:	4837      	ldr	r0, [pc, #220]	; (b77c <ccc_set_direct+0xfc>)
    b69e:	1ac9      	subs	r1, r1, r3
    b6a0:	08c9      	lsrs	r1, r1, #3
    b6a2:	0189      	lsls	r1, r1, #6
    b6a4:	f041 0101 	orr.w	r1, r1, #1
    b6a8:	f018 fc8c 	bl	23fc4 <log_0>
			return -EINVAL;
    b6ac:	f06f 0515 	mvn.w	r5, #21
}
    b6b0:	4628      	mov	r0, r5
    b6b2:	b039      	add	sp, #228	; 0xe4
    b6b4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return ccc_set(name, len, read_cb, cb_arg);
    b6b8:	9e00      	ldr	r6, [sp, #0]
		settings_name_next(name, &next);
    b6ba:	a901      	add	r1, sp, #4
    b6bc:	4630      	mov	r0, r6
    b6be:	f019 f85e 	bl	2477e <settings_name_next>
		if (!name) {
    b6c2:	b96e      	cbnz	r6, b6e0 <ccc_set_direct+0x60>
    b6c4:	492c      	ldr	r1, [pc, #176]	; (b778 <ccc_set_direct+0xf8>)
    b6c6:	4b2b      	ldr	r3, [pc, #172]	; (b774 <ccc_set_direct+0xf4>)
			BT_ERR("Insufficient number of arguments");
    b6c8:	482d      	ldr	r0, [pc, #180]	; (b780 <ccc_set_direct+0x100>)
    b6ca:	1ac9      	subs	r1, r1, r3
    b6cc:	08c9      	lsrs	r1, r1, #3
    b6ce:	0189      	lsls	r1, r1, #6
    b6d0:	f041 0101 	orr.w	r1, r1, #1
    b6d4:	f018 fc76 	bl	23fc4 <log_0>
			return -EINVAL;
    b6d8:	f06f 0415 	mvn.w	r4, #21
			return -EINVAL;
    b6dc:	4625      	mov	r5, r4
    b6de:	e7e7      	b.n	b6b0 <ccc_set_direct+0x30>
		} else if (!next) {
    b6e0:	9801      	ldr	r0, [sp, #4]
    b6e2:	b9c8      	cbnz	r0, b718 <ccc_set_direct+0x98>
		err = bt_settings_decode_key(name, &addr);
    b6e4:	f10d 0908 	add.w	r9, sp, #8
			load.addr_with_id.id = strtol(next, NULL, 10);
    b6e8:	f88d 0014 	strb.w	r0, [sp, #20]
		err = bt_settings_decode_key(name, &addr);
    b6ec:	4649      	mov	r1, r9
    b6ee:	4630      	mov	r0, r6
    b6f0:	f01a fbd9 	bl	25ea6 <bt_settings_decode_key>
		if (err) {
    b6f4:	4605      	mov	r5, r0
    b6f6:	b1a0      	cbz	r0, b722 <ccc_set_direct+0xa2>
    b6f8:	4a1e      	ldr	r2, [pc, #120]	; (b774 <ccc_set_direct+0xf4>)
    b6fa:	4c1f      	ldr	r4, [pc, #124]	; (b778 <ccc_set_direct+0xf8>)
			BT_ERR("Unable to decode address %s", log_strdup(name));
    b6fc:	4630      	mov	r0, r6
    b6fe:	1aa4      	subs	r4, r4, r2
    b700:	08e4      	lsrs	r4, r4, #3
    b702:	f7f6 ff6d 	bl	25e0 <log_strdup>
    b706:	01a4      	lsls	r4, r4, #6
    b708:	f044 0401 	orr.w	r4, r4, #1
    b70c:	4601      	mov	r1, r0
    b70e:	4622      	mov	r2, r4
    b710:	481c      	ldr	r0, [pc, #112]	; (b784 <ccc_set_direct+0x104>)
    b712:	f018 fc64 	bl	23fde <log_1>
    b716:	e7df      	b.n	b6d8 <ccc_set_direct+0x58>
			load.addr_with_id.id = strtol(next, NULL, 10);
    b718:	220a      	movs	r2, #10
    b71a:	2100      	movs	r1, #0
    b71c:	f01a f9f1 	bl	25b02 <strtol>
    b720:	e7e0      	b.n	b6e4 <ccc_set_direct+0x64>
		load.addr_with_id.addr = &addr;
    b722:	f8cd 9010 	str.w	r9, [sp, #16]
		if (len_rd) {
    b726:	f1b8 0f00 	cmp.w	r8, #0
    b72a:	d01d      	beq.n	b768 <ccc_set_direct+0xe8>
			len = read_cb(cb_arg, ccc_store, sizeof(ccc_store));
    b72c:	ae08      	add	r6, sp, #32
    b72e:	22c0      	movs	r2, #192	; 0xc0
    b730:	4631      	mov	r1, r6
    b732:	4638      	mov	r0, r7
    b734:	47a0      	blx	r4
			if (len < 0) {
    b736:	1e04      	subs	r4, r0, #0
    b738:	da0b      	bge.n	b752 <ccc_set_direct+0xd2>
    b73a:	4b0e      	ldr	r3, [pc, #56]	; (b774 <ccc_set_direct+0xf4>)
    b73c:	4a0e      	ldr	r2, [pc, #56]	; (b778 <ccc_set_direct+0xf8>)
				BT_ERR("Failed to decode value (err %d)", len);
    b73e:	4812      	ldr	r0, [pc, #72]	; (b788 <ccc_set_direct+0x108>)
    b740:	1ad2      	subs	r2, r2, r3
    b742:	08d2      	lsrs	r2, r2, #3
    b744:	0192      	lsls	r2, r2, #6
    b746:	f042 0201 	orr.w	r2, r2, #1
    b74a:	4621      	mov	r1, r4
    b74c:	f018 fc47 	bl	23fde <log_1>
				return len;
    b750:	e7c4      	b.n	b6dc <ccc_set_direct+0x5c>
			load.count = len / sizeof(*ccc_store);
    b752:	08a4      	lsrs	r4, r4, #2
			load.entry = ccc_store;
    b754:	9606      	str	r6, [sp, #24]
			load.count = len / sizeof(*ccc_store);
    b756:	9407      	str	r4, [sp, #28]
		bt_gatt_foreach_attr(0x0001, 0xffff, ccc_load, &load);
    b758:	4a0c      	ldr	r2, [pc, #48]	; (b78c <ccc_set_direct+0x10c>)
    b75a:	ab04      	add	r3, sp, #16
    b75c:	f64f 71ff 	movw	r1, #65535	; 0xffff
    b760:	2001      	movs	r0, #1
    b762:	f01b fbdf 	bl	26f24 <bt_gatt_foreach_attr>
	return 0;
    b766:	e7a3      	b.n	b6b0 <ccc_set_direct+0x30>
			load.count = 0;
    b768:	e9cd 0006 	strd	r0, r0, [sp, #24]
    b76c:	e7f4      	b.n	b758 <ccc_set_direct+0xd8>
    b76e:	bf00      	nop
    b770:	0002cbb1 	.word	0x0002cbb1
    b774:	00029830 	.word	0x00029830
    b778:	000298e8 	.word	0x000298e8
    b77c:	0002cbb8 	.word	0x0002cbb8
    b780:	0002ba0e 	.word	0x0002ba0e
    b784:	0002cafd 	.word	0x0002cafd
    b788:	0002cb3b 	.word	0x0002cb3b
    b78c:	0000ac29 	.word	0x0000ac29

0000b790 <bt_gatt_notify_cb>:
{
    b790:	b5f0      	push	{r4, r5, r6, r7, lr}
    b792:	4605      	mov	r5, r0
    b794:	b08b      	sub	sp, #44	; 0x2c
	__ASSERT(params, "invalid parameters\n");
    b796:	460e      	mov	r6, r1
    b798:	b971      	cbnz	r1, b7b8 <bt_gatt_notify_cb+0x28>
    b79a:	4948      	ldr	r1, [pc, #288]	; (b8bc <bt_gatt_notify_cb+0x12c>)
    b79c:	4a48      	ldr	r2, [pc, #288]	; (b8c0 <bt_gatt_notify_cb+0x130>)
    b79e:	4849      	ldr	r0, [pc, #292]	; (b8c4 <bt_gatt_notify_cb+0x134>)
    b7a0:	f240 731c 	movw	r3, #1820	; 0x71c
    b7a4:	f018 fb9d 	bl	23ee2 <printk>
    b7a8:	4847      	ldr	r0, [pc, #284]	; (b8c8 <bt_gatt_notify_cb+0x138>)
    b7aa:	f018 fb9a 	bl	23ee2 <printk>
    b7ae:	4844      	ldr	r0, [pc, #272]	; (b8c0 <bt_gatt_notify_cb+0x130>)
    b7b0:	f240 711c 	movw	r1, #1820	; 0x71c
    b7b4:	f018 fbd8 	bl	23f68 <assert_post_action>
	__ASSERT(params->attr, "invalid parameters\n");
    b7b8:	6873      	ldr	r3, [r6, #4]
    b7ba:	b973      	cbnz	r3, b7da <bt_gatt_notify_cb+0x4a>
    b7bc:	4943      	ldr	r1, [pc, #268]	; (b8cc <bt_gatt_notify_cb+0x13c>)
    b7be:	4a40      	ldr	r2, [pc, #256]	; (b8c0 <bt_gatt_notify_cb+0x130>)
    b7c0:	4840      	ldr	r0, [pc, #256]	; (b8c4 <bt_gatt_notify_cb+0x134>)
    b7c2:	f240 731d 	movw	r3, #1821	; 0x71d
    b7c6:	f018 fb8c 	bl	23ee2 <printk>
    b7ca:	483f      	ldr	r0, [pc, #252]	; (b8c8 <bt_gatt_notify_cb+0x138>)
    b7cc:	f018 fb89 	bl	23ee2 <printk>
    b7d0:	483b      	ldr	r0, [pc, #236]	; (b8c0 <bt_gatt_notify_cb+0x130>)
    b7d2:	f240 711d 	movw	r1, #1821	; 0x71d
    b7d6:	f018 fbc7 	bl	23f68 <assert_post_action>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    b7da:	f3bf 8f5b 	dmb	ish
    b7de:	4b3c      	ldr	r3, [pc, #240]	; (b8d0 <bt_gatt_notify_cb+0x140>)
    b7e0:	681b      	ldr	r3, [r3, #0]
    b7e2:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    b7e6:	079a      	lsls	r2, r3, #30
    b7e8:	d562      	bpl.n	b8b0 <bt_gatt_notify_cb+0x120>
	attr = params->attr;
    b7ea:	6870      	ldr	r0, [r6, #4]
    b7ec:	9005      	str	r0, [sp, #20]
	if (conn && conn->state != BT_CONN_CONNECTED) {
    b7ee:	b115      	cbz	r5, b7f6 <bt_gatt_notify_cb+0x66>
    b7f0:	7aab      	ldrb	r3, [r5, #10]
    b7f2:	2b06      	cmp	r3, #6
    b7f4:	d15f      	bne.n	b8b6 <bt_gatt_notify_cb+0x126>
	handle = attr->handle ? : find_static_attr(attr);
    b7f6:	8a04      	ldrh	r4, [r0, #16]
    b7f8:	b93c      	cbnz	r4, b80a <bt_gatt_notify_cb+0x7a>
    b7fa:	f7ff f8f3 	bl	a9e4 <find_static_attr>
	if (!handle) {
    b7fe:	4604      	mov	r4, r0
    b800:	b918      	cbnz	r0, b80a <bt_gatt_notify_cb+0x7a>
		return -ENOENT;
    b802:	f06f 0001 	mvn.w	r0, #1
}
    b806:	b00b      	add	sp, #44	; 0x2c
    b808:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (params->uuid) {
    b80a:	6832      	ldr	r2, [r6, #0]
    b80c:	b1b2      	cbz	r2, b83c <bt_gatt_notify_cb+0xac>
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    b80e:	a905      	add	r1, sp, #20
    b810:	9102      	str	r1, [sp, #8]
    b812:	4930      	ldr	r1, [pc, #192]	; (b8d4 <bt_gatt_notify_cb+0x144>)
    b814:	9101      	str	r1, [sp, #4]
    b816:	2101      	movs	r1, #1
		attr = NULL;
    b818:	2300      	movs	r3, #0
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    b81a:	9100      	str	r1, [sp, #0]
    b81c:	4620      	mov	r0, r4
    b81e:	f64f 71ff 	movw	r1, #65535	; 0xffff
		attr = NULL;
    b822:	9305      	str	r3, [sp, #20]
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    b824:	f7ff fd64 	bl	b2f0 <bt_gatt_foreach_attr_type>
		if (!attr) {
    b828:	9805      	ldr	r0, [sp, #20]
    b82a:	2800      	cmp	r0, #0
    b82c:	d0e9      	beq.n	b802 <bt_gatt_notify_cb+0x72>
		handle = attr->handle ? : find_static_attr(attr);
    b82e:	8a04      	ldrh	r4, [r0, #16]
    b830:	b924      	cbnz	r4, b83c <bt_gatt_notify_cb+0xac>
    b832:	f7ff f8d7 	bl	a9e4 <find_static_attr>
		if (!handle) {
    b836:	4604      	mov	r4, r0
    b838:	2800      	cmp	r0, #0
    b83a:	d0e2      	beq.n	b802 <bt_gatt_notify_cb+0x72>
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC)) {
    b83c:	9b05      	ldr	r3, [sp, #20]
    b83e:	af07      	add	r7, sp, #28
    b840:	6818      	ldr	r0, [r3, #0]
    b842:	2300      	movs	r3, #0
    b844:	f88d 301c 	strb.w	r3, [sp, #28]
    b848:	4639      	mov	r1, r7
    b84a:	f642 0303 	movw	r3, #10243	; 0x2803
    b84e:	f8ad 301e 	strh.w	r3, [sp, #30]
    b852:	f01a fcf9 	bl	26248 <bt_uuid_cmp>
    b856:	b950      	cbnz	r0, b86e <bt_gatt_notify_cb+0xde>
		struct bt_gatt_chrc *chrc = attr->user_data;
    b858:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_NOTIFY)) {
    b85a:	68c3      	ldr	r3, [r0, #12]
    b85c:	799b      	ldrb	r3, [r3, #6]
    b85e:	06db      	lsls	r3, r3, #27
    b860:	d402      	bmi.n	b868 <bt_gatt_notify_cb+0xd8>
			return -EINVAL;
    b862:	f06f 0015 	mvn.w	r0, #21
    b866:	e7ce      	b.n	b806 <bt_gatt_notify_cb+0x76>
		handle = bt_gatt_attr_value_handle(attr);
    b868:	f7ff fd2a 	bl	b2c0 <bt_gatt_attr_value_handle>
    b86c:	4604      	mov	r4, r0
	if (conn) {
    b86e:	b12d      	cbz	r5, b87c <bt_gatt_notify_cb+0xec>
		return gatt_notify(conn, handle, params);
    b870:	4632      	mov	r2, r6
    b872:	4621      	mov	r1, r4
    b874:	4628      	mov	r0, r5
    b876:	f7ff f8f5 	bl	aa64 <gatt_notify>
    b87a:	e7c4      	b.n	b806 <bt_gatt_notify_cb+0x76>
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    b87c:	f642 1202 	movw	r2, #10498	; 0x2902
	data.err = -ENOTCONN;
    b880:	f06f 0338 	mvn.w	r3, #56	; 0x38
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    b884:	f8ad 201a 	strh.w	r2, [sp, #26]
    b888:	4a13      	ldr	r2, [pc, #76]	; (b8d8 <bt_gatt_notify_cb+0x148>)
	data.err = -ENOTCONN;
    b88a:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_NOTIFY;
    b88c:	2301      	movs	r3, #1
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    b88e:	e9cd 3200 	strd	r3, r2, [sp]
	data.type = BT_GATT_CCC_NOTIFY;
    b892:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    b896:	4620      	mov	r0, r4
    b898:	9702      	str	r7, [sp, #8]
    b89a:	462b      	mov	r3, r5
    b89c:	aa06      	add	r2, sp, #24
    b89e:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.nfy_params = params;
    b8a2:	9609      	str	r6, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    b8a4:	f88d 5018 	strb.w	r5, [sp, #24]
    b8a8:	f7ff fd22 	bl	b2f0 <bt_gatt_foreach_attr_type>
	return data.err;
    b8ac:	9807      	ldr	r0, [sp, #28]
    b8ae:	e7aa      	b.n	b806 <bt_gatt_notify_cb+0x76>
		return -EAGAIN;
    b8b0:	f06f 000a 	mvn.w	r0, #10
    b8b4:	e7a7      	b.n	b806 <bt_gatt_notify_cb+0x76>
		return -ENOTCONN;
    b8b6:	f06f 0038 	mvn.w	r0, #56	; 0x38
    b8ba:	e7a4      	b.n	b806 <bt_gatt_notify_cb+0x76>
    b8bc:	0002cbc4 	.word	0x0002cbc4
    b8c0:	0002c9fb 	.word	0x0002c9fb
    b8c4:	0002a5e8 	.word	0x0002a5e8
    b8c8:	0002cb5f 	.word	0x0002cb5f
    b8cc:	0002cbcb 	.word	0x0002cbcb
    b8d0:	200068ec 	.word	0x200068ec
    b8d4:	00026d11 	.word	0x00026d11
    b8d8:	0000ae49 	.word	0x0000ae49

0000b8dc <bt_gatt_indicate>:
{
    b8dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    b8de:	4605      	mov	r5, r0
    b8e0:	b08b      	sub	sp, #44	; 0x2c
	__ASSERT(params, "invalid parameters\n");
    b8e2:	460e      	mov	r6, r1
    b8e4:	b971      	cbnz	r1, b904 <bt_gatt_indicate+0x28>
    b8e6:	4949      	ldr	r1, [pc, #292]	; (ba0c <bt_gatt_indicate+0x130>)
    b8e8:	4a49      	ldr	r2, [pc, #292]	; (ba10 <bt_gatt_indicate+0x134>)
    b8ea:	484a      	ldr	r0, [pc, #296]	; (ba14 <bt_gatt_indicate+0x138>)
    b8ec:	f240 735e 	movw	r3, #1886	; 0x75e
    b8f0:	f018 faf7 	bl	23ee2 <printk>
    b8f4:	4848      	ldr	r0, [pc, #288]	; (ba18 <bt_gatt_indicate+0x13c>)
    b8f6:	f018 faf4 	bl	23ee2 <printk>
    b8fa:	4845      	ldr	r0, [pc, #276]	; (ba10 <bt_gatt_indicate+0x134>)
    b8fc:	f240 715e 	movw	r1, #1886	; 0x75e
    b900:	f018 fb32 	bl	23f68 <assert_post_action>
	__ASSERT(params->attr, "invalid parameters\n");
    b904:	6873      	ldr	r3, [r6, #4]
    b906:	b973      	cbnz	r3, b926 <bt_gatt_indicate+0x4a>
    b908:	4944      	ldr	r1, [pc, #272]	; (ba1c <bt_gatt_indicate+0x140>)
    b90a:	4a41      	ldr	r2, [pc, #260]	; (ba10 <bt_gatt_indicate+0x134>)
    b90c:	4841      	ldr	r0, [pc, #260]	; (ba14 <bt_gatt_indicate+0x138>)
    b90e:	f240 735f 	movw	r3, #1887	; 0x75f
    b912:	f018 fae6 	bl	23ee2 <printk>
    b916:	4840      	ldr	r0, [pc, #256]	; (ba18 <bt_gatt_indicate+0x13c>)
    b918:	f018 fae3 	bl	23ee2 <printk>
    b91c:	483c      	ldr	r0, [pc, #240]	; (ba10 <bt_gatt_indicate+0x134>)
    b91e:	f240 715f 	movw	r1, #1887	; 0x75f
    b922:	f018 fb21 	bl	23f68 <assert_post_action>
    b926:	f3bf 8f5b 	dmb	ish
    b92a:	4b3d      	ldr	r3, [pc, #244]	; (ba20 <bt_gatt_indicate+0x144>)
    b92c:	681b      	ldr	r3, [r3, #0]
    b92e:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    b932:	079a      	lsls	r2, r3, #30
    b934:	d563      	bpl.n	b9fe <bt_gatt_indicate+0x122>
	attr = params->attr;
    b936:	6870      	ldr	r0, [r6, #4]
    b938:	9005      	str	r0, [sp, #20]
	if (conn && conn->state != BT_CONN_CONNECTED) {
    b93a:	b115      	cbz	r5, b942 <bt_gatt_indicate+0x66>
    b93c:	7aab      	ldrb	r3, [r5, #10]
    b93e:	2b06      	cmp	r3, #6
    b940:	d160      	bne.n	ba04 <bt_gatt_indicate+0x128>
	handle = attr->handle ? : find_static_attr(attr);
    b942:	8a04      	ldrh	r4, [r0, #16]
    b944:	b93c      	cbnz	r4, b956 <bt_gatt_indicate+0x7a>
    b946:	f7ff f84d 	bl	a9e4 <find_static_attr>
	if (!handle) {
    b94a:	4604      	mov	r4, r0
    b94c:	b918      	cbnz	r0, b956 <bt_gatt_indicate+0x7a>
		return -ENOENT;
    b94e:	f06f 0001 	mvn.w	r0, #1
}
    b952:	b00b      	add	sp, #44	; 0x2c
    b954:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (params->uuid) {
    b956:	6832      	ldr	r2, [r6, #0]
    b958:	b1b2      	cbz	r2, b988 <bt_gatt_indicate+0xac>
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    b95a:	a905      	add	r1, sp, #20
    b95c:	9102      	str	r1, [sp, #8]
    b95e:	4931      	ldr	r1, [pc, #196]	; (ba24 <bt_gatt_indicate+0x148>)
    b960:	9101      	str	r1, [sp, #4]
    b962:	2101      	movs	r1, #1
		attr = NULL;
    b964:	2300      	movs	r3, #0
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    b966:	9100      	str	r1, [sp, #0]
    b968:	4620      	mov	r0, r4
    b96a:	f64f 71ff 	movw	r1, #65535	; 0xffff
		attr = NULL;
    b96e:	9305      	str	r3, [sp, #20]
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
    b970:	f7ff fcbe 	bl	b2f0 <bt_gatt_foreach_attr_type>
		if (!attr) {
    b974:	9805      	ldr	r0, [sp, #20]
    b976:	2800      	cmp	r0, #0
    b978:	d0e9      	beq.n	b94e <bt_gatt_indicate+0x72>
		handle = attr->handle ? : find_static_attr(attr);
    b97a:	8a04      	ldrh	r4, [r0, #16]
    b97c:	b924      	cbnz	r4, b988 <bt_gatt_indicate+0xac>
    b97e:	f7ff f831 	bl	a9e4 <find_static_attr>
		if (!handle) {
    b982:	4604      	mov	r4, r0
    b984:	2800      	cmp	r0, #0
    b986:	d0e2      	beq.n	b94e <bt_gatt_indicate+0x72>
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC)) {
    b988:	9b05      	ldr	r3, [sp, #20]
    b98a:	af07      	add	r7, sp, #28
    b98c:	6818      	ldr	r0, [r3, #0]
    b98e:	2300      	movs	r3, #0
    b990:	f88d 301c 	strb.w	r3, [sp, #28]
    b994:	4639      	mov	r1, r7
    b996:	f642 0303 	movw	r3, #10243	; 0x2803
    b99a:	f8ad 301e 	strh.w	r3, [sp, #30]
    b99e:	f01a fc53 	bl	26248 <bt_uuid_cmp>
    b9a2:	b950      	cbnz	r0, b9ba <bt_gatt_indicate+0xde>
		struct bt_gatt_chrc *chrc = attr->user_data;
    b9a4:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
    b9a6:	68c3      	ldr	r3, [r0, #12]
    b9a8:	799b      	ldrb	r3, [r3, #6]
    b9aa:	069b      	lsls	r3, r3, #26
    b9ac:	d402      	bmi.n	b9b4 <bt_gatt_indicate+0xd8>
			return -EINVAL;
    b9ae:	f06f 0015 	mvn.w	r0, #21
    b9b2:	e7ce      	b.n	b952 <bt_gatt_indicate+0x76>
		handle = bt_gatt_attr_value_handle(attr);
    b9b4:	f7ff fc84 	bl	b2c0 <bt_gatt_attr_value_handle>
    b9b8:	4604      	mov	r4, r0
	if (conn) {
    b9ba:	b12d      	cbz	r5, b9c8 <bt_gatt_indicate+0xec>
		return gatt_indicate(conn, handle, params);
    b9bc:	4632      	mov	r2, r6
    b9be:	4621      	mov	r1, r4
    b9c0:	4628      	mov	r0, r5
    b9c2:	f7ff f8c5 	bl	ab50 <gatt_indicate>
    b9c6:	e7c4      	b.n	b952 <bt_gatt_indicate+0x76>
	data.err = -ENOTCONN;
    b9c8:	f06f 0338 	mvn.w	r3, #56	; 0x38
    b9cc:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
    b9ce:	2302      	movs	r3, #2
    b9d0:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    b9d4:	f642 1302 	movw	r3, #10498	; 0x2902
    b9d8:	f8ad 301a 	strh.w	r3, [sp, #26]
    b9dc:	4b12      	ldr	r3, [pc, #72]	; (ba28 <bt_gatt_indicate+0x14c>)
    b9de:	9301      	str	r3, [sp, #4]
    b9e0:	2301      	movs	r3, #1
    b9e2:	9300      	str	r3, [sp, #0]
    b9e4:	4620      	mov	r0, r4
    b9e6:	9702      	str	r7, [sp, #8]
    b9e8:	462b      	mov	r3, r5
    b9ea:	aa06      	add	r2, sp, #24
    b9ec:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.ind_params = params;
    b9f0:	9609      	str	r6, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
    b9f2:	f88d 5018 	strb.w	r5, [sp, #24]
    b9f6:	f7ff fc7b 	bl	b2f0 <bt_gatt_foreach_attr_type>
	return data.err;
    b9fa:	9807      	ldr	r0, [sp, #28]
    b9fc:	e7a9      	b.n	b952 <bt_gatt_indicate+0x76>
		return -EAGAIN;
    b9fe:	f06f 000a 	mvn.w	r0, #10
    ba02:	e7a6      	b.n	b952 <bt_gatt_indicate+0x76>
		return -ENOTCONN;
    ba04:	f06f 0038 	mvn.w	r0, #56	; 0x38
    ba08:	e7a3      	b.n	b952 <bt_gatt_indicate+0x76>
    ba0a:	bf00      	nop
    ba0c:	0002cbc4 	.word	0x0002cbc4
    ba10:	0002c9fb 	.word	0x0002c9fb
    ba14:	0002a5e8 	.word	0x0002a5e8
    ba18:	0002cb5f 	.word	0x0002cb5f
    ba1c:	0002cbcb 	.word	0x0002cbcb
    ba20:	200068ec 	.word	0x200068ec
    ba24:	00026d11 	.word	0x00026d11
    ba28:	0000ae49 	.word	0x0000ae49

0000ba2c <sc_process>:
{
    ba2c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ba2e:	f3bf 8f5b 	dmb	ish
    ba32:	6a03      	ldr	r3, [r0, #32]
    ba34:	f3bf 8f5b 	dmb	ish
	__ASSERT(!atomic_test_bit(sc->flags, SC_INDICATE_PENDING),
    ba38:	079b      	lsls	r3, r3, #30
{
    ba3a:	4604      	mov	r4, r0
	__ASSERT(!atomic_test_bit(sc->flags, SC_INDICATE_PENDING),
    ba3c:	f100 0520 	add.w	r5, r0, #32
    ba40:	d50e      	bpl.n	ba60 <sc_process+0x34>
    ba42:	4921      	ldr	r1, [pc, #132]	; (bac8 <sc_process+0x9c>)
    ba44:	4a21      	ldr	r2, [pc, #132]	; (bacc <sc_process+0xa0>)
    ba46:	4822      	ldr	r0, [pc, #136]	; (bad0 <sc_process+0xa4>)
    ba48:	f240 3373 	movw	r3, #883	; 0x373
    ba4c:	f018 fa49 	bl	23ee2 <printk>
    ba50:	4820      	ldr	r0, [pc, #128]	; (bad4 <sc_process+0xa8>)
    ba52:	f018 fa46 	bl	23ee2 <printk>
    ba56:	481d      	ldr	r0, [pc, #116]	; (bacc <sc_process+0xa0>)
    ba58:	f240 3173 	movw	r1, #883	; 0x373
    ba5c:	f018 fa84 	bl	23f68 <assert_post_action>
	sc_range[0] = sys_cpu_to_le16(sc->start);
    ba60:	f854 3c04 	ldr.w	r3, [r4, #-4]
    ba64:	9301      	str	r3, [sp, #4]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    ba66:	f3bf 8f5b 	dmb	ish
    ba6a:	e855 3f00 	ldrex	r3, [r5]
    ba6e:	f023 0301 	bic.w	r3, r3, #1
    ba72:	e845 3200 	strex	r2, r3, [r5]
    ba76:	2a00      	cmp	r2, #0
    ba78:	d1f7      	bne.n	ba6a <sc_process+0x3e>
    ba7a:	f3bf 8f5b 	dmb	ish
	sc->params.attr = &_1_gatt_svc.attrs[2];
    ba7e:	4b16      	ldr	r3, [pc, #88]	; (bad8 <sc_process+0xac>)
    ba80:	f844 3c14 	str.w	r3, [r4, #-20]
	sc->params.func = sc_indicate_rsp;
    ba84:	4b15      	ldr	r3, [pc, #84]	; (badc <sc_process+0xb0>)
    ba86:	f844 3c10 	str.w	r3, [r4, #-16]
	sc->params.data = &sc_range[0];
    ba8a:	ab01      	add	r3, sp, #4
	sc->start = 0U;
    ba8c:	2000      	movs	r0, #0
	sc->params.data = &sc_range[0];
    ba8e:	f844 3c0c 	str.w	r3, [r4, #-12]
	sc->params.len = sizeof(sc_range);
    ba92:	2304      	movs	r3, #4
	sc->start = 0U;
    ba94:	f824 0c04 	strh.w	r0, [r4, #-4]
	sc->end = 0U;
    ba98:	f824 0c02 	strh.w	r0, [r4, #-2]
	sc->params.len = sizeof(sc_range);
    ba9c:	f824 3c08 	strh.w	r3, [r4, #-8]
	if (bt_gatt_indicate(NULL, &sc->params)) {
    baa0:	f1a4 0118 	sub.w	r1, r4, #24
    baa4:	f7ff ff1a 	bl	b8dc <bt_gatt_indicate>
    baa8:	b958      	cbnz	r0, bac2 <sc_process+0x96>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    baaa:	f3bf 8f5b 	dmb	ish
    baae:	e855 3f00 	ldrex	r3, [r5]
    bab2:	f043 0302 	orr.w	r3, r3, #2
    bab6:	e845 3200 	strex	r2, r3, [r5]
    baba:	2a00      	cmp	r2, #0
    babc:	d1f7      	bne.n	baae <sc_process+0x82>
    babe:	f3bf 8f5b 	dmb	ish
}
    bac2:	b003      	add	sp, #12
    bac4:	bd30      	pop	{r4, r5, pc}
    bac6:	bf00      	nop
    bac8:	0002cbd8 	.word	0x0002cbd8
    bacc:	0002c9fb 	.word	0x0002c9fb
    bad0:	0002a5e8 	.word	0x0002a5e8
    bad4:	0002cc09 	.word	0x0002cc09
    bad8:	00029fb4 	.word	0x00029fb4
    badc:	0000acb9 	.word	0x0000acb9

0000bae0 <update_ccc>:
	if (attr->write != bt_gatt_attr_write_ccc) {
    bae0:	6882      	ldr	r2, [r0, #8]
    bae2:	4b34      	ldr	r3, [pc, #208]	; (bbb4 <update_ccc+0xd4>)
    bae4:	429a      	cmp	r2, r3
{
    bae6:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct bt_conn *conn = data->conn;
    bae8:	680d      	ldr	r5, [r1, #0]
{
    baea:	4604      	mov	r4, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
    baec:	d11b      	bne.n	bb26 <update_ccc+0x46>
	ccc = attr->user_data;
    baee:	68c6      	ldr	r6, [r0, #12]
		if (!cfg->value ||
    baf0:	8933      	ldrh	r3, [r6, #8]
    baf2:	b1c3      	cbz	r3, bb26 <update_ccc+0x46>
		    !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    baf4:	4632      	mov	r2, r6
    baf6:	4628      	mov	r0, r5
    baf8:	f812 1b01 	ldrb.w	r1, [r2], #1
    bafc:	f01a fd34 	bl	26568 <bt_conn_is_peer_addr_le>
		if (!cfg->value ||
    bb00:	b188      	cbz	r0, bb26 <update_ccc+0x46>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
    bb02:	222a      	movs	r2, #42	; 0x2a
    bb04:	4621      	mov	r1, r4
    bb06:	4628      	mov	r0, r5
    bb08:	f01b fa19 	bl	26f3e <bt_gatt_check_perm>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
    bb0c:	2803      	cmp	r0, #3
    bb0e:	d10d      	bne.n	bb2c <update_ccc+0x4c>
    bb10:	4a29      	ldr	r2, [pc, #164]	; (bbb8 <update_ccc+0xd8>)
    bb12:	4b2a      	ldr	r3, [pc, #168]	; (bbbc <update_ccc+0xdc>)
				BT_WARN("CCC %p not writable", attr);
    bb14:	482a      	ldr	r0, [pc, #168]	; (bbc0 <update_ccc+0xe0>)
    bb16:	1ad2      	subs	r2, r2, r3
    bb18:	08d2      	lsrs	r2, r2, #3
    bb1a:	0192      	lsls	r2, r2, #6
    bb1c:	f042 0202 	orr.w	r2, r2, #2
    bb20:	4621      	mov	r1, r4
    bb22:	f018 fa5c 	bl	23fde <log_1>
}
    bb26:	2001      	movs	r0, #1
    bb28:	b002      	add	sp, #8
    bb2a:	bd70      	pop	{r4, r5, r6, pc}
		gatt_ccc_changed(attr, ccc);
    bb2c:	4631      	mov	r1, r6
    bb2e:	4620      	mov	r0, r4
    bb30:	f01b f8bb 	bl	26caa <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
    bb34:	4b23      	ldr	r3, [pc, #140]	; (bbc4 <update_ccc+0xe4>)
    bb36:	429e      	cmp	r6, r3
    bb38:	d1f5      	bne.n	bb26 <update_ccc+0x46>
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
    bb3a:	7a28      	ldrb	r0, [r5, #8]
    bb3c:	f105 0174 	add.w	r1, r5, #116	; 0x74
    bb40:	f7ff f862 	bl	ac08 <find_sc_cfg>
	if (!cfg) {
    bb44:	4604      	mov	r4, r0
    bb46:	2800      	cmp	r0, #0
    bb48:	d0ed      	beq.n	bb26 <update_ccc+0x46>
	if (!(cfg->data.start || cfg->data.end)) {
    bb4a:	8902      	ldrh	r2, [r0, #8]
    bb4c:	8943      	ldrh	r3, [r0, #10]
    bb4e:	ea53 0102 	orrs.w	r1, r3, r2
    bb52:	d0e8      	beq.n	bb26 <update_ccc+0x46>
	index = bt_conn_index(conn);
    bb54:	4628      	mov	r0, r5
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
    bb56:	f8ad 2004 	strh.w	r2, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
    bb5a:	f8ad 3006 	strh.w	r3, [sp, #6]
	index = bt_conn_index(conn);
    bb5e:	f7fd fd95 	bl	968c <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
    bb62:	4919      	ldr	r1, [pc, #100]	; (bbc8 <update_ccc+0xe8>)
    bb64:	4a19      	ldr	r2, [pc, #100]	; (bbcc <update_ccc+0xec>)
    bb66:	2314      	movs	r3, #20
    bb68:	fb03 1300 	mla	r3, r3, r0, r1
    bb6c:	605a      	str	r2, [r3, #4]
	sc_restore_params[index].func = sc_restore_rsp;
    bb6e:	4a18      	ldr	r2, [pc, #96]	; (bbd0 <update_ccc+0xf0>)
    bb70:	609a      	str	r2, [r3, #8]
	sc_restore_params[index].data = &sc_range[0];
    bb72:	aa01      	add	r2, sp, #4
    bb74:	60da      	str	r2, [r3, #12]
	sc_restore_params[index].len = sizeof(sc_range);
    bb76:	2204      	movs	r2, #4
    bb78:	821a      	strh	r2, [r3, #16]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    bb7a:	b203      	sxth	r3, r0
    bb7c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    bb80:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    bb84:	4628      	mov	r0, r5
    bb86:	f7ff fea9 	bl	b8dc <bt_gatt_indicate>
    bb8a:	b148      	cbz	r0, bba0 <update_ccc+0xc0>
    bb8c:	490a      	ldr	r1, [pc, #40]	; (bbb8 <update_ccc+0xd8>)
    bb8e:	4b0b      	ldr	r3, [pc, #44]	; (bbbc <update_ccc+0xdc>)
		BT_ERR("SC restore indication failed");
    bb90:	4810      	ldr	r0, [pc, #64]	; (bbd4 <update_ccc+0xf4>)
    bb92:	1ac9      	subs	r1, r1, r3
    bb94:	08c9      	lsrs	r1, r1, #3
    bb96:	0189      	lsls	r1, r1, #6
    bb98:	f041 0101 	orr.w	r1, r1, #1
    bb9c:	f018 fa12 	bl	23fc4 <log_0>
	memset(&cfg->data, 0, sizeof(cfg->data));
    bba0:	2204      	movs	r2, #4
    bba2:	2100      	movs	r1, #0
    bba4:	f104 0008 	add.w	r0, r4, #8
    bba8:	f01a f8a9 	bl	25cfe <memset>
		sc_store(cfg);
    bbac:	4620      	mov	r0, r4
    bbae:	f7fe feab 	bl	a908 <sc_store>
    bbb2:	e7b8      	b.n	bb26 <update_ccc+0x46>
    bbb4:	0000af09 	.word	0x0000af09
    bbb8:	000298e8 	.word	0x000298e8
    bbbc:	00029830 	.word	0x00029830
    bbc0:	0002cc24 	.word	0x0002cc24
    bbc4:	20006b30 	.word	0x20006b30
    bbc8:	200006fc 	.word	0x200006fc
    bbcc:	00029fb4 	.word	0x00029fb4
    bbd0:	00026ccf 	.word	0x00026ccf
    bbd4:	0002cc38 	.word	0x0002cc38

0000bbd8 <bt_gatt_connected>:
{
    bbd8:	b530      	push	{r4, r5, lr}
    bbda:	b08f      	sub	sp, #60	; 0x3c
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    bbdc:	f100 0574 	add.w	r5, r0, #116	; 0x74
{
    bbe0:	4604      	mov	r4, r0
	data.conn = conn;
    bbe2:	9003      	str	r0, [sp, #12]
	data.sec = BT_SECURITY_L1;
    bbe4:	2301      	movs	r3, #1
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    bbe6:	7a00      	ldrb	r0, [r0, #8]
	data.sec = BT_SECURITY_L1;
    bbe8:	f88d 3010 	strb.w	r3, [sp, #16]
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    bbec:	4629      	mov	r1, r5
    bbee:	f01a fc1c 	bl	2642a <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
    bbf2:	b190      	cbz	r0, bc1a <bt_gatt_connected+0x42>
		if (conn->id) {
    bbf4:	7a22      	ldrb	r2, [r4, #8]
    bbf6:	b1ca      	cbz	r2, bc2c <bt_gatt_connected+0x54>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
    bbf8:	ac02      	add	r4, sp, #8
    bbfa:	2104      	movs	r1, #4
    bbfc:	4620      	mov	r0, r4
    bbfe:	f017 ffb4 	bl	23b6a <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "ccc",
    bc02:	9400      	str	r4, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "ccc",
    bc04:	4a0a      	ldr	r2, [pc, #40]	; (bc30 <bt_gatt_connected+0x58>)
    bc06:	2124      	movs	r1, #36	; 0x24
    bc08:	a805      	add	r0, sp, #20
    bc0a:	462b      	mov	r3, r5
    bc0c:	f7fa fc5e 	bl	64cc <bt_settings_encode_key>
		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
    bc10:	aa05      	add	r2, sp, #20
    bc12:	4908      	ldr	r1, [pc, #32]	; (bc34 <bt_gatt_connected+0x5c>)
    bc14:	4610      	mov	r0, r2
    bc16:	f7f7 fee1 	bl	39dc <settings_load_subtree_direct>
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    bc1a:	4a07      	ldr	r2, [pc, #28]	; (bc38 <bt_gatt_connected+0x60>)
    bc1c:	ab03      	add	r3, sp, #12
    bc1e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    bc22:	2001      	movs	r0, #1
    bc24:	f01b f97e 	bl	26f24 <bt_gatt_foreach_attr>
}
    bc28:	b00f      	add	sp, #60	; 0x3c
    bc2a:	bd30      	pop	{r4, r5, pc}
			bt_settings_encode_key(key, sizeof(key), "ccc",
    bc2c:	9200      	str	r2, [sp, #0]
    bc2e:	e7e9      	b.n	bc04 <bt_gatt_connected+0x2c>
    bc30:	0002cbb4 	.word	0x0002cbb4
    bc34:	0000b681 	.word	0x0000b681
    bc38:	0000bae1 	.word	0x0000bae1

0000bc3c <bt_gatt_store_ccc>:
{
    bc3c:	b570      	push	{r4, r5, r6, lr}
    bc3e:	b0c0      	sub	sp, #256	; 0x100
	save.count = 0;
    bc40:	2300      	movs	r3, #0
{
    bc42:	4604      	mov	r4, r0
    bc44:	460d      	mov	r5, r1
	save.addr_with_id.addr = addr;
    bc46:	910d      	str	r1, [sp, #52]	; 0x34
	save.addr_with_id.id = id;
    bc48:	f88d 0038 	strb.w	r0, [sp, #56]	; 0x38
	save.count = 0;
    bc4c:	933f      	str	r3, [sp, #252]	; 0xfc
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
    bc4e:	4a18      	ldr	r2, [pc, #96]	; (bcb0 <bt_gatt_store_ccc+0x74>)
    bc50:	ab0d      	add	r3, sp, #52	; 0x34
    bc52:	f64f 71ff 	movw	r1, #65535	; 0xffff
    bc56:	2001      	movs	r0, #1
    bc58:	f01b f964 	bl	26f24 <bt_gatt_foreach_attr>
	if (id) {
    bc5c:	b31c      	cbz	r4, bca6 <bt_gatt_store_ccc+0x6a>
		u8_to_dec(id_str, sizeof(id_str), id);
    bc5e:	ae03      	add	r6, sp, #12
    bc60:	4622      	mov	r2, r4
    bc62:	2104      	movs	r1, #4
    bc64:	4630      	mov	r0, r6
    bc66:	f017 ff80 	bl	23b6a <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, id_str);
    bc6a:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
    bc6c:	4a11      	ldr	r2, [pc, #68]	; (bcb4 <bt_gatt_store_ccc+0x78>)
    bc6e:	462b      	mov	r3, r5
    bc70:	2124      	movs	r1, #36	; 0x24
    bc72:	a804      	add	r0, sp, #16
    bc74:	f7fa fc2a 	bl	64cc <bt_settings_encode_key>
	if (save.count) {
    bc78:	9a3f      	ldr	r2, [sp, #252]	; 0xfc
    bc7a:	b1b2      	cbz	r2, bcaa <bt_gatt_store_ccc+0x6e>
		len = save.count * sizeof(*save.store);
    bc7c:	0092      	lsls	r2, r2, #2
		str = (char *)save.store;
    bc7e:	a90f      	add	r1, sp, #60	; 0x3c
	err = settings_save_one(key, str, len);
    bc80:	a804      	add	r0, sp, #16
    bc82:	f7f7 fe4b 	bl	391c <settings_save_one>
	if (err) {
    bc86:	4604      	mov	r4, r0
    bc88:	b150      	cbz	r0, bca0 <bt_gatt_store_ccc+0x64>
    bc8a:	4a0b      	ldr	r2, [pc, #44]	; (bcb8 <bt_gatt_store_ccc+0x7c>)
    bc8c:	4b0b      	ldr	r3, [pc, #44]	; (bcbc <bt_gatt_store_ccc+0x80>)
    bc8e:	1ad2      	subs	r2, r2, r3
    bc90:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Failed to store CCCs (err %d)", err);
    bc92:	0192      	lsls	r2, r2, #6
    bc94:	4601      	mov	r1, r0
    bc96:	f042 0201 	orr.w	r2, r2, #1
    bc9a:	4809      	ldr	r0, [pc, #36]	; (bcc0 <bt_gatt_store_ccc+0x84>)
    bc9c:	f018 f99f 	bl	23fde <log_1>
}
    bca0:	4620      	mov	r0, r4
    bca2:	b040      	add	sp, #256	; 0x100
    bca4:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
    bca6:	9400      	str	r4, [sp, #0]
    bca8:	e7e0      	b.n	bc6c <bt_gatt_store_ccc+0x30>
		str = NULL;
    bcaa:	4611      	mov	r1, r2
    bcac:	e7e8      	b.n	bc80 <bt_gatt_store_ccc+0x44>
    bcae:	bf00      	nop
    bcb0:	0000abd1 	.word	0x0000abd1
    bcb4:	0002cbb4 	.word	0x0002cbb4
    bcb8:	000298e8 	.word	0x000298e8
    bcbc:	00029830 	.word	0x00029830
    bcc0:	0002cc55 	.word	0x0002cc55

0000bcc4 <bt_gatt_disconnected>:
{
    bcc4:	b538      	push	{r3, r4, r5, lr}
    bcc6:	4604      	mov	r4, r0
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
    bcc8:	4603      	mov	r3, r0
    bcca:	f64f 71ff 	movw	r1, #65535	; 0xffff
    bcce:	2001      	movs	r0, #1
    bcd0:	4a08      	ldr	r2, [pc, #32]	; (bcf4 <bt_gatt_disconnected+0x30>)
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    bcd2:	f104 0574 	add.w	r5, r4, #116	; 0x74
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
    bcd6:	f01b f925 	bl	26f24 <bt_gatt_foreach_attr>
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    bcda:	7a20      	ldrb	r0, [r4, #8]
    bcdc:	4629      	mov	r1, r5
    bcde:	f01a fba4 	bl	2642a <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    bce2:	b128      	cbz	r0, bcf0 <bt_gatt_disconnected+0x2c>
		bt_gatt_store_ccc(conn->id, &conn->le.dst);
    bce4:	7a20      	ldrb	r0, [r4, #8]
    bce6:	4629      	mov	r1, r5
}
    bce8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_gatt_store_ccc(conn->id, &conn->le.dst);
    bcec:	f7ff bfa6 	b.w	bc3c <bt_gatt_store_ccc>
}
    bcf0:	bd38      	pop	{r3, r4, r5, pc}
    bcf2:	bf00      	nop
    bcf4:	0000ad31 	.word	0x0000ad31

0000bcf8 <bt_smp_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
		struct bt_l2cap_le_chan *smp = &bt_smp_pool[i];

		if (smp->chan.conn) {
    bcf8:	4a0b      	ldr	r2, [pc, #44]	; (bd28 <bt_smp_accept+0x30>)
{
    bcfa:	b508      	push	{r3, lr}
    bcfc:	4603      	mov	r3, r0
		if (smp->chan.conn) {
    bcfe:	6810      	ldr	r0, [r2, #0]
    bd00:	b918      	cbnz	r0, bd0a <bt_smp_accept+0x12>
			continue;
		}

		smp->chan.ops = &ops;
    bd02:	4b0a      	ldr	r3, [pc, #40]	; (bd2c <bt_smp_accept+0x34>)
    bd04:	6053      	str	r3, [r2, #4]

		*chan = &smp->chan;
    bd06:	600a      	str	r2, [r1, #0]
	}

	BT_ERR("No available SMP context for conn %p", conn);

	return -ENOMEM;
}
    bd08:	bd08      	pop	{r3, pc}
    bd0a:	4909      	ldr	r1, [pc, #36]	; (bd30 <bt_smp_accept+0x38>)
    bd0c:	4a09      	ldr	r2, [pc, #36]	; (bd34 <bt_smp_accept+0x3c>)
	BT_ERR("No available SMP context for conn %p", conn);
    bd0e:	480a      	ldr	r0, [pc, #40]	; (bd38 <bt_smp_accept+0x40>)
    bd10:	1a52      	subs	r2, r2, r1
    bd12:	08d2      	lsrs	r2, r2, #3
    bd14:	0192      	lsls	r2, r2, #6
    bd16:	f042 0201 	orr.w	r2, r2, #1
    bd1a:	4619      	mov	r1, r3
    bd1c:	f018 f95f 	bl	23fde <log_1>
	return -ENOMEM;
    bd20:	f06f 000b 	mvn.w	r0, #11
    bd24:	e7f0      	b.n	bd08 <bt_smp_accept+0x10>
    bd26:	bf00      	nop
    bd28:	20000710 	.word	0x20000710
    bd2c:	0002a068 	.word	0x0002a068
    bd30:	00029830 	.word	0x00029830
    bd34:	00029998 	.word	0x00029998
    bd38:	0002cc81 	.word	0x0002cc81

0000bd3c <bt_mesh_reset>:

	return -ENOTSUP;
}

void bt_mesh_reset(void)
{
    bd3c:	b538      	push	{r3, r4, r5, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    bd3e:	481a      	ldr	r0, [pc, #104]	; (bda8 <bt_mesh_reset+0x6c>)
    bd40:	f3bf 8f5b 	dmb	ish
    bd44:	6803      	ldr	r3, [r0, #0]
    bd46:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
    bd4a:	07db      	lsls	r3, r3, #31
    bd4c:	d52a      	bpl.n	bda4 <bt_mesh_reset+0x68>
		return;
	}

	bt_mesh.iv_index = 0U;
    bd4e:	2400      	movs	r4, #0
	bt_mesh.seq = 0U;

	memset(bt_mesh.flags, 0, sizeof(bt_mesh.flags));
    bd50:	4621      	mov	r1, r4
    bd52:	2204      	movs	r2, #4
	bt_mesh.iv_index = 0U;
    bd54:	f1a0 0508 	sub.w	r5, r0, #8
	bt_mesh.seq = 0U;
    bd58:	e940 4402 	strd	r4, r4, [r0, #-8]
	memset(bt_mesh.flags, 0, sizeof(bt_mesh.flags));
    bd5c:	f019 ffcf 	bl	25cfe <memset>

	k_delayed_work_cancel(&bt_mesh.ivu_timer);
    bd60:	f505 708e 	add.w	r0, r5, #284	; 0x11c
    bd64:	f016 ff8c 	bl	22c80 <k_delayed_work_cancel>

	bt_mesh_cfg_reset();
    bd68:	f006 fdf4 	bl	12954 <bt_mesh_cfg_reset>

	bt_mesh_rx_reset();
    bd6c:	f003 fa52 	bl	f214 <bt_mesh_rx_reset>
	bt_mesh_tx_reset();
    bd70:	f003 fa62 	bl	f238 <bt_mesh_tx_reset>
	if (IS_ENABLED(CONFIG_BT_MESH_LOW_POWER)) {
		bt_mesh_lpn_disable(true);
	}

	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND)) {
		bt_mesh_friend_clear_net_idx(BT_MESH_KEY_ANY);
    bd74:	f64f 70ff 	movw	r0, #65535	; 0xffff
    bd78:	f008 fed4 	bl	14b24 <bt_mesh_friend_clear_net_idx>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY)) {
		bt_mesh_proxy_gatt_disable();
    bd7c:	f00b ff14 	bl	17ba8 <bt_mesh_proxy_gatt_disable>
	}

	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		bt_mesh_clear_net();
    bd80:	f01b ff86 	bl	27c90 <bt_mesh_clear_net>
	}

	(void)memset(bt_mesh.dev_key, 0, sizeof(bt_mesh.dev_key));
    bd84:	4621      	mov	r1, r4
    bd86:	2210      	movs	r2, #16
    bd88:	f505 709e 	add.w	r0, r5, #316	; 0x13c
    bd8c:	f019 ffb7 	bl	25cfe <memset>

	bt_mesh_scan_disable();
    bd90:	f000 fa5a 	bl	c248 <bt_mesh_scan_disable>
	bt_mesh_beacon_disable();
    bd94:	f000 fd4e 	bl	c834 <bt_mesh_beacon_disable>

	bt_mesh_comp_unprovision();
    bd98:	f003 fe7e 	bl	fa98 <bt_mesh_comp_unprovision>

	if (IS_ENABLED(CONFIG_BT_MESH_PROV)) {
		bt_mesh_prov_reset();
	}
}
    bd9c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_mesh_prov_reset();
    bda0:	f00a bc36 	b.w	16610 <bt_mesh_prov_reset>
}
    bda4:	bd38      	pop	{r3, r4, r5, pc}
    bda6:	bf00      	nop
    bda8:	20006b50 	.word	0x20006b50

0000bdac <bt_mesh_is_provisioned>:
    bdac:	4b04      	ldr	r3, [pc, #16]	; (bdc0 <bt_mesh_is_provisioned+0x14>)
    bdae:	f3bf 8f5b 	dmb	ish
    bdb2:	6818      	ldr	r0, [r3, #0]
    bdb4:	f3bf 8f5b 	dmb	ish

bool bt_mesh_is_provisioned(void)
{
	return atomic_test_bit(bt_mesh.flags, BT_MESH_VALID);
}
    bdb8:	f000 0001 	and.w	r0, r0, #1
    bdbc:	4770      	bx	lr
    bdbe:	bf00      	nop
    bdc0:	20006b50 	.word	0x20006b50

0000bdc4 <bt_mesh_start>:
		mod->cb->start(mod);
	}
}

int bt_mesh_start(void)
{
    bdc4:	b508      	push	{r3, lr}
	bt_mesh_net_start();
    bdc6:	f001 feb7 	bl	db38 <bt_mesh_net_start>
	bt_mesh_model_foreach(model_start, NULL);
    bdca:	4803      	ldr	r0, [pc, #12]	; (bdd8 <bt_mesh_start+0x14>)
    bdcc:	2100      	movs	r1, #0
    bdce:	f003 fd57 	bl	f880 <bt_mesh_model_foreach>

	return 0;
}
    bdd2:	2000      	movs	r0, #0
    bdd4:	bd08      	pop	{r3, pc}
    bdd6:	bf00      	nop
    bdd8:	00026fd5 	.word	0x00026fd5

0000bddc <bt_mesh_provision>:
{
    bddc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bde0:	4698      	mov	r8, r3
    bde2:	4c36      	ldr	r4, [pc, #216]	; (bebc <bt_mesh_provision+0xe0>)
    bde4:	4b36      	ldr	r3, [pc, #216]	; (bec0 <bt_mesh_provision+0xe4>)
	BT_DBG("net_idx 0x%04x flags 0x%02x iv_index 0x%04x",
    bde6:	f8df a0ec 	ldr.w	sl, [pc, #236]	; bed4 <bt_mesh_provision+0xf8>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    bdea:	4d36      	ldr	r5, [pc, #216]	; (bec4 <bt_mesh_provision+0xe8>)
{
    bdec:	b087      	sub	sp, #28
    bdee:	1ae4      	subs	r4, r4, r3
    bdf0:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
    bdf4:	08e4      	lsrs	r4, r4, #3
	BT_INFO("Primary Element: 0x%04x", addr);
    bdf6:	01a4      	lsls	r4, r4, #6
{
    bdf8:	460e      	mov	r6, r1
    bdfa:	4617      	mov	r7, r2
	BT_INFO("Primary Element: 0x%04x", addr);
    bdfc:	4659      	mov	r1, fp
    bdfe:	f044 0203 	orr.w	r2, r4, #3
{
    be02:	4681      	mov	r9, r0
	BT_DBG("net_idx 0x%04x flags 0x%02x iv_index 0x%04x",
    be04:	f044 0404 	orr.w	r4, r4, #4
	BT_INFO("Primary Element: 0x%04x", addr);
    be08:	482f      	ldr	r0, [pc, #188]	; (bec8 <bt_mesh_provision+0xec>)
    be0a:	f018 f8e8 	bl	23fde <log_1>
	BT_DBG("net_idx 0x%04x flags 0x%02x iv_index 0x%04x",
    be0e:	482f      	ldr	r0, [pc, #188]	; (becc <bt_mesh_provision+0xf0>)
    be10:	4623      	mov	r3, r4
    be12:	2204      	movs	r2, #4
    be14:	a902      	add	r1, sp, #8
    be16:	e9cd a602 	strd	sl, r6, [sp, #8]
    be1a:	e9cd 7804 	strd	r7, r8, [sp, #16]
    be1e:	f018 f927 	bl	24070 <log_n>
    be22:	f3bf 8f5b 	dmb	ish
    be26:	e855 0f00 	ldrex	r0, [r5]
    be2a:	f040 0301 	orr.w	r3, r0, #1
    be2e:	e845 3200 	strex	r2, r3, [r5]
    be32:	2a00      	cmp	r2, #0
    be34:	d1f7      	bne.n	be26 <bt_mesh_provision+0x4a>
    be36:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(bt_mesh.flags, BT_MESH_VALID)) {
    be3a:	f010 0001 	ands.w	r0, r0, #1
    be3e:	d13a      	bne.n	beb6 <bt_mesh_provision+0xda>
		if (bt_mesh_proxy_prov_disable(false) == 0) {
    be40:	f00b fe58 	bl	17af4 <bt_mesh_proxy_prov_disable>
	err = bt_mesh_net_create(net_idx, flags, net_key, iv_index);
    be44:	4643      	mov	r3, r8
		if (bt_mesh_proxy_prov_disable(false) == 0) {
    be46:	9001      	str	r0, [sp, #4]
	err = bt_mesh_net_create(net_idx, flags, net_key, iv_index);
    be48:	464a      	mov	r2, r9
    be4a:	4630      	mov	r0, r6
    be4c:	4639      	mov	r1, r7
    be4e:	f000 ffb7 	bl	cdc0 <bt_mesh_net_create>
	if (err) {
    be52:	4606      	mov	r6, r0
    be54:	b198      	cbz	r0, be7e <bt_mesh_provision+0xa2>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    be56:	f3bf 8f5b 	dmb	ish
    be5a:	e855 3f00 	ldrex	r3, [r5]
    be5e:	f023 0301 	bic.w	r3, r3, #1
    be62:	e845 3200 	strex	r2, r3, [r5]
    be66:	2a00      	cmp	r2, #0
    be68:	d1f7      	bne.n	be5a <bt_mesh_provision+0x7e>
    be6a:	f3bf 8f5b 	dmb	ish
		if (IS_ENABLED(CONFIG_BT_MESH_PB_GATT) && pb_gatt_enabled) {
    be6e:	9b01      	ldr	r3, [sp, #4]
    be70:	b90b      	cbnz	r3, be76 <bt_mesh_provision+0x9a>
			bt_mesh_proxy_prov_enable();
    be72:	f00b fe1d 	bl	17ab0 <bt_mesh_proxy_prov_enable>
}
    be76:	4630      	mov	r0, r6
    be78:	b007      	add	sp, #28
    be7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bt_mesh.seq = 0U;
    be7e:	f845 0c04 	str.w	r0, [r5, #-4]
	bt_mesh_comp_provision(addr);
    be82:	4658      	mov	r0, fp
    be84:	f003 fdf2 	bl	fa6c <bt_mesh_comp_provision>
	memcpy(bt_mesh.dev_key, dev_key, 16);
    be88:	9911      	ldr	r1, [sp, #68]	; 0x44
    be8a:	2210      	movs	r2, #16
    be8c:	f505 709a 	add.w	r0, r5, #308	; 0x134
    be90:	f019 ff0a 	bl	25ca8 <memcpy>
		BT_DBG("Storing network information persistently");
    be94:	4622      	mov	r2, r4
    be96:	4651      	mov	r1, sl
    be98:	480d      	ldr	r0, [pc, #52]	; (bed0 <bt_mesh_provision+0xf4>)
    be9a:	f018 f8a0 	bl	23fde <log_1>
		bt_mesh_store_net();
    be9e:	f01b fe99 	bl	27bd4 <bt_mesh_store_net>
		bt_mesh_store_subnet(&bt_mesh.sub[0]);
    bea2:	f505 70ca 	add.w	r0, r5, #404	; 0x194
    bea6:	f01b fea9 	bl	27bfc <bt_mesh_store_subnet>
		bt_mesh_store_iv(false);
    beaa:	4630      	mov	r0, r6
    beac:	f01b fe95 	bl	27bda <bt_mesh_store_iv>
	bt_mesh_start();
    beb0:	f7ff ff88 	bl	bdc4 <bt_mesh_start>
	return 0;
    beb4:	e7df      	b.n	be76 <bt_mesh_provision+0x9a>
		return -EALREADY;
    beb6:	f06f 0644 	mvn.w	r6, #68	; 0x44
    beba:	e7dc      	b.n	be76 <bt_mesh_provision+0x9a>
    bebc:	00029950 	.word	0x00029950
    bec0:	00029830 	.word	0x00029830
    bec4:	20006b50 	.word	0x20006b50
    bec8:	0002ccad 	.word	0x0002ccad
    becc:	0002ccc5 	.word	0x0002ccc5
    bed0:	0002ccf5 	.word	0x0002ccf5
    bed4:	0002cd2f 	.word	0x0002cd2f

0000bed8 <adv_alloc>:
static struct bt_mesh_adv adv_pool[CONFIG_BT_MESH_ADV_BUF_COUNT];

static struct bt_mesh_adv *adv_alloc(int id)
{
	return &adv_pool[id];
}
    bed8:	4b02      	ldr	r3, [pc, #8]	; (bee4 <adv_alloc+0xc>)
    beda:	220c      	movs	r2, #12
    bedc:	fb02 3000 	mla	r0, r2, r0, r3
    bee0:	4770      	bx	lr
    bee2:	bf00      	nop
    bee4:	200007a8 	.word	0x200007a8

0000bee8 <adv_thread>:

	BT_DBG("Advertising stopped");
}

static void adv_thread(void *p1, void *p2, void *p3)
{
    bee8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    beec:	4b47      	ldr	r3, [pc, #284]	; (c00c <adv_thread+0x124>)
    beee:	4e48      	ldr	r6, [pc, #288]	; (c010 <adv_thread+0x128>)

	while (1) {
		struct net_buf *buf;

		if (IS_ENABLED(CONFIG_BT_MESH_PROXY)) {
			buf = net_buf_get(&adv_queue, K_NO_WAIT);
    bef0:	f8df 812c 	ldr.w	r8, [pc, #300]	; c020 <adv_thread+0x138>
	ad.type = adv_type[BT_MESH_ADV(buf)->type];
    bef4:	f8df b12c 	ldr.w	fp, [pc, #300]	; c024 <adv_thread+0x13c>
    bef8:	1af6      	subs	r6, r6, r3
{
    befa:	b089      	sub	sp, #36	; 0x24
    befc:	08f6      	lsrs	r6, r6, #3
			buf = net_buf_get(&adv_queue, K_NO_WAIT);
    befe:	2100      	movs	r1, #0
    bf00:	4640      	mov	r0, r8
    bf02:	f012 ffa9 	bl	1ee58 <net_buf_get>
    bf06:	4604      	mov	r4, r0
			while (!buf) {
    bf08:	2c00      	cmp	r4, #0
    bf0a:	d05d      	beq.n	bfc8 <adv_thread+0xe0>
		if (!buf) {
			continue;
		}

		/* busy == 0 means this was canceled */
		if (BT_MESH_ADV(buf)->busy) {
    bf0c:	6962      	ldr	r2, [r4, #20]
    bf0e:	7a13      	ldrb	r3, [r2, #8]
    bf10:	0759      	lsls	r1, r3, #29
    bf12:	d576      	bpl.n	c002 <adv_thread+0x11a>
			BT_MESH_ADV(buf)->busy = 0U;
    bf14:	f36f 0382 	bfc	r3, #2, #1
    bf18:	7213      	strb	r3, [r2, #8]
				   ADV_INT_FAST_MS : ADV_INT_DEFAULT_MS);
    bf1a:	4b3e      	ldr	r3, [pc, #248]	; (c014 <adv_thread+0x12c>)
    bf1c:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
    bf20:	2b08      	cmp	r3, #8
	const struct bt_mesh_send_cb *cb = BT_MESH_ADV(buf)->cb;
    bf22:	6963      	ldr	r3, [r4, #20]
	void *cb_data = BT_MESH_ADV(buf)->cb_data;
    bf24:	e9d3 7900 	ldrd	r7, r9, [r3]
	adv_int = MAX(adv_int_min,
    bf28:	7a5d      	ldrb	r5, [r3, #9]
	ad.type = adv_type[BT_MESH_ADV(buf)->type];
    bf2a:	7a1b      	ldrb	r3, [r3, #8]
	adv_int = MAX(adv_int_min,
    bf2c:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
    bf30:	f04f 000a 	mov.w	r0, #10
	ad.type = adv_type[BT_MESH_ADV(buf)->type];
    bf34:	f003 0303 	and.w	r3, r3, #3
				   ADV_INT_FAST_MS : ADV_INT_DEFAULT_MS);
    bf38:	bf8c      	ite	hi
    bf3a:	2214      	movhi	r2, #20
    bf3c:	2264      	movls	r2, #100	; 0x64
	adv_int = MAX(adv_int_min,
    bf3e:	fb0c 0000 	mla	r0, ip, r0, r0
    bf42:	4290      	cmp	r0, r2
    bf44:	f10c 0101 	add.w	r1, ip, #1
	ad.type = adv_type[BT_MESH_ADV(buf)->type];
    bf48:	f81b 3003 	ldrb.w	r3, [fp, r3]
    bf4c:	f88d 3008 	strb.w	r3, [sp, #8]
	adv_int = MAX(adv_int_min,
    bf50:	bfa8      	it	ge
    bf52:	eb01 0181 	addge.w	r1, r1, r1, lsl #2
	ad.data_len = buf->len;
    bf56:	89a3      	ldrh	r3, [r4, #12]
    bf58:	f88d 3009 	strb.w	r3, [sp, #9]
	adv_int = MAX(adv_int_min,
    bf5c:	bfa8      	it	ge
    bf5e:	004a      	lslge	r2, r1, #1
	ad.data = buf->data;
    bf60:	68a3      	ldr	r3, [r4, #8]
    bf62:	9303      	str	r3, [sp, #12]
	adv_int = MAX(adv_int_min,
    bf64:	bfb8      	it	lt
    bf66:	b292      	uxthlt	r2, r2
		param.options = 0U;
    bf68:	2300      	movs	r3, #0
		    ((BT_MESH_TRANSMIT_COUNT(BT_MESH_ADV(buf)->xmit) + 1) *
    bf6a:	f005 0107 	and.w	r1, r5, #7
		     (adv_int + 10)));
    bf6e:	f102 050a 	add.w	r5, r2, #10
	duration = (MESH_SCAN_WINDOW_MS +
    bf72:	fb01 5505 	mla	r5, r1, r5, r5
	param.interval_min = ADV_SCAN_UNIT(adv_int);
    bf76:	00d2      	lsls	r2, r2, #3
    bf78:	2105      	movs	r1, #5
	err = bt_le_adv_start(&param, &ad, 1, NULL, 0);
    bf7a:	9300      	str	r3, [sp, #0]
	param.interval_min = ADV_SCAN_UNIT(adv_int);
    bf7c:	fbb2 f2f1 	udiv	r2, r2, r1
	err = bt_le_adv_start(&param, &ad, 1, NULL, 0);
    bf80:	a804      	add	r0, sp, #16
	param.interval_max = param.interval_min;
    bf82:	e9cd 2206 	strd	r2, r2, [sp, #24]
	err = bt_le_adv_start(&param, &ad, 1, NULL, 0);
    bf86:	a902      	add	r1, sp, #8
    bf88:	2201      	movs	r2, #1
		param.options = 0U;
    bf8a:	9305      	str	r3, [sp, #20]
	param.id = BT_ID_DEFAULT;
    bf8c:	f88d 3010 	strb.w	r3, [sp, #16]
	err = bt_le_adv_start(&param, &ad, 1, NULL, 0);
    bf90:	f01a fa4d 	bl	2642e <bt_le_adv_start>
	duration = (MESH_SCAN_WINDOW_MS +
    bf94:	351e      	adds	r5, #30
	err = bt_le_adv_start(&param, &ad, 1, NULL, 0);
    bf96:	4682      	mov	sl, r0
	net_buf_unref(buf);
    bf98:	4620      	mov	r0, r4
	duration = (MESH_SCAN_WINDOW_MS +
    bf9a:	b22d      	sxth	r5, r5
	net_buf_unref(buf);
    bf9c:	f013 f894 	bl	1f0c8 <net_buf_unref>
	if (cb && cb->start) {
    bfa0:	b12f      	cbz	r7, bfae <adv_thread+0xc6>
    bfa2:	683b      	ldr	r3, [r7, #0]
    bfa4:	b11b      	cbz	r3, bfae <adv_thread+0xc6>
		cb->start(duration, err, cb_data);
    bfa6:	b2a8      	uxth	r0, r5
    bfa8:	464a      	mov	r2, r9
    bfaa:	4651      	mov	r1, sl
    bfac:	4798      	blx	r3
	if (err) {
    bfae:	f1ba 0f00 	cmp.w	sl, #0
    bfb2:	d013      	beq.n	bfdc <adv_thread+0xf4>
		BT_ERR("Advertising failed: err %d", err);
    bfb4:	01b2      	lsls	r2, r6, #6
    bfb6:	4818      	ldr	r0, [pc, #96]	; (c018 <adv_thread+0x130>)
    bfb8:	f042 0201 	orr.w	r2, r2, #1
    bfbc:	4651      	mov	r1, sl
		BT_ERR("Stopping advertising failed: err %d", err);
    bfbe:	f018 f80e 	bl	23fde <log_1>
	z_impl_k_yield();
    bfc2:	f016 f9ef 	bl	223a4 <z_impl_k_yield>
}
    bfc6:	e79a      	b.n	befe <adv_thread+0x16>
				timeout = bt_mesh_proxy_adv_start();
    bfc8:	f00b fe7c 	bl	17cc4 <bt_mesh_proxy_adv_start>
    bfcc:	4601      	mov	r1, r0
				buf = net_buf_get(&adv_queue, timeout);
    bfce:	4640      	mov	r0, r8
    bfd0:	f012 ff42 	bl	1ee58 <net_buf_get>
    bfd4:	4604      	mov	r4, r0
				bt_mesh_proxy_adv_stop();
    bfd6:	f00c f821 	bl	1801c <bt_mesh_proxy_adv_stop>
    bfda:	e795      	b.n	bf08 <adv_thread+0x20>
	return z_impl_k_sleep(timeout);
    bfdc:	4628      	mov	r0, r5
    bfde:	f016 fb25 	bl	2262c <z_impl_k_sleep>
	err = bt_le_adv_stop();
    bfe2:	f7fc fa69 	bl	84b8 <bt_le_adv_stop>
    bfe6:	4604      	mov	r4, r0
	if (cb && cb->end) {
    bfe8:	b11f      	cbz	r7, bff2 <adv_thread+0x10a>
    bfea:	687b      	ldr	r3, [r7, #4]
    bfec:	b10b      	cbz	r3, bff2 <adv_thread+0x10a>
		cb->end(err, cb_data);
    bfee:	4649      	mov	r1, r9
    bff0:	4798      	blx	r3
	if (err) {
    bff2:	2c00      	cmp	r4, #0
    bff4:	d0e5      	beq.n	bfc2 <adv_thread+0xda>
		BT_ERR("Stopping advertising failed: err %d", err);
    bff6:	01b2      	lsls	r2, r6, #6
    bff8:	4808      	ldr	r0, [pc, #32]	; (c01c <adv_thread+0x134>)
    bffa:	f042 0201 	orr.w	r2, r2, #1
    bffe:	4621      	mov	r1, r4
    c000:	e7dd      	b.n	bfbe <adv_thread+0xd6>
			adv_send(buf);
		} else {
			net_buf_unref(buf);
    c002:	4620      	mov	r0, r4
    c004:	f013 f860 	bl	1f0c8 <net_buf_unref>
    c008:	e7db      	b.n	bfc2 <adv_thread+0xda>
    c00a:	bf00      	nop
    c00c:	00029830 	.word	0x00029830
    c010:	00029910 	.word	0x00029910
    c014:	20006860 	.word	0x20006860
    c018:	0002cd41 	.word	0x0002cd41
    c01c:	0002cd5c 	.word	0x0002cd5c
    c020:	20007648 	.word	0x20007648
    c024:	0002ce0d 	.word	0x0002ce0d

0000c028 <bt_mesh_scan_cb>:
                bt_data_parse(buf, data_cb, &mesh_scan_data);
                net_buf_simple_restore(buf, &state);
        }
#endif

	if (adv_type != BT_HCI_ADV_NONCONN_IND) {
    c028:	2a03      	cmp	r2, #3
{
    c02a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c02e:	460f      	mov	r7, r1
    c030:	461c      	mov	r4, r3
	if (adv_type != BT_HCI_ADV_NONCONN_IND) {
    c032:	d025      	beq.n	c080 <bt_mesh_scan_cb+0x58>
		}

		net_buf_simple_restore(buf, &state);
		net_buf_simple_pull(buf, len);
	}
}
    c034:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	state->offset = net_buf_simple_headroom(buf);
    c038:	4620      	mov	r0, r4
    c03a:	f01c feb0 	bl	28d9e <net_buf_simple_headroom>
    c03e:	4606      	mov	r6, r0
		type = net_buf_simple_pull_u8(buf);
    c040:	4620      	mov	r0, r4
	state->len = buf->len;
    c042:	f8b4 8004 	ldrh.w	r8, [r4, #4]
    c046:	f01c fe86 	bl	28d56 <net_buf_simple_pull_u8>
		buf->len = len - 1;
    c04a:	1e6b      	subs	r3, r5, #1
		switch (type) {
    c04c:	282a      	cmp	r0, #42	; 0x2a
		buf->len = len - 1;
    c04e:	80a3      	strh	r3, [r4, #4]
		switch (type) {
    c050:	d007      	beq.n	c062 <bt_mesh_scan_cb+0x3a>
    c052:	282b      	cmp	r0, #43	; 0x2b
    c054:	d02d      	beq.n	c0b2 <bt_mesh_scan_cb+0x8a>
    c056:	2829      	cmp	r0, #41	; 0x29
    c058:	d108      	bne.n	c06c <bt_mesh_scan_cb+0x44>
			bt_mesh_pb_adv_recv(buf);
    c05a:	4620      	mov	r0, r4
    c05c:	f00b f802 	bl	17064 <bt_mesh_pb_adv_recv>
			break;
    c060:	e004      	b.n	c06c <bt_mesh_scan_cb+0x44>
			bt_mesh_net_recv(buf, rssi, BT_MESH_NET_IF_ADV);
    c062:	2200      	movs	r2, #0
    c064:	4639      	mov	r1, r7
    c066:	4620      	mov	r0, r4
    c068:	f001 fbfa 	bl	d860 <bt_mesh_net_recv>
	buf->data = buf->__buf + state->offset;
    c06c:	68a0      	ldr	r0, [r4, #8]
	buf->len = state->len;
    c06e:	f8a4 8004 	strh.w	r8, [r4, #4]
	buf->data = buf->__buf + state->offset;
    c072:	fa10 f686 	uxtah	r6, r0, r6
    c076:	6026      	str	r6, [r4, #0]
		net_buf_simple_pull(buf, len);
    c078:	4629      	mov	r1, r5
    c07a:	4620      	mov	r0, r4
    c07c:	f013 f8ea 	bl	1f254 <net_buf_simple_pull>
	while (buf->len > 1) {
    c080:	88a3      	ldrh	r3, [r4, #4]
    c082:	2b01      	cmp	r3, #1
    c084:	d9d6      	bls.n	c034 <bt_mesh_scan_cb+0xc>
		len = net_buf_simple_pull_u8(buf);
    c086:	4620      	mov	r0, r4
    c088:	f01c fe65 	bl	28d56 <net_buf_simple_pull_u8>
		if (len == 0U) {
    c08c:	4605      	mov	r5, r0
    c08e:	2800      	cmp	r0, #0
    c090:	d0d0      	beq.n	c034 <bt_mesh_scan_cb+0xc>
		if (len > buf->len) {
    c092:	88a2      	ldrh	r2, [r4, #4]
    c094:	b283      	uxth	r3, r0
    c096:	429a      	cmp	r2, r3
    c098:	d2ce      	bcs.n	c038 <bt_mesh_scan_cb+0x10>
    c09a:	4908      	ldr	r1, [pc, #32]	; (c0bc <bt_mesh_scan_cb+0x94>)
    c09c:	4b08      	ldr	r3, [pc, #32]	; (c0c0 <bt_mesh_scan_cb+0x98>)
			BT_WARN("AD malformed");
    c09e:	4809      	ldr	r0, [pc, #36]	; (c0c4 <bt_mesh_scan_cb+0x9c>)
    c0a0:	1ac9      	subs	r1, r1, r3
    c0a2:	08c9      	lsrs	r1, r1, #3
    c0a4:	0189      	lsls	r1, r1, #6
}
    c0a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			BT_WARN("AD malformed");
    c0aa:	f041 0102 	orr.w	r1, r1, #2
    c0ae:	f017 bf89 	b.w	23fc4 <log_0>
			bt_mesh_beacon_recv(buf);
    c0b2:	4620      	mov	r0, r4
    c0b4:	f000 fa8c 	bl	c5d0 <bt_mesh_beacon_recv>
			break;
    c0b8:	e7d8      	b.n	c06c <bt_mesh_scan_cb+0x44>
    c0ba:	bf00      	nop
    c0bc:	00029910 	.word	0x00029910
    c0c0:	00029830 	.word	0x00029830
    c0c4:	0002cd80 	.word	0x0002cd80

0000c0c8 <bt_mesh_adv_update>:
	z_impl_k_queue_cancel_wait(queue);
    c0c8:	4801      	ldr	r0, [pc, #4]	; (c0d0 <bt_mesh_adv_update+0x8>)
    c0ca:	f014 bf4d 	b.w	20f68 <z_impl_k_queue_cancel_wait>
    c0ce:	bf00      	nop
    c0d0:	20007648 	.word	0x20007648

0000c0d4 <bt_mesh_adv_create_from_pool>:
{
    c0d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c0d8:	461e      	mov	r6, r3
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    c0da:	4b17      	ldr	r3, [pc, #92]	; (c138 <bt_mesh_adv_create_from_pool+0x64>)
    c0dc:	f3bf 8f5b 	dmb	ish
    c0e0:	681b      	ldr	r3, [r3, #0]
    c0e2:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_SUSPENDED)) {
    c0e6:	f3c3 0840 	ubfx	r8, r3, #1, #1
    c0ea:	079b      	lsls	r3, r3, #30
{
    c0ec:	460d      	mov	r5, r1
    c0ee:	4617      	mov	r7, r2
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_SUSPENDED)) {
    c0f0:	d50d      	bpl.n	c10e <bt_mesh_adv_create_from_pool+0x3a>
    c0f2:	4b12      	ldr	r3, [pc, #72]	; (c13c <bt_mesh_adv_create_from_pool+0x68>)
    c0f4:	4912      	ldr	r1, [pc, #72]	; (c140 <bt_mesh_adv_create_from_pool+0x6c>)
		BT_WARN("Refusing to allocate buffer while suspended");
    c0f6:	4813      	ldr	r0, [pc, #76]	; (c144 <bt_mesh_adv_create_from_pool+0x70>)
    c0f8:	1ac9      	subs	r1, r1, r3
    c0fa:	08c9      	lsrs	r1, r1, #3
    c0fc:	0189      	lsls	r1, r1, #6
    c0fe:	f041 0102 	orr.w	r1, r1, #2
    c102:	f017 ff5f 	bl	23fc4 <log_0>
		return NULL;
    c106:	2400      	movs	r4, #0
}
    c108:	4620      	mov	r0, r4
    c10a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	buf = net_buf_alloc(pool, timeout);
    c10e:	9906      	ldr	r1, [sp, #24]
    c110:	f01c fdf3 	bl	28cfa <net_buf_alloc_fixed>
	if (!buf) {
    c114:	4604      	mov	r4, r0
    c116:	2800      	cmp	r0, #0
    c118:	d0f6      	beq.n	c108 <bt_mesh_adv_create_from_pool+0x34>
	adv = get_id(net_buf_id(buf));
    c11a:	f012 fdab 	bl	1ec74 <net_buf_id>
    c11e:	47a8      	blx	r5
    c120:	4605      	mov	r5, r0
	BT_MESH_ADV(buf) = adv;
    c122:	6160      	str	r0, [r4, #20]
	(void)memset(adv, 0, sizeof(*adv));
    c124:	220c      	movs	r2, #12
    c126:	4641      	mov	r1, r8
    c128:	f019 fde9 	bl	25cfe <memset>
	adv->type         = type;
    c12c:	7a2b      	ldrb	r3, [r5, #8]
	adv->xmit         = xmit;
    c12e:	726e      	strb	r6, [r5, #9]
	adv->type         = type;
    c130:	f367 0301 	bfi	r3, r7, #0, #2
    c134:	722b      	strb	r3, [r5, #8]
	return buf;
    c136:	e7e7      	b.n	c108 <bt_mesh_adv_create_from_pool+0x34>
    c138:	20006b50 	.word	0x20006b50
    c13c:	00029830 	.word	0x00029830
    c140:	00029910 	.word	0x00029910
    c144:	0002cd8d 	.word	0x0002cd8d

0000c148 <bt_mesh_adv_create>:
{
    c148:	b507      	push	{r0, r1, r2, lr}
    c14a:	460b      	mov	r3, r1
	return bt_mesh_adv_create_from_pool(&adv_buf_pool, adv_alloc, type,
    c14c:	9200      	str	r2, [sp, #0]
    c14e:	4904      	ldr	r1, [pc, #16]	; (c160 <bt_mesh_adv_create+0x18>)
    c150:	4602      	mov	r2, r0
    c152:	4804      	ldr	r0, [pc, #16]	; (c164 <bt_mesh_adv_create+0x1c>)
    c154:	f7ff ffbe 	bl	c0d4 <bt_mesh_adv_create_from_pool>
}
    c158:	b003      	add	sp, #12
    c15a:	f85d fb04 	ldr.w	pc, [sp], #4
    c15e:	bf00      	nop
    c160:	0000bed9 	.word	0x0000bed9
    c164:	20007694 	.word	0x20007694

0000c168 <bt_mesh_adv_send>:
{
    c168:	b510      	push	{r4, lr}
	BT_MESH_ADV(buf)->cb = cb;
    c16a:	6944      	ldr	r4, [r0, #20]
	BT_MESH_ADV(buf)->cb_data = cb_data;
    c16c:	e9c4 1200 	strd	r1, r2, [r4]
	BT_MESH_ADV(buf)->busy = 1U;
    c170:	6942      	ldr	r2, [r0, #20]
    c172:	7a13      	ldrb	r3, [r2, #8]
    c174:	f043 0304 	orr.w	r3, r3, #4
    c178:	7213      	strb	r3, [r2, #8]
	net_buf_put(&adv_queue, net_buf_ref(buf));
    c17a:	f012 ffed 	bl	1f158 <net_buf_ref>
}
    c17e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	net_buf_put(&adv_queue, net_buf_ref(buf));
    c182:	4601      	mov	r1, r0
    c184:	4801      	ldr	r0, [pc, #4]	; (c18c <bt_mesh_adv_send+0x24>)
    c186:	f012 bf6b 	b.w	1f060 <net_buf_put>
    c18a:	bf00      	nop
    c18c:	20007648 	.word	0x20007648

0000c190 <bt_mesh_adv_init>:

void bt_mesh_adv_init(void)
{
    c190:	b510      	push	{r4, lr}
    c192:	b086      	sub	sp, #24
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    c194:	4c0b      	ldr	r4, [pc, #44]	; (c1c4 <bt_mesh_adv_init+0x34>)
    c196:	490c      	ldr	r1, [pc, #48]	; (c1c8 <bt_mesh_adv_init+0x38>)
    c198:	2300      	movs	r3, #0
    c19a:	f06f 0208 	mvn.w	r2, #8
    c19e:	e9cd 3202 	strd	r3, r2, [sp, #8]
    c1a2:	e9cd 3304 	strd	r3, r3, [sp, #16]
    c1a6:	e9cd 3300 	strd	r3, r3, [sp]
    c1aa:	f44f 7240 	mov.w	r2, #768	; 0x300
    c1ae:	4b07      	ldr	r3, [pc, #28]	; (c1cc <bt_mesh_adv_init+0x3c>)
    c1b0:	4620      	mov	r0, r4
    c1b2:	f016 fb97 	bl	228e4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    c1b6:	4906      	ldr	r1, [pc, #24]	; (c1d0 <bt_mesh_adv_init+0x40>)
    c1b8:	4620      	mov	r0, r4
	k_thread_create(&adv_thread_data, adv_thread_stack,
			K_THREAD_STACK_SIZEOF(adv_thread_stack), adv_thread,
			NULL, NULL, NULL, K_PRIO_COOP(7), 0, K_NO_WAIT);
	k_thread_name_set(&adv_thread_data, "BT Mesh adv");
}
    c1ba:	b006      	add	sp, #24
    c1bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    c1c0:	f016 bb56 	b.w	22870 <z_impl_k_thread_name_set>
    c1c4:	20000814 	.word	0x20000814
    c1c8:	20002f20 	.word	0x20002f20
    c1cc:	0000bee9 	.word	0x0000bee9
    c1d0:	0002cdb9 	.word	0x0002cdb9

0000c1d4 <bt_mesh_scan_enable>:

int bt_mesh_scan_enable(void)
{
    c1d4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct bt_le_scan_param scan_param = {
    c1d6:	2214      	movs	r2, #20
    c1d8:	2100      	movs	r1, #0
    c1da:	a801      	add	r0, sp, #4
    c1dc:	f019 fd8f 	bl	25cfe <memset>
			.window     = MESH_SCAN_WINDOW };
	int err;

	BT_DBG("");

	err = bt_le_scan_start(&scan_param, bt_mesh_scan_cb);
    c1e0:	4913      	ldr	r1, [pc, #76]	; (c230 <bt_mesh_scan_enable+0x5c>)
	struct bt_le_scan_param scan_param = {
    c1e2:	f04f 1330 	mov.w	r3, #3145776	; 0x300030
	err = bt_le_scan_start(&scan_param, bt_mesh_scan_cb);
    c1e6:	a801      	add	r0, sp, #4
	struct bt_le_scan_param scan_param = {
    c1e8:	9303      	str	r3, [sp, #12]
	err = bt_le_scan_start(&scan_param, bt_mesh_scan_cb);
    c1ea:	f7fc faf5 	bl	87d8 <bt_le_scan_start>
	if (err && err != -EALREADY) {
    c1ee:	4601      	mov	r1, r0
    c1f0:	b1c8      	cbz	r0, c226 <bt_mesh_scan_enable+0x52>
    c1f2:	f110 0f45 	cmn.w	r0, #69	; 0x45
    c1f6:	d016      	beq.n	c226 <bt_mesh_scan_enable+0x52>
    c1f8:	4b0e      	ldr	r3, [pc, #56]	; (c234 <bt_mesh_scan_enable+0x60>)
    c1fa:	4a0f      	ldr	r2, [pc, #60]	; (c238 <bt_mesh_scan_enable+0x64>)
		BT_ERR("starting scan failed (err %d)", err);
    c1fc:	480f      	ldr	r0, [pc, #60]	; (c23c <bt_mesh_scan_enable+0x68>)
    c1fe:	1ad2      	subs	r2, r2, r3
    c200:	08d2      	lsrs	r2, r2, #3
    c202:	0192      	lsls	r2, r2, #6
    c204:	f042 0201 	orr.w	r2, r2, #1
    c208:	f017 fee9 	bl	23fde <log_1>
  __ASM volatile ("dsb 0xF":::"memory");
    c20c:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    c210:	490b      	ldr	r1, [pc, #44]	; (c240 <bt_mesh_scan_enable+0x6c>)
    c212:	4b0c      	ldr	r3, [pc, #48]	; (c244 <bt_mesh_scan_enable+0x70>)
    c214:	68ca      	ldr	r2, [r1, #12]
    c216:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    c21a:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    c21c:	60cb      	str	r3, [r1, #12]
    c21e:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    c222:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    c224:	e7fd      	b.n	c222 <bt_mesh_scan_enable+0x4e>
		NVIC_SystemReset();
		return err;
	}

	return 0;
}
    c226:	2000      	movs	r0, #0
    c228:	b007      	add	sp, #28
    c22a:	f85d fb04 	ldr.w	pc, [sp], #4
    c22e:	bf00      	nop
    c230:	0000c029 	.word	0x0000c029
    c234:	00029830 	.word	0x00029830
    c238:	00029910 	.word	0x00029910
    c23c:	0002cdc5 	.word	0x0002cdc5
    c240:	e000ed00 	.word	0xe000ed00
    c244:	05fa0004 	.word	0x05fa0004

0000c248 <bt_mesh_scan_disable>:

int bt_mesh_scan_disable(void)
{
    c248:	b510      	push	{r4, lr}
	int err;

	BT_DBG("");

	err = bt_le_scan_stop();
    c24a:	f7fc fb73 	bl	8934 <bt_le_scan_stop>
	if (err && err != -EALREADY) {
    c24e:	4604      	mov	r4, r0
    c250:	b168      	cbz	r0, c26e <bt_mesh_scan_disable+0x26>
    c252:	f110 0f45 	cmn.w	r0, #69	; 0x45
    c256:	d00c      	beq.n	c272 <bt_mesh_scan_disable+0x2a>
    c258:	4a07      	ldr	r2, [pc, #28]	; (c278 <bt_mesh_scan_disable+0x30>)
    c25a:	4b08      	ldr	r3, [pc, #32]	; (c27c <bt_mesh_scan_disable+0x34>)
    c25c:	1ad2      	subs	r2, r2, r3
    c25e:	08d2      	lsrs	r2, r2, #3
		BT_ERR("stopping scan failed (err %d)", err);
    c260:	0192      	lsls	r2, r2, #6
    c262:	4601      	mov	r1, r0
    c264:	f042 0201 	orr.w	r2, r2, #1
    c268:	4805      	ldr	r0, [pc, #20]	; (c280 <bt_mesh_scan_disable+0x38>)
    c26a:	f017 feb8 	bl	23fde <log_1>
		return err;
	}

	return 0;
}
    c26e:	4620      	mov	r0, r4
    c270:	bd10      	pop	{r4, pc}
	return 0;
    c272:	2400      	movs	r4, #0
    c274:	e7fb      	b.n	c26e <bt_mesh_scan_disable+0x26>
    c276:	bf00      	nop
    c278:	00029910 	.word	0x00029910
    c27c:	00029830 	.word	0x00029830
    c280:	0002cde3 	.word	0x0002cde3

0000c284 <k_work_submit_to_queue.constprop.0>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    c284:	4909      	ldr	r1, [pc, #36]	; (c2ac <k_work_submit_to_queue.constprop.0+0x28>)
    c286:	f3bf 8f5b 	dmb	ish
    c28a:	e851 3f00 	ldrex	r3, [r1]
    c28e:	f043 0201 	orr.w	r2, r3, #1
    c292:	e841 2000 	strex	r0, r2, [r1]
    c296:	2800      	cmp	r0, #0
    c298:	d1f7      	bne.n	c28a <k_work_submit_to_queue.constprop.0+0x6>
    c29a:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    c29e:	07db      	lsls	r3, r3, #31
    c2a0:	d403      	bmi.n	c2aa <k_work_submit_to_queue.constprop.0+0x26>
		k_queue_append(&work_q->queue, work);
    c2a2:	4803      	ldr	r0, [pc, #12]	; (c2b0 <k_work_submit_to_queue.constprop.0+0x2c>)
    c2a4:	3908      	subs	r1, #8
    c2a6:	f01c bfd4 	b.w	29252 <k_queue_append>
}
    c2aa:	4770      	bx	lr
    c2ac:	200008b0 	.word	0x200008b0
    c2b0:	20001dc4 	.word	0x20001dc4

0000c2b4 <bt_mesh_beacon_create>:
	sub->beacon_sent = k_uptime_get_32();
}

void bt_mesh_beacon_create(struct bt_mesh_subnet *sub,
			   struct net_buf_simple *buf)
{
    c2b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c2b6:	460c      	mov	r4, r1
    c2b8:	4605      	mov	r5, r0
	u8_t flags = bt_mesh_net_flags(sub);
    c2ba:	f01a fec6 	bl	2704a <bt_mesh_net_flags>
	struct bt_mesh_subnet_keys *keys;

	net_buf_simple_add_u8(buf, BEACON_TYPE_SECURE);
    c2be:	2101      	movs	r1, #1
	u8_t flags = bt_mesh_net_flags(sub);
    c2c0:	4606      	mov	r6, r0
	net_buf_simple_add_u8(buf, BEACON_TYPE_SECURE);
    c2c2:	4620      	mov	r0, r4
    c2c4:	f01c fd83 	bl	28dce <net_buf_simple_add_u8>

	if (sub->kr_flag) {
    c2c8:	7fab      	ldrb	r3, [r5, #30]
    c2ca:	b1c3      	cbz	r3, c2fe <bt_mesh_beacon_create+0x4a>
		keys = &sub->keys[1];
    c2cc:	f105 0789 	add.w	r7, r5, #137	; 0x89
	} else {
		keys = &sub->keys[0];
	}

	net_buf_simple_add_u8(buf, flags);
    c2d0:	4631      	mov	r1, r6
    c2d2:	4620      	mov	r0, r4
    c2d4:	f01c fd7b 	bl	28dce <net_buf_simple_add_u8>

	/* Network ID */
	net_buf_simple_add_mem(buf, keys->net_id, 8);
    c2d8:	2208      	movs	r2, #8
    c2da:	f107 0121 	add.w	r1, r7, #33	; 0x21
    c2de:	4620      	mov	r0, r4
    c2e0:	f01c fd69 	bl	28db6 <net_buf_simple_add_mem>

	/* IV Index */
	net_buf_simple_add_be32(buf, bt_mesh.iv_index);
    c2e4:	4b07      	ldr	r3, [pc, #28]	; (c304 <bt_mesh_beacon_create+0x50>)
    c2e6:	4620      	mov	r0, r4
    c2e8:	6819      	ldr	r1, [r3, #0]
    c2ea:	f01c fd95 	bl	28e18 <net_buf_simple_add_be32>

	net_buf_simple_add_mem(buf, sub->auth, 8);
    c2ee:	f105 0128 	add.w	r1, r5, #40	; 0x28
    c2f2:	4620      	mov	r0, r4
    c2f4:	2208      	movs	r2, #8

	BT_DBG("net_idx 0x%04x flags 0x%02x NetID %s", sub->net_idx,
	       flags, bt_hex(keys->net_id, 8));
	BT_DBG("IV Index 0x%08x Auth %s", bt_mesh.iv_index,
	       bt_hex(sub->auth, 8));
}
    c2f6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	net_buf_simple_add_mem(buf, sub->auth, 8);
    c2fa:	f01c bd5c 	b.w	28db6 <net_buf_simple_add_mem>
		keys = &sub->keys[0];
    c2fe:	f105 0730 	add.w	r7, r5, #48	; 0x30
    c302:	e7e5      	b.n	c2d0 <bt_mesh_beacon_create+0x1c>
    c304:	20006b48 	.word	0x20006b48

0000c308 <beacon_send>:
		sub->beacons_cur = 0U;
	}
}

static void beacon_send(struct k_work *work)
{
    c308:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c30c:	b08b      	sub	sp, #44	; 0x2c
	/* Don't send anything if we have an active provisioning link */
	if (IS_ENABLED(CONFIG_BT_MESH_PROV) && bt_prov_active()) {
    c30e:	f01b fdef 	bl	27ef0 <bt_prov_active>
    c312:	b110      	cbz	r0, c31a <beacon_send+0x12>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    c314:	f241 3288 	movw	r2, #5000	; 0x1388
    c318:	e065      	b.n	c3e6 <beacon_send+0xde>
		return;
	}

	BT_DBG("");

	if (bt_mesh_is_provisioned()) {
    c31a:	f7ff fd47 	bl	bdac <bt_mesh_is_provisioned>
    c31e:	4604      	mov	r4, r0
    c320:	2800      	cmp	r0, #0
    c322:	f000 8085 	beq.w	c430 <beacon_send+0x128>
	first_half = !first_half;
    c326:	4b85      	ldr	r3, [pc, #532]	; (c53c <beacon_send+0x234>)
    c328:	781a      	ldrb	r2, [r3, #0]
    c32a:	f082 0201 	eor.w	r2, r2, #1
    c32e:	701a      	strb	r2, [r3, #0]
	if (first_half) {
    c330:	4b83      	ldr	r3, [pc, #524]	; (c540 <beacon_send+0x238>)
    c332:	b9ca      	cbnz	r2, c368 <beacon_send+0x60>
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    c334:	f8b3 01b8 	ldrh.w	r0, [r3, #440]	; 0x1b8
    c338:	f64f 71ff 	movw	r1, #65535	; 0xffff
    c33c:	4288      	cmp	r0, r1
		sub->beacons_last = sub->beacons_cur;
    c33e:	bf1c      	itt	ne
    c340:	f893 11a1 	ldrbne.w	r1, [r3, #417]	; 0x1a1
    c344:	f883 11a0 	strbne.w	r1, [r3, #416]	; 0x1a0
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    c348:	f8b3 129c 	ldrh.w	r1, [r3, #668]	; 0x29c
		sub->beacons_cur = 0U;
    c34c:	bf18      	it	ne
    c34e:	f883 21a1 	strbne.w	r2, [r3, #417]	; 0x1a1
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    c352:	f64f 72ff 	movw	r2, #65535	; 0xffff
    c356:	4291      	cmp	r1, r2
		sub->beacons_last = sub->beacons_cur;
    c358:	bf1f      	itttt	ne
    c35a:	f893 2285 	ldrbne.w	r2, [r3, #645]	; 0x285
    c35e:	f883 2284 	strbne.w	r2, [r3, #644]	; 0x284
		sub->beacons_cur = 0U;
    c362:	2200      	movne	r2, #0
    c364:	f883 2285 	strbne.w	r2, [r3, #645]	; 0x285
	return z_impl_k_uptime_ticks();
    c368:	f01d f853 	bl	29412 <z_impl_k_uptime_ticks>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
    c36c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    c370:	460a      	mov	r2, r1
    c372:	fba0 0103 	umull	r0, r1, r0, r3
    c376:	fb03 1102 	mla	r1, r3, r2, r1
    c37a:	0bc4      	lsrs	r4, r0, #15
    c37c:	f8df 91c0 	ldr.w	r9, [pc, #448]	; c540 <beacon_send+0x238>
		if (time_diff < K_SECONDS(600) &&
    c380:	4f70      	ldr	r7, [pc, #448]	; (c544 <beacon_send+0x23c>)
		bt_mesh_adv_send(buf, &send_cb, sub);
    c382:	f8df 81e4 	ldr.w	r8, [pc, #484]	; c568 <beacon_send+0x260>
    c386:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
    c38a:	2500      	movs	r5, #0
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    c38c:	f64f 76ff 	movw	r6, #65535	; 0xffff
    c390:	f8b9 31b8 	ldrh.w	r3, [r9, #440]	; 0x1b8
    c394:	42b3      	cmp	r3, r6
    c396:	d03a      	beq.n	c40e <beacon_send+0x106>
		time_diff = now - sub->beacon_sent;
    c398:	f8d9 219c 	ldr.w	r2, [r9, #412]	; 0x19c
    c39c:	1aa2      	subs	r2, r4, r2
		if (time_diff < K_SECONDS(600) &&
    c39e:	42ba      	cmp	r2, r7
    c3a0:	d80a      	bhi.n	c3b8 <beacon_send+0xb0>
		    time_diff < BEACON_THRESHOLD(sub)) {
    c3a2:	f899 11a0 	ldrb.w	r1, [r9, #416]	; 0x1a0
    c3a6:	f242 7310 	movw	r3, #10000	; 0x2710
    c3aa:	fb01 3303 	mla	r3, r1, r3, r3
    c3ae:	f5a3 539c 	sub.w	r3, r3, #4992	; 0x1380
    c3b2:	3b08      	subs	r3, #8
		if (time_diff < K_SECONDS(600) &&
    c3b4:	429a      	cmp	r2, r3
    c3b6:	d32a      	bcc.n	c40e <beacon_send+0x106>
		buf = bt_mesh_adv_create(BT_MESH_ADV_BEACON, PROV_XMIT,
    c3b8:	2200      	movs	r2, #0
    c3ba:	2108      	movs	r1, #8
    c3bc:	2002      	movs	r0, #2
    c3be:	f7ff fec3 	bl	c148 <bt_mesh_adv_create>
		if (!buf) {
    c3c2:	4682      	mov	sl, r0
    c3c4:	b9a0      	cbnz	r0, c3f0 <beacon_send+0xe8>
    c3c6:	4960      	ldr	r1, [pc, #384]	; (c548 <beacon_send+0x240>)
    c3c8:	4b60      	ldr	r3, [pc, #384]	; (c54c <beacon_send+0x244>)
			BT_ERR("Unable to allocate beacon buffer");
    c3ca:	4861      	ldr	r0, [pc, #388]	; (c550 <beacon_send+0x248>)
    c3cc:	1ac9      	subs	r1, r1, r3
    c3ce:	08c9      	lsrs	r1, r1, #3
    c3d0:	0189      	lsls	r1, r1, #6
    c3d2:	f041 0101 	orr.w	r1, r1, #1
    c3d6:	f017 fdf5 	bl	23fc4 <log_0>
		update_beacon_observation();
		secure_beacon_send();

		/* Only resubmit if beaconing is still enabled */
		if (bt_mesh_beacon_get() == BT_MESH_BEACON_ENABLED ||
    c3da:	f006 f84b 	bl	12474 <bt_mesh_beacon_get>
    c3de:	2801      	cmp	r0, #1
    c3e0:	d11b      	bne.n	c41a <beacon_send+0x112>
    c3e2:	f242 7210 	movw	r2, #10000	; 0x2710
    c3e6:	495b      	ldr	r1, [pc, #364]	; (c554 <beacon_send+0x24c>)
    c3e8:	485b      	ldr	r0, [pc, #364]	; (c558 <beacon_send+0x250>)
    c3ea:	f016 fbb9 	bl	22b60 <k_delayed_work_submit_to_queue>
    c3ee:	e01c      	b.n	c42a <beacon_send+0x122>
    c3f0:	f509 7bce 	add.w	fp, r9, #412	; 0x19c
		bt_mesh_beacon_create(sub, &buf->b);
    c3f4:	f100 0108 	add.w	r1, r0, #8
    c3f8:	4658      	mov	r0, fp
    c3fa:	f7ff ff5b 	bl	c2b4 <bt_mesh_beacon_create>
		bt_mesh_adv_send(buf, &send_cb, sub);
    c3fe:	4650      	mov	r0, sl
    c400:	465a      	mov	r2, fp
    c402:	4641      	mov	r1, r8
    c404:	f7ff feb0 	bl	c168 <bt_mesh_adv_send>
		net_buf_unref(buf);
    c408:	4650      	mov	r0, sl
    c40a:	f012 fe5d 	bl	1f0c8 <net_buf_unref>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
    c40e:	f109 09e4 	add.w	r9, r9, #228	; 0xe4
    c412:	2d00      	cmp	r5, #0
    c414:	d1e1      	bne.n	c3da <beacon_send+0xd2>
    c416:	2501      	movs	r5, #1
    c418:	e7ba      	b.n	c390 <beacon_send+0x88>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    c41a:	4b50      	ldr	r3, [pc, #320]	; (c55c <beacon_send+0x254>)
    c41c:	f3bf 8f5b 	dmb	ish
    c420:	681b      	ldr	r3, [r3, #0]
    c422:	f3bf 8f5b 	dmb	ish
		if (bt_mesh_beacon_get() == BT_MESH_BEACON_ENABLED ||
    c426:	071b      	lsls	r3, r3, #28
    c428:	d4db      	bmi.n	c3e2 <beacon_send+0xda>
		}
	} else if (IS_ENABLED(CONFIG_BT_MESH_PB_ADV)) {
		unprovisioned_beacon_send();
		k_delayed_work_submit(&beacon_timer, UNPROVISIONED_INTERVAL);
	}
}
    c42a:	b00b      	add	sp, #44	; 0x2c
    c42c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	u8_t uri_hash[16] = { 0 };
    c430:	e9cd 0002 	strd	r0, r0, [sp, #8]
    c434:	e9cd 0004 	strd	r0, r0, [sp, #16]
	buf = bt_mesh_adv_create(BT_MESH_ADV_BEACON, UNPROV_XMIT, K_NO_WAIT);
    c438:	4602      	mov	r2, r0
    c43a:	210a      	movs	r1, #10
    c43c:	2002      	movs	r0, #2
    c43e:	f7ff fe83 	bl	c148 <bt_mesh_adv_create>
	if (!buf) {
    c442:	4606      	mov	r6, r0
    c444:	b950      	cbnz	r0, c45c <beacon_send+0x154>
    c446:	4940      	ldr	r1, [pc, #256]	; (c548 <beacon_send+0x240>)
    c448:	4b40      	ldr	r3, [pc, #256]	; (c54c <beacon_send+0x244>)
		BT_ERR("Unable to allocate beacon buffer");
    c44a:	4841      	ldr	r0, [pc, #260]	; (c550 <beacon_send+0x248>)
    c44c:	1ac9      	subs	r1, r1, r3
    c44e:	08c9      	lsrs	r1, r1, #3
    c450:	0189      	lsls	r1, r1, #6
    c452:	f041 0101 	orr.w	r1, r1, #1
			BT_ERR("Unable to allocate URI buffer");
    c456:	f017 fdb5 	bl	23fc4 <log_0>
			return -ENOBUFS;
    c45a:	e75b      	b.n	c314 <beacon_send+0xc>
	prov = bt_mesh_prov_get();
    c45c:	f00a f85c 	bl	16518 <bt_mesh_prov_get>
	net_buf_add_u8(buf, BEACON_TYPE_UNPROVISIONED);
    c460:	f106 0708 	add.w	r7, r6, #8
	prov = bt_mesh_prov_get();
    c464:	4605      	mov	r5, r0
	net_buf_add_u8(buf, BEACON_TYPE_UNPROVISIONED);
    c466:	4621      	mov	r1, r4
    c468:	4638      	mov	r0, r7
    c46a:	f01c fcb0 	bl	28dce <net_buf_simple_add_u8>
	net_buf_add_mem(buf, prov->uuid, 16);
    c46e:	6829      	ldr	r1, [r5, #0]
    c470:	2210      	movs	r2, #16
    c472:	4638      	mov	r0, r7
    c474:	f01c fc9f 	bl	28db6 <net_buf_simple_add_mem>
	if (prov->uri && bt_mesh_s1(prov->uri, uri_hash) == 0) {
    c478:	f8d5 8004 	ldr.w	r8, [r5, #4]
    c47c:	f1b8 0f00 	cmp.w	r8, #0
    c480:	d036      	beq.n	c4f0 <beacon_send+0x1e8>

static inline bool bt_mesh_s1(const char *m, u8_t salt[16])
{
	const u8_t zero[16] = { 0 };

	return bt_mesh_aes_cmac_one(zero, m, strlen(m), salt);
    c482:	4640      	mov	r0, r8
	const u8_t zero[16] = { 0 };
    c484:	e9cd 4406 	strd	r4, r4, [sp, #24]
    c488:	e9cd 4408 	strd	r4, r4, [sp, #32]
	return bt_mesh_aes_cmac_one(zero, m, strlen(m), salt);
    c48c:	f019 fbda 	bl	25c44 <strlen>
	return bt_mesh_aes_cmac(key, &sg, 1, mac);
    c490:	ab02      	add	r3, sp, #8
	struct bt_mesh_sg sg = { m, len };
    c492:	e9cd 8000 	strd	r8, r0, [sp]
	return bt_mesh_aes_cmac(key, &sg, 1, mac);
    c496:	2201      	movs	r2, #1
    c498:	4669      	mov	r1, sp
    c49a:	a806      	add	r0, sp, #24
    c49c:	f01a ff7b 	bl	27396 <bt_mesh_aes_cmac>
    c4a0:	bb30      	cbnz	r0, c4f0 <beacon_send+0x1e8>
		oob_info = prov->oob_info | BT_MESH_PROV_OOB_URI;
    c4a2:	8929      	ldrh	r1, [r5, #8]
    c4a4:	f041 0102 	orr.w	r1, r1, #2
	net_buf_add_be16(buf, oob_info);
    c4a8:	4638      	mov	r0, r7
    c4aa:	f01c fca0 	bl	28dee <net_buf_simple_add_be16>
	net_buf_add_mem(buf, uri_hash, 4);
    c4ae:	2204      	movs	r2, #4
    c4b0:	a902      	add	r1, sp, #8
    c4b2:	4638      	mov	r0, r7
    c4b4:	f01c fc7f 	bl	28db6 <net_buf_simple_add_mem>
	bt_mesh_adv_send(buf, NULL, NULL);
    c4b8:	2200      	movs	r2, #0
    c4ba:	4611      	mov	r1, r2
    c4bc:	4630      	mov	r0, r6
    c4be:	f7ff fe53 	bl	c168 <bt_mesh_adv_send>
	net_buf_unref(buf);
    c4c2:	4630      	mov	r0, r6
    c4c4:	f012 fe00 	bl	1f0c8 <net_buf_unref>
	if (prov->uri) {
    c4c8:	686b      	ldr	r3, [r5, #4]
    c4ca:	2b00      	cmp	r3, #0
    c4cc:	f43f af22 	beq.w	c314 <beacon_send+0xc>
		buf = bt_mesh_adv_create(BT_MESH_ADV_URI, UNPROV_XMIT,
    c4d0:	2200      	movs	r2, #0
    c4d2:	210a      	movs	r1, #10
    c4d4:	2003      	movs	r0, #3
    c4d6:	f7ff fe37 	bl	c148 <bt_mesh_adv_create>
		if (!buf) {
    c4da:	4604      	mov	r4, r0
    c4dc:	b950      	cbnz	r0, c4f4 <beacon_send+0x1ec>
    c4de:	491a      	ldr	r1, [pc, #104]	; (c548 <beacon_send+0x240>)
    c4e0:	4b1a      	ldr	r3, [pc, #104]	; (c54c <beacon_send+0x244>)
			BT_ERR("Unable to allocate URI buffer");
    c4e2:	481f      	ldr	r0, [pc, #124]	; (c560 <beacon_send+0x258>)
    c4e4:	1ac9      	subs	r1, r1, r3
    c4e6:	08c9      	lsrs	r1, r1, #3
    c4e8:	0189      	lsls	r1, r1, #6
    c4ea:	f041 0101 	orr.w	r1, r1, #1
    c4ee:	e7b2      	b.n	c456 <beacon_send+0x14e>
		oob_info = prov->oob_info;
    c4f0:	8929      	ldrh	r1, [r5, #8]
    c4f2:	e7d9      	b.n	c4a8 <beacon_send+0x1a0>
		len = strlen(prov->uri);
    c4f4:	6868      	ldr	r0, [r5, #4]
    c4f6:	f019 fba5 	bl	25c44 <strlen>
		if (net_buf_tailroom(buf) < len) {
    c4fa:	f104 0708 	add.w	r7, r4, #8
		len = strlen(prov->uri);
    c4fe:	4606      	mov	r6, r0
		if (net_buf_tailroom(buf) < len) {
    c500:	4638      	mov	r0, r7
    c502:	f01c fc50 	bl	28da6 <net_buf_simple_tailroom>
    c506:	4286      	cmp	r6, r0
    c508:	d90d      	bls.n	c526 <beacon_send+0x21e>
    c50a:	490f      	ldr	r1, [pc, #60]	; (c548 <beacon_send+0x240>)
    c50c:	4b0f      	ldr	r3, [pc, #60]	; (c54c <beacon_send+0x244>)
			BT_WARN("Too long URI to fit advertising data");
    c50e:	4815      	ldr	r0, [pc, #84]	; (c564 <beacon_send+0x25c>)
    c510:	1ac9      	subs	r1, r1, r3
    c512:	08c9      	lsrs	r1, r1, #3
    c514:	0189      	lsls	r1, r1, #6
    c516:	f041 0102 	orr.w	r1, r1, #2
    c51a:	f017 fd53 	bl	23fc4 <log_0>
		net_buf_unref(buf);
    c51e:	4620      	mov	r0, r4
    c520:	f012 fdd2 	bl	1f0c8 <net_buf_unref>
    c524:	e6f6      	b.n	c314 <beacon_send+0xc>
			net_buf_add_mem(buf, prov->uri, len);
    c526:	6869      	ldr	r1, [r5, #4]
    c528:	4632      	mov	r2, r6
    c52a:	4638      	mov	r0, r7
    c52c:	f01c fc43 	bl	28db6 <net_buf_simple_add_mem>
			bt_mesh_adv_send(buf, NULL, NULL);
    c530:	2200      	movs	r2, #0
    c532:	4611      	mov	r1, r2
    c534:	4620      	mov	r0, r4
    c536:	f7ff fe17 	bl	c168 <bt_mesh_adv_send>
    c53a:	e7f0      	b.n	c51e <beacon_send+0x216>
    c53c:	200024bc 	.word	0x200024bc
    c540:	20006b48 	.word	0x20006b48
    c544:	000927bf 	.word	0x000927bf
    c548:	00029918 	.word	0x00029918
    c54c:	00029830 	.word	0x00029830
    c550:	0002ce11 	.word	0x0002ce11
    c554:	200008a8 	.word	0x200008a8
    c558:	20001dc4 	.word	0x20001dc4
    c55c:	20006b50 	.word	0x20006b50
    c560:	0002ce32 	.word	0x0002ce32
    c564:	0002ce50 	.word	0x0002ce50
    c568:	0002a094 	.word	0x0002a094

0000c56c <bt_mesh_beacon_init>:
	}
}

void bt_mesh_beacon_init(void)
{
	k_delayed_work_init(&beacon_timer, beacon_send);
    c56c:	4901      	ldr	r1, [pc, #4]	; (c574 <bt_mesh_beacon_init+0x8>)
    c56e:	4802      	ldr	r0, [pc, #8]	; (c578 <bt_mesh_beacon_init+0xc>)
    c570:	f01c bf43 	b.w	293fa <k_delayed_work_init>
    c574:	0000c309 	.word	0x0000c309
    c578:	200008a8 	.word	0x200008a8

0000c57c <bt_mesh_beacon_ivu_initiator>:
}

void bt_mesh_beacon_ivu_initiator(bool enable)
{
    c57c:	b508      	push	{r3, lr}
    c57e:	4b12      	ldr	r3, [pc, #72]	; (c5c8 <bt_mesh_beacon_ivu_initiator+0x4c>)
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    c580:	f3bf 8f5b 	dmb	ish
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	if (val) {
    c584:	b168      	cbz	r0, c5a2 <bt_mesh_beacon_ivu_initiator+0x26>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    c586:	e853 2f00 	ldrex	r2, [r3]
    c58a:	f042 0208 	orr.w	r2, r2, #8
    c58e:	e843 2100 	strex	r1, r2, [r3]
    c592:	2900      	cmp	r1, #0
    c594:	d1f7      	bne.n	c586 <bt_mesh_beacon_ivu_initiator+0xa>
    c596:	f3bf 8f5b 	dmb	ish
	if (enable) {
		k_work_submit(&beacon_timer.work);
	} else if (bt_mesh_beacon_get() == BT_MESH_BEACON_DISABLED) {
		k_delayed_work_cancel(&beacon_timer);
	}
}
    c59a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_work_submit_to_queue(&k_sys_work_q, work);
    c59e:	f7ff be71 	b.w	c284 <k_work_submit_to_queue.constprop.0>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    c5a2:	e853 2f00 	ldrex	r2, [r3]
    c5a6:	f022 0208 	bic.w	r2, r2, #8
    c5aa:	e843 2100 	strex	r1, r2, [r3]
    c5ae:	2900      	cmp	r1, #0
    c5b0:	d1f7      	bne.n	c5a2 <bt_mesh_beacon_ivu_initiator+0x26>
    c5b2:	f3bf 8f5b 	dmb	ish
	} else if (bt_mesh_beacon_get() == BT_MESH_BEACON_DISABLED) {
    c5b6:	f005 ff5d 	bl	12474 <bt_mesh_beacon_get>
    c5ba:	b920      	cbnz	r0, c5c6 <bt_mesh_beacon_ivu_initiator+0x4a>
}
    c5bc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		k_delayed_work_cancel(&beacon_timer);
    c5c0:	4802      	ldr	r0, [pc, #8]	; (c5cc <bt_mesh_beacon_ivu_initiator+0x50>)
    c5c2:	f016 bb5d 	b.w	22c80 <k_delayed_work_cancel>
}
    c5c6:	bd08      	pop	{r3, pc}
    c5c8:	20006b50 	.word	0x20006b50
    c5cc:	200008a8 	.word	0x200008a8

0000c5d0 <bt_mesh_beacon_recv>:
{
    c5d0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	if (buf->len < 1) {
    c5d4:	8883      	ldrh	r3, [r0, #4]
{
    c5d6:	4605      	mov	r5, r0
	if (buf->len < 1) {
    c5d8:	b953      	cbnz	r3, c5f0 <bt_mesh_beacon_recv+0x20>
    c5da:	4977      	ldr	r1, [pc, #476]	; (c7b8 <bt_mesh_beacon_recv+0x1e8>)
    c5dc:	4b77      	ldr	r3, [pc, #476]	; (c7bc <bt_mesh_beacon_recv+0x1ec>)
		BT_ERR("Too short beacon");
    c5de:	4878      	ldr	r0, [pc, #480]	; (c7c0 <bt_mesh_beacon_recv+0x1f0>)
    c5e0:	1ac9      	subs	r1, r1, r3
    c5e2:	08c9      	lsrs	r1, r1, #3
    c5e4:	0189      	lsls	r1, r1, #6
    c5e6:	f041 0101 	orr.w	r1, r1, #1
		BT_WARN("Ignoring Phase 2 KR Update secured using old key");
    c5ea:	f017 fceb 	bl	23fc4 <log_0>
		return;
    c5ee:	e038      	b.n	c662 <bt_mesh_beacon_recv+0x92>
	type = net_buf_simple_pull_u8(buf);
    c5f0:	f01c fbb1 	bl	28d56 <net_buf_simple_pull_u8>
	switch (type) {
    c5f4:	4604      	mov	r4, r0
    c5f6:	b158      	cbz	r0, c610 <bt_mesh_beacon_recv+0x40>
    c5f8:	2801      	cmp	r0, #1
    c5fa:	d035      	beq.n	c668 <bt_mesh_beacon_recv+0x98>
    c5fc:	4a6e      	ldr	r2, [pc, #440]	; (c7b8 <bt_mesh_beacon_recv+0x1e8>)
    c5fe:	4b6f      	ldr	r3, [pc, #444]	; (c7bc <bt_mesh_beacon_recv+0x1ec>)
    c600:	1ad2      	subs	r2, r2, r3
    c602:	08d2      	lsrs	r2, r2, #3
		BT_WARN("Unknown beacon type 0x%02x", type);
    c604:	0192      	lsls	r2, r2, #6
    c606:	4601      	mov	r1, r0
    c608:	f042 0202 	orr.w	r2, r2, #2
    c60c:	486d      	ldr	r0, [pc, #436]	; (c7c4 <bt_mesh_beacon_recv+0x1f4>)
    c60e:	e00c      	b.n	c62a <bt_mesh_beacon_recv+0x5a>
	if (buf->len != 18 && buf->len != 22) {
    c610:	88a9      	ldrh	r1, [r5, #4]
    c612:	f021 0304 	bic.w	r3, r1, #4
    c616:	2b12      	cmp	r3, #18
    c618:	d00a      	beq.n	c630 <bt_mesh_beacon_recv+0x60>
    c61a:	4a67      	ldr	r2, [pc, #412]	; (c7b8 <bt_mesh_beacon_recv+0x1e8>)
    c61c:	4b67      	ldr	r3, [pc, #412]	; (c7bc <bt_mesh_beacon_recv+0x1ec>)
		BT_ERR("Invalid unprovisioned beacon length (%u)", buf->len);
    c61e:	486a      	ldr	r0, [pc, #424]	; (c7c8 <bt_mesh_beacon_recv+0x1f8>)
    c620:	1ad2      	subs	r2, r2, r3
    c622:	08d2      	lsrs	r2, r2, #3
    c624:	0192      	lsls	r2, r2, #6
    c626:	f042 0201 	orr.w	r2, r2, #1
		BT_WARN("Unknown beacon type 0x%02x", type);
    c62a:	f017 fcd8 	bl	23fde <log_1>
    c62e:	e018      	b.n	c662 <bt_mesh_beacon_recv+0x92>
	uuid = net_buf_simple_pull_mem(buf, 16);
    c630:	2110      	movs	r1, #16
    c632:	4628      	mov	r0, r5
    c634:	f012 fe2e 	bl	1f294 <net_buf_simple_pull_mem>
    c638:	4606      	mov	r6, r0
	oob_info = net_buf_simple_pull_be16(buf);
    c63a:	4628      	mov	r0, r5
    c63c:	f01c fb9b 	bl	28d76 <net_buf_simple_pull_be16>
	if (buf->len == 4) {
    c640:	88ab      	ldrh	r3, [r5, #4]
    c642:	2b04      	cmp	r3, #4
	oob_info = net_buf_simple_pull_be16(buf);
    c644:	4607      	mov	r7, r0
	if (buf->len == 4) {
    c646:	d104      	bne.n	c652 <bt_mesh_beacon_recv+0x82>
		uri_hash_val = net_buf_simple_pull_be32(buf);
    c648:	4628      	mov	r0, r5
    c64a:	f01c fb9f 	bl	28d8c <net_buf_simple_pull_be32>
		uri_hash = &uri_hash_val;
    c64e:	ac03      	add	r4, sp, #12
		uri_hash_val = net_buf_simple_pull_be32(buf);
    c650:	9003      	str	r0, [sp, #12]
	prov = bt_mesh_prov_get();
    c652:	f009 ff61 	bl	16518 <bt_mesh_prov_get>
	if (prov->unprovisioned_beacon) {
    c656:	6a83      	ldr	r3, [r0, #40]	; 0x28
    c658:	b11b      	cbz	r3, c662 <bt_mesh_beacon_recv+0x92>
		prov->unprovisioned_beacon(uuid,
    c65a:	4622      	mov	r2, r4
    c65c:	4639      	mov	r1, r7
    c65e:	4630      	mov	r0, r6
    c660:	4798      	blx	r3
}
    c662:	b004      	add	sp, #16
    c664:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (buf->len < 21) {
    c668:	88a9      	ldrh	r1, [r5, #4]
    c66a:	2914      	cmp	r1, #20
    c66c:	d808      	bhi.n	c680 <bt_mesh_beacon_recv+0xb0>
    c66e:	4a52      	ldr	r2, [pc, #328]	; (c7b8 <bt_mesh_beacon_recv+0x1e8>)
    c670:	4b52      	ldr	r3, [pc, #328]	; (c7bc <bt_mesh_beacon_recv+0x1ec>)
		BT_ERR("Too short secure beacon (len %u)", buf->len);
    c672:	4856      	ldr	r0, [pc, #344]	; (c7cc <bt_mesh_beacon_recv+0x1fc>)
    c674:	1ad2      	subs	r2, r2, r3
    c676:	08d2      	lsrs	r2, r2, #3
    c678:	0192      	lsls	r2, r2, #6
    c67a:	f042 0201 	orr.w	r2, r2, #1
    c67e:	e7d4      	b.n	c62a <bt_mesh_beacon_recv+0x5a>
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    c680:	4c53      	ldr	r4, [pc, #332]	; (c7d0 <bt_mesh_beacon_recv+0x200>)
	sub = cache_check(buf->data);
    c682:	682e      	ldr	r6, [r5, #0]
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    c684:	f8b4 21b8 	ldrh.w	r2, [r4, #440]	; 0x1b8
    c688:	f64f 73ff 	movw	r3, #65535	; 0xffff
    c68c:	429a      	cmp	r2, r3
    c68e:	4627      	mov	r7, r4
    c690:	d12e      	bne.n	c6f0 <bt_mesh_beacon_recv+0x120>
    c692:	f8b7 229c 	ldrh.w	r2, [r7, #668]	; 0x29c
    c696:	f64f 73ff 	movw	r3, #65535	; 0xffff
    c69a:	429a      	cmp	r2, r3
    c69c:	d133      	bne.n	c706 <bt_mesh_beacon_recv+0x136>
	flags = net_buf_simple_pull_u8(buf);
    c69e:	4628      	mov	r0, r5
	data = buf->data;
    c6a0:	f8d5 8000 	ldr.w	r8, [r5]
	flags = net_buf_simple_pull_u8(buf);
    c6a4:	f01c fb57 	bl	28d56 <net_buf_simple_pull_u8>
	net_id = net_buf_simple_pull_mem(buf, 8);
    c6a8:	2108      	movs	r1, #8
	flags = net_buf_simple_pull_u8(buf);
    c6aa:	4606      	mov	r6, r0
	net_id = net_buf_simple_pull_mem(buf, 8);
    c6ac:	4628      	mov	r0, r5
    c6ae:	f012 fdf1 	bl	1f294 <net_buf_simple_pull_mem>
    c6b2:	4604      	mov	r4, r0
	iv_index = net_buf_simple_pull_be32(buf);
    c6b4:	4628      	mov	r0, r5
    c6b6:	f01c fb69 	bl	28d8c <net_buf_simple_pull_be32>
	sub = bt_mesh_subnet_find(net_id, flags, iv_index, auth, &new_key);
    c6ba:	ab03      	add	r3, sp, #12
    c6bc:	9300      	str	r3, [sp, #0]
    c6be:	4602      	mov	r2, r0
    c6c0:	682b      	ldr	r3, [r5, #0]
	iv_index = net_buf_simple_pull_be32(buf);
    c6c2:	4607      	mov	r7, r0
	sub = bt_mesh_subnet_find(net_id, flags, iv_index, auth, &new_key);
    c6c4:	4631      	mov	r1, r6
    c6c6:	4620      	mov	r0, r4
    c6c8:	f000 fea6 	bl	d418 <bt_mesh_subnet_find>
	if (!sub) {
    c6cc:	4604      	mov	r4, r0
    c6ce:	2800      	cmp	r0, #0
    c6d0:	d0c7      	beq.n	c662 <bt_mesh_beacon_recv+0x92>
	if (sub->kr_phase == BT_MESH_KR_PHASE_2 && !new_key) {
    c6d2:	7fc3      	ldrb	r3, [r0, #31]
    c6d4:	2b02      	cmp	r3, #2
    c6d6:	d11f      	bne.n	c718 <bt_mesh_beacon_recv+0x148>
    c6d8:	f89d 300c 	ldrb.w	r3, [sp, #12]
    c6dc:	b9e3      	cbnz	r3, c718 <bt_mesh_beacon_recv+0x148>
    c6de:	4936      	ldr	r1, [pc, #216]	; (c7b8 <bt_mesh_beacon_recv+0x1e8>)
    c6e0:	4b36      	ldr	r3, [pc, #216]	; (c7bc <bt_mesh_beacon_recv+0x1ec>)
		BT_WARN("Ignoring Phase 2 KR Update secured using old key");
    c6e2:	483c      	ldr	r0, [pc, #240]	; (c7d4 <bt_mesh_beacon_recv+0x204>)
    c6e4:	1ac9      	subs	r1, r1, r3
    c6e6:	08c9      	lsrs	r1, r1, #3
    c6e8:	0189      	lsls	r1, r1, #6
    c6ea:	f041 0102 	orr.w	r1, r1, #2
    c6ee:	e77c      	b.n	c5ea <bt_mesh_beacon_recv+0x1a>
		if (!memcmp(sub->beacon_cache, data, 21)) {
    c6f0:	2215      	movs	r2, #21
    c6f2:	4631      	mov	r1, r6
    c6f4:	f504 70d1 	add.w	r0, r4, #418	; 0x1a2
    c6f8:	f019 fac6 	bl	25c88 <memcmp>
    c6fc:	2800      	cmp	r0, #0
    c6fe:	d1c8      	bne.n	c692 <bt_mesh_beacon_recv+0xc2>
		struct bt_mesh_subnet *sub = &bt_mesh.sub[i];
    c700:	f504 74ce 	add.w	r4, r4, #412	; 0x19c
    c704:	e01d      	b.n	c742 <bt_mesh_beacon_recv+0x172>
		if (!memcmp(sub->beacon_cache, data, 21)) {
    c706:	4834      	ldr	r0, [pc, #208]	; (c7d8 <bt_mesh_beacon_recv+0x208>)
    c708:	2215      	movs	r2, #21
    c70a:	4631      	mov	r1, r6
    c70c:	f019 fabc 	bl	25c88 <memcmp>
    c710:	2800      	cmp	r0, #0
    c712:	d1c4      	bne.n	c69e <bt_mesh_beacon_recv+0xce>
		struct bt_mesh_subnet *sub = &bt_mesh.sub[i];
    c714:	4c31      	ldr	r4, [pc, #196]	; (c7dc <bt_mesh_beacon_recv+0x20c>)
    c716:	e014      	b.n	c742 <bt_mesh_beacon_recv+0x172>
	memcpy(sub->beacon_cache, data, 21);
    c718:	2215      	movs	r2, #21
    c71a:	4641      	mov	r1, r8
    c71c:	1da0      	adds	r0, r4, #6
    c71e:	f019 fac3 	bl	25ca8 <memcpy>
	if (bt_mesh_subnet_get(BT_MESH_KEY_PRIMARY) &&
    c722:	2000      	movs	r0, #0
    c724:	f000 f962 	bl	c9ec <bt_mesh_subnet_get>
    c728:	b1a8      	cbz	r0, c756 <bt_mesh_beacon_recv+0x186>
    c72a:	8ba3      	ldrh	r3, [r4, #28]
    c72c:	b19b      	cbz	r3, c756 <bt_mesh_beacon_recv+0x186>
    c72e:	4922      	ldr	r1, [pc, #136]	; (c7b8 <bt_mesh_beacon_recv+0x1e8>)
    c730:	4b22      	ldr	r3, [pc, #136]	; (c7bc <bt_mesh_beacon_recv+0x1ec>)
		BT_WARN("Ignoring secure beacon on non-primary subnet");
    c732:	482b      	ldr	r0, [pc, #172]	; (c7e0 <bt_mesh_beacon_recv+0x210>)
    c734:	1ac9      	subs	r1, r1, r3
    c736:	08c9      	lsrs	r1, r1, #3
    c738:	0189      	lsls	r1, r1, #6
    c73a:	f041 0102 	orr.w	r1, r1, #2
    c73e:	f017 fc41 	bl	23fc4 <log_0>
	if (bt_mesh_beacon_get() == BT_MESH_BEACON_ENABLED &&
    c742:	f005 fe97 	bl	12474 <bt_mesh_beacon_get>
    c746:	2801      	cmp	r0, #1
    c748:	d18b      	bne.n	c662 <bt_mesh_beacon_recv+0x92>
	    sub->beacons_cur < 0xff) {
    c74a:	7963      	ldrb	r3, [r4, #5]
	if (bt_mesh_beacon_get() == BT_MESH_BEACON_ENABLED &&
    c74c:	2bff      	cmp	r3, #255	; 0xff
    c74e:	d088      	beq.n	c662 <bt_mesh_beacon_recv+0x92>
		sub->beacons_cur++;
    c750:	3301      	adds	r3, #1
    c752:	7163      	strb	r3, [r4, #5]
    c754:	e785      	b.n	c662 <bt_mesh_beacon_recv+0x92>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    c756:	4b23      	ldr	r3, [pc, #140]	; (c7e4 <bt_mesh_beacon_recv+0x214>)
    c758:	f3bf 8f5b 	dmb	ish
    c75c:	681a      	ldr	r2, [r3, #0]
    c75e:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_INITIATOR) &&
    c762:	f012 0f08 	tst.w	r2, #8
    c766:	f3c6 0540 	ubfx	r5, r6, #1, #1
    c76a:	d00b      	beq.n	c784 <bt_mesh_beacon_recv+0x1b4>
    c76c:	f3bf 8f5b 	dmb	ish
    c770:	681b      	ldr	r3, [r3, #0]
    c772:	f3bf 8f5b 	dmb	ish
    c776:	f3c3 0380 	ubfx	r3, r3, #2, #1
    c77a:	42ab      	cmp	r3, r5
    c77c:	d102      	bne.n	c784 <bt_mesh_beacon_recv+0x1b4>
		bt_mesh_beacon_ivu_initiator(false);
    c77e:	2000      	movs	r0, #0
    c780:	f7ff fefc 	bl	c57c <bt_mesh_beacon_ivu_initiator>
	iv_change = bt_mesh_net_iv_update(iv_index, BT_MESH_IV_UPDATE(flags));
    c784:	4629      	mov	r1, r5
    c786:	4638      	mov	r0, r7
    c788:	f000 fc06 	bl	cf98 <bt_mesh_net_iv_update>
	kr_change = bt_mesh_kr_update(sub, BT_MESH_KEY_REFRESH(flags), new_key);
    c78c:	f89d 200c 	ldrb.w	r2, [sp, #12]
	iv_change = bt_mesh_net_iv_update(iv_index, BT_MESH_IV_UPDATE(flags));
    c790:	4605      	mov	r5, r0
	kr_change = bt_mesh_kr_update(sub, BT_MESH_KEY_REFRESH(flags), new_key);
    c792:	f006 0101 	and.w	r1, r6, #1
    c796:	4620      	mov	r0, r4
    c798:	f000 fbac 	bl	cef4 <bt_mesh_kr_update>
	if (kr_change) {
    c79c:	b148      	cbz	r0, c7b2 <bt_mesh_beacon_recv+0x1e2>
		bt_mesh_net_beacon_update(sub);
    c79e:	4620      	mov	r0, r4
    c7a0:	f000 faf4 	bl	cd8c <bt_mesh_net_beacon_update>
	if (iv_change) {
    c7a4:	b11d      	cbz	r5, c7ae <bt_mesh_beacon_recv+0x1de>
		bt_mesh_net_sec_update(NULL);
    c7a6:	2000      	movs	r0, #0
		bt_mesh_net_sec_update(sub);
    c7a8:	f01a fc5b 	bl	27062 <bt_mesh_net_sec_update>
    c7ac:	e7c9      	b.n	c742 <bt_mesh_beacon_recv+0x172>
    c7ae:	4620      	mov	r0, r4
    c7b0:	e7fa      	b.n	c7a8 <bt_mesh_beacon_recv+0x1d8>
	if (iv_change) {
    c7b2:	2d00      	cmp	r5, #0
    c7b4:	d0c5      	beq.n	c742 <bt_mesh_beacon_recv+0x172>
    c7b6:	e7f6      	b.n	c7a6 <bt_mesh_beacon_recv+0x1d6>
    c7b8:	00029918 	.word	0x00029918
    c7bc:	00029830 	.word	0x00029830
    c7c0:	0002ce75 	.word	0x0002ce75
    c7c4:	0002cf2e 	.word	0x0002cf2e
    c7c8:	0002ce86 	.word	0x0002ce86
    c7cc:	0002ceaf 	.word	0x0002ceaf
    c7d0:	20006b48 	.word	0x20006b48
    c7d4:	0002ced0 	.word	0x0002ced0
    c7d8:	20006dce 	.word	0x20006dce
    c7dc:	20006dc8 	.word	0x20006dc8
    c7e0:	0002cf01 	.word	0x0002cf01
    c7e4:	20006b50 	.word	0x20006b50

0000c7e8 <bt_mesh_beacon_enable>:

void bt_mesh_beacon_enable(void)
{
    c7e8:	b510      	push	{r4, lr}
	int i;

	if (!bt_mesh_is_provisioned()) {
    c7ea:	f7ff fadf 	bl	bdac <bt_mesh_is_provisioned>
    c7ee:	b1c8      	cbz	r0, c824 <bt_mesh_beacon_enable+0x3c>
	}

	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
		struct bt_mesh_subnet *sub = &bt_mesh.sub[i];

		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    c7f0:	4c0e      	ldr	r4, [pc, #56]	; (c82c <bt_mesh_beacon_enable+0x44>)
    c7f2:	f8b4 21b8 	ldrh.w	r2, [r4, #440]	; 0x1b8
    c7f6:	f64f 73ff 	movw	r3, #65535	; 0xffff
    c7fa:	429a      	cmp	r2, r3
    c7fc:	d006      	beq.n	c80c <bt_mesh_beacon_enable+0x24>
			continue;
		}

		sub->beacons_last = 0U;
    c7fe:	2300      	movs	r3, #0
		sub->beacons_cur = 0U;

		bt_mesh_net_beacon_update(sub);
    c800:	f504 70ce 	add.w	r0, r4, #412	; 0x19c
		sub->beacons_last = 0U;
    c804:	f8a4 31a0 	strh.w	r3, [r4, #416]	; 0x1a0
		bt_mesh_net_beacon_update(sub);
    c808:	f000 fac0 	bl	cd8c <bt_mesh_net_beacon_update>
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    c80c:	f8b4 229c 	ldrh.w	r2, [r4, #668]	; 0x29c
    c810:	f64f 73ff 	movw	r3, #65535	; 0xffff
    c814:	429a      	cmp	r2, r3
    c816:	d005      	beq.n	c824 <bt_mesh_beacon_enable+0x3c>
		sub->beacons_last = 0U;
    c818:	2300      	movs	r3, #0
		bt_mesh_net_beacon_update(sub);
    c81a:	4805      	ldr	r0, [pc, #20]	; (c830 <bt_mesh_beacon_enable+0x48>)
		sub->beacons_last = 0U;
    c81c:	f8a4 3284 	strh.w	r3, [r4, #644]	; 0x284
		bt_mesh_net_beacon_update(sub);
    c820:	f000 fab4 	bl	cd8c <bt_mesh_net_beacon_update>
	}

	k_work_submit(&beacon_timer.work);
}
    c824:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    c828:	f7ff bd2c 	b.w	c284 <k_work_submit_to_queue.constprop.0>
    c82c:	20006b48 	.word	0x20006b48
    c830:	20006dc8 	.word	0x20006dc8

0000c834 <bt_mesh_beacon_disable>:
    c834:	4b05      	ldr	r3, [pc, #20]	; (c84c <bt_mesh_beacon_disable+0x18>)
    c836:	f3bf 8f5b 	dmb	ish
    c83a:	681b      	ldr	r3, [r3, #0]
    c83c:	f3bf 8f5b 	dmb	ish

void bt_mesh_beacon_disable(void)
{
	if (!atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_INITIATOR)) {
    c840:	071b      	lsls	r3, r3, #28
    c842:	d402      	bmi.n	c84a <bt_mesh_beacon_disable+0x16>
		k_delayed_work_cancel(&beacon_timer);
    c844:	4802      	ldr	r0, [pc, #8]	; (c850 <bt_mesh_beacon_disable+0x1c>)
    c846:	f016 ba1b 	b.w	22c80 <k_delayed_work_cancel>
	}
}
    c84a:	4770      	bx	lr
    c84c:	20006b50 	.word	0x20006b50
    c850:	200008a8 	.word	0x200008a8

0000c854 <auth_match>:
}

static bool auth_match(struct bt_mesh_subnet_keys *keys,
		       const u8_t net_id[8], u8_t flags,
		       u32_t iv_index, const u8_t auth[8])
{
    c854:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    c858:	4604      	mov	r4, r0
	u8_t net_auth[8];

	if (memcmp(net_id, keys->net_id, 8)) {
    c85a:	f104 0a21 	add.w	sl, r4, #33	; 0x21
{
    c85e:	4608      	mov	r0, r1
    c860:	4690      	mov	r8, r2
	if (memcmp(net_id, keys->net_id, 8)) {
    c862:	4651      	mov	r1, sl
    c864:	2208      	movs	r2, #8
{
    c866:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    c868:	4699      	mov	r9, r3
	if (memcmp(net_id, keys->net_id, 8)) {
    c86a:	f019 fa0d 	bl	25c88 <memcmp>
    c86e:	bb58      	cbnz	r0, c8c8 <auth_match+0x74>
		return false;
	}

	bt_mesh_beacon_auth(keys->beacon, flags, keys->net_id, iv_index,
    c870:	ae02      	add	r6, sp, #8
    c872:	4652      	mov	r2, sl
    c874:	4641      	mov	r1, r8
    c876:	9600      	str	r6, [sp, #0]
    c878:	464b      	mov	r3, r9
    c87a:	f104 0049 	add.w	r0, r4, #73	; 0x49
    c87e:	f01a ff3e 	bl	276fe <bt_mesh_beacon_auth>
			    net_auth);

	if (memcmp(auth, net_auth, 8)) {
    c882:	2208      	movs	r2, #8
    c884:	4631      	mov	r1, r6
    c886:	4638      	mov	r0, r7
    c888:	f019 f9fe 	bl	25c88 <memcmp>
    c88c:	b300      	cbz	r0, c8d0 <auth_match+0x7c>
    c88e:	4b11      	ldr	r3, [pc, #68]	; (c8d4 <auth_match+0x80>)
    c890:	4c11      	ldr	r4, [pc, #68]	; (c8d8 <auth_match+0x84>)
		BT_WARN("Authentication Value %s", bt_hex(auth, 8));
    c892:	2108      	movs	r1, #8
    c894:	4638      	mov	r0, r7
    c896:	1ae4      	subs	r4, r4, r3
    c898:	f7f9 fb34 	bl	5f04 <bt_hex_real>
    c89c:	f7f5 fea0 	bl	25e0 <log_strdup>
    c8a0:	08e4      	lsrs	r4, r4, #3
    c8a2:	01a4      	lsls	r4, r4, #6
    c8a4:	f044 0402 	orr.w	r4, r4, #2
    c8a8:	4622      	mov	r2, r4
    c8aa:	4601      	mov	r1, r0
    c8ac:	480b      	ldr	r0, [pc, #44]	; (c8dc <auth_match+0x88>)
    c8ae:	f017 fb96 	bl	23fde <log_1>
		BT_WARN(" != %s", bt_hex(net_auth, 8));
    c8b2:	2108      	movs	r1, #8
    c8b4:	4630      	mov	r0, r6
    c8b6:	f7f9 fb25 	bl	5f04 <bt_hex_real>
    c8ba:	f7f5 fe91 	bl	25e0 <log_strdup>
    c8be:	4622      	mov	r2, r4
    c8c0:	4601      	mov	r1, r0
    c8c2:	4807      	ldr	r0, [pc, #28]	; (c8e0 <auth_match+0x8c>)
    c8c4:	f017 fb8b 	bl	23fde <log_1>
		return false;
    c8c8:	2000      	movs	r0, #0
		return false;
	}

	return true;
}
    c8ca:	b004      	add	sp, #16
    c8cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return true;
    c8d0:	2001      	movs	r0, #1
    c8d2:	e7fa      	b.n	c8ca <auth_match+0x76>
    c8d4:	00029830 	.word	0x00029830
    c8d8:	00029958 	.word	0x00029958
    c8dc:	0002cf58 	.word	0x0002cf58
    c8e0:	0002cf70 	.word	0x0002cf70

0000c8e4 <atomic_get.constprop.0>:
    c8e4:	4b03      	ldr	r3, [pc, #12]	; (c8f4 <atomic_get.constprop.0+0x10>)
    c8e6:	f3bf 8f5b 	dmb	ish
    c8ea:	6898      	ldr	r0, [r3, #8]
    c8ec:	f3bf 8f5b 	dmb	ish
}
    c8f0:	4770      	bx	lr
    c8f2:	bf00      	nop
    c8f4:	20006b48 	.word	0x20006b48

0000c8f8 <net_decrypt.isra.0>:
	}

	return NULL;
}

static int net_decrypt(struct bt_mesh_subnet *sub, const u8_t *enc,
    c8f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		       struct net_buf_simple *buf)
{
	BT_DBG("NID 0x%02x net_idx 0x%04x", NID(data), sub->net_idx);
	BT_DBG("IVI %u net->iv_index 0x%08x", IVI(data), bt_mesh.iv_index);

	rx->old_iv = (IVI(data) != (bt_mesh.iv_index & 0x01));
    c8fc:	4d39      	ldr	r5, [pc, #228]	; (c9e4 <net_decrypt.isra.0+0xec>)
static int net_decrypt(struct bt_mesh_subnet *sub, const u8_t *enc,
    c8fe:	e9dd 7408 	ldrd	r7, r4, [sp, #32]
    c902:	4606      	mov	r6, r0
	rx->old_iv = (IVI(data) != (bt_mesh.iv_index & 0x01));
    c904:	6828      	ldr	r0, [r5, #0]
static int net_decrypt(struct bt_mesh_subnet *sub, const u8_t *enc,
    c906:	469a      	mov	sl, r3
	rx->old_iv = (IVI(data) != (bt_mesh.iv_index & 0x01));
    c908:	7813      	ldrb	r3, [r2, #0]
    c90a:	f000 0001 	and.w	r0, r0, #1
    c90e:	ea80 10d3 	eor.w	r0, r0, r3, lsr #7
    c912:	7d3b      	ldrb	r3, [r7, #20]
    c914:	f360 0300 	bfi	r3, r0, #0, #1
    c918:	753b      	strb	r3, [r7, #20]
	buf->len  = 0U;
    c91a:	2300      	movs	r3, #0
    c91c:	80a3      	strh	r3, [r4, #4]
	buf->data = buf->__buf;
    c91e:	68a3      	ldr	r3, [r4, #8]
    c920:	6023      	str	r3, [r4, #0]
static int net_decrypt(struct bt_mesh_subnet *sub, const u8_t *enc,
    c922:	4690      	mov	r8, r2
    c924:	4689      	mov	r9, r1

	net_buf_simple_reset(buf);
	memcpy(net_buf_simple_add(buf, data_len), data, data_len);
    c926:	4620      	mov	r0, r4
    c928:	4651      	mov	r1, sl
    c92a:	f012 fcd5 	bl	1f2d8 <net_buf_simple_add>
    c92e:	4652      	mov	r2, sl
    c930:	4641      	mov	r1, r8
    c932:	f019 f9b9 	bl	25ca8 <memcpy>

	if (bt_mesh_net_obfuscate(buf->data, BT_MESH_NET_IVI_RX(rx), priv)) {
    c936:	7d3b      	ldrb	r3, [r7, #20]
    c938:	6829      	ldr	r1, [r5, #0]
    c93a:	6820      	ldr	r0, [r4, #0]
    c93c:	f003 0301 	and.w	r3, r3, #1
    c940:	464a      	mov	r2, r9
    c942:	1ac9      	subs	r1, r1, r3
    c944:	f002 fe52 	bl	f5ec <bt_mesh_net_obfuscate>
    c948:	46ac      	mov	ip, r5
    c94a:	2800      	cmp	r0, #0
    c94c:	d140      	bne.n	c9d0 <net_decrypt.isra.0+0xd8>
		return -ENOENT;
	}

	rx->ctx.addr = SRC(buf->data);
    c94e:	6821      	ldr	r1, [r4, #0]
	return ((u16_t)src[0] << 8) | src[1];
    c950:	794a      	ldrb	r2, [r1, #5]
    c952:	798b      	ldrb	r3, [r1, #6]
    c954:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    c958:	b21b      	sxth	r3, r3
	if (!BT_MESH_ADDR_IS_UNICAST(rx->ctx.addr)) {
    c95a:	2b00      	cmp	r3, #0
	rx->ctx.addr = SRC(buf->data);
    c95c:	813b      	strh	r3, [r7, #8]
	if (!BT_MESH_ADDR_IS_UNICAST(rx->ctx.addr)) {
    c95e:	dd3b      	ble.n	c9d8 <net_decrypt.isra.0+0xe0>
		BT_DBG("Ignoring non-unicast src addr 0x%04x", rx->ctx.addr);
		return -EINVAL;
	}

	if (rx->net_if == BT_MESH_NET_IF_ADV && msg_cache_match(rx, buf)) {
    c960:	7d3f      	ldrb	r7, [r7, #20]
    c962:	f017 0330 	ands.w	r3, r7, #48	; 0x30
    c966:	d125      	bne.n	c9b4 <net_decrypt.isra.0+0xbc>
    c968:	7948      	ldrb	r0, [r1, #5]
    c96a:	798a      	ldrb	r2, [r1, #6]
		if (msg_cache[i].src == SRC(pdu->data) &&
    c96c:	f8df e078 	ldr.w	lr, [pc, #120]	; c9e8 <net_decrypt.isra.0+0xf0>
    c970:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    c974:	f83e 0023 	ldrh.w	r0, [lr, r3, lsl #2]
    c978:	f3c0 000e 	ubfx	r0, r0, #0, #15
    c97c:	4290      	cmp	r0, r2
    c97e:	d10f      	bne.n	c9a0 <net_decrypt.isra.0+0xa8>
    c980:	f891 8003 	ldrb.w	r8, [r1, #3]
    c984:	790d      	ldrb	r5, [r1, #4]
		    msg_cache[i].seq == (SEQ(pdu->data) & BIT_MASK(17))) {
    c986:	f85e 0023 	ldr.w	r0, [lr, r3, lsl #2]
	return ((u32_t)src[0] << 16) | sys_get_be16(&src[1]);
    c98a:	ea45 2508 	orr.w	r5, r5, r8, lsl #8
    c98e:	f891 8002 	ldrb.w	r8, [r1, #2]
    c992:	ea45 4508 	orr.w	r5, r5, r8, lsl #16
    c996:	f3c5 0510 	ubfx	r5, r5, #0, #17
		if (msg_cache[i].src == SRC(pdu->data) &&
    c99a:	ebb5 3fd0 	cmp.w	r5, r0, lsr #15
    c99e:	d01e      	beq.n	c9de <net_decrypt.isra.0+0xe6>
	for (i = 0U; i < ARRAY_SIZE(msg_cache); i++) {
    c9a0:	3301      	adds	r3, #1
    c9a2:	2b0a      	cmp	r3, #10
    c9a4:	d1e6      	bne.n	c974 <net_decrypt.isra.0+0x7c>
	    rx->net_if == BT_MESH_NET_IF_PROXY_CFG) {
		return bt_mesh_net_decrypt(enc, buf, BT_MESH_NET_IVI_RX(rx),
					   true);
	}

	return bt_mesh_net_decrypt(enc, buf, BT_MESH_NET_IVI_RX(rx), false);
    c9a6:	f8dc 2000 	ldr.w	r2, [ip]
    c9aa:	f007 0701 	and.w	r7, r7, #1
    c9ae:	2300      	movs	r3, #0
    c9b0:	1bd2      	subs	r2, r2, r7
    c9b2:	e007      	b.n	c9c4 <net_decrypt.isra.0+0xcc>
	if (IS_ENABLED(CONFIG_BT_MESH_PROXY) &&
    c9b4:	6829      	ldr	r1, [r5, #0]
    c9b6:	f007 0201 	and.w	r2, r7, #1
    c9ba:	2b30      	cmp	r3, #48	; 0x30
    c9bc:	eba1 0202 	sub.w	r2, r1, r2
    c9c0:	d1f1      	bne.n	c9a6 <net_decrypt.isra.0+0xae>
		return bt_mesh_net_decrypt(enc, buf, BT_MESH_NET_IVI_RX(rx),
    c9c2:	2301      	movs	r3, #1
	return bt_mesh_net_decrypt(enc, buf, BT_MESH_NET_IVI_RX(rx), false);
    c9c4:	4621      	mov	r1, r4
    c9c6:	4630      	mov	r0, r6
}
    c9c8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_mesh_net_decrypt(enc, buf, BT_MESH_NET_IVI_RX(rx), false);
    c9cc:	f01a bd91 	b.w	274f2 <bt_mesh_net_decrypt>
		return -ENOENT;
    c9d0:	f06f 0001 	mvn.w	r0, #1
}
    c9d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return -EINVAL;
    c9d8:	f06f 0015 	mvn.w	r0, #21
    c9dc:	e7fa      	b.n	c9d4 <net_decrypt.isra.0+0xdc>
		return -EALREADY;
    c9de:	f06f 0044 	mvn.w	r0, #68	; 0x44
    c9e2:	e7f7      	b.n	c9d4 <net_decrypt.isra.0+0xdc>
    c9e4:	20006b48 	.word	0x20006b48
    c9e8:	200008dc 	.word	0x200008dc

0000c9ec <bt_mesh_subnet_get>:
	if (net_idx == BT_MESH_KEY_ANY) {
    c9ec:	f64f 73ff 	movw	r3, #65535	; 0xffff
    c9f0:	4298      	cmp	r0, r3
{
    c9f2:	4602      	mov	r2, r0
	if (net_idx == BT_MESH_KEY_ANY) {
    c9f4:	d012      	beq.n	ca1c <bt_mesh_subnet_get+0x30>
		if (bt_mesh.sub[i].net_idx == net_idx) {
    c9f6:	480b      	ldr	r0, [pc, #44]	; (ca24 <bt_mesh_subnet_get+0x38>)
    c9f8:	f8b0 31b8 	ldrh.w	r3, [r0, #440]	; 0x1b8
    c9fc:	4293      	cmp	r3, r2
    c9fe:	4603      	mov	r3, r0
    ca00:	d00a      	beq.n	ca18 <bt_mesh_subnet_get+0x2c>
    ca02:	f8b0 129c 	ldrh.w	r1, [r0, #668]	; 0x29c
    ca06:	4291      	cmp	r1, r2
    ca08:	d10a      	bne.n	ca20 <bt_mesh_subnet_get+0x34>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
    ca0a:	2001      	movs	r0, #1
			return &bt_mesh.sub[i];
    ca0c:	22e4      	movs	r2, #228	; 0xe4
    ca0e:	fb02 3000 	mla	r0, r2, r0, r3
    ca12:	f500 70ce 	add.w	r0, r0, #412	; 0x19c
    ca16:	4770      	bx	lr
	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
    ca18:	2000      	movs	r0, #0
    ca1a:	e7f7      	b.n	ca0c <bt_mesh_subnet_get+0x20>
		return &bt_mesh.sub[0];
    ca1c:	4802      	ldr	r0, [pc, #8]	; (ca28 <bt_mesh_subnet_get+0x3c>)
    ca1e:	4770      	bx	lr
	return NULL;
    ca20:	2000      	movs	r0, #0
}
    ca22:	4770      	bx	lr
    ca24:	20006b48 	.word	0x20006b48
    ca28:	20006ce4 	.word	0x20006ce4

0000ca2c <bt_mesh_net_keys_create>:
{
    ca2c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	u8_t p[] = { 0 };
    ca2e:	2300      	movs	r3, #0
    ca30:	f88d 300c 	strb.w	r3, [sp, #12]
	err = bt_mesh_k2(key, p, sizeof(p), &nid, keys->enc, keys->privacy);
    ca34:	f100 0339 	add.w	r3, r0, #57	; 0x39
{
    ca38:	460e      	mov	r6, r1
	err = bt_mesh_k2(key, p, sizeof(p), &nid, keys->enc, keys->privacy);
    ca3a:	9301      	str	r3, [sp, #4]
    ca3c:	f100 0311 	add.w	r3, r0, #17
    ca40:	9300      	str	r3, [sp, #0]
{
    ca42:	4605      	mov	r5, r0
	err = bt_mesh_k2(key, p, sizeof(p), &nid, keys->enc, keys->privacy);
    ca44:	f10d 030f 	add.w	r3, sp, #15
    ca48:	2201      	movs	r2, #1
    ca4a:	a903      	add	r1, sp, #12
    ca4c:	4630      	mov	r0, r6
    ca4e:	f002 fd09 	bl	f464 <bt_mesh_k2>
	if (err) {
    ca52:	4604      	mov	r4, r0
    ca54:	b160      	cbz	r0, ca70 <bt_mesh_net_keys_create+0x44>
    ca56:	4924      	ldr	r1, [pc, #144]	; (cae8 <bt_mesh_net_keys_create+0xbc>)
    ca58:	4b24      	ldr	r3, [pc, #144]	; (caec <bt_mesh_net_keys_create+0xc0>)
		BT_ERR("Unable to generate NID, EncKey & PrivacyKey");
    ca5a:	4825      	ldr	r0, [pc, #148]	; (caf0 <bt_mesh_net_keys_create+0xc4>)
    ca5c:	1ac9      	subs	r1, r1, r3
    ca5e:	08c9      	lsrs	r1, r1, #3
    ca60:	0189      	lsls	r1, r1, #6
    ca62:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Unable to generate beacon key");
    ca66:	f017 faad 	bl	23fc4 <log_0>
}
    ca6a:	4620      	mov	r0, r4
    ca6c:	b004      	add	sp, #16
    ca6e:	bd70      	pop	{r4, r5, r6, pc}
	memcpy(keys->net, key, 16);
    ca70:	2210      	movs	r2, #16
    ca72:	4631      	mov	r1, r6
    ca74:	4628      	mov	r0, r5
    ca76:	f019 f917 	bl	25ca8 <memcpy>
	keys->nid = nid;
    ca7a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    ca7e:	742b      	strb	r3, [r5, #16]
	err = bt_mesh_k3(key, keys->net_id);
    ca80:	f105 0121 	add.w	r1, r5, #33	; 0x21
    ca84:	4630      	mov	r0, r6
    ca86:	f002 fd45 	bl	f514 <bt_mesh_k3>
	if (err) {
    ca8a:	4604      	mov	r4, r0
    ca8c:	b140      	cbz	r0, caa0 <bt_mesh_net_keys_create+0x74>
    ca8e:	4916      	ldr	r1, [pc, #88]	; (cae8 <bt_mesh_net_keys_create+0xbc>)
    ca90:	4b16      	ldr	r3, [pc, #88]	; (caec <bt_mesh_net_keys_create+0xc0>)
		BT_ERR("Unable to generate Net ID");
    ca92:	4818      	ldr	r0, [pc, #96]	; (caf4 <bt_mesh_net_keys_create+0xc8>)
    ca94:	1ac9      	subs	r1, r1, r3
    ca96:	08c9      	lsrs	r1, r1, #3
    ca98:	0189      	lsls	r1, r1, #6
    ca9a:	f041 0101 	orr.w	r1, r1, #1
    ca9e:	e7e2      	b.n	ca66 <bt_mesh_net_keys_create+0x3a>
}

static inline int bt_mesh_identity_key(const u8_t net_key[16],
				       u8_t identity_key[16])
{
	return bt_mesh_id128(net_key, "nkik", identity_key);
    caa0:	4915      	ldr	r1, [pc, #84]	; (caf8 <bt_mesh_net_keys_create+0xcc>)
    caa2:	f105 0229 	add.w	r2, r5, #41	; 0x29
    caa6:	4630      	mov	r0, r6
    caa8:	f002 fd8a 	bl	f5c0 <bt_mesh_id128>
	if (err) {
    caac:	4604      	mov	r4, r0
    caae:	b140      	cbz	r0, cac2 <bt_mesh_net_keys_create+0x96>
    cab0:	490d      	ldr	r1, [pc, #52]	; (cae8 <bt_mesh_net_keys_create+0xbc>)
    cab2:	4b0e      	ldr	r3, [pc, #56]	; (caec <bt_mesh_net_keys_create+0xc0>)
		BT_ERR("Unable to generate IdentityKey");
    cab4:	4811      	ldr	r0, [pc, #68]	; (cafc <bt_mesh_net_keys_create+0xd0>)
    cab6:	1ac9      	subs	r1, r1, r3
    cab8:	08c9      	lsrs	r1, r1, #3
    caba:	0189      	lsls	r1, r1, #6
    cabc:	f041 0101 	orr.w	r1, r1, #1
    cac0:	e7d1      	b.n	ca66 <bt_mesh_net_keys_create+0x3a>
}

static inline int bt_mesh_beacon_key(const u8_t net_key[16],
				     u8_t beacon_key[16])
{
	return bt_mesh_id128(net_key, "nkbk", beacon_key);
    cac2:	490f      	ldr	r1, [pc, #60]	; (cb00 <bt_mesh_net_keys_create+0xd4>)
    cac4:	f105 0249 	add.w	r2, r5, #73	; 0x49
    cac8:	4630      	mov	r0, r6
    caca:	f002 fd79 	bl	f5c0 <bt_mesh_id128>
	if (err) {
    cace:	4604      	mov	r4, r0
    cad0:	2800      	cmp	r0, #0
    cad2:	d0ca      	beq.n	ca6a <bt_mesh_net_keys_create+0x3e>
    cad4:	4904      	ldr	r1, [pc, #16]	; (cae8 <bt_mesh_net_keys_create+0xbc>)
    cad6:	4b05      	ldr	r3, [pc, #20]	; (caec <bt_mesh_net_keys_create+0xc0>)
		BT_ERR("Unable to generate beacon key");
    cad8:	480a      	ldr	r0, [pc, #40]	; (cb04 <bt_mesh_net_keys_create+0xd8>)
    cada:	1ac9      	subs	r1, r1, r3
    cadc:	08c9      	lsrs	r1, r1, #3
    cade:	0189      	lsls	r1, r1, #6
    cae0:	f041 0101 	orr.w	r1, r1, #1
    cae4:	e7bf      	b.n	ca66 <bt_mesh_net_keys_create+0x3a>
    cae6:	bf00      	nop
    cae8:	00029958 	.word	0x00029958
    caec:	00029830 	.word	0x00029830
    caf0:	0002cf77 	.word	0x0002cf77
    caf4:	0002cfa3 	.word	0x0002cfa3
    caf8:	0002cfbd 	.word	0x0002cfbd
    cafc:	0002cfc2 	.word	0x0002cfc2
    cb00:	0002cfe1 	.word	0x0002cfe1
    cb04:	0002cfe6 	.word	0x0002cfe6

0000cb08 <friend_cred_set>:
{
    cb08:	b5f0      	push	{r4, r5, r6, r7, lr}
    cb0a:	b087      	sub	sp, #28
    cb0c:	4605      	mov	r5, r0
	lpn_addr = cred->addr;
    cb0e:	8847      	ldrh	r7, [r0, #2]
{
    cb10:	460c      	mov	r4, r1
    cb12:	4616      	mov	r6, r2
	frnd_addr = bt_mesh_primary_addr();
    cb14:	f002 ffca 	bl	faac <bt_mesh_primary_addr>
	p[0] = 0x01;
    cb18:	2301      	movs	r3, #1
    cb1a:	f88d 300c 	strb.w	r3, [sp, #12]
	dst[0] = val >> 8;
    cb1e:	0a3b      	lsrs	r3, r7, #8
    cb20:	f88d 300d 	strb.w	r3, [sp, #13]
    cb24:	0a03      	lsrs	r3, r0, #8
    cb26:	f88d 300f 	strb.w	r3, [sp, #15]
	sys_put_be16(cred->lpn_counter, p + 5);
    cb2a:	88ab      	ldrh	r3, [r5, #4]
	dst[1] = val;
    cb2c:	f88d 3012 	strb.w	r3, [sp, #18]
	dst[0] = val >> 8;
    cb30:	0a1a      	lsrs	r2, r3, #8
	sys_put_be16(cred->frnd_counter, p + 7);
    cb32:	88eb      	ldrh	r3, [r5, #6]
    cb34:	f88d 2011 	strb.w	r2, [sp, #17]
    cb38:	eb04 1144 	add.w	r1, r4, r4, lsl #5
    cb3c:	0a1a      	lsrs	r2, r3, #8
    cb3e:	f88d 2013 	strb.w	r2, [sp, #19]
	dst[1] = val;
    cb42:	f88d 3014 	strb.w	r3, [sp, #20]
			 cred->cred[idx].enc, cred->cred[idx].privacy);
    cb46:	f101 0219 	add.w	r2, r1, #25
	err = bt_mesh_k2(net_key, p, sizeof(p), &cred->cred[idx].nid,
    cb4a:	f101 0308 	add.w	r3, r1, #8
			 cred->cred[idx].enc, cred->cred[idx].privacy);
    cb4e:	3109      	adds	r1, #9
    cb50:	442a      	add	r2, r5
    cb52:	4429      	add	r1, r5
    cb54:	f88d 0010 	strb.w	r0, [sp, #16]
	err = bt_mesh_k2(net_key, p, sizeof(p), &cred->cred[idx].nid,
    cb58:	9201      	str	r2, [sp, #4]
    cb5a:	9100      	str	r1, [sp, #0]
    cb5c:	442b      	add	r3, r5
    cb5e:	2209      	movs	r2, #9
    cb60:	a903      	add	r1, sp, #12
    cb62:	4630      	mov	r0, r6
    cb64:	f88d 700e 	strb.w	r7, [sp, #14]
    cb68:	f002 fc7c 	bl	f464 <bt_mesh_k2>
	if (err) {
    cb6c:	4604      	mov	r4, r0
    cb6e:	b148      	cbz	r0, cb84 <friend_cred_set+0x7c>
    cb70:	4906      	ldr	r1, [pc, #24]	; (cb8c <friend_cred_set+0x84>)
    cb72:	4b07      	ldr	r3, [pc, #28]	; (cb90 <friend_cred_set+0x88>)
		BT_ERR("Unable to generate NID, EncKey & PrivacyKey");
    cb74:	4807      	ldr	r0, [pc, #28]	; (cb94 <friend_cred_set+0x8c>)
    cb76:	1ac9      	subs	r1, r1, r3
    cb78:	08c9      	lsrs	r1, r1, #3
    cb7a:	0189      	lsls	r1, r1, #6
    cb7c:	f041 0101 	orr.w	r1, r1, #1
    cb80:	f017 fa20 	bl	23fc4 <log_0>
}
    cb84:	4620      	mov	r0, r4
    cb86:	b007      	add	sp, #28
    cb88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cb8a:	bf00      	nop
    cb8c:	00029958 	.word	0x00029958
    cb90:	00029830 	.word	0x00029830
    cb94:	0002cf77 	.word	0x0002cf77

0000cb98 <friend_cred_refresh>:
{
    cb98:	b538      	push	{r3, r4, r5, lr}
		if (cred->addr != BT_MESH_ADDR_UNASSIGNED &&
    cb9a:	4c0f      	ldr	r4, [pc, #60]	; (cbd8 <friend_cred_refresh+0x40>)
    cb9c:	8863      	ldrh	r3, [r4, #2]
{
    cb9e:	4605      	mov	r5, r0
		if (cred->addr != BT_MESH_ADDR_UNASSIGNED &&
    cba0:	b14b      	cbz	r3, cbb6 <friend_cred_refresh+0x1e>
    cba2:	8823      	ldrh	r3, [r4, #0]
    cba4:	4283      	cmp	r3, r0
    cba6:	d106      	bne.n	cbb6 <friend_cred_refresh+0x1e>
			memcpy(&cred->cred[0], &cred->cred[1],
    cba8:	2221      	movs	r2, #33	; 0x21
    cbaa:	f104 0129 	add.w	r1, r4, #41	; 0x29
    cbae:	f104 0008 	add.w	r0, r4, #8
    cbb2:	f019 f879 	bl	25ca8 <memcpy>
		if (cred->addr != BT_MESH_ADDR_UNASSIGNED &&
    cbb6:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    cbba:	b15b      	cbz	r3, cbd4 <friend_cred_refresh+0x3c>
    cbbc:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
    cbc0:	42ab      	cmp	r3, r5
    cbc2:	d107      	bne.n	cbd4 <friend_cred_refresh+0x3c>
			memcpy(&cred->cred[0], &cred->cred[1],
    cbc4:	4905      	ldr	r1, [pc, #20]	; (cbdc <friend_cred_refresh+0x44>)
}
    cbc6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			memcpy(&cred->cred[0], &cred->cred[1],
    cbca:	2221      	movs	r2, #33	; 0x21
    cbcc:	f1a1 0021 	sub.w	r0, r1, #33	; 0x21
    cbd0:	f019 b86a 	b.w	25ca8 <memcpy>
}
    cbd4:	bd38      	pop	{r3, r4, r5, pc}
    cbd6:	bf00      	nop
    cbd8:	20001e8a 	.word	0x20001e8a
    cbdc:	20001efd 	.word	0x20001efd

0000cbe0 <friend_cred_update>:
{
    cbe0:	b538      	push	{r3, r4, r5, lr}
		if (cred->addr == BT_MESH_ADDR_UNASSIGNED ||
    cbe2:	4c11      	ldr	r4, [pc, #68]	; (cc28 <friend_cred_update+0x48>)
    cbe4:	8863      	ldrh	r3, [r4, #2]
{
    cbe6:	4605      	mov	r5, r0
		if (cred->addr == BT_MESH_ADDR_UNASSIGNED ||
    cbe8:	b153      	cbz	r3, cc00 <friend_cred_update+0x20>
    cbea:	8822      	ldrh	r2, [r4, #0]
    cbec:	8b83      	ldrh	r3, [r0, #28]
    cbee:	429a      	cmp	r2, r3
    cbf0:	d106      	bne.n	cc00 <friend_cred_update+0x20>
		err = friend_cred_set(cred, 1, sub->keys[1].net);
    cbf2:	f100 0289 	add.w	r2, r0, #137	; 0x89
    cbf6:	2101      	movs	r1, #1
    cbf8:	4620      	mov	r0, r4
    cbfa:	f7ff ff85 	bl	cb08 <friend_cred_set>
		if (err) {
    cbfe:	b918      	cbnz	r0, cc08 <friend_cred_update+0x28>
		if (cred->addr == BT_MESH_ADDR_UNASSIGNED ||
    cc00:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    cc04:	b90b      	cbnz	r3, cc0a <friend_cred_update+0x2a>
	return 0;
    cc06:	2000      	movs	r0, #0
}
    cc08:	bd38      	pop	{r3, r4, r5, pc}
		if (cred->addr == BT_MESH_ADDR_UNASSIGNED ||
    cc0a:	f8b4 204a 	ldrh.w	r2, [r4, #74]	; 0x4a
    cc0e:	8bab      	ldrh	r3, [r5, #28]
    cc10:	429a      	cmp	r2, r3
    cc12:	d1f8      	bne.n	cc06 <friend_cred_update+0x26>
		err = friend_cred_set(cred, 1, sub->keys[1].net);
    cc14:	4805      	ldr	r0, [pc, #20]	; (cc2c <friend_cred_update+0x4c>)
    cc16:	f105 0289 	add.w	r2, r5, #137	; 0x89
    cc1a:	2101      	movs	r1, #1
    cc1c:	f7ff ff74 	bl	cb08 <friend_cred_set>
		if (err) {
    cc20:	2800      	cmp	r0, #0
    cc22:	d0f0      	beq.n	cc06 <friend_cred_update+0x26>
    cc24:	e7f0      	b.n	cc08 <friend_cred_update+0x28>
    cc26:	bf00      	nop
    cc28:	20001e8a 	.word	0x20001e8a
    cc2c:	20001ed4 	.word	0x20001ed4

0000cc30 <friend_cred_create>:
{
    cc30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cc32:	4605      	mov	r5, r0
		if ((friend_cred[i].addr == BT_MESH_ADDR_UNASSIGNED) ||
    cc34:	4823      	ldr	r0, [pc, #140]	; (ccc4 <friend_cred_create+0x94>)
    cc36:	8844      	ldrh	r4, [r0, #2]
    cc38:	b194      	cbz	r4, cc60 <friend_cred_create+0x30>
    cc3a:	42a1      	cmp	r1, r4
    cc3c:	d103      	bne.n	cc46 <friend_cred_create+0x16>
		    (friend_cred[i].addr == addr &&
    cc3e:	8806      	ldrh	r6, [r0, #0]
    cc40:	8bac      	ldrh	r4, [r5, #28]
    cc42:	42a6      	cmp	r6, r4
    cc44:	d00b      	beq.n	cc5e <friend_cred_create+0x2e>
		if ((friend_cred[i].addr == BT_MESH_ADDR_UNASSIGNED) ||
    cc46:	f8b0 404c 	ldrh.w	r4, [r0, #76]	; 0x4c
    cc4a:	b134      	cbz	r4, cc5a <friend_cred_create+0x2a>
    cc4c:	42a1      	cmp	r1, r4
    cc4e:	d11b      	bne.n	cc88 <friend_cred_create+0x58>
		    (friend_cred[i].addr == addr &&
    cc50:	f8b0 604a 	ldrh.w	r6, [r0, #74]	; 0x4a
    cc54:	8bac      	ldrh	r4, [r5, #28]
    cc56:	42a6      	cmp	r6, r4
    cc58:	d116      	bne.n	cc88 <friend_cred_create+0x58>
	for (cred = NULL, i = 0; i < ARRAY_SIZE(friend_cred); i++) {
    cc5a:	2401      	movs	r4, #1
    cc5c:	e000      	b.n	cc60 <friend_cred_create+0x30>
    cc5e:	2400      	movs	r4, #0
			cred = &friend_cred[i];
    cc60:	264a      	movs	r6, #74	; 0x4a
    cc62:	4366      	muls	r6, r4
    cc64:	1984      	adds	r4, r0, r6
	cred->net_idx = sub->net_idx;
    cc66:	8baf      	ldrh	r7, [r5, #28]
    cc68:	5387      	strh	r7, [r0, r6]
	cred->addr = addr;
    cc6a:	8061      	strh	r1, [r4, #2]
	cred->lpn_counter = lpn_counter;
    cc6c:	80a2      	strh	r2, [r4, #4]
	cred->frnd_counter = frnd_counter;
    cc6e:	80e3      	strh	r3, [r4, #6]
	err = friend_cred_set(cred, 0, sub->keys[0].net);
    cc70:	f105 0230 	add.w	r2, r5, #48	; 0x30
    cc74:	2100      	movs	r1, #0
    cc76:	4620      	mov	r0, r4
    cc78:	f7ff ff46 	bl	cb08 <friend_cred_set>
	if (err) {
    cc7c:	4606      	mov	r6, r0
    cc7e:	b180      	cbz	r0, cca2 <friend_cred_create+0x72>
		friend_cred_clear(cred);
    cc80:	4620      	mov	r0, r4
    cc82:	f01a f9d7 	bl	27034 <friend_cred_clear>
    cc86:	e009      	b.n	cc9c <friend_cred_create+0x6c>
    cc88:	490f      	ldr	r1, [pc, #60]	; (ccc8 <friend_cred_create+0x98>)
    cc8a:	4b10      	ldr	r3, [pc, #64]	; (cccc <friend_cred_create+0x9c>)
		BT_WARN("No free friend credential slots");
    cc8c:	4810      	ldr	r0, [pc, #64]	; (ccd0 <friend_cred_create+0xa0>)
    cc8e:	1ac9      	subs	r1, r1, r3
    cc90:	08c9      	lsrs	r1, r1, #3
    cc92:	0189      	lsls	r1, r1, #6
    cc94:	f041 0102 	orr.w	r1, r1, #2
    cc98:	f017 f994 	bl	23fc4 <log_0>
		return NULL;
    cc9c:	2400      	movs	r4, #0
}
    cc9e:	4620      	mov	r0, r4
    cca0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (sub->kr_flag) {
    cca2:	7fab      	ldrb	r3, [r5, #30]
    cca4:	2b00      	cmp	r3, #0
    cca6:	d0fa      	beq.n	cc9e <friend_cred_create+0x6e>
		err = friend_cred_set(cred, 1, sub->keys[1].net);
    cca8:	f105 0289 	add.w	r2, r5, #137	; 0x89
    ccac:	2101      	movs	r1, #1
    ccae:	4620      	mov	r0, r4
    ccb0:	f7ff ff2a 	bl	cb08 <friend_cred_set>
		if (err) {
    ccb4:	2800      	cmp	r0, #0
    ccb6:	d0f2      	beq.n	cc9e <friend_cred_create+0x6e>
			friend_cred_clear(cred);
    ccb8:	4620      	mov	r0, r4
    ccba:	f01a f9bb 	bl	27034 <friend_cred_clear>
			return NULL;
    ccbe:	4634      	mov	r4, r6
    ccc0:	e7ed      	b.n	cc9e <friend_cred_create+0x6e>
    ccc2:	bf00      	nop
    ccc4:	20001e8a 	.word	0x20001e8a
    ccc8:	00029958 	.word	0x00029958
    cccc:	00029830 	.word	0x00029830
    ccd0:	0002d004 	.word	0x0002d004

0000ccd4 <friend_cred_del>:
{
    ccd4:	4603      	mov	r3, r0
		if (cred->addr == addr && cred->net_idx == net_idx) {
    ccd6:	480c      	ldr	r0, [pc, #48]	; (cd08 <friend_cred_del+0x34>)
    ccd8:	8842      	ldrh	r2, [r0, #2]
    ccda:	428a      	cmp	r2, r1
{
    ccdc:	b510      	push	{r4, lr}
    ccde:	4602      	mov	r2, r0
		if (cred->addr == addr && cred->net_idx == net_idx) {
    cce0:	d102      	bne.n	cce8 <friend_cred_del+0x14>
    cce2:	8804      	ldrh	r4, [r0, #0]
    cce4:	429c      	cmp	r4, r3
    cce6:	d008      	beq.n	ccfa <friend_cred_del+0x26>
    cce8:	f8b2 004c 	ldrh.w	r0, [r2, #76]	; 0x4c
    ccec:	4288      	cmp	r0, r1
    ccee:	d108      	bne.n	cd02 <friend_cred_del+0x2e>
    ccf0:	f8b2 204a 	ldrh.w	r2, [r2, #74]	; 0x4a
    ccf4:	429a      	cmp	r2, r3
    ccf6:	d104      	bne.n	cd02 <friend_cred_del+0x2e>
		struct friend_cred *cred = &friend_cred[i];
    ccf8:	4804      	ldr	r0, [pc, #16]	; (cd0c <friend_cred_del+0x38>)
			friend_cred_clear(cred);
    ccfa:	f01a f99b 	bl	27034 <friend_cred_clear>
			return 0;
    ccfe:	2000      	movs	r0, #0
}
    cd00:	bd10      	pop	{r4, pc}
	return -ENOENT;
    cd02:	f06f 0001 	mvn.w	r0, #1
    cd06:	e7fb      	b.n	cd00 <friend_cred_del+0x2c>
    cd08:	20001e8a 	.word	0x20001e8a
    cd0c:	20001ed4 	.word	0x20001ed4

0000cd10 <friend_cred_get>:
{
    cd10:	b5f0      	push	{r4, r5, r6, r7, lr}
    cd12:	4605      	mov	r5, r0
		if (cred->net_idx != sub->net_idx) {
    cd14:	4c1c      	ldr	r4, [pc, #112]	; (cd88 <friend_cred_get+0x78>)
    cd16:	8bae      	ldrh	r6, [r5, #28]
    cd18:	8827      	ldrh	r7, [r4, #0]
{
    cd1a:	9805      	ldr	r0, [sp, #20]
		if (cred->net_idx != sub->net_idx) {
    cd1c:	42b7      	cmp	r7, r6
    cd1e:	d103      	bne.n	cd28 <friend_cred_get+0x18>
		if (addr != BT_MESH_ADDR_UNASSIGNED && cred->addr != addr) {
    cd20:	b171      	cbz	r1, cd40 <friend_cred_get+0x30>
    cd22:	8867      	ldrh	r7, [r4, #2]
    cd24:	428f      	cmp	r7, r1
    cd26:	d00a      	beq.n	cd3e <friend_cred_get+0x2e>
		if (cred->net_idx != sub->net_idx) {
    cd28:	f8b4 704a 	ldrh.w	r7, [r4, #74]	; 0x4a
    cd2c:	42b7      	cmp	r7, r6
    cd2e:	d127      	bne.n	cd80 <friend_cred_get+0x70>
		if (addr != BT_MESH_ADDR_UNASSIGNED && cred->addr != addr) {
    cd30:	b119      	cbz	r1, cd3a <friend_cred_get+0x2a>
    cd32:	f8b4 604c 	ldrh.w	r6, [r4, #76]	; 0x4c
    cd36:	428e      	cmp	r6, r1
    cd38:	d122      	bne.n	cd80 <friend_cred_get+0x70>
	for (i = 0; i < ARRAY_SIZE(friend_cred); i++) {
    cd3a:	2101      	movs	r1, #1
    cd3c:	e000      	b.n	cd40 <friend_cred_get+0x30>
    cd3e:	2100      	movs	r1, #0
		if (nid) {
    cd40:	b142      	cbz	r2, cd54 <friend_cred_get+0x44>
			*nid = cred->cred[sub->kr_flag].nid;
    cd42:	7fae      	ldrb	r6, [r5, #30]
    cd44:	eb06 1746 	add.w	r7, r6, r6, lsl #5
    cd48:	264a      	movs	r6, #74	; 0x4a
    cd4a:	fb06 7601 	mla	r6, r6, r1, r7
    cd4e:	4426      	add	r6, r4
    cd50:	7a36      	ldrb	r6, [r6, #8]
    cd52:	7016      	strb	r6, [r2, #0]
		if (enc) {
    cd54:	b143      	cbz	r3, cd68 <friend_cred_get+0x58>
			*enc = cred->cred[sub->kr_flag].enc;
    cd56:	7faa      	ldrb	r2, [r5, #30]
    cd58:	eb02 1242 	add.w	r2, r2, r2, lsl #5
    cd5c:	3209      	adds	r2, #9
    cd5e:	264a      	movs	r6, #74	; 0x4a
    cd60:	fb06 2201 	mla	r2, r6, r1, r2
    cd64:	4422      	add	r2, r4
    cd66:	601a      	str	r2, [r3, #0]
		if (priv) {
    cd68:	b148      	cbz	r0, cd7e <friend_cred_get+0x6e>
			*priv = cred->cred[sub->kr_flag].privacy;
    cd6a:	7fab      	ldrb	r3, [r5, #30]
    cd6c:	eb03 1343 	add.w	r3, r3, r3, lsl #5
    cd70:	3319      	adds	r3, #25
    cd72:	224a      	movs	r2, #74	; 0x4a
    cd74:	fb02 3101 	mla	r1, r2, r1, r3
    cd78:	4421      	add	r1, r4
    cd7a:	6001      	str	r1, [r0, #0]
		return 0;
    cd7c:	2000      	movs	r0, #0
}
    cd7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return -ENOENT;
    cd80:	f06f 0001 	mvn.w	r0, #1
    cd84:	e7fb      	b.n	cd7e <friend_cred_get+0x6e>
    cd86:	bf00      	nop
    cd88:	20001e8a 	.word	0x20001e8a

0000cd8c <bt_mesh_net_beacon_update>:
{
    cd8c:	b513      	push	{r0, r1, r4, lr}
    cd8e:	4604      	mov	r4, r0
	u8_t flags = bt_mesh_net_flags(sub);
    cd90:	f01a f95b 	bl	2704a <bt_mesh_net_flags>
	if (sub->kr_flag) {
    cd94:	7fa3      	ldrb	r3, [r4, #30]
	u8_t flags = bt_mesh_net_flags(sub);
    cd96:	4601      	mov	r1, r0
	if (sub->kr_flag) {
    cd98:	b163      	cbz	r3, cdb4 <bt_mesh_net_beacon_update+0x28>
		keys = &sub->keys[1];
    cd9a:	f104 0089 	add.w	r0, r4, #137	; 0x89
				   bt_mesh.iv_index, sub->auth);
    cd9e:	3428      	adds	r4, #40	; 0x28
	return bt_mesh_beacon_auth(keys->beacon, flags, keys->net_id,
    cda0:	4b06      	ldr	r3, [pc, #24]	; (cdbc <bt_mesh_net_beacon_update+0x30>)
    cda2:	9400      	str	r4, [sp, #0]
    cda4:	f100 0221 	add.w	r2, r0, #33	; 0x21
    cda8:	681b      	ldr	r3, [r3, #0]
    cdaa:	3049      	adds	r0, #73	; 0x49
    cdac:	f01a fca7 	bl	276fe <bt_mesh_beacon_auth>
}
    cdb0:	b002      	add	sp, #8
    cdb2:	bd10      	pop	{r4, pc}
		keys = &sub->keys[0];
    cdb4:	f104 0030 	add.w	r0, r4, #48	; 0x30
    cdb8:	e7f1      	b.n	cd9e <bt_mesh_net_beacon_update+0x12>
    cdba:	bf00      	nop
    cdbc:	20006b48 	.word	0x20006b48

0000cdc0 <bt_mesh_net_create>:
{
    cdc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    cdc4:	460e      	mov	r6, r1
    cdc6:	4615      	mov	r5, r2
	(void)memset(msg_cache, 0, sizeof(msg_cache));
    cdc8:	2100      	movs	r1, #0
    cdca:	2228      	movs	r2, #40	; 0x28
{
    cdcc:	4680      	mov	r8, r0
	(void)memset(msg_cache, 0, sizeof(msg_cache));
    cdce:	4824      	ldr	r0, [pc, #144]	; (ce60 <bt_mesh_net_create+0xa0>)
	sub->kr_flag = BT_MESH_KEY_REFRESH(flags);
    cdd0:	4c24      	ldr	r4, [pc, #144]	; (ce64 <bt_mesh_net_create+0xa4>)
{
    cdd2:	461f      	mov	r7, r3
	(void)memset(msg_cache, 0, sizeof(msg_cache));
    cdd4:	f018 ff93 	bl	25cfe <memset>
	msg_cache_next = 0U;
    cdd8:	4b23      	ldr	r3, [pc, #140]	; (ce68 <bt_mesh_net_create+0xa8>)
    cdda:	2200      	movs	r2, #0
    cddc:	801a      	strh	r2, [r3, #0]
	sub->kr_flag = BT_MESH_KEY_REFRESH(flags);
    cdde:	f006 0201 	and.w	r2, r6, #1
    cde2:	f884 21ba 	strb.w	r2, [r4, #442]	; 0x1ba
		err = bt_mesh_net_keys_create(&sub->keys[1], key);
    cde6:	4629      	mov	r1, r5
	if (sub->kr_flag) {
    cde8:	b34a      	cbz	r2, ce3e <bt_mesh_net_create+0x7e>
		err = bt_mesh_net_keys_create(&sub->keys[1], key);
    cdea:	f204 2025 	addw	r0, r4, #549	; 0x225
    cdee:	f7ff fe1d 	bl	ca2c <bt_mesh_net_keys_create>
		if (err) {
    cdf2:	b118      	cbz	r0, cdfc <bt_mesh_net_create+0x3c>
			return -EIO;
    cdf4:	f06f 0004 	mvn.w	r0, #4
}
    cdf8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		sub->kr_phase = BT_MESH_KR_PHASE_2;
    cdfc:	2302      	movs	r3, #2
    cdfe:	f884 31bb 	strb.w	r3, [r4, #443]	; 0x1bb
		sub->node_id = BT_MESH_NODE_IDENTITY_STOPPED;
    ce02:	2300      	movs	r3, #0
    ce04:	f884 31bc 	strb.w	r3, [r4, #444]	; 0x1bc
	sub->net_idx = idx;
    ce08:	f8a4 81b8 	strh.w	r8, [r4, #440]	; 0x1b8
	bt_mesh.iv_index = iv_index;
    ce0c:	6027      	str	r7, [r4, #0]
	if (val) {
    ce0e:	f016 0f02 	tst.w	r6, #2
    ce12:	4b16      	ldr	r3, [pc, #88]	; (ce6c <bt_mesh_net_create+0xac>)
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    ce14:	f3bf 8f5b 	dmb	ish
	if (val) {
    ce18:	d018      	beq.n	ce4c <bt_mesh_net_create+0x8c>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    ce1a:	e853 2f00 	ldrex	r2, [r3]
    ce1e:	f042 0204 	orr.w	r2, r2, #4
    ce22:	e843 2100 	strex	r1, r2, [r3]
    ce26:	2900      	cmp	r1, #0
    ce28:	d1f7      	bne.n	ce1a <bt_mesh_net_create+0x5a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    ce2a:	f3bf 8f5b 	dmb	ish
	bt_mesh.ivu_duration = BT_MESH_IVU_MIN_HOURS;
    ce2e:	2360      	movs	r3, #96	; 0x60
	bt_mesh_net_beacon_update(sub);
    ce30:	480f      	ldr	r0, [pc, #60]	; (ce70 <bt_mesh_net_create+0xb0>)
	bt_mesh.ivu_duration = BT_MESH_IVU_MIN_HOURS;
    ce32:	f884 3118 	strb.w	r3, [r4, #280]	; 0x118
	bt_mesh_net_beacon_update(sub);
    ce36:	f7ff ffa9 	bl	cd8c <bt_mesh_net_beacon_update>
	return 0;
    ce3a:	2000      	movs	r0, #0
    ce3c:	e7dc      	b.n	cdf8 <bt_mesh_net_create+0x38>
		err = bt_mesh_net_keys_create(&sub->keys[0], key);
    ce3e:	f504 70e6 	add.w	r0, r4, #460	; 0x1cc
    ce42:	f7ff fdf3 	bl	ca2c <bt_mesh_net_keys_create>
		if (err) {
    ce46:	2800      	cmp	r0, #0
    ce48:	d0db      	beq.n	ce02 <bt_mesh_net_create+0x42>
    ce4a:	e7d3      	b.n	cdf4 <bt_mesh_net_create+0x34>
    ce4c:	e853 2f00 	ldrex	r2, [r3]
    ce50:	f022 0204 	bic.w	r2, r2, #4
    ce54:	e843 2100 	strex	r1, r2, [r3]
    ce58:	2900      	cmp	r1, #0
    ce5a:	d0e6      	beq.n	ce2a <bt_mesh_net_create+0x6a>
    ce5c:	e7f6      	b.n	ce4c <bt_mesh_net_create+0x8c>
    ce5e:	bf00      	nop
    ce60:	200008dc 	.word	0x200008dc
    ce64:	20006b48 	.word	0x20006b48
    ce68:	20001f1e 	.word	0x20001f1e
    ce6c:	20006b50 	.word	0x20006b50
    ce70:	20006ce4 	.word	0x20006ce4

0000ce74 <bt_mesh_net_revoke_keys>:
{
    ce74:	b538      	push	{r3, r4, r5, lr}
	memcpy(&sub->keys[0], &sub->keys[1], sizeof(sub->keys[0]));
    ce76:	2259      	movs	r2, #89	; 0x59
{
    ce78:	4605      	mov	r5, r0
	memcpy(&sub->keys[0], &sub->keys[1], sizeof(sub->keys[0]));
    ce7a:	f100 0189 	add.w	r1, r0, #137	; 0x89
		if (key->net_idx != sub->net_idx || !key->updated) {
    ce7e:	4c1a      	ldr	r4, [pc, #104]	; (cee8 <bt_mesh_net_revoke_keys+0x74>)
	memcpy(&sub->keys[0], &sub->keys[1], sizeof(sub->keys[0]));
    ce80:	3030      	adds	r0, #48	; 0x30
    ce82:	f018 ff11 	bl	25ca8 <memcpy>
		bt_mesh_store_subnet(sub);
    ce86:	4628      	mov	r0, r5
    ce88:	f01a feb8 	bl	27bfc <bt_mesh_store_subnet>
		if (key->net_idx != sub->net_idx || !key->updated) {
    ce8c:	f8b4 214c 	ldrh.w	r2, [r4, #332]	; 0x14c
    ce90:	8bab      	ldrh	r3, [r5, #28]
    ce92:	429a      	cmp	r2, r3
    ce94:	d110      	bne.n	ceb8 <bt_mesh_net_revoke_keys+0x44>
    ce96:	f894 3150 	ldrb.w	r3, [r4, #336]	; 0x150
    ce9a:	b16b      	cbz	r3, ceb8 <bt_mesh_net_revoke_keys+0x44>
		memcpy(&key->keys[0], &key->keys[1], sizeof(key->keys[0]));
    ce9c:	2211      	movs	r2, #17
    ce9e:	f504 71b1 	add.w	r1, r4, #354	; 0x162
    cea2:	f204 1051 	addw	r0, r4, #337	; 0x151
    cea6:	f018 feff 	bl	25ca8 <memcpy>
		key->updated = false;
    ceaa:	2300      	movs	r3, #0
			bt_mesh_store_app_key(key);
    ceac:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
		key->updated = false;
    ceb0:	f884 3150 	strb.w	r3, [r4, #336]	; 0x150
			bt_mesh_store_app_key(key);
    ceb4:	f01a fec4 	bl	27c40 <bt_mesh_store_app_key>
		if (key->net_idx != sub->net_idx || !key->updated) {
    ceb8:	f8b4 2174 	ldrh.w	r2, [r4, #372]	; 0x174
    cebc:	8bab      	ldrh	r3, [r5, #28]
    cebe:	429a      	cmp	r2, r3
    cec0:	d110      	bne.n	cee4 <bt_mesh_net_revoke_keys+0x70>
    cec2:	f894 3178 	ldrb.w	r3, [r4, #376]	; 0x178
    cec6:	b16b      	cbz	r3, cee4 <bt_mesh_net_revoke_keys+0x70>
		memcpy(&key->keys[0], &key->keys[1], sizeof(key->keys[0]));
    cec8:	4908      	ldr	r1, [pc, #32]	; (ceec <bt_mesh_net_revoke_keys+0x78>)
    ceca:	2211      	movs	r2, #17
    cecc:	f1a1 0011 	sub.w	r0, r1, #17
    ced0:	f018 feea 	bl	25ca8 <memcpy>
		key->updated = false;
    ced4:	2300      	movs	r3, #0
    ced6:	f884 3178 	strb.w	r3, [r4, #376]	; 0x178
			bt_mesh_store_app_key(key);
    ceda:	4805      	ldr	r0, [pc, #20]	; (cef0 <bt_mesh_net_revoke_keys+0x7c>)
}
    cedc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			bt_mesh_store_app_key(key);
    cee0:	f01a beae 	b.w	27c40 <bt_mesh_store_app_key>
}
    cee4:	bd38      	pop	{r3, r4, r5, pc}
    cee6:	bf00      	nop
    cee8:	20006b48 	.word	0x20006b48
    ceec:	20006cd2 	.word	0x20006cd2
    cef0:	20006cbc 	.word	0x20006cbc

0000cef4 <bt_mesh_kr_update>:
{
    cef4:	b538      	push	{r3, r4, r5, lr}
    cef6:	4604      	mov	r4, r0
    cef8:	4610      	mov	r0, r2
	if (new_kr != sub->kr_flag && sub->kr_phase == BT_MESH_KR_NORMAL) {
    cefa:	7fa3      	ldrb	r3, [r4, #30]
    cefc:	7fe5      	ldrb	r5, [r4, #31]
    cefe:	428b      	cmp	r3, r1
    cf00:	d00c      	beq.n	cf1c <bt_mesh_kr_update+0x28>
    cf02:	b95d      	cbnz	r5, cf1c <bt_mesh_kr_update+0x28>
    cf04:	4913      	ldr	r1, [pc, #76]	; (cf54 <bt_mesh_kr_update+0x60>)
    cf06:	4b14      	ldr	r3, [pc, #80]	; (cf58 <bt_mesh_kr_update+0x64>)
		BT_WARN("KR change in normal operation. Are we blacklisted?");
    cf08:	4814      	ldr	r0, [pc, #80]	; (cf5c <bt_mesh_kr_update+0x68>)
    cf0a:	1ac9      	subs	r1, r1, r3
    cf0c:	08c9      	lsrs	r1, r1, #3
    cf0e:	0189      	lsls	r1, r1, #6
    cf10:	f041 0102 	orr.w	r1, r1, #2
    cf14:	f017 f856 	bl	23fc4 <log_0>
	return false;
    cf18:	2000      	movs	r0, #0
    cf1a:	e019      	b.n	cf50 <bt_mesh_kr_update+0x5c>
	sub->kr_flag = new_kr;
    cf1c:	2900      	cmp	r1, #0
    cf1e:	bf14      	ite	ne
    cf20:	2301      	movne	r3, #1
    cf22:	2300      	moveq	r3, #0
    cf24:	77a3      	strb	r3, [r4, #30]
	if (sub->kr_flag) {
    cf26:	d005      	beq.n	cf34 <bt_mesh_kr_update+0x40>
		if (sub->kr_phase == BT_MESH_KR_PHASE_1) {
    cf28:	2d01      	cmp	r5, #1
    cf2a:	d1f5      	bne.n	cf18 <bt_mesh_kr_update+0x24>
			sub->kr_phase = BT_MESH_KR_PHASE_2;
    cf2c:	2302      	movs	r3, #2
			sub->kr_phase = BT_MESH_KR_NORMAL;
    cf2e:	77e3      	strb	r3, [r4, #31]
			return true;
    cf30:	2001      	movs	r0, #1
    cf32:	e00d      	b.n	cf50 <bt_mesh_kr_update+0x5c>
		switch (sub->kr_phase) {
    cf34:	2d01      	cmp	r5, #1
    cf36:	d009      	beq.n	cf4c <bt_mesh_kr_update+0x58>
    cf38:	2d02      	cmp	r5, #2
    cf3a:	d1ed      	bne.n	cf18 <bt_mesh_kr_update+0x24>
			bt_mesh_net_revoke_keys(sub);
    cf3c:	4620      	mov	r0, r4
    cf3e:	f7ff ff99 	bl	ce74 <bt_mesh_net_revoke_keys>
				friend_cred_refresh(sub->net_idx);
    cf42:	8ba0      	ldrh	r0, [r4, #28]
    cf44:	f7ff fe28 	bl	cb98 <friend_cred_refresh>
			sub->kr_phase = BT_MESH_KR_NORMAL;
    cf48:	2300      	movs	r3, #0
    cf4a:	e7f0      	b.n	cf2e <bt_mesh_kr_update+0x3a>
			if (!new_key) {
    cf4c:	2800      	cmp	r0, #0
    cf4e:	d1f5      	bne.n	cf3c <bt_mesh_kr_update+0x48>
}
    cf50:	bd38      	pop	{r3, r4, r5, pc}
    cf52:	bf00      	nop
    cf54:	00029958 	.word	0x00029958
    cf58:	00029830 	.word	0x00029830
    cf5c:	0002d024 	.word	0x0002d024

0000cf60 <bt_mesh_rpl_reset>:
{
    cf60:	b570      	push	{r4, r5, r6, lr}
    cf62:	4c0c      	ldr	r4, [pc, #48]	; (cf94 <bt_mesh_rpl_reset+0x34>)
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
    cf64:	2500      	movs	r5, #0
				rpl->old_iv = true;
    cf66:	2601      	movs	r6, #1
		if (rpl->src) {
    cf68:	f8b4 3364 	ldrh.w	r3, [r4, #868]	; 0x364
    cf6c:	b143      	cbz	r3, cf80 <bt_mesh_rpl_reset+0x20>
			if (rpl->old_iv) {
    cf6e:	f894 3366 	ldrb.w	r3, [r4, #870]	; 0x366
    cf72:	b15b      	cbz	r3, cf8c <bt_mesh_rpl_reset+0x2c>
				(void)memset(rpl, 0, sizeof(*rpl));
    cf74:	2208      	movs	r2, #8
    cf76:	2100      	movs	r1, #0
    cf78:	f504 7059 	add.w	r0, r4, #868	; 0x364
    cf7c:	f018 febf 	bl	25cfe <memset>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
    cf80:	3501      	adds	r5, #1
    cf82:	2d0a      	cmp	r5, #10
    cf84:	f104 0408 	add.w	r4, r4, #8
    cf88:	d1ee      	bne.n	cf68 <bt_mesh_rpl_reset+0x8>
}
    cf8a:	bd70      	pop	{r4, r5, r6, pc}
				rpl->old_iv = true;
    cf8c:	f884 6366 	strb.w	r6, [r4, #870]	; 0x366
    cf90:	e7f6      	b.n	cf80 <bt_mesh_rpl_reset+0x20>
    cf92:	bf00      	nop
    cf94:	20006b48 	.word	0x20006b48

0000cf98 <bt_mesh_net_iv_update>:
{
    cf98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cf9a:	4606      	mov	r6, r0
    cf9c:	460c      	mov	r4, r1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    cf9e:	f7ff fca1 	bl	c8e4 <atomic_get.constprop.0>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    cfa2:	4d61      	ldr	r5, [pc, #388]	; (d128 <bt_mesh_net_iv_update+0x190>)
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS)) {
    cfa4:	f010 0f04 	tst.w	r0, #4
		if (iv_index != bt_mesh.iv_index) {
    cfa8:	682a      	ldr	r2, [r5, #0]
    cfaa:	f3c0 0780 	ubfx	r7, r0, #2, #1
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS)) {
    cfae:	d012      	beq.n	cfd6 <bt_mesh_net_iv_update+0x3e>
		if (iv_index != bt_mesh.iv_index) {
    cfb0:	42b2      	cmp	r2, r6
    cfb2:	d00b      	beq.n	cfcc <bt_mesh_net_iv_update+0x34>
    cfb4:	495d      	ldr	r1, [pc, #372]	; (d12c <bt_mesh_net_iv_update+0x194>)
    cfb6:	4b5e      	ldr	r3, [pc, #376]	; (d130 <bt_mesh_net_iv_update+0x198>)
			BT_WARN("IV Index mismatch: 0x%08x != 0x%08x",
    cfb8:	485e      	ldr	r0, [pc, #376]	; (d134 <bt_mesh_net_iv_update+0x19c>)
    cfba:	1a5b      	subs	r3, r3, r1
    cfbc:	08db      	lsrs	r3, r3, #3
    cfbe:	019b      	lsls	r3, r3, #6
    cfc0:	f043 0302 	orr.w	r3, r3, #2
    cfc4:	4631      	mov	r1, r6
			BT_ERR("IV Index out of sync: 0x%08x != 0x%08x",
    cfc6:	f017 f81e 	bl	24006 <log_2>
    cfca:	e001      	b.n	cfd0 <bt_mesh_net_iv_update+0x38>
		if (iv_update) {
    cfcc:	2900      	cmp	r1, #0
    cfce:	d06a      	beq.n	d0a6 <bt_mesh_net_iv_update+0x10e>
			return false;
    cfd0:	2400      	movs	r4, #0
}
    cfd2:	4620      	mov	r0, r4
    cfd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (iv_index == bt_mesh.iv_index) {
    cfd6:	42b2      	cmp	r2, r6
    cfd8:	d079      	beq.n	d0ce <bt_mesh_net_iv_update+0x136>
		if (iv_index < bt_mesh.iv_index ||
    cfda:	d803      	bhi.n	cfe4 <bt_mesh_net_iv_update+0x4c>
		    iv_index > bt_mesh.iv_index + 42) {
    cfdc:	f102 032a 	add.w	r3, r2, #42	; 0x2a
		if (iv_index < bt_mesh.iv_index ||
    cfe0:	42b3      	cmp	r3, r6
    cfe2:	d209      	bcs.n	cff8 <bt_mesh_net_iv_update+0x60>
    cfe4:	4951      	ldr	r1, [pc, #324]	; (d12c <bt_mesh_net_iv_update+0x194>)
    cfe6:	4b52      	ldr	r3, [pc, #328]	; (d130 <bt_mesh_net_iv_update+0x198>)
			BT_ERR("IV Index out of sync: 0x%08x != 0x%08x",
    cfe8:	4853      	ldr	r0, [pc, #332]	; (d138 <bt_mesh_net_iv_update+0x1a0>)
    cfea:	1a5b      	subs	r3, r3, r1
    cfec:	08db      	lsrs	r3, r3, #3
    cfee:	019b      	lsls	r3, r3, #6
    cff0:	f043 0301 	orr.w	r3, r3, #1
    cff4:	4631      	mov	r1, r6
    cff6:	e7e6      	b.n	cfc6 <bt_mesh_net_iv_update+0x2e>
		if (iv_index > bt_mesh.iv_index + 1) {
    cff8:	3201      	adds	r2, #1
    cffa:	42b2      	cmp	r2, r6
    cffc:	d244      	bcs.n	d088 <bt_mesh_net_iv_update+0xf0>
    cffe:	4b4b      	ldr	r3, [pc, #300]	; (d12c <bt_mesh_net_iv_update+0x194>)
    d000:	494b      	ldr	r1, [pc, #300]	; (d130 <bt_mesh_net_iv_update+0x198>)
			BT_WARN("Performing IV Index Recovery");
    d002:	484e      	ldr	r0, [pc, #312]	; (d13c <bt_mesh_net_iv_update+0x1a4>)
    d004:	1ac9      	subs	r1, r1, r3
    d006:	08c9      	lsrs	r1, r1, #3
    d008:	0189      	lsls	r1, r1, #6
    d00a:	f041 0102 	orr.w	r1, r1, #2
    d00e:	f016 ffd9 	bl	23fc4 <log_0>
			(void)memset(bt_mesh.rpl, 0, sizeof(bt_mesh.rpl));
    d012:	2250      	movs	r2, #80	; 0x50
    d014:	4639      	mov	r1, r7
    d016:	f505 7059 	add.w	r0, r5, #868	; 0x364
    d01a:	f018 fe70 	bl	25cfe <memset>
			bt_mesh.seq = 0U;
    d01e:	e9c5 6700 	strd	r6, r7, [r5]
	if (val) {
    d022:	2c00      	cmp	r4, #0
    d024:	d072      	beq.n	d10c <bt_mesh_net_iv_update+0x174>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    d026:	4b46      	ldr	r3, [pc, #280]	; (d140 <bt_mesh_net_iv_update+0x1a8>)
    d028:	f3bf 8f5b 	dmb	ish
    d02c:	e853 2f00 	ldrex	r2, [r3]
    d030:	f042 0204 	orr.w	r2, r2, #4
    d034:	e843 2100 	strex	r1, r2, [r3]
    d038:	2900      	cmp	r1, #0
    d03a:	d1f7      	bne.n	d02c <bt_mesh_net_iv_update+0x94>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    d03c:	f3bf 8f5b 	dmb	ish
	bt_mesh.ivu_duration = 0U;
    d040:	2300      	movs	r3, #0
    d042:	f885 3118 	strb.w	r3, [r5, #280]	; 0x118
	if (iv_update) {
    d046:	2c00      	cmp	r4, #0
    d048:	d06c      	beq.n	d124 <bt_mesh_net_iv_update+0x18c>
		bt_mesh.iv_index = iv_index;
    d04a:	602e      	str	r6, [r5, #0]
		bt_mesh_rpl_reset();
    d04c:	f7ff ff88 	bl	cf60 <bt_mesh_rpl_reset>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    d050:	4a3c      	ldr	r2, [pc, #240]	; (d144 <bt_mesh_net_iv_update+0x1ac>)
    d052:	493d      	ldr	r1, [pc, #244]	; (d148 <bt_mesh_net_iv_update+0x1b0>)
    d054:	483d      	ldr	r0, [pc, #244]	; (d14c <bt_mesh_net_iv_update+0x1b4>)
    d056:	f015 fd83 	bl	22b60 <k_delayed_work_submit_to_queue>
		if (bt_mesh.sub[i].net_idx != BT_MESH_KEY_UNUSED) {
    d05a:	f8b5 21b8 	ldrh.w	r2, [r5, #440]	; 0x1b8
    d05e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d062:	429a      	cmp	r2, r3
    d064:	d002      	beq.n	d06c <bt_mesh_net_iv_update+0xd4>
			bt_mesh_net_beacon_update(&bt_mesh.sub[i]);
    d066:	483a      	ldr	r0, [pc, #232]	; (d150 <bt_mesh_net_iv_update+0x1b8>)
    d068:	f7ff fe90 	bl	cd8c <bt_mesh_net_beacon_update>
		if (bt_mesh.sub[i].net_idx != BT_MESH_KEY_UNUSED) {
    d06c:	f8b5 229c 	ldrh.w	r2, [r5, #668]	; 0x29c
    d070:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d074:	429a      	cmp	r2, r3
    d076:	d002      	beq.n	d07e <bt_mesh_net_iv_update+0xe6>
			bt_mesh_net_beacon_update(&bt_mesh.sub[i]);
    d078:	4836      	ldr	r0, [pc, #216]	; (d154 <bt_mesh_net_iv_update+0x1bc>)
    d07a:	f7ff fe87 	bl	cd8c <bt_mesh_net_beacon_update>
		bt_mesh_store_iv(false);
    d07e:	2000      	movs	r0, #0
    d080:	f01a fdab 	bl	27bda <bt_mesh_store_iv>
	return true;
    d084:	2401      	movs	r4, #1
    d086:	e7a4      	b.n	cfd2 <bt_mesh_net_iv_update+0x3a>
		if (iv_index == bt_mesh.iv_index + 1 && !iv_update) {
    d088:	d10b      	bne.n	d0a2 <bt_mesh_net_iv_update+0x10a>
    d08a:	b961      	cbnz	r1, d0a6 <bt_mesh_net_iv_update+0x10e>
    d08c:	4b27      	ldr	r3, [pc, #156]	; (d12c <bt_mesh_net_iv_update+0x194>)
    d08e:	4928      	ldr	r1, [pc, #160]	; (d130 <bt_mesh_net_iv_update+0x198>)
			BT_WARN("Ignoring new index in normal mode");
    d090:	4831      	ldr	r0, [pc, #196]	; (d158 <bt_mesh_net_iv_update+0x1c0>)
    d092:	1ac9      	subs	r1, r1, r3
    d094:	08c9      	lsrs	r1, r1, #3
    d096:	0189      	lsls	r1, r1, #6
    d098:	f041 0102 	orr.w	r1, r1, #2
    d09c:	f016 ff92 	bl	23fc4 <log_0>
			return false;
    d0a0:	e797      	b.n	cfd2 <bt_mesh_net_iv_update+0x3a>
		if (!iv_update) {
    d0a2:	2900      	cmp	r1, #0
    d0a4:	d095      	beq.n	cfd2 <bt_mesh_net_iv_update+0x3a>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    d0a6:	f7ff fc1d 	bl	c8e4 <atomic_get.constprop.0>
	if (!(IS_ENABLED(CONFIG_BT_MESH_IV_UPDATE_TEST) &&
    d0aa:	06c3      	lsls	r3, r0, #27
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    d0ac:	f3c0 1700 	ubfx	r7, r0, #4, #1
    d0b0:	d40f      	bmi.n	d0d2 <bt_mesh_net_iv_update+0x13a>
		if (bt_mesh.ivu_duration < BT_MESH_IVU_MIN_HOURS) {
    d0b2:	f895 3118 	ldrb.w	r3, [r5, #280]	; 0x118
    d0b6:	2b5f      	cmp	r3, #95	; 0x5f
    d0b8:	d80b      	bhi.n	d0d2 <bt_mesh_net_iv_update+0x13a>
    d0ba:	491d      	ldr	r1, [pc, #116]	; (d130 <bt_mesh_net_iv_update+0x198>)
    d0bc:	4b1b      	ldr	r3, [pc, #108]	; (d12c <bt_mesh_net_iv_update+0x194>)
			BT_WARN("IV Update before minimum duration");
    d0be:	4827      	ldr	r0, [pc, #156]	; (d15c <bt_mesh_net_iv_update+0x1c4>)
    d0c0:	1ac9      	subs	r1, r1, r3
    d0c2:	08c9      	lsrs	r1, r1, #3
    d0c4:	0189      	lsls	r1, r1, #6
    d0c6:	f041 0102 	orr.w	r1, r1, #2
    d0ca:	f016 ff7b 	bl	23fc4 <log_0>
			return false;
    d0ce:	463c      	mov	r4, r7
    d0d0:	e77f      	b.n	cfd2 <bt_mesh_net_iv_update+0x3a>
	if (!iv_update && bt_mesh_tx_in_progress()) {
    d0d2:	2c00      	cmp	r4, #0
    d0d4:	d1a7      	bne.n	d026 <bt_mesh_net_iv_update+0x8e>
    d0d6:	f001 fb81 	bl	e7dc <bt_mesh_tx_in_progress>
    d0da:	b1b8      	cbz	r0, d10c <bt_mesh_net_iv_update+0x174>
    d0dc:	4b13      	ldr	r3, [pc, #76]	; (d12c <bt_mesh_net_iv_update+0x194>)
    d0de:	4914      	ldr	r1, [pc, #80]	; (d130 <bt_mesh_net_iv_update+0x198>)
		BT_WARN("IV Update deferred because of pending transfer");
    d0e0:	481f      	ldr	r0, [pc, #124]	; (d160 <bt_mesh_net_iv_update+0x1c8>)
    d0e2:	1ac9      	subs	r1, r1, r3
    d0e4:	08c9      	lsrs	r1, r1, #3
    d0e6:	0189      	lsls	r1, r1, #6
    d0e8:	f041 0102 	orr.w	r1, r1, #2
    d0ec:	f016 ff6a 	bl	23fc4 <log_0>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    d0f0:	f3bf 8f5b 	dmb	ish
    d0f4:	4b12      	ldr	r3, [pc, #72]	; (d140 <bt_mesh_net_iv_update+0x1a8>)
    d0f6:	e853 2f00 	ldrex	r2, [r3]
    d0fa:	f042 0220 	orr.w	r2, r2, #32
    d0fe:	e843 2100 	strex	r1, r2, [r3]
    d102:	2900      	cmp	r1, #0
    d104:	d1f7      	bne.n	d0f6 <bt_mesh_net_iv_update+0x15e>
    d106:	f3bf 8f5b 	dmb	ish
    d10a:	e762      	b.n	cfd2 <bt_mesh_net_iv_update+0x3a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    d10c:	4b0c      	ldr	r3, [pc, #48]	; (d140 <bt_mesh_net_iv_update+0x1a8>)
    d10e:	f3bf 8f5b 	dmb	ish
    d112:	e853 2f00 	ldrex	r2, [r3]
    d116:	f022 0204 	bic.w	r2, r2, #4
    d11a:	e843 2100 	strex	r1, r2, [r3]
    d11e:	2900      	cmp	r1, #0
    d120:	d08c      	beq.n	d03c <bt_mesh_net_iv_update+0xa4>
    d122:	e7f6      	b.n	d112 <bt_mesh_net_iv_update+0x17a>
		bt_mesh.seq = 0U;
    d124:	606c      	str	r4, [r5, #4]
    d126:	e793      	b.n	d050 <bt_mesh_net_iv_update+0xb8>
    d128:	20006b48 	.word	0x20006b48
    d12c:	00029830 	.word	0x00029830
    d130:	00029958 	.word	0x00029958
    d134:	0002d057 	.word	0x0002d057
    d138:	0002d07b 	.word	0x0002d07b
    d13c:	0002d0a2 	.word	0x0002d0a2
    d140:	20006b50 	.word	0x20006b50
    d144:	05265c00 	.word	0x05265c00
    d148:	20006c64 	.word	0x20006c64
    d14c:	20001dc4 	.word	0x20001dc4
    d150:	20006ce4 	.word	0x20006ce4
    d154:	20006dc8 	.word	0x20006dc8
    d158:	0002d0bf 	.word	0x0002d0bf
    d15c:	0002d0e1 	.word	0x0002d0e1
    d160:	0002d103 	.word	0x0002d103

0000d164 <ivu_refresh>:
		bt_mesh_net_relay(&buf, &rx);
	}
}

static void ivu_refresh(struct k_work *work)
{
    d164:	b510      	push	{r4, lr}
	bt_mesh.ivu_duration += BT_MESH_IVU_HOURS;
    d166:	4c13      	ldr	r4, [pc, #76]	; (d1b4 <ivu_refresh+0x50>)
    d168:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
    d16c:	3318      	adds	r3, #24
    d16e:	b2db      	uxtb	r3, r3
	BT_DBG("%s for %u hour%s",
	       atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS) ?
	       "IVU in Progress" : "IVU Normal mode",
	       bt_mesh.ivu_duration, bt_mesh.ivu_duration == 1U ? "" : "s");

	if (bt_mesh.ivu_duration < BT_MESH_IVU_MIN_HOURS) {
    d170:	2b5f      	cmp	r3, #95	; 0x5f
	bt_mesh.ivu_duration += BT_MESH_IVU_HOURS;
    d172:	f884 3118 	strb.w	r3, [r4, #280]	; 0x118
	if (bt_mesh.ivu_duration < BT_MESH_IVU_MIN_HOURS) {
    d176:	d80a      	bhi.n	d18e <ivu_refresh+0x2a>
		if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
			bt_mesh_store_iv(true);
    d178:	2001      	movs	r0, #1
    d17a:	f01a fd2e 	bl	27bda <bt_mesh_store_iv>
    d17e:	f504 718e 	add.w	r1, r4, #284	; 0x11c
    d182:	4a0d      	ldr	r2, [pc, #52]	; (d1b8 <ivu_refresh+0x54>)
    d184:	480d      	ldr	r0, [pc, #52]	; (d1bc <ivu_refresh+0x58>)
		bt_mesh_beacon_ivu_initiator(true);
		bt_mesh_net_iv_update(bt_mesh.iv_index, false);
	} else if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		bt_mesh_store_iv(true);
	}
}
    d186:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    d18a:	f015 bce9 	b.w	22b60 <k_delayed_work_submit_to_queue>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    d18e:	f7ff fba9 	bl	c8e4 <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS)) {
    d192:	f010 0f04 	tst.w	r0, #4
		bt_mesh_beacon_ivu_initiator(true);
    d196:	f04f 0001 	mov.w	r0, #1
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS)) {
    d19a:	d007      	beq.n	d1ac <ivu_refresh+0x48>
		bt_mesh_beacon_ivu_initiator(true);
    d19c:	f7ff f9ee 	bl	c57c <bt_mesh_beacon_ivu_initiator>
		bt_mesh_net_iv_update(bt_mesh.iv_index, false);
    d1a0:	6820      	ldr	r0, [r4, #0]
    d1a2:	2100      	movs	r1, #0
}
    d1a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_mesh_net_iv_update(bt_mesh.iv_index, false);
    d1a8:	f7ff bef6 	b.w	cf98 <bt_mesh_net_iv_update>
}
    d1ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_mesh_store_iv(true);
    d1b0:	f01a bd13 	b.w	27bda <bt_mesh_store_iv>
    d1b4:	20006b48 	.word	0x20006b48
    d1b8:	05265c00 	.word	0x05265c00
    d1bc:	20001dc4 	.word	0x20001dc4

0000d1c0 <bt_mesh_next_seq>:
{
    d1c0:	b538      	push	{r3, r4, r5, lr}
	u32_t seq = bt_mesh.seq++;
    d1c2:	4c10      	ldr	r4, [pc, #64]	; (d204 <bt_mesh_next_seq+0x44>)
    d1c4:	6865      	ldr	r5, [r4, #4]
    d1c6:	1c6b      	adds	r3, r5, #1
    d1c8:	6063      	str	r3, [r4, #4]
		bt_mesh_store_seq();
    d1ca:	f006 fdff 	bl	13dcc <bt_mesh_store_seq>
    d1ce:	f7ff fb89 	bl	c8e4 <atomic_get.constprop.0>
	if (!atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS) &&
    d1d2:	0743      	lsls	r3, r0, #29
    d1d4:	d414      	bmi.n	d200 <bt_mesh_next_seq+0x40>
    d1d6:	6862      	ldr	r2, [r4, #4]
    d1d8:	4b0b      	ldr	r3, [pc, #44]	; (d208 <bt_mesh_next_seq+0x48>)
    d1da:	429a      	cmp	r2, r3
    d1dc:	d910      	bls.n	d200 <bt_mesh_next_seq+0x40>
		if (bt_mesh.sub[i].net_idx == net_idx) {
    d1de:	f8b4 31b8 	ldrh.w	r3, [r4, #440]	; 0x1b8
    d1e2:	b113      	cbz	r3, d1ea <bt_mesh_next_seq+0x2a>
    d1e4:	f8b4 329c 	ldrh.w	r3, [r4, #668]	; 0x29c
    d1e8:	b953      	cbnz	r3, d200 <bt_mesh_next_seq+0x40>
		bt_mesh_beacon_ivu_initiator(true);
    d1ea:	2001      	movs	r0, #1
    d1ec:	f7ff f9c6 	bl	c57c <bt_mesh_beacon_ivu_initiator>
		bt_mesh_net_iv_update(bt_mesh.iv_index + 1, true);
    d1f0:	6820      	ldr	r0, [r4, #0]
    d1f2:	2101      	movs	r1, #1
    d1f4:	4408      	add	r0, r1
    d1f6:	f7ff fecf 	bl	cf98 <bt_mesh_net_iv_update>
		bt_mesh_net_sec_update(NULL);
    d1fa:	2000      	movs	r0, #0
    d1fc:	f019 ff31 	bl	27062 <bt_mesh_net_sec_update>
}
    d200:	4628      	mov	r0, r5
    d202:	bd38      	pop	{r3, r4, r5, pc}
    d204:	20006b48 	.word	0x20006b48
    d208:	007a1200 	.word	0x007a1200

0000d20c <bt_mesh_net_encode>:
{
    d20c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const bool ctl = (tx->ctx->app_idx == BT_MESH_KEY_UNUSED);
    d210:	6843      	ldr	r3, [r0, #4]
    d212:	885e      	ldrh	r6, [r3, #2]
	if (ctl && net_buf_simple_tailroom(buf) < 8) {
    d214:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d218:	429e      	cmp	r6, r3
{
    d21a:	4605      	mov	r5, r0
    d21c:	460c      	mov	r4, r1
    d21e:	4691      	mov	r9, r2
	if (ctl && net_buf_simple_tailroom(buf) < 8) {
    d220:	d112      	bne.n	d248 <bt_mesh_net_encode+0x3c>
    d222:	4608      	mov	r0, r1
    d224:	f01b fdbf 	bl	28da6 <net_buf_simple_tailroom>
    d228:	2807      	cmp	r0, #7
    d22a:	d80d      	bhi.n	d248 <bt_mesh_net_encode+0x3c>
    d22c:	4936      	ldr	r1, [pc, #216]	; (d308 <bt_mesh_net_encode+0xfc>)
    d22e:	4b37      	ldr	r3, [pc, #220]	; (d30c <bt_mesh_net_encode+0x100>)
		BT_ERR("Insufficient MIC space for CTL PDU");
    d230:	4837      	ldr	r0, [pc, #220]	; (d310 <bt_mesh_net_encode+0x104>)
    d232:	1ac9      	subs	r1, r1, r3
    d234:	08c9      	lsrs	r1, r1, #3
    d236:	0189      	lsls	r1, r1, #6
    d238:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Insufficient MIC space for PDU");
    d23c:	f016 fec2 	bl	23fc4 <log_0>
		return -EINVAL;
    d240:	f06f 0015 	mvn.w	r0, #21
}
    d244:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (net_buf_simple_tailroom(buf) < 4) {
    d248:	4620      	mov	r0, r4
    d24a:	f01b fdac 	bl	28da6 <net_buf_simple_tailroom>
    d24e:	2803      	cmp	r0, #3
    d250:	d808      	bhi.n	d264 <bt_mesh_net_encode+0x58>
    d252:	492d      	ldr	r1, [pc, #180]	; (d308 <bt_mesh_net_encode+0xfc>)
    d254:	4b2d      	ldr	r3, [pc, #180]	; (d30c <bt_mesh_net_encode+0x100>)
		BT_ERR("Insufficient MIC space for PDU");
    d256:	482f      	ldr	r0, [pc, #188]	; (d314 <bt_mesh_net_encode+0x108>)
    d258:	1ac9      	subs	r1, r1, r3
    d25a:	08c9      	lsrs	r1, r1, #3
    d25c:	0189      	lsls	r1, r1, #6
    d25e:	f041 0101 	orr.w	r1, r1, #1
    d262:	e7eb      	b.n	d23c <bt_mesh_net_encode+0x30>
	net_buf_simple_push_be16(buf, tx->ctx->addr);
    d264:	686b      	ldr	r3, [r5, #4]
	net_buf_simple_push_u8(buf, (nid | (BT_MESH_NET_IVI_TX & 1) << 7));
    d266:	4f2c      	ldr	r7, [pc, #176]	; (d318 <bt_mesh_net_encode+0x10c>)
	net_buf_simple_push_be16(buf, tx->ctx->addr);
    d268:	8899      	ldrh	r1, [r3, #4]
    d26a:	4620      	mov	r0, r4
    d26c:	f01b fd57 	bl	28d1e <net_buf_simple_push_be16>
	net_buf_simple_push_be16(buf, tx->src);
    d270:	8929      	ldrh	r1, [r5, #8]
    d272:	4620      	mov	r0, r4
    d274:	f01b fd53 	bl	28d1e <net_buf_simple_push_be16>
	net_buf_simple_push_be24(buf, bt_mesh_next_seq());
    d278:	f7ff ffa2 	bl	d1c0 <bt_mesh_next_seq>
    d27c:	4601      	mov	r1, r0
    d27e:	4620      	mov	r0, r4
    d280:	f01b fd5d 	bl	28d3e <net_buf_simple_push_be24>
	if (ctl) {
    d284:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d288:	429e      	cmp	r6, r3
    d28a:	686b      	ldr	r3, [r5, #4]
		net_buf_simple_push_u8(buf, tx->ctx->send_ttl | 0x80);
    d28c:	7ad9      	ldrb	r1, [r3, #11]
		net_buf_simple_push_u8(buf, tx->ctx->send_ttl);
    d28e:	4620      	mov	r0, r4
		net_buf_simple_push_u8(buf, tx->ctx->send_ttl | 0x80);
    d290:	bf08      	it	eq
    d292:	f041 0180 	orreq.w	r1, r1, #128	; 0x80
		net_buf_simple_push_u8(buf, tx->ctx->send_ttl);
    d296:	f01b fd4b 	bl	28d30 <net_buf_simple_push_u8>
		nid = tx->sub->keys[tx->sub->kr_flag].nid;
    d29a:	682e      	ldr	r6, [r5, #0]
		tx->friend_cred = 0U;
    d29c:	7aeb      	ldrb	r3, [r5, #11]
		nid = tx->sub->keys[tx->sub->kr_flag].nid;
    d29e:	7fb2      	ldrb	r2, [r6, #30]
		tx->friend_cred = 0U;
    d2a0:	f36f 0300 	bfc	r3, #0, #1
    d2a4:	72eb      	strb	r3, [r5, #11]
		nid = tx->sub->keys[tx->sub->kr_flag].nid;
    d2a6:	2559      	movs	r5, #89	; 0x59
    d2a8:	4355      	muls	r5, r2
    d2aa:	1973      	adds	r3, r6, r5
	net_buf_simple_push_u8(buf, (nid | (BT_MESH_NET_IVI_TX & 1) << 7));
    d2ac:	783a      	ldrb	r2, [r7, #0]
		nid = tx->sub->keys[tx->sub->kr_flag].nid;
    d2ae:	f893 1040 	ldrb.w	r1, [r3, #64]	; 0x40
    d2b2:	f7ff fb17 	bl	c8e4 <atomic_get.constprop.0>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    d2b6:	f3c0 0080 	ubfx	r0, r0, #2, #1
	net_buf_simple_push_u8(buf, (nid | (BT_MESH_NET_IVI_TX & 1) << 7));
    d2ba:	1a12      	subs	r2, r2, r0
    d2bc:	ea41 11c2 	orr.w	r1, r1, r2, lsl #7
    d2c0:	b2c9      	uxtb	r1, r1
    d2c2:	4620      	mov	r0, r4
    d2c4:	f01b fd34 	bl	28d30 <net_buf_simple_push_u8>
	err = bt_mesh_net_encrypt(enc, buf, BT_MESH_NET_IVI_TX, proxy);
    d2c8:	683a      	ldr	r2, [r7, #0]
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    d2ca:	f7ff fb0b 	bl	c8e4 <atomic_get.constprop.0>
		enc = tx->sub->keys[tx->sub->kr_flag].enc;
    d2ce:	f105 0841 	add.w	r8, r5, #65	; 0x41
	err = bt_mesh_net_encrypt(enc, buf, BT_MESH_NET_IVI_TX, proxy);
    d2d2:	f3c0 0080 	ubfx	r0, r0, #2, #1
		enc = tx->sub->keys[tx->sub->kr_flag].enc;
    d2d6:	44b0      	add	r8, r6
	err = bt_mesh_net_encrypt(enc, buf, BT_MESH_NET_IVI_TX, proxy);
    d2d8:	1a12      	subs	r2, r2, r0
    d2da:	464b      	mov	r3, r9
    d2dc:	4621      	mov	r1, r4
    d2de:	4640      	mov	r0, r8
    d2e0:	f01a f8b3 	bl	2744a <bt_mesh_net_encrypt>
	if (err) {
    d2e4:	2800      	cmp	r0, #0
    d2e6:	d1ad      	bne.n	d244 <bt_mesh_net_encode+0x38>
	return bt_mesh_net_obfuscate(buf->data, BT_MESH_NET_IVI_TX, priv);
    d2e8:	6824      	ldr	r4, [r4, #0]
    d2ea:	6839      	ldr	r1, [r7, #0]
    d2ec:	f7ff fafa 	bl	c8e4 <atomic_get.constprop.0>
		priv = tx->sub->keys[tx->sub->kr_flag].privacy;
    d2f0:	f105 0269 	add.w	r2, r5, #105	; 0x69
	return bt_mesh_net_obfuscate(buf->data, BT_MESH_NET_IVI_TX, priv);
    d2f4:	f3c0 0080 	ubfx	r0, r0, #2, #1
    d2f8:	4432      	add	r2, r6
    d2fa:	1a09      	subs	r1, r1, r0
    d2fc:	4620      	mov	r0, r4
}
    d2fe:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return bt_mesh_net_obfuscate(buf->data, BT_MESH_NET_IVI_TX, priv);
    d302:	f002 b973 	b.w	f5ec <bt_mesh_net_obfuscate>
    d306:	bf00      	nop
    d308:	00029958 	.word	0x00029958
    d30c:	00029830 	.word	0x00029830
    d310:	0002d132 	.word	0x0002d132
    d314:	0002d155 	.word	0x0002d155
    d318:	20006b48 	.word	0x20006b48

0000d31c <bt_mesh_net_send>:
{
    d31c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (tx->ctx->send_ttl == BT_MESH_TTL_DEFAULT) {
    d320:	6846      	ldr	r6, [r0, #4]
{
    d322:	461f      	mov	r7, r3
	if (tx->ctx->send_ttl == BT_MESH_TTL_DEFAULT) {
    d324:	7af3      	ldrb	r3, [r6, #11]
    d326:	2bff      	cmp	r3, #255	; 0xff
{
    d328:	4605      	mov	r5, r0
    d32a:	4688      	mov	r8, r1
    d32c:	4614      	mov	r4, r2
	if (tx->ctx->send_ttl == BT_MESH_TTL_DEFAULT) {
    d32e:	d102      	bne.n	d336 <bt_mesh_net_send+0x1a>
		tx->ctx->send_ttl = bt_mesh_default_ttl_get();
    d330:	f005 f9ac 	bl	1268c <bt_mesh_default_ttl_get>
    d334:	72f0      	strb	r0, [r6, #11]
	err = bt_mesh_net_encode(tx, &buf->b, false);
    d336:	f108 0908 	add.w	r9, r8, #8
    d33a:	2200      	movs	r2, #0
    d33c:	4649      	mov	r1, r9
    d33e:	4628      	mov	r0, r5
    d340:	f7ff ff64 	bl	d20c <bt_mesh_net_encode>
	if (err) {
    d344:	4606      	mov	r6, r0
    d346:	b9c8      	cbnz	r0, d37c <bt_mesh_net_send+0x60>
	    tx->ctx->send_ttl != 1U) {
    d348:	686b      	ldr	r3, [r5, #4]
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    d34a:	7ada      	ldrb	r2, [r3, #11]
    d34c:	2a01      	cmp	r2, #1
    d34e:	d01b      	beq.n	d388 <bt_mesh_net_send+0x6c>
		if (bt_mesh_proxy_relay(&buf->b, tx->ctx->addr) &&
    d350:	8899      	ldrh	r1, [r3, #4]
    d352:	4648      	mov	r0, r9
    d354:	f00a fc7a 	bl	17c4c <bt_mesh_proxy_relay>
    d358:	b1b0      	cbz	r0, d388 <bt_mesh_net_send+0x6c>
		    BT_MESH_ADDR_IS_UNICAST(tx->ctx->addr)) {
    d35a:	686b      	ldr	r3, [r5, #4]
		if (bt_mesh_proxy_relay(&buf->b, tx->ctx->addr) &&
    d35c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    d360:	2b00      	cmp	r3, #0
    d362:	dd11      	ble.n	d388 <bt_mesh_net_send+0x6c>
int friend_cred_del(u16_t net_idx, u16_t addr);

static inline void send_cb_finalize(const struct bt_mesh_send_cb *cb,
				    void *cb_data)
{
	if (!cb) {
    d364:	b154      	cbz	r4, d37c <bt_mesh_net_send+0x60>
		return;
	}

	if (cb->start) {
    d366:	6823      	ldr	r3, [r4, #0]
    d368:	b11b      	cbz	r3, d372 <bt_mesh_net_send+0x56>
		cb->start(0, 0, cb_data);
    d36a:	463a      	mov	r2, r7
    d36c:	4631      	mov	r1, r6
    d36e:	4630      	mov	r0, r6
    d370:	4798      	blx	r3
	}

	if (cb->end) {
    d372:	6863      	ldr	r3, [r4, #4]
    d374:	b113      	cbz	r3, d37c <bt_mesh_net_send+0x60>
		cb->end(0, cb_data);
    d376:	4639      	mov	r1, r7
    d378:	2000      	movs	r0, #0
    d37a:	4798      	blx	r3
	net_buf_unref(buf);
    d37c:	4640      	mov	r0, r8
    d37e:	f011 fea3 	bl	1f0c8 <net_buf_unref>
}
    d382:	4630      	mov	r0, r6
    d384:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (bt_mesh_fixed_group_match(tx->ctx->addr) ||
    d388:	686b      	ldr	r3, [r5, #4]
    d38a:	8898      	ldrh	r0, [r3, #4]
    d38c:	f01a f9f6 	bl	2777c <bt_mesh_fixed_group_match>
    d390:	b318      	cbz	r0, d3da <bt_mesh_net_send+0xbe>
		if (cb && cb->start) {
    d392:	bb94      	cbnz	r4, d3fa <bt_mesh_net_send+0xde>
		net_buf_slist_put(&bt_mesh.local_queue, net_buf_ref(buf));
    d394:	4640      	mov	r0, r8
    d396:	f011 fedf 	bl	1f158 <net_buf_ref>
    d39a:	4601      	mov	r1, r0
    d39c:	481b      	ldr	r0, [pc, #108]	; (d40c <bt_mesh_net_send+0xf0>)
    d39e:	f011 fdb9 	bl	1ef14 <net_buf_slist_put>
		if (cb && cb->end) {
    d3a2:	b124      	cbz	r4, d3ae <bt_mesh_net_send+0x92>
    d3a4:	6863      	ldr	r3, [r4, #4]
    d3a6:	b113      	cbz	r3, d3ae <bt_mesh_net_send+0x92>
			cb->end(0, cb_data);
    d3a8:	4639      	mov	r1, r7
    d3aa:	2000      	movs	r0, #0
    d3ac:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    d3ae:	f3bf 8f5b 	dmb	ish
    d3b2:	4917      	ldr	r1, [pc, #92]	; (d410 <bt_mesh_net_send+0xf4>)
    d3b4:	e851 3f00 	ldrex	r3, [r1]
    d3b8:	f043 0201 	orr.w	r2, r3, #1
    d3bc:	e841 2000 	strex	r0, r2, [r1]
    d3c0:	2800      	cmp	r0, #0
    d3c2:	d1f7      	bne.n	d3b4 <bt_mesh_net_send+0x98>
    d3c4:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    d3c8:	f013 0401 	ands.w	r4, r3, #1
    d3cc:	d1d6      	bne.n	d37c <bt_mesh_net_send+0x60>
		k_queue_append(&work_q->queue, work);
    d3ce:	4811      	ldr	r0, [pc, #68]	; (d414 <bt_mesh_net_send+0xf8>)
    d3d0:	3908      	subs	r1, #8
    d3d2:	f01b ff3e 	bl	29252 <k_queue_append>
	err = bt_mesh_net_encode(tx, &buf->b, false);
    d3d6:	4626      	mov	r6, r4
    d3d8:	e7d0      	b.n	d37c <bt_mesh_net_send+0x60>
	    bt_mesh_elem_find(tx->ctx->addr)) {
    d3da:	686b      	ldr	r3, [r5, #4]
    d3dc:	8898      	ldrh	r0, [r3, #4]
    d3de:	f002 fb6b 	bl	fab8 <bt_mesh_elem_find>
	if (bt_mesh_fixed_group_match(tx->ctx->addr) ||
    d3e2:	2800      	cmp	r0, #0
    d3e4:	d1d5      	bne.n	d392 <bt_mesh_net_send+0x76>
	} else if (tx->ctx->send_ttl != 1U) {
    d3e6:	686b      	ldr	r3, [r5, #4]
    d3e8:	7adb      	ldrb	r3, [r3, #11]
    d3ea:	2b01      	cmp	r3, #1
    d3ec:	d0c6      	beq.n	d37c <bt_mesh_net_send+0x60>
		bt_mesh_adv_send(buf, cb, cb_data);
    d3ee:	463a      	mov	r2, r7
    d3f0:	4621      	mov	r1, r4
    d3f2:	4640      	mov	r0, r8
    d3f4:	f7fe feb8 	bl	c168 <bt_mesh_adv_send>
    d3f8:	e7c0      	b.n	d37c <bt_mesh_net_send+0x60>
		if (cb && cb->start) {
    d3fa:	6823      	ldr	r3, [r4, #0]
    d3fc:	2b00      	cmp	r3, #0
    d3fe:	d0c9      	beq.n	d394 <bt_mesh_net_send+0x78>
			cb->start(0, 0, cb_data);
    d400:	2100      	movs	r1, #0
    d402:	463a      	mov	r2, r7
    d404:	4608      	mov	r0, r1
    d406:	4798      	blx	r3
    d408:	e7c4      	b.n	d394 <bt_mesh_net_send+0x78>
    d40a:	bf00      	nop
    d40c:	20006b60 	.word	0x20006b60
    d410:	20006b5c 	.word	0x20006b5c
    d414:	20001dc4 	.word	0x20001dc4

0000d418 <bt_mesh_subnet_find>:
{
    d418:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    d41c:	4c28      	ldr	r4, [pc, #160]	; (d4c0 <bt_mesh_subnet_find+0xa8>)
{
    d41e:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    d422:	4617      	mov	r7, r2
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    d424:	f8b4 21b8 	ldrh.w	r2, [r4, #440]	; 0x1b8
{
    d428:	4698      	mov	r8, r3
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    d42a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d42e:	429a      	cmp	r2, r3
{
    d430:	4605      	mov	r5, r0
    d432:	460e      	mov	r6, r1
    d434:	46a2      	mov	sl, r4
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    d436:	d016      	beq.n	d466 <bt_mesh_subnet_find+0x4e>
		if (auth_match(&sub->keys[0], net_id, flags, iv_index, auth)) {
    d438:	460a      	mov	r2, r1
    d43a:	f8cd 8000 	str.w	r8, [sp]
    d43e:	4601      	mov	r1, r0
    d440:	463b      	mov	r3, r7
    d442:	f504 70e6 	add.w	r0, r4, #460	; 0x1cc
    d446:	f7ff fa05 	bl	c854 <auth_match>
    d44a:	bb10      	cbnz	r0, d492 <bt_mesh_subnet_find+0x7a>
		if (sub->kr_phase == BT_MESH_KR_NORMAL) {
    d44c:	f894 31bb 	ldrb.w	r3, [r4, #443]	; 0x1bb
    d450:	b14b      	cbz	r3, d466 <bt_mesh_subnet_find+0x4e>
		if (auth_match(&sub->keys[1], net_id, flags, iv_index, auth)) {
    d452:	f8cd 8000 	str.w	r8, [sp]
    d456:	463b      	mov	r3, r7
    d458:	4632      	mov	r2, r6
    d45a:	4629      	mov	r1, r5
    d45c:	f204 2025 	addw	r0, r4, #549	; 0x225
    d460:	f7ff f9f8 	bl	c854 <auth_match>
    d464:	bb38      	cbnz	r0, d4b6 <bt_mesh_subnet_find+0x9e>
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    d466:	f8ba 229c 	ldrh.w	r2, [sl, #668]	; 0x29c
    d46a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d46e:	429a      	cmp	r2, r3
    d470:	d024      	beq.n	d4bc <bt_mesh_subnet_find+0xa4>
		if (auth_match(&sub->keys[0], net_id, flags, iv_index, auth)) {
    d472:	4814      	ldr	r0, [pc, #80]	; (d4c4 <bt_mesh_subnet_find+0xac>)
    d474:	f8cd 8000 	str.w	r8, [sp]
    d478:	463b      	mov	r3, r7
    d47a:	4632      	mov	r2, r6
    d47c:	4629      	mov	r1, r5
    d47e:	f7ff f9e9 	bl	c854 <auth_match>
    d482:	b148      	cbz	r0, d498 <bt_mesh_subnet_find+0x80>
		struct bt_mesh_subnet *sub = &bt_mesh.sub[i];
    d484:	4810      	ldr	r0, [pc, #64]	; (d4c8 <bt_mesh_subnet_find+0xb0>)
			*new_key = false;
    d486:	2300      	movs	r3, #0
			*new_key = true;
    d488:	f889 3000 	strb.w	r3, [r9]
}
    d48c:	b002      	add	sp, #8
    d48e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		struct bt_mesh_subnet *sub = &bt_mesh.sub[i];
    d492:	f504 70ce 	add.w	r0, r4, #412	; 0x19c
    d496:	e7f6      	b.n	d486 <bt_mesh_subnet_find+0x6e>
		if (sub->kr_phase == BT_MESH_KR_NORMAL) {
    d498:	f89a 329f 	ldrb.w	r3, [sl, #671]	; 0x29f
    d49c:	b173      	cbz	r3, d4bc <bt_mesh_subnet_find+0xa4>
		if (auth_match(&sub->keys[1], net_id, flags, iv_index, auth)) {
    d49e:	480b      	ldr	r0, [pc, #44]	; (d4cc <bt_mesh_subnet_find+0xb4>)
    d4a0:	f8cd 8000 	str.w	r8, [sp]
    d4a4:	463b      	mov	r3, r7
    d4a6:	4632      	mov	r2, r6
    d4a8:	4629      	mov	r1, r5
    d4aa:	f7ff f9d3 	bl	c854 <auth_match>
    d4ae:	b128      	cbz	r0, d4bc <bt_mesh_subnet_find+0xa4>
		struct bt_mesh_subnet *sub = &bt_mesh.sub[i];
    d4b0:	4805      	ldr	r0, [pc, #20]	; (d4c8 <bt_mesh_subnet_find+0xb0>)
			*new_key = true;
    d4b2:	2301      	movs	r3, #1
    d4b4:	e7e8      	b.n	d488 <bt_mesh_subnet_find+0x70>
		struct bt_mesh_subnet *sub = &bt_mesh.sub[i];
    d4b6:	f504 70ce 	add.w	r0, r4, #412	; 0x19c
    d4ba:	e7fa      	b.n	d4b2 <bt_mesh_subnet_find+0x9a>
	return NULL;
    d4bc:	2000      	movs	r0, #0
    d4be:	e7e5      	b.n	d48c <bt_mesh_subnet_find+0x74>
    d4c0:	20006b48 	.word	0x20006b48
    d4c4:	20006df8 	.word	0x20006df8
    d4c8:	20006dc8 	.word	0x20006dc8
    d4cc:	20006e51 	.word	0x20006e51

0000d4d0 <bt_mesh_net_header_parse>:
	rx->old_iv = (IVI(buf->data) != (bt_mesh.iv_index & 0x01));
    d4d0:	4a14      	ldr	r2, [pc, #80]	; (d524 <bt_mesh_net_header_parse+0x54>)
    d4d2:	6803      	ldr	r3, [r0, #0]
    d4d4:	6812      	ldr	r2, [r2, #0]
    d4d6:	7818      	ldrb	r0, [r3, #0]
    d4d8:	f002 0201 	and.w	r2, r2, #1
    d4dc:	ea82 12d0 	eor.w	r2, r2, r0, lsr #7
    d4e0:	7d08      	ldrb	r0, [r1, #20]
    d4e2:	f362 0000 	bfi	r0, r2, #0, #1
    d4e6:	7508      	strb	r0, [r1, #20]
	rx->ctl = CTL(buf->data);
    d4e8:	785a      	ldrb	r2, [r3, #1]
    d4ea:	b2c0      	uxtb	r0, r0
    d4ec:	09d2      	lsrs	r2, r2, #7
    d4ee:	f362 00c3 	bfi	r0, r2, #3, #1
    d4f2:	7508      	strb	r0, [r1, #20]
	rx->ctx.recv_ttl = TTL(buf->data);
    d4f4:	785a      	ldrb	r2, [r3, #1]
    d4f6:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    d4fa:	734a      	strb	r2, [r1, #13]
	return ((u16_t)src[0] << 8) | src[1];
    d4fc:	78d8      	ldrb	r0, [r3, #3]
    d4fe:	791a      	ldrb	r2, [r3, #4]
	return ((u32_t)src[0] << 16) | sys_get_be16(&src[1]);
    d500:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    d504:	7898      	ldrb	r0, [r3, #2]
    d506:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
	rx->seq = SEQ(buf->data);
    d50a:	610a      	str	r2, [r1, #16]
	return ((u16_t)src[0] << 8) | src[1];
    d50c:	7958      	ldrb	r0, [r3, #5]
    d50e:	799a      	ldrb	r2, [r3, #6]
    d510:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rx->ctx.addr = SRC(buf->data);
    d514:	810a      	strh	r2, [r1, #8]
    d516:	79da      	ldrb	r2, [r3, #7]
    d518:	7a1b      	ldrb	r3, [r3, #8]
    d51a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	rx->ctx.recv_dst = DST(buf->data);
    d51e:	814b      	strh	r3, [r1, #10]
}
    d520:	4770      	bx	lr
    d522:	bf00      	nop
    d524:	20006b48 	.word	0x20006b48

0000d528 <bt_mesh_net_decode>:
{
    d528:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (data->len < BT_MESH_NET_MIN_PDU_LEN) {
    d52c:	f8b0 b004 	ldrh.w	fp, [r0, #4]
    d530:	f1bb 0f11 	cmp.w	fp, #17
{
    d534:	b085      	sub	sp, #20
    d536:	4605      	mov	r5, r0
    d538:	460f      	mov	r7, r1
    d53a:	4614      	mov	r4, r2
    d53c:	461e      	mov	r6, r3
	if (data->len < BT_MESH_NET_MIN_PDU_LEN) {
    d53e:	d819      	bhi.n	d574 <bt_mesh_net_decode+0x4c>
    d540:	4ab7      	ldr	r2, [pc, #732]	; (d820 <bt_mesh_net_decode+0x2f8>)
    d542:	4cb8      	ldr	r4, [pc, #736]	; (d824 <bt_mesh_net_decode+0x2fc>)
		BT_WARN("Dropping too short mesh packet (len %u)", data->len);
    d544:	48b8      	ldr	r0, [pc, #736]	; (d828 <bt_mesh_net_decode+0x300>)
    d546:	1aa4      	subs	r4, r4, r2
    d548:	08e4      	lsrs	r4, r4, #3
    d54a:	01a4      	lsls	r4, r4, #6
    d54c:	f044 0402 	orr.w	r4, r4, #2
    d550:	4622      	mov	r2, r4
    d552:	4659      	mov	r1, fp
    d554:	f016 fd43 	bl	23fde <log_1>
		BT_WARN("%s", bt_hex(data->data, data->len));
    d558:	88a9      	ldrh	r1, [r5, #4]
    d55a:	6828      	ldr	r0, [r5, #0]
    d55c:	f7f8 fcd2 	bl	5f04 <bt_hex_real>
    d560:	f7f5 f83e 	bl	25e0 <log_strdup>
    d564:	4622      	mov	r2, r4
    d566:	4601      	mov	r1, r0
    d568:	48b0      	ldr	r0, [pc, #704]	; (d82c <bt_mesh_net_decode+0x304>)
    d56a:	f016 fd38 	bl	23fde <log_1>
		return -EINVAL;
    d56e:	f06f 0015 	mvn.w	r0, #21
    d572:	e125      	b.n	d7c0 <bt_mesh_net_decode+0x298>
	if (net_if == BT_MESH_NET_IF_ADV && check_dup(data)) {
    d574:	f8d0 a000 	ldr.w	sl, [r0]
    d578:	bba9      	cbnz	r1, d5e6 <bt_mesh_net_decode+0xbe>
	return buf->data + buf->len;
    d57a:	eb0a 010b 	add.w	r1, sl, fp
    d57e:	f811 0c07 	ldrb.w	r0, [r1, #-7]
    d582:	f811 5c08 	ldrb.w	r5, [r1, #-8]
    d586:	f811 cc06 	ldrb.w	ip, [r1, #-6]
	return ((u32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
    d58a:	ea40 2505 	orr.w	r5, r0, r5, lsl #8
	return ((u16_t)src[0] << 8) | src[1];
    d58e:	f811 0c05 	ldrb.w	r0, [r1, #-5]
	return ((u32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
    d592:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
    d596:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
	return ((u16_t)src[0] << 8) | src[1];
    d59a:	f811 cc04 	ldrb.w	ip, [r1, #-4]
    d59e:	f811 5c03 	ldrb.w	r5, [r1, #-3]
	return ((u32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
    d5a2:	ea45 250c 	orr.w	r5, r5, ip, lsl #8
	return ((u16_t)src[0] << 8) | src[1];
    d5a6:	f811 cc02 	ldrb.w	ip, [r1, #-2]
    d5aa:	f811 1c01 	ldrb.w	r1, [r1, #-1]
	return ((u32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
    d5ae:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
    d5b2:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
    d5b6:	4d9e      	ldr	r5, [pc, #632]	; (d830 <bt_mesh_net_decode+0x308>)
	val = sys_get_be32(tail - 4) ^ sys_get_be32(tail - 8);
    d5b8:	4048      	eors	r0, r1
	for (i = 0; i < ARRAY_SIZE(dup_cache); i++) {
    d5ba:	46ac      	mov	ip, r5
    d5bc:	4639      	mov	r1, r7
		if (dup_cache[i] == val) {
    d5be:	f855 3b04 	ldr.w	r3, [r5], #4
    d5c2:	4298      	cmp	r0, r3
    d5c4:	d0d3      	beq.n	d56e <bt_mesh_net_decode+0x46>
	for (i = 0; i < ARRAY_SIZE(dup_cache); i++) {
    d5c6:	3101      	adds	r1, #1
    d5c8:	2904      	cmp	r1, #4
    d5ca:	d1f8      	bne.n	d5be <bt_mesh_net_decode+0x96>
	dup_cache[dup_cache_next++] = val;
    d5cc:	4d99      	ldr	r5, [pc, #612]	; (d834 <bt_mesh_net_decode+0x30c>)
    d5ce:	6829      	ldr	r1, [r5, #0]
    d5d0:	f84c 0021 	str.w	r0, [ip, r1, lsl #2]
    d5d4:	3101      	adds	r1, #1
	dup_cache_next %= ARRAY_SIZE(dup_cache);
    d5d6:	4248      	negs	r0, r1
    d5d8:	f000 0003 	and.w	r0, r0, #3
    d5dc:	f001 0103 	and.w	r1, r1, #3
    d5e0:	bf58      	it	pl
    d5e2:	4241      	negpl	r1, r0
    d5e4:	6029      	str	r1, [r5, #0]
	rx->net_if = net_if;
    d5e6:	7d21      	ldrb	r1, [r4, #20]
    d5e8:	4d93      	ldr	r5, [pc, #588]	; (d838 <bt_mesh_net_decode+0x310>)
		if (cred->net_idx != sub->net_idx) {
    d5ea:	f8df 8270 	ldr.w	r8, [pc, #624]	; d85c <bt_mesh_net_decode+0x334>
	rx->net_if = net_if;
    d5ee:	f367 1105 	bfi	r1, r7, #4, #2
    d5f2:	7521      	strb	r1, [r4, #20]
	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
    d5f4:	f04f 0900 	mov.w	r9, #0
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    d5f8:	f8b5 11b8 	ldrh.w	r1, [r5, #440]	; 0x1b8
    d5fc:	f64f 70ff 	movw	r0, #65535	; 0xffff
    d600:	4281      	cmp	r1, r0
    d602:	f000 80d7 	beq.w	d7b4 <bt_mesh_net_decode+0x28c>
		if (cred->net_idx != sub->net_idx) {
    d606:	f8b8 0000 	ldrh.w	r0, [r8]
    d60a:	f505 73ce 	add.w	r3, r5, #412	; 0x19c
    d60e:	4288      	cmp	r0, r1
    d610:	9303      	str	r3, [sp, #12]
    d612:	d12a      	bne.n	d66a <bt_mesh_net_decode+0x142>
		if (NID(data) == cred->cred[0].nid &&
    d614:	f89a 1000 	ldrb.w	r1, [sl]
    d618:	f898 0008 	ldrb.w	r0, [r8, #8]
    d61c:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    d620:	4288      	cmp	r0, r1
    d622:	d10b      	bne.n	d63c <bt_mesh_net_decode+0x114>
		    !net_decrypt(sub, cred->cred[0].enc, cred->cred[0].privacy,
    d624:	4985      	ldr	r1, [pc, #532]	; (d83c <bt_mesh_net_decode+0x314>)
    d626:	e9cd 4600 	strd	r4, r6, [sp]
    d62a:	465b      	mov	r3, fp
    d62c:	4652      	mov	r2, sl
    d62e:	f1a1 0010 	sub.w	r0, r1, #16
    d632:	f7ff f961 	bl	c8f8 <net_decrypt.isra.0>
		if (NID(data) == cred->cred[0].nid &&
    d636:	2800      	cmp	r0, #0
    d638:	f000 8085 	beq.w	d746 <bt_mesh_net_decode+0x21e>
		if (sub->kr_phase == BT_MESH_KR_NORMAL) {
    d63c:	f895 11bb 	ldrb.w	r1, [r5, #443]	; 0x1bb
    d640:	b199      	cbz	r1, d66a <bt_mesh_net_decode+0x142>
		if (NID(data) == cred->cred[1].nid &&
    d642:	f89a 1000 	ldrb.w	r1, [sl]
    d646:	f898 0029 	ldrb.w	r0, [r8, #41]	; 0x29
    d64a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    d64e:	4288      	cmp	r0, r1
    d650:	d10b      	bne.n	d66a <bt_mesh_net_decode+0x142>
		    !net_decrypt(sub, cred->cred[1].enc, cred->cred[1].privacy,
    d652:	497b      	ldr	r1, [pc, #492]	; (d840 <bt_mesh_net_decode+0x318>)
    d654:	e9cd 4600 	strd	r4, r6, [sp]
    d658:	465b      	mov	r3, fp
    d65a:	4652      	mov	r2, sl
    d65c:	f1a1 0010 	sub.w	r0, r1, #16
    d660:	f7ff f94a 	bl	c8f8 <net_decrypt.isra.0>
		if (NID(data) == cred->cred[1].nid &&
    d664:	2800      	cmp	r0, #0
    d666:	f000 8086 	beq.w	d776 <bt_mesh_net_decode+0x24e>
		if (cred->net_idx != sub->net_idx) {
    d66a:	f8b8 004a 	ldrh.w	r0, [r8, #74]	; 0x4a
    d66e:	f8b5 11b8 	ldrh.w	r1, [r5, #440]	; 0x1b8
    d672:	4288      	cmp	r0, r1
    d674:	d10b      	bne.n	d68e <bt_mesh_net_decode+0x166>
		if (NID(data) == cred->cred[0].nid &&
    d676:	f89a 1000 	ldrb.w	r1, [sl]
    d67a:	f898 0052 	ldrb.w	r0, [r8, #82]	; 0x52
    d67e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    d682:	4288      	cmp	r0, r1
    d684:	d054      	beq.n	d730 <bt_mesh_net_decode+0x208>
		if (sub->kr_phase == BT_MESH_KR_NORMAL) {
    d686:	f895 11bb 	ldrb.w	r1, [r5, #443]	; 0x1bb
    d68a:	2900      	cmp	r1, #0
    d68c:	d160      	bne.n	d750 <bt_mesh_net_decode+0x228>
		if (NID(data) == sub->keys[0].nid &&
    d68e:	f89a 1000 	ldrb.w	r1, [sl]
    d692:	f895 01dc 	ldrb.w	r0, [r5, #476]	; 0x1dc
    d696:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    d69a:	4288      	cmp	r0, r1
    d69c:	d170      	bne.n	d780 <bt_mesh_net_decode+0x258>
		    !net_decrypt(sub, sub->keys[0].enc, sub->keys[0].privacy,
    d69e:	e9cd 4600 	strd	r4, r6, [sp]
    d6a2:	465b      	mov	r3, fp
    d6a4:	4652      	mov	r2, sl
    d6a6:	f205 2105 	addw	r1, r5, #517	; 0x205
    d6aa:	f205 10dd 	addw	r0, r5, #477	; 0x1dd
    d6ae:	f7ff f923 	bl	c8f8 <net_decrypt.isra.0>
		if (NID(data) == sub->keys[0].nid &&
    d6b2:	2800      	cmp	r0, #0
    d6b4:	d164      	bne.n	d780 <bt_mesh_net_decode+0x258>
			rx->ctx.net_idx = sub->net_idx;
    d6b6:	4a60      	ldr	r2, [pc, #384]	; (d838 <bt_mesh_net_decode+0x310>)
	rx->ctl = CTL(buf->data);
    d6b8:	7d21      	ldrb	r1, [r4, #20]
			rx->ctx.net_idx = sub->net_idx;
    d6ba:	23e4      	movs	r3, #228	; 0xe4
    d6bc:	fb03 2909 	mla	r9, r3, r9, r2
	rx->ctx.recv_ttl = TTL(buf->data);
    d6c0:	6832      	ldr	r2, [r6, #0]
			rx->ctx.net_idx = sub->net_idx;
    d6c2:	f8b9 31b8 	ldrh.w	r3, [r9, #440]	; 0x1b8
    d6c6:	80a3      	strh	r3, [r4, #4]
			rx->sub = sub;
    d6c8:	9b03      	ldr	r3, [sp, #12]
    d6ca:	6023      	str	r3, [r4, #0]
	rx->ctx.app_idx = BT_MESH_KEY_UNUSED;
    d6cc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d6d0:	80e3      	strh	r3, [r4, #6]
	rx->ctx.recv_ttl = TTL(buf->data);
    d6d2:	7853      	ldrb	r3, [r2, #1]
    d6d4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    d6d8:	7363      	strb	r3, [r4, #13]
	if (rx->ctx.recv_ttl == 0U) {
    d6da:	3b00      	subs	r3, #0
    d6dc:	bf18      	it	ne
    d6de:	2301      	movne	r3, #1
    d6e0:	425b      	negs	r3, r3
    d6e2:	73e3      	strb	r3, [r4, #15]
	rx->ctl = CTL(buf->data);
    d6e4:	7853      	ldrb	r3, [r2, #1]
    d6e6:	09db      	lsrs	r3, r3, #7
    d6e8:	f363 01c3 	bfi	r1, r3, #3, #1
    d6ec:	7521      	strb	r1, [r4, #20]
	return ((u16_t)src[0] << 8) | src[1];
    d6ee:	78d1      	ldrb	r1, [r2, #3]
    d6f0:	7913      	ldrb	r3, [r2, #4]
	return ((u32_t)src[0] << 16) | sys_get_be16(&src[1]);
    d6f2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    d6f6:	7891      	ldrb	r1, [r2, #2]
    d6f8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
	rx->seq = SEQ(buf->data);
    d6fc:	6123      	str	r3, [r4, #16]
	return ((u16_t)src[0] << 8) | src[1];
    d6fe:	79d1      	ldrb	r1, [r2, #7]
    d700:	7a13      	ldrb	r3, [r2, #8]
	if (net_if != BT_MESH_NET_IF_PROXY_CFG &&
    d702:	2f03      	cmp	r7, #3
    d704:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rx->ctx.recv_dst = DST(buf->data);
    d708:	8163      	strh	r3, [r4, #10]
	if (net_if != BT_MESH_NET_IF_PROXY_CFG &&
    d70a:	d05c      	beq.n	d7c6 <bt_mesh_net_decode+0x29e>
    d70c:	2b00      	cmp	r3, #0
    d70e:	d15a      	bne.n	d7c6 <bt_mesh_net_decode+0x29e>
    d710:	4944      	ldr	r1, [pc, #272]	; (d824 <bt_mesh_net_decode+0x2fc>)
    d712:	4b43      	ldr	r3, [pc, #268]	; (d820 <bt_mesh_net_decode+0x2f8>)
		BT_ERR("Destination address is unassigned; dropping packet");
    d714:	484b      	ldr	r0, [pc, #300]	; (d844 <bt_mesh_net_decode+0x31c>)
    d716:	1ac9      	subs	r1, r1, r3
    d718:	08c9      	lsrs	r1, r1, #3
    d71a:	0189      	lsls	r1, r1, #6
    d71c:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Destination address is RFU; dropping packet");
    d720:	f016 fc50 	bl	23fc4 <log_0>
		return -EBADMSG;
    d724:	f06f 004c 	mvn.w	r0, #76	; 0x4c
    d728:	e04a      	b.n	d7c0 <bt_mesh_net_decode+0x298>
    d72a:	f04f 0901 	mov.w	r9, #1
    d72e:	e763      	b.n	d5f8 <bt_mesh_net_decode+0xd0>
		    !net_decrypt(sub, cred->cred[0].enc, cred->cred[0].privacy,
    d730:	4945      	ldr	r1, [pc, #276]	; (d848 <bt_mesh_net_decode+0x320>)
    d732:	e9cd 4600 	strd	r4, r6, [sp]
    d736:	465b      	mov	r3, fp
    d738:	4652      	mov	r2, sl
    d73a:	f1a1 0010 	sub.w	r0, r1, #16
    d73e:	f7ff f8db 	bl	c8f8 <net_decrypt.isra.0>
		if (NID(data) == cred->cred[0].nid &&
    d742:	2800      	cmp	r0, #0
    d744:	d19f      	bne.n	d686 <bt_mesh_net_decode+0x15e>
			rx->friend_cred = 1U;
    d746:	7d23      	ldrb	r3, [r4, #20]
    d748:	f043 0304 	orr.w	r3, r3, #4
			rx->new_key = 1U;
    d74c:	7523      	strb	r3, [r4, #20]
    d74e:	e7b2      	b.n	d6b6 <bt_mesh_net_decode+0x18e>
		if (NID(data) == cred->cred[1].nid &&
    d750:	f89a 1000 	ldrb.w	r1, [sl]
    d754:	f898 0073 	ldrb.w	r0, [r8, #115]	; 0x73
    d758:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    d75c:	4288      	cmp	r0, r1
    d75e:	d196      	bne.n	d68e <bt_mesh_net_decode+0x166>
		    !net_decrypt(sub, cred->cred[1].enc, cred->cred[1].privacy,
    d760:	493a      	ldr	r1, [pc, #232]	; (d84c <bt_mesh_net_decode+0x324>)
    d762:	e9cd 4600 	strd	r4, r6, [sp]
    d766:	465b      	mov	r3, fp
    d768:	4652      	mov	r2, sl
    d76a:	f1a1 0010 	sub.w	r0, r1, #16
    d76e:	f7ff f8c3 	bl	c8f8 <net_decrypt.isra.0>
		if (NID(data) == cred->cred[1].nid &&
    d772:	2800      	cmp	r0, #0
    d774:	d18b      	bne.n	d68e <bt_mesh_net_decode+0x166>
			rx->new_key = 1U;
    d776:	7d23      	ldrb	r3, [r4, #20]
    d778:	f043 0302 	orr.w	r3, r3, #2
    d77c:	7523      	strb	r3, [r4, #20]
			return 0;
    d77e:	e7e2      	b.n	d746 <bt_mesh_net_decode+0x21e>
		if (sub->kr_phase == BT_MESH_KR_NORMAL) {
    d780:	f895 11bb 	ldrb.w	r1, [r5, #443]	; 0x1bb
    d784:	b1b1      	cbz	r1, d7b4 <bt_mesh_net_decode+0x28c>
		if (NID(data) == sub->keys[1].nid &&
    d786:	f89a 1000 	ldrb.w	r1, [sl]
    d78a:	f895 0235 	ldrb.w	r0, [r5, #565]	; 0x235
    d78e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    d792:	4288      	cmp	r0, r1
    d794:	d10e      	bne.n	d7b4 <bt_mesh_net_decode+0x28c>
		    !net_decrypt(sub, sub->keys[1].enc, sub->keys[1].privacy,
    d796:	e9cd 4600 	strd	r4, r6, [sp]
    d79a:	465b      	mov	r3, fp
    d79c:	4652      	mov	r2, sl
    d79e:	f205 215e 	addw	r1, r5, #606	; 0x25e
    d7a2:	f205 2036 	addw	r0, r5, #566	; 0x236
    d7a6:	f7ff f8a7 	bl	c8f8 <net_decrypt.isra.0>
		if (NID(data) == sub->keys[1].nid &&
    d7aa:	b918      	cbnz	r0, d7b4 <bt_mesh_net_decode+0x28c>
			rx->new_key = 1U;
    d7ac:	7d23      	ldrb	r3, [r4, #20]
    d7ae:	f043 0302 	orr.w	r3, r3, #2
    d7b2:	e7cb      	b.n	d74c <bt_mesh_net_decode+0x224>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
    d7b4:	35e4      	adds	r5, #228	; 0xe4
    d7b6:	f1b9 0f00 	cmp.w	r9, #0
    d7ba:	d0b6      	beq.n	d72a <bt_mesh_net_decode+0x202>
		return -ENOENT;
    d7bc:	f06f 0001 	mvn.w	r0, #1
}
    d7c0:	b005      	add	sp, #20
    d7c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (BT_MESH_ADDR_IS_RFU(rx->ctx.recv_dst)) {
    d7c6:	f503 7380 	add.w	r3, r3, #256	; 0x100
    d7ca:	b29b      	uxth	r3, r3
    d7cc:	2bfb      	cmp	r3, #251	; 0xfb
    d7ce:	d808      	bhi.n	d7e2 <bt_mesh_net_decode+0x2ba>
    d7d0:	4914      	ldr	r1, [pc, #80]	; (d824 <bt_mesh_net_decode+0x2fc>)
    d7d2:	4b13      	ldr	r3, [pc, #76]	; (d820 <bt_mesh_net_decode+0x2f8>)
		BT_ERR("Destination address is RFU; dropping packet");
    d7d4:	481e      	ldr	r0, [pc, #120]	; (d850 <bt_mesh_net_decode+0x328>)
    d7d6:	1ac9      	subs	r1, r1, r3
    d7d8:	08c9      	lsrs	r1, r1, #3
    d7da:	0189      	lsls	r1, r1, #6
    d7dc:	f041 0101 	orr.w	r1, r1, #1
    d7e0:	e79e      	b.n	d720 <bt_mesh_net_decode+0x1f8>
	if (net_if != BT_MESH_NET_IF_LOCAL && bt_mesh_elem_find(rx->ctx.addr)) {
    d7e2:	2f01      	cmp	r7, #1
    d7e4:	d115      	bne.n	d812 <bt_mesh_net_decode+0x2ea>
	msg_cache[rx->msg_cache_idx].src = rx->ctx.addr;
    d7e6:	8922      	ldrh	r2, [r4, #8]
    d7e8:	6920      	ldr	r0, [r4, #16]
	rx->msg_cache_idx = msg_cache_next++;
    d7ea:	491a      	ldr	r1, [pc, #104]	; (d854 <bt_mesh_net_decode+0x32c>)
	msg_cache[rx->msg_cache_idx].src = rx->ctx.addr;
    d7ec:	f3c2 020e 	ubfx	r2, r2, #0, #15
	rx->msg_cache_idx = msg_cache_next++;
    d7f0:	880b      	ldrh	r3, [r1, #0]
    d7f2:	82e3      	strh	r3, [r4, #22]
	msg_cache[rx->msg_cache_idx].src = rx->ctx.addr;
    d7f4:	ea42 32c0 	orr.w	r2, r2, r0, lsl #15
    d7f8:	4817      	ldr	r0, [pc, #92]	; (d858 <bt_mesh_net_decode+0x330>)
    d7fa:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
	rx->msg_cache_idx = msg_cache_next++;
    d7fe:	3301      	adds	r3, #1
	msg_cache_next %= ARRAY_SIZE(msg_cache);
    d800:	200a      	movs	r0, #10
    d802:	b29b      	uxth	r3, r3
    d804:	fbb3 f2f0 	udiv	r2, r3, r0
    d808:	fb00 3312 	mls	r3, r0, r2, r3
    d80c:	800b      	strh	r3, [r1, #0]
	return 0;
    d80e:	2000      	movs	r0, #0
}
    d810:	e7d6      	b.n	d7c0 <bt_mesh_net_decode+0x298>
	if (net_if != BT_MESH_NET_IF_LOCAL && bt_mesh_elem_find(rx->ctx.addr)) {
    d812:	8920      	ldrh	r0, [r4, #8]
    d814:	f002 f950 	bl	fab8 <bt_mesh_elem_find>
    d818:	2800      	cmp	r0, #0
    d81a:	d0e4      	beq.n	d7e6 <bt_mesh_net_decode+0x2be>
    d81c:	e782      	b.n	d724 <bt_mesh_net_decode+0x1fc>
    d81e:	bf00      	nop
    d820:	00029830 	.word	0x00029830
    d824:	00029958 	.word	0x00029958
    d828:	0002d174 	.word	0x0002d174
    d82c:	0002f98a 	.word	0x0002f98a
    d830:	200008c8 	.word	0x200008c8
    d834:	200008d8 	.word	0x200008d8
    d838:	20006b48 	.word	0x20006b48
    d83c:	20001ea3 	.word	0x20001ea3
    d840:	20001ec4 	.word	0x20001ec4
    d844:	0002d19c 	.word	0x0002d19c
    d848:	20001eed 	.word	0x20001eed
    d84c:	20001f0e 	.word	0x20001f0e
    d850:	0002d1cf 	.word	0x0002d1cf
    d854:	20001f1e 	.word	0x20001f1e
    d858:	200008dc 	.word	0x200008dc
    d85c:	20001e8a 	.word	0x20001e8a

0000d860 <bt_mesh_net_recv>:
{
    d860:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d864:	b092      	sub	sp, #72	; 0x48
	NET_BUF_SIMPLE_DEFINE(buf, 29);
    d866:	ab0a      	add	r3, sp, #40	; 0x28
{
    d868:	4617      	mov	r7, r2
	NET_BUF_SIMPLE_DEFINE(buf, 29);
    d86a:	f44f 12e8 	mov.w	r2, #1900544	; 0x1d0000
    d86e:	e9cd 2302 	strd	r2, r3, [sp, #8]
{
    d872:	460c      	mov	r4, r1
    d874:	4605      	mov	r5, r0
	struct bt_mesh_net_rx rx = { .ctx.recv_rssi = rssi };
    d876:	2218      	movs	r2, #24
    d878:	2100      	movs	r1, #0
    d87a:	a804      	add	r0, sp, #16
	NET_BUF_SIMPLE_DEFINE(buf, 29);
    d87c:	9301      	str	r3, [sp, #4]
	struct bt_mesh_net_rx rx = { .ctx.recv_rssi = rssi };
    d87e:	f018 fa3e 	bl	25cfe <memset>
    d882:	f88d 401c 	strb.w	r4, [sp, #28]
	if (!bt_mesh_is_provisioned()) {
    d886:	f7fe fa91 	bl	bdac <bt_mesh_is_provisioned>
    d88a:	2800      	cmp	r0, #0
    d88c:	d06f      	beq.n	d96e <bt_mesh_net_recv+0x10e>
	if (bt_mesh_net_decode(data, net_if, &rx, &buf)) {
    d88e:	ab01      	add	r3, sp, #4
    d890:	aa04      	add	r2, sp, #16
    d892:	4639      	mov	r1, r7
    d894:	4628      	mov	r0, r5
    d896:	f7ff fe47 	bl	d528 <bt_mesh_net_decode>
    d89a:	2800      	cmp	r0, #0
    d89c:	d167      	bne.n	d96e <bt_mesh_net_recv+0x10e>
	state->offset = net_buf_simple_headroom(buf);
    d89e:	a801      	add	r0, sp, #4
    d8a0:	f01b fa7d 	bl	28d9e <net_buf_simple_headroom>
    d8a4:	4604      	mov	r4, r0
	rx.local_match = (bt_mesh_fixed_group_match(rx.ctx.recv_dst) ||
    d8a6:	f8bd 001a 	ldrh.w	r0, [sp, #26]
	state->len = buf->len;
    d8aa:	f8bd 6008 	ldrh.w	r6, [sp, #8]
    d8ae:	f019 ff65 	bl	2777c <bt_mesh_fixed_group_match>
    d8b2:	bb40      	cbnz	r0, d906 <bt_mesh_net_recv+0xa6>
			  bt_mesh_elem_find(rx.ctx.recv_dst));
    d8b4:	f8bd 001a 	ldrh.w	r0, [sp, #26]
    d8b8:	f002 f8fe 	bl	fab8 <bt_mesh_elem_find>
	rx.local_match = (bt_mesh_fixed_group_match(rx.ctx.recv_dst) ||
    d8bc:	3800      	subs	r0, #0
    d8be:	bf18      	it	ne
    d8c0:	2001      	movne	r0, #1
    d8c2:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    d8c6:	2f02      	cmp	r7, #2
	rx.local_match = (bt_mesh_fixed_group_match(rx.ctx.recv_dst) ||
    d8c8:	f360 1386 	bfi	r3, r0, #6, #1
    d8cc:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    d8d0:	d11b      	bne.n	d90a <bt_mesh_net_recv+0xaa>
		bt_mesh_proxy_addr_add(data, rx.ctx.addr);
    d8d2:	f8bd 1018 	ldrh.w	r1, [sp, #24]
    d8d6:	4628      	mov	r0, r5
    d8d8:	f01a fb8f 	bl	27ffa <bt_mesh_proxy_addr_add>
		if (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_DISABLED &&
    d8dc:	f004 fe5e 	bl	1259c <bt_mesh_gatt_proxy_get>
		    !rx.local_match) {
    d8e0:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    d8e4:	f003 0340 	and.w	r3, r3, #64	; 0x40
		if (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_DISABLED &&
    d8e8:	4318      	orrs	r0, r3
    d8ea:	f010 0fff 	tst.w	r0, #255	; 0xff
    d8ee:	d10c      	bne.n	d90a <bt_mesh_net_recv+0xaa>
    d8f0:	497d      	ldr	r1, [pc, #500]	; (dae8 <bt_mesh_net_recv+0x288>)
    d8f2:	4b7e      	ldr	r3, [pc, #504]	; (daec <bt_mesh_net_recv+0x28c>)
			BT_INFO("Proxy is disabled; ignoring message");
    d8f4:	487e      	ldr	r0, [pc, #504]	; (daf0 <bt_mesh_net_recv+0x290>)
    d8f6:	1ac9      	subs	r1, r1, r3
    d8f8:	08c9      	lsrs	r1, r1, #3
    d8fa:	0189      	lsls	r1, r1, #6
    d8fc:	f041 0103 	orr.w	r1, r1, #3
		BT_ERR("Out of relay buffers");
    d900:	f016 fb60 	bl	23fc4 <log_0>
		return;
    d904:	e033      	b.n	d96e <bt_mesh_net_recv+0x10e>
	rx.local_match = (bt_mesh_fixed_group_match(rx.ctx.recv_dst) ||
    d906:	2001      	movs	r0, #1
    d908:	e7db      	b.n	d8c2 <bt_mesh_net_recv+0x62>
	if (bt_mesh_trans_recv(&buf, &rx) == -EAGAIN) {
    d90a:	a904      	add	r1, sp, #16
    d90c:	a801      	add	r0, sp, #4
    d90e:	f000 ffe5 	bl	e8dc <bt_mesh_trans_recv>
    d912:	300b      	adds	r0, #11
    d914:	d114      	bne.n	d940 <bt_mesh_net_recv+0xe0>
    d916:	4b75      	ldr	r3, [pc, #468]	; (daec <bt_mesh_net_recv+0x28c>)
    d918:	4973      	ldr	r1, [pc, #460]	; (dae8 <bt_mesh_net_recv+0x288>)
		BT_WARN("Removing rejected message from Network Message Cache");
    d91a:	4876      	ldr	r0, [pc, #472]	; (daf4 <bt_mesh_net_recv+0x294>)
    d91c:	1ac9      	subs	r1, r1, r3
    d91e:	08c9      	lsrs	r1, r1, #3
    d920:	0189      	lsls	r1, r1, #6
    d922:	f041 0102 	orr.w	r1, r1, #2
    d926:	f016 fb4d 	bl	23fc4 <log_0>
		msg_cache[rx.msg_cache_idx].src = BT_MESH_ADDR_UNASSIGNED;
    d92a:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
    d92e:	4a72      	ldr	r2, [pc, #456]	; (daf8 <bt_mesh_net_recv+0x298>)
    d930:	f832 1023 	ldrh.w	r1, [r2, r3, lsl #2]
    d934:	f36f 010e 	bfc	r1, #0, #15
    d938:	f822 1023 	strh.w	r1, [r2, r3, lsl #2]
		msg_cache_next = rx.msg_cache_idx;
    d93c:	4a6f      	ldr	r2, [pc, #444]	; (dafc <bt_mesh_net_recv+0x29c>)
    d93e:	8013      	strh	r3, [r2, #0]
	if (!BT_MESH_ADDR_IS_UNICAST(rx.ctx.recv_dst) ||
    d940:	f9bd 201a 	ldrsh.w	r2, [sp, #26]
    d944:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    d948:	2a00      	cmp	r2, #0
    d94a:	dd02      	ble.n	d952 <bt_mesh_net_recv+0xf2>
    d94c:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    d950:	d10d      	bne.n	d96e <bt_mesh_net_recv+0x10e>
	buf->data = buf->__buf + state->offset;
    d952:	9803      	ldr	r0, [sp, #12]
    d954:	f89d 201d 	ldrb.w	r2, [sp, #29]
	buf->len = state->len;
    d958:	f8ad 6008 	strh.w	r6, [sp, #8]
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
    d95c:	f003 0330 	and.w	r3, r3, #48	; 0x30
	buf->data = buf->__buf + state->offset;
    d960:	fa10 f484 	uxtah	r4, r0, r4
    d964:	2b10      	cmp	r3, #16
    d966:	9401      	str	r4, [sp, #4]
    d968:	d104      	bne.n	d974 <bt_mesh_net_recv+0x114>
		if (rx->ctx.recv_ttl == 1U) {
    d96a:	2a01      	cmp	r2, #1
    d96c:	d10e      	bne.n	d98c <bt_mesh_net_recv+0x12c>
}
    d96e:	b012      	add	sp, #72	; 0x48
    d970:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (rx->ctx.recv_ttl <= 1U) {
    d974:	2a01      	cmp	r2, #1
    d976:	d9fa      	bls.n	d96e <bt_mesh_net_recv+0x10e>
	if (rx->net_if == BT_MESH_NET_IF_ADV &&
    d978:	b943      	cbnz	r3, d98c <bt_mesh_net_recv+0x12c>
	    bt_mesh_relay_get() != BT_MESH_RELAY_ENABLED &&
    d97a:	f004 fcbf 	bl	122fc <bt_mesh_relay_get>
	if (rx->net_if == BT_MESH_NET_IF_ADV &&
    d97e:	2801      	cmp	r0, #1
    d980:	d107      	bne.n	d992 <bt_mesh_net_recv+0x132>
	if (rx->net_if == BT_MESH_NET_IF_ADV) {
    d982:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    d986:	f013 0f30 	tst.w	r3, #48	; 0x30
    d98a:	d007      	beq.n	d99c <bt_mesh_net_recv+0x13c>
		transmit = bt_mesh_net_transmit_get();
    d98c:	f004 fc3a 	bl	12204 <bt_mesh_net_transmit_get>
    d990:	e006      	b.n	d9a0 <bt_mesh_net_recv+0x140>
	    bt_mesh_gatt_proxy_get() != BT_MESH_GATT_PROXY_ENABLED) {
    d992:	f004 fe03 	bl	1259c <bt_mesh_gatt_proxy_get>
	    bt_mesh_relay_get() != BT_MESH_RELAY_ENABLED &&
    d996:	2801      	cmp	r0, #1
    d998:	d1e9      	bne.n	d96e <bt_mesh_net_recv+0x10e>
    d99a:	e7f2      	b.n	d982 <bt_mesh_net_recv+0x122>
		transmit = bt_mesh_relay_retransmit_get();
    d99c:	f004 fcc2 	bl	12324 <bt_mesh_relay_retransmit_get>
		transmit = bt_mesh_net_transmit_get();
    d9a0:	4601      	mov	r1, r0
	buf = bt_mesh_adv_create(BT_MESH_ADV_DATA, transmit, K_NO_WAIT);
    d9a2:	2200      	movs	r2, #0
    d9a4:	2001      	movs	r0, #1
    d9a6:	f7fe fbcf 	bl	c148 <bt_mesh_adv_create>
	if (!buf) {
    d9aa:	4604      	mov	r4, r0
    d9ac:	b940      	cbnz	r0, d9c0 <bt_mesh_net_recv+0x160>
    d9ae:	494e      	ldr	r1, [pc, #312]	; (dae8 <bt_mesh_net_recv+0x288>)
    d9b0:	4b4e      	ldr	r3, [pc, #312]	; (daec <bt_mesh_net_recv+0x28c>)
		BT_ERR("Out of relay buffers");
    d9b2:	4853      	ldr	r0, [pc, #332]	; (db00 <bt_mesh_net_recv+0x2a0>)
    d9b4:	1ac9      	subs	r1, r1, r3
    d9b6:	08c9      	lsrs	r1, r1, #3
    d9b8:	0189      	lsls	r1, r1, #6
    d9ba:	f041 0101 	orr.w	r1, r1, #1
    d9be:	e79f      	b.n	d900 <bt_mesh_net_recv+0xa0>
	if (rx->net_if != BT_MESH_NET_IF_LOCAL) {
    d9c0:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    d9c4:	f003 0330 	and.w	r3, r3, #48	; 0x30
    d9c8:	2b10      	cmp	r3, #16
    d9ca:	d00b      	beq.n	d9e4 <bt_mesh_net_recv+0x184>
    d9cc:	9a01      	ldr	r2, [sp, #4]
		sbuf->data[1] &= 0x80;
    d9ce:	7853      	ldrb	r3, [r2, #1]
    d9d0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    d9d4:	7053      	strb	r3, [r2, #1]
		sbuf->data[1] |= rx->ctx.recv_ttl - 1U;
    d9d6:	9a01      	ldr	r2, [sp, #4]
    d9d8:	f89d 301d 	ldrb.w	r3, [sp, #29]
    d9dc:	7851      	ldrb	r1, [r2, #1]
    d9de:	3b01      	subs	r3, #1
    d9e0:	430b      	orrs	r3, r1
    d9e2:	7053      	strb	r3, [r2, #1]
	net_buf_add_mem(buf, sbuf->data, sbuf->len);
    d9e4:	f104 0708 	add.w	r7, r4, #8
    d9e8:	f8bd 2008 	ldrh.w	r2, [sp, #8]
    d9ec:	9901      	ldr	r1, [sp, #4]
    d9ee:	4638      	mov	r0, r7
    d9f0:	f01b f9e1 	bl	28db6 <net_buf_simple_add_mem>
	enc = rx->sub->keys[rx->sub->kr_flag].enc;
    d9f4:	9e04      	ldr	r6, [sp, #16]
	if (rx->friend_cred) {
    d9f6:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
	enc = rx->sub->keys[rx->sub->kr_flag].enc;
    d9fa:	7fb2      	ldrb	r2, [r6, #30]
    d9fc:	2559      	movs	r5, #89	; 0x59
    d9fe:	4355      	muls	r5, r2
    da00:	f105 0041 	add.w	r0, r5, #65	; 0x41
	if (rx->friend_cred) {
    da04:	075a      	lsls	r2, r3, #29
	enc = rx->sub->keys[rx->sub->kr_flag].enc;
    da06:	4430      	add	r0, r6
	if (rx->friend_cred) {
    da08:	d50b      	bpl.n	da22 <bt_mesh_net_recv+0x1c2>
		buf->data[0] &= 0x80; /* Clear everything except IVI */
    da0a:	68a1      	ldr	r1, [r4, #8]
    da0c:	780a      	ldrb	r2, [r1, #0]
	nid = rx->sub->keys[rx->sub->kr_flag].nid;
    da0e:	1973      	adds	r3, r6, r5
		buf->data[0] &= 0x80; /* Clear everything except IVI */
    da10:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	nid = rx->sub->keys[rx->sub->kr_flag].nid;
    da14:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
		buf->data[0] &= 0x80; /* Clear everything except IVI */
    da18:	700a      	strb	r2, [r1, #0]
		buf->data[0] |= nid;
    da1a:	68a2      	ldr	r2, [r4, #8]
    da1c:	7811      	ldrb	r1, [r2, #0]
    da1e:	430b      	orrs	r3, r1
    da20:	7013      	strb	r3, [r2, #0]
	if (bt_mesh_net_encrypt(enc, &buf->b, BT_MESH_NET_IVI_RX(rx), false)) {
    da22:	f8df 80e8 	ldr.w	r8, [pc, #232]	; db0c <bt_mesh_net_recv+0x2ac>
    da26:	f89d 2024 	ldrb.w	r2, [sp, #36]	; 0x24
    da2a:	f8d8 1000 	ldr.w	r1, [r8]
    da2e:	f002 0201 	and.w	r2, r2, #1
    da32:	1a8a      	subs	r2, r1, r2
    da34:	2300      	movs	r3, #0
    da36:	4639      	mov	r1, r7
    da38:	f019 fd07 	bl	2744a <bt_mesh_net_encrypt>
    da3c:	b168      	cbz	r0, da5a <bt_mesh_net_recv+0x1fa>
    da3e:	492a      	ldr	r1, [pc, #168]	; (dae8 <bt_mesh_net_recv+0x288>)
    da40:	4b2a      	ldr	r3, [pc, #168]	; (daec <bt_mesh_net_recv+0x28c>)
		BT_ERR("Re-encrypting failed");
    da42:	4830      	ldr	r0, [pc, #192]	; (db04 <bt_mesh_net_recv+0x2a4>)
    da44:	1ac9      	subs	r1, r1, r3
    da46:	08c9      	lsrs	r1, r1, #3
    da48:	0189      	lsls	r1, r1, #6
    da4a:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Re-obfuscating failed");
    da4e:	f016 fab9 	bl	23fc4 <log_0>
	net_buf_unref(buf);
    da52:	4620      	mov	r0, r4
    da54:	f011 fb38 	bl	1f0c8 <net_buf_unref>
    da58:	e789      	b.n	d96e <bt_mesh_net_recv+0x10e>
	if (bt_mesh_net_obfuscate(buf->data, BT_MESH_NET_IVI_RX(rx), priv)) {
    da5a:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    da5e:	f8d8 1000 	ldr.w	r1, [r8]
    da62:	68a0      	ldr	r0, [r4, #8]
	priv = rx->sub->keys[rx->sub->kr_flag].privacy;
    da64:	f105 0269 	add.w	r2, r5, #105	; 0x69
	if (bt_mesh_net_obfuscate(buf->data, BT_MESH_NET_IVI_RX(rx), priv)) {
    da68:	f003 0301 	and.w	r3, r3, #1
    da6c:	4432      	add	r2, r6
    da6e:	1ac9      	subs	r1, r1, r3
    da70:	f001 fdbc 	bl	f5ec <bt_mesh_net_obfuscate>
    da74:	b140      	cbz	r0, da88 <bt_mesh_net_recv+0x228>
    da76:	491c      	ldr	r1, [pc, #112]	; (dae8 <bt_mesh_net_recv+0x288>)
    da78:	4b1c      	ldr	r3, [pc, #112]	; (daec <bt_mesh_net_recv+0x28c>)
		BT_ERR("Re-obfuscating failed");
    da7a:	4823      	ldr	r0, [pc, #140]	; (db08 <bt_mesh_net_recv+0x2a8>)
    da7c:	1ac9      	subs	r1, r1, r3
    da7e:	08c9      	lsrs	r1, r1, #3
    da80:	0189      	lsls	r1, r1, #6
    da82:	f041 0101 	orr.w	r1, r1, #1
    da86:	e7e2      	b.n	da4e <bt_mesh_net_recv+0x1ee>
	    (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED ||
    da88:	f004 fd88 	bl	1259c <bt_mesh_gatt_proxy_get>
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    da8c:	2801      	cmp	r0, #1
    da8e:	d01c      	beq.n	daca <bt_mesh_net_recv+0x26a>
	     rx->net_if == BT_MESH_NET_IF_LOCAL)) {
    da90:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    da94:	f003 0330 	and.w	r3, r3, #48	; 0x30
    da98:	2b10      	cmp	r3, #16
    da9a:	d016      	beq.n	daca <bt_mesh_net_recv+0x26a>
	if (relay_to_adv(rx->net_if)) {
    da9c:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    daa0:	f3c3 1301 	ubfx	r3, r3, #4, #2
	switch (net_if) {
    daa4:	2b01      	cmp	r3, #1
    daa6:	d00a      	beq.n	dabe <bt_mesh_net_recv+0x25e>
    daa8:	2b02      	cmp	r3, #2
    daaa:	d01a      	beq.n	dae2 <bt_mesh_net_recv+0x282>
    daac:	2b00      	cmp	r3, #0
    daae:	d1d0      	bne.n	da52 <bt_mesh_net_recv+0x1f2>
		return (bt_mesh_relay_get() == BT_MESH_RELAY_ENABLED);
    dab0:	f004 fc24 	bl	122fc <bt_mesh_relay_get>
		return (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED);
    dab4:	1e43      	subs	r3, r0, #1
    dab6:	4258      	negs	r0, r3
    dab8:	4158      	adcs	r0, r3
	if (relay_to_adv(rx->net_if)) {
    daba:	2800      	cmp	r0, #0
    dabc:	d0c9      	beq.n	da52 <bt_mesh_net_recv+0x1f2>
		bt_mesh_adv_send(buf, NULL, NULL);
    dabe:	2200      	movs	r2, #0
    dac0:	4611      	mov	r1, r2
    dac2:	4620      	mov	r0, r4
    dac4:	f7fe fb50 	bl	c168 <bt_mesh_adv_send>
    dac8:	e7c3      	b.n	da52 <bt_mesh_net_recv+0x1f2>
		if (bt_mesh_proxy_relay(&buf->b, rx->ctx.recv_dst) &&
    daca:	f8bd 101a 	ldrh.w	r1, [sp, #26]
    dace:	4638      	mov	r0, r7
    dad0:	f00a f8bc 	bl	17c4c <bt_mesh_proxy_relay>
    dad4:	2800      	cmp	r0, #0
    dad6:	d0e1      	beq.n	da9c <bt_mesh_net_recv+0x23c>
    dad8:	f9bd 301a 	ldrsh.w	r3, [sp, #26]
    dadc:	2b00      	cmp	r3, #0
    dade:	dddd      	ble.n	da9c <bt_mesh_net_recv+0x23c>
    dae0:	e7b7      	b.n	da52 <bt_mesh_net_recv+0x1f2>
		return (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED);
    dae2:	f004 fd5b 	bl	1259c <bt_mesh_gatt_proxy_get>
    dae6:	e7e5      	b.n	dab4 <bt_mesh_net_recv+0x254>
    dae8:	00029958 	.word	0x00029958
    daec:	00029830 	.word	0x00029830
    daf0:	0002d1fb 	.word	0x0002d1fb
    daf4:	0002d21f 	.word	0x0002d21f
    daf8:	200008dc 	.word	0x200008dc
    dafc:	20001f1e 	.word	0x20001f1e
    db00:	0002d254 	.word	0x0002d254
    db04:	0002d269 	.word	0x0002d269
    db08:	0002d27e 	.word	0x0002d27e
    db0c:	20006b48 	.word	0x20006b48

0000db10 <bt_mesh_net_local>:
{
    db10:	b538      	push	{r3, r4, r5, lr}
	while ((buf = net_buf_slist_get(&bt_mesh.local_queue))) {
    db12:	4d08      	ldr	r5, [pc, #32]	; (db34 <bt_mesh_net_local+0x24>)
    db14:	4628      	mov	r0, r5
    db16:	f011 fa3f 	bl	1ef98 <net_buf_slist_get>
    db1a:	4604      	mov	r4, r0
    db1c:	b900      	cbnz	r0, db20 <bt_mesh_net_local+0x10>
}
    db1e:	bd38      	pop	{r3, r4, r5, pc}
		bt_mesh_net_recv(&buf->b, 0, BT_MESH_NET_IF_LOCAL);
    db20:	f104 0008 	add.w	r0, r4, #8
    db24:	2201      	movs	r2, #1
    db26:	2100      	movs	r1, #0
    db28:	f7ff fe9a 	bl	d860 <bt_mesh_net_recv>
		net_buf_unref(buf);
    db2c:	4620      	mov	r0, r4
    db2e:	f011 facb 	bl	1f0c8 <net_buf_unref>
    db32:	e7ef      	b.n	db14 <bt_mesh_net_local+0x4>
    db34:	20006b60 	.word	0x20006b60

0000db38 <bt_mesh_net_start>:

void bt_mesh_net_start(void)
{
    db38:	b510      	push	{r4, lr}
	if (bt_mesh_beacon_get() == BT_MESH_BEACON_ENABLED) {
    db3a:	f004 fc9b 	bl	12474 <bt_mesh_beacon_get>
    db3e:	2801      	cmp	r0, #1
    db40:	d118      	bne.n	db74 <bt_mesh_net_start+0x3c>
		bt_mesh_beacon_enable();
    db42:	f7fe fe51 	bl	c7e8 <bt_mesh_beacon_enable>
	} else {
		bt_mesh_beacon_disable();
	}

	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
	    bt_mesh_gatt_proxy_get() != BT_MESH_GATT_PROXY_NOT_SUPPORTED) {
    db46:	f004 fd29 	bl	1259c <bt_mesh_gatt_proxy_get>
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    db4a:	2802      	cmp	r0, #2
    db4c:	d003      	beq.n	db56 <bt_mesh_net_start+0x1e>
		bt_mesh_proxy_gatt_enable();
    db4e:	f009 fffd 	bl	17b4c <bt_mesh_proxy_gatt_enable>
		bt_mesh_adv_update();
    db52:	f7fe fab9 	bl	c0c8 <bt_mesh_adv_update>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_LOW_POWER)) {
		bt_mesh_lpn_init();
	} else {
		bt_mesh_scan_enable();
    db56:	f7fe fb3d 	bl	c1d4 <bt_mesh_scan_enable>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND)) {
		bt_mesh_friend_init();
    db5a:	f007 fc31 	bl	153c0 <bt_mesh_friend_init>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_PROV)) {
		u16_t net_idx = bt_mesh.sub[0].net_idx;
    db5e:	4b07      	ldr	r3, [pc, #28]	; (db7c <bt_mesh_net_start+0x44>)
    db60:	f8b3 41b8 	ldrh.w	r4, [r3, #440]	; 0x1b8
		u16_t addr = bt_mesh_primary_addr();
    db64:	f001 ffa2 	bl	faac <bt_mesh_primary_addr>
    db68:	4601      	mov	r1, r0

		bt_mesh_prov_complete(net_idx, addr);
    db6a:	4620      	mov	r0, r4
	}
}
    db6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_mesh_prov_complete(net_idx, addr);
    db70:	f008 bd46 	b.w	16600 <bt_mesh_prov_complete>
		bt_mesh_beacon_disable();
    db74:	f7fe fe5e 	bl	c834 <bt_mesh_beacon_disable>
    db78:	e7e5      	b.n	db46 <bt_mesh_net_start+0xe>
    db7a:	bf00      	nop
    db7c:	20006b48 	.word	0x20006b48

0000db80 <bt_mesh_net_init>:

void bt_mesh_net_init(void)
{
    db80:	b510      	push	{r4, lr}
	k_delayed_work_init(&bt_mesh.ivu_timer, ivu_refresh);
    db82:	4c06      	ldr	r4, [pc, #24]	; (db9c <bt_mesh_net_init+0x1c>)
    db84:	4906      	ldr	r1, [pc, #24]	; (dba0 <bt_mesh_net_init+0x20>)
    db86:	f504 708e 	add.w	r0, r4, #284	; 0x11c
    db8a:	f01b fc36 	bl	293fa <k_delayed_work_init>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    db8e:	4a05      	ldr	r2, [pc, #20]	; (dba4 <bt_mesh_net_init+0x24>)
    db90:	2300      	movs	r3, #0
    db92:	e9c4 2304 	strd	r2, r3, [r4, #16]
    db96:	60e3      	str	r3, [r4, #12]

	k_work_init(&bt_mesh.local_work, bt_mesh_net_local);
}
    db98:	bd10      	pop	{r4, pc}
    db9a:	bf00      	nop
    db9c:	20006b48 	.word	0x20006b48
    dba0:	0000d165 	.word	0x0000d165
    dba4:	0000db11 	.word	0x0000db11

0000dba8 <send_unseg>:
}

static int send_unseg(struct bt_mesh_net_tx *tx, struct net_buf_simple *sdu,
		      const struct bt_mesh_send_cb *cb, void *cb_data,
		      const u8_t *ctl_op)
{
    dba8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    dbac:	4604      	mov	r4, r0
    dbae:	4689      	mov	r9, r1
    dbb0:	4616      	mov	r6, r2
	struct net_buf *buf;

	buf = bt_mesh_adv_create(BT_MESH_ADV_DATA, tx->xmit, BUF_TIMEOUT);
    dbb2:	7a81      	ldrb	r1, [r0, #10]
{
    dbb4:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
	buf = bt_mesh_adv_create(BT_MESH_ADV_DATA, tx->xmit, BUF_TIMEOUT);
    dbb8:	2200      	movs	r2, #0
    dbba:	2001      	movs	r0, #1
{
    dbbc:	461f      	mov	r7, r3
	buf = bt_mesh_adv_create(BT_MESH_ADV_DATA, tx->xmit, BUF_TIMEOUT);
    dbbe:	f7fe fac3 	bl	c148 <bt_mesh_adv_create>
	if (!buf) {
    dbc2:	4605      	mov	r5, r0
    dbc4:	b970      	cbnz	r0, dbe4 <send_unseg+0x3c>
    dbc6:	493c      	ldr	r1, [pc, #240]	; (dcb8 <send_unseg+0x110>)
    dbc8:	4b3c      	ldr	r3, [pc, #240]	; (dcbc <send_unseg+0x114>)
		BT_ERR("Out of network buffers");
    dbca:	483d      	ldr	r0, [pc, #244]	; (dcc0 <send_unseg+0x118>)
    dbcc:	1ac9      	subs	r1, r1, r3
    dbce:	08c9      	lsrs	r1, r1, #3
    dbd0:	0189      	lsls	r1, r1, #6
    dbd2:	f041 0101 	orr.w	r1, r1, #1
    dbd6:	f016 f9f5 	bl	23fc4 <log_0>
						    tx->src, tx->ctx->addr,
						    NULL, 1)) {
			if (BT_MESH_ADDR_IS_UNICAST(tx->ctx->addr)) {
				BT_ERR("Not enough space in Friend Queue");
				net_buf_unref(buf);
				return -ENOBUFS;
    dbda:	f06f 0036 	mvn.w	r0, #54	; 0x36
		}
	}

send:
	return bt_mesh_net_send(tx, buf, cb, cb_data);
}
    dbde:	b002      	add	sp, #8
    dbe0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	net_buf_reserve(buf, BT_MESH_NET_HDR_LEN);
    dbe4:	f100 0808 	add.w	r8, r0, #8
    dbe8:	2109      	movs	r1, #9
    dbea:	4640      	mov	r0, r8
    dbec:	f011 f968 	bl	1eec0 <net_buf_simple_reserve>
	if (ctl_op) {
    dbf0:	f1ba 0f00 	cmp.w	sl, #0
    dbf4:	d02e      	beq.n	dc54 <send_unseg+0xac>
		net_buf_add_u8(buf, TRANS_CTL_HDR(*ctl_op, 0));
    dbf6:	f89a 1000 	ldrb.w	r1, [sl]
    dbfa:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		net_buf_add_u8(buf, UNSEG_HDR(1, tx->aid));
    dbfe:	4640      	mov	r0, r8
    dc00:	f01b f8e5 	bl	28dce <net_buf_simple_add_u8>
	net_buf_add_mem(buf, sdu->data, sdu->len);
    dc04:	f8b9 2004 	ldrh.w	r2, [r9, #4]
    dc08:	f8d9 1000 	ldr.w	r1, [r9]
    dc0c:	4640      	mov	r0, r8
    dc0e:	f01b f8d2 	bl	28db6 <net_buf_simple_add_mem>
		if (!bt_mesh_friend_queue_has_space(tx->sub->net_idx,
    dc12:	6863      	ldr	r3, [r4, #4]
    dc14:	8921      	ldrh	r1, [r4, #8]
    dc16:	889a      	ldrh	r2, [r3, #4]
    dc18:	6823      	ldr	r3, [r4, #0]
    dc1a:	f04f 0901 	mov.w	r9, #1
    dc1e:	8b98      	ldrh	r0, [r3, #28]
    dc20:	f8cd 9000 	str.w	r9, [sp]
    dc24:	2300      	movs	r3, #0
    dc26:	f007 fc3b 	bl	154a0 <bt_mesh_friend_queue_has_space>
    dc2a:	bb68      	cbnz	r0, dc88 <send_unseg+0xe0>
			if (BT_MESH_ADDR_IS_UNICAST(tx->ctx->addr)) {
    dc2c:	4b23      	ldr	r3, [pc, #140]	; (dcbc <send_unseg+0x114>)
    dc2e:	4922      	ldr	r1, [pc, #136]	; (dcb8 <send_unseg+0x110>)
    dc30:	1ac9      	subs	r1, r1, r3
    dc32:	6863      	ldr	r3, [r4, #4]
    dc34:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    dc38:	08c9      	lsrs	r1, r1, #3
    dc3a:	2b00      	cmp	r3, #0
    dc3c:	ea4f 1181 	mov.w	r1, r1, lsl #6
    dc40:	dd14      	ble.n	dc6c <send_unseg+0xc4>
				BT_ERR("Not enough space in Friend Queue");
    dc42:	4820      	ldr	r0, [pc, #128]	; (dcc4 <send_unseg+0x11c>)
    dc44:	ea41 0109 	orr.w	r1, r1, r9
    dc48:	f016 f9bc 	bl	23fc4 <log_0>
				net_buf_unref(buf);
    dc4c:	4628      	mov	r0, r5
    dc4e:	f011 fa3b 	bl	1f0c8 <net_buf_unref>
    dc52:	e7c2      	b.n	dbda <send_unseg+0x32>
	} else if (BT_MESH_IS_DEV_KEY(tx->ctx->app_idx)) {
    dc54:	6863      	ldr	r3, [r4, #4]
    dc56:	885b      	ldrh	r3, [r3, #2]
    dc58:	3303      	adds	r3, #3
    dc5a:	b29b      	uxth	r3, r3
    dc5c:	2b01      	cmp	r3, #1
		net_buf_add_u8(buf, UNSEG_HDR(1, tx->aid));
    dc5e:	bf85      	ittet	hi
    dc60:	7ae1      	ldrbhi	r1, [r4, #11]
    dc62:	0889      	lsrhi	r1, r1, #2
		net_buf_add_u8(buf, UNSEG_HDR(0, 0));
    dc64:	4651      	movls	r1, sl
		net_buf_add_u8(buf, UNSEG_HDR(1, tx->aid));
    dc66:	f041 0140 	orrhi.w	r1, r1, #64	; 0x40
    dc6a:	e7c8      	b.n	dbfe <send_unseg+0x56>
				BT_WARN("No space in Friend Queue");
    dc6c:	4816      	ldr	r0, [pc, #88]	; (dcc8 <send_unseg+0x120>)
    dc6e:	f041 0102 	orr.w	r1, r1, #2
    dc72:	f016 f9a7 	bl	23fc4 <log_0>
	return bt_mesh_net_send(tx, buf, cb, cb_data);
    dc76:	463b      	mov	r3, r7
    dc78:	4632      	mov	r2, r6
    dc7a:	4629      	mov	r1, r5
    dc7c:	4620      	mov	r0, r4
}
    dc7e:	b002      	add	sp, #8
    dc80:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_mesh_net_send(tx, buf, cb, cb_data);
    dc84:	f7ff bb4a 	b.w	d31c <bt_mesh_net_send>
		if (bt_mesh_friend_enqueue_tx(tx, BT_MESH_FRIEND_PDU_SINGLE,
    dc88:	2200      	movs	r2, #0
    dc8a:	f8cd 8000 	str.w	r8, [sp]
    dc8e:	464b      	mov	r3, r9
    dc90:	4611      	mov	r1, r2
    dc92:	4620      	mov	r0, r4
    dc94:	f007 fcf4 	bl	15680 <bt_mesh_friend_enqueue_tx>
    dc98:	2800      	cmp	r0, #0
    dc9a:	d0ec      	beq.n	dc76 <send_unseg+0xce>
		    BT_MESH_ADDR_IS_UNICAST(tx->ctx->addr)) {
    dc9c:	6863      	ldr	r3, [r4, #4]
					      NULL, 1, &buf->b) &&
    dc9e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    dca2:	2b00      	cmp	r3, #0
    dca4:	dde7      	ble.n	dc76 <send_unseg+0xce>
			net_buf_unref(buf);
    dca6:	4628      	mov	r0, r5
    dca8:	f011 fa0e 	bl	1f0c8 <net_buf_unref>
			send_cb_finalize(cb, cb_data);
    dcac:	4630      	mov	r0, r6
    dcae:	4639      	mov	r1, r7
    dcb0:	f019 f9ea 	bl	27088 <send_cb_finalize>
			return 0;
    dcb4:	2000      	movs	r0, #0
    dcb6:	e792      	b.n	dbde <send_unseg+0x36>
    dcb8:	00029988 	.word	0x00029988
    dcbc:	00029830 	.word	0x00029830
    dcc0:	0002d2a0 	.word	0x0002d2a0
    dcc4:	0002d2b7 	.word	0x0002d2b7
    dcc8:	0002d2d8 	.word	0x0002d2d8

0000dccc <seg_rx_reset>:
	return bt_mesh_ctl_send(&tx, TRANS_CTL_OP_ACK, buf, sizeof(buf),
				NULL, NULL);
}

static void seg_rx_reset(struct seg_rx *rx, bool full_reset)
{
    dccc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    dcd0:	4604      	mov	r4, r0
	int i;

	BT_DBG("rx %p", rx);

	k_delayed_work_cancel(&rx->ack);
    dcd2:	302c      	adds	r0, #44	; 0x2c
{
    dcd4:	460d      	mov	r5, r1
	k_delayed_work_cancel(&rx->ack);
    dcd6:	f014 ffd3 	bl	22c80 <k_delayed_work_cancel>

	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->obo &&
    dcda:	f994 301f 	ldrsb.w	r3, [r4, #31]
    dcde:	2b00      	cmp	r3, #0
    dce0:	da1a      	bge.n	dd18 <seg_rx_reset+0x4c>
	    rx->block != BLOCK_COMPLETE(rx->seg_n)) {
    dce2:	7fe3      	ldrb	r3, [r4, #31]
    dce4:	f003 031f 	and.w	r3, r3, #31
    dce8:	1c5a      	adds	r2, r3, #1
    dcea:	2301      	movs	r3, #1
    dcec:	4093      	lsls	r3, r2
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->obo &&
    dcee:	6a62      	ldr	r2, [r4, #36]	; 0x24
	    rx->block != BLOCK_COMPLETE(rx->seg_n)) {
    dcf0:	3b01      	subs	r3, #1
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->obo &&
    dcf2:	429a      	cmp	r2, r3
    dcf4:	d010      	beq.n	dd18 <seg_rx_reset+0x4c>
    dcf6:	4917      	ldr	r1, [pc, #92]	; (dd54 <seg_rx_reset+0x88>)
    dcf8:	4b17      	ldr	r3, [pc, #92]	; (dd58 <seg_rx_reset+0x8c>)
		BT_WARN("Clearing incomplete buffers from Friend queue");
    dcfa:	4818      	ldr	r0, [pc, #96]	; (dd5c <seg_rx_reset+0x90>)
    dcfc:	1a5b      	subs	r3, r3, r1
    dcfe:	08db      	lsrs	r3, r3, #3
    dd00:	019b      	lsls	r3, r3, #6
    dd02:	f043 0102 	orr.w	r1, r3, #2
    dd06:	f016 f95d 	bl	23fc4 <log_0>
		bt_mesh_friend_clear_incomplete(rx->sub, rx->src, rx->dst,
    dd0a:	8b62      	ldrh	r2, [r4, #26]
    dd0c:	8b21      	ldrh	r1, [r4, #24]
    dd0e:	6820      	ldr	r0, [r4, #0]
    dd10:	f104 0310 	add.w	r3, r4, #16
    dd14:	f007 fd70 	bl	157f8 <bt_mesh_friend_clear_incomplete>
{
    dd18:	2700      	movs	r7, #0
						&rx->seq_auth);
	}

	for (i = 0; i <= rx->seg_n; i++) {
		k_mem_slab_free(&segs, &rx->seg[i]);
    dd1a:	f8df 9044 	ldr.w	r9, [pc, #68]	; dd60 <seg_rx_reset+0x94>
    dd1e:	f104 0804 	add.w	r8, r4, #4
		rx->seg[i] = NULL;
    dd22:	463e      	mov	r6, r7
		k_mem_slab_free(&segs, &rx->seg[i]);
    dd24:	4641      	mov	r1, r8
    dd26:	4648      	mov	r0, r9
    dd28:	f012 fd8e 	bl	20848 <k_mem_slab_free>
		rx->seg[i] = NULL;
    dd2c:	f848 6b04 	str.w	r6, [r8], #4
	for (i = 0; i <= rx->seg_n; i++) {
    dd30:	7fe3      	ldrb	r3, [r4, #31]
    dd32:	3701      	adds	r7, #1
    dd34:	f003 021f 	and.w	r2, r3, #31
    dd38:	42ba      	cmp	r2, r7
    dd3a:	daf3      	bge.n	dd24 <seg_rx_reset+0x58>
	}

	rx->in_use = 0U;
    dd3c:	f366 1386 	bfi	r3, r6, #6, #1
    dd40:	77e3      	strb	r3, [r4, #31]

	/* We don't always reset these values since we need to be able to
	 * send an ack if we receive a segment after we've already received
	 * the full SDU.
	 */
	if (full_reset) {
    dd42:	b12d      	cbz	r5, dd50 <seg_rx_reset+0x84>
		rx->seq_auth = 0U;
    dd44:	2200      	movs	r2, #0
    dd46:	2300      	movs	r3, #0
    dd48:	e9c4 2304 	strd	r2, r3, [r4, #16]
		rx->sub = NULL;
    dd4c:	6026      	str	r6, [r4, #0]
		rx->src = BT_MESH_ADDR_UNASSIGNED;
    dd4e:	61a6      	str	r6, [r4, #24]
		rx->dst = BT_MESH_ADDR_UNASSIGNED;
	}
}
    dd50:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    dd54:	00029830 	.word	0x00029830
    dd58:	00029988 	.word	0x00029988
    dd5c:	0002d2f1 	.word	0x0002d2f1
    dd60:	20007594 	.word	0x20007594

0000dd64 <app_key_decrypt.constprop.0>:
static int app_key_decrypt(struct bt_mesh_net_rx *rx,
    dd64:	b5f0      	push	{r4, r5, r6, r7, lr}
    dd66:	460c      	mov	r4, r1
	if (key->net_idx != rx->sub->net_idx) {
    dd68:	6801      	ldr	r1, [r0, #0]
    dd6a:	8825      	ldrh	r5, [r4, #0]
    dd6c:	8b89      	ldrh	r1, [r1, #28]
    dd6e:	428d      	cmp	r5, r1
static int app_key_decrypt(struct bt_mesh_net_rx *rx,
    dd70:	b087      	sub	sp, #28
	if (key->net_idx != rx->sub->net_idx) {
    dd72:	d134      	bne.n	ddde <app_key_decrypt.constprop.0+0x7a>
	if (rx->new_key && key->updated) {
    dd74:	7d01      	ldrb	r1, [r0, #20]
    dd76:	078d      	lsls	r5, r1, #30
    dd78:	d52f      	bpl.n	ddda <app_key_decrypt.constprop.0+0x76>
    dd7a:	7925      	ldrb	r5, [r4, #4]
    dd7c:	b36d      	cbz	r5, ddda <app_key_decrypt.constprop.0+0x76>
		keys = &key->keys[1];
    dd7e:	f104 0516 	add.w	r5, r4, #22
	if (AID(&hdr) != keys->id) {
    dd82:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    dd86:	782f      	ldrb	r7, [r5, #0]
    dd88:	f006 063f 	and.w	r6, r6, #63	; 0x3f
    dd8c:	42b7      	cmp	r7, r6
    dd8e:	d126      	bne.n	ddde <app_key_decrypt.constprop.0+0x7a>
	err = bt_mesh_app_decrypt(keys->val, false, aszmic, buf, sdu, ad,
    dd90:	4e14      	ldr	r6, [pc, #80]	; (dde4 <app_key_decrypt.constprop.0+0x80>)
    dd92:	6836      	ldr	r6, [r6, #0]
				  BT_MESH_NET_IVI_RX(rx));
    dd94:	f001 0101 	and.w	r1, r1, #1
	err = bt_mesh_app_decrypt(keys->val, false, aszmic, buf, sdu, ad,
    dd98:	1a71      	subs	r1, r6, r1
    dd9a:	e9cd 2104 	strd	r2, r1, [sp, #16]
    dd9e:	8942      	ldrh	r2, [r0, #10]
    dda0:	9203      	str	r2, [sp, #12]
    dda2:	8902      	ldrh	r2, [r0, #8]
    dda4:	e9cd 3201 	strd	r3, r2, [sp, #4]
    dda8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    ddaa:	9300      	str	r3, [sp, #0]
    ddac:	1c68      	adds	r0, r5, #1
    ddae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    ddb0:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
    ddb4:	2100      	movs	r1, #0
    ddb6:	f019 fc32 	bl	2761e <bt_mesh_app_decrypt>
	if (err) {
    ddba:	4605      	mov	r5, r0
    ddbc:	b150      	cbz	r0, ddd4 <app_key_decrypt.constprop.0+0x70>
    ddbe:	4a0a      	ldr	r2, [pc, #40]	; (dde8 <app_key_decrypt.constprop.0+0x84>)
    ddc0:	4b0a      	ldr	r3, [pc, #40]	; (ddec <app_key_decrypt.constprop.0+0x88>)
		BT_WARN("Unable to decrypt with AppKey 0x%03x", key->app_idx);
    ddc2:	8861      	ldrh	r1, [r4, #2]
    ddc4:	480a      	ldr	r0, [pc, #40]	; (ddf0 <app_key_decrypt.constprop.0+0x8c>)
    ddc6:	1ad2      	subs	r2, r2, r3
    ddc8:	08d2      	lsrs	r2, r2, #3
    ddca:	0192      	lsls	r2, r2, #6
    ddcc:	f042 0202 	orr.w	r2, r2, #2
    ddd0:	f016 f905 	bl	23fde <log_1>
}
    ddd4:	4628      	mov	r0, r5
    ddd6:	b007      	add	sp, #28
    ddd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		keys = &key->keys[0];
    ddda:	1d65      	adds	r5, r4, #5
    dddc:	e7d1      	b.n	dd82 <app_key_decrypt.constprop.0+0x1e>
		return -EINVAL;
    ddde:	f06f 0515 	mvn.w	r5, #21
    dde2:	e7f7      	b.n	ddd4 <app_key_decrypt.constprop.0+0x70>
    dde4:	20006b48 	.word	0x20006b48
    dde8:	00029988 	.word	0x00029988
    ddec:	00029830 	.word	0x00029830
    ddf0:	0002d31f 	.word	0x0002d31f

0000ddf4 <seg_tx_reset>:
{
    ddf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ddf8:	4604      	mov	r4, r0
	k_delayed_work_cancel(&tx->retransmit);
    ddfa:	3030      	adds	r0, #48	; 0x30
    ddfc:	f014 ff40 	bl	22c80 <k_delayed_work_cancel>
	tx->cb = NULL;
    de00:	2500      	movs	r5, #0
	tx->blocked = false;
    de02:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
	k_mem_slab_free(&segs, (void **)&tx->seg[seg_idx]);
    de06:	4f23      	ldr	r7, [pc, #140]	; (de94 <seg_tx_reset+0xa0>)
	tx->sub = NULL;
    de08:	6025      	str	r5, [r4, #0]
	tx->seq_auth = 0U;
    de0a:	2000      	movs	r0, #0
    de0c:	2100      	movs	r1, #0
	tx->cb_data = NULL;
    de0e:	e9c4 550a 	strd	r5, r5, [r4, #40]	; 0x28
	tx->seq_auth = 0U;
    de12:	e9c4 0104 	strd	r0, r1, [r4, #16]
	tx->blocked = false;
    de16:	f365 12c7 	bfi	r2, r5, #7, #1
	tx->src = BT_MESH_ADDR_UNASSIGNED;
    de1a:	61a5      	str	r5, [r4, #24]
	tx->blocked = false;
    de1c:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21
	for (i = 0; i <= tx->seg_n && tx->nack_count; i++) {
    de20:	1d26      	adds	r6, r4, #4
	tx->seg[seg_idx] = NULL;
    de22:	46a8      	mov	r8, r5
	for (i = 0; i <= tx->seg_n && tx->nack_count; i++) {
    de24:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    de28:	b1ab      	cbz	r3, de56 <seg_tx_reset+0x62>
		if (!tx->seg[i]) {
    de2a:	6833      	ldr	r3, [r6, #0]
    de2c:	b153      	cbz	r3, de44 <seg_tx_reset+0x50>
	k_mem_slab_free(&segs, (void **)&tx->seg[seg_idx]);
    de2e:	4631      	mov	r1, r6
    de30:	4638      	mov	r0, r7
    de32:	f012 fd09 	bl	20848 <k_mem_slab_free>
	tx->seg[seg_idx] = NULL;
    de36:	f8c6 8000 	str.w	r8, [r6]
	tx->nack_count--;
    de3a:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    de3e:	3b01      	subs	r3, #1
    de40:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	for (i = 0; i <= tx->seg_n && tx->nack_count; i++) {
    de44:	f894 3020 	ldrb.w	r3, [r4, #32]
    de48:	3501      	adds	r5, #1
    de4a:	f003 031f 	and.w	r3, r3, #31
    de4e:	42ab      	cmp	r3, r5
    de50:	f106 0604 	add.w	r6, r6, #4
    de54:	dae6      	bge.n	de24 <seg_tx_reset+0x30>
	tx->nack_count = 0;
    de56:	2500      	movs	r5, #0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    de58:	4b0f      	ldr	r3, [pc, #60]	; (de98 <seg_tx_reset+0xa4>)
    de5a:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
    de5e:	f3bf 8f5b 	dmb	ish
    de62:	e853 2f00 	ldrex	r2, [r3]
    de66:	f022 0120 	bic.w	r1, r2, #32
    de6a:	e843 1000 	strex	r0, r1, [r3]
    de6e:	2800      	cmp	r0, #0
    de70:	d1f7      	bne.n	de62 <seg_tx_reset+0x6e>
    de72:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_IVU_PENDING)) {
    de76:	0692      	lsls	r2, r2, #26
    de78:	d50a      	bpl.n	de90 <seg_tx_reset+0x9c>
		if (bt_mesh_net_iv_update(bt_mesh.iv_index, false)) {
    de7a:	f853 0c08 	ldr.w	r0, [r3, #-8]
    de7e:	4629      	mov	r1, r5
    de80:	f7ff f88a 	bl	cf98 <bt_mesh_net_iv_update>
    de84:	b120      	cbz	r0, de90 <seg_tx_reset+0x9c>
			bt_mesh_net_sec_update(NULL);
    de86:	4628      	mov	r0, r5
}
    de88:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			bt_mesh_net_sec_update(NULL);
    de8c:	f019 b8e9 	b.w	27062 <bt_mesh_net_sec_update>
}
    de90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    de94:	20007594 	.word	0x20007594
    de98:	20006b50 	.word	0x20006b50

0000de9c <seg_tx_complete>:
		if (&seg_tx[i] != tx &&
    de9c:	4a2a      	ldr	r2, [pc, #168]	; (df48 <seg_tx_complete+0xac>)
    de9e:	4290      	cmp	r0, r2
{
    dea0:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
	void *cb_data = tx->cb_data;
    dea4:	e9d0 560a 	ldrd	r5, r6, [r0, #40]	; 0x28
{
    dea8:	4681      	mov	r9, r0
    deaa:	460c      	mov	r4, r1
		if (&seg_tx[i] != tx &&
    deac:	d01e      	beq.n	deec <seg_tx_complete+0x50>
		    seg_tx[i].blocked &&
    deae:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
		if (&seg_tx[i] != tx &&
    deb2:	09db      	lsrs	r3, r3, #7
    deb4:	d009      	beq.n	deca <seg_tx_complete+0x2e>
	return (tx->src == src) && (tx->dst == dst);
    deb6:	8b01      	ldrh	r1, [r0, #24]
    deb8:	8b13      	ldrh	r3, [r2, #24]
    deba:	4299      	cmp	r1, r3
    debc:	d114      	bne.n	dee8 <seg_tx_complete+0x4c>
    debe:	8b53      	ldrh	r3, [r2, #26]
    dec0:	8b41      	ldrh	r1, [r0, #26]
	struct seg_tx *blocked = NULL;
    dec2:	428b      	cmp	r3, r1
    dec4:	bf0c      	ite	eq
    dec6:	4613      	moveq	r3, r2
    dec8:	2300      	movne	r3, #0
		if (&seg_tx[i] != tx &&
    deca:	4920      	ldr	r1, [pc, #128]	; (df4c <seg_tx_complete+0xb0>)
    decc:	4589      	cmp	r9, r1
    dece:	d10e      	bne.n	deee <seg_tx_complete+0x52>
	if (blocked) {
    ded0:	bb43      	cbnz	r3, df24 <seg_tx_complete+0x88>
	seg_tx_reset(tx);
    ded2:	4648      	mov	r0, r9
    ded4:	f7ff ff8e 	bl	ddf4 <seg_tx_reset>
	if (cb && cb->end) {
    ded8:	b39d      	cbz	r5, df42 <seg_tx_complete+0xa6>
    deda:	686b      	ldr	r3, [r5, #4]
    dedc:	b38b      	cbz	r3, df42 <seg_tx_complete+0xa6>
		cb->end(err, cb_data);
    dede:	4631      	mov	r1, r6
    dee0:	4620      	mov	r0, r4
}
    dee2:	e8bd 4ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
		cb->end(err, cb_data);
    dee6:	4718      	bx	r3
	struct seg_tx *blocked = NULL;
    dee8:	2300      	movs	r3, #0
    deea:	e7ee      	b.n	deca <seg_tx_complete+0x2e>
    deec:	2300      	movs	r3, #0
		    seg_tx[i].blocked &&
    deee:	f892 1071 	ldrb.w	r1, [r2, #113]	; 0x71
		if (&seg_tx[i] != tx &&
    def2:	09c9      	lsrs	r1, r1, #7
    def4:	d0ec      	beq.n	ded0 <seg_tx_complete+0x34>
	return (tx->src == src) && (tx->dst == dst);
    def6:	f8b2 0068 	ldrh.w	r0, [r2, #104]	; 0x68
    defa:	f8b9 1018 	ldrh.w	r1, [r9, #24]
    defe:	4288      	cmp	r0, r1
    df00:	d1e6      	bne.n	ded0 <seg_tx_complete+0x34>
    df02:	f8b2 006a 	ldrh.w	r0, [r2, #106]	; 0x6a
    df06:	f8b9 101a 	ldrh.w	r1, [r9, #26]
    df0a:	4288      	cmp	r0, r1
    df0c:	d1e0      	bne.n	ded0 <seg_tx_complete+0x34>
		    seg_tx_blocks(tx, seg_tx[i].src, seg_tx[i].dst) &&
    df0e:	b1b3      	cbz	r3, df3e <seg_tx_complete+0xa2>
		    (!blocked || seg_tx[i].seq_auth < blocked->seq_auth)) {
    df10:	e9d2 ab18 	ldrd	sl, fp, [r2, #96]	; 0x60
    df14:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
		if (&seg_tx[i] != tx &&
    df18:	4a0c      	ldr	r2, [pc, #48]	; (df4c <seg_tx_complete+0xb0>)
    df1a:	458b      	cmp	fp, r1
    df1c:	bf08      	it	eq
    df1e:	4582      	cmpeq	sl, r0
    df20:	bf38      	it	cc
    df22:	4613      	movcc	r3, r2
		blocked->blocked = false;
    df24:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    df28:	4809      	ldr	r0, [pc, #36]	; (df50 <seg_tx_complete+0xb4>)
    df2a:	f36f 12c7 	bfc	r2, #7, #1
    df2e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    df32:	f103 0130 	add.w	r1, r3, #48	; 0x30
    df36:	2200      	movs	r2, #0
    df38:	f014 fe12 	bl	22b60 <k_delayed_work_submit_to_queue>
    df3c:	e7c9      	b.n	ded2 <seg_tx_complete+0x36>
		if (&seg_tx[i] != tx &&
    df3e:	4b03      	ldr	r3, [pc, #12]	; (df4c <seg_tx_complete+0xb0>)
    df40:	e7f0      	b.n	df24 <seg_tx_complete+0x88>
}
    df42:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
    df46:	bf00      	nop
    df48:	200000a0 	.word	0x200000a0
    df4c:	200000f0 	.word	0x200000f0
    df50:	20001dc4 	.word	0x20001dc4

0000df54 <seg_tx_send_unacked>:
{
    df54:	b5f0      	push	{r4, r5, r6, r7, lr}
		.net_idx = tx->sub->net_idx,
    df56:	6802      	ldr	r2, [r0, #0]
{
    df58:	b087      	sub	sp, #28
	struct bt_mesh_msg_ctx ctx = {
    df5a:	2300      	movs	r3, #0
    df5c:	f8cd 3006 	str.w	r3, [sp, #6]
	struct bt_mesh_net_tx net_tx = {
    df60:	9203      	str	r2, [sp, #12]
	struct bt_mesh_msg_ctx ctx = {
    df62:	8b93      	ldrh	r3, [r2, #28]
	struct bt_mesh_net_tx net_tx = {
    df64:	8b02      	ldrh	r2, [r0, #24]
	struct bt_mesh_msg_ctx ctx = {
    df66:	f8ad 3000 	strh.w	r3, [sp]
	struct bt_mesh_net_tx net_tx = {
    df6a:	f8ad 2014 	strh.w	r2, [sp, #20]
	struct bt_mesh_msg_ctx ctx = {
    df6e:	f890 3020 	ldrb.w	r3, [r0, #32]
	struct bt_mesh_net_tx net_tx = {
    df72:	7fc2      	ldrb	r2, [r0, #31]
    df74:	f88d 2016 	strb.w	r2, [sp, #22]
    df78:	7f82      	ldrb	r2, [r0, #30]
    df7a:	f8cd d010 	str.w	sp, [sp, #16]
	struct bt_mesh_msg_ctx ctx = {
    df7e:	f343 1140 	sbfx	r1, r3, #5, #1
		.friend_cred = tx->friend_cred,
    df82:	f3c3 13c0 	ubfx	r3, r3, #7, #1
	struct bt_mesh_net_tx net_tx = {
    df86:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
	struct bt_mesh_msg_ctx ctx = {
    df8a:	f8ad 1002 	strh.w	r1, [sp, #2]
	struct bt_mesh_net_tx net_tx = {
    df8e:	f88d 3017 	strb.w	r3, [sp, #23]
	struct bt_mesh_msg_ctx ctx = {
    df92:	8b41      	ldrh	r1, [r0, #26]
	if (!tx->attempts) {
    df94:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
	struct bt_mesh_msg_ctx ctx = {
    df98:	f8ad 1004 	strh.w	r1, [sp, #4]
    df9c:	2101      	movs	r1, #1
    df9e:	f88d 100a 	strb.w	r1, [sp, #10]
	if (!tx->attempts) {
    dfa2:	f013 0fe0 	tst.w	r3, #224	; 0xe0
	struct bt_mesh_msg_ctx ctx = {
    dfa6:	f890 1023 	ldrb.w	r1, [r0, #35]	; 0x23
    dfaa:	f88d 100b 	strb.w	r1, [sp, #11]
{
    dfae:	4604      	mov	r4, r0
	if (!tx->attempts) {
    dfb0:	d110      	bne.n	dfd4 <seg_tx_send_unacked+0x80>
    dfb2:	4b38      	ldr	r3, [pc, #224]	; (e094 <seg_tx_send_unacked+0x140>)
    dfb4:	4938      	ldr	r1, [pc, #224]	; (e098 <seg_tx_send_unacked+0x144>)
		BT_ERR("Ran out of retransmit attempts");
    dfb6:	4839      	ldr	r0, [pc, #228]	; (e09c <seg_tx_send_unacked+0x148>)
    dfb8:	1ac9      	subs	r1, r1, r3
    dfba:	08c9      	lsrs	r1, r1, #3
    dfbc:	0189      	lsls	r1, r1, #6
    dfbe:	f041 0101 	orr.w	r1, r1, #1
    dfc2:	f015 ffff 	bl	23fc4 <log_0>
		seg_tx_complete(tx, -ETIMEDOUT);
    dfc6:	f06f 013b 	mvn.w	r1, #59	; 0x3b
    dfca:	4620      	mov	r0, r4
    dfcc:	f7ff ff66 	bl	de9c <seg_tx_complete>
}
    dfd0:	b007      	add	sp, #28
    dfd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	tx->sending = 1U;
    dfd4:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
		err = bt_mesh_net_send(&net_tx, seg, &seg_sent_cb, tx);
    dfd8:	4e31      	ldr	r6, [pc, #196]	; (e0a0 <seg_tx_send_unacked+0x14c>)
	tx->sending = 1U;
    dfda:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    dfde:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
	for (; tx->seg_o <= tx->seg_n; tx->seg_o++) {
    dfe2:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    dfe6:	f894 1020 	ldrb.w	r1, [r4, #32]
    dfea:	461a      	mov	r2, r3
    dfec:	f001 011f 	and.w	r1, r1, #31
    dff0:	f003 031f 	and.w	r3, r3, #31
    dff4:	4299      	cmp	r1, r3
    dff6:	d209      	bcs.n	e00c <seg_tx_send_unacked+0xb8>
	tx->seg_o = 0U;
    dff8:	f022 035f 	bic.w	r3, r2, #95	; 0x5f
    dffc:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	tx->attempts--;
    e000:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    e004:	33e0      	adds	r3, #224	; 0xe0
    e006:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    e00a:	e7e1      	b.n	dfd0 <seg_tx_send_unacked+0x7c>
		if (!tx->seg[tx->seg_o]) {
    e00c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    e010:	685b      	ldr	r3, [r3, #4]
    e012:	b3b3      	cbz	r3, e082 <seg_tx_send_unacked+0x12e>
		seg = bt_mesh_adv_create(BT_MESH_ADV_DATA, tx->xmit,
    e014:	7fe1      	ldrb	r1, [r4, #31]
    e016:	2200      	movs	r2, #0
    e018:	2001      	movs	r0, #1
    e01a:	f7fe f895 	bl	c148 <bt_mesh_adv_create>
		if (!seg) {
    e01e:	4605      	mov	r5, r0
    e020:	b930      	cbnz	r0, e030 <seg_tx_send_unacked+0xdc>
			tx->sending = 0U;
    e022:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    e026:	f360 1386 	bfi	r3, r0, #6, #1
			tx->sending = 0U;
    e02a:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
			return;
    e02e:	e7cf      	b.n	dfd0 <seg_tx_send_unacked+0x7c>
		net_buf_reserve(seg, BT_MESH_NET_HDR_LEN);
    e030:	f100 0708 	add.w	r7, r0, #8
    e034:	2109      	movs	r1, #9
    e036:	4638      	mov	r0, r7
    e038:	f010 ff42 	bl	1eec0 <net_buf_simple_reserve>
		seg_tx_buf_build(tx, tx->seg_o, &seg->b);
    e03c:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
    e040:	463a      	mov	r2, r7
    e042:	f001 011f 	and.w	r1, r1, #31
    e046:	4620      	mov	r0, r4
    e048:	f019 f830 	bl	270ac <seg_tx_buf_build>
		tx->seg_pending++;
    e04c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    e050:	1c5a      	adds	r2, r3, #1
    e052:	f362 0304 	bfi	r3, r2, #0, #5
    e056:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
		err = bt_mesh_net_send(&net_tx, seg, &seg_sent_cb, tx);
    e05a:	4632      	mov	r2, r6
    e05c:	4623      	mov	r3, r4
    e05e:	4629      	mov	r1, r5
    e060:	a803      	add	r0, sp, #12
    e062:	f7ff f95b 	bl	d31c <bt_mesh_net_send>
		if (err) {
    e066:	b160      	cbz	r0, e082 <seg_tx_send_unacked+0x12e>
			tx->seg_pending--;
    e068:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    e06c:	f103 021f 	add.w	r2, r3, #31
    e070:	f362 0304 	bfi	r3, r2, #0, #5
    e074:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
			tx->sending = 0U;
    e078:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    e07c:	f36f 1386 	bfc	r3, #6, #1
    e080:	e7d3      	b.n	e02a <seg_tx_send_unacked+0xd6>
	for (; tx->seg_o <= tx->seg_n; tx->seg_o++) {
    e082:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    e086:	1c5a      	adds	r2, r3, #1
    e088:	f362 0304 	bfi	r3, r2, #0, #5
    e08c:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    e090:	e7a7      	b.n	dfe2 <seg_tx_send_unacked+0x8e>
    e092:	bf00      	nop
    e094:	00029830 	.word	0x00029830
    e098:	00029988 	.word	0x00029988
    e09c:	0002d344 	.word	0x0002d344
    e0a0:	0002a09c 	.word	0x0002a09c

0000e0a4 <send_seg>:
{
    e0a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e0a8:	4698      	mov	r8, r3
		if (seg_tx[i].nack_count) {
    e0aa:	4bae      	ldr	r3, [pc, #696]	; (e364 <send_seg+0x2c0>)
{
    e0ac:	b091      	sub	sp, #68	; 0x44
		if (seg_tx[i].nack_count) {
    e0ae:	f893 5022 	ldrb.w	r5, [r3, #34]	; 0x22
{
    e0b2:	f8dd 9068 	ldr.w	r9, [sp, #104]	; 0x68
    e0b6:	9204      	str	r2, [sp, #16]
    e0b8:	4606      	mov	r6, r0
    e0ba:	460f      	mov	r7, r1
		if (seg_tx[i].nack_count) {
    e0bc:	b365      	cbz	r5, e118 <send_seg+0x74>
	return (tx->src == src) && (tx->dst == dst);
    e0be:	8b19      	ldrh	r1, [r3, #24]
    e0c0:	8902      	ldrh	r2, [r0, #8]
    e0c2:	4291      	cmp	r1, r2
    e0c4:	d021      	beq.n	e10a <send_seg+0x66>
    e0c6:	2500      	movs	r5, #0
	for (tx = NULL, i = 0; i < ARRAY_SIZE(seg_tx); i++) {
    e0c8:	2400      	movs	r4, #0
		if (seg_tx[i].nack_count) {
    e0ca:	f893 2072 	ldrb.w	r2, [r3, #114]	; 0x72
    e0ce:	b33a      	cbz	r2, e120 <send_seg+0x7c>
	return (tx->src == src) && (tx->dst == dst);
    e0d0:	8931      	ldrh	r1, [r6, #8]
    e0d2:	f8b3 2068 	ldrh.w	r2, [r3, #104]	; 0x68
    e0d6:	4291      	cmp	r1, r2
    e0d8:	d120      	bne.n	e11c <send_seg+0x78>
			blocked |= seg_tx_blocks(&seg_tx[i], net_tx->src,
    e0da:	6872      	ldr	r2, [r6, #4]
	return (tx->src == src) && (tx->dst == dst);
    e0dc:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
    e0e0:	8892      	ldrh	r2, [r2, #4]
    e0e2:	1ad2      	subs	r2, r2, r3
    e0e4:	4253      	negs	r3, r2
    e0e6:	4153      	adcs	r3, r2
			blocked |= seg_tx_blocks(&seg_tx[i], net_tx->src,
    e0e8:	431d      	orrs	r5, r3
	if (!tx) {
    e0ea:	b9ec      	cbnz	r4, e128 <send_seg+0x84>
    e0ec:	4b9e      	ldr	r3, [pc, #632]	; (e368 <send_seg+0x2c4>)
    e0ee:	499f      	ldr	r1, [pc, #636]	; (e36c <send_seg+0x2c8>)
		BT_ERR("No multi-segment message contexts available");
    e0f0:	489f      	ldr	r0, [pc, #636]	; (e370 <send_seg+0x2cc>)
    e0f2:	1ac9      	subs	r1, r1, r3
    e0f4:	08c9      	lsrs	r1, r1, #3
    e0f6:	0189      	lsls	r1, r1, #6
    e0f8:	f041 0101 	orr.w	r1, r1, #1
    e0fc:	f015 ff62 	bl	23fc4 <log_0>
		return -EBUSY;
    e100:	f06f 000f 	mvn.w	r0, #15
}
    e104:	b011      	add	sp, #68	; 0x44
    e106:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			blocked |= seg_tx_blocks(&seg_tx[i], net_tx->src,
    e10a:	6842      	ldr	r2, [r0, #4]
	return (tx->src == src) && (tx->dst == dst);
    e10c:	8b58      	ldrh	r0, [r3, #26]
    e10e:	8895      	ldrh	r5, [r2, #4]
    e110:	1a28      	subs	r0, r5, r0
    e112:	4245      	negs	r5, r0
    e114:	4145      	adcs	r5, r0
    e116:	e7d7      	b.n	e0c8 <send_seg+0x24>
			tx = &seg_tx[i];
    e118:	461c      	mov	r4, r3
    e11a:	e7d6      	b.n	e0ca <send_seg+0x26>
	return (tx->src == src) && (tx->dst == dst);
    e11c:	2300      	movs	r3, #0
    e11e:	e7e3      	b.n	e0e8 <send_seg+0x44>
			tx = &seg_tx[i];
    e120:	4b94      	ldr	r3, [pc, #592]	; (e374 <send_seg+0x2d0>)
    e122:	2c00      	cmp	r4, #0
    e124:	bf08      	it	eq
    e126:	461c      	moveq	r4, r3
	if (ctl_op) {
    e128:	6872      	ldr	r2, [r6, #4]
    e12a:	f1b9 0f00 	cmp.w	r9, #0
    e12e:	f000 8091 	beq.w	e254 <send_seg+0x1b0>
		tx->hdr = TRANS_CTL_HDR(*ctl_op, 1);
    e132:	f899 3000 	ldrb.w	r3, [r9]
    e136:	f063 037f 	orn	r3, r3, #127	; 0x7f
		tx->hdr = SEG_HDR(1, net_tx->aid);
    e13a:	77a3      	strb	r3, [r4, #30]
	tx->src = net_tx->src;
    e13c:	8933      	ldrh	r3, [r6, #8]
    e13e:	8323      	strh	r3, [r4, #24]
		return BT_MESH_APP_SEG_SDU_MAX;
    e140:	f1b9 0f00 	cmp.w	r9, #0
	tx->dst = net_tx->ctx->addr;
    e144:	8893      	ldrh	r3, [r2, #4]
	tx->seg_n = (sdu->len - 1) / seg_len(!!ctl_op);
    e146:	88ba      	ldrh	r2, [r7, #4]
	tx->dst = net_tx->ctx->addr;
    e148:	8363      	strh	r3, [r4, #26]
		return BT_MESH_APP_SEG_SDU_MAX;
    e14a:	bf14      	ite	ne
    e14c:	2108      	movne	r1, #8
    e14e:	210c      	moveq	r1, #12
    e150:	9103      	str	r1, [sp, #12]
	tx->seg_n = (sdu->len - 1) / seg_len(!!ctl_op);
    e152:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
    e156:	fb93 f3f1 	sdiv	r3, r3, r1
    e15a:	f894 1020 	ldrb.w	r1, [r4, #32]
	tx->len = sdu->len;
    e15e:	83a2      	strh	r2, [r4, #28]
	tx->seg_n = (sdu->len - 1) / seg_len(!!ctl_op);
    e160:	f003 031f 	and.w	r3, r3, #31
    e164:	f363 0104 	bfi	r1, r3, #0, #5
    e168:	f884 1020 	strb.w	r1, [r4, #32]
	tx->seg_o = 0;
    e16c:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
	tx->seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_TX, bt_mesh.seq);
    e170:	4a81      	ldr	r2, [pc, #516]	; (e378 <send_seg+0x2d4>)
	tx->seg_o = 0;
    e172:	f36f 0104 	bfc	r1, #0, #5
	tx->nack_count = tx->seg_n + 1;
    e176:	f103 0301 	add.w	r3, r3, #1
	tx->seg_o = 0;
    e17a:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21
	tx->nack_count = tx->seg_n + 1;
    e17e:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	tx->seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_TX, bt_mesh.seq);
    e182:	6813      	ldr	r3, [r2, #0]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    e184:	f3bf 8f5b 	dmb	ish
    e188:	6891      	ldr	r1, [r2, #8]
    e18a:	f3bf 8f5b 	dmb	ish
    e18e:	f3c1 0180 	ubfx	r1, r1, #2, #1
    e192:	6852      	ldr	r2, [r2, #4]
    e194:	eba3 0301 	sub.w	r3, r3, r1
    e198:	ea4f 2113 	mov.w	r1, r3, lsr #8
    e19c:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
    e1a0:	e9c4 3104 	strd	r3, r1, [r4, #16]
	tx->sub = net_tx->sub;
    e1a4:	6833      	ldr	r3, [r6, #0]
    e1a6:	6023      	str	r3, [r4, #0]
	tx->cb = cb;
    e1a8:	9b04      	ldr	r3, [sp, #16]
	tx->cb_data = cb_data;
    e1aa:	e9c4 380a 	strd	r3, r8, [r4, #40]	; 0x28
	tx->seg_pending = 0;
    e1ae:	f04f 0380 	mov.w	r3, #128	; 0x80
    e1b2:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	tx->xmit = net_tx->xmit;
    e1b6:	7ab3      	ldrb	r3, [r6, #10]
    e1b8:	77e3      	strb	r3, [r4, #31]
	tx->aszmic = net_tx->aszmic;
    e1ba:	7af2      	ldrb	r2, [r6, #11]
	tx->ctl = !!ctl_op;
    e1bc:	bf18      	it	ne
    e1be:	2320      	movne	r3, #32
    e1c0:	f3c2 0140 	ubfx	r1, r2, #1, #1
    e1c4:	bf08      	it	eq
    e1c6:	2300      	moveq	r3, #0
    e1c8:	f002 0201 	and.w	r2, r2, #1
    e1cc:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
    e1d0:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
    e1d4:	8c22      	ldrh	r2, [r4, #32]
    e1d6:	f422 5203 	bic.w	r2, r2, #8384	; 0x20c0
    e1da:	f022 0220 	bic.w	r2, r2, #32
    e1de:	0452      	lsls	r2, r2, #17
    e1e0:	ea43 33c5 	orr.w	r3, r3, r5, lsl #15
    e1e4:	0c52      	lsrs	r2, r2, #17
    e1e6:	4313      	orrs	r3, r2
    e1e8:	8423      	strh	r3, [r4, #32]
	if (net_tx->ctx->send_ttl == BT_MESH_TTL_DEFAULT) {
    e1ea:	6873      	ldr	r3, [r6, #4]
    e1ec:	7adb      	ldrb	r3, [r3, #11]
    e1ee:	2bff      	cmp	r3, #255	; 0xff
    e1f0:	d13c      	bne.n	e26c <send_seg+0x1c8>
		tx->ttl = bt_mesh_default_ttl_get();
    e1f2:	f004 fa4b 	bl	1268c <bt_mesh_default_ttl_get>
    e1f6:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
	    !bt_mesh_friend_queue_has_space(tx->sub->net_idx, net_tx->src,
    e1fa:	6823      	ldr	r3, [r4, #0]
    e1fc:	8b62      	ldrh	r2, [r4, #26]
    e1fe:	8b98      	ldrh	r0, [r3, #28]
					    tx->seg_n + 1) &&
    e200:	f894 3020 	ldrb.w	r3, [r4, #32]
    e204:	f3c3 0304 	ubfx	r3, r3, #0, #5
    e208:	3301      	adds	r3, #1
	    !bt_mesh_friend_queue_has_space(tx->sub->net_idx, net_tx->src,
    e20a:	b2db      	uxtb	r3, r3
    e20c:	9300      	str	r3, [sp, #0]
    e20e:	f104 0a10 	add.w	sl, r4, #16
    e212:	8931      	ldrh	r1, [r6, #8]
    e214:	4653      	mov	r3, sl
    e216:	f007 f943 	bl	154a0 <bt_mesh_friend_queue_has_space>
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) &&
    e21a:	b350      	cbz	r0, e272 <send_seg+0x1ce>
    e21c:	f1b9 0f00 	cmp.w	r9, #0
    e220:	bf0c      	ite	eq
    e222:	4653      	moveq	r3, sl
    e224:	2300      	movne	r3, #0
		err = k_mem_slab_alloc(&segs, &buf, BUF_TIMEOUT);
    e226:	f8df b15c 	ldr.w	fp, [pc, #348]	; e384 <send_seg+0x2e0>
    e22a:	9305      	str	r3, [sp, #20]
				type = BT_MESH_FRIEND_PDU_COMPLETE;
    e22c:	f04f 0900 	mov.w	r9, #0
	for (seg_o = 0U; sdu->len; seg_o++) {
    e230:	88bb      	ldrh	r3, [r7, #4]
    e232:	fa5f fa89 	uxtb.w	sl, r9
    e236:	2b00      	cmp	r3, #0
    e238:	d134      	bne.n	e2a4 <send_seg+0x200>
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && !tx->seg[0]) {
    e23a:	6866      	ldr	r6, [r4, #4]
    e23c:	2e00      	cmp	r6, #0
    e23e:	f040 8085 	bne.w	e34c <send_seg+0x2a8>
		seg_tx_reset(tx);
    e242:	4620      	mov	r0, r4
    e244:	f7ff fdd6 	bl	ddf4 <seg_tx_reset>
		send_cb_finalize(cb, cb_data);
    e248:	9804      	ldr	r0, [sp, #16]
    e24a:	4641      	mov	r1, r8
    e24c:	f018 ff1c 	bl	27088 <send_cb_finalize>
		return 0;
    e250:	4630      	mov	r0, r6
    e252:	e757      	b.n	e104 <send_seg+0x60>
	} else if (BT_MESH_IS_DEV_KEY(net_tx->ctx->app_idx)) {
    e254:	8853      	ldrh	r3, [r2, #2]
    e256:	3303      	adds	r3, #3
    e258:	b29b      	uxth	r3, r3
    e25a:	2b01      	cmp	r3, #1
		tx->hdr = SEG_HDR(1, net_tx->aid);
    e25c:	bf85      	ittet	hi
    e25e:	7af3      	ldrbhi	r3, [r6, #11]
    e260:	f3c3 0385 	ubfxhi	r3, r3, #2, #6
		tx->hdr = SEG_HDR(0, 0);
    e264:	2380      	movls	r3, #128	; 0x80
		tx->hdr = SEG_HDR(1, net_tx->aid);
    e266:	f063 033f 	ornhi	r3, r3, #63	; 0x3f
    e26a:	e766      	b.n	e13a <send_seg+0x96>
		tx->ttl = net_tx->ctx->send_ttl;
    e26c:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
    e270:	e7c3      	b.n	e1fa <send_seg+0x156>
					    tx->seg_n + 1) &&
    e272:	f9b4 301a 	ldrsh.w	r3, [r4, #26]
    e276:	2b00      	cmp	r3, #0
    e278:	ddd0      	ble.n	e21c <send_seg+0x178>
    e27a:	4a3c      	ldr	r2, [pc, #240]	; (e36c <send_seg+0x2c8>)
    e27c:	4b3a      	ldr	r3, [pc, #232]	; (e368 <send_seg+0x2c4>)
		BT_ERR("Not enough space in Friend Queue for %u segments",
    e27e:	f894 1020 	ldrb.w	r1, [r4, #32]
    e282:	483e      	ldr	r0, [pc, #248]	; (e37c <send_seg+0x2d8>)
    e284:	1ad2      	subs	r2, r2, r3
    e286:	08d2      	lsrs	r2, r2, #3
    e288:	0192      	lsls	r2, r2, #6
    e28a:	f001 011f 	and.w	r1, r1, #31
    e28e:	f042 0201 	orr.w	r2, r2, #1
    e292:	3101      	adds	r1, #1
    e294:	f015 fea3 	bl	23fde <log_1>
			seg_tx_reset(tx);
    e298:	4620      	mov	r0, r4
    e29a:	f7ff fdab 	bl	ddf4 <seg_tx_reset>
			return -ENOBUFS;
    e29e:	f06f 0036 	mvn.w	r0, #54	; 0x36
    e2a2:	e72f      	b.n	e104 <send_seg+0x60>
		err = k_mem_slab_alloc(&segs, &buf, BUF_TIMEOUT);
    e2a4:	2200      	movs	r2, #0
    e2a6:	a908      	add	r1, sp, #32
    e2a8:	4658      	mov	r0, fp
    e2aa:	f012 fa69 	bl	20780 <k_mem_slab_alloc>
		if (err) {
    e2ae:	b150      	cbz	r0, e2c6 <send_seg+0x222>
    e2b0:	4b2d      	ldr	r3, [pc, #180]	; (e368 <send_seg+0x2c4>)
    e2b2:	492e      	ldr	r1, [pc, #184]	; (e36c <send_seg+0x2c8>)
			BT_ERR("Out of segment buffers");
    e2b4:	4832      	ldr	r0, [pc, #200]	; (e380 <send_seg+0x2dc>)
    e2b6:	1ac9      	subs	r1, r1, r3
    e2b8:	08c9      	lsrs	r1, r1, #3
    e2ba:	0189      	lsls	r1, r1, #6
    e2bc:	f041 0101 	orr.w	r1, r1, #1
    e2c0:	f015 fe80 	bl	23fc4 <log_0>
    e2c4:	e7e8      	b.n	e298 <send_seg+0x1f4>
		memcpy(buf, net_buf_simple_pull_mem(sdu, len), len);
    e2c6:	9b08      	ldr	r3, [sp, #32]
    e2c8:	88ba      	ldrh	r2, [r7, #4]
    e2ca:	9307      	str	r3, [sp, #28]
    e2cc:	9b03      	ldr	r3, [sp, #12]
    e2ce:	429a      	cmp	r2, r3
    e2d0:	bf28      	it	cs
    e2d2:	461a      	movcs	r2, r3
    e2d4:	4611      	mov	r1, r2
    e2d6:	4638      	mov	r0, r7
    e2d8:	9206      	str	r2, [sp, #24]
    e2da:	f010 ffdb 	bl	1f294 <net_buf_simple_pull_mem>
    e2de:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    e2e2:	4601      	mov	r1, r0
    e2e4:	4618      	mov	r0, r3
    e2e6:	f017 fcdf 	bl	25ca8 <memcpy>
			NET_BUF_SIMPLE_DEFINE(seg, 16);
    e2ea:	ab0c      	add	r3, sp, #48	; 0x30
    e2ec:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    e2f0:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
			seg_tx_buf_build(tx, seg_o, &seg);
    e2f4:	4651      	mov	r1, sl
    e2f6:	aa09      	add	r2, sp, #36	; 0x24
    e2f8:	4620      	mov	r0, r4
			NET_BUF_SIMPLE_DEFINE(seg, 16);
    e2fa:	9309      	str	r3, [sp, #36]	; 0x24
			seg_tx_buf_build(tx, seg_o, &seg);
    e2fc:	f018 fed6 	bl	270ac <seg_tx_buf_build>
			if (seg_o == tx->seg_n) {
    e300:	f894 1020 	ldrb.w	r1, [r4, #32]
    e304:	f3c1 0304 	ubfx	r3, r1, #0, #5
			if (bt_mesh_friend_enqueue_tx(
    e308:	aa09      	add	r2, sp, #36	; 0x24
			if (seg_o == tx->seg_n) {
    e30a:	f001 011f 	and.w	r1, r1, #31
				    tx->seg_n + 1, &seg) &&
    e30e:	3301      	adds	r3, #1
			if (bt_mesh_friend_enqueue_tx(
    e310:	9200      	str	r2, [sp, #0]
    e312:	b2db      	uxtb	r3, r3
    e314:	9a05      	ldr	r2, [sp, #20]
    e316:	4551      	cmp	r1, sl
    e318:	bf14      	ite	ne
    e31a:	2101      	movne	r1, #1
    e31c:	2102      	moveq	r1, #2
    e31e:	4630      	mov	r0, r6
    e320:	f007 f9ae 	bl	15680 <bt_mesh_friend_enqueue_tx>
    e324:	b158      	cbz	r0, e33e <send_seg+0x29a>
			    BT_MESH_ADDR_IS_UNICAST(net_tx->ctx->addr)) {
    e326:	6873      	ldr	r3, [r6, #4]
				    tx->seg_n + 1, &seg) &&
    e328:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    e32c:	2b00      	cmp	r3, #0
    e32e:	dd06      	ble.n	e33e <send_seg+0x29a>
				k_mem_slab_free(&segs, &buf);
    e330:	a908      	add	r1, sp, #32
    e332:	4658      	mov	r0, fp
    e334:	f012 fa88 	bl	20848 <k_mem_slab_free>
	for (seg_o = 0U; sdu->len; seg_o++) {
    e338:	f109 0901 	add.w	r9, r9, #1
    e33c:	e778      	b.n	e230 <send_seg+0x18c>
		tx->seg[seg_o] = buf;
    e33e:	fa5f f389 	uxtb.w	r3, r9
    e342:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    e346:	9a08      	ldr	r2, [sp, #32]
    e348:	605a      	str	r2, [r3, #4]
    e34a:	e7f5      	b.n	e338 <send_seg+0x294>
	if (blocked) {
    e34c:	b12d      	cbz	r5, e35a <send_seg+0x2b6>
    e34e:	9303      	str	r3, [sp, #12]
		bt_mesh_next_seq();
    e350:	f7fe ff36 	bl	d1c0 <bt_mesh_next_seq>
		return 0;
    e354:	9b03      	ldr	r3, [sp, #12]
    e356:	4618      	mov	r0, r3
    e358:	e6d4      	b.n	e104 <send_seg+0x60>
	seg_tx_send_unacked(tx);
    e35a:	4620      	mov	r0, r4
    e35c:	f7ff fdfa 	bl	df54 <seg_tx_send_unacked>
	return 0;
    e360:	4628      	mov	r0, r5
    e362:	e6cf      	b.n	e104 <send_seg+0x60>
    e364:	200000a0 	.word	0x200000a0
    e368:	00029830 	.word	0x00029830
    e36c:	00029988 	.word	0x00029988
    e370:	0002d363 	.word	0x0002d363
    e374:	200000f0 	.word	0x200000f0
    e378:	20006b48 	.word	0x20006b48
    e37c:	0002d38f 	.word	0x0002d38f
    e380:	0002d3c0 	.word	0x0002d3c0
    e384:	20007594 	.word	0x20007594

0000e388 <schedule_retransmit>:
{
    e388:	b410      	push	{r4}
	if (!tx->nack_count) {
    e38a:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
    e38e:	2b00      	cmp	r3, #0
    e390:	d03c      	beq.n	e40c <schedule_retransmit+0x84>
	if (--tx->seg_pending) {
    e392:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
    e396:	f103 021f 	add.w	r2, r3, #31
    e39a:	f002 021f 	and.w	r2, r2, #31
    e39e:	f362 0304 	bfi	r3, r2, #0, #5
    e3a2:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    e3a6:	bb8a      	cbnz	r2, e40c <schedule_retransmit+0x84>
	if (!BT_MESH_ADDR_IS_UNICAST(tx->dst) &&
    e3a8:	f9b0 401a 	ldrsh.w	r4, [r0, #26]
    e3ac:	2c00      	cmp	r4, #0
    e3ae:	dc15      	bgt.n	e3dc <schedule_retransmit+0x54>
	    (!tx->attempts ||
    e3b0:	b2db      	uxtb	r3, r3
	if (!BT_MESH_ADDR_IS_UNICAST(tx->dst) &&
    e3b2:	f013 02e0 	ands.w	r2, r3, #224	; 0xe0
    e3b6:	d00d      	beq.n	e3d4 <schedule_retransmit+0x4c>
	     (tx->sending && tx->attempts == 1 && tx->seg_n == tx->seg_o))) {
    e3b8:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
	    (!tx->attempts ||
    e3bc:	0659      	lsls	r1, r3, #25
    e3be:	d50d      	bpl.n	e3dc <schedule_retransmit+0x54>
	     (tx->sending && tx->attempts == 1 && tx->seg_n == tx->seg_o))) {
    e3c0:	2a20      	cmp	r2, #32
    e3c2:	d10b      	bne.n	e3dc <schedule_retransmit+0x54>
    e3c4:	f890 2020 	ldrb.w	r2, [r0, #32]
    e3c8:	f003 031f 	and.w	r3, r3, #31
    e3cc:	f002 021f 	and.w	r2, r2, #31
    e3d0:	429a      	cmp	r2, r3
    e3d2:	d103      	bne.n	e3dc <schedule_retransmit+0x54>
}
    e3d4:	bc10      	pop	{r4}
		seg_tx_complete(tx, 0);
    e3d6:	2100      	movs	r1, #0
    e3d8:	f7ff bd60 	b.w	de9c <seg_tx_complete>
			      (tx->sending || !tx->seg_o) ?
    e3dc:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
	k_delayed_work_submit(&tx->retransmit,
    e3e0:	f013 0240 	ands.w	r2, r3, #64	; 0x40
    e3e4:	f100 0130 	add.w	r1, r0, #48	; 0x30
    e3e8:	d101      	bne.n	e3ee <schedule_retransmit+0x66>
			      (tx->sending || !tx->seg_o) ?
    e3ea:	06db      	lsls	r3, r3, #27
    e3ec:	d10a      	bne.n	e404 <schedule_retransmit+0x7c>
				      SEG_RETRANSMIT_TIMEOUT(tx) :
    e3ee:	2c00      	cmp	r4, #0
    e3f0:	bfc8      	it	gt
    e3f2:	f890 0023 	ldrbgt.w	r0, [r0, #35]	; 0x23
    e3f6:	f04f 0232 	mov.w	r2, #50	; 0x32
    e3fa:	bfc4      	itt	gt
    e3fc:	f44f 73c8 	movgt.w	r3, #400	; 0x190
    e400:	fb12 3200 	smlabbgt	r2, r2, r0, r3
    e404:	4802      	ldr	r0, [pc, #8]	; (e410 <schedule_retransmit+0x88>)
}
    e406:	bc10      	pop	{r4}
    e408:	f014 bbaa 	b.w	22b60 <k_delayed_work_submit_to_queue>
    e40c:	bc10      	pop	{r4}
    e40e:	4770      	bx	lr
    e410:	20001dc4 	.word	0x20001dc4

0000e414 <ctl_recv>:
{
    e414:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	switch (ctl_op) {
    e418:	f011 047f 	ands.w	r4, r1, #127	; 0x7f
{
    e41c:	b085      	sub	sp, #20
    e41e:	4606      	mov	r6, r0
    e420:	4615      	mov	r5, r2
    e422:	461f      	mov	r7, r3
	switch (ctl_op) {
    e424:	d014      	beq.n	e450 <ctl_recv+0x3c>
    e426:	2c0a      	cmp	r4, #10
    e428:	f000 80f4 	beq.w	e614 <ctl_recv+0x200>
	if (!rx->local_match) {
    e42c:	7d03      	ldrb	r3, [r0, #20]
    e42e:	f013 0740 	ands.w	r7, r3, #64	; 0x40
    e432:	d01c      	beq.n	e46e <ctl_recv+0x5a>
		switch (ctl_op) {
    e434:	1e63      	subs	r3, r4, #1
    e436:	2b07      	cmp	r3, #7
    e438:	f200 813f 	bhi.w	e6ba <ctl_recv+0x2a6>
    e43c:	e8df f013 	tbh	[pc, r3, lsl #1]
    e440:	013d0119 	.word	0x013d0119
    e444:	013d011f 	.word	0x013d011f
    e448:	012b0125 	.word	0x012b0125
    e44c:	01370131 	.word	0x01370131
	if (buf->len < 6) {
    e450:	8893      	ldrh	r3, [r2, #4]
    e452:	2b05      	cmp	r3, #5
    e454:	d80f      	bhi.n	e476 <ctl_recv+0x62>
    e456:	49a4      	ldr	r1, [pc, #656]	; (e6e8 <ctl_recv+0x2d4>)
    e458:	4ba4      	ldr	r3, [pc, #656]	; (e6ec <ctl_recv+0x2d8>)
		BT_ERR("Too short ack message");
    e45a:	48a5      	ldr	r0, [pc, #660]	; (e6f0 <ctl_recv+0x2dc>)
    e45c:	1ac9      	subs	r1, r1, r3
    e45e:	08c9      	lsrs	r1, r1, #3
    e460:	0189      	lsls	r1, r1, #6
    e462:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Received ack for group seg");
    e466:	f015 fdad 	bl	23fc4 <log_0>
		return -EINVAL;
    e46a:	f06f 0715 	mvn.w	r7, #21
}
    e46e:	4638      	mov	r0, r7
    e470:	b005      	add	sp, #20
    e472:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	seq_zero = net_buf_simple_pull_be16(buf);
    e476:	4610      	mov	r0, r2
    e478:	f01a fc7d 	bl	28d76 <net_buf_simple_pull_be16>
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->friend_match) {
    e47c:	f996 3014 	ldrsb.w	r3, [r6, #20]
    e480:	2b00      	cmp	r3, #0
	seq_zero = net_buf_simple_pull_be16(buf);
    e482:	4680      	mov	r8, r0
	seq_zero = (seq_zero >> 2) & TRANS_SEQ_ZERO_MASK;
    e484:	f3c0 098c 	ubfx	r9, r0, #2, #13
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->friend_match) {
    e488:	da0c      	bge.n	e4a4 <ctl_recv+0x90>
		*seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_RX(rx), seq_zero);
    e48a:	7d33      	ldrb	r3, [r6, #20]
    e48c:	f003 0201 	and.w	r2, r3, #1
    e490:	4b98      	ldr	r3, [pc, #608]	; (e6f4 <ctl_recv+0x2e0>)
    e492:	681b      	ldr	r3, [r3, #0]
    e494:	1a9b      	subs	r3, r3, r2
    e496:	0a1a      	lsrs	r2, r3, #8
    e498:	ea49 6303 	orr.w	r3, r9, r3, lsl #24
    e49c:	e9c7 3200 	strd	r3, r2, [r7]
	return 0;
    e4a0:	2700      	movs	r7, #0
    e4a2:	e7e4      	b.n	e46e <ctl_recv+0x5a>
	ack = net_buf_simple_pull_be32(buf);
    e4a4:	4628      	mov	r0, r5
    e4a6:	f01a fc71 	bl	28d8c <net_buf_simple_pull_be32>
    e4aa:	4a93      	ldr	r2, [pc, #588]	; (e6f8 <ctl_recv+0x2e4>)
	tx = seg_tx_lookup(seq_zero, obo, rx->ctx.addr);
    e4ac:	f8b6 c008 	ldrh.w	ip, [r6, #8]
	ack = net_buf_simple_pull_be32(buf);
    e4b0:	4605      	mov	r5, r0
		if ((tx->seq_auth & TRANS_SEQ_ZERO_MASK) != seq_zero) {
    e4b2:	2100      	movs	r1, #0
    e4b4:	fa1f f089 	uxth.w	r0, r9
	obo = seq_zero >> 15;
    e4b8:	f3c8 3ecf 	ubfx	lr, r8, #15, #16
    e4bc:	4616      	mov	r6, r2
		if ((tx->seq_auth & TRANS_SEQ_ZERO_MASK) != seq_zero) {
    e4be:	4680      	mov	r8, r0
    e4c0:	4689      	mov	r9, r1
    e4c2:	e9d2 1304 	ldrd	r1, r3, [r2, #16]
    e4c6:	9303      	str	r3, [sp, #12]
    e4c8:	f3c1 030c 	ubfx	r3, r1, #0, #13
    e4cc:	9300      	str	r3, [sp, #0]
    e4ce:	2300      	movs	r3, #0
    e4d0:	9301      	str	r3, [sp, #4]
    e4d2:	e9dd ab00 	ldrd	sl, fp, [sp]
    e4d6:	45cb      	cmp	fp, r9
    e4d8:	bf08      	it	eq
    e4da:	45c2      	cmpeq	sl, r8
    e4dc:	d125      	bne.n	e52a <ctl_recv+0x116>
		if (tx->dst == addr) {
    e4de:	8b53      	ldrh	r3, [r2, #26]
    e4e0:	4563      	cmp	r3, ip
    e4e2:	d011      	beq.n	e508 <ctl_recv+0xf4>
		if (obo && tx->nack_count == tx->seg_n + 1) {
    e4e4:	f1be 0f00 	cmp.w	lr, #0
    e4e8:	d01f      	beq.n	e52a <ctl_recv+0x116>
    e4ea:	4b83      	ldr	r3, [pc, #524]	; (e6f8 <ctl_recv+0x2e4>)
    e4ec:	f892 b022 	ldrb.w	fp, [r2, #34]	; 0x22
    e4f0:	2050      	movs	r0, #80	; 0x50
    e4f2:	fb00 3004 	mla	r0, r0, r4, r3
    e4f6:	f890 3020 	ldrb.w	r3, [r0, #32]
    e4fa:	f003 031f 	and.w	r3, r3, #31
    e4fe:	3301      	adds	r3, #1
    e500:	459b      	cmp	fp, r3
    e502:	d112      	bne.n	e52a <ctl_recv+0x116>
			tx->dst = addr;
    e504:	f8a0 c01a 	strh.w	ip, [r0, #26]
	if (!BT_MESH_ADDR_IS_UNICAST(tx->dst)) {
    e508:	2050      	movs	r0, #80	; 0x50
    e50a:	4360      	muls	r0, r4
    e50c:	eb06 0900 	add.w	r9, r6, r0
    e510:	f9b9 301a 	ldrsh.w	r3, [r9, #26]
    e514:	2b00      	cmp	r3, #0
    e516:	dc0e      	bgt.n	e536 <ctl_recv+0x122>
    e518:	4973      	ldr	r1, [pc, #460]	; (e6e8 <ctl_recv+0x2d4>)
    e51a:	4b74      	ldr	r3, [pc, #464]	; (e6ec <ctl_recv+0x2d8>)
		BT_ERR("Received ack for group seg");
    e51c:	4877      	ldr	r0, [pc, #476]	; (e6fc <ctl_recv+0x2e8>)
    e51e:	1ac9      	subs	r1, r1, r3
    e520:	08c9      	lsrs	r1, r1, #3
    e522:	0189      	lsls	r1, r1, #6
    e524:	f041 0101 	orr.w	r1, r1, #1
    e528:	e79d      	b.n	e466 <ctl_recv+0x52>
	for (i = 0; i < ARRAY_SIZE(seg_tx); i++) {
    e52a:	3250      	adds	r2, #80	; 0x50
    e52c:	2c00      	cmp	r4, #0
    e52e:	f040 80d2 	bne.w	e6d6 <ctl_recv+0x2c2>
    e532:	2401      	movs	r4, #1
    e534:	e7c5      	b.n	e4c2 <ctl_recv+0xae>
	*seq_auth = tx->seq_auth;
    e536:	9b03      	ldr	r3, [sp, #12]
    e538:	6039      	str	r1, [r7, #0]
    e53a:	607b      	str	r3, [r7, #4]
	if (!ack) {
    e53c:	b97d      	cbnz	r5, e55e <ctl_recv+0x14a>
    e53e:	4b6b      	ldr	r3, [pc, #428]	; (e6ec <ctl_recv+0x2d8>)
    e540:	4969      	ldr	r1, [pc, #420]	; (e6e8 <ctl_recv+0x2d4>)
		BT_WARN("SDU canceled");
    e542:	486f      	ldr	r0, [pc, #444]	; (e700 <ctl_recv+0x2ec>)
    e544:	1ac9      	subs	r1, r1, r3
    e546:	08c9      	lsrs	r1, r1, #3
    e548:	0189      	lsls	r1, r1, #6
    e54a:	f041 0102 	orr.w	r1, r1, #2
    e54e:	f015 fd39 	bl	23fc4 <log_0>
		seg_tx_complete(tx, -ECANCELED);
    e552:	f06f 0147 	mvn.w	r1, #71	; 0x47
    e556:	4648      	mov	r0, r9
    e558:	f7ff fca0 	bl	de9c <seg_tx_complete>
		return 0;
    e55c:	e7a0      	b.n	e4a0 <ctl_recv+0x8c>
	if (find_msb_set(ack) - 1 > tx->seg_n) {
    e55e:	f899 3020 	ldrb.w	r3, [r9, #32]
{
	if (op == 0) {
		return 0;
	}

	return 32 - __builtin_clz(op);
    e562:	fab5 f285 	clz	r2, r5
    e566:	f1c2 021f 	rsb	r2, r2, #31
    e56a:	f003 031f 	and.w	r3, r3, #31
    e56e:	429a      	cmp	r2, r3
    e570:	d908      	bls.n	e584 <ctl_recv+0x170>
    e572:	495d      	ldr	r1, [pc, #372]	; (e6e8 <ctl_recv+0x2d4>)
    e574:	4b5d      	ldr	r3, [pc, #372]	; (e6ec <ctl_recv+0x2d8>)
		BT_ERR("Too large segment number in ack");
    e576:	4863      	ldr	r0, [pc, #396]	; (e704 <ctl_recv+0x2f0>)
    e578:	1ac9      	subs	r1, r1, r3
    e57a:	08c9      	lsrs	r1, r1, #3
    e57c:	0189      	lsls	r1, r1, #6
    e57e:	f041 0101 	orr.w	r1, r1, #1
    e582:	e770      	b.n	e466 <ctl_recv+0x52>
	k_delayed_work_cancel(&tx->retransmit);
    e584:	3030      	adds	r0, #48	; 0x30
    e586:	4430      	add	r0, r6
    e588:	f014 fb7a 	bl	22c80 <k_delayed_work_cancel>
	while ((bit = find_lsb_set(ack))) {
    e58c:	f04f 0a14 	mov.w	sl, #20
    e590:	fb0a fa04 	mul.w	sl, sl, r4
	tx->nack_count--;
    e594:	46cb      	mov	fp, r9
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(u32_t op)
{
	return __builtin_ffs(op);
    e596:	2d00      	cmp	r5, #0
    e598:	fa95 f8a5 	rbit	r8, r5
    e59c:	fab8 f888 	clz	r8, r8
    e5a0:	bf08      	it	eq
    e5a2:	f04f 38ff 	moveq.w	r8, #4294967295	; 0xffffffff
	while ((bit = find_lsb_set(ack))) {
    e5a6:	f118 0701 	adds.w	r7, r8, #1
    e5aa:	d109      	bne.n	e5c0 <ctl_recv+0x1ac>
	if (tx->nack_count) {
    e5ac:	2150      	movs	r1, #80	; 0x50
    e5ae:	fb01 6404 	mla	r4, r1, r4, r6
    e5b2:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    e5b6:	b343      	cbz	r3, e60a <ctl_recv+0x1f6>
		seg_tx_send_unacked(tx);
    e5b8:	4648      	mov	r0, r9
    e5ba:	f7ff fccb 	bl	df54 <seg_tx_send_unacked>
    e5be:	e756      	b.n	e46e <ctl_recv+0x5a>
		if (tx->seg[bit - 1]) {
    e5c0:	2714      	movs	r7, #20
    e5c2:	4367      	muls	r7, r4
    e5c4:	eb07 0308 	add.w	r3, r7, r8
    e5c8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
    e5cc:	685b      	ldr	r3, [r3, #4]
    e5ce:	b1b3      	cbz	r3, e5fe <ctl_recv+0x1ea>
	k_mem_slab_free(&segs, (void **)&tx->seg[seg_idx]);
    e5d0:	f10a 0101 	add.w	r1, sl, #1
    e5d4:	fa51 f188 	uxtab	r1, r1, r8
			seg_tx_done(tx, bit - 1);
    e5d8:	fa5f f388 	uxtb.w	r3, r8
	k_mem_slab_free(&segs, (void **)&tx->seg[seg_idx]);
    e5dc:	484a      	ldr	r0, [pc, #296]	; (e708 <ctl_recv+0x2f4>)
			seg_tx_done(tx, bit - 1);
    e5de:	9300      	str	r3, [sp, #0]
	k_mem_slab_free(&segs, (void **)&tx->seg[seg_idx]);
    e5e0:	eb06 0181 	add.w	r1, r6, r1, lsl #2
    e5e4:	f012 f930 	bl	20848 <k_mem_slab_free>
	tx->seg[seg_idx] = NULL;
    e5e8:	9b00      	ldr	r3, [sp, #0]
    e5ea:	441f      	add	r7, r3
    e5ec:	eb06 0787 	add.w	r7, r6, r7, lsl #2
    e5f0:	2300      	movs	r3, #0
    e5f2:	607b      	str	r3, [r7, #4]
	tx->nack_count--;
    e5f4:	f89b 3022 	ldrb.w	r3, [fp, #34]	; 0x22
    e5f8:	3b01      	subs	r3, #1
    e5fa:	f88b 3022 	strb.w	r3, [fp, #34]	; 0x22
		ack &= ~BIT(bit - 1);
    e5fe:	2301      	movs	r3, #1
    e600:	fa03 f808 	lsl.w	r8, r3, r8
    e604:	ea25 0508 	bic.w	r5, r5, r8
    e608:	e7c5      	b.n	e596 <ctl_recv+0x182>
		seg_tx_complete(tx, 0);
    e60a:	4639      	mov	r1, r7
    e60c:	4648      	mov	r0, r9
    e60e:	f7ff fc45 	bl	de9c <seg_tx_complete>
    e612:	e72c      	b.n	e46e <ctl_recv+0x5a>
	if (buf->len < 3) {
    e614:	8893      	ldrh	r3, [r2, #4]
    e616:	2b02      	cmp	r3, #2
    e618:	d808      	bhi.n	e62c <ctl_recv+0x218>
    e61a:	4933      	ldr	r1, [pc, #204]	; (e6e8 <ctl_recv+0x2d4>)
    e61c:	4b33      	ldr	r3, [pc, #204]	; (e6ec <ctl_recv+0x2d8>)
		BT_ERR("Too short heartbeat message");
    e61e:	483b      	ldr	r0, [pc, #236]	; (e70c <ctl_recv+0x2f8>)
    e620:	1ac9      	subs	r1, r1, r3
    e622:	08c9      	lsrs	r1, r1, #3
    e624:	0189      	lsls	r1, r1, #6
    e626:	f041 0101 	orr.w	r1, r1, #1
    e62a:	e71c      	b.n	e466 <ctl_recv+0x52>
	if (rx->ctx.recv_dst != hb_sub_dst) {
    e62c:	4b38      	ldr	r3, [pc, #224]	; (e710 <ctl_recv+0x2fc>)
    e62e:	8942      	ldrh	r2, [r0, #10]
    e630:	881b      	ldrh	r3, [r3, #0]
    e632:	429a      	cmp	r2, r3
    e634:	d00a      	beq.n	e64c <ctl_recv+0x238>
    e636:	4b2d      	ldr	r3, [pc, #180]	; (e6ec <ctl_recv+0x2d8>)
    e638:	492b      	ldr	r1, [pc, #172]	; (e6e8 <ctl_recv+0x2d4>)
		BT_WARN("Ignoring heartbeat to non-subscribed destination");
    e63a:	4836      	ldr	r0, [pc, #216]	; (e714 <ctl_recv+0x300>)
    e63c:	1ac9      	subs	r1, r1, r3
    e63e:	08c9      	lsrs	r1, r1, #3
    e640:	0189      	lsls	r1, r1, #6
    e642:	f041 0102 	orr.w	r1, r1, #2
    e646:	f015 fcbd 	bl	23fc4 <log_0>
		return 0;
    e64a:	e729      	b.n	e4a0 <ctl_recv+0x8c>
	init_ttl = (net_buf_simple_pull_u8(buf) & 0x7f);
    e64c:	4628      	mov	r0, r5
    e64e:	f01a fb82 	bl	28d56 <net_buf_simple_pull_u8>
    e652:	4604      	mov	r4, r0
	feat = net_buf_simple_pull_be16(buf);
    e654:	4628      	mov	r0, r5
    e656:	f01a fb8e 	bl	28d76 <net_buf_simple_pull_be16>
	init_ttl = (net_buf_simple_pull_u8(buf) & 0x7f);
    e65a:	f004 027f 	and.w	r2, r4, #127	; 0x7f
	hops = (init_ttl - rx->ctx.recv_ttl + 1);
    e65e:	7b74      	ldrb	r4, [r6, #13]
	bt_mesh_heartbeat(rx->ctx.addr, rx->ctx.recv_dst, hops, feat);
    e660:	8971      	ldrh	r1, [r6, #10]
	hops = (init_ttl - rx->ctx.recv_ttl + 1);
    e662:	1b12      	subs	r2, r2, r4
    e664:	3201      	adds	r2, #1
	feat = net_buf_simple_pull_be16(buf);
    e666:	4603      	mov	r3, r0
	bt_mesh_heartbeat(rx->ctx.addr, rx->ctx.recv_dst, hops, feat);
    e668:	b2d2      	uxtb	r2, r2
    e66a:	8930      	ldrh	r0, [r6, #8]
    e66c:	f003 fd5e 	bl	1212c <bt_mesh_heartbeat>
    e670:	e716      	b.n	e4a0 <ctl_recv+0x8c>
			return bt_mesh_friend_poll(rx, buf);
    e672:	4629      	mov	r1, r5
}
    e674:	b005      	add	sp, #20
    e676:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			return bt_mesh_friend_poll(rx, buf);
    e67a:	f006 bc1f 	b.w	14ebc <bt_mesh_friend_poll>
			return bt_mesh_friend_req(rx, buf);
    e67e:	4629      	mov	r1, r5
}
    e680:	b005      	add	sp, #20
    e682:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			return bt_mesh_friend_req(rx, buf);
    e686:	f006 bd0f 	b.w	150a8 <bt_mesh_friend_req>
			return bt_mesh_friend_clear(rx, buf);
    e68a:	4629      	mov	r1, r5
}
    e68c:	b005      	add	sp, #20
    e68e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			return bt_mesh_friend_clear(rx, buf);
    e692:	f006 babb 	b.w	14c0c <bt_mesh_friend_clear>
			return bt_mesh_friend_clear_cfm(rx, buf);
    e696:	4629      	mov	r1, r5
}
    e698:	b005      	add	sp, #20
    e69a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			return bt_mesh_friend_clear_cfm(rx, buf);
    e69e:	f006 bca1 	b.w	14fe4 <bt_mesh_friend_clear_cfm>
			return bt_mesh_friend_sub_add(rx, buf);
    e6a2:	4629      	mov	r1, r5
}
    e6a4:	b005      	add	sp, #20
    e6a6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			return bt_mesh_friend_sub_add(rx, buf);
    e6aa:	f006 bb3b 	b.w	14d24 <bt_mesh_friend_sub_add>
			return bt_mesh_friend_sub_rem(rx, buf);
    e6ae:	4629      	mov	r1, r5
}
    e6b0:	b005      	add	sp, #20
    e6b2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			return bt_mesh_friend_sub_rem(rx, buf);
    e6b6:	f006 bb9b 	b.w	14df0 <bt_mesh_friend_sub_rem>
    e6ba:	4b0c      	ldr	r3, [pc, #48]	; (e6ec <ctl_recv+0x2d8>)
    e6bc:	4a0a      	ldr	r2, [pc, #40]	; (e6e8 <ctl_recv+0x2d4>)
	BT_WARN("Unhandled TransOpCode 0x%02x", ctl_op);
    e6be:	4816      	ldr	r0, [pc, #88]	; (e718 <ctl_recv+0x304>)
    e6c0:	1ad2      	subs	r2, r2, r3
    e6c2:	08d2      	lsrs	r2, r2, #3
    e6c4:	0192      	lsls	r2, r2, #6
    e6c6:	f042 0202 	orr.w	r2, r2, #2
    e6ca:	4621      	mov	r1, r4
    e6cc:	f015 fc87 	bl	23fde <log_1>
	return -ENOENT;
    e6d0:	f06f 0701 	mvn.w	r7, #1
    e6d4:	e6cb      	b.n	e46e <ctl_recv+0x5a>
    e6d6:	4904      	ldr	r1, [pc, #16]	; (e6e8 <ctl_recv+0x2d4>)
    e6d8:	4b04      	ldr	r3, [pc, #16]	; (e6ec <ctl_recv+0x2d8>)
		BT_WARN("No matching TX context for ack");
    e6da:	4810      	ldr	r0, [pc, #64]	; (e71c <ctl_recv+0x308>)
    e6dc:	1ac9      	subs	r1, r1, r3
    e6de:	08c9      	lsrs	r1, r1, #3
    e6e0:	0189      	lsls	r1, r1, #6
    e6e2:	f041 0102 	orr.w	r1, r1, #2
    e6e6:	e6be      	b.n	e466 <ctl_recv+0x52>
    e6e8:	00029988 	.word	0x00029988
    e6ec:	00029830 	.word	0x00029830
    e6f0:	0002d3d7 	.word	0x0002d3d7
    e6f4:	20006b48 	.word	0x20006b48
    e6f8:	200000a0 	.word	0x200000a0
    e6fc:	0002d3ed 	.word	0x0002d3ed
    e700:	0002d408 	.word	0x0002d408
    e704:	0002d415 	.word	0x0002d415
    e708:	20007594 	.word	0x20007594
    e70c:	0002d435 	.word	0x0002d435
    e710:	20001f20 	.word	0x20001f20
    e714:	0002d451 	.word	0x0002d451
    e718:	0002d482 	.word	0x0002d482
    e71c:	0002d49f 	.word	0x0002d49f

0000e720 <is_replay>:
{
    e720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
    e722:	7d04      	ldrb	r4, [r0, #20]
    e724:	f004 0330 	and.w	r3, r4, #48	; 0x30
    e728:	2b10      	cmp	r3, #16
{
    e72a:	4605      	mov	r5, r0
    e72c:	460e      	mov	r6, r1
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
    e72e:	d00c      	beq.n	e74a <is_replay+0x2a>
	if (!rx->local_match) {
    e730:	f014 0040 	ands.w	r0, r4, #64	; 0x40
    e734:	d00a      	beq.n	e74c <is_replay+0x2c>
    e736:	4922      	ldr	r1, [pc, #136]	; (e7c0 <is_replay+0xa0>)
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
    e738:	2300      	movs	r3, #0
    e73a:	460f      	mov	r7, r1
		if (!rpl->src) {
    e73c:	f8b1 2364 	ldrh.w	r2, [r1, #868]	; 0x364
    e740:	f501 7059 	add.w	r0, r1, #868	; 0x364
    e744:	b982      	cbnz	r2, e768 <is_replay+0x48>
			if (match) {
    e746:	b116      	cbz	r6, e74e <is_replay+0x2e>
					*match = rpl;
    e748:	6030      	str	r0, [r6, #0]
		return false;
    e74a:	2000      	movs	r0, #0
}
    e74c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	rpl->src = rx->ctx.addr;
    e74e:	336c      	adds	r3, #108	; 0x6c
    e750:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
    e754:	892a      	ldrh	r2, [r5, #8]
    e756:	809a      	strh	r2, [r3, #4]
	rpl->seq = rx->seq;
    e758:	692a      	ldr	r2, [r5, #16]
    e75a:	609a      	str	r2, [r3, #8]
	rpl->old_iv = rx->old_iv;
    e75c:	f3c4 0400 	ubfx	r4, r4, #0, #1
    e760:	719c      	strb	r4, [r3, #6]
		bt_mesh_store_rpl(rpl);
    e762:	f019 fa46 	bl	27bf2 <bt_mesh_store_rpl>
    e766:	e7f0      	b.n	e74a <is_replay+0x2a>
		if (rpl->src == rx->ctx.addr) {
    e768:	f8b5 c008 	ldrh.w	ip, [r5, #8]
    e76c:	4562      	cmp	r2, ip
    e76e:	d116      	bne.n	e79e <is_replay+0x7e>
			if (rx->old_iv && !rpl->old_iv) {
    e770:	336c      	adds	r3, #108	; 0x6c
    e772:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    e776:	07e1      	lsls	r1, r4, #31
    e778:	7992      	ldrb	r2, [r2, #6]
    e77a:	d502      	bpl.n	e782 <is_replay+0x62>
    e77c:	b912      	cbnz	r2, e784 <is_replay+0x64>
				return true;
    e77e:	2001      	movs	r0, #1
    e780:	e7e4      	b.n	e74c <is_replay+0x2c>
			if ((!rx->old_iv && rpl->old_iv) ||
    e782:	b92a      	cbnz	r2, e790 <is_replay+0x70>
			    rpl->seq < rx->seq) {
    e784:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
			if ((!rx->old_iv && rpl->old_iv) ||
    e788:	6891      	ldr	r1, [r2, #8]
    e78a:	692a      	ldr	r2, [r5, #16]
    e78c:	4291      	cmp	r1, r2
    e78e:	d2f6      	bcs.n	e77e <is_replay+0x5e>
				if (match) {
    e790:	2e00      	cmp	r6, #0
    e792:	d1d9      	bne.n	e748 <is_replay+0x28>
	rpl->src = rx->ctx.addr;
    e794:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
    e798:	f8a3 c004 	strh.w	ip, [r3, #4]
    e79c:	e7dc      	b.n	e758 <is_replay+0x38>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
    e79e:	3301      	adds	r3, #1
    e7a0:	2b0a      	cmp	r3, #10
    e7a2:	f101 0108 	add.w	r1, r1, #8
    e7a6:	d1c9      	bne.n	e73c <is_replay+0x1c>
    e7a8:	4b06      	ldr	r3, [pc, #24]	; (e7c4 <is_replay+0xa4>)
    e7aa:	4907      	ldr	r1, [pc, #28]	; (e7c8 <is_replay+0xa8>)
	BT_ERR("RPL is full!");
    e7ac:	4807      	ldr	r0, [pc, #28]	; (e7cc <is_replay+0xac>)
    e7ae:	1ac9      	subs	r1, r1, r3
    e7b0:	08c9      	lsrs	r1, r1, #3
    e7b2:	0189      	lsls	r1, r1, #6
    e7b4:	f041 0101 	orr.w	r1, r1, #1
    e7b8:	f015 fc04 	bl	23fc4 <log_0>
	return true;
    e7bc:	e7df      	b.n	e77e <is_replay+0x5e>
    e7be:	bf00      	nop
    e7c0:	20006b48 	.word	0x20006b48
    e7c4:	00029830 	.word	0x00029830
    e7c8:	00029988 	.word	0x00029988
    e7cc:	0002d4be 	.word	0x0002d4be

0000e7d0 <bt_mesh_set_hb_sub_dst>:
	hb_sub_dst = addr;
    e7d0:	4b01      	ldr	r3, [pc, #4]	; (e7d8 <bt_mesh_set_hb_sub_dst+0x8>)
    e7d2:	8018      	strh	r0, [r3, #0]
}
    e7d4:	4770      	bx	lr
    e7d6:	bf00      	nop
    e7d8:	20001f20 	.word	0x20001f20

0000e7dc <bt_mesh_tx_in_progress>:
		if (seg_tx[i].nack_count) {
    e7dc:	4b04      	ldr	r3, [pc, #16]	; (e7f0 <bt_mesh_tx_in_progress+0x14>)
    e7de:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
    e7e2:	f893 3072 	ldrb.w	r3, [r3, #114]	; 0x72
    e7e6:	4313      	orrs	r3, r2
}
    e7e8:	bf14      	ite	ne
    e7ea:	2001      	movne	r0, #1
    e7ec:	2000      	moveq	r0, #0
    e7ee:	4770      	bx	lr
    e7f0:	200000a0 	.word	0x200000a0

0000e7f4 <bt_mesh_app_key_find>:
		if (key->net_idx != BT_MESH_KEY_UNUSED &&
    e7f4:	4b0f      	ldr	r3, [pc, #60]	; (e834 <bt_mesh_app_key_find+0x40>)
    e7f6:	f8b3 114c 	ldrh.w	r1, [r3, #332]	; 0x14c
    e7fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
    e7fe:	4291      	cmp	r1, r2
    e800:	461a      	mov	r2, r3
    e802:	d003      	beq.n	e80c <bt_mesh_app_key_find+0x18>
    e804:	f8b3 114e 	ldrh.w	r1, [r3, #334]	; 0x14e
    e808:	4281      	cmp	r1, r0
    e80a:	d00d      	beq.n	e828 <bt_mesh_app_key_find+0x34>
    e80c:	f8b2 1174 	ldrh.w	r1, [r2, #372]	; 0x174
    e810:	f64f 73ff 	movw	r3, #65535	; 0xffff
    e814:	4299      	cmp	r1, r3
    e816:	d00a      	beq.n	e82e <bt_mesh_app_key_find+0x3a>
    e818:	f8b2 2176 	ldrh.w	r2, [r2, #374]	; 0x176
		struct bt_mesh_app_key *key = &bt_mesh.app_keys[i];
    e81c:	4b06      	ldr	r3, [pc, #24]	; (e838 <bt_mesh_app_key_find+0x44>)
    e81e:	4282      	cmp	r2, r0
    e820:	bf0c      	ite	eq
    e822:	4618      	moveq	r0, r3
    e824:	2000      	movne	r0, #0
    e826:	4770      	bx	lr
    e828:	f503 70a6 	add.w	r0, r3, #332	; 0x14c
    e82c:	4770      	bx	lr
	return NULL;
    e82e:	2000      	movs	r0, #0
}
    e830:	4770      	bx	lr
    e832:	bf00      	nop
    e834:	20006b48 	.word	0x20006b48
    e838:	20006cbc 	.word	0x20006cbc

0000e83c <seg_ack>:

static void seg_ack(struct k_work *work)
{
    e83c:	b530      	push	{r4, r5, lr}
    e83e:	4604      	mov	r4, r0
    e840:	b085      	sub	sp, #20
	struct seg_rx *rx = CONTAINER_OF(work, struct seg_rx, ack);
    e842:	f1a0 052c 	sub.w	r5, r0, #44	; 0x2c
    e846:	f01a fde4 	bl	29412 <z_impl_k_uptime_ticks>
    e84a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    e84e:	460a      	mov	r2, r1
    e850:	fba0 0103 	umull	r0, r1, r0, r3
    e854:	fb03 1102 	mla	r1, r3, r2, r1

	BT_DBG("rx %p", rx);

	if (k_uptime_get_32() - rx->last > K_SECONDS(60)) {
    e858:	f854 2c04 	ldr.w	r2, [r4, #-4]
    e85c:	0bc3      	lsrs	r3, r0, #15
    e85e:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
    e862:	1a9b      	subs	r3, r3, r2
    e864:	f64e 2260 	movw	r2, #60000	; 0xea60
    e868:	4293      	cmp	r3, r2
    e86a:	d910      	bls.n	e88e <seg_ack+0x52>
    e86c:	4b17      	ldr	r3, [pc, #92]	; (e8cc <seg_ack+0x90>)
    e86e:	4918      	ldr	r1, [pc, #96]	; (e8d0 <seg_ack+0x94>)
		BT_WARN("Incomplete timer expired");
    e870:	4818      	ldr	r0, [pc, #96]	; (e8d4 <seg_ack+0x98>)
    e872:	1ac9      	subs	r1, r1, r3
    e874:	08c9      	lsrs	r1, r1, #3
    e876:	0189      	lsls	r1, r1, #6
    e878:	f041 0102 	orr.w	r1, r1, #2
    e87c:	f015 fba2 	bl	23fc4 <log_0>
		seg_rx_reset(rx, false);
    e880:	2100      	movs	r1, #0
    e882:	4628      	mov	r0, r5

	send_ack(rx->sub, rx->dst, rx->src, rx->ttl, &rx->seq_auth,
		 rx->block, rx->obo);

	k_delayed_work_submit(&rx->ack, ack_timeout(rx));
}
    e884:	b005      	add	sp, #20
    e886:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		seg_rx_reset(rx, false);
    e88a:	f7ff ba1f 	b.w	dccc <seg_rx_reset>
		 rx->block, rx->obo);
    e88e:	f814 3c0d 	ldrb.w	r3, [r4, #-13]
	send_ack(rx->sub, rx->dst, rx->src, rx->ttl, &rx->seq_auth,
    e892:	f834 2c14 	ldrh.w	r2, [r4, #-20]
    e896:	f834 1c12 	ldrh.w	r1, [r4, #-18]
    e89a:	f854 0c2c 	ldr.w	r0, [r4, #-44]
    e89e:	09db      	lsrs	r3, r3, #7
    e8a0:	9302      	str	r3, [sp, #8]
    e8a2:	f854 3c08 	ldr.w	r3, [r4, #-8]
    e8a6:	9301      	str	r3, [sp, #4]
    e8a8:	f1a4 031c 	sub.w	r3, r4, #28
    e8ac:	9300      	str	r3, [sp, #0]
    e8ae:	f814 3c0c 	ldrb.w	r3, [r4, #-12]
    e8b2:	f018 fcd0 	bl	27256 <send_ack>
	k_delayed_work_submit(&rx->ack, ack_timeout(rx));
    e8b6:	4628      	mov	r0, r5
    e8b8:	f018 fc37 	bl	2712a <ack_timeout>
    e8bc:	4602      	mov	r2, r0
    e8be:	4806      	ldr	r0, [pc, #24]	; (e8d8 <seg_ack+0x9c>)
    e8c0:	4621      	mov	r1, r4
}
    e8c2:	b005      	add	sp, #20
    e8c4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    e8c8:	f014 b94a 	b.w	22b60 <k_delayed_work_submit_to_queue>
    e8cc:	00029830 	.word	0x00029830
    e8d0:	00029988 	.word	0x00029988
    e8d4:	0002d4cb 	.word	0x0002d4cb
    e8d8:	20001dc4 	.word	0x20001dc4

0000e8dc <bt_mesh_trans_recv>:

	return err;
}

int bt_mesh_trans_recv(struct net_buf_simple *buf, struct bt_mesh_net_rx *rx)
{
    e8dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u64_t seq_auth = TRANS_SEQ_AUTH_NVAL;
    e8e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
    e8e4:	b09f      	sub	sp, #124	; 0x7c
	u64_t seq_auth = TRANS_SEQ_AUTH_NVAL;
    e8e6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    e8ea:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
	struct net_buf_simple_state state;
	u8_t seg_count = 0;
	int err;

	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND)) {
		rx->friend_match = bt_mesh_friend_match(rx->sub->net_idx,
    e8ee:	680b      	ldr	r3, [r1, #0]
{
    e8f0:	4606      	mov	r6, r0
    e8f2:	460c      	mov	r4, r1
		rx->friend_match = bt_mesh_friend_match(rx->sub->net_idx,
    e8f4:	8b98      	ldrh	r0, [r3, #28]
    e8f6:	8949      	ldrh	r1, [r1, #10]
    e8f8:	f006 fd94 	bl	15424 <bt_mesh_friend_match>
    e8fc:	7d23      	ldrb	r3, [r4, #20]
    e8fe:	f360 13c7 	bfi	r3, r0, #7, #1
    e902:	7523      	strb	r3, [r4, #20]

	BT_DBG("src 0x%04x dst 0x%04x seq 0x%08x friend_match %u",
	       rx->ctx.addr, rx->ctx.recv_dst, rx->seq, rx->friend_match);

	/* Remove network headers */
	net_buf_simple_pull(buf, BT_MESH_NET_HDR_LEN);
    e904:	2109      	movs	r1, #9
    e906:	4630      	mov	r0, r6
    e908:	f010 fca4 	bl	1f254 <net_buf_simple_pull>
	state->offset = net_buf_simple_headroom(buf);
    e90c:	4630      	mov	r0, r6
    e90e:	f01a fa46 	bl	28d9e <net_buf_simple_headroom>
	state->len = buf->len;
    e912:	88b3      	ldrh	r3, [r6, #4]
    e914:	9307      	str	r3, [sp, #28]
	/* Save the app-level state so the buffer can later be placed in
	 * the Friend Queue.
	 */
	net_buf_simple_save(buf, &state);

	if (SEG(buf->data)) {
    e916:	6833      	ldr	r3, [r6, #0]
    e918:	9306      	str	r3, [sp, #24]
    e91a:	f993 3000 	ldrsb.w	r3, [r3]
	state->offset = net_buf_simple_headroom(buf);
    e91e:	9009      	str	r0, [sp, #36]	; 0x24
    e920:	2b00      	cmp	r3, #0
    e922:	f280 8387 	bge.w	f034 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5d4>
		/* Segmented messages must match a local element or an
		 * LPN of this Friend.
		 */
		if (!rx->local_match && !rx->friend_match) {
    e926:	7d27      	ldrb	r7, [r4, #20]
    e928:	f017 00c0 	ands.w	r0, r7, #192	; 0xc0
    e92c:	f04f 0900 	mov.w	r9, #0
    e930:	f000 8446 	beq.w	f1c0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x760>
	if (buf->len < 5) {
    e934:	9b07      	ldr	r3, [sp, #28]
	struct bt_mesh_rpl *rpl = NULL;
    e936:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
	if (buf->len < 5) {
    e93a:	2b04      	cmp	r3, #4
    e93c:	d80d      	bhi.n	e95a <bt_mesh_trans_recv+0x7e>
    e93e:	4aa1      	ldr	r2, [pc, #644]	; (ebc4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x164>)
    e940:	4ba1      	ldr	r3, [pc, #644]	; (ebc8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x168>)
		BT_ERR("Too short segmented message (len %u)", buf->len);
    e942:	9907      	ldr	r1, [sp, #28]
    e944:	48a1      	ldr	r0, [pc, #644]	; (ebcc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x16c>)
    e946:	1ad2      	subs	r2, r2, r3
    e948:	08d2      	lsrs	r2, r2, #3
    e94a:	0192      	lsls	r2, r2, #6
    e94c:	f042 0201 	orr.w	r2, r2, #1
    e950:	f015 fb45 	bl	23fde <log_1>
	enum bt_mesh_friend_pdu_type pdu_type = BT_MESH_FRIEND_PDU_SINGLE;
    e954:	f04f 0800 	mov.w	r8, #0
    e958:	e02c      	b.n	e9b4 <bt_mesh_trans_recv+0xd8>
	if (is_replay(net_rx, &rpl)) {
    e95a:	a90b      	add	r1, sp, #44	; 0x2c
    e95c:	4620      	mov	r0, r4
    e95e:	f7ff fedf 	bl	e720 <is_replay>
    e962:	4680      	mov	r8, r0
    e964:	2800      	cmp	r0, #0
    e966:	d1f5      	bne.n	e954 <bt_mesh_trans_recv+0x78>
	net_buf_simple_pull(buf, 1);
    e968:	2101      	movs	r1, #1
    e96a:	4630      	mov	r0, r6
    e96c:	f010 fc72 	bl	1f254 <net_buf_simple_pull>
	seq_zero = net_buf_simple_pull_be16(buf);
    e970:	4630      	mov	r0, r6
    e972:	f01a fa00 	bl	28d76 <net_buf_simple_pull_be16>
	seg_o = (seq_zero & 0x03) << 3;
    e976:	ea4f 0ac0 	mov.w	sl, r0, lsl #3
	seq_zero = (seq_zero >> 2) & TRANS_SEQ_ZERO_MASK;
    e97a:	f3c0 058c 	ubfx	r5, r0, #2, #13
	seg_n = net_buf_simple_pull_u8(buf);
    e97e:	4630      	mov	r0, r6
    e980:	f01a f9e9 	bl	28d56 <net_buf_simple_pull_u8>
	seg_o = (seq_zero & 0x03) << 3;
    e984:	f00a 0a18 	and.w	sl, sl, #24
	seg_o |= seg_n >> 5;
    e988:	ea4a 1a50 	orr.w	sl, sl, r0, lsr #5
    e98c:	fa5f fa8a 	uxtb.w	sl, sl
	seg_n &= 0x1f;
    e990:	f000 071f 	and.w	r7, r0, #31
	if (seg_o > seg_n) {
    e994:	45ba      	cmp	sl, r7
	seg_n = net_buf_simple_pull_u8(buf);
    e996:	4683      	mov	fp, r0
	if (seg_o > seg_n) {
    e998:	d90f      	bls.n	e9ba <bt_mesh_trans_recv+0xde>
    e99a:	4a8b      	ldr	r2, [pc, #556]	; (ebc8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x168>)
    e99c:	4b89      	ldr	r3, [pc, #548]	; (ebc4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x164>)
		BT_ERR("SegO greater than SegN (%u > %u)", seg_o, seg_n);
    e99e:	488c      	ldr	r0, [pc, #560]	; (ebd0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x170>)
    e9a0:	1a9b      	subs	r3, r3, r2
    e9a2:	08db      	lsrs	r3, r3, #3
    e9a4:	019b      	lsls	r3, r3, #6
    e9a6:	f043 0301 	orr.w	r3, r3, #1
    e9aa:	463a      	mov	r2, r7
    e9ac:	4651      	mov	r1, sl
    e9ae:	f015 fb2a 	bl	24006 <log_2>
	u8_t seg_count = 0;
    e9b2:	46c1      	mov	r9, r8
		return -EINVAL;
    e9b4:	f06f 0715 	mvn.w	r7, #21
    e9b8:	e0e4      	b.n	eb84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x124>
	*seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_RX(net_rx),
    e9ba:	6922      	ldr	r2, [r4, #16]
    e9bc:	4985      	ldr	r1, [pc, #532]	; (ebd4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x174>)
    e9be:	7d23      	ldrb	r3, [r4, #20]
    e9c0:	6809      	ldr	r1, [r1, #0]
		if (rx->src != net_rx->ctx.addr ||
    e9c2:	f8d4 c008 	ldr.w	ip, [r4, #8]
	*seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_RX(net_rx),
    e9c6:	1b55      	subs	r5, r2, r5
    e9c8:	f003 0301 	and.w	r3, r3, #1
    e9cc:	f3c5 050c 	ubfx	r5, r5, #0, #13
    e9d0:	1acb      	subs	r3, r1, r3
    e9d2:	1b55      	subs	r5, r2, r5
    e9d4:	ea45 6003 	orr.w	r0, r5, r3, lsl #24
		if (rx->src != net_rx->ctx.addr ||
    e9d8:	4d7f      	ldr	r5, [pc, #508]	; (ebd8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x178>)
	*seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_RX(net_rx),
    e9da:	0a19      	lsrs	r1, r3, #8
	*seg_count = seg_n + 1;
    e9dc:	1c7b      	adds	r3, r7, #1
    e9de:	9308      	str	r3, [sp, #32]
    e9e0:	4699      	mov	r9, r3
		if (rx->src != net_rx->ctx.addr ||
    e9e2:	69ab      	ldr	r3, [r5, #24]
    e9e4:	459c      	cmp	ip, r3
	*seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_RX(net_rx),
    e9e6:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
		if (rx->src != net_rx->ctx.addr ||
    e9ea:	d109      	bne.n	ea00 <bt_mesh_trans_recv+0x124>
		if (rx->seq_auth >= *seq_auth) {
    e9ec:	e9d5 2304 	ldrd	r2, r3, [r5, #16]
    e9f0:	428b      	cmp	r3, r1
    e9f2:	bf08      	it	eq
    e9f4:	4282      	cmpeq	r2, r0
    e9f6:	f080 83e8 	bcs.w	f1ca <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x76a>
		if (rx->in_use) {
    e9fa:	7feb      	ldrb	r3, [r5, #31]
    e9fc:	065b      	lsls	r3, r3, #25
    e9fe:	d40f      	bmi.n	ea20 <bt_mesh_trans_recv+0x144>
		if (rx->src != net_rx->ctx.addr ||
    ea00:	4d75      	ldr	r5, [pc, #468]	; (ebd8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x178>)
    ea02:	6eab      	ldr	r3, [r5, #104]	; 0x68
    ea04:	4563      	cmp	r3, ip
    ea06:	d11a      	bne.n	ea3e <bt_mesh_trans_recv+0x162>
		if (rx->seq_auth >= *seq_auth) {
    ea08:	e9d5 2318 	ldrd	r2, r3, [r5, #96]	; 0x60
    ea0c:	428b      	cmp	r3, r1
    ea0e:	bf08      	it	eq
    ea10:	4282      	cmpeq	r2, r0
    ea12:	f080 83d7 	bcs.w	f1c4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x764>
		if (rx->in_use) {
    ea16:	f895 306f 	ldrb.w	r3, [r5, #111]	; 0x6f
    ea1a:	065a      	lsls	r2, r3, #25
    ea1c:	d50f      	bpl.n	ea3e <bt_mesh_trans_recv+0x162>
		struct seg_rx *rx = &seg_rx[i];
    ea1e:	3550      	adds	r5, #80	; 0x50
    ea20:	4b69      	ldr	r3, [pc, #420]	; (ebc8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x168>)
    ea22:	4a68      	ldr	r2, [pc, #416]	; (ebc4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x164>)
			BT_WARN("Duplicate SDU from src 0x%04x",
    ea24:	8921      	ldrh	r1, [r4, #8]
    ea26:	486d      	ldr	r0, [pc, #436]	; (ebdc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x17c>)
    ea28:	1ad2      	subs	r2, r2, r3
    ea2a:	08d2      	lsrs	r2, r2, #3
    ea2c:	0192      	lsls	r2, r2, #6
    ea2e:	f042 0202 	orr.w	r2, r2, #2
    ea32:	f015 fad4 	bl	23fde <log_1>
			seg_rx_reset(rx, true);
    ea36:	2101      	movs	r1, #1
    ea38:	4628      	mov	r0, r5
    ea3a:	f7ff f947 	bl	dccc <seg_rx_reset>
	if (!sdu_len_is_ok(net_rx->ctl, seg_n)) {
    ea3e:	2f02      	cmp	r7, #2
    ea40:	d973      	bls.n	eb2a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xca>
    ea42:	4b61      	ldr	r3, [pc, #388]	; (ebc8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x168>)
    ea44:	495f      	ldr	r1, [pc, #380]	; (ebc4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x164>)
		BT_ERR("Too big incoming SDU length");
    ea46:	4866      	ldr	r0, [pc, #408]	; (ebe0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x180>)
    ea48:	1ac9      	subs	r1, r1, r3
    ea4a:	08c9      	lsrs	r1, r1, #3
    ea4c:	0189      	lsls	r1, r1, #6
    ea4e:	f041 0101 	orr.w	r1, r1, #1
    ea52:	f015 fab7 	bl	23fc4 <log_0>
			 net_rx->friend_match);
    ea56:	7d23      	ldrb	r3, [r4, #20]
		send_ack(net_rx->sub, net_rx->ctx.recv_dst, net_rx->ctx.addr,
    ea58:	8922      	ldrh	r2, [r4, #8]
    ea5a:	8961      	ldrh	r1, [r4, #10]
    ea5c:	6820      	ldr	r0, [r4, #0]
    ea5e:	09db      	lsrs	r3, r3, #7
    ea60:	9302      	str	r3, [sp, #8]
    ea62:	2500      	movs	r5, #0
    ea64:	ab0c      	add	r3, sp, #48	; 0x30
    ea66:	9300      	str	r3, [sp, #0]
    ea68:	9501      	str	r5, [sp, #4]
    ea6a:	7be3      	ldrb	r3, [r4, #15]
    ea6c:	f018 fbf3 	bl	27256 <send_ack>
	enum bt_mesh_friend_pdu_type pdu_type = BT_MESH_FRIEND_PDU_SINGLE;
    ea70:	46a8      	mov	r8, r5
			return -EMSGSIZE;
    ea72:	f06f 0723 	mvn.w	r7, #35	; 0x23
    ea76:	e085      	b.n	eb84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x124>
	if (rx->hdr != *hdr || rx->seg_n != seg_n) {
    ea78:	4b57      	ldr	r3, [pc, #348]	; (ebd8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x178>)
    ea7a:	9a06      	ldr	r2, [sp, #24]
    ea7c:	2050      	movs	r0, #80	; 0x50
    ea7e:	fb00 3308 	mla	r3, r0, r8, r3
    ea82:	7811      	ldrb	r1, [r2, #0]
    ea84:	7f9a      	ldrb	r2, [r3, #30]
    ea86:	4291      	cmp	r1, r2
    ea88:	d104      	bne.n	ea94 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x34>
    ea8a:	7fda      	ldrb	r2, [r3, #31]
    ea8c:	f002 011f 	and.w	r1, r2, #31
    ea90:	42b9      	cmp	r1, r7
    ea92:	d008      	beq.n	eaa6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x46>
    ea94:	494b      	ldr	r1, [pc, #300]	; (ebc4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x164>)
    ea96:	4b4c      	ldr	r3, [pc, #304]	; (ebc8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x168>)
		BT_ERR("Invalid segment for ongoing session");
    ea98:	4852      	ldr	r0, [pc, #328]	; (ebe4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x184>)
    ea9a:	1ac9      	subs	r1, r1, r3
    ea9c:	08c9      	lsrs	r1, r1, #3
    ea9e:	0189      	lsls	r1, r1, #6
    eaa0:	f041 0101 	orr.w	r1, r1, #1
    eaa4:	e39e      	b.n	f1e4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x784>
	if (rx->ctl != net_rx->ctl) {
    eaa6:	7d21      	ldrb	r1, [r4, #20]
    eaa8:	f3c2 1040 	ubfx	r0, r2, #5, #1
    eaac:	f3c1 01c0 	ubfx	r1, r1, #3, #1
    eab0:	4288      	cmp	r0, r1
    eab2:	d008      	beq.n	eac6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x66>
    eab4:	4943      	ldr	r1, [pc, #268]	; (ebc4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x164>)
    eab6:	4b44      	ldr	r3, [pc, #272]	; (ebc8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x168>)
		BT_ERR("Inconsistent CTL in segment");
    eab8:	484b      	ldr	r0, [pc, #300]	; (ebe8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x188>)
    eaba:	1ac9      	subs	r1, r1, r3
    eabc:	08c9      	lsrs	r1, r1, #3
    eabe:	0189      	lsls	r1, r1, #6
    eac0:	f041 0101 	orr.w	r1, r1, #1
    eac4:	e38e      	b.n	f1e4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x784>
		if (rx->in_use) {
    eac6:	f893 801f 	ldrb.w	r8, [r3, #31]
    eaca:	f018 0840 	ands.w	r8, r8, #64	; 0x40
    eace:	f040 80ec 	bne.w	ecaa <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x24a>
		if (rx->block == BLOCK_COMPLETE(rx->seg_n)) {
    ead2:	1c79      	adds	r1, r7, #1
    ead4:	2701      	movs	r7, #1
    ead6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    ead8:	408f      	lsls	r7, r1
    eada:	3f01      	subs	r7, #1
    eadc:	42bb      	cmp	r3, r7
    eade:	d119      	bne.n	eb14 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xb4>
			send_ack(net_rx->sub, net_rx->ctx.recv_dst,
    eae0:	09d2      	lsrs	r2, r2, #7
    eae2:	e9cd 3201 	strd	r3, r2, [sp, #4]
    eae6:	ab0c      	add	r3, sp, #48	; 0x30
    eae8:	9300      	str	r3, [sp, #0]
    eaea:	8922      	ldrh	r2, [r4, #8]
    eaec:	7be3      	ldrb	r3, [r4, #15]
    eaee:	8961      	ldrh	r1, [r4, #10]
    eaf0:	6820      	ldr	r0, [r4, #0]
    eaf2:	f018 fbb0 	bl	27256 <send_ack>
			if (rpl) {
    eaf6:	980b      	ldr	r0, [sp, #44]	; 0x2c
    eaf8:	b148      	cbz	r0, eb0e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xae>
	rpl->src = rx->ctx.addr;
    eafa:	8923      	ldrh	r3, [r4, #8]
    eafc:	8003      	strh	r3, [r0, #0]
	rpl->seq = rx->seq;
    eafe:	6923      	ldr	r3, [r4, #16]
    eb00:	6043      	str	r3, [r0, #4]
	rpl->old_iv = rx->old_iv;
    eb02:	7d23      	ldrb	r3, [r4, #20]
    eb04:	f3c3 0300 	ubfx	r3, r3, #0, #1
    eb08:	7083      	strb	r3, [r0, #2]
		bt_mesh_store_rpl(rpl);
    eb0a:	f019 f872 	bl	27bf2 <bt_mesh_store_rpl>
			return -EALREADY;
    eb0e:	f06f 0744 	mvn.w	r7, #68	; 0x44
    eb12:	e037      	b.n	eb84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x124>
    eb14:	492b      	ldr	r1, [pc, #172]	; (ebc4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x164>)
    eb16:	4b2c      	ldr	r3, [pc, #176]	; (ebc8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x168>)
		BT_WARN("Got segment for canceled SDU");
    eb18:	4834      	ldr	r0, [pc, #208]	; (ebec <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x18c>)
    eb1a:	1ac9      	subs	r1, r1, r3
    eb1c:	08c9      	lsrs	r1, r1, #3
    eb1e:	0189      	lsls	r1, r1, #6
    eb20:	f041 0102 	orr.w	r1, r1, #2
			BT_ERR("Incorrect segment size for message type");
    eb24:	f015 fa4e 	bl	23fc4 <log_0>
			return -EINVAL;
    eb28:	e744      	b.n	e9b4 <bt_mesh_trans_recv+0xd8>
	    net_rx->friend_match && !net_rx->local_match &&
    eb2a:	7d23      	ldrb	r3, [r4, #20]
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) &&
    eb2c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    eb30:	2b80      	cmp	r3, #128	; 0x80
    eb32:	d15f      	bne.n	ebf4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x194>
	    !bt_mesh_friend_queue_has_space(net_rx->sub->net_idx,
    eb34:	6823      	ldr	r3, [r4, #0]
    eb36:	8962      	ldrh	r2, [r4, #10]
    eb38:	8b98      	ldrh	r0, [r3, #28]
    eb3a:	8921      	ldrh	r1, [r4, #8]
    eb3c:	f8cd 9000 	str.w	r9, [sp]
    eb40:	f10d 0830 	add.w	r8, sp, #48	; 0x30
    eb44:	4643      	mov	r3, r8
    eb46:	f006 fcab 	bl	154a0 <bt_mesh_friend_queue_has_space>
	    net_rx->friend_match && !net_rx->local_match &&
    eb4a:	4605      	mov	r5, r0
    eb4c:	2800      	cmp	r0, #0
    eb4e:	d151      	bne.n	ebf4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x194>
    eb50:	4b1d      	ldr	r3, [pc, #116]	; (ebc8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x168>)
    eb52:	4a1c      	ldr	r2, [pc, #112]	; (ebc4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x164>)
		BT_ERR("No space in Friend Queue for %u segments", *seg_count);
    eb54:	9908      	ldr	r1, [sp, #32]
    eb56:	4826      	ldr	r0, [pc, #152]	; (ebf0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x190>)
    eb58:	1ad2      	subs	r2, r2, r3
    eb5a:	08d2      	lsrs	r2, r2, #3
    eb5c:	0192      	lsls	r2, r2, #6
    eb5e:	f042 0201 	orr.w	r2, r2, #1
    eb62:	f015 fa3c 	bl	23fde <log_1>
			 net_rx->friend_match);
    eb66:	7d23      	ldrb	r3, [r4, #20]
		send_ack(net_rx->sub, net_rx->ctx.recv_dst, net_rx->ctx.addr,
    eb68:	f8cd 8000 	str.w	r8, [sp]
    eb6c:	09db      	lsrs	r3, r3, #7
    eb6e:	e9cd 5301 	strd	r5, r3, [sp, #4]
    eb72:	8922      	ldrh	r2, [r4, #8]
    eb74:	7be3      	ldrb	r3, [r4, #15]
    eb76:	8961      	ldrh	r1, [r4, #10]
    eb78:	6820      	ldr	r0, [r4, #0]
    eb7a:	f018 fb6c 	bl	27256 <send_ack>
	enum bt_mesh_friend_pdu_type pdu_type = BT_MESH_FRIEND_PDU_SINGLE;
    eb7e:	46a8      	mov	r8, r5
		return -ENOBUFS;
    eb80:	f06f 0736 	mvn.w	r7, #54	; 0x36
	buf->data = buf->__buf + state->offset;
    eb84:	9b09      	ldr	r3, [sp, #36]	; 0x24
    eb86:	68b0      	ldr	r0, [r6, #8]
    eb88:	fa10 f083 	uxtah	r0, r0, r3
	buf->len = state->len;
    eb8c:	9b07      	ldr	r3, [sp, #28]
    eb8e:	80b3      	strh	r3, [r6, #4]
		bt_mesh_lpn_msg_received(rx);
	}

	net_buf_simple_restore(buf, &state);

	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->friend_match && !err) {
    eb90:	f994 3014 	ldrsb.w	r3, [r4, #20]
	buf->data = buf->__buf + state->offset;
    eb94:	6030      	str	r0, [r6, #0]
    eb96:	2b00      	cmp	r3, #0
    eb98:	da0f      	bge.n	ebba <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x15a>
    eb9a:	b977      	cbnz	r7, ebba <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x15a>
		if (seq_auth == TRANS_SEQ_AUTH_NVAL) {
    eb9c:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
    eba0:	3301      	adds	r3, #1
    eba2:	bf08      	it	eq
    eba4:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
			bt_mesh_friend_enqueue_rx(rx, pdu_type, NULL,
    eba8:	9600      	str	r6, [sp, #0]
    ebaa:	464b      	mov	r3, r9
    ebac:	bf0c      	ite	eq
    ebae:	463a      	moveq	r2, r7
						  seg_count, buf);
		} else {
			bt_mesh_friend_enqueue_rx(rx, pdu_type, &seq_auth,
    ebb0:	aa0c      	addne	r2, sp, #48	; 0x30
    ebb2:	4641      	mov	r1, r8
    ebb4:	4620      	mov	r0, r4
    ebb6:	f006 fcab 	bl	15510 <bt_mesh_friend_enqueue_rx>
						  seg_count, buf);
		}
	}

	return err;
}
    ebba:	4638      	mov	r0, r7
    ebbc:	b01f      	add	sp, #124	; 0x7c
    ebbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ebc2:	bf00      	nop
    ebc4:	00029988 	.word	0x00029988
    ebc8:	00029830 	.word	0x00029830
    ebcc:	0002d4e4 	.word	0x0002d4e4
    ebd0:	0002d509 	.word	0x0002d509
    ebd4:	20006b48 	.word	0x20006b48
    ebd8:	20000000 	.word	0x20000000
    ebdc:	0002d52a 	.word	0x0002d52a
    ebe0:	0002d5ba 	.word	0x0002d5ba
    ebe4:	0002d55d 	.word	0x0002d55d
    ebe8:	0002d581 	.word	0x0002d581
    ebec:	0002d59d 	.word	0x0002d59d
    ebf0:	0002d5d6 	.word	0x0002d5d6
	return slab->num_blocks - slab->num_used;
    ebf4:	4aa3      	ldr	r2, [pc, #652]	; (ee84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x424>)
    ebf6:	6893      	ldr	r3, [r2, #8]
    ebf8:	6992      	ldr	r2, [r2, #24]
    ebfa:	1a9b      	subs	r3, r3, r2
	if (k_mem_slab_num_free_get(&segs) < seg_n) {
    ebfc:	42bb      	cmp	r3, r7
    ebfe:	d367      	bcc.n	ecd0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x270>
		if (rx->in_use) {
    ec00:	49a1      	ldr	r1, [pc, #644]	; (ee88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x428>)
    ec02:	7fca      	ldrb	r2, [r1, #31]
    ec04:	f012 0240 	ands.w	r2, r2, #64	; 0x40
    ec08:	4688      	mov	r8, r1
    ec0a:	d07a      	beq.n	ed02 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2a2>
    ec0c:	f891 306f 	ldrb.w	r3, [r1, #111]	; 0x6f
    ec10:	065b      	lsls	r3, r3, #25
    ec12:	d467      	bmi.n	ece4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x284>
	for (i = 0; i < ARRAY_SIZE(seg_rx); i++) {
    ec14:	2201      	movs	r2, #1
		struct seg_rx *rx = &seg_rx[i];
    ec16:	f101 0550 	add.w	r5, r1, #80	; 0x50
		rx->sub = net_rx->sub;
    ec1a:	2350      	movs	r3, #80	; 0x50
    ec1c:	4353      	muls	r3, r2
    ec1e:	6820      	ldr	r0, [r4, #0]
    ec20:	f848 0003 	str.w	r0, [r8, r3]
		rx->seq_auth = *seq_auth;
    ec24:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
		rx->sub = net_rx->sub;
    ec28:	eb08 0c03 	add.w	ip, r8, r3
		rx->ctl = net_rx->ctl;
    ec2c:	f894 e014 	ldrb.w	lr, [r4, #20]
    ec30:	3318      	adds	r3, #24
		rx->seq_auth = *seq_auth;
    ec32:	e9cc 0104 	strd	r0, r1, [ip, #16]
    ec36:	4443      	add	r3, r8
		rx->seg_n = seg_n;
    ec38:	f00b 001f 	and.w	r0, fp, #31
    ec3c:	f040 0040 	orr.w	r0, r0, #64	; 0x40
		rx->ctl = net_rx->ctl;
    ec40:	f3ce 0ec0 	ubfx	lr, lr, #3, #1
		rx->seg_n = seg_n;
    ec44:	ea40 1e4e 	orr.w	lr, r0, lr, lsl #5
    ec48:	79d8      	ldrb	r0, [r3, #7]
			k_mem_slab_alloc(&segs, &rx->seg[j], K_NO_WAIT);
    ec4a:	f8df b238 	ldr.w	fp, [pc, #568]	; ee84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x424>
		rx->seg_n = seg_n;
    ec4e:	f020 007f 	bic.w	r0, r0, #127	; 0x7f
    ec52:	ea4e 0e00 	orr.w	lr, lr, r0
    ec56:	f883 e007 	strb.w	lr, [r3, #7]
		rx->hdr = *hdr;
    ec5a:	9b06      	ldr	r3, [sp, #24]
    ec5c:	781b      	ldrb	r3, [r3, #0]
    ec5e:	f88c 301e 	strb.w	r3, [ip, #30]
		rx->ttl = net_rx->ctx.send_ttl;
    ec62:	7be3      	ldrb	r3, [r4, #15]
    ec64:	f88c 3020 	strb.w	r3, [ip, #32]
		rx->src = net_rx->ctx.addr;
    ec68:	2014      	movs	r0, #20
    ec6a:	8923      	ldrh	r3, [r4, #8]
    ec6c:	f8ac 3018 	strh.w	r3, [ip, #24]
		rx->dst = net_rx->ctx.recv_dst;
    ec70:	4342      	muls	r2, r0
    ec72:	8963      	ldrh	r3, [r4, #10]
    ec74:	f8ac 301a 	strh.w	r3, [ip, #26]
		rx->block = 0U;
    ec78:	3201      	adds	r2, #1
    ec7a:	2300      	movs	r3, #0
    ec7c:	eb08 0182 	add.w	r1, r8, r2, lsl #2
    ec80:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
		for (j = 0; j <= seg_n; j++) {
    ec84:	4698      	mov	r8, r3
			k_mem_slab_alloc(&segs, &rx->seg[j], K_NO_WAIT);
    ec86:	2200      	movs	r2, #0
    ec88:	4658      	mov	r0, fp
    ec8a:	9108      	str	r1, [sp, #32]
		for (j = 0; j <= seg_n; j++) {
    ec8c:	f108 0801 	add.w	r8, r8, #1
			k_mem_slab_alloc(&segs, &rx->seg[j], K_NO_WAIT);
    ec90:	f011 fd76 	bl	20780 <k_mem_slab_alloc>
		for (j = 0; j <= seg_n; j++) {
    ec94:	9908      	ldr	r1, [sp, #32]
    ec96:	45b8      	cmp	r8, r7
    ec98:	f101 0104 	add.w	r1, r1, #4
    ec9c:	ddf3      	ble.n	ec86 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x226>
	rx->obo = net_rx->friend_match;
    ec9e:	7d23      	ldrb	r3, [r4, #20]
    eca0:	7fea      	ldrb	r2, [r5, #31]
    eca2:	09db      	lsrs	r3, r3, #7
    eca4:	f363 12c7 	bfi	r2, r3, #7, #1
    eca8:	77ea      	strb	r2, [r5, #31]
	if (BIT(seg_o) & rx->block) {
    ecaa:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    ecac:	fa23 f80a 	lsr.w	r8, r3, sl
    ecb0:	f018 0801 	ands.w	r8, r8, #1
    ecb4:	d027      	beq.n	ed06 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2a6>
    ecb6:	4b75      	ldr	r3, [pc, #468]	; (ee8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x42c>)
    ecb8:	4975      	ldr	r1, [pc, #468]	; (ee90 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x430>)
		BT_WARN("Received already received fragment");
    ecba:	4876      	ldr	r0, [pc, #472]	; (ee94 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x434>)
    ecbc:	1ac9      	subs	r1, r1, r3
    ecbe:	08c9      	lsrs	r1, r1, #3
    ecc0:	0189      	lsls	r1, r1, #6
    ecc2:	f041 0102 	orr.w	r1, r1, #2
    ecc6:	f015 f97d 	bl	23fc4 <log_0>
	enum bt_mesh_friend_pdu_type pdu_type = BT_MESH_FRIEND_PDU_SINGLE;
    ecca:	f04f 0800 	mov.w	r8, #0
    ecce:	e71e      	b.n	eb0e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xae>
    ecd0:	496f      	ldr	r1, [pc, #444]	; (ee90 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x430>)
    ecd2:	4b6e      	ldr	r3, [pc, #440]	; (ee8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x42c>)
		BT_WARN("Not enough segments for incoming message");
    ecd4:	4870      	ldr	r0, [pc, #448]	; (ee98 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x438>)
    ecd6:	1ac9      	subs	r1, r1, r3
    ecd8:	08c9      	lsrs	r1, r1, #3
    ecda:	0189      	lsls	r1, r1, #6
    ecdc:	f041 0102 	orr.w	r1, r1, #2
    ece0:	f015 f970 	bl	23fc4 <log_0>
    ece4:	4b69      	ldr	r3, [pc, #420]	; (ee8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x42c>)
    ece6:	496a      	ldr	r1, [pc, #424]	; (ee90 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x430>)
		BT_WARN("No free slots for new incoming segmented messages");
    ece8:	486c      	ldr	r0, [pc, #432]	; (ee9c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x43c>)
    ecea:	1ac9      	subs	r1, r1, r3
    ecec:	08c9      	lsrs	r1, r1, #3
    ecee:	0189      	lsls	r1, r1, #6
    ecf0:	f041 0102 	orr.w	r1, r1, #2
    ecf4:	f015 f966 	bl	23fc4 <log_0>
	enum bt_mesh_friend_pdu_type pdu_type = BT_MESH_FRIEND_PDU_SINGLE;
    ecf8:	f04f 0800 	mov.w	r8, #0
		return -ENOMEM;
    ecfc:	f06f 070b 	mvn.w	r7, #11
    ed00:	e740      	b.n	eb84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x124>
		struct seg_rx *rx = &seg_rx[i];
    ed02:	460d      	mov	r5, r1
    ed04:	e789      	b.n	ec1a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x1ba>
	if (seg_o == seg_n) {
    ed06:	7fea      	ldrb	r2, [r5, #31]
    ed08:	88b1      	ldrh	r1, [r6, #4]
    ed0a:	f3c2 1240 	ubfx	r2, r2, #5, #1
		return BT_MESH_APP_SEG_SDU_MAX;
    ed0e:	2a00      	cmp	r2, #0
    ed10:	bf14      	ite	ne
    ed12:	2308      	movne	r3, #8
    ed14:	230c      	moveq	r3, #12
	if (seg_o == seg_n) {
    ed16:	45ba      	cmp	sl, r7
    ed18:	d120      	bne.n	ed5c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2fc>
		rx->len = seg_n * seg_len(rx->ctl) + buf->len;
    ed1a:	fb03 130a 	mla	r3, r3, sl, r1
    ed1e:	b29b      	uxth	r3, r3
		if (rx->len > BT_MESH_RX_SDU_MAX) {
    ed20:	2b24      	cmp	r3, #36	; 0x24
		rx->len = seg_n * seg_len(rx->ctl) + buf->len;
    ed22:	83ab      	strh	r3, [r5, #28]
		if (rx->len > BT_MESH_RX_SDU_MAX) {
    ed24:	d925      	bls.n	ed72 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x312>
    ed26:	4b59      	ldr	r3, [pc, #356]	; (ee8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x42c>)
    ed28:	4959      	ldr	r1, [pc, #356]	; (ee90 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x430>)
			BT_ERR("Too large SDU len");
    ed2a:	485d      	ldr	r0, [pc, #372]	; (eea0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x440>)
    ed2c:	1ac9      	subs	r1, r1, r3
    ed2e:	08c9      	lsrs	r1, r1, #3
    ed30:	0189      	lsls	r1, r1, #6
    ed32:	f041 0101 	orr.w	r1, r1, #1
    ed36:	f015 f945 	bl	23fc4 <log_0>
				 seq_auth, 0, rx->obo);
    ed3a:	7feb      	ldrb	r3, [r5, #31]
			send_ack(net_rx->sub, net_rx->ctx.recv_dst,
    ed3c:	8961      	ldrh	r1, [r4, #10]
    ed3e:	8922      	ldrh	r2, [r4, #8]
    ed40:	6820      	ldr	r0, [r4, #0]
    ed42:	09db      	lsrs	r3, r3, #7
    ed44:	e9cd 8301 	strd	r8, r3, [sp, #4]
    ed48:	ab0c      	add	r3, sp, #48	; 0x30
    ed4a:	9300      	str	r3, [sp, #0]
    ed4c:	7be3      	ldrb	r3, [r4, #15]
    ed4e:	f018 fa82 	bl	27256 <send_ack>
			seg_rx_reset(rx, true);
    ed52:	2101      	movs	r1, #1
    ed54:	4628      	mov	r0, r5
    ed56:	f7fe ffb9 	bl	dccc <seg_rx_reset>
    ed5a:	e68a      	b.n	ea72 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x12>
		if (buf->len != seg_len(rx->ctl)) {
    ed5c:	428b      	cmp	r3, r1
    ed5e:	d008      	beq.n	ed72 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x312>
    ed60:	494b      	ldr	r1, [pc, #300]	; (ee90 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x430>)
    ed62:	4b4a      	ldr	r3, [pc, #296]	; (ee8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x42c>)
			BT_ERR("Incorrect segment size for message type");
    ed64:	484f      	ldr	r0, [pc, #316]	; (eea4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x444>)
    ed66:	1ac9      	subs	r1, r1, r3
    ed68:	08c9      	lsrs	r1, r1, #3
    ed6a:	0189      	lsls	r1, r1, #6
    ed6c:	f041 0101 	orr.w	r1, r1, #1
    ed70:	e6d8      	b.n	eb24 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xc4>
    ed72:	f01a fb4e 	bl	29412 <z_impl_k_uptime_ticks>
    ed76:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
    ed7a:	460b      	mov	r3, r1
    ed7c:	fba0 0108 	umull	r0, r1, r0, r8
    ed80:	fb08 1103 	mla	r1, r8, r3, r1
    ed84:	0bc3      	lsrs	r3, r0, #15
    ed86:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
	return (u32_t)k_uptime_get();
    ed8a:	62ab      	str	r3, [r5, #40]	; 0x28
	return k_ticks_to_ms_floor32(z_timeout_remaining(&work->timeout));
    ed8c:	f105 0038 	add.w	r0, r5, #56	; 0x38
    ed90:	f014 f912 	bl	22fb8 <z_timeout_remaining>
			return (u32_t)((t * to_hz + off) / from_hz);
    ed94:	fba0 0108 	umull	r0, r1, r0, r8
    ed98:	0bc3      	lsrs	r3, r0, #15
	if (!k_delayed_work_remaining_get(&rx->ack) &&
    ed9a:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
    ed9e:	f105 0b2c 	add.w	fp, r5, #44	; 0x2c
    eda2:	d107      	bne.n	edb4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x354>
		k_delayed_work_submit(&rx->ack, ack_timeout(rx));
    eda4:	4628      	mov	r0, r5
    eda6:	f018 f9c0 	bl	2712a <ack_timeout>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    edaa:	4659      	mov	r1, fp
    edac:	4602      	mov	r2, r0
    edae:	483e      	ldr	r0, [pc, #248]	; (eea8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x448>)
    edb0:	f013 fed6 	bl	22b60 <k_delayed_work_submit_to_queue>
	memcpy(rx->seg[seg_o], buf->data, buf->len);
    edb4:	eb05 038a 	add.w	r3, r5, sl, lsl #2
	rx->block |= BIT(seg_o);
    edb8:	f04f 0801 	mov.w	r8, #1
	memcpy(rx->seg[seg_o], buf->data, buf->len);
    edbc:	6858      	ldr	r0, [r3, #4]
    edbe:	88b2      	ldrh	r2, [r6, #4]
    edc0:	6831      	ldr	r1, [r6, #0]
    edc2:	f016 ff71 	bl	25ca8 <memcpy>
	if (rx->block != BLOCK_COMPLETE(seg_n)) {
    edc6:	4447      	add	r7, r8
	rx->block |= BIT(seg_o);
    edc8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    edca:	fa08 fa0a 	lsl.w	sl, r8, sl
	if (rx->block != BLOCK_COMPLETE(seg_n)) {
    edce:	fa08 f707 	lsl.w	r7, r8, r7
	rx->block |= BIT(seg_o);
    edd2:	ea4a 0303 	orr.w	r3, sl, r3
	if (rx->block != BLOCK_COMPLETE(seg_n)) {
    edd6:	3f01      	subs	r7, #1
    edd8:	42bb      	cmp	r3, r7
	rx->block |= BIT(seg_o);
    edda:	626b      	str	r3, [r5, #36]	; 0x24
	if (rx->block != BLOCK_COMPLETE(seg_n)) {
    eddc:	f040 8128 	bne.w	f030 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5d0>
	if (rpl) {
    ede0:	980b      	ldr	r0, [sp, #44]	; 0x2c
    ede2:	b148      	cbz	r0, edf8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x398>
	rpl->src = rx->ctx.addr;
    ede4:	8923      	ldrh	r3, [r4, #8]
    ede6:	8003      	strh	r3, [r0, #0]
	rpl->seq = rx->seq;
    ede8:	6923      	ldr	r3, [r4, #16]
    edea:	6043      	str	r3, [r0, #4]
	rpl->old_iv = rx->old_iv;
    edec:	7d23      	ldrb	r3, [r4, #20]
    edee:	f3c3 0300 	ubfx	r3, r3, #0, #1
    edf2:	7083      	strb	r3, [r0, #2]
		bt_mesh_store_rpl(rpl);
    edf4:	f018 fefd 	bl	27bf2 <bt_mesh_store_rpl>
	k_delayed_work_cancel(&rx->ack);
    edf8:	4658      	mov	r0, fp
    edfa:	f013 ff41 	bl	22c80 <k_delayed_work_cancel>
		 net_rx->ctx.send_ttl, seq_auth, rx->block, rx->obo);
    edfe:	7feb      	ldrb	r3, [r5, #31]
	send_ack(net_rx->sub, net_rx->ctx.recv_dst, net_rx->ctx.addr,
    ee00:	8922      	ldrh	r2, [r4, #8]
    ee02:	8961      	ldrh	r1, [r4, #10]
    ee04:	6820      	ldr	r0, [r4, #0]
    ee06:	09db      	lsrs	r3, r3, #7
    ee08:	9302      	str	r3, [sp, #8]
    ee0a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    ee0c:	9301      	str	r3, [sp, #4]
    ee0e:	af0c      	add	r7, sp, #48	; 0x30
    ee10:	7be3      	ldrb	r3, [r4, #15]
    ee12:	9700      	str	r7, [sp, #0]
    ee14:	f018 fa1f 	bl	27256 <send_ack>
	if (net_rx->ctl) {
    ee18:	7d23      	ldrb	r3, [r4, #20]
    ee1a:	f013 0808 	ands.w	r8, r3, #8
    ee1e:	aa15      	add	r2, sp, #84	; 0x54
    ee20:	d012      	beq.n	ee48 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x3e8>
		NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_RX_CTL_MAX);
    ee22:	f44f 13c0 	mov.w	r3, #1572864	; 0x180000
    ee26:	e9cd 3213 	strd	r3, r2, [sp, #76]	; 0x4c
    ee2a:	9212      	str	r2, [sp, #72]	; 0x48
		seg_rx_assemble(rx, &sdu, 0U);
    ee2c:	a912      	add	r1, sp, #72	; 0x48
    ee2e:	2200      	movs	r2, #0
    ee30:	4628      	mov	r0, r5
    ee32:	f018 f998 	bl	27166 <seg_rx_assemble>
		err = ctl_recv(net_rx, *hdr, &sdu, seq_auth);
    ee36:	9906      	ldr	r1, [sp, #24]
    ee38:	463b      	mov	r3, r7
    ee3a:	7809      	ldrb	r1, [r1, #0]
    ee3c:	aa12      	add	r2, sp, #72	; 0x48
    ee3e:	4620      	mov	r0, r4
    ee40:	f7ff fae8 	bl	e414 <ctl_recv>
		return 0;
    ee44:	4607      	mov	r7, r0
    ee46:	e08e      	b.n	ef66 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x506>
		err = sdu_recv_seg(rx, *hdr, ASZMIC(hdr), net_rx);
    ee48:	9906      	ldr	r1, [sp, #24]
    ee4a:	784f      	ldrb	r7, [r1, #1]
    ee4c:	f891 a000 	ldrb.w	sl, [r1]
	NET_BUF_SIMPLE_DEFINE(buf, BT_MESH_RX_SDU_MAX);
    ee50:	920f      	str	r2, [sp, #60]	; 0x3c
    ee52:	f44f 1110 	mov.w	r1, #2359296	; 0x240000
    ee56:	e9cd 1210 	strd	r1, r2, [sp, #64]	; 0x40
	if (seg->len < 1 + APP_MIC_LEN(aszmic)) {
    ee5a:	09ff      	lsrs	r7, r7, #7
    ee5c:	8ba9      	ldrh	r1, [r5, #28]
    ee5e:	bf14      	ite	ne
    ee60:	2209      	movne	r2, #9
    ee62:	2205      	moveq	r2, #5
    ee64:	4291      	cmp	r1, r2
    ee66:	da23      	bge.n	eeb0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x450>
    ee68:	4909      	ldr	r1, [pc, #36]	; (ee90 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x430>)
    ee6a:	4b08      	ldr	r3, [pc, #32]	; (ee8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x42c>)
		BT_ERR("Too short SDU + MIC");
    ee6c:	480f      	ldr	r0, [pc, #60]	; (eeac <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x44c>)
    ee6e:	1ac9      	subs	r1, r1, r3
    ee70:	08c9      	lsrs	r1, r1, #3
    ee72:	0189      	lsls	r1, r1, #6
    ee74:	f041 0101 	orr.w	r1, r1, #1
	BT_WARN("No matching AppKey");
    ee78:	f015 f8a4 	bl	23fc4 <log_0>
	return -EINVAL;
    ee7c:	f06f 0715 	mvn.w	r7, #21
    ee80:	e071      	b.n	ef66 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x506>
    ee82:	bf00      	nop
    ee84:	20007594 	.word	0x20007594
    ee88:	20000000 	.word	0x20000000
    ee8c:	00029830 	.word	0x00029830
    ee90:	00029988 	.word	0x00029988
    ee94:	0002d65a 	.word	0x0002d65a
    ee98:	0002d5ff 	.word	0x0002d5ff
    ee9c:	0002d628 	.word	0x0002d628
    eea0:	0002d67d 	.word	0x0002d67d
    eea4:	0002d68f 	.word	0x0002d68f
    eea8:	20001dc4 	.word	0x20001dc4
    eeac:	0002d6b7 	.word	0x0002d6b7
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && !rx->local_match) {
    eeb0:	f013 0040 	ands.w	r0, r3, #64	; 0x40
    eeb4:	d0c6      	beq.n	ee44 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x3e4>
	if (BT_MESH_ADDR_IS_VIRTUAL(rx->ctx.recv_dst)) {
    eeb6:	8960      	ldrh	r0, [r4, #10]
	u32_t seq = (seg->seq_auth & 0xffffff);
    eeb8:	f8d5 b010 	ldr.w	fp, [r5, #16]
	if (BT_MESH_ADDR_IS_VIRTUAL(rx->ctx.recv_dst)) {
    eebc:	f480 4300 	eor.w	r3, r0, #32768	; 0x8000
    eec0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    eec4:	d202      	bcs.n	eecc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x46c>
		ad = bt_mesh_label_uuid_get(rx->ctx.recv_dst);
    eec6:	f003 fc75 	bl	127b4 <bt_mesh_label_uuid_get>
    eeca:	4680      	mov	r8, r0
	u32_t seq = (seg->seq_auth & 0xffffff);
    eecc:	f02b 437f 	bic.w	r3, fp, #4278190080	; 0xff000000
	if (!AKF(&hdr)) {
    eed0:	f01a 0f40 	tst.w	sl, #64	; 0x40
	u32_t seq = (seg->seq_auth & 0xffffff);
    eed4:	9306      	str	r3, [sp, #24]
	if (!AKF(&hdr)) {
    eed6:	f3ca 1b80 	ubfx	fp, sl, #6, #1
    eeda:	d153      	bne.n	ef84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x524>
		seg_rx_assemble(seg, &buf, aszmic);
    eedc:	463a      	mov	r2, r7
    eede:	a90f      	add	r1, sp, #60	; 0x3c
    eee0:	4628      	mov	r0, r5
    eee2:	f018 f940 	bl	27166 <seg_rx_assemble>
					      seg->len - APP_MIC_LEN(aszmic));
    eee6:	2f00      	cmp	r7, #0
    eee8:	8baa      	ldrh	r2, [r5, #28]
		net_buf_simple_init_with_data(&sdu, buf.data,
    eeea:	990f      	ldr	r1, [sp, #60]	; 0x3c
					      seg->len - APP_MIC_LEN(aszmic));
    eeec:	bf14      	ite	ne
    eeee:	2308      	movne	r3, #8
    eef0:	2304      	moveq	r3, #4
		net_buf_simple_init_with_data(&sdu, buf.data,
    eef2:	f10d 0a48 	add.w	sl, sp, #72	; 0x48
    eef6:	1ad2      	subs	r2, r2, r3
    eef8:	4650      	mov	r0, sl
    eefa:	9308      	str	r3, [sp, #32]
    eefc:	f019 ff03 	bl	28d06 <net_buf_simple_init_with_data>
		seg_rx_assemble(seg, &buf, aszmic);
    ef00:	463a      	mov	r2, r7
    ef02:	a90f      	add	r1, sp, #60	; 0x3c
    ef04:	4628      	mov	r0, r5
		sdu.len = 0;
    ef06:	f8ad b04c 	strh.w	fp, [sp, #76]	; 0x4c
		seg_rx_assemble(seg, &buf, aszmic);
    ef0a:	f018 f92c 	bl	27166 <seg_rx_assemble>
		net_buf_simple_init_with_data(&sdu, buf.data,
    ef0e:	9b08      	ldr	r3, [sp, #32]
					      seg->len - APP_MIC_LEN(aszmic));
    ef10:	8baa      	ldrh	r2, [r5, #28]
		net_buf_simple_init_with_data(&sdu, buf.data,
    ef12:	990f      	ldr	r1, [sp, #60]	; 0x3c
    ef14:	1ad2      	subs	r2, r2, r3
    ef16:	4650      	mov	r0, sl
    ef18:	f019 fef5 	bl	28d06 <net_buf_simple_init_with_data>
					  BT_MESH_NET_IVI_RX(rx));
    ef1c:	7d23      	ldrb	r3, [r4, #20]
    ef1e:	48b3      	ldr	r0, [pc, #716]	; (f1ec <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x78c>)
		sdu.len = 0;
    ef20:	f8ad b04c 	strh.w	fp, [sp, #76]	; 0x4c
					  BT_MESH_NET_IVI_RX(rx));
    ef24:	f003 0201 	and.w	r2, r3, #1
		err = bt_mesh_app_decrypt(bt_mesh.dev_key, true, aszmic, &buf,
    ef28:	6803      	ldr	r3, [r0, #0]
    ef2a:	f8cd a000 	str.w	sl, [sp]
    ef2e:	1a9b      	subs	r3, r3, r2
    ef30:	9305      	str	r3, [sp, #20]
    ef32:	9b06      	ldr	r3, [sp, #24]
    ef34:	9304      	str	r3, [sp, #16]
    ef36:	8963      	ldrh	r3, [r4, #10]
    ef38:	9303      	str	r3, [sp, #12]
    ef3a:	8923      	ldrh	r3, [r4, #8]
    ef3c:	463a      	mov	r2, r7
    ef3e:	e9cd 8301 	strd	r8, r3, [sp, #4]
    ef42:	2101      	movs	r1, #1
    ef44:	ab0f      	add	r3, sp, #60	; 0x3c
    ef46:	f500 709e 	add.w	r0, r0, #316	; 0x13c
    ef4a:	f018 fb68 	bl	2761e <bt_mesh_app_decrypt>
		if (err) {
    ef4e:	4607      	mov	r7, r0
    ef50:	b180      	cbz	r0, ef74 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x514>
    ef52:	49a7      	ldr	r1, [pc, #668]	; (f1f0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x790>)
    ef54:	4ba7      	ldr	r3, [pc, #668]	; (f1f4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x794>)
			BT_ERR("Unable to decrypt with local DevKey");
    ef56:	48a8      	ldr	r0, [pc, #672]	; (f1f8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x798>)
    ef58:	1ac9      	subs	r1, r1, r3
    ef5a:	08c9      	lsrs	r1, r1, #3
    ef5c:	0189      	lsls	r1, r1, #6
    ef5e:	f041 0101 	orr.w	r1, r1, #1
    ef62:	f015 f82f 	bl	23fc4 <log_0>
	seg_rx_reset(rx, false);
    ef66:	2100      	movs	r1, #0
    ef68:	4628      	mov	r0, r5
    ef6a:	f7fe feaf 	bl	dccc <seg_rx_reset>
	*pdu_type = BT_MESH_FRIEND_PDU_COMPLETE;
    ef6e:	f04f 0802 	mov.w	r8, #2
	return err;
    ef72:	e607      	b.n	eb84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x124>
		rx->ctx.app_idx = BT_MESH_KEY_DEV_LOCAL;
    ef74:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    ef78:	80e3      	strh	r3, [r4, #6]
		bt_mesh_model_recv(rx, &sdu);
    ef7a:	4651      	mov	r1, sl
    ef7c:	4620      	mov	r0, r4
    ef7e:	f000 fdef 	bl	fb60 <bt_mesh_model_recv>
		return 0;
    ef82:	e7f0      	b.n	ef66 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x506>
    ef84:	2f00      	cmp	r7, #0
    ef86:	bf14      	ite	ne
    ef88:	2308      	movne	r3, #8
    ef8a:	2304      	moveq	r3, #4
		seg_rx_assemble(seg, &buf, aszmic);
    ef8c:	463a      	mov	r2, r7
    ef8e:	a90f      	add	r1, sp, #60	; 0x3c
    ef90:	4628      	mov	r0, r5
    ef92:	9308      	str	r3, [sp, #32]
    ef94:	f018 f8e7 	bl	27166 <seg_rx_assemble>
		net_buf_simple_init_with_data(&sdu, buf.data,
    ef98:	9b08      	ldr	r3, [sp, #32]
					      seg->len - APP_MIC_LEN(aszmic));
    ef9a:	8baa      	ldrh	r2, [r5, #28]
		net_buf_simple_init_with_data(&sdu, buf.data,
    ef9c:	990f      	ldr	r1, [sp, #60]	; 0x3c
    ef9e:	1ad2      	subs	r2, r2, r3
    efa0:	a812      	add	r0, sp, #72	; 0x48
    efa2:	f019 feb0 	bl	28d06 <net_buf_simple_init_with_data>
		err = app_key_decrypt(rx, &bt_mesh.app_keys[i], seq, ad, hdr,
    efa6:	ab12      	add	r3, sp, #72	; 0x48
    efa8:	9303      	str	r3, [sp, #12]
    efaa:	ab0f      	add	r3, sp, #60	; 0x3c
    efac:	e9cd 7301 	strd	r7, r3, [sp, #4]
		sdu.len = 0;
    efb0:	f04f 0b00 	mov.w	fp, #0
		err = app_key_decrypt(rx, &bt_mesh.app_keys[i], seq, ad, hdr,
    efb4:	9a06      	ldr	r2, [sp, #24]
    efb6:	4991      	ldr	r1, [pc, #580]	; (f1fc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x79c>)
    efb8:	f8cd a000 	str.w	sl, [sp]
    efbc:	4643      	mov	r3, r8
    efbe:	4620      	mov	r0, r4
		sdu.len = 0;
    efc0:	f8ad b04c 	strh.w	fp, [sp, #76]	; 0x4c
		err = app_key_decrypt(rx, &bt_mesh.app_keys[i], seq, ad, hdr,
    efc4:	f7fe fece 	bl	dd64 <app_key_decrypt.constprop.0>
		if (err) {
    efc8:	b328      	cbz	r0, f016 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5b6>
		seg_rx_assemble(seg, &buf, aszmic);
    efca:	463a      	mov	r2, r7
    efcc:	a90f      	add	r1, sp, #60	; 0x3c
    efce:	4628      	mov	r0, r5
    efd0:	f018 f8c9 	bl	27166 <seg_rx_assemble>
		net_buf_simple_init_with_data(&sdu, buf.data,
    efd4:	9b08      	ldr	r3, [sp, #32]
					      seg->len - APP_MIC_LEN(aszmic));
    efd6:	8baa      	ldrh	r2, [r5, #28]
		net_buf_simple_init_with_data(&sdu, buf.data,
    efd8:	990f      	ldr	r1, [sp, #60]	; 0x3c
    efda:	1ad2      	subs	r2, r2, r3
    efdc:	a812      	add	r0, sp, #72	; 0x48
    efde:	f019 fe92 	bl	28d06 <net_buf_simple_init_with_data>
		err = app_key_decrypt(rx, &bt_mesh.app_keys[i], seq, ad, hdr,
    efe2:	ab12      	add	r3, sp, #72	; 0x48
    efe4:	9303      	str	r3, [sp, #12]
    efe6:	ab0f      	add	r3, sp, #60	; 0x3c
    efe8:	e9cd 7301 	strd	r7, r3, [sp, #4]
    efec:	9a06      	ldr	r2, [sp, #24]
    efee:	4984      	ldr	r1, [pc, #528]	; (f200 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7a0>)
    eff0:	f8cd a000 	str.w	sl, [sp]
    eff4:	4643      	mov	r3, r8
    eff6:	4620      	mov	r0, r4
		sdu.len = 0;
    eff8:	f8ad b04c 	strh.w	fp, [sp, #76]	; 0x4c
		err = app_key_decrypt(rx, &bt_mesh.app_keys[i], seq, ad, hdr,
    effc:	f7fe feb2 	bl	dd64 <app_key_decrypt.constprop.0>
		if (err) {
    f000:	b140      	cbz	r0, f014 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5b4>
    f002:	497b      	ldr	r1, [pc, #492]	; (f1f0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x790>)
    f004:	4b7b      	ldr	r3, [pc, #492]	; (f1f4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x794>)
	BT_WARN("No matching AppKey");
    f006:	487f      	ldr	r0, [pc, #508]	; (f204 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7a4>)
    f008:	1ac9      	subs	r1, r1, r3
    f00a:	08c9      	lsrs	r1, r1, #3
    f00c:	0189      	lsls	r1, r1, #6
    f00e:	f041 0102 	orr.w	r1, r1, #2
    f012:	e731      	b.n	ee78 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x418>
		struct bt_mesh_app_key *key = &bt_mesh.app_keys[i];
    f014:	2001      	movs	r0, #1
		rx->ctx.app_idx = key->app_idx;
    f016:	4b75      	ldr	r3, [pc, #468]	; (f1ec <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x78c>)
    f018:	2228      	movs	r2, #40	; 0x28
    f01a:	fb02 3000 	mla	r0, r2, r0, r3
		bt_mesh_model_recv(rx, &sdu);
    f01e:	a912      	add	r1, sp, #72	; 0x48
		rx->ctx.app_idx = key->app_idx;
    f020:	f8b0 314e 	ldrh.w	r3, [r0, #334]	; 0x14e
    f024:	80e3      	strh	r3, [r4, #6]
		bt_mesh_model_recv(rx, &sdu);
    f026:	4620      	mov	r0, r4
    f028:	f000 fd9a 	bl	fb60 <bt_mesh_model_recv>
		return 0;
    f02c:	2700      	movs	r7, #0
    f02e:	e79a      	b.n	ef66 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x506>
		return 0;
    f030:	2700      	movs	r7, #0
    f032:	e5a7      	b.n	eb84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x124>
	if (buf->len < 1) {
    f034:	9b07      	ldr	r3, [sp, #28]
    f036:	b963      	cbnz	r3, f052 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5f2>
    f038:	496d      	ldr	r1, [pc, #436]	; (f1f0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x790>)
    f03a:	4b6e      	ldr	r3, [pc, #440]	; (f1f4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x794>)
		BT_ERR("Too small unsegmented PDU");
    f03c:	4872      	ldr	r0, [pc, #456]	; (f208 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7a8>)
    f03e:	1ac9      	subs	r1, r1, r3
    f040:	08c9      	lsrs	r1, r1, #3
    f042:	0189      	lsls	r1, r1, #6
    f044:	f041 0101 	orr.w	r1, r1, #1
    f048:	f014 ffbc 	bl	23fc4 <log_0>
		seg_count = 1;
    f04c:	f04f 0901 	mov.w	r9, #1
    f050:	e480      	b.n	e954 <bt_mesh_trans_recv+0x78>
	if (is_replay(rx, NULL)) {
    f052:	2100      	movs	r1, #0
    f054:	4620      	mov	r0, r4
    f056:	f7ff fb63 	bl	e720 <is_replay>
    f05a:	4680      	mov	r8, r0
    f05c:	2800      	cmp	r0, #0
    f05e:	d1f5      	bne.n	f04c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5ec>
	hdr = net_buf_simple_pull_u8(buf);
    f060:	4630      	mov	r0, r6
    f062:	f019 fe78 	bl	28d56 <net_buf_simple_pull_u8>
	if (rx->ctl) {
    f066:	7d22      	ldrb	r2, [r4, #20]
    f068:	f012 0308 	ands.w	r3, r2, #8
	hdr = net_buf_simple_pull_u8(buf);
    f06c:	4607      	mov	r7, r0
	if (rx->ctl) {
    f06e:	d009      	beq.n	f084 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x624>
		return ctl_recv(rx, hdr, buf, seq_auth);
    f070:	4601      	mov	r1, r0
    f072:	ab0c      	add	r3, sp, #48	; 0x30
    f074:	4632      	mov	r2, r6
    f076:	4620      	mov	r0, r4
    f078:	f7ff f9cc 	bl	e414 <ctl_recv>
    f07c:	4607      	mov	r7, r0
		seg_count = 1;
    f07e:	f04f 0901 	mov.w	r9, #1
		return sdu_recv_unseg(rx, hdr, buf);
    f082:	e57f      	b.n	eb84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x124>
		if (!rx->local_match && !rx->friend_match) {
    f084:	f012 08c0 	ands.w	r8, r2, #192	; 0xc0
    f088:	f000 8096 	beq.w	f1b8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x758>
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_SDU_UNSEG_MAX);
    f08c:	a912      	add	r1, sp, #72	; 0x48
    f08e:	f44f 2030 	mov.w	r0, #720896	; 0xb0000
    f092:	e9cd 0116 	strd	r0, r1, [sp, #88]	; 0x58
    f096:	9115      	str	r1, [sp, #84]	; 0x54
	if (buf->len < 1 + APP_MIC_LEN(0)) {
    f098:	88b1      	ldrh	r1, [r6, #4]
    f09a:	2904      	cmp	r1, #4
    f09c:	d80c      	bhi.n	f0b8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x658>
    f09e:	4954      	ldr	r1, [pc, #336]	; (f1f0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x790>)
    f0a0:	4b54      	ldr	r3, [pc, #336]	; (f1f4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x794>)
		BT_ERR("Too short SDU + MIC");
    f0a2:	485a      	ldr	r0, [pc, #360]	; (f20c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7ac>)
    f0a4:	1ac9      	subs	r1, r1, r3
    f0a6:	08c9      	lsrs	r1, r1, #3
    f0a8:	0189      	lsls	r1, r1, #6
    f0aa:	f041 0101 	orr.w	r1, r1, #1
	BT_WARN("No matching AppKey");
    f0ae:	f014 ff89 	bl	23fc4 <log_0>
	return -EINVAL;
    f0b2:	f06f 0715 	mvn.w	r7, #21
    f0b6:	e03a      	b.n	f12e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6ce>
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && !rx->local_match) {
    f0b8:	f012 0040 	ands.w	r0, r2, #64	; 0x40
    f0bc:	d07a      	beq.n	f1b4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x754>
	if (BT_MESH_ADDR_IS_VIRTUAL(rx->ctx.recv_dst)) {
    f0be:	8960      	ldrh	r0, [r4, #10]
    f0c0:	f480 4200 	eor.w	r2, r0, #32768	; 0x8000
    f0c4:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
    f0c8:	d234      	bcs.n	f134 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6d4>
		ad = bt_mesh_label_uuid_get(rx->ctx.recv_dst);
    f0ca:	f003 fb73 	bl	127b4 <bt_mesh_label_uuid_get>
    f0ce:	4680      	mov	r8, r0
	buf->len -= APP_MIC_LEN(0);
    f0d0:	88b3      	ldrh	r3, [r6, #4]
	if (!AKF(&hdr)) {
    f0d2:	f017 0f40 	tst.w	r7, #64	; 0x40
	buf->len -= APP_MIC_LEN(0);
    f0d6:	f1a3 0304 	sub.w	r3, r3, #4
    f0da:	80b3      	strh	r3, [r6, #4]
	if (!AKF(&hdr)) {
    f0dc:	f3c7 1280 	ubfx	r2, r7, #6, #1
    f0e0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    f0e2:	ad15      	add	r5, sp, #84	; 0x54
    f0e4:	d130      	bne.n	f148 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6e8>
					  rx->seq, BT_MESH_NET_IVI_RX(rx));
    f0e6:	4841      	ldr	r0, [pc, #260]	; (f1ec <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x78c>)
	buf->data = buf->__buf;
    f0e8:	9315      	str	r3, [sp, #84]	; 0x54
    f0ea:	7d23      	ldrb	r3, [r4, #20]
    f0ec:	6921      	ldr	r1, [r4, #16]
	buf->len  = 0U;
    f0ee:	f8ad 2058 	strh.w	r2, [sp, #88]	; 0x58
    f0f2:	f003 0701 	and.w	r7, r3, #1
		err = bt_mesh_app_decrypt(bt_mesh.dev_key, true, 0, buf, &sdu,
    f0f6:	6803      	ldr	r3, [r0, #0]
    f0f8:	9500      	str	r5, [sp, #0]
    f0fa:	1bdb      	subs	r3, r3, r7
    f0fc:	e9cd 1304 	strd	r1, r3, [sp, #16]
    f100:	8963      	ldrh	r3, [r4, #10]
    f102:	9303      	str	r3, [sp, #12]
    f104:	8923      	ldrh	r3, [r4, #8]
    f106:	2101      	movs	r1, #1
    f108:	e9cd 8301 	strd	r8, r3, [sp, #4]
    f10c:	f500 709e 	add.w	r0, r0, #316	; 0x13c
    f110:	4633      	mov	r3, r6
    f112:	f018 fa84 	bl	2761e <bt_mesh_app_decrypt>
		if (err) {
    f116:	4607      	mov	r7, r0
    f118:	b170      	cbz	r0, f138 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6d8>
    f11a:	4935      	ldr	r1, [pc, #212]	; (f1f0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x790>)
    f11c:	4b35      	ldr	r3, [pc, #212]	; (f1f4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x794>)
			BT_ERR("Unable to decrypt with local DevKey");
    f11e:	4836      	ldr	r0, [pc, #216]	; (f1f8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x798>)
    f120:	1ac9      	subs	r1, r1, r3
    f122:	08c9      	lsrs	r1, r1, #3
    f124:	0189      	lsls	r1, r1, #6
    f126:	f041 0101 	orr.w	r1, r1, #1
    f12a:	f014 ff4b 	bl	23fc4 <log_0>
	enum bt_mesh_friend_pdu_type pdu_type = BT_MESH_FRIEND_PDU_SINGLE;
    f12e:	f04f 0800 	mov.w	r8, #0
    f132:	e7a4      	b.n	f07e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x61e>
		ad = NULL;
    f134:	4698      	mov	r8, r3
    f136:	e7cb      	b.n	f0d0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x670>
		rx->ctx.app_idx = BT_MESH_KEY_DEV_LOCAL;
    f138:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    f13c:	80e3      	strh	r3, [r4, #6]
		bt_mesh_model_recv(rx, &sdu);
    f13e:	4629      	mov	r1, r5
    f140:	4620      	mov	r0, r4
    f142:	f000 fd0d 	bl	fb60 <bt_mesh_model_recv>
		return 0;
    f146:	e7f2      	b.n	f12e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6ce>
    f148:	f04f 0900 	mov.w	r9, #0
	buf->data = buf->__buf;
    f14c:	9315      	str	r3, [sp, #84]	; 0x54
		err = app_key_decrypt(rx, &bt_mesh.app_keys[i], rx->seq, ad,
    f14e:	e9cd 6502 	strd	r6, r5, [sp, #8]
    f152:	e9cd 7900 	strd	r7, r9, [sp]
    f156:	6922      	ldr	r2, [r4, #16]
    f158:	4928      	ldr	r1, [pc, #160]	; (f1fc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x79c>)
	buf->len  = 0U;
    f15a:	f8ad 9058 	strh.w	r9, [sp, #88]	; 0x58
    f15e:	4643      	mov	r3, r8
    f160:	4620      	mov	r0, r4
    f162:	f7fe fdff 	bl	dd64 <app_key_decrypt.constprop.0>
		if (err) {
    f166:	b1c0      	cbz	r0, f19a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x73a>
	buf->data = buf->__buf;
    f168:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    f16a:	9315      	str	r3, [sp, #84]	; 0x54
		err = app_key_decrypt(rx, &bt_mesh.app_keys[i], rx->seq, ad,
    f16c:	e9cd 6502 	strd	r6, r5, [sp, #8]
    f170:	e9cd 7900 	strd	r7, r9, [sp]
    f174:	6922      	ldr	r2, [r4, #16]
    f176:	4922      	ldr	r1, [pc, #136]	; (f200 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7a0>)
	buf->len  = 0U;
    f178:	f8ad 9058 	strh.w	r9, [sp, #88]	; 0x58
    f17c:	4643      	mov	r3, r8
    f17e:	4620      	mov	r0, r4
    f180:	f7fe fdf0 	bl	dd64 <app_key_decrypt.constprop.0>
		if (err) {
    f184:	b140      	cbz	r0, f198 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x738>
    f186:	491a      	ldr	r1, [pc, #104]	; (f1f0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x790>)
    f188:	4b1a      	ldr	r3, [pc, #104]	; (f1f4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x794>)
	BT_WARN("No matching AppKey");
    f18a:	481e      	ldr	r0, [pc, #120]	; (f204 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7a4>)
    f18c:	1ac9      	subs	r1, r1, r3
    f18e:	08c9      	lsrs	r1, r1, #3
    f190:	0189      	lsls	r1, r1, #6
    f192:	f041 0102 	orr.w	r1, r1, #2
    f196:	e78a      	b.n	f0ae <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x64e>
		struct bt_mesh_app_key *key = &bt_mesh.app_keys[i];
    f198:	2001      	movs	r0, #1
		rx->ctx.app_idx = key->app_idx;
    f19a:	4b14      	ldr	r3, [pc, #80]	; (f1ec <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x78c>)
    f19c:	2228      	movs	r2, #40	; 0x28
    f19e:	fb02 3000 	mla	r0, r2, r0, r3
		bt_mesh_model_recv(rx, &sdu);
    f1a2:	4629      	mov	r1, r5
		rx->ctx.app_idx = key->app_idx;
    f1a4:	f8b0 314e 	ldrh.w	r3, [r0, #334]	; 0x14e
    f1a8:	80e3      	strh	r3, [r4, #6]
		bt_mesh_model_recv(rx, &sdu);
    f1aa:	4620      	mov	r0, r4
    f1ac:	f000 fcd8 	bl	fb60 <bt_mesh_model_recv>
		return 0;
    f1b0:	2700      	movs	r7, #0
    f1b2:	e7bc      	b.n	f12e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6ce>
		return 0;
    f1b4:	4607      	mov	r7, r0
    f1b6:	e7ba      	b.n	f12e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6ce>
		seg_count = 1;
    f1b8:	f04f 0901 	mov.w	r9, #1
			return 0;
    f1bc:	4647      	mov	r7, r8
    f1be:	e4e1      	b.n	eb84 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x124>
			return 0;
    f1c0:	4607      	mov	r7, r0
    f1c2:	e4fa      	b.n	ebba <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x15a>
		struct seg_rx *rx = &seg_rx[i];
    f1c4:	3550      	adds	r5, #80	; 0x50
	for (i = 0; i < ARRAY_SIZE(seg_rx); i++) {
    f1c6:	f04f 0801 	mov.w	r8, #1
		if (rx->seq_auth > *seq_auth) {
    f1ca:	4299      	cmp	r1, r3
    f1cc:	bf08      	it	eq
    f1ce:	4290      	cmpeq	r0, r2
    f1d0:	f4bf ac52 	bcs.w	ea78 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x18>
    f1d4:	4906      	ldr	r1, [pc, #24]	; (f1f0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x790>)
    f1d6:	4b07      	ldr	r3, [pc, #28]	; (f1f4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x794>)
			BT_WARN("Ignoring old SeqAuth");
    f1d8:	480d      	ldr	r0, [pc, #52]	; (f210 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7b0>)
    f1da:	1ac9      	subs	r1, r1, r3
    f1dc:	08c9      	lsrs	r1, r1, #3
    f1de:	0189      	lsls	r1, r1, #6
    f1e0:	f041 0102 	orr.w	r1, r1, #2
		BT_ERR("Inconsistent CTL in segment");
    f1e4:	f014 feee 	bl	23fc4 <log_0>
		return false;
    f1e8:	f7ff bbb4 	b.w	e954 <bt_mesh_trans_recv+0x78>
    f1ec:	20006b48 	.word	0x20006b48
    f1f0:	00029988 	.word	0x00029988
    f1f4:	00029830 	.word	0x00029830
    f1f8:	0002d6cb 	.word	0x0002d6cb
    f1fc:	20006c94 	.word	0x20006c94
    f200:	20006cbc 	.word	0x20006cbc
    f204:	0002d6ef 	.word	0x0002d6ef
    f208:	0002d702 	.word	0x0002d702
    f20c:	0002d6b7 	.word	0x0002d6b7
    f210:	0002d548 	.word	0x0002d548

0000f214 <bt_mesh_rx_reset>:

void bt_mesh_rx_reset(void)
{
    f214:	b510      	push	{r4, lr}
	int i;

	BT_DBG("");

	for (i = 0; i < ARRAY_SIZE(seg_rx); i++) {
		seg_rx_reset(&seg_rx[i], true);
    f216:	4c07      	ldr	r4, [pc, #28]	; (f234 <bt_mesh_rx_reset+0x20>)
    f218:	2101      	movs	r1, #1
    f21a:	4620      	mov	r0, r4
    f21c:	f7fe fd56 	bl	dccc <seg_rx_reset>
    f220:	f104 0050 	add.w	r0, r4, #80	; 0x50
    f224:	2101      	movs	r1, #1
    f226:	f7fe fd51 	bl	dccc <seg_rx_reset>
	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		bt_mesh_clear_rpl();
	} else {
		(void)memset(bt_mesh.rpl, 0, sizeof(bt_mesh.rpl));
	}
}
    f22a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_mesh_clear_rpl();
    f22e:	f018 bd7d 	b.w	27d2c <bt_mesh_clear_rpl>
    f232:	bf00      	nop
    f234:	20000000 	.word	0x20000000

0000f238 <bt_mesh_tx_reset>:

void bt_mesh_tx_reset(void)
{
    f238:	b510      	push	{r4, lr}
	int i;

	BT_DBG("");

	for (i = 0; i < ARRAY_SIZE(seg_tx); i++) {
		seg_tx_reset(&seg_tx[i]);
    f23a:	4c05      	ldr	r4, [pc, #20]	; (f250 <bt_mesh_tx_reset+0x18>)
    f23c:	4620      	mov	r0, r4
    f23e:	f7fe fdd9 	bl	ddf4 <seg_tx_reset>
    f242:	f104 0050 	add.w	r0, r4, #80	; 0x50
	}
}
    f246:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		seg_tx_reset(&seg_tx[i]);
    f24a:	f7fe bdd3 	b.w	ddf4 <seg_tx_reset>
    f24e:	bf00      	nop
    f250:	200000a0 	.word	0x200000a0

0000f254 <bt_mesh_trans_init>:

void bt_mesh_trans_init(void)
{
    f254:	b538      	push	{r3, r4, r5, lr}
	int i;

	for (i = 0; i < ARRAY_SIZE(seg_tx); i++) {
		k_delayed_work_init(&seg_tx[i].retransmit, seg_retransmit);
    f256:	4d0d      	ldr	r5, [pc, #52]	; (f28c <bt_mesh_trans_init+0x38>)
    f258:	4c0d      	ldr	r4, [pc, #52]	; (f290 <bt_mesh_trans_init+0x3c>)
    f25a:	4629      	mov	r1, r5
    f25c:	f104 0030 	add.w	r0, r4, #48	; 0x30
    f260:	f01a f8cb 	bl	293fa <k_delayed_work_init>
    f264:	4629      	mov	r1, r5
    f266:	f104 0080 	add.w	r0, r4, #128	; 0x80
	}

	for (i = 0; i < ARRAY_SIZE(seg_rx); i++) {
		k_delayed_work_init(&seg_rx[i].ack, seg_ack);
    f26a:	4d0a      	ldr	r5, [pc, #40]	; (f294 <bt_mesh_trans_init+0x40>)
    f26c:	4c0a      	ldr	r4, [pc, #40]	; (f298 <bt_mesh_trans_init+0x44>)
		k_delayed_work_init(&seg_tx[i].retransmit, seg_retransmit);
    f26e:	f01a f8c4 	bl	293fa <k_delayed_work_init>
		k_delayed_work_init(&seg_rx[i].ack, seg_ack);
    f272:	4629      	mov	r1, r5
    f274:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    f278:	f01a f8bf 	bl	293fa <k_delayed_work_init>
    f27c:	4629      	mov	r1, r5
    f27e:	f104 007c 	add.w	r0, r4, #124	; 0x7c
	}
}
    f282:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		k_delayed_work_init(&seg_rx[i].ack, seg_ack);
    f286:	f01a b8b8 	b.w	293fa <k_delayed_work_init>
    f28a:	bf00      	nop
    f28c:	000271c5 	.word	0x000271c5
    f290:	200000a0 	.word	0x200000a0
    f294:	0000e83d 	.word	0x0000e83d
    f298:	20000000 	.word	0x20000000

0000f29c <bt_mesh_app_key_get>:
			 NULL, NULL);
}

int bt_mesh_app_key_get(const struct bt_mesh_subnet *subnet, u16_t app_idx,
			u16_t addr, const u8_t **key, u8_t *aid)
{
    f29c:	b570      	push	{r4, r5, r6, lr}
    f29e:	461c      	mov	r4, r3
	struct bt_mesh_app_key *app_key;

	if (app_idx == BT_MESH_KEY_DEV_LOCAL ||
    f2a0:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    f2a4:	4299      	cmp	r1, r3
{
    f2a6:	4605      	mov	r5, r0
    f2a8:	9e04      	ldr	r6, [sp, #16]
    f2aa:	4610      	mov	r0, r2
	if (app_idx == BT_MESH_KEY_DEV_LOCAL ||
    f2ac:	d104      	bne.n	f2b8 <bt_mesh_app_key_get+0x1c>
	    (app_idx == BT_MESH_KEY_DEV_REMOTE &&
	     bt_mesh_elem_find(addr) != NULL)) {
		*aid = 0;
		*key = bt_mesh.dev_key;
    f2ae:	4b15      	ldr	r3, [pc, #84]	; (f304 <bt_mesh_app_key_get+0x68>)
		*aid = 0;
    f2b0:	2000      	movs	r0, #0
    f2b2:	7030      	strb	r0, [r6, #0]
		*key = bt_mesh.dev_key;
    f2b4:	6023      	str	r3, [r4, #0]
		*key = app_key->keys[0].val;
		*aid = app_key->keys[0].id;
	}

	return 0;
}
    f2b6:	bd70      	pop	{r4, r5, r6, pc}
	if (app_idx == BT_MESH_KEY_DEV_LOCAL ||
    f2b8:	f64f 73fd 	movw	r3, #65533	; 0xfffd
    f2bc:	4299      	cmp	r1, r3
    f2be:	d10d      	bne.n	f2dc <bt_mesh_app_key_get+0x40>
	     bt_mesh_elem_find(addr) != NULL)) {
    f2c0:	f000 fbfa 	bl	fab8 <bt_mesh_elem_find>
	    (app_idx == BT_MESH_KEY_DEV_REMOTE &&
    f2c4:	2800      	cmp	r0, #0
    f2c6:	d1f2      	bne.n	f2ae <bt_mesh_app_key_get+0x12>
			return -EINVAL;
    f2c8:	f06f 0015 	mvn.w	r0, #21
    f2cc:	e7f3      	b.n	f2b6 <bt_mesh_app_key_get+0x1a>
		*key = app_key->keys[0].val;
    f2ce:	1d83      	adds	r3, r0, #6
    f2d0:	6023      	str	r3, [r4, #0]
		*aid = app_key->keys[0].id;
    f2d2:	7943      	ldrb	r3, [r0, #5]
    f2d4:	e013      	b.n	f2fe <bt_mesh_app_key_get+0x62>
		return -ENOENT;
    f2d6:	f06f 0001 	mvn.w	r0, #1
    f2da:	e7ec      	b.n	f2b6 <bt_mesh_app_key_get+0x1a>
	if (!subnet) {
    f2dc:	2d00      	cmp	r5, #0
    f2de:	d0f3      	beq.n	f2c8 <bt_mesh_app_key_get+0x2c>
	app_key = bt_mesh_app_key_find(app_idx);
    f2e0:	4608      	mov	r0, r1
    f2e2:	f7ff fa87 	bl	e7f4 <bt_mesh_app_key_find>
	if (!app_key) {
    f2e6:	2800      	cmp	r0, #0
    f2e8:	d0f5      	beq.n	f2d6 <bt_mesh_app_key_get+0x3a>
	if (subnet->kr_phase == BT_MESH_KR_PHASE_2 && app_key->updated) {
    f2ea:	7feb      	ldrb	r3, [r5, #31]
    f2ec:	2b02      	cmp	r3, #2
    f2ee:	d1ee      	bne.n	f2ce <bt_mesh_app_key_get+0x32>
    f2f0:	7903      	ldrb	r3, [r0, #4]
    f2f2:	2b00      	cmp	r3, #0
    f2f4:	d0eb      	beq.n	f2ce <bt_mesh_app_key_get+0x32>
		*key = app_key->keys[1].val;
    f2f6:	f100 0317 	add.w	r3, r0, #23
    f2fa:	6023      	str	r3, [r4, #0]
		*aid = app_key->keys[1].id;
    f2fc:	7d83      	ldrb	r3, [r0, #22]
		*aid = app_key->keys[0].id;
    f2fe:	7033      	strb	r3, [r6, #0]
	return 0;
    f300:	2000      	movs	r0, #0
    f302:	e7d8      	b.n	f2b6 <bt_mesh_app_key_get+0x1a>
    f304:	20006c84 	.word	0x20006c84

0000f308 <bt_mesh_trans_send>:
{
    f308:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f30c:	460d      	mov	r5, r1
	if (msg->len < 1) {
    f30e:	8889      	ldrh	r1, [r1, #4]
{
    f310:	b088      	sub	sp, #32
    f312:	4604      	mov	r4, r0
    f314:	4616      	mov	r6, r2
    f316:	461f      	mov	r7, r3
	if (msg->len < 1) {
    f318:	b961      	cbnz	r1, f334 <bt_mesh_trans_send+0x2c>
    f31a:	494c      	ldr	r1, [pc, #304]	; (f44c <bt_mesh_trans_send+0x144>)
    f31c:	4b4c      	ldr	r3, [pc, #304]	; (f450 <bt_mesh_trans_send+0x148>)
		BT_ERR("Zero-length SDU not allowed");
    f31e:	484d      	ldr	r0, [pc, #308]	; (f454 <bt_mesh_trans_send+0x14c>)
    f320:	1ac9      	subs	r1, r1, r3
    f322:	08c9      	lsrs	r1, r1, #3
    f324:	0189      	lsls	r1, r1, #6
    f326:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Insufficient tailroom for Transport MIC");
    f32a:	f014 fe4b 	bl	23fc4 <log_0>
		return -EINVAL;
    f32e:	f06f 0015 	mvn.w	r0, #21
    f332:	e00d      	b.n	f350 <bt_mesh_trans_send+0x48>
	if (msg->len > BT_MESH_TX_SDU_MAX) {
    f334:	2924      	cmp	r1, #36	; 0x24
    f336:	d90e      	bls.n	f356 <bt_mesh_trans_send+0x4e>
    f338:	4b45      	ldr	r3, [pc, #276]	; (f450 <bt_mesh_trans_send+0x148>)
    f33a:	4a44      	ldr	r2, [pc, #272]	; (f44c <bt_mesh_trans_send+0x144>)
		BT_ERR("Not enough segment buffers for length %u", msg->len);
    f33c:	4846      	ldr	r0, [pc, #280]	; (f458 <bt_mesh_trans_send+0x150>)
    f33e:	1ad2      	subs	r2, r2, r3
    f340:	08d2      	lsrs	r2, r2, #3
    f342:	0192      	lsls	r2, r2, #6
    f344:	f042 0201 	orr.w	r2, r2, #1
    f348:	f014 fe49 	bl	23fde <log_1>
		return -EMSGSIZE;
    f34c:	f06f 0023 	mvn.w	r0, #35	; 0x23
}
    f350:	b008      	add	sp, #32
    f352:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (net_buf_simple_tailroom(msg) < 4) {
    f356:	4628      	mov	r0, r5
    f358:	f019 fd25 	bl	28da6 <net_buf_simple_tailroom>
    f35c:	2803      	cmp	r0, #3
    f35e:	d808      	bhi.n	f372 <bt_mesh_trans_send+0x6a>
    f360:	493a      	ldr	r1, [pc, #232]	; (f44c <bt_mesh_trans_send+0x144>)
    f362:	4b3b      	ldr	r3, [pc, #236]	; (f450 <bt_mesh_trans_send+0x148>)
		BT_ERR("Insufficient tailroom for Transport MIC");
    f364:	483d      	ldr	r0, [pc, #244]	; (f45c <bt_mesh_trans_send+0x154>)
    f366:	1ac9      	subs	r1, r1, r3
    f368:	08c9      	lsrs	r1, r1, #3
    f36a:	0189      	lsls	r1, r1, #6
    f36c:	f041 0101 	orr.w	r1, r1, #1
    f370:	e7db      	b.n	f32a <bt_mesh_trans_send+0x22>
	if (msg->len > BT_MESH_SDU_UNSEG_MAX) {
    f372:	88aa      	ldrh	r2, [r5, #4]
    f374:	6863      	ldr	r3, [r4, #4]
	err = bt_mesh_app_key_get(tx->sub, tx->ctx->app_idx,
    f376:	6820      	ldr	r0, [r4, #0]
    f378:	8859      	ldrh	r1, [r3, #2]
	if (msg->len > BT_MESH_SDU_UNSEG_MAX) {
    f37a:	2a0b      	cmp	r2, #11
		tx->ctx->send_rel = true;
    f37c:	bf84      	itt	hi
    f37e:	2201      	movhi	r2, #1
    f380:	729a      	strbhi	r2, [r3, #10]
	err = bt_mesh_app_key_get(tx->sub, tx->ctx->app_idx,
    f382:	889a      	ldrh	r2, [r3, #4]
    f384:	f10d 031b 	add.w	r3, sp, #27
    f388:	9300      	str	r3, [sp, #0]
    f38a:	ab07      	add	r3, sp, #28
    f38c:	f7ff ff86 	bl	f29c <bt_mesh_app_key_get>
	if (err) {
    f390:	2800      	cmp	r0, #0
    f392:	d1dd      	bne.n	f350 <bt_mesh_trans_send+0x48>
	tx->aid = aid;
    f394:	7ae3      	ldrb	r3, [r4, #11]
    f396:	f89d 201b 	ldrb.w	r2, [sp, #27]
    f39a:	f362 0387 	bfi	r3, r2, #2, #6
    f39e:	72e3      	strb	r3, [r4, #11]
	if (!tx->ctx->send_rel || net_buf_simple_tailroom(msg) < 8) {
    f3a0:	6863      	ldr	r3, [r4, #4]
    f3a2:	7a98      	ldrb	r0, [r3, #10]
    f3a4:	b130      	cbz	r0, f3b4 <bt_mesh_trans_send+0xac>
    f3a6:	4628      	mov	r0, r5
    f3a8:	f019 fcfd 	bl	28da6 <net_buf_simple_tailroom>
    f3ac:	2807      	cmp	r0, #7
    f3ae:	bf94      	ite	ls
    f3b0:	2000      	movls	r0, #0
    f3b2:	2001      	movhi	r0, #1
    f3b4:	7ae3      	ldrb	r3, [r4, #11]
    f3b6:	f360 0341 	bfi	r3, r0, #1, #1
    f3ba:	72e3      	strb	r3, [r4, #11]
	if (BT_MESH_ADDR_IS_VIRTUAL(tx->ctx->addr)) {
    f3bc:	6863      	ldr	r3, [r4, #4]
    f3be:	8898      	ldrh	r0, [r3, #4]
    f3c0:	f480 4300 	eor.w	r3, r0, #32768	; 0x8000
    f3c4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    f3c8:	d236      	bcs.n	f438 <bt_mesh_trans_send+0x130>
		ad = bt_mesh_label_uuid_get(tx->ctx->addr);
    f3ca:	f003 f9f3 	bl	127b4 <bt_mesh_label_uuid_get>
    f3ce:	4603      	mov	r3, r0
	err = bt_mesh_app_encrypt(key, BT_MESH_IS_DEV_KEY(tx->ctx->app_idx),
    f3d0:	6862      	ldr	r2, [r4, #4]
    f3d2:	f8df c08c 	ldr.w	ip, [pc, #140]	; f460 <bt_mesh_trans_send+0x158>
    f3d6:	8851      	ldrh	r1, [r2, #2]
    f3d8:	f8b2 9004 	ldrh.w	r9, [r2, #4]
				  tx->aszmic, msg, ad, tx->src, tx->ctx->addr,
    f3dc:	f894 e00b 	ldrb.w	lr, [r4, #11]
	err = bt_mesh_app_encrypt(key, BT_MESH_IS_DEV_KEY(tx->ctx->app_idx),
    f3e0:	f8b4 8008 	ldrh.w	r8, [r4, #8]
    f3e4:	9807      	ldr	r0, [sp, #28]
				  bt_mesh.seq, BT_MESH_NET_IVI_TX);
    f3e6:	e9dc 2a00 	ldrd	r2, sl, [ip]
    f3ea:	f3bf 8f5b 	dmb	ish
    f3ee:	f8dc c008 	ldr.w	ip, [ip, #8]
    f3f2:	f3bf 8f5b 	dmb	ish
	err = bt_mesh_app_encrypt(key, BT_MESH_IS_DEV_KEY(tx->ctx->app_idx),
    f3f6:	3103      	adds	r1, #3
    f3f8:	b289      	uxth	r1, r1
				  bt_mesh.seq, BT_MESH_NET_IVI_TX);
    f3fa:	f3cc 0c80 	ubfx	ip, ip, #2, #1
	err = bt_mesh_app_encrypt(key, BT_MESH_IS_DEV_KEY(tx->ctx->app_idx),
    f3fe:	2901      	cmp	r1, #1
    f400:	eba2 020c 	sub.w	r2, r2, ip
    f404:	e9cd a203 	strd	sl, r2, [sp, #12]
    f408:	9300      	str	r3, [sp, #0]
    f40a:	bf8c      	ite	hi
    f40c:	2100      	movhi	r1, #0
    f40e:	2101      	movls	r1, #1
    f410:	e9cd 8901 	strd	r8, r9, [sp, #4]
    f414:	462b      	mov	r3, r5
    f416:	f3ce 0240 	ubfx	r2, lr, #1, #1
    f41a:	f018 f8ba 	bl	27592 <bt_mesh_app_encrypt>
	if (err) {
    f41e:	2800      	cmp	r0, #0
    f420:	d196      	bne.n	f350 <bt_mesh_trans_send+0x48>
	if (tx->ctx->send_rel) {
    f422:	6863      	ldr	r3, [r4, #4]
    f424:	7a9b      	ldrb	r3, [r3, #10]
		err = send_seg(tx, msg, cb, cb_data, NULL);
    f426:	9000      	str	r0, [sp, #0]
	if (tx->ctx->send_rel) {
    f428:	b143      	cbz	r3, f43c <bt_mesh_trans_send+0x134>
		err = send_seg(tx, msg, cb, cb_data, NULL);
    f42a:	463b      	mov	r3, r7
    f42c:	4632      	mov	r2, r6
    f42e:	4629      	mov	r1, r5
    f430:	4620      	mov	r0, r4
    f432:	f7fe fe37 	bl	e0a4 <send_seg>
    f436:	e78b      	b.n	f350 <bt_mesh_trans_send+0x48>
		ad = NULL;
    f438:	2300      	movs	r3, #0
    f43a:	e7c9      	b.n	f3d0 <bt_mesh_trans_send+0xc8>
		err = send_unseg(tx, msg, cb, cb_data, NULL);
    f43c:	463b      	mov	r3, r7
    f43e:	4632      	mov	r2, r6
    f440:	4629      	mov	r1, r5
    f442:	4620      	mov	r0, r4
    f444:	f7fe fbb0 	bl	dba8 <send_unseg>
    f448:	e782      	b.n	f350 <bt_mesh_trans_send+0x48>
    f44a:	bf00      	nop
    f44c:	00029988 	.word	0x00029988
    f450:	00029830 	.word	0x00029830
    f454:	0002d71c 	.word	0x0002d71c
    f458:	0002d738 	.word	0x0002d738
    f45c:	0002d761 	.word	0x0002d761
    f460:	20006b48 	.word	0x20006b48

0000f464 <bt_mesh_k2>:
	return bt_mesh_aes_cmac_one(okm, info, strlen(info), okm);
}

int bt_mesh_k2(const u8_t n[16], const u8_t *p, size_t p_len,
	       u8_t net_id[1], u8_t enc_key[16], u8_t priv_key[16])
{
    f464:	b5f0      	push	{r4, r5, r6, r7, lr}
    f466:	b095      	sub	sp, #84	; 0x54
    f468:	4604      	mov	r4, r0
    f46a:	460f      	mov	r7, r1
	int err;

	BT_DBG("n %s", bt_hex(n, 16));
	BT_DBG("p %s", bt_hex(p, p_len));

	err = bt_mesh_s1("smk2", salt);
    f46c:	4828      	ldr	r0, [pc, #160]	; (f510 <bt_mesh_k2+0xac>)
    f46e:	a902      	add	r1, sp, #8
{
    f470:	4615      	mov	r5, r2
    f472:	461e      	mov	r6, r3
	err = bt_mesh_s1("smk2", salt);
    f474:	f017 ffbb 	bl	273ee <bt_mesh_s1>
	if (err) {
    f478:	2800      	cmp	r0, #0
    f47a:	d146      	bne.n	f50a <bt_mesh_k2+0xa6>
		return err;
	}

	err = bt_mesh_aes_cmac_one(salt, n, 16, t);
    f47c:	4621      	mov	r1, r4
    f47e:	ab0a      	add	r3, sp, #40	; 0x28
    f480:	2210      	movs	r2, #16
    f482:	a802      	add	r0, sp, #8
    f484:	f017 ffa9 	bl	273da <bt_mesh_aes_cmac_one>
	if (err) {
    f488:	4604      	mov	r4, r0
    f48a:	2800      	cmp	r0, #0
    f48c:	d13a      	bne.n	f504 <bt_mesh_k2+0xa0>
		return err;
	}

	pad = 0x01;
    f48e:	2301      	movs	r3, #1

	sg[0].data = NULL;
	sg[0].len  = 0;
	sg[1].data = p;
	sg[1].len  = p_len;
    f490:	e9cd 7510 	strd	r7, r5, [sp, #64]	; 0x40
	sg[2].data = &pad;
    f494:	f10d 0207 	add.w	r2, sp, #7
	sg[2].len  = sizeof(pad);

	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
    f498:	ad06      	add	r5, sp, #24
	sg[2].len  = sizeof(pad);
    f49a:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
	sg[0].len  = 0;
    f49e:	e9cd 000e 	strd	r0, r0, [sp, #56]	; 0x38
	pad = 0x01;
    f4a2:	f88d 3007 	strb.w	r3, [sp, #7]
	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
    f4a6:	2203      	movs	r2, #3
    f4a8:	462b      	mov	r3, r5
    f4aa:	a90e      	add	r1, sp, #56	; 0x38
    f4ac:	a80a      	add	r0, sp, #40	; 0x28
    f4ae:	f017 ff72 	bl	27396 <bt_mesh_aes_cmac>
	if (err) {
    f4b2:	4604      	mov	r4, r0
    f4b4:	bb30      	cbnz	r0, f504 <bt_mesh_k2+0xa0>
		return err;
	}

	net_id[0] = out[15] & 0x7f;
    f4b6:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27

	sg[0].data = out;
    f4ba:	950e      	str	r5, [sp, #56]	; 0x38
	net_id[0] = out[15] & 0x7f;
    f4bc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    f4c0:	7033      	strb	r3, [r6, #0]
	sg[0].len  = sizeof(out);
	pad = 0x02;
    f4c2:	2302      	movs	r3, #2
    f4c4:	f88d 3007 	strb.w	r3, [sp, #7]
	sg[0].len  = sizeof(out);
    f4c8:	2610      	movs	r6, #16

	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
    f4ca:	462b      	mov	r3, r5
    f4cc:	2203      	movs	r2, #3
    f4ce:	a90e      	add	r1, sp, #56	; 0x38
    f4d0:	a80a      	add	r0, sp, #40	; 0x28
	sg[0].len  = sizeof(out);
    f4d2:	960f      	str	r6, [sp, #60]	; 0x3c
	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
    f4d4:	f017 ff5f 	bl	27396 <bt_mesh_aes_cmac>
	if (err) {
    f4d8:	4604      	mov	r4, r0
    f4da:	b998      	cbnz	r0, f504 <bt_mesh_k2+0xa0>
		return err;
	}

	memcpy(enc_key, out, 16);
    f4dc:	4632      	mov	r2, r6
    f4de:	4629      	mov	r1, r5
    f4e0:	981a      	ldr	r0, [sp, #104]	; 0x68
    f4e2:	f016 fbe1 	bl	25ca8 <memcpy>

	pad = 0x03;
    f4e6:	2203      	movs	r2, #3

	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
    f4e8:	462b      	mov	r3, r5
    f4ea:	a90e      	add	r1, sp, #56	; 0x38
    f4ec:	a80a      	add	r0, sp, #40	; 0x28
	pad = 0x03;
    f4ee:	f88d 2007 	strb.w	r2, [sp, #7]
	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
    f4f2:	f017 ff50 	bl	27396 <bt_mesh_aes_cmac>
	if (err) {
    f4f6:	4604      	mov	r4, r0
    f4f8:	b920      	cbnz	r0, f504 <bt_mesh_k2+0xa0>
		return err;
	}

	memcpy(priv_key, out, 16);
    f4fa:	981b      	ldr	r0, [sp, #108]	; 0x6c
    f4fc:	4632      	mov	r2, r6
    f4fe:	4629      	mov	r1, r5
    f500:	f016 fbd2 	bl	25ca8 <memcpy>

	BT_DBG("NID 0x%02x enc_key %s", net_id[0], bt_hex(enc_key, 16));
	BT_DBG("priv_key %s", bt_hex(priv_key, 16));

	return 0;
}
    f504:	4620      	mov	r0, r4
    f506:	b015      	add	sp, #84	; 0x54
    f508:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return err;
    f50a:	2401      	movs	r4, #1
    f50c:	e7fa      	b.n	f504 <bt_mesh_k2+0xa0>
    f50e:	bf00      	nop
    f510:	0002d79b 	.word	0x0002d79b

0000f514 <bt_mesh_k3>:

int bt_mesh_k3(const u8_t n[16], u8_t out[8])
{
    f514:	b530      	push	{r4, r5, lr}
	u8_t id64[] = { 'i', 'd', '6', '4', 0x01 };
    f516:	4b14      	ldr	r3, [pc, #80]	; (f568 <bt_mesh_k3+0x54>)
{
    f518:	b08b      	sub	sp, #44	; 0x2c
    f51a:	4604      	mov	r4, r0
	u8_t id64[] = { 'i', 'd', '6', '4', 0x01 };
    f51c:	6818      	ldr	r0, [r3, #0]
    f51e:	9000      	str	r0, [sp, #0]
    f520:	791b      	ldrb	r3, [r3, #4]
	u8_t tmp[16];
	u8_t t[16];
	int err;

	err = bt_mesh_s1("smk3", tmp);
    f522:	4812      	ldr	r0, [pc, #72]	; (f56c <bt_mesh_k3+0x58>)
	u8_t id64[] = { 'i', 'd', '6', '4', 0x01 };
    f524:	f88d 3004 	strb.w	r3, [sp, #4]
{
    f528:	460d      	mov	r5, r1
	err = bt_mesh_s1("smk3", tmp);
    f52a:	a902      	add	r1, sp, #8
    f52c:	f017 ff5f 	bl	273ee <bt_mesh_s1>
	if (err) {
    f530:	b9b8      	cbnz	r0, f562 <bt_mesh_k3+0x4e>
		return err;
	}

	err = bt_mesh_aes_cmac_one(tmp, n, 16, t);
    f532:	4621      	mov	r1, r4
    f534:	ab06      	add	r3, sp, #24
    f536:	2210      	movs	r2, #16
    f538:	a802      	add	r0, sp, #8
    f53a:	f017 ff4e 	bl	273da <bt_mesh_aes_cmac_one>
	if (err) {
    f53e:	4604      	mov	r4, r0
    f540:	b960      	cbnz	r0, f55c <bt_mesh_k3+0x48>
		return err;
	}

	err = bt_mesh_aes_cmac_one(t, id64, sizeof(id64), tmp);
    f542:	ab02      	add	r3, sp, #8
    f544:	2205      	movs	r2, #5
    f546:	4669      	mov	r1, sp
    f548:	a806      	add	r0, sp, #24
    f54a:	f017 ff46 	bl	273da <bt_mesh_aes_cmac_one>
	if (err) {
    f54e:	4604      	mov	r4, r0
    f550:	b920      	cbnz	r0, f55c <bt_mesh_k3+0x48>
		return err;
	}

	memcpy(out, tmp + 8, 8);
    f552:	2208      	movs	r2, #8
    f554:	a904      	add	r1, sp, #16
    f556:	4628      	mov	r0, r5
    f558:	f016 fba6 	bl	25ca8 <memcpy>

	return 0;
}
    f55c:	4620      	mov	r0, r4
    f55e:	b00b      	add	sp, #44	; 0x2c
    f560:	bd30      	pop	{r4, r5, pc}
		return err;
    f562:	2401      	movs	r4, #1
    f564:	e7fa      	b.n	f55c <bt_mesh_k3+0x48>
    f566:	bf00      	nop
    f568:	0002d7a5 	.word	0x0002d7a5
    f56c:	0002d7a0 	.word	0x0002d7a0

0000f570 <bt_mesh_k4>:

int bt_mesh_k4(const u8_t n[16], u8_t out[1])
{
    f570:	b530      	push	{r4, r5, lr}
    f572:	b08b      	sub	sp, #44	; 0x2c
	u8_t id6[] = { 'i', 'd', '6', 0x01 };
    f574:	4b10      	ldr	r3, [pc, #64]	; (f5b8 <bt_mesh_k4+0x48>)
    f576:	9301      	str	r3, [sp, #4]
{
    f578:	4605      	mov	r5, r0
    f57a:	460c      	mov	r4, r1
	u8_t tmp[16];
	u8_t t[16];
	int err;

	err = bt_mesh_s1("smk4", tmp);
    f57c:	480f      	ldr	r0, [pc, #60]	; (f5bc <bt_mesh_k4+0x4c>)
    f57e:	a902      	add	r1, sp, #8
    f580:	f017 ff35 	bl	273ee <bt_mesh_s1>
	if (err) {
    f584:	b9a8      	cbnz	r0, f5b2 <bt_mesh_k4+0x42>
		return err;
	}

	err = bt_mesh_aes_cmac_one(tmp, n, 16, t);
    f586:	ab06      	add	r3, sp, #24
    f588:	2210      	movs	r2, #16
    f58a:	4629      	mov	r1, r5
    f58c:	a802      	add	r0, sp, #8
    f58e:	f017 ff24 	bl	273da <bt_mesh_aes_cmac_one>
	if (err) {
    f592:	b960      	cbnz	r0, f5ae <bt_mesh_k4+0x3e>
		return err;
	}

	err = bt_mesh_aes_cmac_one(t, id6, sizeof(id6), tmp);
    f594:	2204      	movs	r2, #4
    f596:	ab02      	add	r3, sp, #8
    f598:	eb0d 0102 	add.w	r1, sp, r2
    f59c:	a806      	add	r0, sp, #24
    f59e:	f017 ff1c 	bl	273da <bt_mesh_aes_cmac_one>
	if (err) {
    f5a2:	b920      	cbnz	r0, f5ae <bt_mesh_k4+0x3e>
		return err;
	}

	out[0] = tmp[15] & BIT_MASK(6);
    f5a4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    f5a8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    f5ac:	7023      	strb	r3, [r4, #0]

	return 0;
}
    f5ae:	b00b      	add	sp, #44	; 0x2c
    f5b0:	bd30      	pop	{r4, r5, pc}
		return err;
    f5b2:	2001      	movs	r0, #1
    f5b4:	e7fb      	b.n	f5ae <bt_mesh_k4+0x3e>
    f5b6:	bf00      	nop
    f5b8:	01366469 	.word	0x01366469
    f5bc:	0002d7ab 	.word	0x0002d7ab

0000f5c0 <bt_mesh_id128>:

int bt_mesh_id128(const u8_t n[16], const char *s, u8_t out[16])
{
    f5c0:	b530      	push	{r4, r5, lr}
    f5c2:	b087      	sub	sp, #28
    f5c4:	4604      	mov	r4, r0
    f5c6:	4608      	mov	r0, r1
	const char *id128 = "id128\x01";
	u8_t salt[16];
	int err;

	err = bt_mesh_s1(s, salt);
    f5c8:	a902      	add	r1, sp, #8
{
    f5ca:	4615      	mov	r5, r2
	err = bt_mesh_s1(s, salt);
    f5cc:	f017 ff0f 	bl	273ee <bt_mesh_s1>
	if (err) {
    f5d0:	b940      	cbnz	r0, f5e4 <bt_mesh_id128+0x24>
		return err;
	}

	return bt_mesh_k1(n, 16, salt, id128, out);
    f5d2:	4b05      	ldr	r3, [pc, #20]	; (f5e8 <bt_mesh_id128+0x28>)
    f5d4:	9500      	str	r5, [sp, #0]
    f5d6:	aa02      	add	r2, sp, #8
    f5d8:	2110      	movs	r1, #16
    f5da:	4620      	mov	r0, r4
    f5dc:	f017 ff1d 	bl	2741a <bt_mesh_k1>
}
    f5e0:	b007      	add	sp, #28
    f5e2:	bd30      	pop	{r4, r5, pc}
		return err;
    f5e4:	2001      	movs	r0, #1
    f5e6:	e7fb      	b.n	f5e0 <bt_mesh_id128+0x20>
    f5e8:	0002d7b0 	.word	0x0002d7b0

0000f5ec <bt_mesh_net_obfuscate>:
	sys_put_be32(iv_index, &nonce[9]);
}

int bt_mesh_net_obfuscate(u8_t *pdu, u32_t iv_index,
			  const u8_t privacy_key[16])
{
    f5ec:	b570      	push	{r4, r5, r6, lr}
	u8_t priv_rand[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, };
    f5ee:	4b18      	ldr	r3, [pc, #96]	; (f650 <bt_mesh_net_obfuscate+0x64>)
{
    f5f0:	b088      	sub	sp, #32
    f5f2:	4604      	mov	r4, r0
    f5f4:	460e      	mov	r6, r1
	u8_t priv_rand[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, };
    f5f6:	6818      	ldr	r0, [r3, #0]
    f5f8:	889b      	ldrh	r3, [r3, #4]
    f5fa:	9000      	str	r0, [sp, #0]
    f5fc:	f8ad 3004 	strh.w	r3, [sp, #4]
	u8_t tmp[16];
	int err, i;

	BT_DBG("IVIndex %u, PrivacyKey %s", iv_index, bt_hex(privacy_key, 16));

	sys_put_be32(iv_index, &priv_rand[5]);
    f600:	f10d 0105 	add.w	r1, sp, #5
	u8_t priv_rand[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, };
    f604:	2300      	movs	r3, #0
	sys_put_be32(iv_index, &priv_rand[5]);
    f606:	4630      	mov	r0, r6
{
    f608:	4615      	mov	r5, r2
	u8_t priv_rand[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, };
    f60a:	f8cd 3006 	str.w	r3, [sp, #6]
    f60e:	f8cd 300a 	str.w	r3, [sp, #10]
    f612:	f8ad 300e 	strh.w	r3, [sp, #14]
	sys_put_be32(iv_index, &priv_rand[5]);
    f616:	f017 feb5 	bl	27384 <sys_put_be32>
	memcpy(&priv_rand[9], &pdu[7], 7);
    f61a:	2207      	movs	r2, #7
    f61c:	18a1      	adds	r1, r4, r2
    f61e:	f10d 0009 	add.w	r0, sp, #9
    f622:	f016 fb41 	bl	25ca8 <memcpy>

	BT_DBG("PrivacyRandom %s", bt_hex(priv_rand, 16));

	err = bt_encrypt_be(privacy_key, priv_rand, tmp);
    f626:	aa04      	add	r2, sp, #16
    f628:	4669      	mov	r1, sp
    f62a:	4628      	mov	r0, r5
    f62c:	f018 feb3 	bl	28396 <bt_encrypt_be>
	if (err) {
    f630:	b958      	cbnz	r0, f64a <bt_mesh_net_obfuscate+0x5e>
    f632:	4623      	mov	r3, r4
    f634:	aa04      	add	r2, sp, #16
    f636:	3406      	adds	r4, #6
		return err;
	}

	for (i = 0; i < 6; i++) {
		pdu[1 + i] ^= tmp[i];
    f638:	f813 5f01 	ldrb.w	r5, [r3, #1]!
    f63c:	f812 1b01 	ldrb.w	r1, [r2], #1
	for (i = 0; i < 6; i++) {
    f640:	42a3      	cmp	r3, r4
		pdu[1 + i] ^= tmp[i];
    f642:	ea81 0105 	eor.w	r1, r1, r5
    f646:	7019      	strb	r1, [r3, #0]
	for (i = 0; i < 6; i++) {
    f648:	d1f6      	bne.n	f638 <bt_mesh_net_obfuscate+0x4c>
	}

	return 0;
}
    f64a:	b008      	add	sp, #32
    f64c:	bd70      	pop	{r4, r5, r6, pc}
    f64e:	bf00      	nop
    f650:	00029a9c 	.word	0x00029a9c

0000f654 <bt_mesh_fcs_calc>:
	0xb4, 0x25, 0x57, 0xc6, 0xb3, 0x22, 0x50, 0xc1,
	0xba, 0x2b, 0x59, 0xc8, 0xbd, 0x2c, 0x5e, 0xcf
};

u8_t bt_mesh_fcs_calc(const u8_t *data, u8_t data_len)
{
    f654:	b510      	push	{r4, lr}
	u8_t fcs = 0xff;

	while (data_len--) {
		fcs = crc_table[fcs ^ *data++];
    f656:	4a06      	ldr	r2, [pc, #24]	; (f670 <bt_mesh_fcs_calc+0x1c>)
    f658:	4401      	add	r1, r0
	u8_t fcs = 0xff;
    f65a:	23ff      	movs	r3, #255	; 0xff
	while (data_len--) {
    f65c:	4288      	cmp	r0, r1
    f65e:	d102      	bne.n	f666 <bt_mesh_fcs_calc+0x12>
	}

	BT_DBG("fcs 0x%02x", 0xff - fcs);

	return 0xff - fcs;
    f660:	43d8      	mvns	r0, r3
}
    f662:	b2c0      	uxtb	r0, r0
    f664:	bd10      	pop	{r4, pc}
		fcs = crc_table[fcs ^ *data++];
    f666:	f810 4b01 	ldrb.w	r4, [r0], #1
    f66a:	4063      	eors	r3, r4
    f66c:	5cd3      	ldrb	r3, [r2, r3]
    f66e:	e7f5      	b.n	f65c <bt_mesh_fcs_calc+0x8>
    f670:	0002d7d0 	.word	0x0002d7d0

0000f674 <bt_mesh_fcs_check>:

bool bt_mesh_fcs_check(struct net_buf_simple *buf, u8_t received_fcs)
{
    f674:	b530      	push	{r4, r5, lr}
	const u8_t *data = buf->data;
    f676:	6804      	ldr	r4, [r0, #0]
	u16_t data_len = buf->len;
	u8_t fcs = 0xff;

	while (data_len--) {
    f678:	8880      	ldrh	r0, [r0, #4]
    f67a:	4d08      	ldr	r5, [pc, #32]	; (f69c <bt_mesh_fcs_check+0x28>)
    f67c:	4420      	add	r0, r4
	u8_t fcs = 0xff;
    f67e:	23ff      	movs	r3, #255	; 0xff
	while (data_len--) {
    f680:	4284      	cmp	r4, r0
    f682:	d106      	bne.n	f692 <bt_mesh_fcs_check+0x1e>
		fcs = crc_table[fcs ^ *data++];
	}

	return crc_table[fcs ^ received_fcs] == 0xcf;
    f684:	404b      	eors	r3, r1
    f686:	5ce8      	ldrb	r0, [r5, r3]
}
    f688:	f1a0 03cf 	sub.w	r3, r0, #207	; 0xcf
    f68c:	4258      	negs	r0, r3
    f68e:	4158      	adcs	r0, r3
    f690:	bd30      	pop	{r4, r5, pc}
		fcs = crc_table[fcs ^ *data++];
    f692:	f814 2b01 	ldrb.w	r2, [r4], #1
    f696:	405a      	eors	r2, r3
    f698:	5cab      	ldrb	r3, [r5, r2]
    f69a:	e7f1      	b.n	f680 <bt_mesh_fcs_check+0xc>
    f69c:	0002d7d0 	.word	0x0002d7d0

0000f6a0 <bt_mesh_virtual_addr>:

int bt_mesh_virtual_addr(const u8_t virtual_label[16], u16_t *addr)
{
    f6a0:	b530      	push	{r4, r5, lr}
    f6a2:	b089      	sub	sp, #36	; 0x24
    f6a4:	4605      	mov	r5, r0
    f6a6:	460c      	mov	r4, r1
	u8_t salt[16];
	u8_t tmp[16];
	int err;

	err = bt_mesh_s1("vtad", salt);
    f6a8:	480e      	ldr	r0, [pc, #56]	; (f6e4 <bt_mesh_virtual_addr+0x44>)
    f6aa:	4669      	mov	r1, sp
    f6ac:	f017 fe9f 	bl	273ee <bt_mesh_s1>
	if (err) {
    f6b0:	b9a8      	cbnz	r0, f6de <bt_mesh_virtual_addr+0x3e>
		return err;
	}

	err = bt_mesh_aes_cmac_one(salt, virtual_label, 16, tmp);
    f6b2:	ab04      	add	r3, sp, #16
    f6b4:	2210      	movs	r2, #16
    f6b6:	4629      	mov	r1, r5
    f6b8:	4668      	mov	r0, sp
    f6ba:	f017 fe8e 	bl	273da <bt_mesh_aes_cmac_one>
	if (err) {
    f6be:	b960      	cbnz	r0, f6da <bt_mesh_virtual_addr+0x3a>
    f6c0:	f89d 201e 	ldrb.w	r2, [sp, #30]
    f6c4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    f6c8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		return err;
	}

	*addr = (sys_get_be16(&tmp[14]) & 0x3fff) | 0x8000;
    f6cc:	f3c3 030d 	ubfx	r3, r3, #0, #14
    f6d0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    f6d4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    f6d8:	8023      	strh	r3, [r4, #0]

	return 0;
}
    f6da:	b009      	add	sp, #36	; 0x24
    f6dc:	bd30      	pop	{r4, r5, pc}
		return err;
    f6de:	2001      	movs	r0, #1
    f6e0:	e7fb      	b.n	f6da <bt_mesh_virtual_addr+0x3a>
    f6e2:	bf00      	nop
    f6e4:	0002d7b7 	.word	0x0002d7b7

0000f6e8 <bt_mesh_prov_conf_key>:
	return bt_mesh_aes_cmac_one(conf_salt_key, conf_inputs, 145, salt);
}

int bt_mesh_prov_conf_key(const u8_t dhkey[32], const u8_t conf_salt[16],
			  u8_t conf_key[16])
{
    f6e8:	b507      	push	{r0, r1, r2, lr}
	return bt_mesh_k1(dhkey, 32, conf_salt, "prck", conf_key);
    f6ea:	4b04      	ldr	r3, [pc, #16]	; (f6fc <bt_mesh_prov_conf_key+0x14>)
    f6ec:	9200      	str	r2, [sp, #0]
    f6ee:	460a      	mov	r2, r1
    f6f0:	2120      	movs	r1, #32
    f6f2:	f017 fe92 	bl	2741a <bt_mesh_k1>
}
    f6f6:	b003      	add	sp, #12
    f6f8:	f85d fb04 	ldr.w	pc, [sp], #4
    f6fc:	0002d7bc 	.word	0x0002d7bc

0000f700 <mod_init>:
	}
}

static void mod_init(struct bt_mesh_model *mod, struct bt_mesh_elem *elem,
		     bool vnd, bool primary, void *user_data)
{
    f700:	b570      	push	{r4, r5, r6, lr}
    f702:	4604      	mov	r4, r0
	int i;

	if (mod->pub) {
    f704:	6880      	ldr	r0, [r0, #8]
{
    f706:	460d      	mov	r5, r1
    f708:	4616      	mov	r6, r2
	if (mod->pub) {
    f70a:	b120      	cbz	r0, f716 <mod_init+0x16>
		mod->pub->mod = mod;
    f70c:	f840 4b18 	str.w	r4, [r0], #24
		k_delayed_work_init(&mod->pub->timer, mod_publish);
    f710:	490e      	ldr	r1, [pc, #56]	; (f74c <mod_init+0x4c>)
    f712:	f019 fe72 	bl	293fa <k_delayed_work_init>
	}

	for (i = 0; i < ARRAY_SIZE(mod->keys); i++) {
		mod->keys[i] = BT_MESH_KEY_UNUSED;
    f716:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    f71a:	60e3      	str	r3, [r4, #12]
	}

	mod->elem_idx = elem - dev_comp->elem;
    f71c:	4b0c      	ldr	r3, [pc, #48]	; (f750 <mod_init+0x50>)
    f71e:	681b      	ldr	r3, [r3, #0]
    f720:	68db      	ldr	r3, [r3, #12]
    f722:	1aeb      	subs	r3, r5, r3
    f724:	111b      	asrs	r3, r3, #4
    f726:	7123      	strb	r3, [r4, #4]
	if (vnd) {
    f728:	b166      	cbz	r6, f744 <mod_init+0x44>
		mod->mod_idx = mod - elem->vnd_models;
    f72a:	68eb      	ldr	r3, [r5, #12]
	} else {
		mod->mod_idx = mod - elem->models;
    f72c:	1ae3      	subs	r3, r4, r3
    f72e:	f3c3 1347 	ubfx	r3, r3, #5, #8
    f732:	7163      	strb	r3, [r4, #5]
	}

	if (mod->cb && mod->cb->init) {
    f734:	69a3      	ldr	r3, [r4, #24]
    f736:	b13b      	cbz	r3, f748 <mod_init+0x48>
    f738:	689b      	ldr	r3, [r3, #8]
    f73a:	b12b      	cbz	r3, f748 <mod_init+0x48>
		mod->cb->init(mod);
    f73c:	4620      	mov	r0, r4
	}
}
    f73e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		mod->cb->init(mod);
    f742:	4718      	bx	r3
		mod->mod_idx = mod - elem->models;
    f744:	68ab      	ldr	r3, [r5, #8]
    f746:	e7f1      	b.n	f72c <mod_init+0x2c>
}
    f748:	bd70      	pop	{r4, r5, r6, pc}
    f74a:	bf00      	nop
    f74c:	0000fe29 	.word	0x0000fe29
    f750:	20000904 	.word	0x20000904

0000f754 <model_send>:

static int model_send(struct bt_mesh_model *model,
		      struct bt_mesh_net_tx *tx, bool implicit_bind,
		      struct net_buf_simple *msg,
		      const struct bt_mesh_send_cb *cb, void *cb_data)
{
    f754:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f758:	4606      	mov	r6, r0
    f75a:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
    f75e:	460d      	mov	r5, r1
    f760:	4691      	mov	r9, r2
    f762:	461c      	mov	r4, r3
	BT_DBG("net_idx 0x%04x app_idx 0x%04x dst 0x%04x", tx->ctx->net_idx,
	       tx->ctx->app_idx, tx->ctx->addr);
	BT_DBG("len %u: %s", msg->len, bt_hex(msg->data, msg->len));

	if (!bt_mesh_is_provisioned()) {
    f764:	f7fc fb22 	bl	bdac <bt_mesh_is_provisioned>
    f768:	b968      	cbnz	r0, f786 <model_send+0x32>
    f76a:	4b2f      	ldr	r3, [pc, #188]	; (f828 <model_send+0xd4>)
    f76c:	492f      	ldr	r1, [pc, #188]	; (f82c <model_send+0xd8>)
		BT_ERR("Local node is not yet provisioned");
    f76e:	4830      	ldr	r0, [pc, #192]	; (f830 <model_send+0xdc>)
    f770:	1ac9      	subs	r1, r1, r3
    f772:	08c9      	lsrs	r1, r1, #3
    f774:	0189      	lsls	r1, r1, #6
    f776:	f041 0101 	orr.w	r1, r1, #1
    f77a:	f014 fc23 	bl	23fc4 <log_0>
		return -EAGAIN;
    f77e:	f06f 000a 	mvn.w	r0, #10
		BT_ERR("Model not bound to AppKey 0x%04x", tx->ctx->app_idx);
		return -EINVAL;
	}

	return bt_mesh_trans_send(tx, msg, cb, cb_data);
}
    f782:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (net_buf_simple_tailroom(msg) < 4) {
    f786:	4620      	mov	r0, r4
    f788:	f019 fb0d 	bl	28da6 <net_buf_simple_tailroom>
    f78c:	2803      	cmp	r0, #3
    f78e:	d80c      	bhi.n	f7aa <model_send+0x56>
    f790:	4926      	ldr	r1, [pc, #152]	; (f82c <model_send+0xd8>)
    f792:	4b25      	ldr	r3, [pc, #148]	; (f828 <model_send+0xd4>)
		BT_ERR("Not enough tailroom for TransMIC");
    f794:	4827      	ldr	r0, [pc, #156]	; (f834 <model_send+0xe0>)
    f796:	1ac9      	subs	r1, r1, r3
    f798:	08c9      	lsrs	r1, r1, #3
    f79a:	0189      	lsls	r1, r1, #6
    f79c:	f041 0101 	orr.w	r1, r1, #1
    f7a0:	f014 fc10 	bl	23fc4 <log_0>
		return -EINVAL;
    f7a4:	f06f 0015 	mvn.w	r0, #21
    f7a8:	e7eb      	b.n	f782 <model_send+0x2e>
	if (msg->len > BT_MESH_TX_SDU_MAX - 4) {
    f7aa:	88a3      	ldrh	r3, [r4, #4]
    f7ac:	2b20      	cmp	r3, #32
    f7ae:	d90c      	bls.n	f7ca <model_send+0x76>
    f7b0:	4b1d      	ldr	r3, [pc, #116]	; (f828 <model_send+0xd4>)
    f7b2:	491e      	ldr	r1, [pc, #120]	; (f82c <model_send+0xd8>)
		BT_ERR("Too big message");
    f7b4:	4820      	ldr	r0, [pc, #128]	; (f838 <model_send+0xe4>)
    f7b6:	1ac9      	subs	r1, r1, r3
    f7b8:	08c9      	lsrs	r1, r1, #3
    f7ba:	0189      	lsls	r1, r1, #6
    f7bc:	f041 0101 	orr.w	r1, r1, #1
    f7c0:	f014 fc00 	bl	23fc4 <log_0>
		return -EMSGSIZE;
    f7c4:	f06f 0023 	mvn.w	r0, #35	; 0x23
    f7c8:	e7db      	b.n	f782 <model_send+0x2e>
	if (!implicit_bind && !model_has_key(model, tx->ctx->app_idx)) {
    f7ca:	f1b9 0f00 	cmp.w	r9, #0
    f7ce:	d122      	bne.n	f816 <model_send+0xc2>
    f7d0:	686b      	ldr	r3, [r5, #4]
    f7d2:	8859      	ldrh	r1, [r3, #2]
		if (mod->keys[i] == key ||
    f7d4:	89b3      	ldrh	r3, [r6, #12]
    f7d6:	428b      	cmp	r3, r1
    f7d8:	d01d      	beq.n	f816 <model_send+0xc2>
    f7da:	f64f 72fc 	movw	r2, #65532	; 0xfffc
    f7de:	4293      	cmp	r3, r2
    f7e0:	d103      	bne.n	f7ea <model_send+0x96>
		     BT_MESH_IS_DEV_KEY(key))) {
    f7e2:	1ccb      	adds	r3, r1, #3
		    (mod->keys[i] == BT_MESH_KEY_DEV_ANY &&
    f7e4:	b29b      	uxth	r3, r3
    f7e6:	2b01      	cmp	r3, #1
    f7e8:	d915      	bls.n	f816 <model_send+0xc2>
		if (mod->keys[i] == key ||
    f7ea:	89f3      	ldrh	r3, [r6, #14]
    f7ec:	4299      	cmp	r1, r3
    f7ee:	d012      	beq.n	f816 <model_send+0xc2>
    f7f0:	f64f 72fc 	movw	r2, #65532	; 0xfffc
    f7f4:	4293      	cmp	r3, r2
    f7f6:	d103      	bne.n	f800 <model_send+0xac>
		     BT_MESH_IS_DEV_KEY(key))) {
    f7f8:	1ccb      	adds	r3, r1, #3
		    (mod->keys[i] == BT_MESH_KEY_DEV_ANY &&
    f7fa:	b29b      	uxth	r3, r3
    f7fc:	2b01      	cmp	r3, #1
    f7fe:	d90a      	bls.n	f816 <model_send+0xc2>
    f800:	4b09      	ldr	r3, [pc, #36]	; (f828 <model_send+0xd4>)
    f802:	4a0a      	ldr	r2, [pc, #40]	; (f82c <model_send+0xd8>)
		BT_ERR("Model not bound to AppKey 0x%04x", tx->ctx->app_idx);
    f804:	480d      	ldr	r0, [pc, #52]	; (f83c <model_send+0xe8>)
    f806:	1ad2      	subs	r2, r2, r3
    f808:	08d2      	lsrs	r2, r2, #3
    f80a:	0192      	lsls	r2, r2, #6
    f80c:	f042 0201 	orr.w	r2, r2, #1
    f810:	f014 fbe5 	bl	23fde <log_1>
    f814:	e7c6      	b.n	f7a4 <model_send+0x50>
	return bt_mesh_trans_send(tx, msg, cb, cb_data);
    f816:	4643      	mov	r3, r8
    f818:	463a      	mov	r2, r7
    f81a:	4621      	mov	r1, r4
    f81c:	4628      	mov	r0, r5
}
    f81e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_mesh_trans_send(tx, msg, cb, cb_data);
    f822:	f7ff bd71 	b.w	f308 <bt_mesh_trans_send>
    f826:	bf00      	nop
    f828:	00029830 	.word	0x00029830
    f82c:	00029908 	.word	0x00029908
    f830:	0002d8d0 	.word	0x0002d8d0
    f834:	0002d8f2 	.word	0x0002d8f2
    f838:	0002d913 	.word	0x0002d913
    f83c:	0002d923 	.word	0x0002d923

0000f840 <publish_start>:
{
    f840:	b510      	push	{r4, lr}
	if (err) {
    f842:	b159      	cbz	r1, f85c <publish_start+0x1c>
    f844:	4a0b      	ldr	r2, [pc, #44]	; (f874 <publish_start+0x34>)
    f846:	4b0c      	ldr	r3, [pc, #48]	; (f878 <publish_start+0x38>)
		BT_ERR("Failed to publish: err %d", err);
    f848:	480c      	ldr	r0, [pc, #48]	; (f87c <publish_start+0x3c>)
    f84a:	1ad2      	subs	r2, r2, r3
    f84c:	08d2      	lsrs	r2, r2, #3
    f84e:	0192      	lsls	r2, r2, #6
}
    f850:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_ERR("Failed to publish: err %d", err);
    f854:	f042 0201 	orr.w	r2, r2, #1
    f858:	f014 bbc1 	b.w	23fde <log_1>
	struct bt_mesh_model_pub *pub = mod->pub;
    f85c:	6894      	ldr	r4, [r2, #8]
	if (pub->count == BT_MESH_PUB_TRANSMIT_COUNT(pub->retransmit)) {
    f85e:	7a63      	ldrb	r3, [r4, #9]
    f860:	7ae2      	ldrb	r2, [r4, #11]
    f862:	f003 0307 	and.w	r3, r3, #7
    f866:	ebb3 1f52 	cmp.w	r3, r2, lsr #5
    f86a:	d102      	bne.n	f872 <publish_start+0x32>
		pub->period_start = k_uptime_get_32();
    f86c:	f017 ff69 	bl	27742 <k_uptime_get_32>
    f870:	60e0      	str	r0, [r4, #12]
}
    f872:	bd10      	pop	{r4, pc}
    f874:	00029908 	.word	0x00029908
    f878:	00029830 	.word	0x00029830
    f87c:	0002d944 	.word	0x0002d944

0000f880 <bt_mesh_model_foreach>:
{
    f880:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	for (i = 0; i < dev_comp->elem_count; i++) {
    f884:	f8df 9068 	ldr.w	r9, [pc, #104]	; f8f0 <bt_mesh_model_foreach+0x70>
{
    f888:	4606      	mov	r6, r0
    f88a:	460f      	mov	r7, r1
	for (i = 0; i < dev_comp->elem_count; i++) {
    f88c:	2500      	movs	r5, #0
    f88e:	f8d9 3000 	ldr.w	r3, [r9]
    f892:	689a      	ldr	r2, [r3, #8]
    f894:	42aa      	cmp	r2, r5
    f896:	d802      	bhi.n	f89e <bt_mesh_model_foreach+0x1e>
}
    f898:	b003      	add	sp, #12
    f89a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		struct bt_mesh_elem *elem = &dev_comp->elem[i];
    f89e:	68dc      	ldr	r4, [r3, #12]
		for (j = 0; j < elem->model_count; j++) {
    f8a0:	f04f 0800 	mov.w	r8, #0
		struct bt_mesh_elem *elem = &dev_comp->elem[i];
    f8a4:	eb04 1405 	add.w	r4, r4, r5, lsl #4
		for (j = 0; j < elem->model_count; j++) {
    f8a8:	7923      	ldrb	r3, [r4, #4]
    f8aa:	4543      	cmp	r3, r8
    f8ac:	dc06      	bgt.n	f8bc <bt_mesh_model_foreach+0x3c>
		for (j = 0; j < elem->vnd_model_count; j++) {
    f8ae:	f04f 0800 	mov.w	r8, #0
    f8b2:	7963      	ldrb	r3, [r4, #5]
    f8b4:	4543      	cmp	r3, r8
    f8b6:	dc0e      	bgt.n	f8d6 <bt_mesh_model_foreach+0x56>
	for (i = 0; i < dev_comp->elem_count; i++) {
    f8b8:	3501      	adds	r5, #1
    f8ba:	e7e8      	b.n	f88e <bt_mesh_model_foreach+0xe>
			struct bt_mesh_model *model = &elem->models[j];
    f8bc:	68a0      	ldr	r0, [r4, #8]
			func(model, elem, false, i == 0, user_data);
    f8be:	9700      	str	r7, [sp, #0]
    f8c0:	fab5 f385 	clz	r3, r5
    f8c4:	eb00 1048 	add.w	r0, r0, r8, lsl #5
    f8c8:	095b      	lsrs	r3, r3, #5
    f8ca:	2200      	movs	r2, #0
    f8cc:	4621      	mov	r1, r4
    f8ce:	47b0      	blx	r6
		for (j = 0; j < elem->model_count; j++) {
    f8d0:	f108 0801 	add.w	r8, r8, #1
    f8d4:	e7e8      	b.n	f8a8 <bt_mesh_model_foreach+0x28>
			struct bt_mesh_model *model = &elem->vnd_models[j];
    f8d6:	68e0      	ldr	r0, [r4, #12]
			func(model, elem, true, i == 0, user_data);
    f8d8:	9700      	str	r7, [sp, #0]
    f8da:	fab5 f385 	clz	r3, r5
    f8de:	eb00 1048 	add.w	r0, r0, r8, lsl #5
    f8e2:	095b      	lsrs	r3, r3, #5
    f8e4:	2201      	movs	r2, #1
    f8e6:	4621      	mov	r1, r4
    f8e8:	47b0      	blx	r6
		for (j = 0; j < elem->vnd_model_count; j++) {
    f8ea:	f108 0801 	add.w	r8, r8, #1
    f8ee:	e7e0      	b.n	f8b2 <bt_mesh_model_foreach+0x32>
    f8f0:	20000904 	.word	0x20000904

0000f8f4 <bt_mesh_model_pub_period_get>:
	if (!mod->pub) {
    f8f4:	6883      	ldr	r3, [r0, #8]
    f8f6:	b1e3      	cbz	r3, f932 <bt_mesh_model_pub_period_get+0x3e>
	switch (mod->pub->period >> 6) {
    f8f8:	7a98      	ldrb	r0, [r3, #10]
    f8fa:	0982      	lsrs	r2, r0, #6
    f8fc:	2a02      	cmp	r2, #2
    f8fe:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    f902:	d011      	beq.n	f928 <bt_mesh_model_pub_period_get+0x34>
    f904:	2a03      	cmp	r2, #3
    f906:	d012      	beq.n	f92e <bt_mesh_model_pub_period_get+0x3a>
    f908:	2a01      	cmp	r2, #1
    f90a:	d009      	beq.n	f920 <bt_mesh_model_pub_period_get+0x2c>
		period = K_MSEC((mod->pub->period & BIT_MASK(6)) * 100U);
    f90c:	2264      	movs	r2, #100	; 0x64
    f90e:	fb10 f002 	smulbb	r0, r0, r2
	if (mod->pub->fast_period) {
    f912:	7adb      	ldrb	r3, [r3, #11]
    f914:	06da      	lsls	r2, r3, #27
    f916:	d50d      	bpl.n	f934 <bt_mesh_model_pub_period_get+0x40>
		return period >> mod->pub->period_div;
    f918:	f003 030f 	and.w	r3, r3, #15
    f91c:	4118      	asrs	r0, r3
    f91e:	4770      	bx	lr
		period = K_SECONDS(mod->pub->period & BIT_MASK(6));
    f920:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		period = K_MINUTES((mod->pub->period & BIT_MASK(6)) * 10U);
    f924:	4350      	muls	r0, r2
		break;
    f926:	e7f4      	b.n	f912 <bt_mesh_model_pub_period_get+0x1e>
		period = K_SECONDS((mod->pub->period & BIT_MASK(6)) * 10U);
    f928:	f242 7210 	movw	r2, #10000	; 0x2710
    f92c:	e7fa      	b.n	f924 <bt_mesh_model_pub_period_get+0x30>
		period = K_MINUTES((mod->pub->period & BIT_MASK(6)) * 10U);
    f92e:	4a02      	ldr	r2, [pc, #8]	; (f938 <bt_mesh_model_pub_period_get+0x44>)
    f930:	e7f8      	b.n	f924 <bt_mesh_model_pub_period_get+0x30>
		return 0;
    f932:	4618      	mov	r0, r3
}
    f934:	4770      	bx	lr
    f936:	bf00      	nop
    f938:	000927c0 	.word	0x000927c0

0000f93c <publish_sent>:
{
    f93c:	b570      	push	{r4, r5, r6, lr}
	if (mod->pub->count) {
    f93e:	688e      	ldr	r6, [r1, #8]
    f940:	7af3      	ldrb	r3, [r6, #11]
    f942:	f013 0fe0 	tst.w	r3, #224	; 0xe0
{
    f946:	460d      	mov	r5, r1
	if (mod->pub->count) {
    f948:	d00b      	beq.n	f962 <publish_sent+0x26>
		delay = BT_MESH_PUB_TRANSMIT_INT(mod->pub->retransmit);
    f94a:	7a72      	ldrb	r2, [r6, #9]
    f94c:	08d4      	lsrs	r4, r2, #3
    f94e:	2232      	movs	r2, #50	; 0x32
    f950:	fb04 2202 	mla	r2, r4, r2, r2
		k_delayed_work_submit(&mod->pub->timer, delay);
    f954:	68a9      	ldr	r1, [r5, #8]
    f956:	4810      	ldr	r0, [pc, #64]	; (f998 <publish_sent+0x5c>)
}
    f958:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    f95c:	3118      	adds	r1, #24
    f95e:	f013 b8ff 	b.w	22b60 <k_delayed_work_submit_to_queue>
	period = bt_mesh_model_pub_period_get(mod);
    f962:	4608      	mov	r0, r1
    f964:	f7ff ffc6 	bl	f8f4 <bt_mesh_model_pub_period_get>
	if (!period) {
    f968:	4604      	mov	r4, r0
    f96a:	b1a0      	cbz	r0, f996 <publish_sent+0x5a>
	elapsed = k_uptime_get_32() - pub->period_start;
    f96c:	f017 fee9 	bl	27742 <k_uptime_get_32>
    f970:	68f2      	ldr	r2, [r6, #12]
    f972:	1a83      	subs	r3, r0, r2
	if (elapsed >= period) {
    f974:	429c      	cmp	r4, r3
    f976:	d80b      	bhi.n	f990 <publish_sent+0x54>
    f978:	4908      	ldr	r1, [pc, #32]	; (f99c <publish_sent+0x60>)
    f97a:	4b09      	ldr	r3, [pc, #36]	; (f9a0 <publish_sent+0x64>)
		BT_WARN("Publication sending took longer than the period");
    f97c:	4809      	ldr	r0, [pc, #36]	; (f9a4 <publish_sent+0x68>)
    f97e:	1a5b      	subs	r3, r3, r1
    f980:	08db      	lsrs	r3, r3, #3
    f982:	019b      	lsls	r3, r3, #6
    f984:	f043 0102 	orr.w	r1, r3, #2
    f988:	f014 fb1c 	bl	23fc4 <log_0>
		return K_MSEC(1);
    f98c:	2201      	movs	r2, #1
    f98e:	e7e1      	b.n	f954 <publish_sent+0x18>
	return period - elapsed;
    f990:	4414      	add	r4, r2
	if (delay) {
    f992:	1a22      	subs	r2, r4, r0
    f994:	d1de      	bne.n	f954 <publish_sent+0x18>
}
    f996:	bd70      	pop	{r4, r5, r6, pc}
    f998:	20001dc4 	.word	0x20001dc4
    f99c:	00029830 	.word	0x00029830
    f9a0:	00029908 	.word	0x00029908
    f9a4:	0002d95e 	.word	0x0002d95e

0000f9a8 <bt_mesh_model_elem>:
	return &dev_comp->elem[mod->elem_idx];
    f9a8:	4b03      	ldr	r3, [pc, #12]	; (f9b8 <bt_mesh_model_elem+0x10>)
    f9aa:	7900      	ldrb	r0, [r0, #4]
    f9ac:	681b      	ldr	r3, [r3, #0]
    f9ae:	68db      	ldr	r3, [r3, #12]
}
    f9b0:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    f9b4:	4770      	bx	lr
    f9b6:	bf00      	nop
    f9b8:	20000904 	.word	0x20000904

0000f9bc <bt_mesh_model_get>:
{
    f9bc:	b538      	push	{r3, r4, r5, lr}
    f9be:	4613      	mov	r3, r2
	if (elem_idx >= dev_comp->elem_count) {
    f9c0:	4a1b      	ldr	r2, [pc, #108]	; (fa30 <bt_mesh_model_get+0x74>)
    f9c2:	6812      	ldr	r2, [r2, #0]
{
    f9c4:	4604      	mov	r4, r0
	if (elem_idx >= dev_comp->elem_count) {
    f9c6:	6890      	ldr	r0, [r2, #8]
    f9c8:	4281      	cmp	r1, r0
{
    f9ca:	460d      	mov	r5, r1
	if (elem_idx >= dev_comp->elem_count) {
    f9cc:	d30b      	bcc.n	f9e6 <bt_mesh_model_get+0x2a>
    f9ce:	4a19      	ldr	r2, [pc, #100]	; (fa34 <bt_mesh_model_get+0x78>)
    f9d0:	4b19      	ldr	r3, [pc, #100]	; (fa38 <bt_mesh_model_get+0x7c>)
		BT_ERR("Invalid element index %u", elem_idx);
    f9d2:	481a      	ldr	r0, [pc, #104]	; (fa3c <bt_mesh_model_get+0x80>)
    f9d4:	1ad2      	subs	r2, r2, r3
    f9d6:	08d2      	lsrs	r2, r2, #3
    f9d8:	0192      	lsls	r2, r2, #6
    f9da:	f042 0201 	orr.w	r2, r2, #1
    f9de:	f014 fafe 	bl	23fde <log_1>
		return NULL;
    f9e2:	2000      	movs	r0, #0
}
    f9e4:	bd38      	pop	{r3, r4, r5, pc}
	elem = &dev_comp->elem[elem_idx];
    f9e6:	68d1      	ldr	r1, [r2, #12]
    f9e8:	eb01 1105 	add.w	r1, r1, r5, lsl #4
	if (vnd) {
    f9ec:	b184      	cbz	r4, fa10 <bt_mesh_model_get+0x54>
		if (mod_idx >= elem->vnd_model_count) {
    f9ee:	794a      	ldrb	r2, [r1, #5]
    f9f0:	429a      	cmp	r2, r3
    f9f2:	d809      	bhi.n	fa08 <bt_mesh_model_get+0x4c>
    f9f4:	4910      	ldr	r1, [pc, #64]	; (fa38 <bt_mesh_model_get+0x7c>)
    f9f6:	4a0f      	ldr	r2, [pc, #60]	; (fa34 <bt_mesh_model_get+0x78>)
			BT_ERR("Invalid vendor model index %u", mod_idx);
    f9f8:	4811      	ldr	r0, [pc, #68]	; (fa40 <bt_mesh_model_get+0x84>)
    f9fa:	1a52      	subs	r2, r2, r1
    f9fc:	08d2      	lsrs	r2, r2, #3
    f9fe:	0192      	lsls	r2, r2, #6
    fa00:	f042 0201 	orr.w	r2, r2, #1
    fa04:	4619      	mov	r1, r3
    fa06:	e7ea      	b.n	f9de <bt_mesh_model_get+0x22>
		return &elem->vnd_models[mod_idx];
    fa08:	68c8      	ldr	r0, [r1, #12]
		return &elem->models[mod_idx];
    fa0a:	eb00 1043 	add.w	r0, r0, r3, lsl #5
    fa0e:	e7e9      	b.n	f9e4 <bt_mesh_model_get+0x28>
		if (mod_idx >= elem->model_count) {
    fa10:	790a      	ldrb	r2, [r1, #4]
    fa12:	429a      	cmp	r2, r3
    fa14:	d809      	bhi.n	fa2a <bt_mesh_model_get+0x6e>
    fa16:	4908      	ldr	r1, [pc, #32]	; (fa38 <bt_mesh_model_get+0x7c>)
    fa18:	4a06      	ldr	r2, [pc, #24]	; (fa34 <bt_mesh_model_get+0x78>)
			BT_ERR("Invalid SIG model index %u", mod_idx);
    fa1a:	480a      	ldr	r0, [pc, #40]	; (fa44 <bt_mesh_model_get+0x88>)
    fa1c:	1a52      	subs	r2, r2, r1
    fa1e:	08d2      	lsrs	r2, r2, #3
    fa20:	0192      	lsls	r2, r2, #6
    fa22:	f042 0201 	orr.w	r2, r2, #1
    fa26:	4619      	mov	r1, r3
    fa28:	e7d9      	b.n	f9de <bt_mesh_model_get+0x22>
		return &elem->models[mod_idx];
    fa2a:	6888      	ldr	r0, [r1, #8]
    fa2c:	e7ed      	b.n	fa0a <bt_mesh_model_get+0x4e>
    fa2e:	bf00      	nop
    fa30:	20000904 	.word	0x20000904
    fa34:	00029908 	.word	0x00029908
    fa38:	00029830 	.word	0x00029830
    fa3c:	0002d98e 	.word	0x0002d98e
    fa40:	0002d9a7 	.word	0x0002d9a7
    fa44:	0002d9c5 	.word	0x0002d9c5

0000fa48 <bt_mesh_comp_register>:
{
    fa48:	b508      	push	{r3, lr}
	if (!comp->elem_count) {
    fa4a:	6883      	ldr	r3, [r0, #8]
    fa4c:	b13b      	cbz	r3, fa5e <bt_mesh_comp_register+0x16>
	dev_comp = comp;
    fa4e:	4b05      	ldr	r3, [pc, #20]	; (fa64 <bt_mesh_comp_register+0x1c>)
	bt_mesh_model_foreach(mod_init, NULL);
    fa50:	2100      	movs	r1, #0
	dev_comp = comp;
    fa52:	6018      	str	r0, [r3, #0]
	bt_mesh_model_foreach(mod_init, NULL);
    fa54:	4804      	ldr	r0, [pc, #16]	; (fa68 <bt_mesh_comp_register+0x20>)
    fa56:	f7ff ff13 	bl	f880 <bt_mesh_model_foreach>
	return 0;
    fa5a:	2000      	movs	r0, #0
}
    fa5c:	bd08      	pop	{r3, pc}
		return -EINVAL;
    fa5e:	f06f 0015 	mvn.w	r0, #21
    fa62:	e7fb      	b.n	fa5c <bt_mesh_comp_register+0x14>
    fa64:	20000904 	.word	0x20000904
    fa68:	0000f701 	.word	0x0000f701

0000fa6c <bt_mesh_comp_provision>:
	dev_primary_addr = addr;
    fa6c:	4b08      	ldr	r3, [pc, #32]	; (fa90 <bt_mesh_comp_provision+0x24>)
{
    fa6e:	b570      	push	{r4, r5, r6, lr}
	dev_primary_addr = addr;
    fa70:	8018      	strh	r0, [r3, #0]
	for (i = 0; i < dev_comp->elem_count; i++) {
    fa72:	4b08      	ldr	r3, [pc, #32]	; (fa94 <bt_mesh_comp_provision+0x28>)
    fa74:	6819      	ldr	r1, [r3, #0]
    fa76:	688c      	ldr	r4, [r1, #8]
    fa78:	2300      	movs	r3, #0
    fa7a:	18c2      	adds	r2, r0, r3
    fa7c:	42a3      	cmp	r3, r4
    fa7e:	b292      	uxth	r2, r2
    fa80:	d100      	bne.n	fa84 <bt_mesh_comp_provision+0x18>
}
    fa82:	bd70      	pop	{r4, r5, r6, pc}
		elem->addr = addr++;
    fa84:	011d      	lsls	r5, r3, #4
    fa86:	68ce      	ldr	r6, [r1, #12]
	for (i = 0; i < dev_comp->elem_count; i++) {
    fa88:	3301      	adds	r3, #1
		elem->addr = addr++;
    fa8a:	5372      	strh	r2, [r6, r5]
	for (i = 0; i < dev_comp->elem_count; i++) {
    fa8c:	e7f5      	b.n	fa7a <bt_mesh_comp_provision+0xe>
    fa8e:	bf00      	nop
    fa90:	20001f22 	.word	0x20001f22
    fa94:	20000904 	.word	0x20000904

0000fa98 <bt_mesh_comp_unprovision>:
	dev_primary_addr = BT_MESH_ADDR_UNASSIGNED;
    fa98:	4b02      	ldr	r3, [pc, #8]	; (faa4 <bt_mesh_comp_unprovision+0xc>)
	bt_mesh_model_foreach(mod_init, NULL);
    fa9a:	4803      	ldr	r0, [pc, #12]	; (faa8 <bt_mesh_comp_unprovision+0x10>)
	dev_primary_addr = BT_MESH_ADDR_UNASSIGNED;
    fa9c:	2100      	movs	r1, #0
    fa9e:	8019      	strh	r1, [r3, #0]
	bt_mesh_model_foreach(mod_init, NULL);
    faa0:	f7ff beee 	b.w	f880 <bt_mesh_model_foreach>
    faa4:	20001f22 	.word	0x20001f22
    faa8:	0000f701 	.word	0x0000f701

0000faac <bt_mesh_primary_addr>:
}
    faac:	4b01      	ldr	r3, [pc, #4]	; (fab4 <bt_mesh_primary_addr+0x8>)
    faae:	8818      	ldrh	r0, [r3, #0]
    fab0:	4770      	bx	lr
    fab2:	bf00      	nop
    fab4:	20001f22 	.word	0x20001f22

0000fab8 <bt_mesh_elem_find>:
	if (BT_MESH_ADDR_IS_UNICAST(addr)) {
    fab8:	4a25      	ldr	r2, [pc, #148]	; (fb50 <bt_mesh_elem_find+0x98>)
{
    faba:	b5f0      	push	{r4, r5, r6, r7, lr}
    fabc:	6817      	ldr	r7, [r2, #0]
	if (BT_MESH_ADDR_IS_UNICAST(addr)) {
    fabe:	b202      	sxth	r2, r0
    fac0:	2a00      	cmp	r2, #0
    fac2:	68bd      	ldr	r5, [r7, #8]
{
    fac4:	4603      	mov	r3, r0
	if (BT_MESH_ADDR_IS_UNICAST(addr)) {
    fac6:	dd3d      	ble.n	fb44 <bt_mesh_elem_find+0x8c>
		index = (addr - dev_comp->elem[0].addr);
    fac8:	68f8      	ldr	r0, [r7, #12]
    faca:	8802      	ldrh	r2, [r0, #0]
    facc:	1a9b      	subs	r3, r3, r2
		if (index < dev_comp->elem_count) {
    face:	b29b      	uxth	r3, r3
    fad0:	42ab      	cmp	r3, r5
    fad2:	d23b      	bcs.n	fb4c <bt_mesh_elem_find+0x94>
			return &dev_comp->elem[index];
    fad4:	eb00 1003 	add.w	r0, r0, r3, lsl #4
}
    fad8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		struct bt_mesh_elem *elem = &dev_comp->elem[index];
    fada:	68fa      	ldr	r2, [r7, #12]
    fadc:	eb02 1000 	add.w	r0, r2, r0, lsl #4
	for (i = 0; i < elem->model_count; i++) {
    fae0:	2100      	movs	r1, #0
    fae2:	f890 c004 	ldrb.w	ip, [r0, #4]
    fae6:	4561      	cmp	r1, ip
    fae8:	db06      	blt.n	faf8 <bt_mesh_elem_find+0x40>
	for (i = 0; i < elem->vnd_model_count; i++) {
    faea:	f890 c005 	ldrb.w	ip, [r0, #5]
    faee:	2100      	movs	r1, #0
    faf0:	4561      	cmp	r1, ip
    faf2:	db14      	blt.n	fb1e <bt_mesh_elem_find+0x66>
	for (index = 0; index < dev_comp->elem_count; index++) {
    faf4:	3601      	adds	r6, #1
    faf6:	e026      	b.n	fb46 <bt_mesh_elem_find+0x8e>
		model = &elem->models[i];
    faf8:	6882      	ldr	r2, [r0, #8]
    fafa:	eb02 1241 	add.w	r2, r2, r1, lsl #5
		if (mod->groups[i] == addr) {
    fafe:	8a14      	ldrh	r4, [r2, #16]
    fb00:	429c      	cmp	r4, r3
    fb02:	d00a      	beq.n	fb1a <bt_mesh_elem_find+0x62>
    fb04:	8a54      	ldrh	r4, [r2, #18]
    fb06:	429c      	cmp	r4, r3
    fb08:	d105      	bne.n	fb16 <bt_mesh_elem_find+0x5e>
	for (i = 0; i < ARRAY_SIZE(mod->groups); i++) {
    fb0a:	2401      	movs	r4, #1
			return &mod->groups[i];
    fb0c:	3408      	adds	r4, #8
    fb0e:	eb02 0244 	add.w	r2, r2, r4, lsl #1
		if (match) {
    fb12:	2a00      	cmp	r2, #0
    fb14:	d1e0      	bne.n	fad8 <bt_mesh_elem_find+0x20>
	for (i = 0; i < elem->model_count; i++) {
    fb16:	3101      	adds	r1, #1
    fb18:	e7e5      	b.n	fae6 <bt_mesh_elem_find+0x2e>
	for (i = 0; i < ARRAY_SIZE(mod->groups); i++) {
    fb1a:	2400      	movs	r4, #0
    fb1c:	e7f6      	b.n	fb0c <bt_mesh_elem_find+0x54>
		model = &elem->vnd_models[i];
    fb1e:	68c2      	ldr	r2, [r0, #12]
    fb20:	eb02 1241 	add.w	r2, r2, r1, lsl #5
		if (mod->groups[i] == addr) {
    fb24:	8a14      	ldrh	r4, [r2, #16]
    fb26:	429c      	cmp	r4, r3
    fb28:	d00a      	beq.n	fb40 <bt_mesh_elem_find+0x88>
    fb2a:	8a54      	ldrh	r4, [r2, #18]
    fb2c:	429c      	cmp	r4, r3
    fb2e:	d105      	bne.n	fb3c <bt_mesh_elem_find+0x84>
	for (i = 0; i < ARRAY_SIZE(mod->groups); i++) {
    fb30:	2401      	movs	r4, #1
			return &mod->groups[i];
    fb32:	3408      	adds	r4, #8
    fb34:	eb02 0244 	add.w	r2, r2, r4, lsl #1
		if (match) {
    fb38:	2a00      	cmp	r2, #0
    fb3a:	d1cd      	bne.n	fad8 <bt_mesh_elem_find+0x20>
	for (i = 0; i < elem->vnd_model_count; i++) {
    fb3c:	3101      	adds	r1, #1
    fb3e:	e7d7      	b.n	faf0 <bt_mesh_elem_find+0x38>
	for (i = 0; i < ARRAY_SIZE(mod->groups); i++) {
    fb40:	2400      	movs	r4, #0
    fb42:	e7f6      	b.n	fb32 <bt_mesh_elem_find+0x7a>
    fb44:	2600      	movs	r6, #0
	for (index = 0; index < dev_comp->elem_count; index++) {
    fb46:	b2b0      	uxth	r0, r6
    fb48:	42a8      	cmp	r0, r5
    fb4a:	d3c6      	bcc.n	fada <bt_mesh_elem_find+0x22>
			return NULL;
    fb4c:	2000      	movs	r0, #0
    fb4e:	e7c3      	b.n	fad8 <bt_mesh_elem_find+0x20>
    fb50:	20000904 	.word	0x20000904

0000fb54 <bt_mesh_elem_count>:
	return dev_comp->elem_count;
    fb54:	4b01      	ldr	r3, [pc, #4]	; (fb5c <bt_mesh_elem_count+0x8>)
    fb56:	681b      	ldr	r3, [r3, #0]
}
    fb58:	7a18      	ldrb	r0, [r3, #8]
    fb5a:	4770      	bx	lr
    fb5c:	20000904 	.word	0x20000904

0000fb60 <bt_mesh_model_recv>:
{
    fb60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	switch (buf->data[0] >> 6) {
    fb64:	680b      	ldr	r3, [r1, #0]
    fb66:	4d64      	ldr	r5, [pc, #400]	; (fcf8 <bt_mesh_model_recv+0x198>)
    fb68:	781b      	ldrb	r3, [r3, #0]
{
    fb6a:	460c      	mov	r4, r1
    fb6c:	4963      	ldr	r1, [pc, #396]	; (fcfc <bt_mesh_model_recv+0x19c>)
	switch (buf->data[0] >> 6) {
    fb6e:	099a      	lsrs	r2, r3, #6
    fb70:	1a6d      	subs	r5, r5, r1
    fb72:	2a02      	cmp	r2, #2
{
    fb74:	b085      	sub	sp, #20
    fb76:	4680      	mov	r8, r0
    fb78:	ea4f 05d5 	mov.w	r5, r5, lsr #3
	switch (buf->data[0] >> 6) {
    fb7c:	d024      	beq.n	fbc8 <bt_mesh_model_recv+0x68>
    fb7e:	2a03      	cmp	r2, #3
    fb80:	d02e      	beq.n	fbe0 <bt_mesh_model_recv+0x80>
		if (buf->data[0] == 0x7f) {
    fb82:	2b7f      	cmp	r3, #127	; 0x7f
    fb84:	d10e      	bne.n	fba4 <bt_mesh_model_recv+0x44>
			BT_ERR("Ignoring RFU OpCode");
    fb86:	01a9      	lsls	r1, r5, #6
    fb88:	485d      	ldr	r0, [pc, #372]	; (fd00 <bt_mesh_model_recv+0x1a0>)
    fb8a:	f041 0101 	orr.w	r1, r1, #1
			BT_ERR("Too short payload for 2-octet OpCode");
    fb8e:	f014 fa19 	bl	23fc4 <log_0>
		BT_WARN("Unable to decode OpCode");
    fb92:	01ad      	lsls	r5, r5, #6
    fb94:	485b      	ldr	r0, [pc, #364]	; (fd04 <bt_mesh_model_recv+0x1a4>)
    fb96:	f045 0102 	orr.w	r1, r5, #2
}
    fb9a:	b005      	add	sp, #20
    fb9c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		BT_WARN("Unable to decode OpCode");
    fba0:	f014 ba10 	b.w	23fc4 <log_0>
		*opcode = net_buf_simple_pull_u8(buf);
    fba4:	4620      	mov	r0, r4
    fba6:	f019 f8d6 	bl	28d56 <net_buf_simple_pull_u8>
		*opcode = net_buf_simple_pull_be16(buf);
    fbaa:	4607      	mov	r7, r0
			BT_ERR("Too short message for OpCode 0x%08x", opcode);
    fbac:	01ad      	lsls	r5, r5, #6
    fbae:	f045 0301 	orr.w	r3, r5, #1
	for (i = 0; i < dev_comp->elem_count; i++) {
    fbb2:	f04f 0a00 	mov.w	sl, #0
			BT_ERR("Too short message for OpCode 0x%08x", opcode);
    fbb6:	9301      	str	r3, [sp, #4]
	for (i = 0; i < dev_comp->elem_count; i++) {
    fbb8:	4b53      	ldr	r3, [pc, #332]	; (fd08 <bt_mesh_model_recv+0x1a8>)
    fbba:	681b      	ldr	r3, [r3, #0]
    fbbc:	689a      	ldr	r2, [r3, #8]
    fbbe:	4552      	cmp	r2, sl
    fbc0:	d820      	bhi.n	fc04 <bt_mesh_model_recv+0xa4>
}
    fbc2:	b005      	add	sp, #20
    fbc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (buf->len < 2) {
    fbc8:	88a3      	ldrh	r3, [r4, #4]
    fbca:	2b01      	cmp	r3, #1
    fbcc:	d804      	bhi.n	fbd8 <bt_mesh_model_recv+0x78>
			BT_ERR("Too short payload for 2-octet OpCode");
    fbce:	01a9      	lsls	r1, r5, #6
    fbd0:	484e      	ldr	r0, [pc, #312]	; (fd0c <bt_mesh_model_recv+0x1ac>)
    fbd2:	f041 0101 	orr.w	r1, r1, #1
    fbd6:	e7da      	b.n	fb8e <bt_mesh_model_recv+0x2e>
		*opcode = net_buf_simple_pull_be16(buf);
    fbd8:	4620      	mov	r0, r4
    fbda:	f019 f8cc 	bl	28d76 <net_buf_simple_pull_be16>
    fbde:	e7e4      	b.n	fbaa <bt_mesh_model_recv+0x4a>
		if (buf->len < 3) {
    fbe0:	88a3      	ldrh	r3, [r4, #4]
    fbe2:	2b02      	cmp	r3, #2
    fbe4:	d804      	bhi.n	fbf0 <bt_mesh_model_recv+0x90>
			BT_ERR("Too short payload for 3-octet OpCode");
    fbe6:	01a9      	lsls	r1, r5, #6
    fbe8:	4849      	ldr	r0, [pc, #292]	; (fd10 <bt_mesh_model_recv+0x1b0>)
    fbea:	f041 0101 	orr.w	r1, r1, #1
    fbee:	e7ce      	b.n	fb8e <bt_mesh_model_recv+0x2e>
		*opcode = net_buf_simple_pull_u8(buf) << 16;
    fbf0:	4620      	mov	r0, r4
    fbf2:	f019 f8b0 	bl	28d56 <net_buf_simple_pull_u8>
    fbf6:	4607      	mov	r7, r0
		*opcode |= net_buf_simple_pull_le16(buf);
    fbf8:	4620      	mov	r0, r4
    fbfa:	f019 f8b4 	bl	28d66 <net_buf_simple_pull_le16>
    fbfe:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
		return 0;
    fc02:	e7d3      	b.n	fbac <bt_mesh_model_recv+0x4c>
		struct bt_mesh_elem *elem = &dev_comp->elem[i];
    fc04:	f8d3 c00c 	ldr.w	ip, [r3, #12]
    fc08:	eb0c 130a 	add.w	r3, ip, sl, lsl #4
			models = elem->vnd_models;
    fc0c:	e9d3 2602 	ldrd	r2, r6, [r3, #8]
		if (BT_MESH_MODEL_OP_LEN(opcode) < 3) {
    fc10:	f5b7 3f80 	cmp.w	r7, #65536	; 0x10000
			count = elem->model_count;
    fc14:	bf36      	itet	cc
    fc16:	791b      	ldrbcc	r3, [r3, #4]
			count = elem->vnd_model_count;
    fc18:	795b      	ldrbcs	r3, [r3, #5]
			models = elem->models;
    fc1a:	4616      	movcc	r6, r2
	for (i = 0U; i < model_count; i++) {
    fc1c:	eb06 1243 	add.w	r2, r6, r3, lsl #5
    fc20:	42b2      	cmp	r2, r6
    fc22:	d102      	bne.n	fc2a <bt_mesh_model_recv+0xca>
	for (i = 0; i < dev_comp->elem_count; i++) {
    fc24:	f10a 0a01 	add.w	sl, sl, #1
    fc28:	e7c6      	b.n	fbb8 <bt_mesh_model_recv+0x58>
		for (op = (*model)->op; op->func; op++) {
    fc2a:	6975      	ldr	r5, [r6, #20]
    fc2c:	68a9      	ldr	r1, [r5, #8]
    fc2e:	b909      	cbnz	r1, fc34 <bt_mesh_model_recv+0xd4>
	for (i = 0U; i < model_count; i++) {
    fc30:	3620      	adds	r6, #32
    fc32:	e7f5      	b.n	fc20 <bt_mesh_model_recv+0xc0>
			if (op->opcode == opcode) {
    fc34:	6829      	ldr	r1, [r5, #0]
    fc36:	42b9      	cmp	r1, r7
    fc38:	d02a      	beq.n	fc90 <bt_mesh_model_recv+0x130>
		for (op = (*model)->op; op->func; op++) {
    fc3a:	350c      	adds	r5, #12
    fc3c:	e7f6      	b.n	fc2c <bt_mesh_model_recv+0xcc>
	} else if (BT_MESH_ADDR_IS_GROUP(dst) || BT_MESH_ADDR_IS_VIRTUAL(dst)) {
    fc3e:	f480 4200 	eor.w	r2, r0, #32768	; 0x8000
    fc42:	f5b2 4ffe 	cmp.w	r2, #32512	; 0x7f00
    fc46:	d807      	bhi.n	fc58 <bt_mesh_model_recv+0xf8>
		return bt_mesh_model_find_group(&mod, dst);
    fc48:	4601      	mov	r1, r0
    fc4a:	a803      	add	r0, sp, #12
    fc4c:	f017 fd86 	bl	2775c <bt_mesh_model_find_group>
    fc50:	3800      	subs	r0, #0
    fc52:	bf18      	it	ne
    fc54:	2001      	movne	r0, #1
    fc56:	e041      	b.n	fcdc <bt_mesh_model_recv+0x17c>
	return (mod->elem_idx == 0 && bt_mesh_fixed_group_match(dst));
    fc58:	7932      	ldrb	r2, [r6, #4]
    fc5a:	b922      	cbnz	r2, fc66 <bt_mesh_model_recv+0x106>
    fc5c:	f017 fd8e 	bl	2777c <bt_mesh_fixed_group_match>
    fc60:	f000 0001 	and.w	r0, r0, #1
    fc64:	e03a      	b.n	fcdc <bt_mesh_model_recv+0x17c>
    fc66:	2000      	movs	r0, #0
    fc68:	e7fa      	b.n	fc60 <bt_mesh_model_recv+0x100>
	state->offset = net_buf_simple_headroom(buf);
    fc6a:	4620      	mov	r0, r4
    fc6c:	f019 f897 	bl	28d9e <net_buf_simple_headroom>
		op->func(model, &rx->ctx, buf);
    fc70:	68ab      	ldr	r3, [r5, #8]
	state->len = buf->len;
    fc72:	f8b4 b004 	ldrh.w	fp, [r4, #4]
	state->offset = net_buf_simple_headroom(buf);
    fc76:	4681      	mov	r9, r0
    fc78:	4622      	mov	r2, r4
    fc7a:	4630      	mov	r0, r6
    fc7c:	f108 0104 	add.w	r1, r8, #4
    fc80:	4798      	blx	r3
	buf->data = buf->__buf + state->offset;
    fc82:	68a0      	ldr	r0, [r4, #8]
	buf->len = state->len;
    fc84:	f8a4 b004 	strh.w	fp, [r4, #4]
	buf->data = buf->__buf + state->offset;
    fc88:	fa10 f089 	uxtah	r0, r0, r9
    fc8c:	6020      	str	r0, [r4, #0]
	buf->len = state->len;
    fc8e:	e7c9      	b.n	fc24 <bt_mesh_model_recv+0xc4>
		if (!model_has_key(model, rx->ctx.app_idx)) {
    fc90:	f8b8 2006 	ldrh.w	r2, [r8, #6]
		if (mod->keys[i] == key ||
    fc94:	89b1      	ldrh	r1, [r6, #12]
    fc96:	428a      	cmp	r2, r1
    fc98:	d012      	beq.n	fcc0 <bt_mesh_model_recv+0x160>
    fc9a:	f64f 70fc 	movw	r0, #65532	; 0xfffc
    fc9e:	4281      	cmp	r1, r0
    fca0:	d103      	bne.n	fcaa <bt_mesh_model_recv+0x14a>
		     BT_MESH_IS_DEV_KEY(key))) {
    fca2:	1cd1      	adds	r1, r2, #3
		    (mod->keys[i] == BT_MESH_KEY_DEV_ANY &&
    fca4:	b289      	uxth	r1, r1
    fca6:	2901      	cmp	r1, #1
    fca8:	d90a      	bls.n	fcc0 <bt_mesh_model_recv+0x160>
		if (mod->keys[i] == key ||
    fcaa:	89f1      	ldrh	r1, [r6, #14]
    fcac:	4291      	cmp	r1, r2
    fcae:	d007      	beq.n	fcc0 <bt_mesh_model_recv+0x160>
    fcb0:	f64f 70fc 	movw	r0, #65532	; 0xfffc
    fcb4:	4281      	cmp	r1, r0
    fcb6:	d1b5      	bne.n	fc24 <bt_mesh_model_recv+0xc4>
		     BT_MESH_IS_DEV_KEY(key))) {
    fcb8:	3203      	adds	r2, #3
		    (mod->keys[i] == BT_MESH_KEY_DEV_ANY &&
    fcba:	b292      	uxth	r2, r2
    fcbc:	2a01      	cmp	r2, #1
    fcbe:	d8b1      	bhi.n	fc24 <bt_mesh_model_recv+0xc4>
	if (BT_MESH_ADDR_IS_UNICAST(dst)) {
    fcc0:	f9b8 200a 	ldrsh.w	r2, [r8, #10]
		if (!model_has_dst(model, rx->ctx.recv_dst)) {
    fcc4:	f8b8 000a 	ldrh.w	r0, [r8, #10]
    fcc8:	9603      	str	r6, [sp, #12]
	if (BT_MESH_ADDR_IS_UNICAST(dst)) {
    fcca:	2a00      	cmp	r2, #0
    fccc:	ddb7      	ble.n	fc3e <bt_mesh_model_recv+0xde>
		return (dev_comp->elem[mod->elem_idx].addr == dst);
    fcce:	7932      	ldrb	r2, [r6, #4]
    fcd0:	0112      	lsls	r2, r2, #4
    fcd2:	f83c 2002 	ldrh.w	r2, [ip, r2]
    fcd6:	1a13      	subs	r3, r2, r0
    fcd8:	4258      	negs	r0, r3
    fcda:	4158      	adcs	r0, r3
		if (!model_has_dst(model, rx->ctx.recv_dst)) {
    fcdc:	2800      	cmp	r0, #0
    fcde:	d0a1      	beq.n	fc24 <bt_mesh_model_recv+0xc4>
		if (buf->len < op->min_len) {
    fce0:	88a1      	ldrh	r1, [r4, #4]
    fce2:	686a      	ldr	r2, [r5, #4]
    fce4:	4291      	cmp	r1, r2
    fce6:	d2c0      	bcs.n	fc6a <bt_mesh_model_recv+0x10a>
			BT_ERR("Too short message for OpCode 0x%08x", opcode);
    fce8:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    fcec:	4809      	ldr	r0, [pc, #36]	; (fd14 <bt_mesh_model_recv+0x1b4>)
    fcee:	4639      	mov	r1, r7
    fcf0:	f014 f975 	bl	23fde <log_1>
			continue;
    fcf4:	e796      	b.n	fc24 <bt_mesh_model_recv+0xc4>
    fcf6:	bf00      	nop
    fcf8:	00029908 	.word	0x00029908
    fcfc:	00029830 	.word	0x00029830
    fd00:	0002d9e0 	.word	0x0002d9e0
    fd04:	0002da3e 	.word	0x0002da3e
    fd08:	20000904 	.word	0x20000904
    fd0c:	0002d9f4 	.word	0x0002d9f4
    fd10:	0002da19 	.word	0x0002da19
    fd14:	0002da56 	.word	0x0002da56

0000fd18 <bt_mesh_model_publish>:

	return model_send(model, &tx, false, msg, cb, cb_data);
}

int bt_mesh_model_publish(struct bt_mesh_model *model)
{
    fd18:	b570      	push	{r4, r5, r6, lr}
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
	struct bt_mesh_model_pub *pub = model->pub;
    fd1a:	6884      	ldr	r4, [r0, #8]
{
    fd1c:	b094      	sub	sp, #80	; 0x50
	struct bt_mesh_app_key *key;
	struct bt_mesh_msg_ctx ctx = {
		.send_rel = pub->send_rel,
    fd1e:	79e1      	ldrb	r1, [r4, #7]
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
    fd20:	ab0b      	add	r3, sp, #44	; 0x2c
    fd22:	f44f 1210 	mov.w	r2, #2359296	; 0x240000
    fd26:	e9cd 2303 	strd	r2, r3, [sp, #12]
		.send_rel = pub->send_rel,
    fd2a:	f3c1 1140 	ubfx	r1, r1, #5, #1
	struct bt_mesh_msg_ctx ctx = {
    fd2e:	aa05      	add	r2, sp, #20
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
    fd30:	9302      	str	r3, [sp, #8]
	struct bt_mesh_msg_ctx ctx = {
    fd32:	2300      	movs	r3, #0
	};
	struct bt_mesh_net_tx tx = {
    fd34:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
	struct bt_mesh_msg_ctx ctx = {
    fd38:	9307      	str	r3, [sp, #28]
    fd3a:	e9cd 3305 	strd	r3, r3, [sp, #20]
    fd3e:	f88d 101e 	strb.w	r1, [sp, #30]
	struct bt_mesh_net_tx tx = {
    fd42:	9308      	str	r3, [sp, #32]
{
    fd44:	4605      	mov	r5, r0
		.ctx = &ctx,
		.src = bt_mesh_model_elem(model)->addr,
    fd46:	f7ff fe2f 	bl	f9a8 <bt_mesh_model_elem>
	struct bt_mesh_net_tx tx = {
    fd4a:	8803      	ldrh	r3, [r0, #0]
    fd4c:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
		.xmit = bt_mesh_net_transmit_get(),
    fd50:	f002 fa58 	bl	12204 <bt_mesh_net_transmit_get>
	struct bt_mesh_net_tx tx = {
    fd54:	f88d 002a 	strb.w	r0, [sp, #42]	; 0x2a

	if (!pub) {
		return -ENOTSUP;
	}

	if (pub->addr == BT_MESH_ADDR_UNASSIGNED) {
    fd58:	88a3      	ldrh	r3, [r4, #4]
    fd5a:	b923      	cbnz	r3, fd66 <bt_mesh_model_publish+0x4e>
		return -EADDRNOTAVAIL;
    fd5c:	f06f 0530 	mvn.w	r5, #48	; 0x30
		publish_retransmit_end(err, pub);
		return err;
	}

	return 0;
}
    fd60:	4628      	mov	r0, r5
    fd62:	b014      	add	sp, #80	; 0x50
    fd64:	bd70      	pop	{r4, r5, r6, pc}
	key = bt_mesh_app_key_find(pub->key);
    fd66:	88e0      	ldrh	r0, [r4, #6]
    fd68:	f3c0 000b 	ubfx	r0, r0, #0, #12
    fd6c:	f7fe fd42 	bl	e7f4 <bt_mesh_app_key_find>
	if (!key) {
    fd70:	4606      	mov	r6, r0
    fd72:	2800      	cmp	r0, #0
    fd74:	d0f2      	beq.n	fd5c <bt_mesh_model_publish+0x44>
	if (pub->msg->len + 4 > BT_MESH_TX_SDU_MAX) {
    fd76:	6923      	ldr	r3, [r4, #16]
    fd78:	889b      	ldrh	r3, [r3, #4]
    fd7a:	3304      	adds	r3, #4
    fd7c:	2b24      	cmp	r3, #36	; 0x24
    fd7e:	dd0c      	ble.n	fd9a <bt_mesh_model_publish+0x82>
    fd80:	4b25      	ldr	r3, [pc, #148]	; (fe18 <bt_mesh_model_publish+0x100>)
    fd82:	4926      	ldr	r1, [pc, #152]	; (fe1c <bt_mesh_model_publish+0x104>)
		BT_ERR("Message does not fit maximum SDU size");
    fd84:	4826      	ldr	r0, [pc, #152]	; (fe20 <bt_mesh_model_publish+0x108>)
    fd86:	1ac9      	subs	r1, r1, r3
    fd88:	08c9      	lsrs	r1, r1, #3
    fd8a:	0189      	lsls	r1, r1, #6
    fd8c:	f041 0101 	orr.w	r1, r1, #1
    fd90:	f014 f918 	bl	23fc4 <log_0>
		return -EMSGSIZE;
    fd94:	f06f 0523 	mvn.w	r5, #35	; 0x23
    fd98:	e7e2      	b.n	fd60 <bt_mesh_model_publish+0x48>
	if (pub->count) {
    fd9a:	7ae3      	ldrb	r3, [r4, #11]
    fd9c:	f013 0fe0 	tst.w	r3, #224	; 0xe0
    fda0:	d003      	beq.n	fdaa <bt_mesh_model_publish+0x92>
		k_delayed_work_cancel(&pub->timer);
    fda2:	f104 0018 	add.w	r0, r4, #24
    fda6:	f012 ff6b 	bl	22c80 <k_delayed_work_cancel>
	net_buf_simple_add_mem(&sdu, pub->msg->data, pub->msg->len);
    fdaa:	6923      	ldr	r3, [r4, #16]
    fdac:	a802      	add	r0, sp, #8
    fdae:	6819      	ldr	r1, [r3, #0]
    fdb0:	889a      	ldrh	r2, [r3, #4]
    fdb2:	f019 f800 	bl	28db6 <net_buf_simple_add_mem>
	ctx.addr = pub->addr;
    fdb6:	88a3      	ldrh	r3, [r4, #4]
    fdb8:	f8ad 3018 	strh.w	r3, [sp, #24]
	ctx.send_ttl = pub->ttl;
    fdbc:	7a23      	ldrb	r3, [r4, #8]
    fdbe:	f88d 301f 	strb.w	r3, [sp, #31]
	ctx.app_idx = key->app_idx;
    fdc2:	8873      	ldrh	r3, [r6, #2]
	ctx.net_idx = key->net_idx;
    fdc4:	8830      	ldrh	r0, [r6, #0]
	ctx.app_idx = key->app_idx;
    fdc6:	f8ad 3016 	strh.w	r3, [sp, #22]
	tx.friend_cred = pub->cred;
    fdca:	79e3      	ldrb	r3, [r4, #7]
    fdcc:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
	ctx.net_idx = key->net_idx;
    fdd0:	f8ad 0014 	strh.w	r0, [sp, #20]
	tx.friend_cred = pub->cred;
    fdd4:	f3c3 1300 	ubfx	r3, r3, #4, #1
    fdd8:	f363 0200 	bfi	r2, r3, #0, #1
    fddc:	f88d 202b 	strb.w	r2, [sp, #43]	; 0x2b
	tx.sub = bt_mesh_subnet_get(ctx.net_idx),
    fde0:	f7fc fe04 	bl	c9ec <bt_mesh_subnet_get>
	pub->count = BT_MESH_PUB_TRANSMIT_COUNT(pub->retransmit);
    fde4:	7ae3      	ldrb	r3, [r4, #11]
    fde6:	7a62      	ldrb	r2, [r4, #9]
	tx.sub = bt_mesh_subnet_get(ctx.net_idx),
    fde8:	9008      	str	r0, [sp, #32]
	pub->count = BT_MESH_PUB_TRANSMIT_COUNT(pub->retransmit);
    fdea:	f362 1347 	bfi	r3, r2, #5, #3
    fdee:	72e3      	strb	r3, [r4, #11]
	err = model_send(model, &tx, true, &sdu, &pub_sent_cb, model);
    fdf0:	4b0c      	ldr	r3, [pc, #48]	; (fe24 <bt_mesh_model_publish+0x10c>)
    fdf2:	9501      	str	r5, [sp, #4]
    fdf4:	9300      	str	r3, [sp, #0]
    fdf6:	4628      	mov	r0, r5
    fdf8:	ab02      	add	r3, sp, #8
    fdfa:	2201      	movs	r2, #1
    fdfc:	a908      	add	r1, sp, #32
    fdfe:	f7ff fca9 	bl	f754 <model_send>
	if (err) {
    fe02:	4605      	mov	r5, r0
    fe04:	2800      	cmp	r0, #0
    fe06:	d0ab      	beq.n	fd60 <bt_mesh_model_publish+0x48>
	pub->count = 0U;
    fe08:	7ae3      	ldrb	r3, [r4, #11]
	publish_sent(err, pub->mod);
    fe0a:	6821      	ldr	r1, [r4, #0]
	pub->count = 0U;
    fe0c:	f36f 1347 	bfc	r3, #5, #3
    fe10:	72e3      	strb	r3, [r4, #11]
	publish_sent(err, pub->mod);
    fe12:	f7ff fd93 	bl	f93c <publish_sent>
}
    fe16:	e7a3      	b.n	fd60 <bt_mesh_model_publish+0x48>
    fe18:	00029830 	.word	0x00029830
    fe1c:	00029908 	.word	0x00029908
    fe20:	0002da7a 	.word	0x0002da7a
    fe24:	0002a0a4 	.word	0x0002a0a4

0000fe28 <mod_publish>:
{
    fe28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	period_ms = bt_mesh_model_pub_period_get(pub->mod);
    fe2c:	f850 8c18 	ldr.w	r8, [r0, #-24]
{
    fe30:	4604      	mov	r4, r0
    fe32:	b092      	sub	sp, #72	; 0x48
	period_ms = bt_mesh_model_pub_period_get(pub->mod);
    fe34:	4640      	mov	r0, r8
    fe36:	f7ff fd5d 	bl	f8f4 <bt_mesh_model_pub_period_get>
	if (pub->count) {
    fe3a:	f814 3c0d 	ldrb.w	r3, [r4, #-13]
    fe3e:	f013 0fe0 	tst.w	r3, #224	; 0xe0
	period_ms = bt_mesh_model_pub_period_get(pub->mod);
    fe42:	4607      	mov	r7, r0
	if (pub->count) {
    fe44:	d068      	beq.n	ff18 <mod_publish+0xf0>
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
    fe46:	ab09      	add	r3, sp, #36	; 0x24
    fe48:	f44f 1210 	mov.w	r2, #2359296	; 0x240000
    fe4c:	e9cd 2301 	strd	r2, r3, [sp, #4]
	struct bt_mesh_msg_ctx ctx = {
    fe50:	2200      	movs	r2, #0
	struct bt_mesh_model_pub *pub = mod->pub;
    fe52:	f8d8 5008 	ldr.w	r5, [r8, #8]
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
    fe56:	9300      	str	r3, [sp, #0]
	struct bt_mesh_msg_ctx ctx = {
    fe58:	e9cd 2203 	strd	r2, r2, [sp, #12]
    fe5c:	88a9      	ldrh	r1, [r5, #4]
    fe5e:	f8cd 2013 	str.w	r2, [sp, #19]
    fe62:	ab03      	add	r3, sp, #12
    fe64:	f8ad 1010 	strh.w	r1, [sp, #16]
		.src = bt_mesh_model_elem(mod)->addr,
    fe68:	4640      	mov	r0, r8
	struct bt_mesh_msg_ctx ctx = {
    fe6a:	7a29      	ldrb	r1, [r5, #8]
    fe6c:	f88d 1017 	strb.w	r1, [sp, #23]
	struct bt_mesh_net_tx tx = {
    fe70:	e9cd 3207 	strd	r3, r2, [sp, #28]
    fe74:	9206      	str	r2, [sp, #24]
		.src = bt_mesh_model_elem(mod)->addr,
    fe76:	f7ff fd97 	bl	f9a8 <bt_mesh_model_elem>
	struct bt_mesh_net_tx tx = {
    fe7a:	8803      	ldrh	r3, [r0, #0]
    fe7c:	f8ad 3020 	strh.w	r3, [sp, #32]
		.xmit = bt_mesh_net_transmit_get(),
    fe80:	f002 f9c0 	bl	12204 <bt_mesh_net_transmit_get>
	struct bt_mesh_net_tx tx = {
    fe84:	f88d 0022 	strb.w	r0, [sp, #34]	; 0x22
		.friend_cred = pub->cred,
    fe88:	79eb      	ldrb	r3, [r5, #7]
	struct bt_mesh_net_tx tx = {
    fe8a:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
	key = bt_mesh_app_key_find(pub->key);
    fe8e:	88e8      	ldrh	r0, [r5, #6]
		.friend_cred = pub->cred,
    fe90:	f3c3 1300 	ubfx	r3, r3, #4, #1
	struct bt_mesh_net_tx tx = {
    fe94:	f363 0200 	bfi	r2, r3, #0, #1
	key = bt_mesh_app_key_find(pub->key);
    fe98:	f3c0 000b 	ubfx	r0, r0, #0, #12
	struct bt_mesh_net_tx tx = {
    fe9c:	f88d 2023 	strb.w	r2, [sp, #35]	; 0x23
	key = bt_mesh_app_key_find(pub->key);
    fea0:	f7fe fca8 	bl	e7f4 <bt_mesh_app_key_find>
	if (!key) {
    fea4:	4606      	mov	r6, r0
    fea6:	b9c0      	cbnz	r0, feda <mod_publish+0xb2>
		return -EADDRNOTAVAIL;
    fea8:	f06f 0130 	mvn.w	r1, #48	; 0x30
    feac:	4b36      	ldr	r3, [pc, #216]	; (ff88 <mod_publish+0x160>)
    feae:	4a37      	ldr	r2, [pc, #220]	; (ff8c <mod_publish+0x164>)
			BT_ERR("Failed to retransmit (err %d)", err);
    feb0:	4837      	ldr	r0, [pc, #220]	; (ff90 <mod_publish+0x168>)
    feb2:	1ad2      	subs	r2, r2, r3
    feb4:	08d2      	lsrs	r2, r2, #3
    feb6:	0192      	lsls	r2, r2, #6
    feb8:	f042 0201 	orr.w	r2, r2, #1
    febc:	f014 f88f 	bl	23fde <log_1>
			pub->count = 0U;
    fec0:	f814 3c0d 	ldrb.w	r3, [r4, #-13]
    fec4:	f36f 1347 	bfc	r3, #5, #3
    fec8:	f804 3c0d 	strb.w	r3, [r4, #-13]
			if (period_ms) {
    fecc:	b30f      	cbz	r7, ff12 <mod_publish+0xea>
    fece:	463a      	mov	r2, r7
    fed0:	4621      	mov	r1, r4
    fed2:	4830      	ldr	r0, [pc, #192]	; (ff94 <mod_publish+0x16c>)
    fed4:	f012 fe44 	bl	22b60 <k_delayed_work_submit_to_queue>
    fed8:	e01b      	b.n	ff12 <mod_publish+0xea>
	tx.sub = bt_mesh_subnet_get(key->net_idx);
    feda:	8800      	ldrh	r0, [r0, #0]
    fedc:	f7fc fd86 	bl	c9ec <bt_mesh_subnet_get>
	ctx.net_idx = key->net_idx;
    fee0:	8833      	ldrh	r3, [r6, #0]
    fee2:	f8ad 300c 	strh.w	r3, [sp, #12]
	ctx.app_idx = key->app_idx;
    fee6:	8873      	ldrh	r3, [r6, #2]
    fee8:	f8ad 300e 	strh.w	r3, [sp, #14]
	net_buf_simple_add_mem(&sdu, pub->msg->data, pub->msg->len);
    feec:	692b      	ldr	r3, [r5, #16]
	tx.sub = bt_mesh_subnet_get(key->net_idx);
    feee:	9006      	str	r0, [sp, #24]
	net_buf_simple_add_mem(&sdu, pub->msg->data, pub->msg->len);
    fef0:	889a      	ldrh	r2, [r3, #4]
    fef2:	6819      	ldr	r1, [r3, #0]
    fef4:	4668      	mov	r0, sp
    fef6:	f018 ff5e 	bl	28db6 <net_buf_simple_add_mem>
	pub->count--;
    fefa:	7aeb      	ldrb	r3, [r5, #11]
	return bt_mesh_trans_send(&tx, &sdu, &pub_sent_cb, mod);
    fefc:	4a26      	ldr	r2, [pc, #152]	; (ff98 <mod_publish+0x170>)
	pub->count--;
    fefe:	33e0      	adds	r3, #224	; 0xe0
    ff00:	72eb      	strb	r3, [r5, #11]
	return bt_mesh_trans_send(&tx, &sdu, &pub_sent_cb, mod);
    ff02:	4669      	mov	r1, sp
    ff04:	4643      	mov	r3, r8
    ff06:	a806      	add	r0, sp, #24
    ff08:	f7ff f9fe 	bl	f308 <bt_mesh_trans_send>
		if (err) {
    ff0c:	4601      	mov	r1, r0
    ff0e:	2800      	cmp	r0, #0
    ff10:	d1cc      	bne.n	feac <mod_publish+0x84>
}
    ff12:	b012      	add	sp, #72	; 0x48
    ff14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!period_ms) {
    ff18:	2800      	cmp	r0, #0
    ff1a:	d0fa      	beq.n	ff12 <mod_publish+0xea>
	__ASSERT_NO_MSG(pub->update != NULL);
    ff1c:	f854 3c04 	ldr.w	r3, [r4, #-4]
    ff20:	b94b      	cbnz	r3, ff36 <mod_publish+0x10e>
    ff22:	491e      	ldr	r1, [pc, #120]	; (ff9c <mod_publish+0x174>)
    ff24:	481e      	ldr	r0, [pc, #120]	; (ffa0 <mod_publish+0x178>)
    ff26:	4a1f      	ldr	r2, [pc, #124]	; (ffa4 <mod_publish+0x17c>)
    ff28:	23e7      	movs	r3, #231	; 0xe7
    ff2a:	f013 ffda 	bl	23ee2 <printk>
    ff2e:	481d      	ldr	r0, [pc, #116]	; (ffa4 <mod_publish+0x17c>)
    ff30:	21e7      	movs	r1, #231	; 0xe7
    ff32:	f014 f819 	bl	23f68 <assert_post_action>
	err = pub->update(pub->mod);
    ff36:	f854 3c04 	ldr.w	r3, [r4, #-4]
    ff3a:	f854 0c18 	ldr.w	r0, [r4, #-24]
    ff3e:	4798      	blx	r3
	if (err) {
    ff40:	4605      	mov	r5, r0
    ff42:	b178      	cbz	r0, ff64 <mod_publish+0x13c>
		pub->period_start = k_uptime_get_32();
    ff44:	f017 fbfd 	bl	27742 <k_uptime_get_32>
	pub->count = 0U;
    ff48:	f814 3c0d 	ldrb.w	r3, [r4, #-13]
		pub->period_start = k_uptime_get_32();
    ff4c:	f844 0c0c 	str.w	r0, [r4, #-12]
	pub->count = 0U;
    ff50:	f36f 1347 	bfc	r3, #5, #3
	publish_sent(err, pub->mod);
    ff54:	f854 1c18 	ldr.w	r1, [r4, #-24]
	pub->count = 0U;
    ff58:	f804 3c0d 	strb.w	r3, [r4, #-13]
	publish_sent(err, pub->mod);
    ff5c:	4628      	mov	r0, r5
    ff5e:	f7ff fced 	bl	f93c <publish_sent>
}
    ff62:	e7d6      	b.n	ff12 <mod_publish+0xea>
	err = bt_mesh_model_publish(pub->mod);
    ff64:	f854 0c18 	ldr.w	r0, [r4, #-24]
    ff68:	f7ff fed6 	bl	fd18 <bt_mesh_model_publish>
	if (err) {
    ff6c:	4601      	mov	r1, r0
    ff6e:	2800      	cmp	r0, #0
    ff70:	d0cf      	beq.n	ff12 <mod_publish+0xea>
    ff72:	4b05      	ldr	r3, [pc, #20]	; (ff88 <mod_publish+0x160>)
    ff74:	4a05      	ldr	r2, [pc, #20]	; (ff8c <mod_publish+0x164>)
		BT_ERR("Publishing failed (err %d)", err);
    ff76:	480c      	ldr	r0, [pc, #48]	; (ffa8 <mod_publish+0x180>)
    ff78:	1ad2      	subs	r2, r2, r3
    ff7a:	08d2      	lsrs	r2, r2, #3
    ff7c:	0192      	lsls	r2, r2, #6
    ff7e:	f042 0201 	orr.w	r2, r2, #1
    ff82:	f014 f82c 	bl	23fde <log_1>
    ff86:	e7c4      	b.n	ff12 <mod_publish+0xea>
    ff88:	00029830 	.word	0x00029830
    ff8c:	00029908 	.word	0x00029908
    ff90:	0002daa0 	.word	0x0002daa0
    ff94:	20001dc4 	.word	0x20001dc4
    ff98:	0002a0a4 	.word	0x0002a0a4
    ff9c:	0002daf0 	.word	0x0002daf0
    ffa0:	0002a5e8 	.word	0x0002a5e8
    ffa4:	0002dabe 	.word	0x0002dabe
    ffa8:	0002db0b 	.word	0x0002db0b

0000ffac <bt_mesh_comp_get>:
}

const struct bt_mesh_comp *bt_mesh_comp_get(void)
{
	return dev_comp;
}
    ffac:	4b01      	ldr	r3, [pc, #4]	; (ffb4 <bt_mesh_comp_get+0x8>)
    ffae:	6818      	ldr	r0, [r3, #0]
    ffb0:	4770      	bx	lr
    ffb2:	bf00      	nop
    ffb4:	20000904 	.word	0x20000904

0000ffb8 <app_key_is_valid>:
	int i;

	for (i = 0; i < ARRAY_SIZE(bt_mesh.app_keys); i++) {
		struct bt_mesh_app_key *key = &bt_mesh.app_keys[i];

		if (key->net_idx != BT_MESH_KEY_UNUSED &&
    ffb8:	4b0d      	ldr	r3, [pc, #52]	; (fff0 <app_key_is_valid+0x38>)
    ffba:	f8b3 114c 	ldrh.w	r1, [r3, #332]	; 0x14c
    ffbe:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ffc2:	4291      	cmp	r1, r2
    ffc4:	461a      	mov	r2, r3
    ffc6:	d003      	beq.n	ffd0 <app_key_is_valid+0x18>
    ffc8:	f8b3 314e 	ldrh.w	r3, [r3, #334]	; 0x14e
    ffcc:	4283      	cmp	r3, r0
    ffce:	d00b      	beq.n	ffe8 <app_key_is_valid+0x30>
    ffd0:	f8b2 1174 	ldrh.w	r1, [r2, #372]	; 0x174
    ffd4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    ffd8:	4299      	cmp	r1, r3
    ffda:	d007      	beq.n	ffec <app_key_is_valid+0x34>
    ffdc:	f8b2 3176 	ldrh.w	r3, [r2, #374]	; 0x176
    ffe0:	1a1b      	subs	r3, r3, r0
    ffe2:	4258      	negs	r0, r3
    ffe4:	4158      	adcs	r0, r3
    ffe6:	4770      	bx	lr
		    key->app_idx == app_idx) {
			return true;
    ffe8:	2001      	movs	r0, #1
    ffea:	4770      	bx	lr
		}
	}

	return false;
    ffec:	2000      	movs	r0, #0
}
    ffee:	4770      	bx	lr
    fff0:	20006b48 	.word	0x20006b48

0000fff4 <_mod_pub_set>:

static u8_t _mod_pub_set(struct bt_mesh_model *model, u16_t pub_addr,
			 u16_t app_idx, u8_t cred_flag, u8_t ttl, u8_t period,
			 u8_t retransmit, bool store)
{
    fff4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    fff8:	4605      	mov	r5, r0
	if (!model->pub) {
    fffa:	6880      	ldr	r0, [r0, #8]
{
    fffc:	f89d 8024 	ldrb.w	r8, [sp, #36]	; 0x24
   10000:	f89d 702c 	ldrb.w	r7, [sp, #44]	; 0x2c
   10004:	4689      	mov	r9, r1
   10006:	4616      	mov	r6, r2
   10008:	461c      	mov	r4, r3
	if (!model->pub) {
   1000a:	2800      	cmp	r0, #0
   1000c:	d047      	beq.n	1009e <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x9f>
		return STATUS_NVAL_PUB_PARAM;
	}

	if (!IS_ENABLED(CONFIG_BT_MESH_LOW_POWER) && cred_flag) {
   1000e:	2b00      	cmp	r3, #0
   10010:	d143      	bne.n	1009a <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x9b>
		return STATUS_FEAT_NOT_SUPP;
	}

	if (!model->pub->update && period) {
   10012:	6941      	ldr	r1, [r0, #20]
   10014:	b911      	cbnz	r1, 1001c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x1d>
   10016:	f1b8 0f00 	cmp.w	r8, #0
   1001a:	d140      	bne.n	1009e <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x9f>
		return STATUS_NVAL_PUB_PARAM;
	}

	if (pub_addr == BT_MESH_ADDR_UNASSIGNED) {
   1001c:	f1b9 0f00 	cmp.w	r9, #0
   10020:	d114      	bne.n	1004c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x4d>
		if (model->pub->addr == BT_MESH_ADDR_UNASSIGNED) {
   10022:	8882      	ldrh	r2, [r0, #4]
   10024:	b17a      	cbz	r2, 10046 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x47>
			return STATUS_SUCCESS;
		}

		model->pub->addr = BT_MESH_ADDR_UNASSIGNED;
   10026:	6842      	ldr	r2, [r0, #4]
   10028:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
   1002c:	6042      	str	r2, [r0, #4]
		model->pub->key = 0U;
		model->pub->cred = 0U;
		model->pub->ttl = 0U;
   1002e:	6882      	ldr	r2, [r0, #8]
   10030:	f002 52f8 	and.w	r2, r2, #520093696	; 0x1f000000
   10034:	6082      	str	r2, [r0, #8]
		model->pub->period = 0U;
		model->pub->retransmit = 0U;
		model->pub->count = 0U;

		if (model->pub->update) {
   10036:	b111      	cbz	r1, 1003e <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x3f>
			k_delayed_work_cancel(&model->pub->timer);
   10038:	3018      	adds	r0, #24
   1003a:	f012 fe21 	bl	22c80 <k_delayed_work_cancel>
		}

		if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
   1003e:	b117      	cbz	r7, 10046 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x47>
			bt_mesh_store_mod_pub(model);
   10040:	4628      	mov	r0, r5
   10042:	f017 fe84 	bl	27d4e <bt_mesh_store_mod_pub>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
		bt_mesh_store_mod_pub(model);
	}

	return STATUS_SUCCESS;
}
   10046:	4620      	mov	r0, r4
   10048:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (!bt_mesh_app_key_find(app_idx)) {
   1004c:	4630      	mov	r0, r6
   1004e:	f7fe fbd1 	bl	e7f4 <bt_mesh_app_key_find>
   10052:	b330      	cbz	r0, 100a2 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xa3>
	model->pub->addr = pub_addr;
   10054:	68ab      	ldr	r3, [r5, #8]
	model->pub->ttl = ttl;
   10056:	f89d 2020 	ldrb.w	r2, [sp, #32]
	model->pub->key = app_idx;
   1005a:	88d9      	ldrh	r1, [r3, #6]
	model->pub->ttl = ttl;
   1005c:	721a      	strb	r2, [r3, #8]
	model->pub->key = app_idx;
   1005e:	f401 4160 	and.w	r1, r1, #57344	; 0xe000
   10062:	f3c6 060c 	ubfx	r6, r6, #0, #13
	model->pub->retransmit = retransmit;
   10066:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
	model->pub->addr = pub_addr;
   1006a:	f8a3 9004 	strh.w	r9, [r3, #4]
	model->pub->key = app_idx;
   1006e:	430e      	orrs	r6, r1
   10070:	80de      	strh	r6, [r3, #6]
	model->pub->period = period;
   10072:	f883 800a 	strb.w	r8, [r3, #10]
	model->pub->retransmit = retransmit;
   10076:	725a      	strb	r2, [r3, #9]
	if (model->pub->update) {
   10078:	695b      	ldr	r3, [r3, #20]
   1007a:	2b00      	cmp	r3, #0
   1007c:	d0df      	beq.n	1003e <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x3f>
		period_ms = bt_mesh_model_pub_period_get(model);
   1007e:	4628      	mov	r0, r5
   10080:	f7ff fc38 	bl	f8f4 <bt_mesh_model_pub_period_get>
		if (period_ms) {
   10084:	68a9      	ldr	r1, [r5, #8]
   10086:	4602      	mov	r2, r0
   10088:	b120      	cbz	r0, 10094 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x95>
   1008a:	3118      	adds	r1, #24
   1008c:	4806      	ldr	r0, [pc, #24]	; (100a8 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xa9>)
   1008e:	f012 fd67 	bl	22b60 <k_delayed_work_submit_to_queue>
   10092:	e7d4      	b.n	1003e <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x3f>
			k_delayed_work_cancel(&model->pub->timer);
   10094:	f101 0018 	add.w	r0, r1, #24
   10098:	e7cf      	b.n	1003a <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x3b>
		return STATUS_FEAT_NOT_SUPP;
   1009a:	240a      	movs	r4, #10
   1009c:	e7d3      	b.n	10046 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x47>
		return STATUS_NVAL_PUB_PARAM;
   1009e:	2407      	movs	r4, #7
   100a0:	e7d1      	b.n	10046 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x47>
		return STATUS_INVALID_APPKEY;
   100a2:	2403      	movs	r4, #3
   100a4:	e7cf      	b.n	10046 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x47>
   100a6:	bf00      	nop
   100a8:	20001dc4 	.word	0x20001dc4

000100ac <node_identity_get>:
}

static void node_identity_get(struct bt_mesh_model *model,
			      struct bt_mesh_msg_ctx *ctx,
			      struct net_buf_simple *buf)
{
   100ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   100ae:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_IDENTITY_STATUS, 4);
   100b0:	ab02      	add	r3, sp, #8
{
   100b2:	4606      	mov	r6, r0
   100b4:	460f      	mov	r7, r1

	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
	       ctx->net_idx, ctx->app_idx, ctx->addr, buf->len,
	       bt_hex(buf->data, buf->len));

	idx = net_buf_simple_pull_le16(buf);
   100b6:	4610      	mov	r0, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_IDENTITY_STATUS, 4);
   100b8:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
   100bc:	e9cd 1306 	strd	r1, r3, [sp, #24]
   100c0:	9305      	str	r3, [sp, #20]
	idx = net_buf_simple_pull_le16(buf);
   100c2:	f018 fe50 	bl	28d66 <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   100c6:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   100ca:	4605      	mov	r5, r0
	if (idx > 0xfff) {
   100cc:	d30c      	bcc.n	100e8 <node_identity_get+0x3c>
   100ce:	4a1f      	ldr	r2, [pc, #124]	; (1014c <node_identity_get+0xa0>)
   100d0:	4b1f      	ldr	r3, [pc, #124]	; (10150 <node_identity_get+0xa4>)
   100d2:	1ad2      	subs	r2, r2, r3
   100d4:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   100d6:	0192      	lsls	r2, r2, #6
   100d8:	4601      	mov	r1, r0
   100da:	f042 0201 	orr.w	r2, r2, #1
   100de:	481d      	ldr	r0, [pc, #116]	; (10154 <node_identity_get+0xa8>)
   100e0:	f013 ff7d 	bl	23fde <log_1>
	net_buf_simple_add_u8(&msg, node_id);

	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
		BT_ERR("Unable to send Node Identity Status");
	}
}
   100e4:	b009      	add	sp, #36	; 0x24
   100e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_mesh_model_msg_init(&msg, OP_NODE_IDENTITY_STATUS);
   100e8:	f248 0148 	movw	r1, #32840	; 0x8048
   100ec:	a805      	add	r0, sp, #20
   100ee:	f017 fb5f 	bl	277b0 <bt_mesh_model_msg_init>
	sub = bt_mesh_subnet_get(idx);
   100f2:	4628      	mov	r0, r5
   100f4:	f7fc fc7a 	bl	c9ec <bt_mesh_subnet_get>
	if (!sub) {
   100f8:	4604      	mov	r4, r0
   100fa:	b9f8      	cbnz	r0, 1013c <node_identity_get+0x90>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_NETKEY);
   100fc:	2104      	movs	r1, #4
   100fe:	a805      	add	r0, sp, #20
   10100:	f018 fe65 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, idx);
   10104:	4629      	mov	r1, r5
   10106:	a805      	add	r0, sp, #20
   10108:	f018 fe68 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_u8(&msg, node_id);
   1010c:	4621      	mov	r1, r4
   1010e:	a805      	add	r0, sp, #20
   10110:	f018 fe5d 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10114:	2300      	movs	r3, #0
   10116:	9300      	str	r3, [sp, #0]
   10118:	aa05      	add	r2, sp, #20
   1011a:	4639      	mov	r1, r7
   1011c:	4630      	mov	r0, r6
   1011e:	f017 fb70 	bl	27802 <bt_mesh_model_send>
   10122:	2800      	cmp	r0, #0
   10124:	d0de      	beq.n	100e4 <node_identity_get+0x38>
   10126:	4b0a      	ldr	r3, [pc, #40]	; (10150 <node_identity_get+0xa4>)
   10128:	4908      	ldr	r1, [pc, #32]	; (1014c <node_identity_get+0xa0>)
		BT_ERR("Unable to send Node Identity Status");
   1012a:	480b      	ldr	r0, [pc, #44]	; (10158 <node_identity_get+0xac>)
   1012c:	1ac9      	subs	r1, r1, r3
   1012e:	08c9      	lsrs	r1, r1, #3
   10130:	0189      	lsls	r1, r1, #6
   10132:	f041 0101 	orr.w	r1, r1, #1
   10136:	f013 ff45 	bl	23fc4 <log_0>
   1013a:	e7d3      	b.n	100e4 <node_identity_get+0x38>
		net_buf_simple_add_u8(&msg, STATUS_SUCCESS);
   1013c:	2100      	movs	r1, #0
   1013e:	a805      	add	r0, sp, #20
   10140:	f018 fe45 	bl	28dce <net_buf_simple_add_u8>
		node_id = sub->node_id;
   10144:	f894 4020 	ldrb.w	r4, [r4, #32]
   10148:	e7dc      	b.n	10104 <node_identity_get+0x58>
   1014a:	bf00      	nop
   1014c:	00029928 	.word	0x00029928
   10150:	00029830 	.word	0x00029830
   10154:	0002db35 	.word	0x0002db35
   10158:	0002db50 	.word	0x0002db50

0001015c <app_key_get>:
{
   1015c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1015e:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_LIST,
   10160:	ab02      	add	r3, sp, #8
{
   10162:	4605      	mov	r5, r0
   10164:	460e      	mov	r6, r1
	get_idx = net_buf_simple_pull_le16(buf);
   10166:	4610      	mov	r0, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_LIST,
   10168:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   1016c:	e9cd 1306 	strd	r1, r3, [sp, #24]
   10170:	9305      	str	r3, [sp, #20]
	get_idx = net_buf_simple_pull_le16(buf);
   10172:	f018 fdf8 	bl	28d66 <net_buf_simple_pull_le16>
	if (get_idx > 0xfff) {
   10176:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	get_idx = net_buf_simple_pull_le16(buf);
   1017a:	4604      	mov	r4, r0
	if (get_idx > 0xfff) {
   1017c:	d30c      	bcc.n	10198 <app_key_get+0x3c>
   1017e:	4a2a      	ldr	r2, [pc, #168]	; (10228 <app_key_get+0xcc>)
   10180:	4b2a      	ldr	r3, [pc, #168]	; (1022c <app_key_get+0xd0>)
   10182:	1ad2      	subs	r2, r2, r3
   10184:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Invalid NetKeyIndex 0x%04x", get_idx);
   10186:	0192      	lsls	r2, r2, #6
   10188:	4601      	mov	r1, r0
   1018a:	f042 0201 	orr.w	r2, r2, #1
   1018e:	4828      	ldr	r0, [pc, #160]	; (10230 <app_key_get+0xd4>)
   10190:	f013 ff25 	bl	23fde <log_1>
}
   10194:	b009      	add	sp, #36	; 0x24
   10196:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_mesh_model_msg_init(&msg, OP_APP_KEY_LIST);
   10198:	f248 0102 	movw	r1, #32770	; 0x8002
   1019c:	a805      	add	r0, sp, #20
   1019e:	f017 fb07 	bl	277b0 <bt_mesh_model_msg_init>
	if (!bt_mesh_subnet_get(get_idx)) {
   101a2:	4620      	mov	r0, r4
   101a4:	f7fc fc22 	bl	c9ec <bt_mesh_subnet_get>
		status = STATUS_SUCCESS;
   101a8:	2800      	cmp	r0, #0
   101aa:	bf0c      	ite	eq
   101ac:	2704      	moveq	r7, #4
   101ae:	2700      	movne	r7, #0
	net_buf_simple_add_u8(&msg, status);
   101b0:	4639      	mov	r1, r7
   101b2:	a805      	add	r0, sp, #20
   101b4:	f018 fe0b 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, get_idx);
   101b8:	4621      	mov	r1, r4
   101ba:	a805      	add	r0, sp, #20
   101bc:	f018 fe0e 	bl	28ddc <net_buf_simple_add_le16>
	if (status != STATUS_SUCCESS) {
   101c0:	b9af      	cbnz	r7, 101ee <app_key_get+0x92>
		if (key->net_idx != get_idx) {
   101c2:	4b1c      	ldr	r3, [pc, #112]	; (10234 <app_key_get+0xd8>)
   101c4:	f8b3 214c 	ldrh.w	r2, [r3, #332]	; 0x14c
   101c8:	42a2      	cmp	r2, r4
   101ca:	f8b3 2174 	ldrh.w	r2, [r3, #372]	; 0x174
			prev = key->app_idx;
   101ce:	bf0c      	ite	eq
   101d0:	f8b3 114e 	ldrheq.w	r1, [r3, #334]	; 0x14e
	prev = BT_MESH_KEY_UNUSED;
   101d4:	f64f 71ff 	movwne	r1, #65535	; 0xffff
		if (key->net_idx != get_idx) {
   101d8:	42a2      	cmp	r2, r4
   101da:	d11d      	bne.n	10218 <app_key_get+0xbc>
		if (prev == BT_MESH_KEY_UNUSED) {
   101dc:	f8b3 2176 	ldrh.w	r2, [r3, #374]	; 0x176
   101e0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   101e4:	4299      	cmp	r1, r3
   101e6:	d016      	beq.n	10216 <app_key_get+0xba>
		key_idx_pack(&msg, prev, key->app_idx);
   101e8:	a805      	add	r0, sp, #20
   101ea:	f017 fb5c 	bl	278a6 <key_idx_pack>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   101ee:	2300      	movs	r3, #0
   101f0:	9300      	str	r3, [sp, #0]
   101f2:	aa05      	add	r2, sp, #20
   101f4:	4631      	mov	r1, r6
   101f6:	4628      	mov	r0, r5
   101f8:	f017 fb03 	bl	27802 <bt_mesh_model_send>
   101fc:	2800      	cmp	r0, #0
   101fe:	d0c9      	beq.n	10194 <app_key_get+0x38>
   10200:	4b0a      	ldr	r3, [pc, #40]	; (1022c <app_key_get+0xd0>)
   10202:	4909      	ldr	r1, [pc, #36]	; (10228 <app_key_get+0xcc>)
		BT_ERR("Unable to send AppKey List");
   10204:	480c      	ldr	r0, [pc, #48]	; (10238 <app_key_get+0xdc>)
   10206:	1ac9      	subs	r1, r1, r3
   10208:	08c9      	lsrs	r1, r1, #3
   1020a:	0189      	lsls	r1, r1, #6
   1020c:	f041 0101 	orr.w	r1, r1, #1
   10210:	f013 fed8 	bl	23fc4 <log_0>
   10214:	e7be      	b.n	10194 <app_key_get+0x38>
			prev = key->app_idx;
   10216:	4611      	mov	r1, r2
	if (prev != BT_MESH_KEY_UNUSED) {
   10218:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1021c:	4299      	cmp	r1, r3
   1021e:	d0e6      	beq.n	101ee <app_key_get+0x92>
		net_buf_simple_add_le16(&msg, prev);
   10220:	a805      	add	r0, sp, #20
   10222:	f018 fddb 	bl	28ddc <net_buf_simple_add_le16>
   10226:	e7e2      	b.n	101ee <app_key_get+0x92>
   10228:	00029928 	.word	0x00029928
   1022c:	00029830 	.word	0x00029830
   10230:	0002db35 	.word	0x0002db35
   10234:	20006b48 	.word	0x20006b48
   10238:	0002db74 	.word	0x0002db74

0001023c <hb_pub_send_status>:
} __packed;

static void hb_pub_send_status(struct bt_mesh_model *model,
			       struct bt_mesh_msg_ctx *ctx, u8_t status,
			       struct hb_pub_param *orig_msg)
{
   1023c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10240:	b08a      	sub	sp, #40	; 0x28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_PUB_STATUS, 10);
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   10242:	69c4      	ldr	r4, [r0, #28]
{
   10244:	4690      	mov	r8, r2
   10246:	461f      	mov	r7, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_PUB_STATUS, 10);
   10248:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   1024c:	ab06      	add	r3, sp, #24
{
   1024e:	4605      	mov	r5, r0
   10250:	460e      	mov	r6, r1

	BT_DBG("src 0x%04x status 0x%02x", ctx->addr, status);

	bt_mesh_model_msg_init(&msg, OP_HEARTBEAT_PUB_STATUS);
   10252:	a803      	add	r0, sp, #12
   10254:	2106      	movs	r1, #6
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_PUB_STATUS, 10);
   10256:	e9cd 2304 	strd	r2, r3, [sp, #16]
   1025a:	9303      	str	r3, [sp, #12]
	bt_mesh_model_msg_init(&msg, OP_HEARTBEAT_PUB_STATUS);
   1025c:	f017 faa8 	bl	277b0 <bt_mesh_model_msg_init>

	net_buf_simple_add_u8(&msg, status);
   10260:	4641      	mov	r1, r8
   10262:	a803      	add	r0, sp, #12
   10264:	f018 fdb3 	bl	28dce <net_buf_simple_add_u8>

	if (orig_msg) {
   10268:	b1e7      	cbz	r7, 102a4 <hb_pub_send_status+0x68>
		memcpy(net_buf_simple_add(&msg, sizeof(*orig_msg)), orig_msg,
   1026a:	2109      	movs	r1, #9
   1026c:	a803      	add	r0, sp, #12
   1026e:	f00f f833 	bl	1f2d8 <net_buf_simple_add>
   10272:	2209      	movs	r2, #9
   10274:	4639      	mov	r1, r7
   10276:	f015 fd17 	bl	25ca8 <memcpy>
	net_buf_simple_add_u8(&msg, cfg->hb_pub.ttl);
	net_buf_simple_add_le16(&msg, cfg->hb_pub.feat);
	net_buf_simple_add_le16(&msg, cfg->hb_pub.net_idx);

send:
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   1027a:	2300      	movs	r3, #0
   1027c:	9300      	str	r3, [sp, #0]
   1027e:	aa03      	add	r2, sp, #12
   10280:	4631      	mov	r1, r6
   10282:	4628      	mov	r0, r5
   10284:	f017 fabd 	bl	27802 <bt_mesh_model_send>
   10288:	b148      	cbz	r0, 1029e <hb_pub_send_status+0x62>
   1028a:	491c      	ldr	r1, [pc, #112]	; (102fc <hb_pub_send_status+0xc0>)
   1028c:	4b1c      	ldr	r3, [pc, #112]	; (10300 <hb_pub_send_status+0xc4>)
		BT_ERR("Unable to send Heartbeat Publication Status");
   1028e:	481d      	ldr	r0, [pc, #116]	; (10304 <hb_pub_send_status+0xc8>)
   10290:	1ac9      	subs	r1, r1, r3
   10292:	08c9      	lsrs	r1, r1, #3
   10294:	0189      	lsls	r1, r1, #6
   10296:	f041 0101 	orr.w	r1, r1, #1
   1029a:	f013 fe93 	bl	23fc4 <log_0>
	}
}
   1029e:	b00a      	add	sp, #40	; 0x28
   102a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	net_buf_simple_add_le16(&msg, cfg->hb_pub.dst);
   102a4:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
   102a6:	a803      	add	r0, sp, #12
   102a8:	f018 fd98 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_u8(&msg, hb_pub_count_log(cfg->hb_pub.count));
   102ac:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
	if (!val) {
   102ae:	b171      	cbz	r1, 102ce <hb_pub_send_status+0x92>
	} else if (val == 0x01) {
   102b0:	2901      	cmp	r1, #1
   102b2:	d00c      	beq.n	102ce <hb_pub_send_status+0x92>
	} else if (val == 0xffff) {
   102b4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   102b8:	4299      	cmp	r1, r3
		return 32 - __builtin_clz(val - 1) + 1;
   102ba:	bf1f      	itttt	ne
   102bc:	f101 31ff 	addne.w	r1, r1, #4294967295	; 0xffffffff
   102c0:	fab1 f181 	clzne	r1, r1
   102c4:	f1c1 0121 	rsbne	r1, r1, #33	; 0x21
   102c8:	b2c9      	uxtbne	r1, r1
		return 0xff;
   102ca:	bf08      	it	eq
   102cc:	21ff      	moveq	r1, #255	; 0xff
	net_buf_simple_add_u8(&msg, hb_pub_count_log(cfg->hb_pub.count));
   102ce:	a803      	add	r0, sp, #12
   102d0:	f018 fd7d 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, cfg->hb_pub.period);
   102d4:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
   102d8:	a803      	add	r0, sp, #12
   102da:	f018 fd78 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, cfg->hb_pub.ttl);
   102de:	f894 1031 	ldrb.w	r1, [r4, #49]	; 0x31
   102e2:	a803      	add	r0, sp, #12
   102e4:	f018 fd73 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, cfg->hb_pub.feat);
   102e8:	8e61      	ldrh	r1, [r4, #50]	; 0x32
   102ea:	a803      	add	r0, sp, #12
   102ec:	f018 fd76 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, cfg->hb_pub.net_idx);
   102f0:	8ea1      	ldrh	r1, [r4, #52]	; 0x34
   102f2:	a803      	add	r0, sp, #12
   102f4:	f018 fd72 	bl	28ddc <net_buf_simple_add_le16>
   102f8:	e7bf      	b.n	1027a <hb_pub_send_status+0x3e>
   102fa:	bf00      	nop
   102fc:	00029928 	.word	0x00029928
   10300:	00029830 	.word	0x00029830
   10304:	0002db8f 	.word	0x0002db8f

00010308 <send_mod_sub_status>:
{
   10308:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1030c:	b08b      	sub	sp, #44	; 0x2c
   1030e:	4617      	mov	r7, r2
   10310:	461e      	mov	r6, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_SUB_STATUS, 9);
   10312:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   10316:	ab06      	add	r3, sp, #24
{
   10318:	4604      	mov	r4, r0
   1031a:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_MOD_SUB_STATUS);
   1031c:	a803      	add	r0, sp, #12
   1031e:	f248 011f 	movw	r1, #32799	; 0x801f
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_SUB_STATUS, 9);
   10322:	e9cd 2304 	strd	r2, r3, [sp, #16]
   10326:	9303      	str	r3, [sp, #12]
{
   10328:	f89d 9050 	ldrb.w	r9, [sp, #80]	; 0x50
   1032c:	f8dd 804c 	ldr.w	r8, [sp, #76]	; 0x4c
	bt_mesh_model_msg_init(&msg, OP_MOD_SUB_STATUS);
   10330:	f017 fa3e 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   10334:	4639      	mov	r1, r7
   10336:	a803      	add	r0, sp, #12
   10338:	f018 fd49 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, elem_addr);
   1033c:	4631      	mov	r1, r6
   1033e:	a803      	add	r0, sp, #12
   10340:	f018 fd4c 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, sub_addr);
   10344:	f8bd 1048 	ldrh.w	r1, [sp, #72]	; 0x48
   10348:	a803      	add	r0, sp, #12
   1034a:	f018 fd47 	bl	28ddc <net_buf_simple_add_le16>
	if (vnd) {
   1034e:	f1b9 0f00 	cmp.w	r9, #0
   10352:	d01c      	beq.n	1038e <send_mod_sub_status+0x86>
		memcpy(net_buf_simple_add(&msg, 4), mod_id, 4);
   10354:	2104      	movs	r1, #4
   10356:	a803      	add	r0, sp, #12
   10358:	f00e ffbe 	bl	1f2d8 <net_buf_simple_add>
   1035c:	2204      	movs	r2, #4
		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
   1035e:	4641      	mov	r1, r8
   10360:	f015 fca2 	bl	25ca8 <memcpy>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10364:	2300      	movs	r3, #0
   10366:	9300      	str	r3, [sp, #0]
   10368:	aa03      	add	r2, sp, #12
   1036a:	4629      	mov	r1, r5
   1036c:	4620      	mov	r0, r4
   1036e:	f017 fa48 	bl	27802 <bt_mesh_model_send>
   10372:	b148      	cbz	r0, 10388 <send_mod_sub_status+0x80>
   10374:	4909      	ldr	r1, [pc, #36]	; (1039c <send_mod_sub_status+0x94>)
   10376:	4b0a      	ldr	r3, [pc, #40]	; (103a0 <send_mod_sub_status+0x98>)
		BT_ERR("Unable to send Model Subscription Status");
   10378:	480a      	ldr	r0, [pc, #40]	; (103a4 <send_mod_sub_status+0x9c>)
   1037a:	1ac9      	subs	r1, r1, r3
   1037c:	08c9      	lsrs	r1, r1, #3
   1037e:	0189      	lsls	r1, r1, #6
   10380:	f041 0101 	orr.w	r1, r1, #1
   10384:	f013 fe1e 	bl	23fc4 <log_0>
}
   10388:	b00b      	add	sp, #44	; 0x2c
   1038a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
   1038e:	2102      	movs	r1, #2
   10390:	a803      	add	r0, sp, #12
   10392:	f00e ffa1 	bl	1f2d8 <net_buf_simple_add>
   10396:	2202      	movs	r2, #2
   10398:	e7e1      	b.n	1035e <send_mod_sub_status+0x56>
   1039a:	bf00      	nop
   1039c:	00029928 	.word	0x00029928
   103a0:	00029830 	.word	0x00029830
   103a4:	0002dbbb 	.word	0x0002dbbb

000103a8 <lpn_timeout_get>:
{
   103a8:	b570      	push	{r4, r5, r6, lr}
   103aa:	b088      	sub	sp, #32
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_LPN_TIMEOUT_STATUS, 5);
   103ac:	ab02      	add	r3, sp, #8
{
   103ae:	4605      	mov	r5, r0
   103b0:	460e      	mov	r6, r1
	lpn_addr = net_buf_simple_pull_le16(buf);
   103b2:	4610      	mov	r0, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_LPN_TIMEOUT_STATUS, 5);
   103b4:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   103b8:	e9cd 1306 	strd	r1, r3, [sp, #24]
   103bc:	9305      	str	r3, [sp, #20]
	lpn_addr = net_buf_simple_pull_le16(buf);
   103be:	f018 fcd2 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(lpn_addr)) {
   103c2:	b203      	sxth	r3, r0
   103c4:	2b00      	cmp	r3, #0
	lpn_addr = net_buf_simple_pull_le16(buf);
   103c6:	4604      	mov	r4, r0
	if (!BT_MESH_ADDR_IS_UNICAST(lpn_addr)) {
   103c8:	dc0b      	bgt.n	103e2 <lpn_timeout_get+0x3a>
   103ca:	4920      	ldr	r1, [pc, #128]	; (1044c <lpn_timeout_get+0xa4>)
   103cc:	4b20      	ldr	r3, [pc, #128]	; (10450 <lpn_timeout_get+0xa8>)
		BT_WARN("Invalid LPNAddress; ignoring msg");
   103ce:	4821      	ldr	r0, [pc, #132]	; (10454 <lpn_timeout_get+0xac>)
   103d0:	1ac9      	subs	r1, r1, r3
   103d2:	08c9      	lsrs	r1, r1, #3
   103d4:	0189      	lsls	r1, r1, #6
   103d6:	f041 0102 	orr.w	r1, r1, #2
		BT_ERR("Unable to send LPN PollTimeout Status");
   103da:	f013 fdf3 	bl	23fc4 <log_0>
}
   103de:	b008      	add	sp, #32
   103e0:	bd70      	pop	{r4, r5, r6, pc}
	bt_mesh_model_msg_init(&msg, OP_LPN_TIMEOUT_STATUS);
   103e2:	f248 012e 	movw	r1, #32814	; 0x802e
   103e6:	a805      	add	r0, sp, #20
   103e8:	f017 f9e2 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_le16(&msg, lpn_addr);
   103ec:	4621      	mov	r1, r4
   103ee:	a805      	add	r0, sp, #20
   103f0:	f018 fcf4 	bl	28ddc <net_buf_simple_add_le16>
	frnd = bt_mesh_friend_find(BT_MESH_KEY_ANY, lpn_addr, true, true);
   103f4:	2301      	movs	r3, #1
   103f6:	461a      	mov	r2, r3
   103f8:	4621      	mov	r1, r4
   103fa:	f64f 70ff 	movw	r0, #65535	; 0xffff
   103fe:	f004 fb3f 	bl	14a80 <bt_mesh_friend_find>
	if (!frnd) {
   10402:	b308      	cbz	r0, 10448 <lpn_timeout_get+0xa0>
	return k_ticks_to_ms_floor32(z_timeout_remaining(&work->timeout));
   10404:	3024      	adds	r0, #36	; 0x24
   10406:	f012 fdd7 	bl	22fb8 <z_timeout_remaining>
   1040a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1040e:	fba0 0103 	umull	r0, r1, r0, r3
   10412:	0bc3      	lsrs	r3, r0, #15
   10414:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
	timeout = k_delayed_work_remaining_get(&frnd->timer) / 100;
   10418:	2064      	movs	r0, #100	; 0x64
   1041a:	fbb3 f1f0 	udiv	r1, r3, r0
	net_buf_simple_add_le24(&msg, timeout);
   1041e:	a805      	add	r0, sp, #20
   10420:	f018 fcee 	bl	28e00 <net_buf_simple_add_le24>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10424:	2300      	movs	r3, #0
   10426:	9300      	str	r3, [sp, #0]
   10428:	aa05      	add	r2, sp, #20
   1042a:	4631      	mov	r1, r6
   1042c:	4628      	mov	r0, r5
   1042e:	f017 f9e8 	bl	27802 <bt_mesh_model_send>
   10432:	2800      	cmp	r0, #0
   10434:	d0d3      	beq.n	103de <lpn_timeout_get+0x36>
   10436:	4905      	ldr	r1, [pc, #20]	; (1044c <lpn_timeout_get+0xa4>)
   10438:	4b05      	ldr	r3, [pc, #20]	; (10450 <lpn_timeout_get+0xa8>)
		BT_ERR("Unable to send LPN PollTimeout Status");
   1043a:	4807      	ldr	r0, [pc, #28]	; (10458 <lpn_timeout_get+0xb0>)
   1043c:	1ac9      	subs	r1, r1, r3
   1043e:	08c9      	lsrs	r1, r1, #3
   10440:	0189      	lsls	r1, r1, #6
   10442:	f041 0101 	orr.w	r1, r1, #1
   10446:	e7c8      	b.n	103da <lpn_timeout_get+0x32>
		timeout = 0;
   10448:	4601      	mov	r1, r0
   1044a:	e7e8      	b.n	1041e <lpn_timeout_get+0x76>
   1044c:	00029928 	.word	0x00029928
   10450:	00029830 	.word	0x00029830
   10454:	0002dbe4 	.word	0x0002dbe4
   10458:	0002dc05 	.word	0x0002dc05

0001045c <node_reset>:
{
   1045c:	b530      	push	{r4, r5, lr}
   1045e:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_RESET_STATUS, 0);
   10460:	ab03      	add	r3, sp, #12
   10462:	f44f 22c0 	mov.w	r2, #393216	; 0x60000
{
   10466:	4604      	mov	r4, r0
   10468:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_NODE_RESET_STATUS);
   1046a:	a805      	add	r0, sp, #20
   1046c:	f248 014a 	movw	r1, #32842	; 0x804a
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_RESET_STATUS, 0);
   10470:	e9cd 2306 	strd	r2, r3, [sp, #24]
   10474:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_NODE_RESET_STATUS);
   10476:	f017 f99b 	bl	277b0 <bt_mesh_model_msg_init>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   1047a:	2300      	movs	r3, #0
   1047c:	9300      	str	r3, [sp, #0]
   1047e:	aa05      	add	r2, sp, #20
   10480:	4629      	mov	r1, r5
   10482:	4620      	mov	r0, r4
   10484:	f017 f9bd 	bl	27802 <bt_mesh_model_send>
   10488:	b148      	cbz	r0, 1049e <node_reset+0x42>
   1048a:	4907      	ldr	r1, [pc, #28]	; (104a8 <node_reset+0x4c>)
   1048c:	4b07      	ldr	r3, [pc, #28]	; (104ac <node_reset+0x50>)
		BT_ERR("Unable to send Node Reset Status");
   1048e:	4808      	ldr	r0, [pc, #32]	; (104b0 <node_reset+0x54>)
   10490:	1ac9      	subs	r1, r1, r3
   10492:	08c9      	lsrs	r1, r1, #3
   10494:	0189      	lsls	r1, r1, #6
   10496:	f041 0101 	orr.w	r1, r1, #1
   1049a:	f013 fd93 	bl	23fc4 <log_0>
	bt_mesh_reset();
   1049e:	f7fb fc4d 	bl	bd3c <bt_mesh_reset>
}
   104a2:	b009      	add	sp, #36	; 0x24
   104a4:	bd30      	pop	{r4, r5, pc}
   104a6:	bf00      	nop
   104a8:	00029928 	.word	0x00029928
   104ac:	00029830 	.word	0x00029830
   104b0:	0002dc2b 	.word	0x0002dc2b

000104b4 <node_identity_set>:
{
   104b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   104b8:	4615      	mov	r5, r2
   104ba:	b088      	sub	sp, #32
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_IDENTITY_STATUS, 4);
   104bc:	ab02      	add	r3, sp, #8
   104be:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
{
   104c2:	4607      	mov	r7, r0
	idx = net_buf_simple_pull_le16(buf);
   104c4:	4628      	mov	r0, r5
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_IDENTITY_STATUS, 4);
   104c6:	e9cd 2306 	strd	r2, r3, [sp, #24]
{
   104ca:	4688      	mov	r8, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_IDENTITY_STATUS, 4);
   104cc:	9305      	str	r3, [sp, #20]
	idx = net_buf_simple_pull_le16(buf);
   104ce:	f018 fc4a 	bl	28d66 <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   104d2:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   104d6:	4604      	mov	r4, r0
	if (idx > 0xfff) {
   104d8:	d30d      	bcc.n	104f6 <node_identity_set+0x42>
   104da:	4a2e      	ldr	r2, [pc, #184]	; (10594 <node_identity_set+0xe0>)
   104dc:	4b2e      	ldr	r3, [pc, #184]	; (10598 <node_identity_set+0xe4>)
   104de:	1ad2      	subs	r2, r2, r3
   104e0:	08d2      	lsrs	r2, r2, #3
		BT_WARN("Invalid NetKeyIndex 0x%04x", idx);
   104e2:	0192      	lsls	r2, r2, #6
   104e4:	4601      	mov	r1, r0
   104e6:	482d      	ldr	r0, [pc, #180]	; (1059c <node_identity_set+0xe8>)
   104e8:	f042 0202 	orr.w	r2, r2, #2
		BT_WARN("Invalid Node ID value 0x%02x", node_id);
   104ec:	f013 fd77 	bl	23fde <log_1>
}
   104f0:	b008      	add	sp, #32
   104f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	node_id = net_buf_simple_pull_u8(buf);
   104f6:	4628      	mov	r0, r5
   104f8:	f018 fc2d 	bl	28d56 <net_buf_simple_pull_u8>
	if (node_id != 0x00 && node_id != 0x01) {
   104fc:	2801      	cmp	r0, #1
	node_id = net_buf_simple_pull_u8(buf);
   104fe:	4606      	mov	r6, r0
	if (node_id != 0x00 && node_id != 0x01) {
   10500:	d909      	bls.n	10516 <node_identity_set+0x62>
   10502:	4a24      	ldr	r2, [pc, #144]	; (10594 <node_identity_set+0xe0>)
   10504:	4b24      	ldr	r3, [pc, #144]	; (10598 <node_identity_set+0xe4>)
   10506:	1ad2      	subs	r2, r2, r3
   10508:	08d2      	lsrs	r2, r2, #3
		BT_WARN("Invalid Node ID value 0x%02x", node_id);
   1050a:	0192      	lsls	r2, r2, #6
   1050c:	4601      	mov	r1, r0
   1050e:	f042 0202 	orr.w	r2, r2, #2
   10512:	4823      	ldr	r0, [pc, #140]	; (105a0 <node_identity_set+0xec>)
   10514:	e7ea      	b.n	104ec <node_identity_set+0x38>
	bt_mesh_model_msg_init(&msg, OP_NODE_IDENTITY_STATUS);
   10516:	f248 0148 	movw	r1, #32840	; 0x8048
   1051a:	a805      	add	r0, sp, #20
   1051c:	f017 f948 	bl	277b0 <bt_mesh_model_msg_init>
	sub = bt_mesh_subnet_get(idx);
   10520:	4620      	mov	r0, r4
   10522:	f7fc fa63 	bl	c9ec <bt_mesh_subnet_get>
	if (!sub) {
   10526:	4605      	mov	r5, r0
   10528:	b9f8      	cbnz	r0, 1056a <node_identity_set+0xb6>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_NETKEY);
   1052a:	2104      	movs	r1, #4
   1052c:	a805      	add	r0, sp, #20
   1052e:	f018 fc4e 	bl	28dce <net_buf_simple_add_u8>
		net_buf_simple_add_le16(&msg, idx);
   10532:	4621      	mov	r1, r4
   10534:	a805      	add	r0, sp, #20
   10536:	f018 fc51 	bl	28ddc <net_buf_simple_add_le16>
		net_buf_simple_add_u8(&msg, node_id);
   1053a:	4631      	mov	r1, r6
		net_buf_simple_add_u8(&msg, sub->node_id);
   1053c:	a805      	add	r0, sp, #20
   1053e:	f018 fc46 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10542:	2300      	movs	r3, #0
   10544:	9300      	str	r3, [sp, #0]
   10546:	aa05      	add	r2, sp, #20
   10548:	4641      	mov	r1, r8
   1054a:	4638      	mov	r0, r7
   1054c:	f017 f959 	bl	27802 <bt_mesh_model_send>
   10550:	2800      	cmp	r0, #0
   10552:	d0cd      	beq.n	104f0 <node_identity_set+0x3c>
   10554:	4b10      	ldr	r3, [pc, #64]	; (10598 <node_identity_set+0xe4>)
   10556:	490f      	ldr	r1, [pc, #60]	; (10594 <node_identity_set+0xe0>)
		BT_ERR("Unable to send Node Identity Status");
   10558:	4812      	ldr	r0, [pc, #72]	; (105a4 <node_identity_set+0xf0>)
   1055a:	1ac9      	subs	r1, r1, r3
   1055c:	08c9      	lsrs	r1, r1, #3
   1055e:	0189      	lsls	r1, r1, #6
   10560:	f041 0101 	orr.w	r1, r1, #1
   10564:	f013 fd2e 	bl	23fc4 <log_0>
   10568:	e7c2      	b.n	104f0 <node_identity_set+0x3c>
		net_buf_simple_add_u8(&msg, STATUS_SUCCESS);
   1056a:	2100      	movs	r1, #0
   1056c:	a805      	add	r0, sp, #20
   1056e:	f018 fc2e 	bl	28dce <net_buf_simple_add_u8>
		net_buf_simple_add_le16(&msg, idx);
   10572:	a805      	add	r0, sp, #20
   10574:	4621      	mov	r1, r4
   10576:	f018 fc31 	bl	28ddc <net_buf_simple_add_le16>
				bt_mesh_proxy_identity_start(sub);
   1057a:	4628      	mov	r0, r5
			if (node_id) {
   1057c:	b136      	cbz	r6, 1058c <node_identity_set+0xd8>
				bt_mesh_proxy_identity_start(sub);
   1057e:	f007 fa37 	bl	179f0 <bt_mesh_proxy_identity_start>
			bt_mesh_adv_update();
   10582:	f7fb fda1 	bl	c0c8 <bt_mesh_adv_update>
		net_buf_simple_add_u8(&msg, sub->node_id);
   10586:	f895 1020 	ldrb.w	r1, [r5, #32]
   1058a:	e7d7      	b.n	1053c <node_identity_set+0x88>
				bt_mesh_proxy_identity_stop(sub);
   1058c:	f017 fd30 	bl	27ff0 <bt_mesh_proxy_identity_stop>
   10590:	e7f7      	b.n	10582 <node_identity_set+0xce>
   10592:	bf00      	nop
   10594:	00029928 	.word	0x00029928
   10598:	00029830 	.word	0x00029830
   1059c:	0002db35 	.word	0x0002db35
   105a0:	0002dc4c 	.word	0x0002dc4c
   105a4:	0002db50 	.word	0x0002db50

000105a8 <mod_sub_get_vnd>:
{
   105a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   105ac:	4615      	mov	r5, r2
   105ae:	b08f      	sub	sp, #60	; 0x3c
	NET_BUF_SIMPLE_DEFINE(msg, BT_MESH_TX_SDU_MAX);
   105b0:	ab05      	add	r3, sp, #20
   105b2:	f44f 1210 	mov.w	r2, #2359296	; 0x240000
{
   105b6:	4607      	mov	r7, r0
	addr = net_buf_simple_pull_le16(buf);
   105b8:	4628      	mov	r0, r5
	NET_BUF_SIMPLE_DEFINE(msg, BT_MESH_TX_SDU_MAX);
   105ba:	e9cd 2303 	strd	r2, r3, [sp, #12]
   105be:	9302      	str	r3, [sp, #8]
{
   105c0:	4688      	mov	r8, r1
	addr = net_buf_simple_pull_le16(buf);
   105c2:	f018 fbd0 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(addr)) {
   105c6:	b203      	sxth	r3, r0
   105c8:	2b00      	cmp	r3, #0
	addr = net_buf_simple_pull_le16(buf);
   105ca:	4604      	mov	r4, r0
	if (!BT_MESH_ADDR_IS_UNICAST(addr)) {
   105cc:	dc0c      	bgt.n	105e8 <mod_sub_get_vnd+0x40>
   105ce:	4930      	ldr	r1, [pc, #192]	; (10690 <mod_sub_get_vnd+0xe8>)
   105d0:	4b30      	ldr	r3, [pc, #192]	; (10694 <mod_sub_get_vnd+0xec>)
		BT_WARN("Prohibited element address");
   105d2:	4831      	ldr	r0, [pc, #196]	; (10698 <mod_sub_get_vnd+0xf0>)
   105d4:	1ac9      	subs	r1, r1, r3
   105d6:	08c9      	lsrs	r1, r1, #3
   105d8:	0189      	lsls	r1, r1, #6
   105da:	f041 0102 	orr.w	r1, r1, #2
		BT_ERR("Unable to send Vendor Model Subscription List");
   105de:	f013 fcf1 	bl	23fc4 <log_0>
}
   105e2:	b00f      	add	sp, #60	; 0x3c
   105e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	company = net_buf_simple_pull_le16(buf);
   105e8:	4628      	mov	r0, r5
   105ea:	f018 fbbc 	bl	28d66 <net_buf_simple_pull_le16>
   105ee:	4606      	mov	r6, r0
	id = net_buf_simple_pull_le16(buf);
   105f0:	4628      	mov	r0, r5
   105f2:	f018 fbb8 	bl	28d66 <net_buf_simple_pull_le16>
	bt_mesh_model_msg_init(&msg, OP_MOD_SUB_LIST_VND);
   105f6:	f248 012c 	movw	r1, #32812	; 0x802c
	id = net_buf_simple_pull_le16(buf);
   105fa:	4605      	mov	r5, r0
	bt_mesh_model_msg_init(&msg, OP_MOD_SUB_LIST_VND);
   105fc:	a802      	add	r0, sp, #8
   105fe:	f017 f8d7 	bl	277b0 <bt_mesh_model_msg_init>
	elem = bt_mesh_elem_find(addr);
   10602:	4620      	mov	r0, r4
   10604:	f7ff fa58 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   10608:	bb08      	cbnz	r0, 1064e <mod_sub_get_vnd+0xa6>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_ADDRESS);
   1060a:	2101      	movs	r1, #1
		net_buf_simple_add_u8(&msg, STATUS_INVALID_MODEL);
   1060c:	a802      	add	r0, sp, #8
   1060e:	f018 fbde 	bl	28dce <net_buf_simple_add_u8>
		net_buf_simple_add_le16(&msg, addr);
   10612:	4621      	mov	r1, r4
   10614:	a802      	add	r0, sp, #8
   10616:	f018 fbe1 	bl	28ddc <net_buf_simple_add_le16>
		net_buf_simple_add_le16(&msg, company);
   1061a:	4631      	mov	r1, r6
   1061c:	a802      	add	r0, sp, #8
   1061e:	f018 fbdd 	bl	28ddc <net_buf_simple_add_le16>
		net_buf_simple_add_le16(&msg, id);
   10622:	4629      	mov	r1, r5
   10624:	a802      	add	r0, sp, #8
   10626:	f018 fbd9 	bl	28ddc <net_buf_simple_add_le16>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   1062a:	2300      	movs	r3, #0
   1062c:	9300      	str	r3, [sp, #0]
   1062e:	aa02      	add	r2, sp, #8
   10630:	4641      	mov	r1, r8
   10632:	4638      	mov	r0, r7
   10634:	f017 f8e5 	bl	27802 <bt_mesh_model_send>
   10638:	2800      	cmp	r0, #0
   1063a:	d0d2      	beq.n	105e2 <mod_sub_get_vnd+0x3a>
   1063c:	4914      	ldr	r1, [pc, #80]	; (10690 <mod_sub_get_vnd+0xe8>)
   1063e:	4b15      	ldr	r3, [pc, #84]	; (10694 <mod_sub_get_vnd+0xec>)
		BT_ERR("Unable to send Vendor Model Subscription List");
   10640:	4816      	ldr	r0, [pc, #88]	; (1069c <mod_sub_get_vnd+0xf4>)
   10642:	1ac9      	subs	r1, r1, r3
   10644:	08c9      	lsrs	r1, r1, #3
   10646:	0189      	lsls	r1, r1, #6
   10648:	f041 0101 	orr.w	r1, r1, #1
   1064c:	e7c7      	b.n	105de <mod_sub_get_vnd+0x36>
	mod = bt_mesh_model_find_vnd(elem, company, id);
   1064e:	462a      	mov	r2, r5
   10650:	4631      	mov	r1, r6
   10652:	f017 f8fc 	bl	2784e <bt_mesh_model_find_vnd>
	if (!mod) {
   10656:	4681      	mov	r9, r0
   10658:	b908      	cbnz	r0, 1065e <mod_sub_get_vnd+0xb6>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_MODEL);
   1065a:	2102      	movs	r1, #2
   1065c:	e7d6      	b.n	1060c <mod_sub_get_vnd+0x64>
	net_buf_simple_add_u8(&msg, STATUS_SUCCESS);
   1065e:	2100      	movs	r1, #0
   10660:	a802      	add	r0, sp, #8
   10662:	f018 fbb4 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, addr);
   10666:	4621      	mov	r1, r4
   10668:	a802      	add	r0, sp, #8
   1066a:	f018 fbb7 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, company);
   1066e:	4631      	mov	r1, r6
   10670:	a802      	add	r0, sp, #8
   10672:	f018 fbb3 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, id);
   10676:	4629      	mov	r1, r5
   10678:	a802      	add	r0, sp, #8
   1067a:	f018 fbaf 	bl	28ddc <net_buf_simple_add_le16>
	bt_mesh_model_tree_walk(bt_mesh_model_root(mod), mod_sub_list_visitor,
   1067e:	4648      	mov	r0, r9
   10680:	f017 f90d 	bl	2789e <bt_mesh_model_root>
   10684:	4906      	ldr	r1, [pc, #24]	; (106a0 <mod_sub_get_vnd+0xf8>)
   10686:	aa02      	add	r2, sp, #8
   10688:	f017 f90a 	bl	278a0 <bt_mesh_model_tree_walk>
   1068c:	e7cd      	b.n	1062a <mod_sub_get_vnd+0x82>
   1068e:	bf00      	nop
   10690:	00029928 	.word	0x00029928
   10694:	00029830 	.word	0x00029830
   10698:	0002dc69 	.word	0x0002dc69
   1069c:	0002dc84 	.word	0x0002dc84
   106a0:	00011565 	.word	0x00011565

000106a4 <mod_sub_get>:
{
   106a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   106a8:	4614      	mov	r4, r2
   106aa:	b091      	sub	sp, #68	; 0x44
	NET_BUF_SIMPLE_DEFINE(msg, BT_MESH_TX_SDU_MAX);
   106ac:	ab07      	add	r3, sp, #28
   106ae:	f44f 1210 	mov.w	r2, #2359296	; 0x240000
{
   106b2:	4680      	mov	r8, r0
	addr = net_buf_simple_pull_le16(buf);
   106b4:	4620      	mov	r0, r4
	NET_BUF_SIMPLE_DEFINE(msg, BT_MESH_TX_SDU_MAX);
   106b6:	e9cd 2305 	strd	r2, r3, [sp, #20]
   106ba:	9304      	str	r3, [sp, #16]
{
   106bc:	4689      	mov	r9, r1
	addr = net_buf_simple_pull_le16(buf);
   106be:	f018 fb52 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(addr)) {
   106c2:	b203      	sxth	r3, r0
   106c4:	2b00      	cmp	r3, #0
	addr = net_buf_simple_pull_le16(buf);
   106c6:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(addr)) {
   106c8:	dc0c      	bgt.n	106e4 <mod_sub_get+0x40>
   106ca:	492c      	ldr	r1, [pc, #176]	; (1077c <mod_sub_get+0xd8>)
   106cc:	4b2c      	ldr	r3, [pc, #176]	; (10780 <mod_sub_get+0xdc>)
		BT_WARN("Prohibited element address");
   106ce:	482d      	ldr	r0, [pc, #180]	; (10784 <mod_sub_get+0xe0>)
   106d0:	1ac9      	subs	r1, r1, r3
   106d2:	08c9      	lsrs	r1, r1, #3
   106d4:	0189      	lsls	r1, r1, #6
   106d6:	f041 0102 	orr.w	r1, r1, #2
		BT_ERR("Unable to send Model Subscription List");
   106da:	f013 fc73 	bl	23fc4 <log_0>
}
   106de:	b011      	add	sp, #68	; 0x44
   106e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	id = net_buf_simple_pull_le16(buf);
   106e4:	4620      	mov	r0, r4
   106e6:	f018 fb3e 	bl	28d66 <net_buf_simple_pull_le16>
	bt_mesh_model_msg_init(&msg, OP_MOD_SUB_LIST);
   106ea:	ac04      	add	r4, sp, #16
	id = net_buf_simple_pull_le16(buf);
   106ec:	4606      	mov	r6, r0
	bt_mesh_model_msg_init(&msg, OP_MOD_SUB_LIST);
   106ee:	f248 012a 	movw	r1, #32810	; 0x802a
   106f2:	4620      	mov	r0, r4
   106f4:	f017 f85c 	bl	277b0 <bt_mesh_model_msg_init>
	elem = bt_mesh_elem_find(addr);
   106f8:	4628      	mov	r0, r5
   106fa:	f7ff f9dd 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   106fe:	b9e8      	cbnz	r0, 1073c <mod_sub_get+0x98>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_ADDRESS);
   10700:	2101      	movs	r1, #1
		net_buf_simple_add_u8(&msg, STATUS_INVALID_MODEL);
   10702:	4620      	mov	r0, r4
   10704:	f018 fb63 	bl	28dce <net_buf_simple_add_u8>
		net_buf_simple_add_le16(&msg, addr);
   10708:	4629      	mov	r1, r5
   1070a:	4620      	mov	r0, r4
   1070c:	f018 fb66 	bl	28ddc <net_buf_simple_add_le16>
		net_buf_simple_add_le16(&msg, id);
   10710:	4631      	mov	r1, r6
   10712:	4620      	mov	r0, r4
   10714:	f018 fb62 	bl	28ddc <net_buf_simple_add_le16>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10718:	2300      	movs	r3, #0
   1071a:	9300      	str	r3, [sp, #0]
   1071c:	4622      	mov	r2, r4
   1071e:	4649      	mov	r1, r9
   10720:	4640      	mov	r0, r8
   10722:	f017 f86e 	bl	27802 <bt_mesh_model_send>
   10726:	2800      	cmp	r0, #0
   10728:	d0d9      	beq.n	106de <mod_sub_get+0x3a>
   1072a:	4914      	ldr	r1, [pc, #80]	; (1077c <mod_sub_get+0xd8>)
   1072c:	4b14      	ldr	r3, [pc, #80]	; (10780 <mod_sub_get+0xdc>)
		BT_ERR("Unable to send Model Subscription List");
   1072e:	4816      	ldr	r0, [pc, #88]	; (10788 <mod_sub_get+0xe4>)
   10730:	1ac9      	subs	r1, r1, r3
   10732:	08c9      	lsrs	r1, r1, #3
   10734:	0189      	lsls	r1, r1, #6
   10736:	f041 0101 	orr.w	r1, r1, #1
   1073a:	e7ce      	b.n	106da <mod_sub_get+0x36>
	mod = bt_mesh_model_find(elem, id);
   1073c:	4631      	mov	r1, r6
   1073e:	f017 f89b 	bl	27878 <bt_mesh_model_find>
	if (!mod) {
   10742:	4607      	mov	r7, r0
   10744:	b908      	cbnz	r0, 1074a <mod_sub_get+0xa6>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_MODEL);
   10746:	2102      	movs	r1, #2
   10748:	e7db      	b.n	10702 <mod_sub_get+0x5e>
	net_buf_simple_add_u8(&msg, STATUS_SUCCESS);
   1074a:	2100      	movs	r1, #0
   1074c:	4620      	mov	r0, r4
   1074e:	f018 fb3e 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, addr);
   10752:	4629      	mov	r1, r5
   10754:	4620      	mov	r0, r4
   10756:	f018 fb41 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, id);
   1075a:	4631      	mov	r1, r6
   1075c:	4620      	mov	r0, r4
   1075e:	f018 fb3d 	bl	28ddc <net_buf_simple_add_le16>
	visit_ctx.msg = &msg;
   10762:	9403      	str	r4, [sp, #12]
	visit_ctx.elem_idx = mod->elem_idx;
   10764:	793b      	ldrb	r3, [r7, #4]
   10766:	f8ad 3008 	strh.w	r3, [sp, #8]
	bt_mesh_model_tree_walk(bt_mesh_model_root(mod), mod_sub_list_visitor,
   1076a:	4638      	mov	r0, r7
   1076c:	f017 f897 	bl	2789e <bt_mesh_model_root>
   10770:	4906      	ldr	r1, [pc, #24]	; (1078c <mod_sub_get+0xe8>)
   10772:	aa02      	add	r2, sp, #8
   10774:	f017 f894 	bl	278a0 <bt_mesh_model_tree_walk>
   10778:	e7ce      	b.n	10718 <mod_sub_get+0x74>
   1077a:	bf00      	nop
   1077c:	00029928 	.word	0x00029928
   10780:	00029830 	.word	0x00029830
   10784:	0002dc69 	.word	0x0002dc69
   10788:	0002dcb2 	.word	0x0002dcb2
   1078c:	00011565 	.word	0x00011565

00010790 <cfg_srv_init>:

	return true;
}

static int cfg_srv_init(struct bt_mesh_model *model)
{
   10790:	b570      	push	{r4, r5, r6, lr}
	struct bt_mesh_cfg_srv *cfg = model->user_data;

	if (!bt_mesh_model_in_primary(model)) {
   10792:	7905      	ldrb	r5, [r0, #4]
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   10794:	69c4      	ldr	r4, [r0, #28]
{
   10796:	4606      	mov	r6, r0
	if (!bt_mesh_model_in_primary(model)) {
   10798:	b165      	cbz	r5, 107b4 <cfg_srv_init+0x24>
   1079a:	491f      	ldr	r1, [pc, #124]	; (10818 <cfg_srv_init+0x88>)
   1079c:	4b1f      	ldr	r3, [pc, #124]	; (1081c <cfg_srv_init+0x8c>)
		BT_ERR("Configuration Server only allowed in primary element");
   1079e:	4820      	ldr	r0, [pc, #128]	; (10820 <cfg_srv_init+0x90>)
   107a0:	1ac9      	subs	r1, r1, r3
   107a2:	08c9      	lsrs	r1, r1, #3
   107a4:	0189      	lsls	r1, r1, #6
   107a6:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("No Configuration Server context provided");
		return -EINVAL;
	}

	if (!conf_is_valid(cfg)) {
		BT_ERR("Invalid values in configuration");
   107aa:	f013 fc0b 	bl	23fc4 <log_0>
		return -EINVAL;
   107ae:	f06f 0015 	mvn.w	r0, #21
   107b2:	e026      	b.n	10802 <cfg_srv_init+0x72>
	if (!cfg) {
   107b4:	b944      	cbnz	r4, 107c8 <cfg_srv_init+0x38>
   107b6:	4918      	ldr	r1, [pc, #96]	; (10818 <cfg_srv_init+0x88>)
   107b8:	4b18      	ldr	r3, [pc, #96]	; (1081c <cfg_srv_init+0x8c>)
		BT_ERR("No Configuration Server context provided");
   107ba:	481a      	ldr	r0, [pc, #104]	; (10824 <cfg_srv_init+0x94>)
   107bc:	1ac9      	subs	r1, r1, r3
   107be:	08c9      	lsrs	r1, r1, #3
   107c0:	0189      	lsls	r1, r1, #6
   107c2:	f041 0101 	orr.w	r1, r1, #1
   107c6:	e7f0      	b.n	107aa <cfg_srv_init+0x1a>
	if (cfg->relay > 0x02) {
   107c8:	7963      	ldrb	r3, [r4, #5]
   107ca:	2b02      	cmp	r3, #2
   107cc:	d81a      	bhi.n	10804 <cfg_srv_init+0x74>
	if (cfg->beacon > 0x01) {
   107ce:	79e3      	ldrb	r3, [r4, #7]
   107d0:	2b01      	cmp	r3, #1
   107d2:	d817      	bhi.n	10804 <cfg_srv_init+0x74>
	if (cfg->default_ttl > BT_MESH_TTL_MAX) {
   107d4:	f994 300a 	ldrsb.w	r3, [r4, #10]
   107d8:	2b00      	cmp	r3, #0
   107da:	db13      	blt.n	10804 <cfg_srv_init+0x74>

	/*
	 * Configuration Model security is device-key based and only the local
	 * device-key is allowed to access this model.
	 */
	model->keys[0] = BT_MESH_KEY_DEV_LOCAL;
   107dc:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   107e0:	8183      	strh	r3, [r0, #12]

	if (!IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY)) {
		cfg->gatt_proxy = BT_MESH_GATT_PROXY_NOT_SUPPORTED;
	}

	k_delayed_work_init(&cfg->hb_pub.timer, hb_publish);
   107e2:	4911      	ldr	r1, [pc, #68]	; (10828 <cfg_srv_init+0x98>)
   107e4:	f104 000c 	add.w	r0, r4, #12
   107e8:	f018 fe07 	bl	293fa <k_delayed_work_init>
	cfg->hb_pub.net_idx = BT_MESH_KEY_UNUSED;
   107ec:	f64f 73ff 	movw	r3, #65535	; 0xffff
   107f0:	86a3      	strh	r3, [r4, #52]	; 0x34
	cfg->hb_sub.expiry = 0;
   107f2:	2200      	movs	r2, #0
   107f4:	2300      	movs	r3, #0
   107f6:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38

	cfg->model = model;

	conf = cfg;
   107fa:	4b0c      	ldr	r3, [pc, #48]	; (1082c <cfg_srv_init+0x9c>)
	cfg->model = model;
   107fc:	6026      	str	r6, [r4, #0]
	conf = cfg;
   107fe:	601c      	str	r4, [r3, #0]

	return 0;
   10800:	4628      	mov	r0, r5
}
   10802:	bd70      	pop	{r4, r5, r6, pc}
   10804:	4904      	ldr	r1, [pc, #16]	; (10818 <cfg_srv_init+0x88>)
   10806:	4b05      	ldr	r3, [pc, #20]	; (1081c <cfg_srv_init+0x8c>)
		BT_ERR("Invalid values in configuration");
   10808:	4809      	ldr	r0, [pc, #36]	; (10830 <cfg_srv_init+0xa0>)
   1080a:	1ac9      	subs	r1, r1, r3
   1080c:	08c9      	lsrs	r1, r1, #3
   1080e:	0189      	lsls	r1, r1, #6
   10810:	f041 0101 	orr.w	r1, r1, #1
   10814:	e7c9      	b.n	107aa <cfg_srv_init+0x1a>
   10816:	bf00      	nop
   10818:	00029928 	.word	0x00029928
   1081c:	00029830 	.word	0x00029830
   10820:	0002dcd9 	.word	0x0002dcd9
   10824:	0002dd0e 	.word	0x0002dd0e
   10828:	00011b59 	.word	0x00011b59
   1082c:	20000908 	.word	0x20000908
   10830:	0002dd37 	.word	0x0002dd37

00010834 <send_krp_status>:
{
   10834:	b5f0      	push	{r4, r5, r6, r7, lr}
   10836:	b089      	sub	sp, #36	; 0x24
   10838:	4604      	mov	r4, r0
   1083a:	460d      	mov	r5, r1
   1083c:	4617      	mov	r7, r2
   1083e:	461e      	mov	r6, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_KRP_STATUS, 4);
   10840:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
   10844:	ab02      	add	r3, sp, #8
	bt_mesh_model_msg_init(&msg, OP_KRP_STATUS);
   10846:	f248 0117 	movw	r1, #32791	; 0x8017
   1084a:	a805      	add	r0, sp, #20
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_KRP_STATUS, 4);
   1084c:	e9cd 2306 	strd	r2, r3, [sp, #24]
   10850:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_KRP_STATUS);
   10852:	f016 ffad 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   10856:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38
   1085a:	a805      	add	r0, sp, #20
   1085c:	f018 fab7 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, idx);
   10860:	4639      	mov	r1, r7
   10862:	a805      	add	r0, sp, #20
   10864:	f018 faba 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_u8(&msg, phase);
   10868:	4631      	mov	r1, r6
   1086a:	a805      	add	r0, sp, #20
   1086c:	f018 faaf 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10870:	2300      	movs	r3, #0
   10872:	9300      	str	r3, [sp, #0]
   10874:	aa05      	add	r2, sp, #20
   10876:	4629      	mov	r1, r5
   10878:	4620      	mov	r0, r4
   1087a:	f016 ffc2 	bl	27802 <bt_mesh_model_send>
   1087e:	b148      	cbz	r0, 10894 <send_krp_status+0x60>
   10880:	4905      	ldr	r1, [pc, #20]	; (10898 <send_krp_status+0x64>)
   10882:	4b06      	ldr	r3, [pc, #24]	; (1089c <send_krp_status+0x68>)
		BT_ERR("Unable to send Key Refresh State Status");
   10884:	4806      	ldr	r0, [pc, #24]	; (108a0 <send_krp_status+0x6c>)
   10886:	1ac9      	subs	r1, r1, r3
   10888:	08c9      	lsrs	r1, r1, #3
   1088a:	0189      	lsls	r1, r1, #6
   1088c:	f041 0101 	orr.w	r1, r1, #1
   10890:	f013 fb98 	bl	23fc4 <log_0>
}
   10894:	b009      	add	sp, #36	; 0x24
   10896:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10898:	00029928 	.word	0x00029928
   1089c:	00029830 	.word	0x00029830
   108a0:	0002dd57 	.word	0x0002dd57

000108a4 <krp_get>:
{
   108a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   108a6:	4605      	mov	r5, r0
	idx = net_buf_simple_pull_le16(buf);
   108a8:	4610      	mov	r0, r2
{
   108aa:	460e      	mov	r6, r1
	idx = net_buf_simple_pull_le16(buf);
   108ac:	f018 fa5b 	bl	28d66 <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   108b0:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   108b4:	4604      	mov	r4, r0
	if (idx > 0xfff) {
   108b6:	d30d      	bcc.n	108d4 <krp_get+0x30>
   108b8:	4b0e      	ldr	r3, [pc, #56]	; (108f4 <krp_get+0x50>)
   108ba:	4a0f      	ldr	r2, [pc, #60]	; (108f8 <krp_get+0x54>)
   108bc:	1ad2      	subs	r2, r2, r3
   108be:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   108c0:	4601      	mov	r1, r0
   108c2:	0192      	lsls	r2, r2, #6
   108c4:	480d      	ldr	r0, [pc, #52]	; (108fc <krp_get+0x58>)
   108c6:	f042 0201 	orr.w	r2, r2, #1
}
   108ca:	b002      	add	sp, #8
   108cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   108d0:	f013 bb85 	b.w	23fde <log_1>
	sub = bt_mesh_subnet_get(idx);
   108d4:	f7fc f88a 	bl	c9ec <bt_mesh_subnet_get>
	if (!sub) {
   108d8:	4603      	mov	r3, r0
   108da:	b940      	cbnz	r0, 108ee <krp_get+0x4a>
		send_krp_status(model, ctx, idx, 0x00, STATUS_INVALID_NETKEY);
   108dc:	2204      	movs	r2, #4
		send_krp_status(model, ctx, idx, sub->kr_phase,
   108de:	9200      	str	r2, [sp, #0]
   108e0:	4631      	mov	r1, r6
   108e2:	4622      	mov	r2, r4
   108e4:	4628      	mov	r0, r5
   108e6:	f7ff ffa5 	bl	10834 <send_krp_status>
}
   108ea:	b002      	add	sp, #8
   108ec:	bd70      	pop	{r4, r5, r6, pc}
		send_krp_status(model, ctx, idx, sub->kr_phase,
   108ee:	7fc3      	ldrb	r3, [r0, #31]
   108f0:	2200      	movs	r2, #0
   108f2:	e7f4      	b.n	108de <krp_get+0x3a>
   108f4:	00029830 	.word	0x00029830
   108f8:	00029928 	.word	0x00029928
   108fc:	0002db35 	.word	0x0002db35

00010900 <krp_set>:
{
   10900:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   10904:	4680      	mov	r8, r0
	idx = net_buf_simple_pull_le16(buf);
   10906:	4610      	mov	r0, r2
{
   10908:	4614      	mov	r4, r2
   1090a:	460f      	mov	r7, r1
	idx = net_buf_simple_pull_le16(buf);
   1090c:	f018 fa2b 	bl	28d66 <net_buf_simple_pull_le16>
   10910:	4605      	mov	r5, r0
	phase = net_buf_simple_pull_u8(buf);
   10912:	4620      	mov	r0, r4
   10914:	f018 fa1f 	bl	28d56 <net_buf_simple_pull_u8>
	if (idx > 0xfff) {
   10918:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
	phase = net_buf_simple_pull_u8(buf);
   1091c:	4606      	mov	r6, r0
	if (idx > 0xfff) {
   1091e:	d30d      	bcc.n	1093c <krp_set+0x3c>
   10920:	4b27      	ldr	r3, [pc, #156]	; (109c0 <krp_set+0xc0>)
   10922:	4a28      	ldr	r2, [pc, #160]	; (109c4 <krp_set+0xc4>)
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   10924:	4828      	ldr	r0, [pc, #160]	; (109c8 <krp_set+0xc8>)
   10926:	1ad2      	subs	r2, r2, r3
   10928:	08d2      	lsrs	r2, r2, #3
   1092a:	0192      	lsls	r2, r2, #6
   1092c:	f042 0201 	orr.w	r2, r2, #1
   10930:	4629      	mov	r1, r5
}
   10932:	b002      	add	sp, #8
   10934:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   10938:	f013 bb51 	b.w	23fde <log_1>
	sub = bt_mesh_subnet_get(idx);
   1093c:	4628      	mov	r0, r5
   1093e:	f7fc f855 	bl	c9ec <bt_mesh_subnet_get>
   10942:	4604      	mov	r4, r0
	if (!sub) {
   10944:	b950      	cbnz	r0, 1095c <krp_set+0x5c>
		send_krp_status(model, ctx, idx, 0x00, STATUS_INVALID_NETKEY);
   10946:	2304      	movs	r3, #4
   10948:	9300      	str	r3, [sp, #0]
   1094a:	4603      	mov	r3, r0
	send_krp_status(model, ctx, idx, sub->kr_phase, STATUS_SUCCESS);
   1094c:	462a      	mov	r2, r5
   1094e:	4639      	mov	r1, r7
   10950:	4640      	mov	r0, r8
   10952:	f7ff ff6f 	bl	10834 <send_krp_status>
}
   10956:	b002      	add	sp, #8
   10958:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (phase < BT_MESH_KR_PHASE_2 || phase > BT_MESH_KR_PHASE_3 ||
   1095c:	1eb3      	subs	r3, r6, #2
   1095e:	b2db      	uxtb	r3, r3
   10960:	2b01      	cmp	r3, #1
   10962:	7fc1      	ldrb	r1, [r0, #31]
   10964:	d802      	bhi.n	1096c <krp_set+0x6c>
   10966:	b979      	cbnz	r1, 10988 <krp_set+0x88>
	    (sub->kr_phase == BT_MESH_KR_NORMAL &&
   10968:	2e02      	cmp	r6, #2
   1096a:	d116      	bne.n	1099a <krp_set+0x9a>
   1096c:	4a14      	ldr	r2, [pc, #80]	; (109c0 <krp_set+0xc0>)
   1096e:	4b15      	ldr	r3, [pc, #84]	; (109c4 <krp_set+0xc4>)
		BT_WARN("Prohibited transition %u -> %u", sub->kr_phase, phase);
   10970:	4816      	ldr	r0, [pc, #88]	; (109cc <krp_set+0xcc>)
   10972:	1a9b      	subs	r3, r3, r2
   10974:	08db      	lsrs	r3, r3, #3
   10976:	019b      	lsls	r3, r3, #6
   10978:	f043 0302 	orr.w	r3, r3, #2
   1097c:	4632      	mov	r2, r6
}
   1097e:	b002      	add	sp, #8
   10980:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		BT_WARN("Prohibited transition %u -> %u", sub->kr_phase, phase);
   10984:	f013 bb3f 	b.w	24006 <log_2>
	if (sub->kr_phase == BT_MESH_KR_PHASE_1 &&
   10988:	2901      	cmp	r1, #1
   1098a:	d10a      	bne.n	109a2 <krp_set+0xa2>
   1098c:	2e02      	cmp	r6, #2
   1098e:	d10a      	bne.n	109a6 <krp_set+0xa6>
		sub->kr_flag = 1;
   10990:	f240 2301 	movw	r3, #513	; 0x201
   10994:	83c3      	strh	r3, [r0, #30]
		bt_mesh_net_beacon_update(sub);
   10996:	f7fc f9f9 	bl	cd8c <bt_mesh_net_beacon_update>
	send_krp_status(model, ctx, idx, sub->kr_phase, STATUS_SUCCESS);
   1099a:	2200      	movs	r2, #0
   1099c:	7fe3      	ldrb	r3, [r4, #31]
   1099e:	9200      	str	r2, [sp, #0]
   109a0:	e7d4      	b.n	1094c <krp_set+0x4c>
	} else if ((sub->kr_phase == BT_MESH_KR_PHASE_1 ||
   109a2:	2902      	cmp	r1, #2
   109a4:	d1f9      	bne.n	1099a <krp_set+0x9a>
		    sub->kr_phase == BT_MESH_KR_PHASE_2) &&
   109a6:	2e03      	cmp	r6, #3
   109a8:	d1f7      	bne.n	1099a <krp_set+0x9a>
		bt_mesh_net_revoke_keys(sub);
   109aa:	4620      	mov	r0, r4
   109ac:	f7fc fa62 	bl	ce74 <bt_mesh_net_revoke_keys>
			friend_cred_refresh(ctx->net_idx);
   109b0:	8838      	ldrh	r0, [r7, #0]
   109b2:	f7fc f8f1 	bl	cb98 <friend_cred_refresh>
		sub->kr_flag = 0;
   109b6:	2300      	movs	r3, #0
   109b8:	83e3      	strh	r3, [r4, #30]
		bt_mesh_net_beacon_update(sub);
   109ba:	4620      	mov	r0, r4
   109bc:	e7eb      	b.n	10996 <krp_set+0x96>
   109be:	bf00      	nop
   109c0:	00029830 	.word	0x00029830
   109c4:	00029928 	.word	0x00029928
   109c8:	0002db35 	.word	0x0002db35
   109cc:	0002dd7f 	.word	0x0002dd7f

000109d0 <send_friend_status>:
{
   109d0:	b570      	push	{r4, r5, r6, lr}
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   109d2:	69c6      	ldr	r6, [r0, #28]
{
   109d4:	b088      	sub	sp, #32
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_FRIEND_STATUS, 1);
   109d6:	ab03      	add	r3, sp, #12
   109d8:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   109dc:	4604      	mov	r4, r0
   109de:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_FRIEND_STATUS);
   109e0:	a805      	add	r0, sp, #20
   109e2:	f248 0111 	movw	r1, #32785	; 0x8011
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_FRIEND_STATUS, 1);
   109e6:	e9cd 2306 	strd	r2, r3, [sp, #24]
   109ea:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_FRIEND_STATUS);
   109ec:	f016 fee0 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, cfg->frnd);
   109f0:	7a71      	ldrb	r1, [r6, #9]
   109f2:	a805      	add	r0, sp, #20
   109f4:	f018 f9eb 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   109f8:	2300      	movs	r3, #0
   109fa:	9300      	str	r3, [sp, #0]
   109fc:	aa05      	add	r2, sp, #20
   109fe:	4629      	mov	r1, r5
   10a00:	4620      	mov	r0, r4
   10a02:	f016 fefe 	bl	27802 <bt_mesh_model_send>
   10a06:	b148      	cbz	r0, 10a1c <send_friend_status+0x4c>
   10a08:	4905      	ldr	r1, [pc, #20]	; (10a20 <send_friend_status+0x50>)
   10a0a:	4b06      	ldr	r3, [pc, #24]	; (10a24 <send_friend_status+0x54>)
		BT_ERR("Unable to send Friend Status");
   10a0c:	4806      	ldr	r0, [pc, #24]	; (10a28 <send_friend_status+0x58>)
   10a0e:	1ac9      	subs	r1, r1, r3
   10a10:	08c9      	lsrs	r1, r1, #3
   10a12:	0189      	lsls	r1, r1, #6
   10a14:	f041 0101 	orr.w	r1, r1, #1
   10a18:	f013 fad4 	bl	23fc4 <log_0>
}
   10a1c:	b008      	add	sp, #32
   10a1e:	bd70      	pop	{r4, r5, r6, pc}
   10a20:	00029928 	.word	0x00029928
   10a24:	00029830 	.word	0x00029830
   10a28:	0002dd9e 	.word	0x0002dd9e

00010a2c <friend_set>:
{
   10a2c:	b570      	push	{r4, r5, r6, lr}
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   10a2e:	6813      	ldr	r3, [r2, #0]
{
   10a30:	460e      	mov	r6, r1
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   10a32:	7819      	ldrb	r1, [r3, #0]
   10a34:	2901      	cmp	r1, #1
{
   10a36:	4605      	mov	r5, r0
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   10a38:	d90b      	bls.n	10a52 <friend_set+0x26>
   10a3a:	4a18      	ldr	r2, [pc, #96]	; (10a9c <friend_set+0x70>)
   10a3c:	4b18      	ldr	r3, [pc, #96]	; (10aa0 <friend_set+0x74>)
		BT_WARN("Invalid Friend value 0x%02x", buf->data[0]);
   10a3e:	4819      	ldr	r0, [pc, #100]	; (10aa4 <friend_set+0x78>)
   10a40:	1ad2      	subs	r2, r2, r3
   10a42:	08d2      	lsrs	r2, r2, #3
   10a44:	0192      	lsls	r2, r2, #6
}
   10a46:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("Invalid Friend value 0x%02x", buf->data[0]);
   10a4a:	f042 0202 	orr.w	r2, r2, #2
   10a4e:	f013 bac6 	b.w	23fde <log_1>
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   10a52:	69c4      	ldr	r4, [r0, #28]
	if (!cfg) {
   10a54:	b97c      	cbnz	r4, 10a76 <friend_set+0x4a>
   10a56:	4912      	ldr	r1, [pc, #72]	; (10aa0 <friend_set+0x74>)
   10a58:	4b10      	ldr	r3, [pc, #64]	; (10a9c <friend_set+0x70>)
		BT_WARN("No Configuration Server context available");
   10a5a:	4813      	ldr	r0, [pc, #76]	; (10aa8 <friend_set+0x7c>)
   10a5c:	1a5b      	subs	r3, r3, r1
   10a5e:	08db      	lsrs	r3, r3, #3
   10a60:	019b      	lsls	r3, r3, #6
   10a62:	f043 0102 	orr.w	r1, r3, #2
   10a66:	f013 faad 	bl	23fc4 <log_0>
	send_friend_status(model, ctx);
   10a6a:	4631      	mov	r1, r6
   10a6c:	4628      	mov	r0, r5
}
   10a6e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	send_friend_status(model, ctx);
   10a72:	f7ff bfad 	b.w	109d0 <send_friend_status>
	if (cfg->frnd == buf->data[0]) {
   10a76:	7a63      	ldrb	r3, [r4, #9]
   10a78:	428b      	cmp	r3, r1
   10a7a:	d0f6      	beq.n	10a6a <friend_set+0x3e>
		cfg->frnd = buf->data[0];
   10a7c:	7261      	strb	r1, [r4, #9]
			bt_mesh_store_cfg();
   10a7e:	f017 f904 	bl	27c8a <bt_mesh_store_cfg>
		if (cfg->frnd == BT_MESH_FRIEND_DISABLED) {
   10a82:	7a63      	ldrb	r3, [r4, #9]
   10a84:	b91b      	cbnz	r3, 10a8e <friend_set+0x62>
			bt_mesh_friend_clear_net_idx(BT_MESH_KEY_ANY);
   10a86:	f64f 70ff 	movw	r0, #65535	; 0xffff
   10a8a:	f004 f84b 	bl	14b24 <bt_mesh_friend_clear_net_idx>
	if (cfg->hb_pub.feat & BT_MESH_FEAT_FRIEND) {
   10a8e:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   10a90:	075b      	lsls	r3, r3, #29
   10a92:	d5ea      	bpl.n	10a6a <friend_set+0x3e>
		bt_mesh_heartbeat_send();
   10a94:	f016 fc26 	bl	272e4 <bt_mesh_heartbeat_send>
   10a98:	e7e7      	b.n	10a6a <friend_set+0x3e>
   10a9a:	bf00      	nop
   10a9c:	00029928 	.word	0x00029928
   10aa0:	00029830 	.word	0x00029830
   10aa4:	0002ddbb 	.word	0x0002ddbb
   10aa8:	0002ddd7 	.word	0x0002ddd7

00010aac <net_key_get>:
{
   10aac:	b530      	push	{r4, r5, lr}
   10aae:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_KEY_LIST,
   10ab0:	ab02      	add	r3, sp, #8
   10ab2:	f44f 2210 	mov.w	r2, #589824	; 0x90000
{
   10ab6:	4604      	mov	r4, r0
   10ab8:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_NET_KEY_LIST);
   10aba:	a805      	add	r0, sp, #20
   10abc:	f248 0143 	movw	r1, #32835	; 0x8043
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_KEY_LIST,
   10ac0:	e9cd 2306 	strd	r2, r3, [sp, #24]
   10ac4:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_NET_KEY_LIST);
   10ac6:	f016 fe73 	bl	277b0 <bt_mesh_model_msg_init>
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   10aca:	4b15      	ldr	r3, [pc, #84]	; (10b20 <net_key_get+0x74>)
   10acc:	f8b3 229c 	ldrh.w	r2, [r3, #668]	; 0x29c
   10ad0:	f8b3 11b8 	ldrh.w	r1, [r3, #440]	; 0x1b8
   10ad4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   10ad8:	429a      	cmp	r2, r3
   10ada:	d018      	beq.n	10b0e <net_key_get+0x62>
		if (prev == BT_MESH_KEY_UNUSED) {
   10adc:	4299      	cmp	r1, r3
   10ade:	d019      	beq.n	10b14 <net_key_get+0x68>
		key_idx_pack(&msg, prev, sub->net_idx);
   10ae0:	a805      	add	r0, sp, #20
   10ae2:	f016 fee0 	bl	278a6 <key_idx_pack>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10ae6:	2300      	movs	r3, #0
   10ae8:	9300      	str	r3, [sp, #0]
   10aea:	aa05      	add	r2, sp, #20
   10aec:	4629      	mov	r1, r5
   10aee:	4620      	mov	r0, r4
   10af0:	f016 fe87 	bl	27802 <bt_mesh_model_send>
   10af4:	b148      	cbz	r0, 10b0a <net_key_get+0x5e>
   10af6:	490b      	ldr	r1, [pc, #44]	; (10b24 <net_key_get+0x78>)
   10af8:	4b0b      	ldr	r3, [pc, #44]	; (10b28 <net_key_get+0x7c>)
		BT_ERR("Unable to send NetKey List");
   10afa:	480c      	ldr	r0, [pc, #48]	; (10b2c <net_key_get+0x80>)
   10afc:	1ac9      	subs	r1, r1, r3
   10afe:	08c9      	lsrs	r1, r1, #3
   10b00:	0189      	lsls	r1, r1, #6
   10b02:	f041 0101 	orr.w	r1, r1, #1
   10b06:	f013 fa5d 	bl	23fc4 <log_0>
}
   10b0a:	b009      	add	sp, #36	; 0x24
   10b0c:	bd30      	pop	{r4, r5, pc}
	if (prev != BT_MESH_KEY_UNUSED) {
   10b0e:	4291      	cmp	r1, r2
   10b10:	d0e9      	beq.n	10ae6 <net_key_get+0x3a>
   10b12:	460a      	mov	r2, r1
		net_buf_simple_add_le16(&msg, prev);
   10b14:	4611      	mov	r1, r2
   10b16:	a805      	add	r0, sp, #20
   10b18:	f018 f960 	bl	28ddc <net_buf_simple_add_le16>
   10b1c:	e7e3      	b.n	10ae6 <net_key_get+0x3a>
   10b1e:	bf00      	nop
   10b20:	20006b48 	.word	0x20006b48
   10b24:	00029928 	.word	0x00029928
   10b28:	00029830 	.word	0x00029830
   10b2c:	0002de01 	.word	0x0002de01

00010b30 <send_net_key_status>:
{
   10b30:	b5f0      	push	{r4, r5, r6, r7, lr}
   10b32:	b089      	sub	sp, #36	; 0x24
   10b34:	4604      	mov	r4, r0
   10b36:	460d      	mov	r5, r1
   10b38:	4616      	mov	r6, r2
   10b3a:	461f      	mov	r7, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_KEY_STATUS, 3);
   10b3c:	f44f 2210 	mov.w	r2, #589824	; 0x90000
   10b40:	ab02      	add	r3, sp, #8
	bt_mesh_model_msg_init(&msg, OP_NET_KEY_STATUS);
   10b42:	f248 0144 	movw	r1, #32836	; 0x8044
   10b46:	a805      	add	r0, sp, #20
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_KEY_STATUS, 3);
   10b48:	e9cd 2306 	strd	r2, r3, [sp, #24]
   10b4c:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_NET_KEY_STATUS);
   10b4e:	f016 fe2f 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   10b52:	4639      	mov	r1, r7
   10b54:	a805      	add	r0, sp, #20
   10b56:	f018 f93a 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, idx);
   10b5a:	4631      	mov	r1, r6
   10b5c:	a805      	add	r0, sp, #20
   10b5e:	f018 f93d 	bl	28ddc <net_buf_simple_add_le16>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10b62:	2300      	movs	r3, #0
   10b64:	9300      	str	r3, [sp, #0]
   10b66:	aa05      	add	r2, sp, #20
   10b68:	4629      	mov	r1, r5
   10b6a:	4620      	mov	r0, r4
   10b6c:	f016 fe49 	bl	27802 <bt_mesh_model_send>
   10b70:	b148      	cbz	r0, 10b86 <send_net_key_status+0x56>
   10b72:	4906      	ldr	r1, [pc, #24]	; (10b8c <send_net_key_status+0x5c>)
   10b74:	4b06      	ldr	r3, [pc, #24]	; (10b90 <send_net_key_status+0x60>)
		BT_ERR("Unable to send NetKey Status");
   10b76:	4807      	ldr	r0, [pc, #28]	; (10b94 <send_net_key_status+0x64>)
   10b78:	1ac9      	subs	r1, r1, r3
   10b7a:	08c9      	lsrs	r1, r1, #3
   10b7c:	0189      	lsls	r1, r1, #6
   10b7e:	f041 0101 	orr.w	r1, r1, #1
   10b82:	f013 fa1f 	bl	23fc4 <log_0>
}
   10b86:	b009      	add	sp, #36	; 0x24
   10b88:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10b8a:	bf00      	nop
   10b8c:	00029928 	.word	0x00029928
   10b90:	00029830 	.word	0x00029830
   10b94:	0002de1c 	.word	0x0002de1c

00010b98 <net_key_update>:
{
   10b98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10b9c:	4606      	mov	r6, r0
	idx = net_buf_simple_pull_le16(buf);
   10b9e:	4610      	mov	r0, r2
{
   10ba0:	460f      	mov	r7, r1
   10ba2:	4690      	mov	r8, r2
	idx = net_buf_simple_pull_le16(buf);
   10ba4:	f018 f8df 	bl	28d66 <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   10ba8:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   10bac:	4605      	mov	r5, r0
	if (idx > 0xfff) {
   10bae:	d30c      	bcc.n	10bca <net_key_update+0x32>
   10bb0:	4a27      	ldr	r2, [pc, #156]	; (10c50 <net_key_update+0xb8>)
   10bb2:	4b28      	ldr	r3, [pc, #160]	; (10c54 <net_key_update+0xbc>)
   10bb4:	1ad2      	subs	r2, r2, r3
   10bb6:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   10bb8:	0192      	lsls	r2, r2, #6
   10bba:	4601      	mov	r1, r0
}
   10bbc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   10bc0:	4825      	ldr	r0, [pc, #148]	; (10c58 <net_key_update+0xc0>)
   10bc2:	f042 0201 	orr.w	r2, r2, #1
   10bc6:	f013 ba0a 	b.w	23fde <log_1>
	sub = bt_mesh_subnet_get(idx);
   10bca:	f7fb ff0f 	bl	c9ec <bt_mesh_subnet_get>
	if (!sub) {
   10bce:	4604      	mov	r4, r0
   10bd0:	b938      	cbnz	r0, 10be2 <net_key_update+0x4a>
		send_net_key_status(model, ctx, idx, STATUS_INVALID_NETKEY);
   10bd2:	2304      	movs	r3, #4
	send_net_key_status(model, ctx, idx, STATUS_SUCCESS);
   10bd4:	462a      	mov	r2, r5
   10bd6:	4639      	mov	r1, r7
   10bd8:	4630      	mov	r0, r6
}
   10bda:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	send_net_key_status(model, ctx, idx, STATUS_SUCCESS);
   10bde:	f7ff bfa7 	b.w	10b30 <send_net_key_status>
	switch (sub->kr_phase) {
   10be2:	7fc3      	ldrb	r3, [r0, #31]
   10be4:	2b01      	cmp	r3, #1
   10be6:	d017      	beq.n	10c18 <net_key_update+0x80>
   10be8:	d90b      	bls.n	10c02 <net_key_update+0x6a>
   10bea:	3b02      	subs	r3, #2
   10bec:	2b01      	cmp	r3, #1
   10bee:	d91d      	bls.n	10c2c <net_key_update+0x94>
	err = bt_mesh_net_keys_create(&sub->keys[1], buf->data);
   10bf0:	f8d8 1000 	ldr.w	r1, [r8]
   10bf4:	f104 0089 	add.w	r0, r4, #137	; 0x89
   10bf8:	f7fb ff18 	bl	ca2c <bt_mesh_net_keys_create>
	if (!err && (IS_ENABLED(CONFIG_BT_MESH_LOW_POWER) ||
   10bfc:	b1c0      	cbz	r0, 10c30 <net_key_update+0x98>
		send_net_key_status(model, ctx, idx, STATUS_UNSPECIFIED);
   10bfe:	2310      	movs	r3, #16
   10c00:	e7e8      	b.n	10bd4 <net_key_update+0x3c>
		if (!memcmp(buf->data, sub->keys[0].net, 16)) {
   10c02:	f100 0130 	add.w	r1, r0, #48	; 0x30
   10c06:	2210      	movs	r2, #16
   10c08:	f8d8 0000 	ldr.w	r0, [r8]
   10c0c:	f015 f83c 	bl	25c88 <memcmp>
   10c10:	2800      	cmp	r0, #0
   10c12:	d1ed      	bne.n	10bf0 <net_key_update+0x58>
}
   10c14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!memcmp(buf->data, sub->keys[1].net, 16)) {
   10c18:	f100 0189 	add.w	r1, r0, #137	; 0x89
   10c1c:	2210      	movs	r2, #16
   10c1e:	f8d8 0000 	ldr.w	r0, [r8]
   10c22:	f015 f831 	bl	25c88 <memcmp>
   10c26:	4603      	mov	r3, r0
   10c28:	2800      	cmp	r0, #0
   10c2a:	d0d3      	beq.n	10bd4 <net_key_update+0x3c>
		send_net_key_status(model, ctx, idx, STATUS_CANNOT_UPDATE);
   10c2c:	230b      	movs	r3, #11
   10c2e:	e7d1      	b.n	10bd4 <net_key_update+0x3c>
		err = friend_cred_update(sub);
   10c30:	4620      	mov	r0, r4
   10c32:	f7fb ffd5 	bl	cbe0 <friend_cred_update>
	if (err) {
   10c36:	4680      	mov	r8, r0
   10c38:	2800      	cmp	r0, #0
   10c3a:	d1e0      	bne.n	10bfe <net_key_update+0x66>
	sub->kr_phase = BT_MESH_KR_PHASE_1;
   10c3c:	2301      	movs	r3, #1
   10c3e:	77e3      	strb	r3, [r4, #31]
		bt_mesh_store_subnet(sub);
   10c40:	4620      	mov	r0, r4
   10c42:	f016 ffdb 	bl	27bfc <bt_mesh_store_subnet>
	bt_mesh_net_beacon_update(sub);
   10c46:	4620      	mov	r0, r4
   10c48:	f7fc f8a0 	bl	cd8c <bt_mesh_net_beacon_update>
	send_net_key_status(model, ctx, idx, STATUS_SUCCESS);
   10c4c:	4643      	mov	r3, r8
   10c4e:	e7c1      	b.n	10bd4 <net_key_update+0x3c>
   10c50:	00029928 	.word	0x00029928
   10c54:	00029830 	.word	0x00029830
   10c58:	0002db35 	.word	0x0002db35

00010c5c <net_key_add>:
{
   10c5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10c60:	4606      	mov	r6, r0
	idx = net_buf_simple_pull_le16(buf);
   10c62:	4610      	mov	r0, r2
{
   10c64:	460f      	mov	r7, r1
   10c66:	4690      	mov	r8, r2
	idx = net_buf_simple_pull_le16(buf);
   10c68:	f018 f87d 	bl	28d66 <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   10c6c:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   10c70:	4605      	mov	r5, r0
	if (idx > 0xfff) {
   10c72:	d30c      	bcc.n	10c8e <net_key_add+0x32>
   10c74:	4a28      	ldr	r2, [pc, #160]	; (10d18 <net_key_add+0xbc>)
   10c76:	4b29      	ldr	r3, [pc, #164]	; (10d1c <net_key_add+0xc0>)
   10c78:	1ad2      	subs	r2, r2, r3
   10c7a:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   10c7c:	0192      	lsls	r2, r2, #6
   10c7e:	4601      	mov	r1, r0
}
   10c80:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   10c84:	4826      	ldr	r0, [pc, #152]	; (10d20 <net_key_add+0xc4>)
   10c86:	f042 0201 	orr.w	r2, r2, #1
   10c8a:	f013 b9a8 	b.w	23fde <log_1>
	sub = bt_mesh_subnet_get(idx);
   10c8e:	f7fb fead 	bl	c9ec <bt_mesh_subnet_get>
	if (!sub) {
   10c92:	4604      	mov	r4, r0
   10c94:	b980      	cbnz	r0, 10cb8 <net_key_add+0x5c>
			if (bt_mesh.sub[i].net_idx == BT_MESH_KEY_UNUSED) {
   10c96:	4b23      	ldr	r3, [pc, #140]	; (10d24 <net_key_add+0xc8>)
   10c98:	f8b3 11b8 	ldrh.w	r1, [r3, #440]	; 0x1b8
   10c9c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   10ca0:	4291      	cmp	r1, r2
   10ca2:	d004      	beq.n	10cae <net_key_add+0x52>
   10ca4:	f8b3 129c 	ldrh.w	r1, [r3, #668]	; 0x29c
   10ca8:	4291      	cmp	r1, r2
   10caa:	d115      	bne.n	10cd8 <net_key_add+0x7c>
		for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
   10cac:	2401      	movs	r4, #1
				sub = &bt_mesh.sub[i];
   10cae:	20e4      	movs	r0, #228	; 0xe4
   10cb0:	fb00 3404 	mla	r4, r0, r4, r3
   10cb4:	f504 74ce 	add.w	r4, r4, #412	; 0x19c
	if (sub->net_idx == idx) {
   10cb8:	8ba2      	ldrh	r2, [r4, #28]
   10cba:	f8d8 0000 	ldr.w	r0, [r8]
   10cbe:	42aa      	cmp	r2, r5
   10cc0:	f104 0330 	add.w	r3, r4, #48	; 0x30
   10cc4:	d110      	bne.n	10ce8 <net_key_add+0x8c>
		if (memcmp(buf->data, sub->keys[0].net, 16)) {
   10cc6:	4619      	mov	r1, r3
   10cc8:	2210      	movs	r2, #16
   10cca:	f014 ffdd 	bl	25c88 <memcmp>
			status = STATUS_SUCCESS;
   10cce:	2800      	cmp	r0, #0
		send_net_key_status(model, ctx, idx, status);
   10cd0:	bf14      	ite	ne
   10cd2:	2306      	movne	r3, #6
   10cd4:	2300      	moveq	r3, #0
   10cd6:	e000      	b.n	10cda <net_key_add+0x7e>
			send_net_key_status(model, ctx, idx,
   10cd8:	2305      	movs	r3, #5
	send_net_key_status(model, ctx, idx, STATUS_SUCCESS);
   10cda:	462a      	mov	r2, r5
   10cdc:	4639      	mov	r1, r7
   10cde:	4630      	mov	r0, r6
}
   10ce0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	send_net_key_status(model, ctx, idx, STATUS_SUCCESS);
   10ce4:	f7ff bf24 	b.w	10b30 <send_net_key_status>
	err = bt_mesh_net_keys_create(&sub->keys[0], buf->data);
   10ce8:	4601      	mov	r1, r0
   10cea:	4618      	mov	r0, r3
   10cec:	f7fb fe9e 	bl	ca2c <bt_mesh_net_keys_create>
	if (err) {
   10cf0:	4680      	mov	r8, r0
   10cf2:	b108      	cbz	r0, 10cf8 <net_key_add+0x9c>
		send_net_key_status(model, ctx, idx, STATUS_UNSPECIFIED);
   10cf4:	2310      	movs	r3, #16
   10cf6:	e7f0      	b.n	10cda <net_key_add+0x7e>
		bt_mesh_store_subnet(sub);
   10cf8:	4620      	mov	r0, r4
	sub->net_idx = idx;
   10cfa:	83a5      	strh	r5, [r4, #28]
		bt_mesh_store_subnet(sub);
   10cfc:	f016 ff7e 	bl	27bfc <bt_mesh_store_subnet>
	bt_mesh_net_beacon_update(sub);
   10d00:	4620      	mov	r0, r4
   10d02:	f7fc f843 	bl	cd8c <bt_mesh_net_beacon_update>
		bt_mesh_proxy_beacon_send(sub);
   10d06:	4620      	mov	r0, r4
		sub->node_id = BT_MESH_NODE_IDENTITY_STOPPED;
   10d08:	f884 8020 	strb.w	r8, [r4, #32]
		bt_mesh_proxy_beacon_send(sub);
   10d0c:	f006 fe4a 	bl	179a4 <bt_mesh_proxy_beacon_send>
		bt_mesh_adv_update();
   10d10:	f7fb f9da 	bl	c0c8 <bt_mesh_adv_update>
	send_net_key_status(model, ctx, idx, STATUS_SUCCESS);
   10d14:	4643      	mov	r3, r8
   10d16:	e7e0      	b.n	10cda <net_key_add+0x7e>
   10d18:	00029928 	.word	0x00029928
   10d1c:	00029830 	.word	0x00029830
   10d20:	0002db35 	.word	0x0002db35
   10d24:	20006b48 	.word	0x20006b48

00010d28 <send_mod_pub_status.isra.0>:
static void send_mod_pub_status(struct bt_mesh_model *cfg_mod,
   10d28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10d2c:	b08b      	sub	sp, #44	; 0x2c
   10d2e:	4692      	mov	sl, r2
   10d30:	f89d b058 	ldrb.w	fp, [sp, #88]	; 0x58
   10d34:	f89d 8050 	ldrb.w	r8, [sp, #80]	; 0x50
   10d38:	9c15      	ldr	r4, [sp, #84]	; 0x54
   10d3a:	9f17      	ldr	r7, [sp, #92]	; 0x5c
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_PUB_STATUS, 14);
   10d3c:	f44f 12a0 	mov.w	r2, #1310720	; 0x140000
static void send_mod_pub_status(struct bt_mesh_model *cfg_mod,
   10d40:	4605      	mov	r5, r0
   10d42:	460e      	mov	r6, r1
	bt_mesh_model_msg_init(&msg, OP_MOD_PUB_STATUS);
   10d44:	a802      	add	r0, sp, #8
   10d46:	f248 0119 	movw	r1, #32793	; 0x8019
static void send_mod_pub_status(struct bt_mesh_model *cfg_mod,
   10d4a:	4699      	mov	r9, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_PUB_STATUS, 14);
   10d4c:	ab05      	add	r3, sp, #20
   10d4e:	e9cd 2303 	strd	r2, r3, [sp, #12]
   10d52:	9302      	str	r3, [sp, #8]
	bt_mesh_model_msg_init(&msg, OP_MOD_PUB_STATUS);
   10d54:	f016 fd2c 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   10d58:	4659      	mov	r1, fp
   10d5a:	a802      	add	r0, sp, #8
   10d5c:	f018 f837 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, elem_addr);
   10d60:	4651      	mov	r1, sl
   10d62:	a802      	add	r0, sp, #8
   10d64:	f018 f83a 	bl	28ddc <net_buf_simple_add_le16>
	if (status != STATUS_SUCCESS) {
   10d68:	f1bb 0f00 	cmp.w	fp, #0
   10d6c:	d027      	beq.n	10dbe <send_mod_pub_status.isra.0+0x96>
		(void)memset(net_buf_simple_add(&msg, 7), 0, 7);
   10d6e:	2107      	movs	r1, #7
   10d70:	a802      	add	r0, sp, #8
   10d72:	f00e fab1 	bl	1f2d8 <net_buf_simple_add>
   10d76:	2207      	movs	r2, #7
   10d78:	2100      	movs	r1, #0
   10d7a:	f014 ffc0 	bl	25cfe <memset>
	if (vnd) {
   10d7e:	f1b8 0f00 	cmp.w	r8, #0
   10d82:	d03c      	beq.n	10dfe <send_mod_pub_status.isra.0+0xd6>
		memcpy(net_buf_simple_add(&msg, 4), mod_id, 4);
   10d84:	2104      	movs	r1, #4
   10d86:	a802      	add	r0, sp, #8
   10d88:	f00e faa6 	bl	1f2d8 <net_buf_simple_add>
   10d8c:	2204      	movs	r2, #4
		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
   10d8e:	4639      	mov	r1, r7
   10d90:	f014 ff8a 	bl	25ca8 <memcpy>
	if (bt_mesh_model_send(cfg_mod, ctx, &msg, NULL, NULL)) {
   10d94:	2300      	movs	r3, #0
   10d96:	9300      	str	r3, [sp, #0]
   10d98:	aa02      	add	r2, sp, #8
   10d9a:	4631      	mov	r1, r6
   10d9c:	4628      	mov	r0, r5
   10d9e:	f016 fd30 	bl	27802 <bt_mesh_model_send>
   10da2:	b148      	cbz	r0, 10db8 <send_mod_pub_status.isra.0+0x90>
   10da4:	4919      	ldr	r1, [pc, #100]	; (10e0c <send_mod_pub_status.isra.0+0xe4>)
   10da6:	4b1a      	ldr	r3, [pc, #104]	; (10e10 <send_mod_pub_status.isra.0+0xe8>)
		BT_ERR("Unable to send Model Publication Status");
   10da8:	481a      	ldr	r0, [pc, #104]	; (10e14 <send_mod_pub_status.isra.0+0xec>)
   10daa:	1ac9      	subs	r1, r1, r3
   10dac:	08c9      	lsrs	r1, r1, #3
   10dae:	0189      	lsls	r1, r1, #6
   10db0:	f041 0101 	orr.w	r1, r1, #1
   10db4:	f013 f906 	bl	23fc4 <log_0>
}
   10db8:	b00b      	add	sp, #44	; 0x2c
   10dba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		net_buf_simple_add_le16(&msg, pub_addr);
   10dbe:	4649      	mov	r1, r9
   10dc0:	a802      	add	r0, sp, #8
   10dc2:	f018 f80b 	bl	28ddc <net_buf_simple_add_le16>
		idx_cred = mod->pub->key | (u16_t)mod->pub->cred << 12;
   10dc6:	6823      	ldr	r3, [r4, #0]
   10dc8:	79d9      	ldrb	r1, [r3, #7]
   10dca:	88db      	ldrh	r3, [r3, #6]
   10dcc:	f3c1 1100 	ubfx	r1, r1, #4, #1
   10dd0:	f3c3 030b 	ubfx	r3, r3, #0, #12
		net_buf_simple_add_le16(&msg, idx_cred);
   10dd4:	ea43 3101 	orr.w	r1, r3, r1, lsl #12
   10dd8:	a802      	add	r0, sp, #8
   10dda:	f017 ffff 	bl	28ddc <net_buf_simple_add_le16>
		net_buf_simple_add_u8(&msg, mod->pub->ttl);
   10dde:	6823      	ldr	r3, [r4, #0]
   10de0:	a802      	add	r0, sp, #8
   10de2:	7a19      	ldrb	r1, [r3, #8]
   10de4:	f017 fff3 	bl	28dce <net_buf_simple_add_u8>
		net_buf_simple_add_u8(&msg, mod->pub->period);
   10de8:	6823      	ldr	r3, [r4, #0]
   10dea:	a802      	add	r0, sp, #8
   10dec:	7a99      	ldrb	r1, [r3, #10]
   10dee:	f017 ffee 	bl	28dce <net_buf_simple_add_u8>
		net_buf_simple_add_u8(&msg, mod->pub->retransmit);
   10df2:	6823      	ldr	r3, [r4, #0]
   10df4:	a802      	add	r0, sp, #8
   10df6:	7a59      	ldrb	r1, [r3, #9]
   10df8:	f017 ffe9 	bl	28dce <net_buf_simple_add_u8>
   10dfc:	e7bf      	b.n	10d7e <send_mod_pub_status.isra.0+0x56>
		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
   10dfe:	2102      	movs	r1, #2
   10e00:	a802      	add	r0, sp, #8
   10e02:	f00e fa69 	bl	1f2d8 <net_buf_simple_add>
   10e06:	2202      	movs	r2, #2
   10e08:	e7c1      	b.n	10d8e <send_mod_pub_status.isra.0+0x66>
   10e0a:	bf00      	nop
   10e0c:	00029928 	.word	0x00029928
   10e10:	00029830 	.word	0x00029830
   10e14:	0002de39 	.word	0x0002de39

00010e18 <mod_app_get>:
{
   10e18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10e1c:	4615      	mov	r5, r2
   10e1e:	b08d      	sub	sp, #52	; 0x34
	NET_BUF_SIMPLE_DEFINE(msg,
   10e20:	ab07      	add	r3, sp, #28
   10e22:	f44f 1298 	mov.w	r2, #1245184	; 0x130000
{
   10e26:	4607      	mov	r7, r0
	elem_addr = net_buf_simple_pull_le16(buf);
   10e28:	4628      	mov	r0, r5
	NET_BUF_SIMPLE_DEFINE(msg,
   10e2a:	e9cd 2305 	strd	r2, r3, [sp, #20]
   10e2e:	9304      	str	r3, [sp, #16]
{
   10e30:	4688      	mov	r8, r1
	elem_addr = net_buf_simple_pull_le16(buf);
   10e32:	f017 ff98 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   10e36:	b203      	sxth	r3, r0
   10e38:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   10e3a:	4606      	mov	r6, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   10e3c:	dc0c      	bgt.n	10e58 <mod_app_get+0x40>
   10e3e:	4933      	ldr	r1, [pc, #204]	; (10f0c <mod_app_get+0xf4>)
   10e40:	4b33      	ldr	r3, [pc, #204]	; (10f10 <mod_app_get+0xf8>)
		BT_WARN("Prohibited element address");
   10e42:	4834      	ldr	r0, [pc, #208]	; (10f14 <mod_app_get+0xfc>)
   10e44:	1ac9      	subs	r1, r1, r3
   10e46:	08c9      	lsrs	r1, r1, #3
   10e48:	0189      	lsls	r1, r1, #6
   10e4a:	f041 0102 	orr.w	r1, r1, #2
		BT_ERR("Unable to send Model Application List message");
   10e4e:	f013 f8b9 	bl	23fc4 <log_0>
}
   10e52:	b00d      	add	sp, #52	; 0x34
   10e54:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	mod_id = buf->data;
   10e58:	f8d5 9000 	ldr.w	r9, [r5]
	elem = bt_mesh_elem_find(elem_addr);
   10e5c:	f7fe fe2c 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   10e60:	4604      	mov	r4, r0
   10e62:	2800      	cmp	r0, #0
   10e64:	d143      	bne.n	10eee <mod_app_get+0xd6>
		vnd = (buf->len == 4U);
   10e66:	88ab      	ldrh	r3, [r5, #4]
   10e68:	1f1a      	subs	r2, r3, #4
   10e6a:	4253      	negs	r3, r2
   10e6c:	4153      	adcs	r3, r2
   10e6e:	f88d 300f 	strb.w	r3, [sp, #15]
		status = STATUS_INVALID_ADDRESS;
   10e72:	2501      	movs	r5, #1
	if (vnd) {
   10e74:	f89d 300f 	ldrb.w	r3, [sp, #15]
   10e78:	2b00      	cmp	r3, #0
   10e7a:	d042      	beq.n	10f02 <mod_app_get+0xea>
		bt_mesh_model_msg_init(&msg, OP_VND_MOD_APP_LIST);
   10e7c:	f248 014e 	movw	r1, #32846	; 0x804e
		bt_mesh_model_msg_init(&msg, OP_SIG_MOD_APP_LIST);
   10e80:	a804      	add	r0, sp, #16
   10e82:	f016 fc95 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   10e86:	4629      	mov	r1, r5
   10e88:	a804      	add	r0, sp, #16
   10e8a:	f017 ffa0 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, elem_addr);
   10e8e:	4631      	mov	r1, r6
   10e90:	a804      	add	r0, sp, #16
   10e92:	f017 ffa3 	bl	28ddc <net_buf_simple_add_le16>
	if (vnd) {
   10e96:	f89d 300f 	ldrb.w	r3, [sp, #15]
   10e9a:	2b00      	cmp	r3, #0
   10e9c:	d034      	beq.n	10f08 <mod_app_get+0xf0>
		net_buf_simple_add_mem(&msg, mod_id, 4);
   10e9e:	2204      	movs	r2, #4
		net_buf_simple_add_mem(&msg, mod_id, 2);
   10ea0:	4649      	mov	r1, r9
   10ea2:	a804      	add	r0, sp, #16
   10ea4:	f017 ff87 	bl	28db6 <net_buf_simple_add_mem>
	if (mod) {
   10ea8:	b17c      	cbz	r4, 10eca <mod_app_get+0xb2>
			if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   10eaa:	89a1      	ldrh	r1, [r4, #12]
   10eac:	f64f 73ff 	movw	r3, #65535	; 0xffff
   10eb0:	4299      	cmp	r1, r3
   10eb2:	d002      	beq.n	10eba <mod_app_get+0xa2>
				net_buf_simple_add_le16(&msg, mod->keys[i]);
   10eb4:	a804      	add	r0, sp, #16
   10eb6:	f017 ff91 	bl	28ddc <net_buf_simple_add_le16>
			if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   10eba:	89e1      	ldrh	r1, [r4, #14]
   10ebc:	f64f 73ff 	movw	r3, #65535	; 0xffff
   10ec0:	4299      	cmp	r1, r3
   10ec2:	d002      	beq.n	10eca <mod_app_get+0xb2>
				net_buf_simple_add_le16(&msg, mod->keys[i]);
   10ec4:	a804      	add	r0, sp, #16
   10ec6:	f017 ff89 	bl	28ddc <net_buf_simple_add_le16>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10eca:	2300      	movs	r3, #0
   10ecc:	9300      	str	r3, [sp, #0]
   10ece:	aa04      	add	r2, sp, #16
   10ed0:	4641      	mov	r1, r8
   10ed2:	4638      	mov	r0, r7
   10ed4:	f016 fc95 	bl	27802 <bt_mesh_model_send>
   10ed8:	2800      	cmp	r0, #0
   10eda:	d0ba      	beq.n	10e52 <mod_app_get+0x3a>
   10edc:	490b      	ldr	r1, [pc, #44]	; (10f0c <mod_app_get+0xf4>)
   10ede:	4b0c      	ldr	r3, [pc, #48]	; (10f10 <mod_app_get+0xf8>)
		BT_ERR("Unable to send Model Application List message");
   10ee0:	480d      	ldr	r0, [pc, #52]	; (10f18 <mod_app_get+0x100>)
   10ee2:	1ac9      	subs	r1, r1, r3
   10ee4:	08c9      	lsrs	r1, r1, #3
   10ee6:	0189      	lsls	r1, r1, #6
   10ee8:	f041 0101 	orr.w	r1, r1, #1
   10eec:	e7af      	b.n	10e4e <mod_app_get+0x36>
	mod = get_model(elem, buf, &vnd);
   10eee:	4629      	mov	r1, r5
   10ef0:	f10d 020f 	add.w	r2, sp, #15
   10ef4:	f016 fd58 	bl	279a8 <get_model>
		status = STATUS_INVALID_MODEL;
   10ef8:	1e04      	subs	r4, r0, #0
   10efa:	bf14      	ite	ne
   10efc:	2500      	movne	r5, #0
   10efe:	2502      	moveq	r5, #2
   10f00:	e7b8      	b.n	10e74 <mod_app_get+0x5c>
		bt_mesh_model_msg_init(&msg, OP_SIG_MOD_APP_LIST);
   10f02:	f248 014c 	movw	r1, #32844	; 0x804c
   10f06:	e7bb      	b.n	10e80 <mod_app_get+0x68>
		net_buf_simple_add_mem(&msg, mod_id, 2);
   10f08:	2202      	movs	r2, #2
   10f0a:	e7c9      	b.n	10ea0 <mod_app_get+0x88>
   10f0c:	00029928 	.word	0x00029928
   10f10:	00029830 	.word	0x00029830
   10f14:	0002dc69 	.word	0x0002dc69
   10f18:	0002de61 	.word	0x0002de61

00010f1c <mod_app_unbind>:
{
   10f1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10f20:	4614      	mov	r4, r2
   10f22:	b08b      	sub	sp, #44	; 0x2c
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_APP_STATUS, 9);
   10f24:	ab06      	add	r3, sp, #24
   10f26:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
{
   10f2a:	4607      	mov	r7, r0
	elem_addr = net_buf_simple_pull_le16(buf);
   10f2c:	4620      	mov	r0, r4
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_APP_STATUS, 9);
   10f2e:	e9cd 2304 	strd	r2, r3, [sp, #16]
   10f32:	9303      	str	r3, [sp, #12]
{
   10f34:	4688      	mov	r8, r1
	elem_addr = net_buf_simple_pull_le16(buf);
   10f36:	f017 ff16 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   10f3a:	b203      	sxth	r3, r0
   10f3c:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   10f3e:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   10f40:	dc0c      	bgt.n	10f5c <mod_app_unbind+0x40>
   10f42:	4927      	ldr	r1, [pc, #156]	; (10fe0 <mod_app_unbind+0xc4>)
   10f44:	4b27      	ldr	r3, [pc, #156]	; (10fe4 <mod_app_unbind+0xc8>)
		BT_WARN("Prohibited element address");
   10f46:	4828      	ldr	r0, [pc, #160]	; (10fe8 <mod_app_unbind+0xcc>)
   10f48:	1ac9      	subs	r1, r1, r3
   10f4a:	08c9      	lsrs	r1, r1, #3
   10f4c:	0189      	lsls	r1, r1, #6
   10f4e:	f041 0102 	orr.w	r1, r1, #2
		BT_ERR("Unable to send Model App Unbind Status response");
   10f52:	f013 f837 	bl	23fc4 <log_0>
}
   10f56:	b00b      	add	sp, #44	; 0x2c
   10f58:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	key_app_idx = net_buf_simple_pull_le16(buf);
   10f5c:	4620      	mov	r0, r4
   10f5e:	f017 ff02 	bl	28d66 <net_buf_simple_pull_le16>
   10f62:	4606      	mov	r6, r0
	elem = bt_mesh_elem_find(elem_addr);
   10f64:	4628      	mov	r0, r5
	mod_id = buf->data;
   10f66:	f8d4 9000 	ldr.w	r9, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   10f6a:	f7fe fda5 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   10f6e:	bb08      	cbnz	r0, 10fb4 <mod_app_unbind+0x98>
		vnd = (buf->len == 4U);
   10f70:	88a3      	ldrh	r3, [r4, #4]
   10f72:	1f1a      	subs	r2, r3, #4
   10f74:	4253      	negs	r3, r2
   10f76:	4153      	adcs	r3, r2
   10f78:	f88d 300b 	strb.w	r3, [sp, #11]
		status = STATUS_INVALID_ADDRESS;
   10f7c:	2001      	movs	r0, #1
	create_mod_app_status(&msg, mod, vnd, elem_addr, key_app_idx, status,
   10f7e:	e9cd 0900 	strd	r0, r9, [sp]
   10f82:	f89d 100b 	ldrb.w	r1, [sp, #11]
   10f86:	4633      	mov	r3, r6
   10f88:	462a      	mov	r2, r5
   10f8a:	a803      	add	r0, sp, #12
   10f8c:	f016 fce1 	bl	27952 <create_mod_app_status.isra.0>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   10f90:	2300      	movs	r3, #0
   10f92:	9300      	str	r3, [sp, #0]
   10f94:	aa03      	add	r2, sp, #12
   10f96:	4641      	mov	r1, r8
   10f98:	4638      	mov	r0, r7
   10f9a:	f016 fc32 	bl	27802 <bt_mesh_model_send>
   10f9e:	2800      	cmp	r0, #0
   10fa0:	d0d9      	beq.n	10f56 <mod_app_unbind+0x3a>
   10fa2:	490f      	ldr	r1, [pc, #60]	; (10fe0 <mod_app_unbind+0xc4>)
   10fa4:	4b0f      	ldr	r3, [pc, #60]	; (10fe4 <mod_app_unbind+0xc8>)
		BT_ERR("Unable to send Model App Unbind Status response");
   10fa6:	4811      	ldr	r0, [pc, #68]	; (10fec <mod_app_unbind+0xd0>)
   10fa8:	1ac9      	subs	r1, r1, r3
   10faa:	08c9      	lsrs	r1, r1, #3
   10fac:	0189      	lsls	r1, r1, #6
   10fae:	f041 0101 	orr.w	r1, r1, #1
   10fb2:	e7ce      	b.n	10f52 <mod_app_unbind+0x36>
	mod = get_model(elem, buf, &vnd);
   10fb4:	4621      	mov	r1, r4
   10fb6:	f10d 020b 	add.w	r2, sp, #11
   10fba:	f016 fcf5 	bl	279a8 <get_model>
	if (!mod) {
   10fbe:	4604      	mov	r4, r0
   10fc0:	b148      	cbz	r0, 10fd6 <mod_app_unbind+0xba>
	if (!app_key_is_valid(key_idx)) {
   10fc2:	4630      	mov	r0, r6
   10fc4:	f7fe fff8 	bl	ffb8 <app_key_is_valid>
   10fc8:	b138      	cbz	r0, 10fda <mod_app_unbind+0xbe>
   10fca:	2201      	movs	r2, #1
   10fcc:	4631      	mov	r1, r6
   10fce:	4620      	mov	r0, r4
   10fd0:	f016 fc8f 	bl	278f2 <mod_unbind.part.0>
   10fd4:	e7d3      	b.n	10f7e <mod_app_unbind+0x62>
		status = STATUS_INVALID_MODEL;
   10fd6:	2002      	movs	r0, #2
   10fd8:	e7d1      	b.n	10f7e <mod_app_unbind+0x62>
		return STATUS_INVALID_APPKEY;
   10fda:	2003      	movs	r0, #3
   10fdc:	e7cf      	b.n	10f7e <mod_app_unbind+0x62>
   10fde:	bf00      	nop
   10fe0:	00029928 	.word	0x00029928
   10fe4:	00029830 	.word	0x00029830
   10fe8:	0002dc69 	.word	0x0002dc69
   10fec:	0002de8f 	.word	0x0002de8f

00010ff0 <mod_app_bind>:
{
   10ff0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10ff4:	4614      	mov	r4, r2
   10ff6:	b08b      	sub	sp, #44	; 0x2c
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_APP_STATUS, 9);
   10ff8:	ab06      	add	r3, sp, #24
   10ffa:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
{
   10ffe:	4607      	mov	r7, r0
	elem_addr = net_buf_simple_pull_le16(buf);
   11000:	4620      	mov	r0, r4
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_APP_STATUS, 9);
   11002:	e9cd 2304 	strd	r2, r3, [sp, #16]
   11006:	9303      	str	r3, [sp, #12]
{
   11008:	4688      	mov	r8, r1
	elem_addr = net_buf_simple_pull_le16(buf);
   1100a:	f017 feac 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   1100e:	b203      	sxth	r3, r0
   11010:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   11012:	4606      	mov	r6, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11014:	dc0c      	bgt.n	11030 <mod_app_bind+0x40>
   11016:	4938      	ldr	r1, [pc, #224]	; (110f8 <mod_app_bind+0x108>)
   11018:	4b38      	ldr	r3, [pc, #224]	; (110fc <mod_app_bind+0x10c>)
		BT_WARN("Prohibited element address");
   1101a:	4839      	ldr	r0, [pc, #228]	; (11100 <mod_app_bind+0x110>)
   1101c:	1ac9      	subs	r1, r1, r3
   1101e:	08c9      	lsrs	r1, r1, #3
   11020:	0189      	lsls	r1, r1, #6
   11022:	f041 0102 	orr.w	r1, r1, #2
		BT_ERR("Unable to send Model App Bind Status response");
   11026:	f012 ffcd 	bl	23fc4 <log_0>
}
   1102a:	b00b      	add	sp, #44	; 0x2c
   1102c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	key_app_idx = net_buf_simple_pull_le16(buf);
   11030:	4620      	mov	r0, r4
   11032:	f017 fe98 	bl	28d66 <net_buf_simple_pull_le16>
   11036:	4605      	mov	r5, r0
	elem = bt_mesh_elem_find(elem_addr);
   11038:	4630      	mov	r0, r6
	mod_id = buf->data;
   1103a:	f8d4 9000 	ldr.w	r9, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   1103e:	f7fe fd3b 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   11042:	bb08      	cbnz	r0, 11088 <mod_app_bind+0x98>
		vnd = (buf->len == 4U);
   11044:	88a3      	ldrh	r3, [r4, #4]
   11046:	1f1a      	subs	r2, r3, #4
   11048:	4253      	negs	r3, r2
   1104a:	4153      	adcs	r3, r2
   1104c:	f88d 300b 	strb.w	r3, [sp, #11]
		status = STATUS_INVALID_ADDRESS;
   11050:	2301      	movs	r3, #1
	create_mod_app_status(&msg, mod, vnd, elem_addr, key_app_idx, status,
   11052:	e9cd 3900 	strd	r3, r9, [sp]
   11056:	f89d 100b 	ldrb.w	r1, [sp, #11]
   1105a:	462b      	mov	r3, r5
   1105c:	4632      	mov	r2, r6
   1105e:	a803      	add	r0, sp, #12
   11060:	f016 fc77 	bl	27952 <create_mod_app_status.isra.0>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   11064:	2300      	movs	r3, #0
   11066:	9300      	str	r3, [sp, #0]
   11068:	aa03      	add	r2, sp, #12
   1106a:	4641      	mov	r1, r8
   1106c:	4638      	mov	r0, r7
   1106e:	f016 fbc8 	bl	27802 <bt_mesh_model_send>
   11072:	2800      	cmp	r0, #0
   11074:	d0d9      	beq.n	1102a <mod_app_bind+0x3a>
   11076:	4920      	ldr	r1, [pc, #128]	; (110f8 <mod_app_bind+0x108>)
   11078:	4b20      	ldr	r3, [pc, #128]	; (110fc <mod_app_bind+0x10c>)
		BT_ERR("Unable to send Model App Bind Status response");
   1107a:	4822      	ldr	r0, [pc, #136]	; (11104 <mod_app_bind+0x114>)
   1107c:	1ac9      	subs	r1, r1, r3
   1107e:	08c9      	lsrs	r1, r1, #3
   11080:	0189      	lsls	r1, r1, #6
   11082:	f041 0101 	orr.w	r1, r1, #1
   11086:	e7ce      	b.n	11026 <mod_app_bind+0x36>
	mod = get_model(elem, buf, &vnd);
   11088:	4621      	mov	r1, r4
   1108a:	f10d 020b 	add.w	r2, sp, #11
   1108e:	f016 fc8b 	bl	279a8 <get_model>
	if (!mod) {
   11092:	4604      	mov	r4, r0
   11094:	b348      	cbz	r0, 110ea <mod_app_bind+0xfa>
	if (model == mod) {
   11096:	42b8      	cmp	r0, r7
   11098:	d10b      	bne.n	110b2 <mod_app_bind+0xc2>
   1109a:	4918      	ldr	r1, [pc, #96]	; (110fc <mod_app_bind+0x10c>)
   1109c:	4b16      	ldr	r3, [pc, #88]	; (110f8 <mod_app_bind+0x108>)
		BT_ERR("Client tried to bind AppKey to Configuration Model");
   1109e:	481a      	ldr	r0, [pc, #104]	; (11108 <mod_app_bind+0x118>)
   110a0:	1a5b      	subs	r3, r3, r1
   110a2:	08db      	lsrs	r3, r3, #3
   110a4:	019b      	lsls	r3, r3, #6
   110a6:	f043 0101 	orr.w	r1, r3, #1
   110aa:	f012 ff8b 	bl	23fc4 <log_0>
		status = STATUS_CANNOT_BIND;
   110ae:	230d      	movs	r3, #13
		goto send_status;
   110b0:	e7cf      	b.n	11052 <mod_app_bind+0x62>
	if (!app_key_is_valid(key_idx)) {
   110b2:	4628      	mov	r0, r5
   110b4:	f7fe ff80 	bl	ffb8 <app_key_is_valid>
   110b8:	b1c8      	cbz	r0, 110ee <mod_app_bind+0xfe>
		if (model->keys[i] == key_idx) {
   110ba:	89a1      	ldrh	r1, [r4, #12]
   110bc:	428d      	cmp	r5, r1
   110be:	d010      	beq.n	110e2 <mod_app_bind+0xf2>
   110c0:	89e2      	ldrh	r2, [r4, #14]
   110c2:	4295      	cmp	r5, r2
   110c4:	d00d      	beq.n	110e2 <mod_app_bind+0xf2>
		if (model->keys[i] == BT_MESH_KEY_UNUSED) {
   110c6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   110ca:	4299      	cmp	r1, r3
   110cc:	d00b      	beq.n	110e6 <mod_app_bind+0xf6>
   110ce:	429a      	cmp	r2, r3
   110d0:	d10f      	bne.n	110f2 <mod_app_bind+0x102>
	for (i = 0; i < ARRAY_SIZE(model->keys); i++) {
   110d2:	2301      	movs	r3, #1
			model->keys[i] = key_idx;
   110d4:	3304      	adds	r3, #4
   110d6:	eb04 0343 	add.w	r3, r4, r3, lsl #1
				bt_mesh_store_mod_bind(model);
   110da:	4620      	mov	r0, r4
			model->keys[i] = key_idx;
   110dc:	809d      	strh	r5, [r3, #4]
				bt_mesh_store_mod_bind(model);
   110de:	f016 fe28 	bl	27d32 <bt_mesh_store_mod_bind>
			return STATUS_SUCCESS;
   110e2:	2300      	movs	r3, #0
   110e4:	e7b5      	b.n	11052 <mod_app_bind+0x62>
	for (i = 0; i < ARRAY_SIZE(model->keys); i++) {
   110e6:	2300      	movs	r3, #0
   110e8:	e7f4      	b.n	110d4 <mod_app_bind+0xe4>
		status = STATUS_INVALID_MODEL;
   110ea:	2302      	movs	r3, #2
   110ec:	e7b1      	b.n	11052 <mod_app_bind+0x62>
		return STATUS_INVALID_APPKEY;
   110ee:	2303      	movs	r3, #3
   110f0:	e7af      	b.n	11052 <mod_app_bind+0x62>
	return STATUS_INSUFF_RESOURCES;
   110f2:	2305      	movs	r3, #5
   110f4:	e7ad      	b.n	11052 <mod_app_bind+0x62>
   110f6:	bf00      	nop
   110f8:	00029928 	.word	0x00029928
   110fc:	00029830 	.word	0x00029830
   11100:	0002dc69 	.word	0x0002dc69
   11104:	0002def2 	.word	0x0002def2
   11108:	0002debf 	.word	0x0002debf

0001110c <mod_pub_set>:
{
   1110c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11110:	4680      	mov	r8, r0
   11112:	b08b      	sub	sp, #44	; 0x2c
	elem_addr = net_buf_simple_pull_le16(buf);
   11114:	4610      	mov	r0, r2
{
   11116:	4689      	mov	r9, r1
   11118:	4693      	mov	fp, r2
	elem_addr = net_buf_simple_pull_le16(buf);
   1111a:	f017 fe24 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   1111e:	b203      	sxth	r3, r0
   11120:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   11122:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11124:	dc0c      	bgt.n	11140 <mod_pub_set+0x34>
   11126:	4934      	ldr	r1, [pc, #208]	; (111f8 <mod_pub_set+0xec>)
   11128:	4b34      	ldr	r3, [pc, #208]	; (111fc <mod_pub_set+0xf0>)
		BT_WARN("Prohibited element address");
   1112a:	4835      	ldr	r0, [pc, #212]	; (11200 <mod_pub_set+0xf4>)
   1112c:	1ac9      	subs	r1, r1, r3
   1112e:	08c9      	lsrs	r1, r1, #3
   11130:	0189      	lsls	r1, r1, #6
   11132:	f041 0102 	orr.w	r1, r1, #2
   11136:	f012 ff45 	bl	23fc4 <log_0>
}
   1113a:	b00b      	add	sp, #44	; 0x2c
   1113c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	pub_addr = net_buf_simple_pull_le16(buf);
   11140:	4658      	mov	r0, fp
   11142:	f017 fe10 	bl	28d66 <net_buf_simple_pull_le16>
   11146:	4606      	mov	r6, r0
	pub_app_idx = net_buf_simple_pull_le16(buf);
   11148:	4658      	mov	r0, fp
   1114a:	f017 fe0c 	bl	28d66 <net_buf_simple_pull_le16>
   1114e:	4607      	mov	r7, r0
	pub_ttl = net_buf_simple_pull_u8(buf);
   11150:	4658      	mov	r0, fp
   11152:	f017 fe00 	bl	28d56 <net_buf_simple_pull_u8>
	if (pub_ttl > BT_MESH_TTL_MAX && pub_ttl != BT_MESH_TTL_DEFAULT) {
   11156:	f1a0 0280 	sub.w	r2, r0, #128	; 0x80
   1115a:	b2d2      	uxtb	r2, r2
   1115c:	2a7e      	cmp	r2, #126	; 0x7e
	pub_ttl = net_buf_simple_pull_u8(buf);
   1115e:	4682      	mov	sl, r0
	if (pub_ttl > BT_MESH_TTL_MAX && pub_ttl != BT_MESH_TTL_DEFAULT) {
   11160:	d80b      	bhi.n	1117a <mod_pub_set+0x6e>
   11162:	4926      	ldr	r1, [pc, #152]	; (111fc <mod_pub_set+0xf0>)
   11164:	4a24      	ldr	r2, [pc, #144]	; (111f8 <mod_pub_set+0xec>)
   11166:	1a52      	subs	r2, r2, r1
   11168:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Invalid TTL value 0x%02x", pub_ttl);
   1116a:	0192      	lsls	r2, r2, #6
   1116c:	4601      	mov	r1, r0
   1116e:	f042 0201 	orr.w	r2, r2, #1
   11172:	4824      	ldr	r0, [pc, #144]	; (11204 <mod_pub_set+0xf8>)
   11174:	f012 ff33 	bl	23fde <log_1>
		return;
   11178:	e7df      	b.n	1113a <mod_pub_set+0x2e>
	pub_period = net_buf_simple_pull_u8(buf);
   1117a:	4658      	mov	r0, fp
   1117c:	f017 fdeb 	bl	28d56 <net_buf_simple_pull_u8>
   11180:	9006      	str	r0, [sp, #24]
	retransmit = net_buf_simple_pull_u8(buf);
   11182:	4658      	mov	r0, fp
   11184:	f017 fde7 	bl	28d56 <net_buf_simple_pull_u8>
	mod_id = buf->data;
   11188:	f8db 3000 	ldr.w	r3, [fp]
	retransmit = net_buf_simple_pull_u8(buf);
   1118c:	9007      	str	r0, [sp, #28]
	elem = bt_mesh_elem_find(elem_addr);
   1118e:	4628      	mov	r0, r5
	mod_id = buf->data;
   11190:	9305      	str	r3, [sp, #20]
	elem = bt_mesh_elem_find(elem_addr);
   11192:	f7fe fc91 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   11196:	4604      	mov	r4, r0
   11198:	b9b0      	cbnz	r0, 111c8 <mod_pub_set+0xbc>
		vnd = (buf->len == 4U);
   1119a:	f8bb 3004 	ldrh.w	r3, [fp, #4]
   1119e:	1f1a      	subs	r2, r3, #4
   111a0:	4253      	negs	r3, r2
   111a2:	4153      	adcs	r3, r2
   111a4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
		status = STATUS_INVALID_ADDRESS;
   111a8:	2001      	movs	r0, #1
	send_mod_pub_status(model, ctx, elem_addr, pub_addr, vnd, mod,
   111aa:	9b05      	ldr	r3, [sp, #20]
   111ac:	3408      	adds	r4, #8
   111ae:	e9cd 0302 	strd	r0, r3, [sp, #8]
   111b2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   111b6:	9300      	str	r3, [sp, #0]
   111b8:	9401      	str	r4, [sp, #4]
   111ba:	4633      	mov	r3, r6
   111bc:	462a      	mov	r2, r5
   111be:	4649      	mov	r1, r9
   111c0:	4640      	mov	r0, r8
   111c2:	f7ff fdb1 	bl	10d28 <send_mod_pub_status.isra.0>
   111c6:	e7b8      	b.n	1113a <mod_pub_set+0x2e>
	mod = get_model(elem, buf, &vnd);
   111c8:	f10d 0227 	add.w	r2, sp, #39	; 0x27
   111cc:	4659      	mov	r1, fp
   111ce:	f016 fbeb 	bl	279a8 <get_model>
	if (!mod) {
   111d2:	4604      	mov	r4, r0
   111d4:	b170      	cbz	r0, 111f4 <mod_pub_set+0xe8>
	status = _mod_pub_set(mod, pub_addr, pub_app_idx, cred_flag, pub_ttl,
   111d6:	9b07      	ldr	r3, [sp, #28]
   111d8:	9302      	str	r3, [sp, #8]
   111da:	9b06      	ldr	r3, [sp, #24]
   111dc:	2201      	movs	r2, #1
   111de:	e9cd a300 	strd	sl, r3, [sp]
   111e2:	9203      	str	r2, [sp, #12]
   111e4:	f3c7 3300 	ubfx	r3, r7, #12, #1
   111e8:	f3c7 020b 	ubfx	r2, r7, #0, #12
   111ec:	4631      	mov	r1, r6
   111ee:	f7fe ff01 	bl	fff4 <_mod_pub_set>
   111f2:	e7da      	b.n	111aa <mod_pub_set+0x9e>
		status = STATUS_INVALID_MODEL;
   111f4:	2002      	movs	r0, #2
   111f6:	e7d8      	b.n	111aa <mod_pub_set+0x9e>
   111f8:	00029928 	.word	0x00029928
   111fc:	00029830 	.word	0x00029830
   11200:	0002dc69 	.word	0x0002dc69
   11204:	0002df20 	.word	0x0002df20

00011208 <mod_sub_del_all>:
{
   11208:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1120c:	4606      	mov	r6, r0
   1120e:	b086      	sub	sp, #24
	elem_addr = net_buf_simple_pull_le16(buf);
   11210:	4610      	mov	r0, r2
{
   11212:	460f      	mov	r7, r1
   11214:	4614      	mov	r4, r2
	elem_addr = net_buf_simple_pull_le16(buf);
   11216:	f017 fda6 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   1121a:	b203      	sxth	r3, r0
   1121c:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   1121e:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11220:	dc0c      	bgt.n	1123c <mod_sub_del_all+0x34>
   11222:	491c      	ldr	r1, [pc, #112]	; (11294 <mod_sub_del_all+0x8c>)
   11224:	4b1c      	ldr	r3, [pc, #112]	; (11298 <mod_sub_del_all+0x90>)
		BT_WARN("Prohibited element address");
   11226:	481d      	ldr	r0, [pc, #116]	; (1129c <mod_sub_del_all+0x94>)
   11228:	1ac9      	subs	r1, r1, r3
   1122a:	08c9      	lsrs	r1, r1, #3
   1122c:	0189      	lsls	r1, r1, #6
   1122e:	f041 0102 	orr.w	r1, r1, #2
   11232:	f012 fec7 	bl	23fc4 <log_0>
}
   11236:	b006      	add	sp, #24
   11238:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	mod_id = buf->data;
   1123c:	f8d4 8000 	ldr.w	r8, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   11240:	f7fe fc3a 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   11244:	b990      	cbnz	r0, 1126c <mod_sub_del_all+0x64>
		vnd = (buf->len == 4U);
   11246:	88a3      	ldrh	r3, [r4, #4]
   11248:	1f1a      	subs	r2, r3, #4
   1124a:	4253      	negs	r3, r2
   1124c:	4153      	adcs	r3, r2
   1124e:	f88d 3017 	strb.w	r3, [sp, #23]
		status = STATUS_INVALID_ADDRESS;
   11252:	2201      	movs	r2, #1
	send_mod_sub_status(model, ctx, status, elem_addr,
   11254:	f89d 3017 	ldrb.w	r3, [sp, #23]
   11258:	e9cd 8301 	strd	r8, r3, [sp, #4]
   1125c:	2300      	movs	r3, #0
   1125e:	9300      	str	r3, [sp, #0]
   11260:	4639      	mov	r1, r7
   11262:	462b      	mov	r3, r5
   11264:	4630      	mov	r0, r6
   11266:	f7ff f84f 	bl	10308 <send_mod_sub_status>
   1126a:	e7e4      	b.n	11236 <mod_sub_del_all+0x2e>
	mod = get_model(elem, buf, &vnd);
   1126c:	4621      	mov	r1, r4
   1126e:	f10d 0217 	add.w	r2, sp, #23
   11272:	f016 fb99 	bl	279a8 <get_model>
	if (!mod) {
   11276:	4604      	mov	r4, r0
   11278:	b150      	cbz	r0, 11290 <mod_sub_del_all+0x88>
	bt_mesh_model_tree_walk(bt_mesh_model_root(mod), mod_sub_clear_visitor,
   1127a:	f016 fb10 	bl	2789e <bt_mesh_model_root>
   1127e:	2200      	movs	r2, #0
   11280:	4907      	ldr	r1, [pc, #28]	; (112a0 <mod_sub_del_all+0x98>)
   11282:	f016 fb0d 	bl	278a0 <bt_mesh_model_tree_walk>
		bt_mesh_store_mod_sub(mod);
   11286:	4620      	mov	r0, r4
   11288:	f016 fd5a 	bl	27d40 <bt_mesh_store_mod_sub>
	status = STATUS_SUCCESS;
   1128c:	2200      	movs	r2, #0
   1128e:	e7e1      	b.n	11254 <mod_sub_del_all+0x4c>
		status = STATUS_INVALID_MODEL;
   11290:	2202      	movs	r2, #2
   11292:	e7df      	b.n	11254 <mod_sub_del_all+0x4c>
   11294:	00029928 	.word	0x00029928
   11298:	00029830 	.word	0x00029830
   1129c:	0002dc69 	.word	0x0002dc69
   112a0:	00027b15 	.word	0x00027b15

000112a4 <mod_sub_overwrite>:
{
   112a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   112a8:	4607      	mov	r7, r0
   112aa:	b087      	sub	sp, #28
	elem_addr = net_buf_simple_pull_le16(buf);
   112ac:	4610      	mov	r0, r2
{
   112ae:	4688      	mov	r8, r1
   112b0:	4614      	mov	r4, r2
	elem_addr = net_buf_simple_pull_le16(buf);
   112b2:	f017 fd58 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   112b6:	b203      	sxth	r3, r0
   112b8:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   112ba:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   112bc:	dc0c      	bgt.n	112d8 <mod_sub_overwrite+0x34>
   112be:	4922      	ldr	r1, [pc, #136]	; (11348 <mod_sub_overwrite+0xa4>)
   112c0:	4b22      	ldr	r3, [pc, #136]	; (1134c <mod_sub_overwrite+0xa8>)
		BT_WARN("Prohibited element address");
   112c2:	4823      	ldr	r0, [pc, #140]	; (11350 <mod_sub_overwrite+0xac>)
   112c4:	1ac9      	subs	r1, r1, r3
   112c6:	08c9      	lsrs	r1, r1, #3
   112c8:	0189      	lsls	r1, r1, #6
   112ca:	f041 0102 	orr.w	r1, r1, #2
   112ce:	f012 fe79 	bl	23fc4 <log_0>
}
   112d2:	b007      	add	sp, #28
   112d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	sub_addr = net_buf_simple_pull_le16(buf);
   112d8:	4620      	mov	r0, r4
   112da:	f017 fd44 	bl	28d66 <net_buf_simple_pull_le16>
   112de:	4606      	mov	r6, r0
	elem = bt_mesh_elem_find(elem_addr);
   112e0:	4628      	mov	r0, r5
	mod_id = buf->data;
   112e2:	f8d4 9000 	ldr.w	r9, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   112e6:	f7fe fbe7 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   112ea:	b938      	cbnz	r0, 112fc <mod_sub_overwrite+0x58>
		vnd = (buf->len == 4U);
   112ec:	88a3      	ldrh	r3, [r4, #4]
   112ee:	1f1a      	subs	r2, r3, #4
   112f0:	4253      	negs	r3, r2
   112f2:	4153      	adcs	r3, r2
   112f4:	f88d 3017 	strb.w	r3, [sp, #23]
		status = STATUS_INVALID_ADDRESS;
   112f8:	2201      	movs	r2, #1
   112fa:	e017      	b.n	1132c <mod_sub_overwrite+0x88>
	mod = get_model(elem, buf, &vnd);
   112fc:	4621      	mov	r1, r4
   112fe:	f10d 0217 	add.w	r2, sp, #23
   11302:	f016 fb51 	bl	279a8 <get_model>
	if (!mod) {
   11306:	4604      	mov	r4, r0
   11308:	b1d8      	cbz	r0, 11342 <mod_sub_overwrite+0x9e>
	if (!BT_MESH_ADDR_IS_GROUP(sub_addr)) {
   1130a:	f506 4380 	add.w	r3, r6, #16384	; 0x4000
   1130e:	b29b      	uxth	r3, r3
   11310:	f5b3 5f7c 	cmp.w	r3, #16128	; 0x3f00
   11314:	d8f0      	bhi.n	112f8 <mod_sub_overwrite+0x54>
		bt_mesh_model_tree_walk(bt_mesh_model_root(mod),
   11316:	f016 fac2 	bl	2789e <bt_mesh_model_root>
   1131a:	2200      	movs	r2, #0
   1131c:	490d      	ldr	r1, [pc, #52]	; (11354 <mod_sub_overwrite+0xb0>)
   1131e:	f016 fabf 	bl	278a0 <bt_mesh_model_tree_walk>
		mod->groups[0] = sub_addr;
   11322:	8226      	strh	r6, [r4, #16]
			bt_mesh_store_mod_sub(mod);
   11324:	4620      	mov	r0, r4
   11326:	f016 fd0b 	bl	27d40 <bt_mesh_store_mod_sub>
		status = STATUS_SUCCESS;
   1132a:	2200      	movs	r2, #0
	send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   1132c:	f89d 3017 	ldrb.w	r3, [sp, #23]
   11330:	9600      	str	r6, [sp, #0]
   11332:	e9cd 9301 	strd	r9, r3, [sp, #4]
   11336:	4641      	mov	r1, r8
   11338:	462b      	mov	r3, r5
   1133a:	4638      	mov	r0, r7
   1133c:	f7fe ffe4 	bl	10308 <send_mod_sub_status>
   11340:	e7c7      	b.n	112d2 <mod_sub_overwrite+0x2e>
		status = STATUS_INVALID_MODEL;
   11342:	2202      	movs	r2, #2
   11344:	e7f2      	b.n	1132c <mod_sub_overwrite+0x88>
   11346:	bf00      	nop
   11348:	00029928 	.word	0x00029928
   1134c:	00029830 	.word	0x00029830
   11350:	0002dc69 	.word	0x0002dc69
   11354:	00027b15 	.word	0x00027b15

00011358 <mod_sub_del>:
{
   11358:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1135c:	4606      	mov	r6, r0
   1135e:	b087      	sub	sp, #28
	elem_addr = net_buf_simple_pull_le16(buf);
   11360:	4610      	mov	r0, r2
{
   11362:	460f      	mov	r7, r1
   11364:	4691      	mov	r9, r2
	elem_addr = net_buf_simple_pull_le16(buf);
   11366:	f017 fcfe 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   1136a:	b203      	sxth	r3, r0
   1136c:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   1136e:	4604      	mov	r4, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11370:	dc0c      	bgt.n	1138c <mod_sub_del+0x34>
   11372:	4924      	ldr	r1, [pc, #144]	; (11404 <mod_sub_del+0xac>)
   11374:	4b24      	ldr	r3, [pc, #144]	; (11408 <mod_sub_del+0xb0>)
		BT_WARN("Prohibited element address");
   11376:	4825      	ldr	r0, [pc, #148]	; (1140c <mod_sub_del+0xb4>)
   11378:	1ac9      	subs	r1, r1, r3
   1137a:	08c9      	lsrs	r1, r1, #3
   1137c:	0189      	lsls	r1, r1, #6
   1137e:	f041 0102 	orr.w	r1, r1, #2
   11382:	f012 fe1f 	bl	23fc4 <log_0>
}
   11386:	b007      	add	sp, #28
   11388:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	sub_addr = net_buf_simple_pull_le16(buf);
   1138c:	4648      	mov	r0, r9
   1138e:	f017 fcea 	bl	28d66 <net_buf_simple_pull_le16>
   11392:	4605      	mov	r5, r0
	elem = bt_mesh_elem_find(elem_addr);
   11394:	4620      	mov	r0, r4
	mod_id = buf->data;
   11396:	f8d9 8000 	ldr.w	r8, [r9]
	elem = bt_mesh_elem_find(elem_addr);
   1139a:	f7fe fb8d 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   1139e:	b948      	cbnz	r0, 113b4 <mod_sub_del+0x5c>
		vnd = (buf->len == 4U);
   113a0:	f8b9 3004 	ldrh.w	r3, [r9, #4]
		mod = NULL;
   113a4:	9005      	str	r0, [sp, #20]
		vnd = (buf->len == 4U);
   113a6:	1f1a      	subs	r2, r3, #4
   113a8:	4253      	negs	r3, r2
   113aa:	4153      	adcs	r3, r2
   113ac:	f88d 3013 	strb.w	r3, [sp, #19]
		status = STATUS_INVALID_ADDRESS;
   113b0:	2201      	movs	r2, #1
   113b2:	e01a      	b.n	113ea <mod_sub_del+0x92>
	mod = get_model(elem, buf, &vnd);
   113b4:	f10d 0213 	add.w	r2, sp, #19
   113b8:	4649      	mov	r1, r9
   113ba:	f016 faf5 	bl	279a8 <get_model>
   113be:	9005      	str	r0, [sp, #20]
	if (!mod) {
   113c0:	b1f0      	cbz	r0, 11400 <mod_sub_del+0xa8>
	if (!BT_MESH_ADDR_IS_GROUP(sub_addr)) {
   113c2:	f505 4380 	add.w	r3, r5, #16384	; 0x4000
   113c6:	b29b      	uxth	r3, r3
   113c8:	f5b3 5f7c 	cmp.w	r3, #16128	; 0x3f00
   113cc:	d8f0      	bhi.n	113b0 <mod_sub_del+0x58>
	match = bt_mesh_model_find_group(&mod, sub_addr);
   113ce:	4629      	mov	r1, r5
   113d0:	a805      	add	r0, sp, #20
   113d2:	f016 f9c3 	bl	2775c <bt_mesh_model_find_group>
	if (match) {
   113d6:	f04f 0900 	mov.w	r9, #0
   113da:	4602      	mov	r2, r0
   113dc:	b128      	cbz	r0, 113ea <mod_sub_del+0x92>
		*match = BT_MESH_ADDR_UNASSIGNED;
   113de:	f8a0 9000 	strh.w	r9, [r0]
			bt_mesh_store_mod_sub(mod);
   113e2:	9805      	ldr	r0, [sp, #20]
   113e4:	f016 fcac 	bl	27d40 <bt_mesh_store_mod_sub>
	status = STATUS_SUCCESS;
   113e8:	464a      	mov	r2, r9
	send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   113ea:	f89d 3013 	ldrb.w	r3, [sp, #19]
   113ee:	9500      	str	r5, [sp, #0]
   113f0:	e9cd 8301 	strd	r8, r3, [sp, #4]
   113f4:	4639      	mov	r1, r7
   113f6:	4623      	mov	r3, r4
   113f8:	4630      	mov	r0, r6
   113fa:	f7fe ff85 	bl	10308 <send_mod_sub_status>
   113fe:	e7c2      	b.n	11386 <mod_sub_del+0x2e>
		status = STATUS_INVALID_MODEL;
   11400:	2202      	movs	r2, #2
   11402:	e7f2      	b.n	113ea <mod_sub_del+0x92>
   11404:	00029928 	.word	0x00029928
   11408:	00029830 	.word	0x00029830
   1140c:	0002dc69 	.word	0x0002dc69

00011410 <mod_sub_add>:
{
   11410:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11414:	4607      	mov	r7, r0
   11416:	b087      	sub	sp, #28
	elem_addr = net_buf_simple_pull_le16(buf);
   11418:	4610      	mov	r0, r2
{
   1141a:	4688      	mov	r8, r1
   1141c:	4614      	mov	r4, r2
	elem_addr = net_buf_simple_pull_le16(buf);
   1141e:	f017 fca2 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11422:	b203      	sxth	r3, r0
   11424:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   11426:	4606      	mov	r6, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11428:	dc0c      	bgt.n	11444 <mod_sub_add+0x34>
   1142a:	4925      	ldr	r1, [pc, #148]	; (114c0 <mod_sub_add+0xb0>)
   1142c:	4b25      	ldr	r3, [pc, #148]	; (114c4 <mod_sub_add+0xb4>)
		BT_WARN("Prohibited element address");
   1142e:	4826      	ldr	r0, [pc, #152]	; (114c8 <mod_sub_add+0xb8>)
   11430:	1ac9      	subs	r1, r1, r3
   11432:	08c9      	lsrs	r1, r1, #3
   11434:	0189      	lsls	r1, r1, #6
   11436:	f041 0102 	orr.w	r1, r1, #2
   1143a:	f012 fdc3 	bl	23fc4 <log_0>
}
   1143e:	b007      	add	sp, #28
   11440:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	sub_addr = net_buf_simple_pull_le16(buf);
   11444:	4620      	mov	r0, r4
   11446:	f017 fc8e 	bl	28d66 <net_buf_simple_pull_le16>
   1144a:	4605      	mov	r5, r0
	elem = bt_mesh_elem_find(elem_addr);
   1144c:	4630      	mov	r0, r6
	mod_id = buf->data;
   1144e:	f8d4 9000 	ldr.w	r9, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   11452:	f7fe fb31 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   11456:	b940      	cbnz	r0, 1146a <mod_sub_add+0x5a>
		vnd = (buf->len == 4U);
   11458:	88a3      	ldrh	r3, [r4, #4]
		mod = NULL;
   1145a:	9005      	str	r0, [sp, #20]
		vnd = (buf->len == 4U);
   1145c:	1f1a      	subs	r2, r3, #4
   1145e:	4253      	negs	r3, r2
   11460:	4153      	adcs	r3, r2
   11462:	f88d 3013 	strb.w	r3, [sp, #19]
		status = STATUS_INVALID_ADDRESS;
   11466:	2201      	movs	r2, #1
   11468:	e01d      	b.n	114a6 <mod_sub_add+0x96>
	mod = get_model(elem, buf, &vnd);
   1146a:	f10d 0213 	add.w	r2, sp, #19
   1146e:	4621      	mov	r1, r4
   11470:	f016 fa9a 	bl	279a8 <get_model>
   11474:	9005      	str	r0, [sp, #20]
	if (!mod) {
   11476:	b1a8      	cbz	r0, 114a4 <mod_sub_add+0x94>
	if (!BT_MESH_ADDR_IS_GROUP(sub_addr)) {
   11478:	f505 4380 	add.w	r3, r5, #16384	; 0x4000
   1147c:	b29b      	uxth	r3, r3
   1147e:	f5b3 5f7c 	cmp.w	r3, #16128	; 0x3f00
   11482:	d8f0      	bhi.n	11466 <mod_sub_add+0x56>
	if (bt_mesh_model_find_group(&mod, sub_addr)) {
   11484:	4629      	mov	r1, r5
   11486:	a805      	add	r0, sp, #20
   11488:	f016 f968 	bl	2775c <bt_mesh_model_find_group>
   1148c:	b940      	cbnz	r0, 114a0 <mod_sub_add+0x90>
	entry = bt_mesh_model_find_group(&mod, BT_MESH_ADDR_UNASSIGNED);
   1148e:	4601      	mov	r1, r0
   11490:	a805      	add	r0, sp, #20
   11492:	f016 f963 	bl	2775c <bt_mesh_model_find_group>
	if (!entry) {
   11496:	b188      	cbz	r0, 114bc <mod_sub_add+0xac>
	*entry = sub_addr;
   11498:	8005      	strh	r5, [r0, #0]
		bt_mesh_store_mod_sub(mod);
   1149a:	9805      	ldr	r0, [sp, #20]
   1149c:	f016 fc50 	bl	27d40 <bt_mesh_store_mod_sub>
		status = STATUS_SUCCESS;
   114a0:	2200      	movs	r2, #0
   114a2:	e000      	b.n	114a6 <mod_sub_add+0x96>
		status = STATUS_INVALID_MODEL;
   114a4:	2202      	movs	r2, #2
	send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   114a6:	f89d 3013 	ldrb.w	r3, [sp, #19]
   114aa:	9500      	str	r5, [sp, #0]
   114ac:	e9cd 9301 	strd	r9, r3, [sp, #4]
   114b0:	4641      	mov	r1, r8
   114b2:	4633      	mov	r3, r6
   114b4:	4638      	mov	r0, r7
   114b6:	f7fe ff27 	bl	10308 <send_mod_sub_status>
   114ba:	e7c0      	b.n	1143e <mod_sub_add+0x2e>
		status = STATUS_INSUFF_RESOURCES;
   114bc:	2205      	movs	r2, #5
   114be:	e7f2      	b.n	114a6 <mod_sub_add+0x96>
   114c0:	00029928 	.word	0x00029928
   114c4:	00029830 	.word	0x00029830
   114c8:	0002dc69 	.word	0x0002dc69

000114cc <mod_pub_get>:
{
   114cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   114d0:	4606      	mov	r6, r0
   114d2:	b087      	sub	sp, #28
	elem_addr = net_buf_simple_pull_le16(buf);
   114d4:	4610      	mov	r0, r2
{
   114d6:	460f      	mov	r7, r1
   114d8:	4691      	mov	r9, r2
	elem_addr = net_buf_simple_pull_le16(buf);
   114da:	f017 fc44 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   114de:	b203      	sxth	r3, r0
   114e0:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   114e2:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   114e4:	dc0c      	bgt.n	11500 <mod_pub_get+0x34>
   114e6:	491c      	ldr	r1, [pc, #112]	; (11558 <mod_pub_get+0x8c>)
   114e8:	4b1c      	ldr	r3, [pc, #112]	; (1155c <mod_pub_get+0x90>)
		BT_WARN("Prohibited element address");
   114ea:	481d      	ldr	r0, [pc, #116]	; (11560 <mod_pub_get+0x94>)
   114ec:	1ac9      	subs	r1, r1, r3
   114ee:	08c9      	lsrs	r1, r1, #3
   114f0:	0189      	lsls	r1, r1, #6
   114f2:	f041 0102 	orr.w	r1, r1, #2
   114f6:	f012 fd65 	bl	23fc4 <log_0>
}
   114fa:	b007      	add	sp, #28
   114fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	mod_id = buf->data;
   11500:	f8d9 8000 	ldr.w	r8, [r9]
	elem = bt_mesh_elem_find(elem_addr);
   11504:	f7fe fad8 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   11508:	4604      	mov	r4, r0
   1150a:	b948      	cbnz	r0, 11520 <mod_pub_get+0x54>
		vnd = (buf->len == 4U);
   1150c:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   11510:	1f1a      	subs	r2, r3, #4
   11512:	4253      	negs	r3, r2
   11514:	4153      	adcs	r3, r2
   11516:	f88d 3017 	strb.w	r3, [sp, #23]
		status = STATUS_INVALID_ADDRESS;
   1151a:	2201      	movs	r2, #1
	u16_t elem_addr, pub_addr = 0U;
   1151c:	4623      	mov	r3, r4
   1151e:	e00a      	b.n	11536 <mod_pub_get+0x6a>
	mod = get_model(elem, buf, &vnd);
   11520:	f10d 0217 	add.w	r2, sp, #23
   11524:	4649      	mov	r1, r9
   11526:	f016 fa3f 	bl	279a8 <get_model>
	if (!mod) {
   1152a:	4604      	mov	r4, r0
   1152c:	b180      	cbz	r0, 11550 <mod_pub_get+0x84>
	if (!mod->pub) {
   1152e:	6883      	ldr	r3, [r0, #8]
   11530:	b183      	cbz	r3, 11554 <mod_pub_get+0x88>
	pub_addr = mod->pub->addr;
   11532:	889b      	ldrh	r3, [r3, #4]
	status = STATUS_SUCCESS;
   11534:	2200      	movs	r2, #0
	send_mod_pub_status(model, ctx, elem_addr, pub_addr, vnd, mod,
   11536:	e9cd 2802 	strd	r2, r8, [sp, #8]
   1153a:	3408      	adds	r4, #8
   1153c:	f89d 2017 	ldrb.w	r2, [sp, #23]
   11540:	9200      	str	r2, [sp, #0]
   11542:	9401      	str	r4, [sp, #4]
   11544:	462a      	mov	r2, r5
   11546:	4639      	mov	r1, r7
   11548:	4630      	mov	r0, r6
   1154a:	f7ff fbed 	bl	10d28 <send_mod_pub_status.isra.0>
   1154e:	e7d4      	b.n	114fa <mod_pub_get+0x2e>
		status = STATUS_INVALID_MODEL;
   11550:	2202      	movs	r2, #2
   11552:	e7e3      	b.n	1151c <mod_pub_get+0x50>
		status = STATUS_NVAL_PUB_PARAM;
   11554:	2207      	movs	r2, #7
   11556:	e7ee      	b.n	11536 <mod_pub_get+0x6a>
   11558:	00029928 	.word	0x00029928
   1155c:	00029830 	.word	0x00029830
   11560:	0002dc69 	.word	0x0002dc69

00011564 <mod_sub_list_visitor>:
{
   11564:	b538      	push	{r3, r4, r5, lr}
   11566:	4614      	mov	r4, r2
	if (mod->elem_idx != visit->elem_idx) {
   11568:	7902      	ldrb	r2, [r0, #4]
   1156a:	8823      	ldrh	r3, [r4, #0]
   1156c:	429a      	cmp	r2, r3
{
   1156e:	4605      	mov	r5, r0
	if (mod->elem_idx != visit->elem_idx) {
   11570:	d121      	bne.n	115b6 <mod_sub_list_visitor+0x52>
		if (mod->groups[i] == BT_MESH_ADDR_UNASSIGNED) {
   11572:	8a03      	ldrh	r3, [r0, #16]
   11574:	b143      	cbz	r3, 11588 <mod_sub_list_visitor+0x24>
		if (net_buf_simple_tailroom(visit->msg) <
   11576:	6860      	ldr	r0, [r4, #4]
   11578:	f017 fc15 	bl	28da6 <net_buf_simple_tailroom>
   1157c:	2805      	cmp	r0, #5
   1157e:	d90a      	bls.n	11596 <mod_sub_list_visitor+0x32>
		net_buf_simple_add_le16(visit->msg, mod->groups[i]);
   11580:	8a29      	ldrh	r1, [r5, #16]
   11582:	6860      	ldr	r0, [r4, #4]
   11584:	f017 fc2a 	bl	28ddc <net_buf_simple_add_le16>
		if (mod->groups[i] == BT_MESH_ADDR_UNASSIGNED) {
   11588:	8a6b      	ldrh	r3, [r5, #18]
   1158a:	b1a3      	cbz	r3, 115b6 <mod_sub_list_visitor+0x52>
		if (net_buf_simple_tailroom(visit->msg) <
   1158c:	6860      	ldr	r0, [r4, #4]
   1158e:	f017 fc0a 	bl	28da6 <net_buf_simple_tailroom>
   11592:	2805      	cmp	r0, #5
   11594:	d80b      	bhi.n	115ae <mod_sub_list_visitor+0x4a>
   11596:	4b09      	ldr	r3, [pc, #36]	; (115bc <mod_sub_list_visitor+0x58>)
   11598:	4909      	ldr	r1, [pc, #36]	; (115c0 <mod_sub_list_visitor+0x5c>)
			BT_WARN("No room for all groups");
   1159a:	480a      	ldr	r0, [pc, #40]	; (115c4 <mod_sub_list_visitor+0x60>)
   1159c:	1ac9      	subs	r1, r1, r3
   1159e:	08c9      	lsrs	r1, r1, #3
   115a0:	0189      	lsls	r1, r1, #6
   115a2:	f041 0102 	orr.w	r1, r1, #2
   115a6:	f012 fd0d 	bl	23fc4 <log_0>
			return BT_MESH_WALK_STOP;
   115aa:	2000      	movs	r0, #0
}
   115ac:	bd38      	pop	{r3, r4, r5, pc}
		net_buf_simple_add_le16(visit->msg, mod->groups[i]);
   115ae:	8a69      	ldrh	r1, [r5, #18]
   115b0:	6860      	ldr	r0, [r4, #4]
   115b2:	f017 fc13 	bl	28ddc <net_buf_simple_add_le16>
		return BT_MESH_WALK_CONTINUE;
   115b6:	2001      	movs	r0, #1
   115b8:	e7f8      	b.n	115ac <mod_sub_list_visitor+0x48>
   115ba:	bf00      	nop
   115bc:	00029830 	.word	0x00029830
   115c0:	00029928 	.word	0x00029928
   115c4:	0002df39 	.word	0x0002df39

000115c8 <dev_comp_data_get>:
{
   115c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   115cc:	b08f      	sub	sp, #60	; 0x3c
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   115ce:	ab05      	add	r3, sp, #20
{
   115d0:	4680      	mov	r8, r0
   115d2:	4689      	mov	r9, r1
	page = net_buf_simple_pull_u8(buf);
   115d4:	4610      	mov	r0, r2
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   115d6:	f44f 1110 	mov.w	r1, #2359296	; 0x240000
   115da:	e9cd 1303 	strd	r1, r3, [sp, #12]
   115de:	9302      	str	r3, [sp, #8]
	page = net_buf_simple_pull_u8(buf);
   115e0:	f017 fbb9 	bl	28d56 <net_buf_simple_pull_u8>
	bt_mesh_model_msg_init(&sdu, OP_DEV_COMP_DATA_STATUS);
   115e4:	2102      	movs	r1, #2
   115e6:	a802      	add	r0, sp, #8
   115e8:	f016 f8e2 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&sdu, page);
   115ec:	2100      	movs	r1, #0
   115ee:	a802      	add	r0, sp, #8
   115f0:	f017 fbed 	bl	28dce <net_buf_simple_add_u8>
	comp = bt_mesh_comp_get();
   115f4:	f7fe fcda 	bl	ffac <bt_mesh_comp_get>
   115f8:	4605      	mov	r5, r0
	net_buf_simple_add_le16(buf, comp->cid);
   115fa:	8801      	ldrh	r1, [r0, #0]
   115fc:	a802      	add	r0, sp, #8
   115fe:	f017 fbed 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(buf, comp->pid);
   11602:	8869      	ldrh	r1, [r5, #2]
   11604:	a802      	add	r0, sp, #8
   11606:	f017 fbe9 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(buf, comp->vid);
   1160a:	88a9      	ldrh	r1, [r5, #4]
   1160c:	a802      	add	r0, sp, #8
   1160e:	f017 fbe5 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(buf, CONFIG_BT_MESH_CRPL);
   11612:	210a      	movs	r1, #10
   11614:	a802      	add	r0, sp, #8
   11616:	f017 fbe1 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(buf, feat);
   1161a:	2107      	movs	r1, #7
   1161c:	a802      	add	r0, sp, #8
   1161e:	f017 fbdd 	bl	28ddc <net_buf_simple_add_le16>
	for (i = 0; i < comp->elem_count; i++) {
   11622:	2700      	movs	r7, #0
	    4 + (elem->model_count * 2U) + (elem->vnd_model_count * 4U)) {
   11624:	f04f 0a02 	mov.w	sl, #2
	for (i = 0; i < comp->elem_count; i++) {
   11628:	68ab      	ldr	r3, [r5, #8]
   1162a:	429f      	cmp	r7, r3
   1162c:	d310      	bcc.n	11650 <dev_comp_data_get+0x88>
	if (bt_mesh_model_send(model, ctx, &sdu, NULL, NULL)) {
   1162e:	2300      	movs	r3, #0
   11630:	9300      	str	r3, [sp, #0]
   11632:	aa02      	add	r2, sp, #8
   11634:	4649      	mov	r1, r9
   11636:	4640      	mov	r0, r8
   11638:	f016 f8e3 	bl	27802 <bt_mesh_model_send>
   1163c:	b328      	cbz	r0, 1168a <dev_comp_data_get+0xc2>
   1163e:	492b      	ldr	r1, [pc, #172]	; (116ec <dev_comp_data_get+0x124>)
   11640:	4b2b      	ldr	r3, [pc, #172]	; (116f0 <dev_comp_data_get+0x128>)
		BT_ERR("Unable to send Device Composition Status response");
   11642:	482c      	ldr	r0, [pc, #176]	; (116f4 <dev_comp_data_get+0x12c>)
   11644:	1ac9      	subs	r1, r1, r3
   11646:	08c9      	lsrs	r1, r1, #3
   11648:	0189      	lsls	r1, r1, #6
   1164a:	f041 0101 	orr.w	r1, r1, #1
   1164e:	e01a      	b.n	11686 <dev_comp_data_get+0xbe>
		err = comp_add_elem(buf, &comp->elem[i], i == 0);
   11650:	68ec      	ldr	r4, [r5, #12]
   11652:	eb04 1407 	add.w	r4, r4, r7, lsl #4
	if (net_buf_simple_tailroom(buf) <
   11656:	a802      	add	r0, sp, #8
   11658:	f017 fba5 	bl	28da6 <net_buf_simple_tailroom>
	    4 + (elem->model_count * 2U) + (elem->vnd_model_count * 4U)) {
   1165c:	7922      	ldrb	r2, [r4, #4]
   1165e:	7963      	ldrb	r3, [r4, #5]
   11660:	3202      	adds	r2, #2
   11662:	fb1a 2303 	smlabb	r3, sl, r3, r2
	if (net_buf_simple_tailroom(buf) <
   11666:	ebb0 0f43 	cmp.w	r0, r3, lsl #1
   1166a:	d211      	bcs.n	11690 <dev_comp_data_get+0xc8>
   1166c:	4b20      	ldr	r3, [pc, #128]	; (116f0 <dev_comp_data_get+0x128>)
   1166e:	4c1f      	ldr	r4, [pc, #124]	; (116ec <dev_comp_data_get+0x124>)
		BT_ERR("Too large device composition");
   11670:	4821      	ldr	r0, [pc, #132]	; (116f8 <dev_comp_data_get+0x130>)
   11672:	1ae4      	subs	r4, r4, r3
   11674:	08e4      	lsrs	r4, r4, #3
   11676:	01a4      	lsls	r4, r4, #6
   11678:	f044 0401 	orr.w	r4, r4, #1
   1167c:	4621      	mov	r1, r4
   1167e:	f012 fca1 	bl	23fc4 <log_0>
		BT_ERR("Unable to get composition page 0");
   11682:	481e      	ldr	r0, [pc, #120]	; (116fc <dev_comp_data_get+0x134>)
   11684:	4621      	mov	r1, r4
		BT_ERR("Unable to send Device Composition Status response");
   11686:	f012 fc9d 	bl	23fc4 <log_0>
}
   1168a:	b00f      	add	sp, #60	; 0x3c
   1168c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	net_buf_simple_add_le16(buf, elem->loc);
   11690:	8861      	ldrh	r1, [r4, #2]
   11692:	a802      	add	r0, sp, #8
   11694:	f017 fba2 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_u8(buf, elem->model_count);
   11698:	7921      	ldrb	r1, [r4, #4]
   1169a:	a802      	add	r0, sp, #8
   1169c:	f017 fb97 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(buf, elem->vnd_model_count);
   116a0:	7961      	ldrb	r1, [r4, #5]
   116a2:	a802      	add	r0, sp, #8
   116a4:	f017 fb93 	bl	28dce <net_buf_simple_add_u8>
	for (i = 0; i < elem->model_count; i++) {
   116a8:	2600      	movs	r6, #0
   116aa:	7923      	ldrb	r3, [r4, #4]
   116ac:	429e      	cmp	r6, r3
   116ae:	db05      	blt.n	116bc <dev_comp_data_get+0xf4>
	for (i = 0; i < elem->vnd_model_count; i++) {
   116b0:	2600      	movs	r6, #0
   116b2:	7963      	ldrb	r3, [r4, #5]
   116b4:	429e      	cmp	r6, r3
   116b6:	db09      	blt.n	116cc <dev_comp_data_get+0x104>
	for (i = 0; i < comp->elem_count; i++) {
   116b8:	3701      	adds	r7, #1
   116ba:	e7b5      	b.n	11628 <dev_comp_data_get+0x60>
		net_buf_simple_add_le16(buf, mod->id);
   116bc:	0173      	lsls	r3, r6, #5
   116be:	68a2      	ldr	r2, [r4, #8]
   116c0:	a802      	add	r0, sp, #8
   116c2:	5ad1      	ldrh	r1, [r2, r3]
   116c4:	f017 fb8a 	bl	28ddc <net_buf_simple_add_le16>
	for (i = 0; i < elem->model_count; i++) {
   116c8:	3601      	adds	r6, #1
   116ca:	e7ee      	b.n	116aa <dev_comp_data_get+0xe2>
		mod = &elem->vnd_models[i];
   116cc:	68e3      	ldr	r3, [r4, #12]
   116ce:	0172      	lsls	r2, r6, #5
   116d0:	eb03 1b46 	add.w	fp, r3, r6, lsl #5
		net_buf_simple_add_le16(buf, mod->vnd.company);
   116d4:	5a99      	ldrh	r1, [r3, r2]
   116d6:	a802      	add	r0, sp, #8
   116d8:	f017 fb80 	bl	28ddc <net_buf_simple_add_le16>
		net_buf_simple_add_le16(buf, mod->vnd.id);
   116dc:	f8bb 1002 	ldrh.w	r1, [fp, #2]
   116e0:	a802      	add	r0, sp, #8
   116e2:	f017 fb7b 	bl	28ddc <net_buf_simple_add_le16>
	for (i = 0; i < elem->vnd_model_count; i++) {
   116e6:	3601      	adds	r6, #1
   116e8:	e7e3      	b.n	116b2 <dev_comp_data_get+0xea>
   116ea:	bf00      	nop
   116ec:	00029928 	.word	0x00029928
   116f0:	00029830 	.word	0x00029830
   116f4:	0002df8e 	.word	0x0002df8e
   116f8:	0002df50 	.word	0x0002df50
   116fc:	0002df6d 	.word	0x0002df6d

00011700 <va_add>:
{
   11700:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (labels[i].ref == 0) {
   11704:	4e19      	ldr	r6, [pc, #100]	; (1176c <va_add+0x6c>)
			match = &labels[i];
   11706:	2300      	movs	r3, #0
{
   11708:	4605      	mov	r5, r0
   1170a:	460f      	mov	r7, r1
			match = &labels[i];
   1170c:	461c      	mov	r4, r3
		if (!memcmp(labels[i].uuid, label_uuid, 16)) {
   1170e:	f106 0804 	add.w	r8, r6, #4
		if (labels[i].ref == 0) {
   11712:	8832      	ldrh	r2, [r6, #0]
	for (i = 0; i < ARRAY_SIZE(labels); i++) {
   11714:	b113      	cbz	r3, 1171c <va_add+0x1c>
	if (update) {
   11716:	b91c      	cbnz	r4, 11720 <va_add+0x20>
		return STATUS_INSUFF_RESOURCES;
   11718:	2005      	movs	r0, #5
   1171a:	e008      	b.n	1172e <va_add+0x2e>
		if (labels[i].ref == 0) {
   1171c:	b94a      	cbnz	r2, 11732 <va_add+0x32>
	if (update) {
   1171e:	b194      	cbz	r4, 11746 <va_add+0x46>
		update->ref++;
   11720:	8823      	ldrh	r3, [r4, #0]
   11722:	3301      	adds	r3, #1
   11724:	8023      	strh	r3, [r4, #0]
		va_store(update);
   11726:	4620      	mov	r0, r4
   11728:	f016 f96d 	bl	27a06 <va_store>
		return STATUS_SUCCESS;
   1172c:	2000      	movs	r0, #0
}
   1172e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!memcmp(labels[i].uuid, label_uuid, 16)) {
   11732:	2210      	movs	r2, #16
   11734:	4629      	mov	r1, r5
   11736:	4640      	mov	r0, r8
   11738:	f014 faa6 	bl	25c88 <memcmp>
			match = &labels[i];
   1173c:	2301      	movs	r3, #1
   1173e:	2800      	cmp	r0, #0
   11740:	bf08      	it	eq
   11742:	4634      	moveq	r4, r6
   11744:	e7e5      	b.n	11712 <va_add+0x12>
	if (bt_mesh_virtual_addr(label_uuid, addr) < 0) {
   11746:	4639      	mov	r1, r7
   11748:	4628      	mov	r0, r5
   1174a:	f7fd ffa9 	bl	f6a0 <bt_mesh_virtual_addr>
   1174e:	2800      	cmp	r0, #0
   11750:	db0a      	blt.n	11768 <va_add+0x68>
	free_slot->ref = 1U;
   11752:	2301      	movs	r3, #1
   11754:	8033      	strh	r3, [r6, #0]
	free_slot->addr = *addr;
   11756:	883b      	ldrh	r3, [r7, #0]
	memcpy(free_slot->uuid, label_uuid, 16);
   11758:	4805      	ldr	r0, [pc, #20]	; (11770 <va_add+0x70>)
	free_slot->addr = *addr;
   1175a:	8073      	strh	r3, [r6, #2]
	memcpy(free_slot->uuid, label_uuid, 16);
   1175c:	2210      	movs	r2, #16
   1175e:	4629      	mov	r1, r5
   11760:	f014 faa2 	bl	25ca8 <memcpy>
	va_store(free_slot);
   11764:	4801      	ldr	r0, [pc, #4]	; (1176c <va_add+0x6c>)
   11766:	e7df      	b.n	11728 <va_add+0x28>
		return STATUS_UNSPECIFIED;
   11768:	2010      	movs	r0, #16
   1176a:	e7e0      	b.n	1172e <va_add+0x2e>
   1176c:	2000090c 	.word	0x2000090c
   11770:	20000910 	.word	0x20000910

00011774 <mod_sub_va_overwrite>:
{
   11774:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11778:	b087      	sub	sp, #28
	u16_t elem_addr, sub_addr = BT_MESH_ADDR_UNASSIGNED;
   1177a:	f04f 0b00 	mov.w	fp, #0
{
   1177e:	4607      	mov	r7, r0
	elem_addr = net_buf_simple_pull_le16(buf);
   11780:	4610      	mov	r0, r2
{
   11782:	4688      	mov	r8, r1
   11784:	4614      	mov	r4, r2
	u16_t elem_addr, sub_addr = BT_MESH_ADDR_UNASSIGNED;
   11786:	f8ad b016 	strh.w	fp, [sp, #22]
	elem_addr = net_buf_simple_pull_le16(buf);
   1178a:	f017 faec 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   1178e:	b203      	sxth	r3, r0
   11790:	455b      	cmp	r3, fp
	elem_addr = net_buf_simple_pull_le16(buf);
   11792:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11794:	dc0c      	bgt.n	117b0 <mod_sub_va_overwrite+0x3c>
   11796:	4925      	ldr	r1, [pc, #148]	; (1182c <mod_sub_va_overwrite+0xb8>)
   11798:	4b25      	ldr	r3, [pc, #148]	; (11830 <mod_sub_va_overwrite+0xbc>)
		BT_WARN("Prohibited element address");
   1179a:	4826      	ldr	r0, [pc, #152]	; (11834 <mod_sub_va_overwrite+0xc0>)
   1179c:	1ac9      	subs	r1, r1, r3
   1179e:	08c9      	lsrs	r1, r1, #3
   117a0:	0189      	lsls	r1, r1, #6
   117a2:	f041 0102 	orr.w	r1, r1, #2
   117a6:	f012 fc0d 	bl	23fc4 <log_0>
}
   117aa:	b007      	add	sp, #28
   117ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   117b0:	2110      	movs	r1, #16
   117b2:	4620      	mov	r0, r4
   117b4:	f00d fd6e 	bl	1f294 <net_buf_simple_pull_mem>
   117b8:	4682      	mov	sl, r0
	elem = bt_mesh_elem_find(elem_addr);
   117ba:	4628      	mov	r0, r5
	mod_id = buf->data;
   117bc:	f8d4 9000 	ldr.w	r9, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   117c0:	f7fe f97a 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   117c4:	b9a0      	cbnz	r0, 117f0 <mod_sub_va_overwrite+0x7c>
		vnd = (buf->len == 4U);
   117c6:	88a3      	ldrh	r3, [r4, #4]
   117c8:	1f1a      	subs	r2, r3, #4
   117ca:	4253      	negs	r3, r2
   117cc:	4153      	adcs	r3, r2
   117ce:	f88d 3015 	strb.w	r3, [sp, #21]
		status = STATUS_INVALID_ADDRESS;
   117d2:	2401      	movs	r4, #1
	send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   117d4:	f89d 3015 	ldrb.w	r3, [sp, #21]
   117d8:	e9cd 9301 	strd	r9, r3, [sp, #4]
   117dc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   117e0:	9300      	str	r3, [sp, #0]
   117e2:	4622      	mov	r2, r4
   117e4:	462b      	mov	r3, r5
   117e6:	4641      	mov	r1, r8
   117e8:	4638      	mov	r0, r7
   117ea:	f7fe fd8d 	bl	10308 <send_mod_sub_status>
   117ee:	e7dc      	b.n	117aa <mod_sub_va_overwrite+0x36>
	mod = get_model(elem, buf, &vnd);
   117f0:	f10d 0215 	add.w	r2, sp, #21
   117f4:	4621      	mov	r1, r4
   117f6:	f016 f8d7 	bl	279a8 <get_model>
	if (!mod) {
   117fa:	4606      	mov	r6, r0
   117fc:	b1a0      	cbz	r0, 11828 <mod_sub_va_overwrite+0xb4>
		bt_mesh_model_tree_walk(bt_mesh_model_root(mod),
   117fe:	f016 f84e 	bl	2789e <bt_mesh_model_root>
   11802:	490d      	ldr	r1, [pc, #52]	; (11838 <mod_sub_va_overwrite+0xc4>)
   11804:	465a      	mov	r2, fp
   11806:	f016 f84b 	bl	278a0 <bt_mesh_model_tree_walk>
		status = va_add(label_uuid, &sub_addr);
   1180a:	f10d 0116 	add.w	r1, sp, #22
   1180e:	4650      	mov	r0, sl
   11810:	f7ff ff76 	bl	11700 <va_add>
		if (status == STATUS_SUCCESS) {
   11814:	4604      	mov	r4, r0
   11816:	2800      	cmp	r0, #0
   11818:	d1dc      	bne.n	117d4 <mod_sub_va_overwrite+0x60>
			mod->groups[0] = sub_addr;
   1181a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   1181e:	8233      	strh	r3, [r6, #16]
				bt_mesh_store_mod_sub(mod);
   11820:	4630      	mov	r0, r6
   11822:	f016 fa8d 	bl	27d40 <bt_mesh_store_mod_sub>
   11826:	e7d5      	b.n	117d4 <mod_sub_va_overwrite+0x60>
		status = STATUS_INVALID_MODEL;
   11828:	2402      	movs	r4, #2
   1182a:	e7d3      	b.n	117d4 <mod_sub_va_overwrite+0x60>
   1182c:	00029928 	.word	0x00029928
   11830:	00029830 	.word	0x00029830
   11834:	0002dc69 	.word	0x0002dc69
   11838:	00027b15 	.word	0x00027b15

0001183c <mod_pub_va_set>:
{
   1183c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11840:	4680      	mov	r8, r0
   11842:	b08b      	sub	sp, #44	; 0x2c
	elem_addr = net_buf_simple_pull_le16(buf);
   11844:	4610      	mov	r0, r2
{
   11846:	4692      	mov	sl, r2
   11848:	4689      	mov	r9, r1
	elem_addr = net_buf_simple_pull_le16(buf);
   1184a:	f017 fa8c 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   1184e:	b202      	sxth	r2, r0
   11850:	2a00      	cmp	r2, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   11852:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11854:	dc0c      	bgt.n	11870 <mod_pub_va_set+0x34>
   11856:	493c      	ldr	r1, [pc, #240]	; (11948 <mod_pub_va_set+0x10c>)
   11858:	4b3c      	ldr	r3, [pc, #240]	; (1194c <mod_pub_va_set+0x110>)
		BT_WARN("Prohibited element address");
   1185a:	483d      	ldr	r0, [pc, #244]	; (11950 <mod_pub_va_set+0x114>)
   1185c:	1ac9      	subs	r1, r1, r3
   1185e:	08c9      	lsrs	r1, r1, #3
   11860:	0189      	lsls	r1, r1, #6
   11862:	f041 0102 	orr.w	r1, r1, #2
   11866:	f012 fbad 	bl	23fc4 <log_0>
}
   1186a:	b00b      	add	sp, #44	; 0x2c
   1186c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   11870:	2110      	movs	r1, #16
   11872:	4650      	mov	r0, sl
   11874:	f00d fd0e 	bl	1f294 <net_buf_simple_pull_mem>
   11878:	4683      	mov	fp, r0
	pub_app_idx = net_buf_simple_pull_le16(buf);
   1187a:	4650      	mov	r0, sl
   1187c:	f017 fa73 	bl	28d66 <net_buf_simple_pull_le16>
   11880:	4607      	mov	r7, r0
	pub_ttl = net_buf_simple_pull_u8(buf);
   11882:	4650      	mov	r0, sl
   11884:	f017 fa67 	bl	28d56 <net_buf_simple_pull_u8>
	if (pub_ttl > BT_MESH_TTL_MAX && pub_ttl != BT_MESH_TTL_DEFAULT) {
   11888:	f1a0 0280 	sub.w	r2, r0, #128	; 0x80
   1188c:	b2d2      	uxtb	r2, r2
   1188e:	2a7e      	cmp	r2, #126	; 0x7e
	pub_ttl = net_buf_simple_pull_u8(buf);
   11890:	4606      	mov	r6, r0
	if (pub_ttl > BT_MESH_TTL_MAX && pub_ttl != BT_MESH_TTL_DEFAULT) {
   11892:	d80b      	bhi.n	118ac <mod_pub_va_set+0x70>
   11894:	4b2d      	ldr	r3, [pc, #180]	; (1194c <mod_pub_va_set+0x110>)
   11896:	4a2c      	ldr	r2, [pc, #176]	; (11948 <mod_pub_va_set+0x10c>)
   11898:	1ad2      	subs	r2, r2, r3
   1189a:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Invalid TTL value 0x%02x", pub_ttl);
   1189c:	0192      	lsls	r2, r2, #6
   1189e:	4601      	mov	r1, r0
   118a0:	f042 0201 	orr.w	r2, r2, #1
   118a4:	482b      	ldr	r0, [pc, #172]	; (11954 <mod_pub_va_set+0x118>)
   118a6:	f012 fb9a 	bl	23fde <log_1>
		return;
   118aa:	e7de      	b.n	1186a <mod_pub_va_set+0x2e>
	pub_period = net_buf_simple_pull_u8(buf);
   118ac:	4650      	mov	r0, sl
   118ae:	f017 fa52 	bl	28d56 <net_buf_simple_pull_u8>
   118b2:	9006      	str	r0, [sp, #24]
	retransmit = net_buf_simple_pull_u8(buf);
   118b4:	4650      	mov	r0, sl
   118b6:	f017 fa4e 	bl	28d56 <net_buf_simple_pull_u8>
	mod_id = buf->data;
   118ba:	f8da 3000 	ldr.w	r3, [sl]
	retransmit = net_buf_simple_pull_u8(buf);
   118be:	9007      	str	r0, [sp, #28]
	elem = bt_mesh_elem_find(elem_addr);
   118c0:	4628      	mov	r0, r5
	mod_id = buf->data;
   118c2:	9305      	str	r3, [sp, #20]
	elem = bt_mesh_elem_find(elem_addr);
   118c4:	f7fe f8f8 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   118c8:	4604      	mov	r4, r0
   118ca:	b9c8      	cbnz	r0, 11900 <mod_pub_va_set+0xc4>
		vnd = (buf->len == 4U);
   118cc:	f8ba 3004 	ldrh.w	r3, [sl, #4]
		pub_addr = 0U;
   118d0:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
		vnd = (buf->len == 4U);
   118d4:	1f1a      	subs	r2, r3, #4
   118d6:	4253      	negs	r3, r2
   118d8:	4153      	adcs	r3, r2
   118da:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
		status = STATUS_INVALID_ADDRESS;
   118de:	2001      	movs	r0, #1
	send_mod_pub_status(model, ctx, elem_addr, pub_addr, vnd, mod,
   118e0:	9b05      	ldr	r3, [sp, #20]
   118e2:	3408      	adds	r4, #8
   118e4:	e9cd 0302 	strd	r0, r3, [sp, #8]
   118e8:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   118ec:	9300      	str	r3, [sp, #0]
   118ee:	9401      	str	r4, [sp, #4]
   118f0:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
   118f4:	462a      	mov	r2, r5
   118f6:	4649      	mov	r1, r9
   118f8:	4640      	mov	r0, r8
   118fa:	f7ff fa15 	bl	10d28 <send_mod_pub_status.isra.0>
   118fe:	e7b4      	b.n	1186a <mod_pub_va_set+0x2e>
	mod = get_model(elem, buf, &vnd);
   11900:	f10d 0225 	add.w	r2, sp, #37	; 0x25
   11904:	4651      	mov	r1, sl
   11906:	f016 f84f 	bl	279a8 <get_model>
	if (!mod) {
   1190a:	4604      	mov	r4, r0
   1190c:	b918      	cbnz	r0, 11916 <mod_pub_va_set+0xda>
		pub_addr = 0U;
   1190e:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
		status = STATUS_INVALID_MODEL;
   11912:	2002      	movs	r0, #2
		goto send_status;
   11914:	e7e4      	b.n	118e0 <mod_pub_va_set+0xa4>
	status = va_add(label_uuid, &pub_addr);
   11916:	f10d 0126 	add.w	r1, sp, #38	; 0x26
   1191a:	4658      	mov	r0, fp
   1191c:	f7ff fef0 	bl	11700 <va_add>
	if (status == STATUS_SUCCESS) {
   11920:	2800      	cmp	r0, #0
   11922:	d1dd      	bne.n	118e0 <mod_pub_va_set+0xa4>
		status = _mod_pub_set(mod, pub_addr, pub_app_idx, cred_flag,
   11924:	2301      	movs	r3, #1
   11926:	9303      	str	r3, [sp, #12]
   11928:	9b07      	ldr	r3, [sp, #28]
   1192a:	9302      	str	r3, [sp, #8]
   1192c:	9b06      	ldr	r3, [sp, #24]
   1192e:	f8bd 1026 	ldrh.w	r1, [sp, #38]	; 0x26
   11932:	e9cd 6300 	strd	r6, r3, [sp]
   11936:	f3c7 020b 	ubfx	r2, r7, #0, #12
   1193a:	f3c7 3300 	ubfx	r3, r7, #12, #1
   1193e:	4620      	mov	r0, r4
   11940:	f7fe fb58 	bl	fff4 <_mod_pub_set>
   11944:	e7cc      	b.n	118e0 <mod_pub_va_set+0xa4>
   11946:	bf00      	nop
   11948:	00029928 	.word	0x00029928
   1194c:	00029830 	.word	0x00029830
   11950:	0002dc69 	.word	0x0002dc69
   11954:	0002df20 	.word	0x0002df20

00011958 <mod_sub_va_add>:
{
   11958:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1195c:	4606      	mov	r6, r0
   1195e:	b087      	sub	sp, #28
	elem_addr = net_buf_simple_pull_le16(buf);
   11960:	4610      	mov	r0, r2
{
   11962:	460f      	mov	r7, r1
   11964:	4614      	mov	r4, r2
	elem_addr = net_buf_simple_pull_le16(buf);
   11966:	f017 f9fe 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   1196a:	b203      	sxth	r3, r0
   1196c:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   1196e:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11970:	dc0c      	bgt.n	1198c <mod_sub_va_add+0x34>
   11972:	492c      	ldr	r1, [pc, #176]	; (11a24 <mod_sub_va_add+0xcc>)
   11974:	4b2c      	ldr	r3, [pc, #176]	; (11a28 <mod_sub_va_add+0xd0>)
		BT_WARN("Prohibited element address");
   11976:	482d      	ldr	r0, [pc, #180]	; (11a2c <mod_sub_va_add+0xd4>)
   11978:	1ac9      	subs	r1, r1, r3
   1197a:	08c9      	lsrs	r1, r1, #3
   1197c:	0189      	lsls	r1, r1, #6
   1197e:	f041 0102 	orr.w	r1, r1, #2
   11982:	f012 fb1f 	bl	23fc4 <log_0>
}
   11986:	b007      	add	sp, #28
   11988:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   1198c:	2110      	movs	r1, #16
   1198e:	4620      	mov	r0, r4
   11990:	f00d fc80 	bl	1f294 <net_buf_simple_pull_mem>
   11994:	4681      	mov	r9, r0
	elem = bt_mesh_elem_find(elem_addr);
   11996:	4628      	mov	r0, r5
	mod_id = buf->data;
   11998:	f8d4 8000 	ldr.w	r8, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   1199c:	f7fe f88c 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   119a0:	b9b8      	cbnz	r0, 119d2 <mod_sub_va_add+0x7a>
		vnd = (buf->len == 4U);
   119a2:	88a2      	ldrh	r2, [r4, #4]
		mod = NULL;
   119a4:	9005      	str	r0, [sp, #20]
		vnd = (buf->len == 4U);
   119a6:	1f11      	subs	r1, r2, #4
   119a8:	424a      	negs	r2, r1
   119aa:	414a      	adcs	r2, r1
   119ac:	f88d 2011 	strb.w	r2, [sp, #17]
		sub_addr = BT_MESH_ADDR_UNASSIGNED;
   119b0:	f8ad 0012 	strh.w	r0, [sp, #18]
		status = STATUS_INVALID_ADDRESS;
   119b4:	2401      	movs	r4, #1
	send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   119b6:	f89d 3011 	ldrb.w	r3, [sp, #17]
   119ba:	e9cd 8301 	strd	r8, r3, [sp, #4]
   119be:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   119c2:	9300      	str	r3, [sp, #0]
   119c4:	4622      	mov	r2, r4
   119c6:	462b      	mov	r3, r5
   119c8:	4639      	mov	r1, r7
   119ca:	4630      	mov	r0, r6
   119cc:	f7fe fc9c 	bl	10308 <send_mod_sub_status>
   119d0:	e7d9      	b.n	11986 <mod_sub_va_add+0x2e>
	mod = get_model(elem, buf, &vnd);
   119d2:	f10d 0211 	add.w	r2, sp, #17
   119d6:	4621      	mov	r1, r4
   119d8:	f015 ffe6 	bl	279a8 <get_model>
   119dc:	9005      	str	r0, [sp, #20]
	if (!mod) {
   119de:	b918      	cbnz	r0, 119e8 <mod_sub_va_add+0x90>
		sub_addr = BT_MESH_ADDR_UNASSIGNED;
   119e0:	f8ad 0012 	strh.w	r0, [sp, #18]
		status = STATUS_INVALID_MODEL;
   119e4:	2402      	movs	r4, #2
		goto send_status;
   119e6:	e7e6      	b.n	119b6 <mod_sub_va_add+0x5e>
	status = va_add(label_uuid, &sub_addr);
   119e8:	f10d 0112 	add.w	r1, sp, #18
   119ec:	4648      	mov	r0, r9
   119ee:	f7ff fe87 	bl	11700 <va_add>
	if (status != STATUS_SUCCESS) {
   119f2:	4604      	mov	r4, r0
   119f4:	2800      	cmp	r0, #0
   119f6:	d1de      	bne.n	119b6 <mod_sub_va_add+0x5e>
	if (bt_mesh_model_find_group(&mod, sub_addr)) {
   119f8:	f8bd 1012 	ldrh.w	r1, [sp, #18]
   119fc:	a805      	add	r0, sp, #20
   119fe:	f015 fead 	bl	2775c <bt_mesh_model_find_group>
   11a02:	2800      	cmp	r0, #0
   11a04:	d1d7      	bne.n	119b6 <mod_sub_va_add+0x5e>
	entry = bt_mesh_model_find_group(&mod, BT_MESH_ADDR_UNASSIGNED);
   11a06:	4621      	mov	r1, r4
   11a08:	a805      	add	r0, sp, #20
   11a0a:	f015 fea7 	bl	2775c <bt_mesh_model_find_group>
	if (!entry) {
   11a0e:	b130      	cbz	r0, 11a1e <mod_sub_va_add+0xc6>
	*entry = sub_addr;
   11a10:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   11a14:	8003      	strh	r3, [r0, #0]
		bt_mesh_store_mod_sub(mod);
   11a16:	9805      	ldr	r0, [sp, #20]
   11a18:	f016 f992 	bl	27d40 <bt_mesh_store_mod_sub>
	status = STATUS_SUCCESS;
   11a1c:	e7cb      	b.n	119b6 <mod_sub_va_add+0x5e>
		status = STATUS_INSUFF_RESOURCES;
   11a1e:	2405      	movs	r4, #5
   11a20:	e7c9      	b.n	119b6 <mod_sub_va_add+0x5e>
   11a22:	bf00      	nop
   11a24:	00029928 	.word	0x00029928
   11a28:	00029830 	.word	0x00029830
   11a2c:	0002dc69 	.word	0x0002dc69

00011a30 <heartbeat_pub_set>:
{
   11a30:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct hb_pub_param *param = (void *)buf->data;
   11a34:	6815      	ldr	r5, [r2, #0]
	dst = sys_le16_to_cpu(param->dst);
   11a36:	f8b5 8000 	ldrh.w	r8, [r5]
	if (BT_MESH_ADDR_IS_VIRTUAL(dst)) {
   11a3a:	f488 4300 	eor.w	r3, r8, #32768	; 0x8000
   11a3e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
{
   11a42:	4606      	mov	r6, r0
   11a44:	460f      	mov	r7, r1
	dst = sys_le16_to_cpu(param->dst);
   11a46:	fa1f fa88 	uxth.w	sl, r8
	if (BT_MESH_ADDR_IS_VIRTUAL(dst)) {
   11a4a:	d374      	bcc.n	11b36 <heartbeat_pub_set+0x106>
	if (param->count_log > 0x11 && param->count_log != 0xff) {
   11a4c:	78ab      	ldrb	r3, [r5, #2]
   11a4e:	3b12      	subs	r3, #18
   11a50:	b2db      	uxtb	r3, r3
   11a52:	2bec      	cmp	r3, #236	; 0xec
   11a54:	d972      	bls.n	11b3c <heartbeat_pub_set+0x10c>
	if (param->period_log > 0x10) {
   11a56:	78eb      	ldrb	r3, [r5, #3]
   11a58:	2b10      	cmp	r3, #16
   11a5a:	d86f      	bhi.n	11b3c <heartbeat_pub_set+0x10c>
	if (param->ttl > BT_MESH_TTL_MAX && param->ttl != BT_MESH_TTL_DEFAULT) {
   11a5c:	7929      	ldrb	r1, [r5, #4]
   11a5e:	f081 0380 	eor.w	r3, r1, #128	; 0x80
   11a62:	2b7e      	cmp	r3, #126	; 0x7e
   11a64:	d80c      	bhi.n	11a80 <heartbeat_pub_set+0x50>
   11a66:	4a37      	ldr	r2, [pc, #220]	; (11b44 <heartbeat_pub_set+0x114>)
   11a68:	4b37      	ldr	r3, [pc, #220]	; (11b48 <heartbeat_pub_set+0x118>)
		BT_ERR("Invalid TTL value 0x%02x", param->ttl);
   11a6a:	4838      	ldr	r0, [pc, #224]	; (11b4c <heartbeat_pub_set+0x11c>)
   11a6c:	1ad2      	subs	r2, r2, r3
   11a6e:	08d2      	lsrs	r2, r2, #3
   11a70:	0192      	lsls	r2, r2, #6
   11a72:	f042 0201 	orr.w	r2, r2, #1
}
   11a76:	b001      	add	sp, #4
   11a78:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   11a7c:	f012 baaf 	b.w	23fde <log_1>
	idx = sys_le16_to_cpu(param->net_idx);
   11a80:	f8b5 9007 	ldrh.w	r9, [r5, #7]
	if (idx > 0xfff) {
   11a84:	f5b9 5f80 	cmp.w	r9, #4096	; 0x1000
	idx = sys_le16_to_cpu(param->net_idx);
   11a88:	fa1f f189 	uxth.w	r1, r9
	if (idx > 0xfff) {
   11a8c:	d308      	bcc.n	11aa0 <heartbeat_pub_set+0x70>
   11a8e:	4a2d      	ldr	r2, [pc, #180]	; (11b44 <heartbeat_pub_set+0x114>)
   11a90:	4b2d      	ldr	r3, [pc, #180]	; (11b48 <heartbeat_pub_set+0x118>)
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   11a92:	482f      	ldr	r0, [pc, #188]	; (11b50 <heartbeat_pub_set+0x120>)
   11a94:	1ad2      	subs	r2, r2, r3
   11a96:	08d2      	lsrs	r2, r2, #3
   11a98:	0192      	lsls	r2, r2, #6
   11a9a:	f042 0201 	orr.w	r2, r2, #1
   11a9e:	e7ea      	b.n	11a76 <heartbeat_pub_set+0x46>
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   11aa0:	69c4      	ldr	r4, [r0, #28]
	feat = sys_le16_to_cpu(param->feat);
   11aa2:	f8b5 b005 	ldrh.w	fp, [r5, #5]
	if (!bt_mesh_subnet_get(idx)) {
   11aa6:	4608      	mov	r0, r1
   11aa8:	f7fa ffa0 	bl	c9ec <bt_mesh_subnet_get>
   11aac:	2800      	cmp	r0, #0
   11aae:	d047      	beq.n	11b40 <heartbeat_pub_set+0x110>
	cfg->hb_pub.dst = dst;
   11ab0:	f8a4 802c 	strh.w	r8, [r4, #44]	; 0x2c
	cfg->hb_pub.period = param->period_log;
   11ab4:	78ea      	ldrb	r2, [r5, #3]
   11ab6:	f884 2030 	strb.w	r2, [r4, #48]	; 0x30
	cfg->hb_pub.feat = feat & BT_MESH_FEAT_SUPPORTED;
   11aba:	f00b 0b0f 	and.w	fp, fp, #15
   11abe:	f8a4 b032 	strh.w	fp, [r4, #50]	; 0x32
	cfg->hb_pub.net_idx = idx;
   11ac2:	f8a4 9034 	strh.w	r9, [r4, #52]	; 0x34
	if (dst == BT_MESH_ADDR_UNASSIGNED) {
   11ac6:	f104 010c 	add.w	r1, r4, #12
   11aca:	f1ba 0f00 	cmp.w	sl, #0
   11ace:	d107      	bne.n	11ae0 <heartbeat_pub_set+0xb0>
	cfg->hb_pub.dst = BT_MESH_ADDR_UNASSIGNED;
   11ad0:	f8c4 a02c 	str.w	sl, [r4, #44]	; 0x2c
	cfg->hb_pub.period = 0U;
   11ad4:	f8a4 8030 	strh.w	r8, [r4, #48]	; 0x30
			k_delayed_work_cancel(&cfg->hb_pub.timer);
   11ad8:	4608      	mov	r0, r1
   11ada:	f011 f8d1 	bl	22c80 <k_delayed_work_cancel>
   11ade:	e01f      	b.n	11b20 <heartbeat_pub_set+0xf0>
		cfg->hb_pub.count = hb_pwr2(param->count_log, 1);
   11ae0:	f895 8002 	ldrb.w	r8, [r5, #2]
   11ae4:	4640      	mov	r0, r8
   11ae6:	f015 ff80 	bl	279ea <hb_pwr2.constprop.0>
   11aea:	85e0      	strh	r0, [r4, #46]	; 0x2e
		cfg->hb_pub.ttl = param->ttl;
   11aec:	792b      	ldrb	r3, [r5, #4]
   11aee:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
		if (param->period_log && param->count_log) {
   11af2:	2a00      	cmp	r2, #0
   11af4:	d0f0      	beq.n	11ad8 <heartbeat_pub_set+0xa8>
   11af6:	f1b8 0f00 	cmp.w	r8, #0
   11afa:	d0ed      	beq.n	11ad8 <heartbeat_pub_set+0xa8>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   11afc:	3414      	adds	r4, #20
   11afe:	f3bf 8f5b 	dmb	ish
   11b02:	e854 3f00 	ldrex	r3, [r4]
   11b06:	f043 0201 	orr.w	r2, r3, #1
   11b0a:	e844 2000 	strex	r0, r2, [r4]
   11b0e:	2800      	cmp	r0, #0
   11b10:	d1f7      	bne.n	11b02 <heartbeat_pub_set+0xd2>
   11b12:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   11b16:	07db      	lsls	r3, r3, #31
   11b18:	d402      	bmi.n	11b20 <heartbeat_pub_set+0xf0>
		k_queue_append(&work_q->queue, work);
   11b1a:	480e      	ldr	r0, [pc, #56]	; (11b54 <heartbeat_pub_set+0x124>)
   11b1c:	f017 fb99 	bl	29252 <k_queue_append>
		bt_mesh_store_hb_pub();
   11b20:	f016 f8b0 	bl	27c84 <bt_mesh_store_hb_pub>
	hb_pub_send_status(model, ctx, STATUS_SUCCESS, NULL);
   11b24:	2300      	movs	r3, #0
   11b26:	461a      	mov	r2, r3
	hb_pub_send_status(model, ctx, status, param);
   11b28:	4639      	mov	r1, r7
   11b2a:	4630      	mov	r0, r6
}
   11b2c:	b001      	add	sp, #4
   11b2e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	hb_pub_send_status(model, ctx, status, param);
   11b32:	f7fe bb83 	b.w	1023c <hb_pub_send_status>
		status = STATUS_INVALID_ADDRESS;
   11b36:	2201      	movs	r2, #1
	hb_pub_send_status(model, ctx, status, param);
   11b38:	462b      	mov	r3, r5
   11b3a:	e7f5      	b.n	11b28 <heartbeat_pub_set+0xf8>
		status = STATUS_CANNOT_SET;
   11b3c:	220f      	movs	r2, #15
   11b3e:	e7fb      	b.n	11b38 <heartbeat_pub_set+0x108>
		status = STATUS_INVALID_NETKEY;
   11b40:	2204      	movs	r2, #4
   11b42:	e7f9      	b.n	11b38 <heartbeat_pub_set+0x108>
   11b44:	00029928 	.word	0x00029928
   11b48:	00029830 	.word	0x00029830
   11b4c:	0002df20 	.word	0x0002df20
   11b50:	0002db35 	.word	0x0002db35
   11b54:	20001dc4 	.word	0x20001dc4

00011b58 <hb_publish>:
{
   11b58:	b538      	push	{r3, r4, r5, lr}
   11b5a:	4604      	mov	r4, r0
	sub = bt_mesh_subnet_get(cfg->hb_pub.net_idx);
   11b5c:	8d00      	ldrh	r0, [r0, #40]	; 0x28
   11b5e:	f7fa ff45 	bl	c9ec <bt_mesh_subnet_get>
	if (!sub) {
   11b62:	4605      	mov	r5, r0
   11b64:	b960      	cbnz	r0, 11b80 <hb_publish+0x28>
   11b66:	4b16      	ldr	r3, [pc, #88]	; (11bc0 <hb_publish+0x68>)
   11b68:	4a16      	ldr	r2, [pc, #88]	; (11bc4 <hb_publish+0x6c>)
		BT_ERR("No matching subnet for idx 0x%02x",
   11b6a:	8d21      	ldrh	r1, [r4, #40]	; 0x28
   11b6c:	4816      	ldr	r0, [pc, #88]	; (11bc8 <hb_publish+0x70>)
   11b6e:	1ad2      	subs	r2, r2, r3
   11b70:	08d2      	lsrs	r2, r2, #3
   11b72:	0192      	lsls	r2, r2, #6
   11b74:	f042 0201 	orr.w	r2, r2, #1
   11b78:	f012 fa31 	bl	23fde <log_1>
		cfg->hb_pub.dst = BT_MESH_ADDR_UNASSIGNED;
   11b7c:	8425      	strh	r5, [r4, #32]
}
   11b7e:	bd38      	pop	{r3, r4, r5, pc}
	if (cfg->hb_pub.count == 0U) {
   11b80:	8c61      	ldrh	r1, [r4, #34]	; 0x22
   11b82:	2900      	cmp	r1, #0
   11b84:	d0fb      	beq.n	11b7e <hb_publish+0x26>
	period_ms = hb_pwr2(cfg->hb_pub.period, 1) * 1000U;
   11b86:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
   11b8a:	f015 ff2e 	bl	279ea <hb_pwr2.constprop.0>
   11b8e:	ebc0 1240 	rsb	r2, r0, r0, lsl #5
   11b92:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   11b96:	00d2      	lsls	r2, r2, #3
   11b98:	b292      	uxth	r2, r2
	if (period_ms && cfg->hb_pub.count > 1) {
   11b9a:	b12a      	cbz	r2, 11ba8 <hb_publish+0x50>
   11b9c:	2901      	cmp	r1, #1
   11b9e:	d903      	bls.n	11ba8 <hb_publish+0x50>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   11ba0:	480a      	ldr	r0, [pc, #40]	; (11bcc <hb_publish+0x74>)
   11ba2:	4621      	mov	r1, r4
   11ba4:	f010 ffdc 	bl	22b60 <k_delayed_work_submit_to_queue>
	bt_mesh_heartbeat_send();
   11ba8:	f015 fb9c 	bl	272e4 <bt_mesh_heartbeat_send>
	if (cfg->hb_pub.count != 0xffff) {
   11bac:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   11bae:	f64f 72ff 	movw	r2, #65535	; 0xffff
   11bb2:	4293      	cmp	r3, r2
		cfg->hb_pub.count--;
   11bb4:	bf1c      	itt	ne
   11bb6:	f103 33ff 	addne.w	r3, r3, #4294967295	; 0xffffffff
   11bba:	8463      	strhne	r3, [r4, #34]	; 0x22
   11bbc:	e7df      	b.n	11b7e <hb_publish+0x26>
   11bbe:	bf00      	nop
   11bc0:	00029830 	.word	0x00029830
   11bc4:	00029928 	.word	0x00029928
   11bc8:	0002dfc0 	.word	0x0002dfc0
   11bcc:	20001dc4 	.word	0x20001dc4

00011bd0 <va_del>:
{
   11bd0:	b538      	push	{r3, r4, r5, lr}
		if (labels[i].ref == 0) {
   11bd2:	4d0e      	ldr	r5, [pc, #56]	; (11c0c <va_del+0x3c>)
   11bd4:	882b      	ldrh	r3, [r5, #0]
{
   11bd6:	460c      	mov	r4, r1
		if (labels[i].ref == 0) {
   11bd8:	b913      	cbnz	r3, 11be0 <va_del+0x10>
	if (addr) {
   11bda:	b99c      	cbnz	r4, 11c04 <va_del+0x34>
	return STATUS_CANNOT_REMOVE;
   11bdc:	200c      	movs	r0, #12
   11bde:	e010      	b.n	11c02 <va_del+0x32>
		if (!memcmp(labels[i].uuid, label_uuid, 16)) {
   11be0:	4601      	mov	r1, r0
   11be2:	2210      	movs	r2, #16
   11be4:	1d28      	adds	r0, r5, #4
   11be6:	f014 f84f 	bl	25c88 <memcmp>
   11bea:	2800      	cmp	r0, #0
   11bec:	d1f5      	bne.n	11bda <va_del+0xa>
		update->ref--;
   11bee:	882b      	ldrh	r3, [r5, #0]
   11bf0:	3b01      	subs	r3, #1
   11bf2:	802b      	strh	r3, [r5, #0]
		if (addr) {
   11bf4:	b10c      	cbz	r4, 11bfa <va_del+0x2a>
			*addr = update->addr;
   11bf6:	886b      	ldrh	r3, [r5, #2]
   11bf8:	8023      	strh	r3, [r4, #0]
		va_store(update);
   11bfa:	4804      	ldr	r0, [pc, #16]	; (11c0c <va_del+0x3c>)
   11bfc:	f015 ff03 	bl	27a06 <va_store>
		return STATUS_SUCCESS;
   11c00:	2000      	movs	r0, #0
}
   11c02:	bd38      	pop	{r3, r4, r5, pc}
		*addr = BT_MESH_ADDR_UNASSIGNED;
   11c04:	2300      	movs	r3, #0
   11c06:	8023      	strh	r3, [r4, #0]
   11c08:	e7e8      	b.n	11bdc <va_del+0xc>
   11c0a:	bf00      	nop
   11c0c:	2000090c 	.word	0x2000090c

00011c10 <mod_sub_va_del>:
{
   11c10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11c14:	4606      	mov	r6, r0
   11c16:	b087      	sub	sp, #28
	elem_addr = net_buf_simple_pull_le16(buf);
   11c18:	4610      	mov	r0, r2
{
   11c1a:	460f      	mov	r7, r1
   11c1c:	4614      	mov	r4, r2
	elem_addr = net_buf_simple_pull_le16(buf);
   11c1e:	f017 f8a2 	bl	28d66 <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11c22:	b203      	sxth	r3, r0
   11c24:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   11c26:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11c28:	dc0c      	bgt.n	11c44 <mod_sub_va_del+0x34>
   11c2a:	4928      	ldr	r1, [pc, #160]	; (11ccc <mod_sub_va_del+0xbc>)
   11c2c:	4b28      	ldr	r3, [pc, #160]	; (11cd0 <mod_sub_va_del+0xc0>)
		BT_WARN("Prohibited element address");
   11c2e:	4829      	ldr	r0, [pc, #164]	; (11cd4 <mod_sub_va_del+0xc4>)
   11c30:	1ac9      	subs	r1, r1, r3
   11c32:	08c9      	lsrs	r1, r1, #3
   11c34:	0189      	lsls	r1, r1, #6
   11c36:	f041 0102 	orr.w	r1, r1, #2
   11c3a:	f012 f9c3 	bl	23fc4 <log_0>
}
   11c3e:	b007      	add	sp, #28
   11c40:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   11c44:	2110      	movs	r1, #16
   11c46:	4620      	mov	r0, r4
   11c48:	f00d fb24 	bl	1f294 <net_buf_simple_pull_mem>
   11c4c:	4681      	mov	r9, r0
	elem = bt_mesh_elem_find(elem_addr);
   11c4e:	4628      	mov	r0, r5
	mod_id = buf->data;
   11c50:	f8d4 8000 	ldr.w	r8, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   11c54:	f7fd ff30 	bl	fab8 <bt_mesh_elem_find>
	if (!elem) {
   11c58:	b9b0      	cbnz	r0, 11c88 <mod_sub_va_del+0x78>
		vnd = (buf->len == 4U);
   11c5a:	88a2      	ldrh	r2, [r4, #4]
		mod = NULL;
   11c5c:	9005      	str	r0, [sp, #20]
		vnd = (buf->len == 4U);
   11c5e:	1f11      	subs	r1, r2, #4
   11c60:	424a      	negs	r2, r1
   11c62:	414a      	adcs	r2, r1
   11c64:	f88d 2011 	strb.w	r2, [sp, #17]
		sub_addr = BT_MESH_ADDR_UNASSIGNED;
   11c68:	f8ad 0012 	strh.w	r0, [sp, #18]
		status = STATUS_INVALID_ADDRESS;
   11c6c:	2201      	movs	r2, #1
	send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   11c6e:	f89d 3011 	ldrb.w	r3, [sp, #17]
   11c72:	e9cd 8301 	strd	r8, r3, [sp, #4]
   11c76:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   11c7a:	9300      	str	r3, [sp, #0]
   11c7c:	4639      	mov	r1, r7
   11c7e:	462b      	mov	r3, r5
   11c80:	4630      	mov	r0, r6
   11c82:	f7fe fb41 	bl	10308 <send_mod_sub_status>
   11c86:	e7da      	b.n	11c3e <mod_sub_va_del+0x2e>
	mod = get_model(elem, buf, &vnd);
   11c88:	f10d 0211 	add.w	r2, sp, #17
   11c8c:	4621      	mov	r1, r4
   11c8e:	f015 fe8b 	bl	279a8 <get_model>
   11c92:	9005      	str	r0, [sp, #20]
	if (!mod) {
   11c94:	b918      	cbnz	r0, 11c9e <mod_sub_va_del+0x8e>
		sub_addr = BT_MESH_ADDR_UNASSIGNED;
   11c96:	f8ad 0012 	strh.w	r0, [sp, #18]
		status = STATUS_INVALID_MODEL;
   11c9a:	2202      	movs	r2, #2
		goto send_status;
   11c9c:	e7e7      	b.n	11c6e <mod_sub_va_del+0x5e>
	status = va_del(label_uuid, &sub_addr);
   11c9e:	f10d 0112 	add.w	r1, sp, #18
   11ca2:	4648      	mov	r0, r9
   11ca4:	f7ff ff94 	bl	11bd0 <va_del>
	if (sub_addr == BT_MESH_ADDR_UNASSIGNED) {
   11ca8:	f8bd 1012 	ldrh.w	r1, [sp, #18]
	status = va_del(label_uuid, &sub_addr);
   11cac:	4602      	mov	r2, r0
	if (sub_addr == BT_MESH_ADDR_UNASSIGNED) {
   11cae:	2900      	cmp	r1, #0
   11cb0:	d0dd      	beq.n	11c6e <mod_sub_va_del+0x5e>
	match = bt_mesh_model_find_group(&mod, sub_addr);
   11cb2:	a805      	add	r0, sp, #20
   11cb4:	f015 fd52 	bl	2775c <bt_mesh_model_find_group>
	if (match) {
   11cb8:	b130      	cbz	r0, 11cc8 <mod_sub_va_del+0xb8>
		*match = BT_MESH_ADDR_UNASSIGNED;
   11cba:	2400      	movs	r4, #0
   11cbc:	8004      	strh	r4, [r0, #0]
			bt_mesh_store_mod_sub(mod);
   11cbe:	9805      	ldr	r0, [sp, #20]
   11cc0:	f016 f83e 	bl	27d40 <bt_mesh_store_mod_sub>
		status = STATUS_SUCCESS;
   11cc4:	4622      	mov	r2, r4
   11cc6:	e7d2      	b.n	11c6e <mod_sub_va_del+0x5e>
		status = STATUS_CANNOT_REMOVE;
   11cc8:	220c      	movs	r2, #12
   11cca:	e7d0      	b.n	11c6e <mod_sub_va_del+0x5e>
   11ccc:	00029928 	.word	0x00029928
   11cd0:	00029830 	.word	0x00029830
   11cd4:	0002dc69 	.word	0x0002dc69

00011cd8 <hb_sub_send_status.constprop.0>:
static void hb_sub_send_status(struct bt_mesh_model *model,
   11cd8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11cdc:	b08a      	sub	sp, #40	; 0x28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_SUB_STATUS, 9);
   11cde:	ab06      	add	r3, sp, #24
   11ce0:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   11ce4:	e9cd 2304 	strd	r2, r3, [sp, #16]
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   11ce8:	69c6      	ldr	r6, [r0, #28]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_SUB_STATUS, 9);
   11cea:	9303      	str	r3, [sp, #12]
static void hb_sub_send_status(struct bt_mesh_model *model,
   11cec:	4607      	mov	r7, r0
   11cee:	468a      	mov	sl, r1
   11cf0:	f017 fb8f 	bl	29412 <z_impl_k_uptime_ticks>
			return (t * to_hz + off) / from_hz;
   11cf4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
	if (uptime > cfg->hb_sub.expiry) {
   11cf8:	e9d6 890e 	ldrd	r8, r9, [r6, #56]	; 0x38
   11cfc:	460a      	mov	r2, r1
   11cfe:	fba0 0103 	umull	r0, r1, r0, r3
   11d02:	fb03 1102 	mla	r1, r3, r2, r1
   11d06:	0bc4      	lsrs	r4, r0, #15
   11d08:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
   11d0c:	0bcd      	lsrs	r5, r1, #15
   11d0e:	45a0      	cmp	r8, r4
   11d10:	eb79 0305 	sbcs.w	r3, r9, r5
   11d14:	db5a      	blt.n	11dcc <hb_sub_send_status.constprop.0+0xf4>
		period = (cfg->hb_sub.expiry - uptime) / 1000;
   11d16:	ebb8 0004 	subs.w	r0, r8, r4
   11d1a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   11d1e:	f04f 0300 	mov.w	r3, #0
   11d22:	eb69 0105 	sbc.w	r1, r9, r5
   11d26:	f7ee f9eb 	bl	100 <__aeabi_ldivmod>
   11d2a:	b284      	uxth	r4, r0
	bt_mesh_model_msg_init(&msg, OP_HEARTBEAT_SUB_STATUS);
   11d2c:	f248 013c 	movw	r1, #32828	; 0x803c
   11d30:	a803      	add	r0, sp, #12
   11d32:	f015 fd3d 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   11d36:	2100      	movs	r1, #0
   11d38:	a803      	add	r0, sp, #12
   11d3a:	f017 f848 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, cfg->hb_sub.src);
   11d3e:	f8b6 1040 	ldrh.w	r1, [r6, #64]	; 0x40
   11d42:	a803      	add	r0, sp, #12
   11d44:	f017 f84a 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, cfg->hb_sub.dst);
   11d48:	f8b6 1042 	ldrh.w	r1, [r6, #66]	; 0x42
   11d4c:	a803      	add	r0, sp, #12
   11d4e:	f017 f845 	bl	28ddc <net_buf_simple_add_le16>
	if (!val) {
   11d52:	2c00      	cmp	r4, #0
   11d54:	d03c      	beq.n	11dd0 <hb_sub_send_status.constprop.0+0xf8>
	} else if (val == 0xffff) {
   11d56:	f64f 73ff 	movw	r3, #65535	; 0xffff
   11d5a:	429c      	cmp	r4, r3
   11d5c:	d03a      	beq.n	11dd4 <hb_sub_send_status.constprop.0+0xfc>
		return 32 - __builtin_clz(val);
   11d5e:	fab4 f484 	clz	r4, r4
   11d62:	f1c4 0420 	rsb	r4, r4, #32
   11d66:	b2e1      	uxtb	r1, r4
	net_buf_simple_add_u8(&msg, hb_log(period));
   11d68:	a803      	add	r0, sp, #12
   11d6a:	f017 f830 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, hb_log(cfg->hb_sub.count));
   11d6e:	f8b6 1044 	ldrh.w	r1, [r6, #68]	; 0x44
	if (!val) {
   11d72:	b149      	cbz	r1, 11d88 <hb_sub_send_status.constprop.0+0xb0>
	} else if (val == 0xffff) {
   11d74:	f64f 73ff 	movw	r3, #65535	; 0xffff
   11d78:	4299      	cmp	r1, r3
		return 32 - __builtin_clz(val);
   11d7a:	bf1d      	ittte	ne
   11d7c:	fab1 f181 	clzne	r1, r1
   11d80:	f1c1 0120 	rsbne	r1, r1, #32
   11d84:	b2c9      	uxtbne	r1, r1
		return 0xff;
   11d86:	21ff      	moveq	r1, #255	; 0xff
	net_buf_simple_add_u8(&msg, hb_log(cfg->hb_sub.count));
   11d88:	a803      	add	r0, sp, #12
   11d8a:	f017 f820 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, cfg->hb_sub.min_hops);
   11d8e:	f896 1046 	ldrb.w	r1, [r6, #70]	; 0x46
   11d92:	a803      	add	r0, sp, #12
   11d94:	f017 f81b 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, cfg->hb_sub.max_hops);
   11d98:	f896 1047 	ldrb.w	r1, [r6, #71]	; 0x47
   11d9c:	a803      	add	r0, sp, #12
   11d9e:	f017 f816 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   11da2:	2300      	movs	r3, #0
   11da4:	9300      	str	r3, [sp, #0]
   11da6:	aa03      	add	r2, sp, #12
   11da8:	4651      	mov	r1, sl
   11daa:	4638      	mov	r0, r7
   11dac:	f015 fd29 	bl	27802 <bt_mesh_model_send>
   11db0:	b148      	cbz	r0, 11dc6 <hb_sub_send_status.constprop.0+0xee>
   11db2:	4909      	ldr	r1, [pc, #36]	; (11dd8 <hb_sub_send_status.constprop.0+0x100>)
   11db4:	4b09      	ldr	r3, [pc, #36]	; (11ddc <hb_sub_send_status.constprop.0+0x104>)
		BT_ERR("Unable to send Heartbeat Subscription Status");
   11db6:	480a      	ldr	r0, [pc, #40]	; (11de0 <hb_sub_send_status.constprop.0+0x108>)
   11db8:	1ac9      	subs	r1, r1, r3
   11dba:	08c9      	lsrs	r1, r1, #3
   11dbc:	0189      	lsls	r1, r1, #6
   11dbe:	f041 0101 	orr.w	r1, r1, #1
   11dc2:	f012 f8ff 	bl	23fc4 <log_0>
}
   11dc6:	b00a      	add	sp, #40	; 0x28
   11dc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		period = 0U;
   11dcc:	2400      	movs	r4, #0
   11dce:	e7ad      	b.n	11d2c <hb_sub_send_status.constprop.0+0x54>
		return 0x00;
   11dd0:	4621      	mov	r1, r4
   11dd2:	e7c9      	b.n	11d68 <hb_sub_send_status.constprop.0+0x90>
		return 0xff;
   11dd4:	21ff      	movs	r1, #255	; 0xff
   11dd6:	e7c7      	b.n	11d68 <hb_sub_send_status.constprop.0+0x90>
   11dd8:	00029928 	.word	0x00029928
   11ddc:	00029830 	.word	0x00029830
   11de0:	0002dfe2 	.word	0x0002dfe2

00011de4 <heartbeat_sub_set>:
{
   11de4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   11de8:	69c5      	ldr	r5, [r0, #28]
{
   11dea:	4607      	mov	r7, r0
	sub_src = net_buf_simple_pull_le16(buf);
   11dec:	4610      	mov	r0, r2
{
   11dee:	4614      	mov	r4, r2
   11df0:	4688      	mov	r8, r1
	sub_src = net_buf_simple_pull_le16(buf);
   11df2:	f016 ffb8 	bl	28d66 <net_buf_simple_pull_le16>
   11df6:	4681      	mov	r9, r0
	sub_dst = net_buf_simple_pull_le16(buf);
   11df8:	4620      	mov	r0, r4
   11dfa:	f016 ffb4 	bl	28d66 <net_buf_simple_pull_le16>
   11dfe:	4606      	mov	r6, r0
	sub_period = net_buf_simple_pull_u8(buf);
   11e00:	4620      	mov	r0, r4
   11e02:	f016 ffa8 	bl	28d56 <net_buf_simple_pull_u8>
	if (sub_src != BT_MESH_ADDR_UNASSIGNED &&
   11e06:	f419 4f00 	tst.w	r9, #32768	; 0x8000
	sub_period = net_buf_simple_pull_u8(buf);
   11e0a:	4604      	mov	r4, r0
	if (sub_src != BT_MESH_ADDR_UNASSIGNED &&
   11e0c:	d00b      	beq.n	11e26 <heartbeat_sub_set+0x42>
   11e0e:	4938      	ldr	r1, [pc, #224]	; (11ef0 <heartbeat_sub_set+0x10c>)
   11e10:	4b38      	ldr	r3, [pc, #224]	; (11ef4 <heartbeat_sub_set+0x110>)
		BT_WARN("Prohibited source address");
   11e12:	4839      	ldr	r0, [pc, #228]	; (11ef8 <heartbeat_sub_set+0x114>)
   11e14:	1ac9      	subs	r1, r1, r3
   11e16:	08c9      	lsrs	r1, r1, #3
   11e18:	0189      	lsls	r1, r1, #6
   11e1a:	f041 0102 	orr.w	r1, r1, #2
}
   11e1e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		BT_WARN("Prohibited destination address");
   11e22:	f012 b8cf 	b.w	23fc4 <log_0>
	if (BT_MESH_ADDR_IS_VIRTUAL(sub_dst) || BT_MESH_ADDR_IS_RFU(sub_dst) ||
   11e26:	f5a6 4300 	sub.w	r3, r6, #32768	; 0x8000
   11e2a:	b29b      	uxth	r3, r3
   11e2c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   11e30:	d208      	bcs.n	11e44 <heartbeat_sub_set+0x60>
   11e32:	492f      	ldr	r1, [pc, #188]	; (11ef0 <heartbeat_sub_set+0x10c>)
   11e34:	4b2f      	ldr	r3, [pc, #188]	; (11ef4 <heartbeat_sub_set+0x110>)
		BT_WARN("Prohibited destination address");
   11e36:	4831      	ldr	r0, [pc, #196]	; (11efc <heartbeat_sub_set+0x118>)
   11e38:	1ac9      	subs	r1, r1, r3
   11e3a:	08c9      	lsrs	r1, r1, #3
   11e3c:	0189      	lsls	r1, r1, #6
   11e3e:	f041 0102 	orr.w	r1, r1, #2
   11e42:	e7ec      	b.n	11e1e <heartbeat_sub_set+0x3a>
	if (BT_MESH_ADDR_IS_VIRTUAL(sub_dst) || BT_MESH_ADDR_IS_RFU(sub_dst) ||
   11e44:	f506 7380 	add.w	r3, r6, #256	; 0x100
   11e48:	b29b      	uxth	r3, r3
   11e4a:	2bfb      	cmp	r3, #251	; 0xfb
   11e4c:	d9f1      	bls.n	11e32 <heartbeat_sub_set+0x4e>
   11e4e:	b233      	sxth	r3, r6
   11e50:	2b00      	cmp	r3, #0
   11e52:	dd03      	ble.n	11e5c <heartbeat_sub_set+0x78>
	     sub_dst != bt_mesh_primary_addr())) {
   11e54:	f7fd fe2a 	bl	faac <bt_mesh_primary_addr>
	    (BT_MESH_ADDR_IS_UNICAST(sub_dst) &&
   11e58:	42b0      	cmp	r0, r6
   11e5a:	d1ea      	bne.n	11e32 <heartbeat_sub_set+0x4e>
	if (sub_period > 0x11) {
   11e5c:	2c11      	cmp	r4, #17
   11e5e:	d90c      	bls.n	11e7a <heartbeat_sub_set+0x96>
   11e60:	4b24      	ldr	r3, [pc, #144]	; (11ef4 <heartbeat_sub_set+0x110>)
   11e62:	4a23      	ldr	r2, [pc, #140]	; (11ef0 <heartbeat_sub_set+0x10c>)
		BT_WARN("Prohibited subscription period 0x%02x", sub_period);
   11e64:	4826      	ldr	r0, [pc, #152]	; (11f00 <heartbeat_sub_set+0x11c>)
   11e66:	1ad2      	subs	r2, r2, r3
   11e68:	08d2      	lsrs	r2, r2, #3
   11e6a:	0192      	lsls	r2, r2, #6
   11e6c:	4621      	mov	r1, r4
   11e6e:	f042 0202 	orr.w	r2, r2, #2
}
   11e72:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		BT_WARN("Prohibited subscription period 0x%02x", sub_period);
   11e76:	f012 b8b2 	b.w	23fde <log_1>
	if (sub_src == BT_MESH_ADDR_UNASSIGNED ||
   11e7a:	f1b9 0f00 	cmp.w	r9, #0
   11e7e:	d00f      	beq.n	11ea0 <heartbeat_sub_set+0xbc>
   11e80:	b176      	cbz	r6, 11ea0 <heartbeat_sub_set+0xbc>
	    sub_dst == BT_MESH_ADDR_UNASSIGNED ||
   11e82:	b194      	cbz	r4, 11eaa <heartbeat_sub_set+0xc6>
		cfg->hb_sub.count = 0U;
   11e84:	f44f 03fe 	mov.w	r3, #8323072	; 0x7f0000
		period_ms = hb_pwr2(sub_period, 1) * 1000U;
   11e88:	4620      	mov	r0, r4
		cfg->hb_sub.src = sub_src;
   11e8a:	f8a5 9040 	strh.w	r9, [r5, #64]	; 0x40
		cfg->hb_sub.dst = sub_dst;
   11e8e:	f8a5 6042 	strh.w	r6, [r5, #66]	; 0x42
		cfg->hb_sub.count = 0U;
   11e92:	646b      	str	r3, [r5, #68]	; 0x44
		period_ms = hb_pwr2(sub_period, 1) * 1000U;
   11e94:	f015 fda9 	bl	279ea <hb_pwr2.constprop.0>
   11e98:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   11e9c:	4344      	muls	r4, r0
   11e9e:	e004      	b.n	11eaa <heartbeat_sub_set+0xc6>
			cfg->hb_sub.count = 0U;
   11ea0:	2400      	movs	r4, #0
   11ea2:	f44f 03fe 	mov.w	r3, #8323072	; 0x7f0000
   11ea6:	e9c5 4310 	strd	r4, r3, [r5, #64]	; 0x40
	bt_mesh_set_hb_sub_dst(cfg->hb_sub.dst);
   11eaa:	f8b5 0042 	ldrh.w	r0, [r5, #66]	; 0x42
   11eae:	f7fc fc8f 	bl	e7d0 <bt_mesh_set_hb_sub_dst>
	if (period_ms) {
   11eb2:	b1d4      	cbz	r4, 11eea <heartbeat_sub_set+0x106>
   11eb4:	f017 faad 	bl	29412 <z_impl_k_uptime_ticks>
   11eb8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   11ebc:	460a      	mov	r2, r1
   11ebe:	fba0 0103 	umull	r0, r1, r0, r3
   11ec2:	fb03 1102 	mla	r1, r3, r2, r1
   11ec6:	0bc2      	lsrs	r2, r0, #15
   11ec8:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
   11ecc:	0bcb      	lsrs	r3, r1, #15
		cfg->hb_sub.expiry = k_uptime_get() + period_ms;
   11ece:	1912      	adds	r2, r2, r4
   11ed0:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
		cfg->hb_sub.expiry = 0;
   11ed4:	e9c5 230e 	strd	r2, r3, [r5, #56]	; 0x38
	hb_sub_send_status(model, ctx, STATUS_SUCCESS);
   11ed8:	4641      	mov	r1, r8
   11eda:	4638      	mov	r0, r7
   11edc:	f7ff fefc 	bl	11cd8 <hb_sub_send_status.constprop.0>
	if (!period_ms) {
   11ee0:	b90c      	cbnz	r4, 11ee6 <heartbeat_sub_set+0x102>
		cfg->hb_sub.min_hops = 0U;
   11ee2:	f885 4046 	strb.w	r4, [r5, #70]	; 0x46
}
   11ee6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		cfg->hb_sub.expiry = 0;
   11eea:	2200      	movs	r2, #0
   11eec:	2300      	movs	r3, #0
   11eee:	e7f1      	b.n	11ed4 <heartbeat_sub_set+0xf0>
   11ef0:	00029928 	.word	0x00029928
   11ef4:	00029830 	.word	0x00029830
   11ef8:	0002e00f 	.word	0x0002e00f
   11efc:	0002e029 	.word	0x0002e029
   11f00:	0002e048 	.word	0x0002e048

00011f04 <bt_mesh_app_key_alloc>:
		if (key->net_idx == BT_MESH_KEY_UNUSED) {
   11f04:	4808      	ldr	r0, [pc, #32]	; (11f28 <bt_mesh_app_key_alloc+0x24>)
   11f06:	f8b0 214c 	ldrh.w	r2, [r0, #332]	; 0x14c
   11f0a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   11f0e:	429a      	cmp	r2, r3
   11f10:	d007      	beq.n	11f22 <bt_mesh_app_key_alloc+0x1e>
   11f12:	f8b0 2174 	ldrh.w	r2, [r0, #372]	; 0x174
		struct bt_mesh_app_key *key = &bt_mesh.app_keys[i];
   11f16:	f500 70ba 	add.w	r0, r0, #372	; 0x174
   11f1a:	429a      	cmp	r2, r3
   11f1c:	bf18      	it	ne
   11f1e:	2000      	movne	r0, #0
   11f20:	4770      	bx	lr
   11f22:	f500 70a6 	add.w	r0, r0, #332	; 0x14c
}
   11f26:	4770      	bx	lr
   11f28:	20006b48 	.word	0x20006b48

00011f2c <app_key_update>:
{
   11f2c:	b570      	push	{r4, r5, r6, lr}
   11f2e:	b08a      	sub	sp, #40	; 0x28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   11f30:	ab04      	add	r3, sp, #16
{
   11f32:	4614      	mov	r4, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   11f34:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
   11f38:	e9cd 2308 	strd	r2, r3, [sp, #32]
{
   11f3c:	4605      	mov	r5, r0
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   11f3e:	f10d 020e 	add.w	r2, sp, #14
{
   11f42:	460e      	mov	r6, r1
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   11f44:	4620      	mov	r0, r4
   11f46:	a903      	add	r1, sp, #12
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   11f48:	9307      	str	r3, [sp, #28]
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   11f4a:	f015 fcbf 	bl	278cc <key_idx_unpack>
	bt_mesh_model_msg_init(&msg, OP_APP_KEY_STATUS);
   11f4e:	f248 0103 	movw	r1, #32771	; 0x8003
   11f52:	a807      	add	r0, sp, #28
   11f54:	f015 fc2c 	bl	277b0 <bt_mesh_model_msg_init>
	status = app_key_set(key_net_idx, key_app_idx, buf->data, true);
   11f58:	2301      	movs	r3, #1
   11f5a:	6822      	ldr	r2, [r4, #0]
   11f5c:	f8bd 100e 	ldrh.w	r1, [sp, #14]
   11f60:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   11f64:	f015 fd70 	bl	27a48 <app_key_set>
   11f68:	4601      	mov	r1, r0
	net_buf_simple_add_u8(&msg, status);
   11f6a:	a807      	add	r0, sp, #28
   11f6c:	f016 ff2f 	bl	28dce <net_buf_simple_add_u8>
	key_idx_pack(&msg, key_net_idx, key_app_idx);
   11f70:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   11f74:	f8bd 100c 	ldrh.w	r1, [sp, #12]
   11f78:	a807      	add	r0, sp, #28
   11f7a:	f015 fc94 	bl	278a6 <key_idx_pack>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   11f7e:	2300      	movs	r3, #0
   11f80:	9300      	str	r3, [sp, #0]
   11f82:	aa07      	add	r2, sp, #28
   11f84:	4631      	mov	r1, r6
   11f86:	4628      	mov	r0, r5
   11f88:	f015 fc3b 	bl	27802 <bt_mesh_model_send>
   11f8c:	b148      	cbz	r0, 11fa2 <app_key_update+0x76>
   11f8e:	4906      	ldr	r1, [pc, #24]	; (11fa8 <app_key_update+0x7c>)
   11f90:	4b06      	ldr	r3, [pc, #24]	; (11fac <app_key_update+0x80>)
		BT_ERR("Unable to send App Key Status response");
   11f92:	4807      	ldr	r0, [pc, #28]	; (11fb0 <app_key_update+0x84>)
   11f94:	1ac9      	subs	r1, r1, r3
   11f96:	08c9      	lsrs	r1, r1, #3
   11f98:	0189      	lsls	r1, r1, #6
   11f9a:	f041 0101 	orr.w	r1, r1, #1
   11f9e:	f012 f811 	bl	23fc4 <log_0>
}
   11fa2:	b00a      	add	sp, #40	; 0x28
   11fa4:	bd70      	pop	{r4, r5, r6, pc}
   11fa6:	bf00      	nop
   11fa8:	00029928 	.word	0x00029928
   11fac:	00029830 	.word	0x00029830
   11fb0:	0002e06e 	.word	0x0002e06e

00011fb4 <app_key_add>:
{
   11fb4:	b570      	push	{r4, r5, r6, lr}
   11fb6:	b08a      	sub	sp, #40	; 0x28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   11fb8:	ab04      	add	r3, sp, #16
{
   11fba:	4614      	mov	r4, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   11fbc:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
   11fc0:	e9cd 2308 	strd	r2, r3, [sp, #32]
{
   11fc4:	4605      	mov	r5, r0
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   11fc6:	f10d 020e 	add.w	r2, sp, #14
{
   11fca:	460e      	mov	r6, r1
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   11fcc:	4620      	mov	r0, r4
   11fce:	a903      	add	r1, sp, #12
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   11fd0:	9307      	str	r3, [sp, #28]
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   11fd2:	f015 fc7b 	bl	278cc <key_idx_unpack>
	bt_mesh_model_msg_init(&msg, OP_APP_KEY_STATUS);
   11fd6:	f248 0103 	movw	r1, #32771	; 0x8003
   11fda:	a807      	add	r0, sp, #28
   11fdc:	f015 fbe8 	bl	277b0 <bt_mesh_model_msg_init>
	status = app_key_set(key_net_idx, key_app_idx, buf->data, false);
   11fe0:	2300      	movs	r3, #0
   11fe2:	6822      	ldr	r2, [r4, #0]
   11fe4:	f8bd 100e 	ldrh.w	r1, [sp, #14]
   11fe8:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   11fec:	f015 fd2c 	bl	27a48 <app_key_set>
   11ff0:	4601      	mov	r1, r0
	net_buf_simple_add_u8(&msg, status);
   11ff2:	a807      	add	r0, sp, #28
   11ff4:	f016 feeb 	bl	28dce <net_buf_simple_add_u8>
	key_idx_pack(&msg, key_net_idx, key_app_idx);
   11ff8:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   11ffc:	f8bd 100c 	ldrh.w	r1, [sp, #12]
   12000:	a807      	add	r0, sp, #28
   12002:	f015 fc50 	bl	278a6 <key_idx_pack>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   12006:	2300      	movs	r3, #0
   12008:	9300      	str	r3, [sp, #0]
   1200a:	aa07      	add	r2, sp, #28
   1200c:	4631      	mov	r1, r6
   1200e:	4628      	mov	r0, r5
   12010:	f015 fbf7 	bl	27802 <bt_mesh_model_send>
   12014:	b148      	cbz	r0, 1202a <app_key_add+0x76>
   12016:	4906      	ldr	r1, [pc, #24]	; (12030 <app_key_add+0x7c>)
   12018:	4b06      	ldr	r3, [pc, #24]	; (12034 <app_key_add+0x80>)
		BT_ERR("Unable to send App Key Status response");
   1201a:	4807      	ldr	r0, [pc, #28]	; (12038 <app_key_add+0x84>)
   1201c:	1ac9      	subs	r1, r1, r3
   1201e:	08c9      	lsrs	r1, r1, #3
   12020:	0189      	lsls	r1, r1, #6
   12022:	f041 0101 	orr.w	r1, r1, #1
   12026:	f011 ffcd 	bl	23fc4 <log_0>
}
   1202a:	b00a      	add	sp, #40	; 0x28
   1202c:	bd70      	pop	{r4, r5, r6, pc}
   1202e:	bf00      	nop
   12030:	00029928 	.word	0x00029928
   12034:	00029830 	.word	0x00029830
   12038:	0002e06e 	.word	0x0002e06e

0001203c <bt_mesh_app_key_del>:
{
   1203c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct unbind_data data = { .app_idx = key->app_idx, .store = store };
   1203e:	8843      	ldrh	r3, [r0, #2]
   12040:	f88d 1006 	strb.w	r1, [sp, #6]
{
   12044:	460d      	mov	r5, r1
   12046:	4604      	mov	r4, r0
	bt_mesh_model_foreach(_mod_unbind, &data);
   12048:	a901      	add	r1, sp, #4
   1204a:	480a      	ldr	r0, [pc, #40]	; (12074 <bt_mesh_app_key_del+0x38>)
	struct unbind_data data = { .app_idx = key->app_idx, .store = store };
   1204c:	f8ad 3004 	strh.w	r3, [sp, #4]
	bt_mesh_model_foreach(_mod_unbind, &data);
   12050:	f7fd fc16 	bl	f880 <bt_mesh_model_foreach>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
   12054:	b115      	cbz	r5, 1205c <bt_mesh_app_key_del+0x20>
		bt_mesh_clear_app_key(key);
   12056:	4620      	mov	r0, r4
   12058:	f015 fe47 	bl	27cea <bt_mesh_clear_app_key>
	key->net_idx = BT_MESH_KEY_UNUSED;
   1205c:	4620      	mov	r0, r4
   1205e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   12062:	f820 3b05 	strh.w	r3, [r0], #5
	(void)memset(key->keys, 0, sizeof(key->keys));
   12066:	2222      	movs	r2, #34	; 0x22
   12068:	2100      	movs	r1, #0
   1206a:	f013 fe48 	bl	25cfe <memset>
}
   1206e:	b003      	add	sp, #12
   12070:	bd30      	pop	{r4, r5, pc}
   12072:	bf00      	nop
   12074:	00027a25 	.word	0x00027a25

00012078 <app_key_del>:
{
   12078:	b570      	push	{r4, r5, r6, lr}
   1207a:	b08a      	sub	sp, #40	; 0x28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   1207c:	ab04      	add	r3, sp, #16
{
   1207e:	4605      	mov	r5, r0
   12080:	4610      	mov	r0, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   12082:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
   12086:	e9cd 2308 	strd	r2, r3, [sp, #32]
{
   1208a:	460e      	mov	r6, r1
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   1208c:	f10d 020e 	add.w	r2, sp, #14
   12090:	a903      	add	r1, sp, #12
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   12092:	9307      	str	r3, [sp, #28]
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   12094:	f015 fc1a 	bl	278cc <key_idx_unpack>
	if (!bt_mesh_subnet_get(key_net_idx)) {
   12098:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   1209c:	f7fa fca6 	bl	c9ec <bt_mesh_subnet_get>
   120a0:	b390      	cbz	r0, 12108 <app_key_del+0x90>
	key = bt_mesh_app_key_find(key_app_idx);
   120a2:	f8bd 000e 	ldrh.w	r0, [sp, #14]
   120a6:	f7fc fba5 	bl	e7f4 <bt_mesh_app_key_find>
   120aa:	4604      	mov	r4, r0
	if (!key) {
   120ac:	b140      	cbz	r0, 120c0 <app_key_del+0x48>
	if (key->net_idx != key_net_idx) {
   120ae:	8802      	ldrh	r2, [r0, #0]
   120b0:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   120b4:	429a      	cmp	r2, r3
   120b6:	d129      	bne.n	1210c <app_key_del+0x94>
	bt_mesh_app_key_del(key, true);
   120b8:	2101      	movs	r1, #1
   120ba:	f7ff ffbf 	bl	1203c <bt_mesh_app_key_del>
	status = STATUS_SUCCESS;
   120be:	2400      	movs	r4, #0
	bt_mesh_model_msg_init(&msg, OP_APP_KEY_STATUS);
   120c0:	f248 0103 	movw	r1, #32771	; 0x8003
   120c4:	a807      	add	r0, sp, #28
   120c6:	f015 fb73 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   120ca:	4621      	mov	r1, r4
   120cc:	a807      	add	r0, sp, #28
   120ce:	f016 fe7e 	bl	28dce <net_buf_simple_add_u8>
	key_idx_pack(&msg, key_net_idx, key_app_idx);
   120d2:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   120d6:	f8bd 100c 	ldrh.w	r1, [sp, #12]
   120da:	a807      	add	r0, sp, #28
   120dc:	f015 fbe3 	bl	278a6 <key_idx_pack>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   120e0:	2300      	movs	r3, #0
   120e2:	9300      	str	r3, [sp, #0]
   120e4:	aa07      	add	r2, sp, #28
   120e6:	4631      	mov	r1, r6
   120e8:	4628      	mov	r0, r5
   120ea:	f015 fb8a 	bl	27802 <bt_mesh_model_send>
   120ee:	b148      	cbz	r0, 12104 <app_key_del+0x8c>
   120f0:	4907      	ldr	r1, [pc, #28]	; (12110 <app_key_del+0x98>)
   120f2:	4b08      	ldr	r3, [pc, #32]	; (12114 <app_key_del+0x9c>)
		BT_ERR("Unable to send App Key Status response");
   120f4:	4808      	ldr	r0, [pc, #32]	; (12118 <app_key_del+0xa0>)
   120f6:	1ac9      	subs	r1, r1, r3
   120f8:	08c9      	lsrs	r1, r1, #3
   120fa:	0189      	lsls	r1, r1, #6
   120fc:	f041 0101 	orr.w	r1, r1, #1
   12100:	f011 ff60 	bl	23fc4 <log_0>
}
   12104:	b00a      	add	sp, #40	; 0x28
   12106:	bd70      	pop	{r4, r5, r6, pc}
		status = STATUS_INVALID_NETKEY;
   12108:	2404      	movs	r4, #4
   1210a:	e7d9      	b.n	120c0 <app_key_del+0x48>
		status = STATUS_INVALID_BINDING;
   1210c:	2411      	movs	r4, #17
   1210e:	e7d7      	b.n	120c0 <app_key_del+0x48>
   12110:	00029928 	.word	0x00029928
   12114:	00029830 	.word	0x00029830
   12118:	0002e06e 	.word	0x0002e06e

0001211c <get_label>:
	if (index >= ARRAY_SIZE(labels)) {
   1211c:	2800      	cmp	r0, #0
}
   1211e:	4802      	ldr	r0, [pc, #8]	; (12128 <get_label+0xc>)
   12120:	bf18      	it	ne
   12122:	2000      	movne	r0, #0
   12124:	4770      	bx	lr
   12126:	bf00      	nop
   12128:	2000090c 	.word	0x2000090c

0001212c <bt_mesh_heartbeat>:

	(void)memset(labels, 0, sizeof(labels));
}

void bt_mesh_heartbeat(u16_t src, u16_t dst, u8_t hops, u16_t feat)
{
   1212c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12130:	4698      	mov	r8, r3
	struct bt_mesh_cfg_srv *cfg = conf;
   12132:	4b2e      	ldr	r3, [pc, #184]	; (121ec <bt_mesh_heartbeat+0xc0>)
   12134:	681c      	ldr	r4, [r3, #0]
{
   12136:	4615      	mov	r5, r2

	if (!cfg) {
   12138:	b95c      	cbnz	r4, 12152 <bt_mesh_heartbeat+0x26>
   1213a:	492d      	ldr	r1, [pc, #180]	; (121f0 <bt_mesh_heartbeat+0xc4>)
   1213c:	4b2d      	ldr	r3, [pc, #180]	; (121f4 <bt_mesh_heartbeat+0xc8>)
		BT_WARN("No configuaration server context available");
   1213e:	482e      	ldr	r0, [pc, #184]	; (121f8 <bt_mesh_heartbeat+0xcc>)
   12140:	1ac9      	subs	r1, r1, r3
   12142:	08c9      	lsrs	r1, r1, #3
   12144:	0189      	lsls	r1, r1, #6
   12146:	f041 0102 	orr.w	r1, r1, #2
	       cfg->hb_sub.count);

	if (cfg->hb_sub.func) {
		cfg->hb_sub.func(hops, feat);
	}
}
   1214a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		BT_WARN("No subscription for received heartbeat");
   1214e:	f011 bf39 	b.w	23fc4 <log_0>
	if (src != cfg->hb_sub.src || dst != cfg->hb_sub.dst) {
   12152:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
   12156:	4283      	cmp	r3, r0
   12158:	d103      	bne.n	12162 <bt_mesh_heartbeat+0x36>
   1215a:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
   1215e:	428b      	cmp	r3, r1
   12160:	d008      	beq.n	12174 <bt_mesh_heartbeat+0x48>
   12162:	4923      	ldr	r1, [pc, #140]	; (121f0 <bt_mesh_heartbeat+0xc4>)
   12164:	4b23      	ldr	r3, [pc, #140]	; (121f4 <bt_mesh_heartbeat+0xc8>)
		BT_WARN("No subscription for received heartbeat");
   12166:	4825      	ldr	r0, [pc, #148]	; (121fc <bt_mesh_heartbeat+0xd0>)
   12168:	1ac9      	subs	r1, r1, r3
   1216a:	08c9      	lsrs	r1, r1, #3
   1216c:	0189      	lsls	r1, r1, #6
   1216e:	f041 0102 	orr.w	r1, r1, #2
   12172:	e7ea      	b.n	1214a <bt_mesh_heartbeat+0x1e>
   12174:	f017 f94d 	bl	29412 <z_impl_k_uptime_ticks>
   12178:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1217c:	460a      	mov	r2, r1
   1217e:	fba0 0103 	umull	r0, r1, r0, r3
   12182:	fb03 1102 	mla	r1, r3, r2, r1
	if (k_uptime_get() > cfg->hb_sub.expiry) {
   12186:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
   1218a:	0bc6      	lsrs	r6, r0, #15
   1218c:	ea46 4641 	orr.w	r6, r6, r1, lsl #17
   12190:	0bcf      	lsrs	r7, r1, #15
   12192:	42b2      	cmp	r2, r6
   12194:	41bb      	sbcs	r3, r7
   12196:	da08      	bge.n	121aa <bt_mesh_heartbeat+0x7e>
   12198:	4915      	ldr	r1, [pc, #84]	; (121f0 <bt_mesh_heartbeat+0xc4>)
   1219a:	4b16      	ldr	r3, [pc, #88]	; (121f4 <bt_mesh_heartbeat+0xc8>)
		BT_WARN("Heartbeat subscription period expired");
   1219c:	4818      	ldr	r0, [pc, #96]	; (12200 <bt_mesh_heartbeat+0xd4>)
   1219e:	1ac9      	subs	r1, r1, r3
   121a0:	08c9      	lsrs	r1, r1, #3
   121a2:	0189      	lsls	r1, r1, #6
   121a4:	f041 0102 	orr.w	r1, r1, #2
   121a8:	e7cf      	b.n	1214a <bt_mesh_heartbeat+0x1e>
	cfg->hb_sub.min_hops = MIN(cfg->hb_sub.min_hops, hops);
   121aa:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
	if (cfg->hb_sub.count < 0xffff) {
   121ae:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
	cfg->hb_sub.min_hops = MIN(cfg->hb_sub.min_hops, hops);
   121b2:	42ab      	cmp	r3, r5
   121b4:	bf28      	it	cs
   121b6:	462b      	movcs	r3, r5
   121b8:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
	cfg->hb_sub.max_hops = MAX(cfg->hb_sub.max_hops, hops);
   121bc:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
   121c0:	42ab      	cmp	r3, r5
   121c2:	bf38      	it	cc
   121c4:	462b      	movcc	r3, r5
   121c6:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
	if (cfg->hb_sub.count < 0xffff) {
   121ca:	f64f 73ff 	movw	r3, #65535	; 0xffff
   121ce:	429a      	cmp	r2, r3
	if (cfg->hb_sub.func) {
   121d0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
		cfg->hb_sub.count++;
   121d2:	bf1c      	itt	ne
   121d4:	3201      	addne	r2, #1
   121d6:	f8a4 2044 	strhne.w	r2, [r4, #68]	; 0x44
	if (cfg->hb_sub.func) {
   121da:	b123      	cbz	r3, 121e6 <bt_mesh_heartbeat+0xba>
		cfg->hb_sub.func(hops, feat);
   121dc:	4641      	mov	r1, r8
   121de:	4628      	mov	r0, r5
}
   121e0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cfg->hb_sub.func(hops, feat);
   121e4:	4718      	bx	r3
}
   121e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   121ea:	bf00      	nop
   121ec:	20000908 	.word	0x20000908
   121f0:	00029928 	.word	0x00029928
   121f4:	00029830 	.word	0x00029830
   121f8:	0002e095 	.word	0x0002e095
   121fc:	0002e0c0 	.word	0x0002e0c0
   12200:	0002e0e7 	.word	0x0002e0e7

00012204 <bt_mesh_net_transmit_get>:

u8_t bt_mesh_net_transmit_get(void)
{
	if (conf) {
   12204:	4b02      	ldr	r3, [pc, #8]	; (12210 <bt_mesh_net_transmit_get+0xc>)
   12206:	6818      	ldr	r0, [r3, #0]
   12208:	b100      	cbz	r0, 1220c <bt_mesh_net_transmit_get+0x8>
		return conf->net_transmit;
   1220a:	7900      	ldrb	r0, [r0, #4]
	}

	return 0;
}
   1220c:	4770      	bx	lr
   1220e:	bf00      	nop
   12210:	20000908 	.word	0x20000908

00012214 <net_transmit_set>:
{
   12214:	b530      	push	{r4, r5, lr}
   12216:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_TRANSMIT_STATUS, 1);
   12218:	ab03      	add	r3, sp, #12
{
   1221a:	460d      	mov	r5, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_TRANSMIT_STATUS, 1);
   1221c:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   12220:	e9cd 1306 	strd	r1, r3, [sp, #24]
   12224:	9305      	str	r3, [sp, #20]
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   12226:	69c3      	ldr	r3, [r0, #28]
{
   12228:	4604      	mov	r4, r0
	if (!cfg) {
   1222a:	bb43      	cbnz	r3, 1227e <net_transmit_set+0x6a>
   1222c:	4917      	ldr	r1, [pc, #92]	; (1228c <net_transmit_set+0x78>)
   1222e:	4b18      	ldr	r3, [pc, #96]	; (12290 <net_transmit_set+0x7c>)
		BT_WARN("No Configuration Server context available");
   12230:	4818      	ldr	r0, [pc, #96]	; (12294 <net_transmit_set+0x80>)
   12232:	1a5b      	subs	r3, r3, r1
   12234:	08db      	lsrs	r3, r3, #3
   12236:	019b      	lsls	r3, r3, #6
   12238:	f043 0102 	orr.w	r1, r3, #2
   1223c:	f011 fec2 	bl	23fc4 <log_0>
	bt_mesh_model_msg_init(&msg, OP_NET_TRANSMIT_STATUS);
   12240:	f248 0125 	movw	r1, #32805	; 0x8025
   12244:	a805      	add	r0, sp, #20
   12246:	f015 fab3 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_net_transmit_get());
   1224a:	f7ff ffdb 	bl	12204 <bt_mesh_net_transmit_get>
   1224e:	4601      	mov	r1, r0
   12250:	a805      	add	r0, sp, #20
   12252:	f016 fdbc 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   12256:	2300      	movs	r3, #0
   12258:	9300      	str	r3, [sp, #0]
   1225a:	aa05      	add	r2, sp, #20
   1225c:	4629      	mov	r1, r5
   1225e:	4620      	mov	r0, r4
   12260:	f015 facf 	bl	27802 <bt_mesh_model_send>
   12264:	b148      	cbz	r0, 1227a <net_transmit_set+0x66>
   12266:	490a      	ldr	r1, [pc, #40]	; (12290 <net_transmit_set+0x7c>)
   12268:	4b08      	ldr	r3, [pc, #32]	; (1228c <net_transmit_set+0x78>)
		BT_ERR("Unable to send Network Transmit Status");
   1226a:	480b      	ldr	r0, [pc, #44]	; (12298 <net_transmit_set+0x84>)
   1226c:	1ac9      	subs	r1, r1, r3
   1226e:	08c9      	lsrs	r1, r1, #3
   12270:	0189      	lsls	r1, r1, #6
   12272:	f041 0101 	orr.w	r1, r1, #1
   12276:	f011 fea5 	bl	23fc4 <log_0>
}
   1227a:	b009      	add	sp, #36	; 0x24
   1227c:	bd30      	pop	{r4, r5, pc}
		cfg->net_transmit = buf->data[0];
   1227e:	6812      	ldr	r2, [r2, #0]
   12280:	7812      	ldrb	r2, [r2, #0]
   12282:	711a      	strb	r2, [r3, #4]
			bt_mesh_store_cfg();
   12284:	f015 fd01 	bl	27c8a <bt_mesh_store_cfg>
   12288:	e7da      	b.n	12240 <net_transmit_set+0x2c>
   1228a:	bf00      	nop
   1228c:	00029830 	.word	0x00029830
   12290:	00029928 	.word	0x00029928
   12294:	0002ddd7 	.word	0x0002ddd7
   12298:	0002e10d 	.word	0x0002e10d

0001229c <net_transmit_get>:
{
   1229c:	b530      	push	{r4, r5, lr}
   1229e:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_TRANSMIT_STATUS, 1);
   122a0:	ab03      	add	r3, sp, #12
   122a2:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   122a6:	4604      	mov	r4, r0
   122a8:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_NET_TRANSMIT_STATUS);
   122aa:	a805      	add	r0, sp, #20
   122ac:	f248 0125 	movw	r1, #32805	; 0x8025
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_TRANSMIT_STATUS, 1);
   122b0:	e9cd 2306 	strd	r2, r3, [sp, #24]
   122b4:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_NET_TRANSMIT_STATUS);
   122b6:	f015 fa7b 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_net_transmit_get());
   122ba:	f7ff ffa3 	bl	12204 <bt_mesh_net_transmit_get>
   122be:	4601      	mov	r1, r0
   122c0:	a805      	add	r0, sp, #20
   122c2:	f016 fd84 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   122c6:	2300      	movs	r3, #0
   122c8:	9300      	str	r3, [sp, #0]
   122ca:	aa05      	add	r2, sp, #20
   122cc:	4629      	mov	r1, r5
   122ce:	4620      	mov	r0, r4
   122d0:	f015 fa97 	bl	27802 <bt_mesh_model_send>
   122d4:	b148      	cbz	r0, 122ea <net_transmit_get+0x4e>
   122d6:	4906      	ldr	r1, [pc, #24]	; (122f0 <net_transmit_get+0x54>)
   122d8:	4b06      	ldr	r3, [pc, #24]	; (122f4 <net_transmit_get+0x58>)
		BT_ERR("Unable to send Config Network Transmit Status");
   122da:	4807      	ldr	r0, [pc, #28]	; (122f8 <net_transmit_get+0x5c>)
   122dc:	1ac9      	subs	r1, r1, r3
   122de:	08c9      	lsrs	r1, r1, #3
   122e0:	0189      	lsls	r1, r1, #6
   122e2:	f041 0101 	orr.w	r1, r1, #1
   122e6:	f011 fe6d 	bl	23fc4 <log_0>
}
   122ea:	b009      	add	sp, #36	; 0x24
   122ec:	bd30      	pop	{r4, r5, pc}
   122ee:	bf00      	nop
   122f0:	00029928 	.word	0x00029928
   122f4:	00029830 	.word	0x00029830
   122f8:	0002e134 	.word	0x0002e134

000122fc <bt_mesh_relay_get>:

u8_t bt_mesh_relay_get(void)
{
	if (conf) {
   122fc:	4b03      	ldr	r3, [pc, #12]	; (1230c <bt_mesh_relay_get+0x10>)
   122fe:	681b      	ldr	r3, [r3, #0]
   12300:	b10b      	cbz	r3, 12306 <bt_mesh_relay_get+0xa>
		return conf->relay;
   12302:	7958      	ldrb	r0, [r3, #5]
   12304:	4770      	bx	lr
	}

	return BT_MESH_RELAY_NOT_SUPPORTED;
   12306:	2002      	movs	r0, #2
}
   12308:	4770      	bx	lr
   1230a:	bf00      	nop
   1230c:	20000908 	.word	0x20000908

00012310 <bt_mesh_friend_get>:
u8_t bt_mesh_friend_get(void)
{
	BT_DBG("conf %p conf->frnd 0x%02x", conf,
	       conf ? conf->frnd : BT_MESH_FRIEND_NOT_SUPPORTED);

	if (conf) {
   12310:	4b03      	ldr	r3, [pc, #12]	; (12320 <bt_mesh_friend_get+0x10>)
   12312:	681b      	ldr	r3, [r3, #0]
   12314:	b10b      	cbz	r3, 1231a <bt_mesh_friend_get+0xa>
		return conf->frnd;
   12316:	7a58      	ldrb	r0, [r3, #9]
   12318:	4770      	bx	lr
	}

	return BT_MESH_FRIEND_NOT_SUPPORTED;
   1231a:	2002      	movs	r0, #2
}
   1231c:	4770      	bx	lr
   1231e:	bf00      	nop
   12320:	20000908 	.word	0x20000908

00012324 <bt_mesh_relay_retransmit_get>:

u8_t bt_mesh_relay_retransmit_get(void)
{
	if (conf) {
   12324:	4b02      	ldr	r3, [pc, #8]	; (12330 <bt_mesh_relay_retransmit_get+0xc>)
   12326:	6818      	ldr	r0, [r3, #0]
   12328:	b100      	cbz	r0, 1232c <bt_mesh_relay_retransmit_get+0x8>
		return conf->relay_retransmit;
   1232a:	7980      	ldrb	r0, [r0, #6]
	}

	return 0;
}
   1232c:	4770      	bx	lr
   1232e:	bf00      	nop
   12330:	20000908 	.word	0x20000908

00012334 <relay_set>:
{
   12334:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   12336:	69c7      	ldr	r7, [r0, #28]
{
   12338:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   1233a:	ab03      	add	r3, sp, #12
{
   1233c:	460e      	mov	r6, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   1233e:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   12342:	e9cd 1306 	strd	r1, r3, [sp, #24]
{
   12346:	4605      	mov	r5, r0
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   12348:	9305      	str	r3, [sp, #20]
	if (!cfg) {
   1234a:	bb6f      	cbnz	r7, 123a8 <relay_set+0x74>
   1234c:	4929      	ldr	r1, [pc, #164]	; (123f4 <relay_set+0xc0>)
   1234e:	4b2a      	ldr	r3, [pc, #168]	; (123f8 <relay_set+0xc4>)
		BT_WARN("No Configuration Server context available");
   12350:	482a      	ldr	r0, [pc, #168]	; (123fc <relay_set+0xc8>)
   12352:	1a5b      	subs	r3, r3, r1
   12354:	08db      	lsrs	r3, r3, #3
   12356:	019b      	lsls	r3, r3, #6
   12358:	f043 0102 	orr.w	r1, r3, #2
   1235c:	f011 fe32 	bl	23fc4 <log_0>
	bt_mesh_model_msg_init(&msg, OP_RELAY_STATUS);
   12360:	f248 0128 	movw	r1, #32808	; 0x8028
   12364:	a805      	add	r0, sp, #20
   12366:	f015 fa23 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_relay_get());
   1236a:	f7ff ffc7 	bl	122fc <bt_mesh_relay_get>
   1236e:	4601      	mov	r1, r0
   12370:	a805      	add	r0, sp, #20
   12372:	f016 fd2c 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, bt_mesh_relay_retransmit_get());
   12376:	f7ff ffd5 	bl	12324 <bt_mesh_relay_retransmit_get>
   1237a:	4601      	mov	r1, r0
   1237c:	a805      	add	r0, sp, #20
   1237e:	f016 fd26 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   12382:	2300      	movs	r3, #0
   12384:	9300      	str	r3, [sp, #0]
   12386:	aa05      	add	r2, sp, #20
   12388:	4631      	mov	r1, r6
   1238a:	4628      	mov	r0, r5
   1238c:	f015 fa39 	bl	27802 <bt_mesh_model_send>
   12390:	b368      	cbz	r0, 123ee <relay_set+0xba>
   12392:	4b18      	ldr	r3, [pc, #96]	; (123f4 <relay_set+0xc0>)
   12394:	4918      	ldr	r1, [pc, #96]	; (123f8 <relay_set+0xc4>)
		BT_ERR("Unable to send Relay Status response");
   12396:	481a      	ldr	r0, [pc, #104]	; (12400 <relay_set+0xcc>)
   12398:	1ac9      	subs	r1, r1, r3
   1239a:	08c9      	lsrs	r1, r1, #3
   1239c:	0189      	lsls	r1, r1, #6
   1239e:	f041 0101 	orr.w	r1, r1, #1
   123a2:	f011 fe0f 	bl	23fc4 <log_0>
   123a6:	e022      	b.n	123ee <relay_set+0xba>
	} else if (buf->data[0] == 0x00 || buf->data[0] == 0x01) {
   123a8:	6813      	ldr	r3, [r2, #0]
   123aa:	7819      	ldrb	r1, [r3, #0]
   123ac:	2901      	cmp	r1, #1
   123ae:	d814      	bhi.n	123da <relay_set+0xa6>
		if (cfg->relay == BT_MESH_RELAY_NOT_SUPPORTED) {
   123b0:	797c      	ldrb	r4, [r7, #5]
   123b2:	2c02      	cmp	r4, #2
   123b4:	d00f      	beq.n	123d6 <relay_set+0xa2>
			cfg->relay = buf->data[0];
   123b6:	7179      	strb	r1, [r7, #5]
			cfg->relay_retransmit = buf->data[1];
   123b8:	785b      	ldrb	r3, [r3, #1]
   123ba:	71bb      	strb	r3, [r7, #6]
			change = (cfg->relay != buf->data[0]);
   123bc:	1b0c      	subs	r4, r1, r4
   123be:	bf18      	it	ne
   123c0:	2401      	movne	r4, #1
				bt_mesh_store_cfg();
   123c2:	f015 fc62 	bl	27c8a <bt_mesh_store_cfg>
		if ((cfg->hb_pub.feat & BT_MESH_FEAT_RELAY) && change) {
   123c6:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
   123c8:	07db      	lsls	r3, r3, #31
   123ca:	d5c9      	bpl.n	12360 <relay_set+0x2c>
   123cc:	2c00      	cmp	r4, #0
   123ce:	d0c7      	beq.n	12360 <relay_set+0x2c>
			bt_mesh_heartbeat_send();
   123d0:	f014 ff88 	bl	272e4 <bt_mesh_heartbeat_send>
   123d4:	e7c4      	b.n	12360 <relay_set+0x2c>
			change = false;
   123d6:	2400      	movs	r4, #0
   123d8:	e7f5      	b.n	123c6 <relay_set+0x92>
   123da:	4a07      	ldr	r2, [pc, #28]	; (123f8 <relay_set+0xc4>)
   123dc:	4b05      	ldr	r3, [pc, #20]	; (123f4 <relay_set+0xc0>)
		BT_WARN("Invalid Relay value 0x%02x", buf->data[0]);
   123de:	4809      	ldr	r0, [pc, #36]	; (12404 <relay_set+0xd0>)
   123e0:	1ad2      	subs	r2, r2, r3
   123e2:	08d2      	lsrs	r2, r2, #3
   123e4:	0192      	lsls	r2, r2, #6
   123e6:	f042 0202 	orr.w	r2, r2, #2
   123ea:	f011 fdf8 	bl	23fde <log_1>
}
   123ee:	b009      	add	sp, #36	; 0x24
   123f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   123f2:	bf00      	nop
   123f4:	00029830 	.word	0x00029830
   123f8:	00029928 	.word	0x00029928
   123fc:	0002ddd7 	.word	0x0002ddd7
   12400:	0002e17d 	.word	0x0002e17d
   12404:	0002e162 	.word	0x0002e162

00012408 <relay_get>:
{
   12408:	b530      	push	{r4, r5, lr}
   1240a:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   1240c:	ab03      	add	r3, sp, #12
   1240e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
{
   12412:	4604      	mov	r4, r0
   12414:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_RELAY_STATUS);
   12416:	a805      	add	r0, sp, #20
   12418:	f248 0128 	movw	r1, #32808	; 0x8028
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   1241c:	e9cd 2306 	strd	r2, r3, [sp, #24]
   12420:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_RELAY_STATUS);
   12422:	f015 f9c5 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_relay_get());
   12426:	f7ff ff69 	bl	122fc <bt_mesh_relay_get>
   1242a:	4601      	mov	r1, r0
   1242c:	a805      	add	r0, sp, #20
   1242e:	f016 fcce 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, bt_mesh_relay_retransmit_get());
   12432:	f7ff ff77 	bl	12324 <bt_mesh_relay_retransmit_get>
   12436:	4601      	mov	r1, r0
   12438:	a805      	add	r0, sp, #20
   1243a:	f016 fcc8 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   1243e:	2300      	movs	r3, #0
   12440:	9300      	str	r3, [sp, #0]
   12442:	aa05      	add	r2, sp, #20
   12444:	4629      	mov	r1, r5
   12446:	4620      	mov	r0, r4
   12448:	f015 f9db 	bl	27802 <bt_mesh_model_send>
   1244c:	b148      	cbz	r0, 12462 <relay_get+0x5a>
   1244e:	4906      	ldr	r1, [pc, #24]	; (12468 <relay_get+0x60>)
   12450:	4b06      	ldr	r3, [pc, #24]	; (1246c <relay_get+0x64>)
		BT_ERR("Unable to send Config Relay Status response");
   12452:	4807      	ldr	r0, [pc, #28]	; (12470 <relay_get+0x68>)
   12454:	1ac9      	subs	r1, r1, r3
   12456:	08c9      	lsrs	r1, r1, #3
   12458:	0189      	lsls	r1, r1, #6
   1245a:	f041 0101 	orr.w	r1, r1, #1
   1245e:	f011 fdb1 	bl	23fc4 <log_0>
}
   12462:	b009      	add	sp, #36	; 0x24
   12464:	bd30      	pop	{r4, r5, pc}
   12466:	bf00      	nop
   12468:	00029928 	.word	0x00029928
   1246c:	00029830 	.word	0x00029830
   12470:	0002e1a2 	.word	0x0002e1a2

00012474 <bt_mesh_beacon_get>:

u8_t bt_mesh_beacon_get(void)
{
	if (conf) {
   12474:	4b02      	ldr	r3, [pc, #8]	; (12480 <bt_mesh_beacon_get+0xc>)
   12476:	6818      	ldr	r0, [r3, #0]
   12478:	b100      	cbz	r0, 1247c <bt_mesh_beacon_get+0x8>
		return conf->beacon;
   1247a:	79c0      	ldrb	r0, [r0, #7]
	}

	return BT_MESH_BEACON_DISABLED;
}
   1247c:	4770      	bx	lr
   1247e:	bf00      	nop
   12480:	20000908 	.word	0x20000908

00012484 <beacon_set>:
{
   12484:	b570      	push	{r4, r5, r6, lr}
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   12486:	69c5      	ldr	r5, [r0, #28]
{
   12488:	b088      	sub	sp, #32
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   1248a:	ab03      	add	r3, sp, #12
{
   1248c:	460e      	mov	r6, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   1248e:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   12492:	e9cd 1306 	strd	r1, r3, [sp, #24]
{
   12496:	4604      	mov	r4, r0
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   12498:	9305      	str	r3, [sp, #20]
	if (!cfg) {
   1249a:	bb3d      	cbnz	r5, 124ec <beacon_set+0x68>
   1249c:	4922      	ldr	r1, [pc, #136]	; (12528 <beacon_set+0xa4>)
   1249e:	4b23      	ldr	r3, [pc, #140]	; (1252c <beacon_set+0xa8>)
		BT_WARN("No Configuration Server context available");
   124a0:	4823      	ldr	r0, [pc, #140]	; (12530 <beacon_set+0xac>)
   124a2:	1a5b      	subs	r3, r3, r1
   124a4:	08db      	lsrs	r3, r3, #3
   124a6:	019b      	lsls	r3, r3, #6
   124a8:	f043 0102 	orr.w	r1, r3, #2
   124ac:	f011 fd8a 	bl	23fc4 <log_0>
	bt_mesh_model_msg_init(&msg, OP_BEACON_STATUS);
   124b0:	f248 010b 	movw	r1, #32779	; 0x800b
   124b4:	a805      	add	r0, sp, #20
   124b6:	f015 f97b 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_beacon_get());
   124ba:	f7ff ffdb 	bl	12474 <bt_mesh_beacon_get>
   124be:	4601      	mov	r1, r0
   124c0:	a805      	add	r0, sp, #20
   124c2:	f016 fc84 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   124c6:	2300      	movs	r3, #0
   124c8:	9300      	str	r3, [sp, #0]
   124ca:	aa05      	add	r2, sp, #20
   124cc:	4631      	mov	r1, r6
   124ce:	4620      	mov	r0, r4
   124d0:	f015 f997 	bl	27802 <bt_mesh_model_send>
   124d4:	b330      	cbz	r0, 12524 <beacon_set+0xa0>
   124d6:	4b14      	ldr	r3, [pc, #80]	; (12528 <beacon_set+0xa4>)
   124d8:	4914      	ldr	r1, [pc, #80]	; (1252c <beacon_set+0xa8>)
		BT_ERR("Unable to send Config Beacon Status response");
   124da:	4816      	ldr	r0, [pc, #88]	; (12534 <beacon_set+0xb0>)
   124dc:	1ac9      	subs	r1, r1, r3
   124de:	08c9      	lsrs	r1, r1, #3
   124e0:	0189      	lsls	r1, r1, #6
   124e2:	f041 0101 	orr.w	r1, r1, #1
   124e6:	f011 fd6d 	bl	23fc4 <log_0>
   124ea:	e01b      	b.n	12524 <beacon_set+0xa0>
	} else if (buf->data[0] == 0x00 || buf->data[0] == 0x01) {
   124ec:	6813      	ldr	r3, [r2, #0]
   124ee:	7819      	ldrb	r1, [r3, #0]
   124f0:	2901      	cmp	r1, #1
   124f2:	d80d      	bhi.n	12510 <beacon_set+0x8c>
		if (buf->data[0] != cfg->beacon) {
   124f4:	79eb      	ldrb	r3, [r5, #7]
   124f6:	428b      	cmp	r3, r1
   124f8:	d0da      	beq.n	124b0 <beacon_set+0x2c>
			cfg->beacon = buf->data[0];
   124fa:	71e9      	strb	r1, [r5, #7]
				bt_mesh_store_cfg();
   124fc:	f015 fbc5 	bl	27c8a <bt_mesh_store_cfg>
			if (cfg->beacon) {
   12500:	79eb      	ldrb	r3, [r5, #7]
   12502:	b113      	cbz	r3, 1250a <beacon_set+0x86>
				bt_mesh_beacon_enable();
   12504:	f7fa f970 	bl	c7e8 <bt_mesh_beacon_enable>
   12508:	e7d2      	b.n	124b0 <beacon_set+0x2c>
				bt_mesh_beacon_disable();
   1250a:	f7fa f993 	bl	c834 <bt_mesh_beacon_disable>
   1250e:	e7cf      	b.n	124b0 <beacon_set+0x2c>
   12510:	4a06      	ldr	r2, [pc, #24]	; (1252c <beacon_set+0xa8>)
   12512:	4b05      	ldr	r3, [pc, #20]	; (12528 <beacon_set+0xa4>)
		BT_WARN("Invalid Config Beacon value 0x%02x", buf->data[0]);
   12514:	4808      	ldr	r0, [pc, #32]	; (12538 <beacon_set+0xb4>)
   12516:	1ad2      	subs	r2, r2, r3
   12518:	08d2      	lsrs	r2, r2, #3
   1251a:	0192      	lsls	r2, r2, #6
   1251c:	f042 0202 	orr.w	r2, r2, #2
   12520:	f011 fd5d 	bl	23fde <log_1>
}
   12524:	b008      	add	sp, #32
   12526:	bd70      	pop	{r4, r5, r6, pc}
   12528:	00029830 	.word	0x00029830
   1252c:	00029928 	.word	0x00029928
   12530:	0002ddd7 	.word	0x0002ddd7
   12534:	0002e1f1 	.word	0x0002e1f1
   12538:	0002e1ce 	.word	0x0002e1ce

0001253c <beacon_get>:
{
   1253c:	b530      	push	{r4, r5, lr}
   1253e:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   12540:	ab03      	add	r3, sp, #12
   12542:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   12546:	4604      	mov	r4, r0
   12548:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_BEACON_STATUS);
   1254a:	a805      	add	r0, sp, #20
   1254c:	f248 010b 	movw	r1, #32779	; 0x800b
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   12550:	e9cd 2306 	strd	r2, r3, [sp, #24]
   12554:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_BEACON_STATUS);
   12556:	f015 f92b 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_beacon_get());
   1255a:	f7ff ff8b 	bl	12474 <bt_mesh_beacon_get>
   1255e:	4601      	mov	r1, r0
   12560:	a805      	add	r0, sp, #20
   12562:	f016 fc34 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   12566:	2300      	movs	r3, #0
   12568:	9300      	str	r3, [sp, #0]
   1256a:	aa05      	add	r2, sp, #20
   1256c:	4629      	mov	r1, r5
   1256e:	4620      	mov	r0, r4
   12570:	f015 f947 	bl	27802 <bt_mesh_model_send>
   12574:	b148      	cbz	r0, 1258a <beacon_get+0x4e>
   12576:	4906      	ldr	r1, [pc, #24]	; (12590 <beacon_get+0x54>)
   12578:	4b06      	ldr	r3, [pc, #24]	; (12594 <beacon_get+0x58>)
		BT_ERR("Unable to send Config Beacon Status response");
   1257a:	4807      	ldr	r0, [pc, #28]	; (12598 <beacon_get+0x5c>)
   1257c:	1ac9      	subs	r1, r1, r3
   1257e:	08c9      	lsrs	r1, r1, #3
   12580:	0189      	lsls	r1, r1, #6
   12582:	f041 0101 	orr.w	r1, r1, #1
   12586:	f011 fd1d 	bl	23fc4 <log_0>
}
   1258a:	b009      	add	sp, #36	; 0x24
   1258c:	bd30      	pop	{r4, r5, pc}
   1258e:	bf00      	nop
   12590:	00029928 	.word	0x00029928
   12594:	00029830 	.word	0x00029830
   12598:	0002e1f1 	.word	0x0002e1f1

0001259c <bt_mesh_gatt_proxy_get>:

u8_t bt_mesh_gatt_proxy_get(void)
{
	if (conf) {
   1259c:	4b03      	ldr	r3, [pc, #12]	; (125ac <bt_mesh_gatt_proxy_get+0x10>)
   1259e:	681b      	ldr	r3, [r3, #0]
   125a0:	b10b      	cbz	r3, 125a6 <bt_mesh_gatt_proxy_get+0xa>
		return conf->gatt_proxy;
   125a2:	7a18      	ldrb	r0, [r3, #8]
   125a4:	4770      	bx	lr
	}

	return BT_MESH_GATT_PROXY_NOT_SUPPORTED;
   125a6:	2002      	movs	r0, #2
}
   125a8:	4770      	bx	lr
   125aa:	bf00      	nop
   125ac:	20000908 	.word	0x20000908

000125b0 <send_gatt_proxy_status>:
{
   125b0:	b530      	push	{r4, r5, lr}
   125b2:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_GATT_PROXY_STATUS, 1);
   125b4:	ab03      	add	r3, sp, #12
   125b6:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   125ba:	4604      	mov	r4, r0
   125bc:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_GATT_PROXY_STATUS);
   125be:	a805      	add	r0, sp, #20
   125c0:	f248 0114 	movw	r1, #32788	; 0x8014
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_GATT_PROXY_STATUS, 1);
   125c4:	e9cd 2306 	strd	r2, r3, [sp, #24]
   125c8:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_GATT_PROXY_STATUS);
   125ca:	f015 f8f1 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_gatt_proxy_get());
   125ce:	f7ff ffe5 	bl	1259c <bt_mesh_gatt_proxy_get>
   125d2:	4601      	mov	r1, r0
   125d4:	a805      	add	r0, sp, #20
   125d6:	f016 fbfa 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   125da:	2300      	movs	r3, #0
   125dc:	9300      	str	r3, [sp, #0]
   125de:	aa05      	add	r2, sp, #20
   125e0:	4629      	mov	r1, r5
   125e2:	4620      	mov	r0, r4
   125e4:	f015 f90d 	bl	27802 <bt_mesh_model_send>
   125e8:	b148      	cbz	r0, 125fe <send_gatt_proxy_status+0x4e>
   125ea:	4906      	ldr	r1, [pc, #24]	; (12604 <send_gatt_proxy_status+0x54>)
   125ec:	4b06      	ldr	r3, [pc, #24]	; (12608 <send_gatt_proxy_status+0x58>)
		BT_ERR("Unable to send GATT Proxy Status");
   125ee:	4807      	ldr	r0, [pc, #28]	; (1260c <send_gatt_proxy_status+0x5c>)
   125f0:	1ac9      	subs	r1, r1, r3
   125f2:	08c9      	lsrs	r1, r1, #3
   125f4:	0189      	lsls	r1, r1, #6
   125f6:	f041 0101 	orr.w	r1, r1, #1
   125fa:	f011 fce3 	bl	23fc4 <log_0>
}
   125fe:	b009      	add	sp, #36	; 0x24
   12600:	bd30      	pop	{r4, r5, pc}
   12602:	bf00      	nop
   12604:	00029928 	.word	0x00029928
   12608:	00029830 	.word	0x00029830
   1260c:	0002e21e 	.word	0x0002e21e

00012610 <gatt_proxy_set>:
{
   12610:	b570      	push	{r4, r5, r6, lr}
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   12612:	6813      	ldr	r3, [r2, #0]
{
   12614:	460e      	mov	r6, r1
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   12616:	7819      	ldrb	r1, [r3, #0]
   12618:	2901      	cmp	r1, #1
{
   1261a:	4604      	mov	r4, r0
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   1261c:	d90b      	bls.n	12636 <gatt_proxy_set+0x26>
   1261e:	4a17      	ldr	r2, [pc, #92]	; (1267c <gatt_proxy_set+0x6c>)
   12620:	4b17      	ldr	r3, [pc, #92]	; (12680 <gatt_proxy_set+0x70>)
		BT_WARN("Invalid GATT Proxy value 0x%02x", buf->data[0]);
   12622:	4818      	ldr	r0, [pc, #96]	; (12684 <gatt_proxy_set+0x74>)
   12624:	1ad2      	subs	r2, r2, r3
   12626:	08d2      	lsrs	r2, r2, #3
   12628:	0192      	lsls	r2, r2, #6
}
   1262a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("Invalid GATT Proxy value 0x%02x", buf->data[0]);
   1262e:	f042 0202 	orr.w	r2, r2, #2
   12632:	f011 bcd4 	b.w	23fde <log_1>
	    bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_NOT_SUPPORTED) {
   12636:	f7ff ffb1 	bl	1259c <bt_mesh_gatt_proxy_get>
	if (!IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) ||
   1263a:	2802      	cmp	r0, #2
   1263c:	d00b      	beq.n	12656 <gatt_proxy_set+0x46>
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   1263e:	69e5      	ldr	r5, [r4, #28]
	if (!cfg) {
   12640:	b97d      	cbnz	r5, 12662 <gatt_proxy_set+0x52>
   12642:	490f      	ldr	r1, [pc, #60]	; (12680 <gatt_proxy_set+0x70>)
   12644:	4b0d      	ldr	r3, [pc, #52]	; (1267c <gatt_proxy_set+0x6c>)
		BT_WARN("No Configuration Server context available");
   12646:	4810      	ldr	r0, [pc, #64]	; (12688 <gatt_proxy_set+0x78>)
   12648:	1a5b      	subs	r3, r3, r1
   1264a:	08db      	lsrs	r3, r3, #3
   1264c:	019b      	lsls	r3, r3, #6
   1264e:	f043 0102 	orr.w	r1, r3, #2
   12652:	f011 fcb7 	bl	23fc4 <log_0>
	send_gatt_proxy_status(model, ctx);
   12656:	4631      	mov	r1, r6
   12658:	4620      	mov	r0, r4
}
   1265a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	send_gatt_proxy_status(model, ctx);
   1265e:	f7ff bfa7 	b.w	125b0 <send_gatt_proxy_status>
	if (cfg->gatt_proxy == buf->data[0]) {
   12662:	7a2b      	ldrb	r3, [r5, #8]
   12664:	428b      	cmp	r3, r1
   12666:	d0f6      	beq.n	12656 <gatt_proxy_set+0x46>
	cfg->gatt_proxy = buf->data[0];
   12668:	7229      	strb	r1, [r5, #8]
		bt_mesh_store_cfg();
   1266a:	f015 fb0e 	bl	27c8a <bt_mesh_store_cfg>
	if (cfg->hb_pub.feat & BT_MESH_FEAT_PROXY) {
   1266e:	8e6b      	ldrh	r3, [r5, #50]	; 0x32
   12670:	079b      	lsls	r3, r3, #30
   12672:	d5f0      	bpl.n	12656 <gatt_proxy_set+0x46>
		bt_mesh_heartbeat_send();
   12674:	f014 fe36 	bl	272e4 <bt_mesh_heartbeat_send>
   12678:	e7ed      	b.n	12656 <gatt_proxy_set+0x46>
   1267a:	bf00      	nop
   1267c:	00029928 	.word	0x00029928
   12680:	00029830 	.word	0x00029830
   12684:	0002e23f 	.word	0x0002e23f
   12688:	0002ddd7 	.word	0x0002ddd7

0001268c <bt_mesh_default_ttl_get>:

u8_t bt_mesh_default_ttl_get(void)
{
	if (conf) {
   1268c:	4b03      	ldr	r3, [pc, #12]	; (1269c <bt_mesh_default_ttl_get+0x10>)
   1268e:	681b      	ldr	r3, [r3, #0]
   12690:	b10b      	cbz	r3, 12696 <bt_mesh_default_ttl_get+0xa>
		return conf->default_ttl;
   12692:	7a98      	ldrb	r0, [r3, #10]
   12694:	4770      	bx	lr
	}

	return DEFAULT_TTL;
   12696:	2007      	movs	r0, #7
}
   12698:	4770      	bx	lr
   1269a:	bf00      	nop
   1269c:	20000908 	.word	0x20000908

000126a0 <default_ttl_set>:
{
   126a0:	b530      	push	{r4, r5, lr}
   126a2:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_DEFAULT_TTL_STATUS, 1);
   126a4:	ab03      	add	r3, sp, #12
{
   126a6:	460d      	mov	r5, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_DEFAULT_TTL_STATUS, 1);
   126a8:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   126ac:	e9cd 1306 	strd	r1, r3, [sp, #24]
   126b0:	9305      	str	r3, [sp, #20]
	struct bt_mesh_cfg_srv *cfg = model->user_data;
   126b2:	69c3      	ldr	r3, [r0, #28]
{
   126b4:	4604      	mov	r4, r0
	if (!cfg) {
   126b6:	bb3b      	cbnz	r3, 12708 <default_ttl_set+0x68>
   126b8:	4921      	ldr	r1, [pc, #132]	; (12740 <default_ttl_set+0xa0>)
   126ba:	4b22      	ldr	r3, [pc, #136]	; (12744 <default_ttl_set+0xa4>)
		BT_WARN("No Configuration Server context available");
   126bc:	4822      	ldr	r0, [pc, #136]	; (12748 <default_ttl_set+0xa8>)
   126be:	1a5b      	subs	r3, r3, r1
   126c0:	08db      	lsrs	r3, r3, #3
   126c2:	019b      	lsls	r3, r3, #6
   126c4:	f043 0102 	orr.w	r1, r3, #2
   126c8:	f011 fc7c 	bl	23fc4 <log_0>
	bt_mesh_model_msg_init(&msg, OP_DEFAULT_TTL_STATUS);
   126cc:	f248 010e 	movw	r1, #32782	; 0x800e
   126d0:	a805      	add	r0, sp, #20
   126d2:	f015 f86d 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_default_ttl_get());
   126d6:	f7ff ffd9 	bl	1268c <bt_mesh_default_ttl_get>
   126da:	4601      	mov	r1, r0
   126dc:	a805      	add	r0, sp, #20
   126de:	f016 fb76 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   126e2:	2300      	movs	r3, #0
   126e4:	9300      	str	r3, [sp, #0]
   126e6:	aa05      	add	r2, sp, #20
   126e8:	4629      	mov	r1, r5
   126ea:	4620      	mov	r0, r4
   126ec:	f015 f889 	bl	27802 <bt_mesh_model_send>
   126f0:	b318      	cbz	r0, 1273a <default_ttl_set+0x9a>
   126f2:	4b13      	ldr	r3, [pc, #76]	; (12740 <default_ttl_set+0xa0>)
   126f4:	4913      	ldr	r1, [pc, #76]	; (12744 <default_ttl_set+0xa4>)
		BT_ERR("Unable to send Default TTL Status response");
   126f6:	4815      	ldr	r0, [pc, #84]	; (1274c <default_ttl_set+0xac>)
   126f8:	1ac9      	subs	r1, r1, r3
   126fa:	08c9      	lsrs	r1, r1, #3
   126fc:	0189      	lsls	r1, r1, #6
   126fe:	f041 0101 	orr.w	r1, r1, #1
   12702:	f011 fc5f 	bl	23fc4 <log_0>
   12706:	e018      	b.n	1273a <default_ttl_set+0x9a>
	} else if (buf->data[0] <= BT_MESH_TTL_MAX && buf->data[0] != 0x01) {
   12708:	6812      	ldr	r2, [r2, #0]
   1270a:	7811      	ldrb	r1, [r2, #0]
   1270c:	f992 2000 	ldrsb.w	r2, [r2]
   12710:	2a00      	cmp	r2, #0
   12712:	db08      	blt.n	12726 <default_ttl_set+0x86>
   12714:	2901      	cmp	r1, #1
   12716:	d006      	beq.n	12726 <default_ttl_set+0x86>
		if (cfg->default_ttl != buf->data[0]) {
   12718:	7a9a      	ldrb	r2, [r3, #10]
   1271a:	428a      	cmp	r2, r1
   1271c:	d0d6      	beq.n	126cc <default_ttl_set+0x2c>
			cfg->default_ttl = buf->data[0];
   1271e:	7299      	strb	r1, [r3, #10]
				bt_mesh_store_cfg();
   12720:	f015 fab3 	bl	27c8a <bt_mesh_store_cfg>
   12724:	e7d2      	b.n	126cc <default_ttl_set+0x2c>
   12726:	4a07      	ldr	r2, [pc, #28]	; (12744 <default_ttl_set+0xa4>)
   12728:	4b05      	ldr	r3, [pc, #20]	; (12740 <default_ttl_set+0xa0>)
		BT_WARN("Prohibited Default TTL value 0x%02x", buf->data[0]);
   1272a:	4809      	ldr	r0, [pc, #36]	; (12750 <default_ttl_set+0xb0>)
   1272c:	1ad2      	subs	r2, r2, r3
   1272e:	08d2      	lsrs	r2, r2, #3
   12730:	0192      	lsls	r2, r2, #6
   12732:	f042 0202 	orr.w	r2, r2, #2
   12736:	f011 fc52 	bl	23fde <log_1>
}
   1273a:	b009      	add	sp, #36	; 0x24
   1273c:	bd30      	pop	{r4, r5, pc}
   1273e:	bf00      	nop
   12740:	00029830 	.word	0x00029830
   12744:	00029928 	.word	0x00029928
   12748:	0002ddd7 	.word	0x0002ddd7
   1274c:	0002e283 	.word	0x0002e283
   12750:	0002e25f 	.word	0x0002e25f

00012754 <default_ttl_get>:
{
   12754:	b530      	push	{r4, r5, lr}
   12756:	b089      	sub	sp, #36	; 0x24
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_DEFAULT_TTL_STATUS, 1);
   12758:	ab03      	add	r3, sp, #12
   1275a:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   1275e:	4604      	mov	r4, r0
   12760:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_DEFAULT_TTL_STATUS);
   12762:	a805      	add	r0, sp, #20
   12764:	f248 010e 	movw	r1, #32782	; 0x800e
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_DEFAULT_TTL_STATUS, 1);
   12768:	e9cd 2306 	strd	r2, r3, [sp, #24]
   1276c:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_DEFAULT_TTL_STATUS);
   1276e:	f015 f81f 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_default_ttl_get());
   12772:	f7ff ff8b 	bl	1268c <bt_mesh_default_ttl_get>
   12776:	4601      	mov	r1, r0
   12778:	a805      	add	r0, sp, #20
   1277a:	f016 fb28 	bl	28dce <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   1277e:	2300      	movs	r3, #0
   12780:	9300      	str	r3, [sp, #0]
   12782:	aa05      	add	r2, sp, #20
   12784:	4629      	mov	r1, r5
   12786:	4620      	mov	r0, r4
   12788:	f015 f83b 	bl	27802 <bt_mesh_model_send>
   1278c:	b148      	cbz	r0, 127a2 <default_ttl_get+0x4e>
   1278e:	4906      	ldr	r1, [pc, #24]	; (127a8 <default_ttl_get+0x54>)
   12790:	4b06      	ldr	r3, [pc, #24]	; (127ac <default_ttl_get+0x58>)
		BT_ERR("Unable to send Default TTL Status response");
   12792:	4807      	ldr	r0, [pc, #28]	; (127b0 <default_ttl_get+0x5c>)
   12794:	1ac9      	subs	r1, r1, r3
   12796:	08c9      	lsrs	r1, r1, #3
   12798:	0189      	lsls	r1, r1, #6
   1279a:	f041 0101 	orr.w	r1, r1, #1
   1279e:	f011 fc11 	bl	23fc4 <log_0>
}
   127a2:	b009      	add	sp, #36	; 0x24
   127a4:	bd30      	pop	{r4, r5, pc}
   127a6:	bf00      	nop
   127a8:	00029928 	.word	0x00029928
   127ac:	00029830 	.word	0x00029830
   127b0:	0002e283 	.word	0x0002e283

000127b4 <bt_mesh_label_uuid_get>:

u8_t *bt_mesh_label_uuid_get(u16_t addr)
{
   127b4:	4601      	mov	r1, r0
	int i;

	BT_DBG("addr 0x%04x", addr);

	for (i = 0; i < ARRAY_SIZE(labels); i++) {
		if (labels[i].addr == addr) {
   127b6:	4809      	ldr	r0, [pc, #36]	; (127dc <bt_mesh_label_uuid_get+0x28>)
   127b8:	8842      	ldrh	r2, [r0, #2]
   127ba:	428a      	cmp	r2, r1
{
   127bc:	b508      	push	{r3, lr}
		if (labels[i].addr == addr) {
   127be:	d00b      	beq.n	127d8 <bt_mesh_label_uuid_get+0x24>
   127c0:	4b07      	ldr	r3, [pc, #28]	; (127e0 <bt_mesh_label_uuid_get+0x2c>)
   127c2:	4a08      	ldr	r2, [pc, #32]	; (127e4 <bt_mesh_label_uuid_get+0x30>)
			       bt_hex(labels[i].uuid, 16));
			return labels[i].uuid;
		}
	}

	BT_WARN("No matching Label UUID for 0x%04x", addr);
   127c4:	4808      	ldr	r0, [pc, #32]	; (127e8 <bt_mesh_label_uuid_get+0x34>)
   127c6:	1ad2      	subs	r2, r2, r3
   127c8:	08d2      	lsrs	r2, r2, #3
   127ca:	0192      	lsls	r2, r2, #6
   127cc:	f042 0202 	orr.w	r2, r2, #2
   127d0:	f011 fc05 	bl	23fde <log_1>

	return NULL;
   127d4:	2000      	movs	r0, #0
}
   127d6:	bd08      	pop	{r3, pc}
			return labels[i].uuid;
   127d8:	3004      	adds	r0, #4
   127da:	e7fc      	b.n	127d6 <bt_mesh_label_uuid_get+0x22>
   127dc:	2000090c 	.word	0x2000090c
   127e0:	00029830 	.word	0x00029830
   127e4:	00029928 	.word	0x00029928
   127e8:	0002e2ae 	.word	0x0002e2ae

000127ec <mod_sub_list_clear>:
{
   127ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   127f0:	4b16      	ldr	r3, [pc, #88]	; (1284c <mod_sub_list_clear+0x60>)
   127f2:	4c17      	ldr	r4, [pc, #92]	; (12850 <mod_sub_list_clear+0x64>)
			BT_ERR("Label UUID not found");
   127f4:	f8df 805c 	ldr.w	r8, [pc, #92]	; 12854 <mod_sub_list_clear+0x68>
   127f8:	1ae4      	subs	r4, r4, r3
   127fa:	08e4      	lsrs	r4, r4, #3
   127fc:	01a4      	lsls	r4, r4, #6
   127fe:	f100 0610 	add.w	r6, r0, #16
   12802:	f100 0714 	add.w	r7, r0, #20
	for (i = 0, clear_count = 0; i < ARRAY_SIZE(mod->groups); i++) {
   12806:	2500      	movs	r5, #0
			BT_ERR("Label UUID not found");
   12808:	f044 0401 	orr.w	r4, r4, #1
		if (!BT_MESH_ADDR_IS_VIRTUAL(mod->groups[i])) {
   1280c:	f836 0b02 	ldrh.w	r0, [r6], #2
   12810:	f480 4300 	eor.w	r3, r0, #32768	; 0x8000
   12814:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   12818:	d309      	bcc.n	1282e <mod_sub_list_clear+0x42>
			if (mod->groups[i] != BT_MESH_ADDR_UNASSIGNED) {
   1281a:	b118      	cbz	r0, 12824 <mod_sub_list_clear+0x38>
				mod->groups[i] = BT_MESH_ADDR_UNASSIGNED;
   1281c:	2300      	movs	r3, #0
   1281e:	f826 3c02 	strh.w	r3, [r6, #-2]
				clear_count++;
   12822:	3501      	adds	r5, #1
	for (i = 0, clear_count = 0; i < ARRAY_SIZE(mod->groups); i++) {
   12824:	42b7      	cmp	r7, r6
   12826:	d1f1      	bne.n	1280c <mod_sub_list_clear+0x20>
}
   12828:	4628      	mov	r0, r5
   1282a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		label_uuid = bt_mesh_label_uuid_get(mod->groups[i]);
   1282e:	f7ff ffc1 	bl	127b4 <bt_mesh_label_uuid_get>
		mod->groups[i] = BT_MESH_ADDR_UNASSIGNED;
   12832:	2100      	movs	r1, #0
   12834:	f826 1c02 	strh.w	r1, [r6, #-2]
		clear_count++;
   12838:	3501      	adds	r5, #1
		if (label_uuid) {
   1283a:	b110      	cbz	r0, 12842 <mod_sub_list_clear+0x56>
			va_del(label_uuid, NULL);
   1283c:	f7ff f9c8 	bl	11bd0 <va_del>
   12840:	e7f0      	b.n	12824 <mod_sub_list_clear+0x38>
			BT_ERR("Label UUID not found");
   12842:	4621      	mov	r1, r4
   12844:	4640      	mov	r0, r8
   12846:	f011 fbbd 	bl	23fc4 <log_0>
   1284a:	e7eb      	b.n	12824 <mod_sub_list_clear+0x38>
   1284c:	00029830 	.word	0x00029830
   12850:	00029928 	.word	0x00029928
   12854:	0002e2d0 	.word	0x0002e2d0

00012858 <bt_mesh_hb_pub_get>:

struct bt_mesh_hb_pub *bt_mesh_hb_pub_get(void)
{
	if (!conf) {
   12858:	4b02      	ldr	r3, [pc, #8]	; (12864 <bt_mesh_hb_pub_get+0xc>)
   1285a:	6818      	ldr	r0, [r3, #0]
   1285c:	b100      	cbz	r0, 12860 <bt_mesh_hb_pub_get+0x8>
		return NULL;
	}

	return &conf->hb_pub;
   1285e:	300c      	adds	r0, #12
}
   12860:	4770      	bx	lr
   12862:	bf00      	nop
   12864:	20000908 	.word	0x20000908

00012868 <bt_mesh_cfg_get>:
}

struct bt_mesh_cfg_srv *bt_mesh_cfg_get(void)
{
	return conf;
}
   12868:	4b01      	ldr	r3, [pc, #4]	; (12870 <bt_mesh_cfg_get+0x8>)
   1286a:	6818      	ldr	r0, [r3, #0]
   1286c:	4770      	bx	lr
   1286e:	bf00      	nop
   12870:	20000908 	.word	0x20000908

00012874 <bt_mesh_subnet_del>:
{
	int i;

	BT_DBG("NetIdx 0x%03x store %u", sub->net_idx, store);

	if (conf && conf->hb_pub.net_idx == sub->net_idx) {
   12874:	4b1b      	ldr	r3, [pc, #108]	; (128e4 <bt_mesh_subnet_del+0x70>)
{
   12876:	b570      	push	{r4, r5, r6, lr}
   12878:	4604      	mov	r4, r0
	if (conf && conf->hb_pub.net_idx == sub->net_idx) {
   1287a:	6818      	ldr	r0, [r3, #0]
{
   1287c:	460d      	mov	r5, r1
	if (conf && conf->hb_pub.net_idx == sub->net_idx) {
   1287e:	b160      	cbz	r0, 1289a <bt_mesh_subnet_del+0x26>
   12880:	8e82      	ldrh	r2, [r0, #52]	; 0x34
   12882:	8ba3      	ldrh	r3, [r4, #28]
   12884:	429a      	cmp	r2, r3
   12886:	d108      	bne.n	1289a <bt_mesh_subnet_del+0x26>
	cfg->hb_pub.dst = BT_MESH_ADDR_UNASSIGNED;
   12888:	2300      	movs	r3, #0
   1288a:	62c3      	str	r3, [r0, #44]	; 0x2c
	cfg->hb_pub.period = 0U;
   1288c:	8603      	strh	r3, [r0, #48]	; 0x30
	k_delayed_work_cancel(&cfg->hb_pub.timer);
   1288e:	300c      	adds	r0, #12
   12890:	f010 f9f6 	bl	22c80 <k_delayed_work_cancel>
		hb_pub_disable(conf);

		if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
   12894:	b10d      	cbz	r5, 1289a <bt_mesh_subnet_del+0x26>
			bt_mesh_store_hb_pub();
   12896:	f015 f9f5 	bl	27c84 <bt_mesh_store_hb_pub>

	/* Delete any app keys bound to this NetKey index */
	for (i = 0; i < ARRAY_SIZE(bt_mesh.app_keys); i++) {
		struct bt_mesh_app_key *key = &bt_mesh.app_keys[i];

		if (key->net_idx == sub->net_idx) {
   1289a:	4e13      	ldr	r6, [pc, #76]	; (128e8 <bt_mesh_subnet_del+0x74>)
   1289c:	8ba3      	ldrh	r3, [r4, #28]
   1289e:	f8b6 214c 	ldrh.w	r2, [r6, #332]	; 0x14c
   128a2:	429a      	cmp	r2, r3
   128a4:	d104      	bne.n	128b0 <bt_mesh_subnet_del+0x3c>
			bt_mesh_app_key_del(key, store);
   128a6:	4629      	mov	r1, r5
   128a8:	f506 70a6 	add.w	r0, r6, #332	; 0x14c
   128ac:	f7ff fbc6 	bl	1203c <bt_mesh_app_key_del>
		if (key->net_idx == sub->net_idx) {
   128b0:	f8b6 2174 	ldrh.w	r2, [r6, #372]	; 0x174
   128b4:	8ba3      	ldrh	r3, [r4, #28]
   128b6:	429a      	cmp	r2, r3
   128b8:	d103      	bne.n	128c2 <bt_mesh_subnet_del+0x4e>
			bt_mesh_app_key_del(key, store);
   128ba:	480c      	ldr	r0, [pc, #48]	; (128ec <bt_mesh_subnet_del+0x78>)
   128bc:	4629      	mov	r1, r5
   128be:	f7ff fbbd 	bl	1203c <bt_mesh_app_key_del>
		}
	}

	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND)) {
		bt_mesh_friend_clear_net_idx(sub->net_idx);
   128c2:	8ba0      	ldrh	r0, [r4, #28]
   128c4:	f002 f92e 	bl	14b24 <bt_mesh_friend_clear_net_idx>
	}

	if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
   128c8:	b115      	cbz	r5, 128d0 <bt_mesh_subnet_del+0x5c>
		bt_mesh_clear_subnet(sub);
   128ca:	4620      	mov	r0, r4
   128cc:	f015 f9ec 	bl	27ca8 <bt_mesh_clear_subnet>
	}

	(void)memset(sub, 0, sizeof(*sub));
   128d0:	22e4      	movs	r2, #228	; 0xe4
   128d2:	2100      	movs	r1, #0
   128d4:	4620      	mov	r0, r4
   128d6:	f013 fa12 	bl	25cfe <memset>
	sub->net_idx = BT_MESH_KEY_UNUSED;
   128da:	f64f 73ff 	movw	r3, #65535	; 0xffff
   128de:	83a3      	strh	r3, [r4, #28]
}
   128e0:	bd70      	pop	{r4, r5, r6, pc}
   128e2:	bf00      	nop
   128e4:	20000908 	.word	0x20000908
   128e8:	20006b48 	.word	0x20006b48
   128ec:	20006cbc 	.word	0x20006cbc

000128f0 <net_key_del>:
{
   128f0:	b570      	push	{r4, r5, r6, lr}
   128f2:	4606      	mov	r6, r0
	del_idx = net_buf_simple_pull_le16(buf);
   128f4:	4610      	mov	r0, r2
{
   128f6:	460d      	mov	r5, r1
	del_idx = net_buf_simple_pull_le16(buf);
   128f8:	f016 fa35 	bl	28d66 <net_buf_simple_pull_le16>
	if (del_idx > 0xfff) {
   128fc:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	del_idx = net_buf_simple_pull_le16(buf);
   12900:	4604      	mov	r4, r0
	if (del_idx > 0xfff) {
   12902:	d30c      	bcc.n	1291e <net_key_del+0x2e>
   12904:	4a10      	ldr	r2, [pc, #64]	; (12948 <net_key_del+0x58>)
   12906:	4b11      	ldr	r3, [pc, #68]	; (1294c <net_key_del+0x5c>)
   12908:	1ad2      	subs	r2, r2, r3
   1290a:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Invalid NetKeyIndex 0x%04x", del_idx);
   1290c:	0192      	lsls	r2, r2, #6
   1290e:	4601      	mov	r1, r0
}
   12910:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Invalid NetKeyIndex 0x%04x", del_idx);
   12914:	480e      	ldr	r0, [pc, #56]	; (12950 <net_key_del+0x60>)
   12916:	f042 0201 	orr.w	r2, r2, #1
   1291a:	f011 bb60 	b.w	23fde <log_1>
	sub = bt_mesh_subnet_get(del_idx);
   1291e:	f7fa f865 	bl	c9ec <bt_mesh_subnet_get>
   12922:	4603      	mov	r3, r0
	if (!sub) {
   12924:	b130      	cbz	r0, 12934 <net_key_del+0x44>
	if (ctx->net_idx == del_idx) {
   12926:	882b      	ldrh	r3, [r5, #0]
   12928:	42a3      	cmp	r3, r4
   1292a:	d00a      	beq.n	12942 <net_key_del+0x52>
	bt_mesh_subnet_del(sub, true);
   1292c:	2101      	movs	r1, #1
   1292e:	f7ff ffa1 	bl	12874 <bt_mesh_subnet_del>
	status = STATUS_SUCCESS;
   12932:	2300      	movs	r3, #0
	send_net_key_status(model, ctx, del_idx, status);
   12934:	4622      	mov	r2, r4
   12936:	4629      	mov	r1, r5
   12938:	4630      	mov	r0, r6
}
   1293a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	send_net_key_status(model, ctx, del_idx, status);
   1293e:	f7fe b8f7 	b.w	10b30 <send_net_key_status>
		status = STATUS_CANNOT_REMOVE;
   12942:	230c      	movs	r3, #12
   12944:	e7f6      	b.n	12934 <net_key_del+0x44>
   12946:	bf00      	nop
   12948:	00029928 	.word	0x00029928
   1294c:	00029830 	.word	0x00029830
   12950:	0002db35 	.word	0x0002db35

00012954 <bt_mesh_cfg_reset>:
	struct bt_mesh_cfg_srv *cfg = conf;
   12954:	4b17      	ldr	r3, [pc, #92]	; (129b4 <bt_mesh_cfg_reset+0x60>)
{
   12956:	b510      	push	{r4, lr}
	struct bt_mesh_cfg_srv *cfg = conf;
   12958:	681c      	ldr	r4, [r3, #0]
	if (!cfg) {
   1295a:	b34c      	cbz	r4, 129b0 <bt_mesh_cfg_reset+0x5c>
	bt_mesh_set_hb_sub_dst(BT_MESH_ADDR_UNASSIGNED);
   1295c:	2000      	movs	r0, #0
   1295e:	f7fb ff37 	bl	e7d0 <bt_mesh_set_hb_sub_dst>
	cfg->hb_sub.expiry = 0;
   12962:	2200      	movs	r2, #0
   12964:	2300      	movs	r3, #0
   12966:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	cfg->hb_sub.src = BT_MESH_ADDR_UNASSIGNED;
   1296a:	2300      	movs	r3, #0
   1296c:	6423      	str	r3, [r4, #64]	; 0x40
		if (sub->net_idx != BT_MESH_KEY_UNUSED) {
   1296e:	4c12      	ldr	r4, [pc, #72]	; (129b8 <bt_mesh_cfg_reset+0x64>)
   12970:	f8b4 21b8 	ldrh.w	r2, [r4, #440]	; 0x1b8
   12974:	f64f 73ff 	movw	r3, #65535	; 0xffff
   12978:	429a      	cmp	r2, r3
   1297a:	d004      	beq.n	12986 <bt_mesh_cfg_reset+0x32>
			bt_mesh_subnet_del(sub, true);
   1297c:	2101      	movs	r1, #1
   1297e:	f504 70ce 	add.w	r0, r4, #412	; 0x19c
   12982:	f7ff ff77 	bl	12874 <bt_mesh_subnet_del>
		if (sub->net_idx != BT_MESH_KEY_UNUSED) {
   12986:	f8b4 229c 	ldrh.w	r2, [r4, #668]	; 0x29c
   1298a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1298e:	429a      	cmp	r2, r3
   12990:	d003      	beq.n	1299a <bt_mesh_cfg_reset+0x46>
			bt_mesh_subnet_del(sub, true);
   12992:	480a      	ldr	r0, [pc, #40]	; (129bc <bt_mesh_cfg_reset+0x68>)
   12994:	2101      	movs	r1, #1
   12996:	f7ff ff6d 	bl	12874 <bt_mesh_subnet_del>
	bt_mesh_model_foreach(mod_reset, NULL);
   1299a:	4809      	ldr	r0, [pc, #36]	; (129c0 <bt_mesh_cfg_reset+0x6c>)
   1299c:	2100      	movs	r1, #0
   1299e:	f7fc ff6f 	bl	f880 <bt_mesh_model_foreach>
}
   129a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void)memset(labels, 0, sizeof(labels));
   129a6:	4807      	ldr	r0, [pc, #28]	; (129c4 <bt_mesh_cfg_reset+0x70>)
   129a8:	2218      	movs	r2, #24
   129aa:	2100      	movs	r1, #0
   129ac:	f013 b9a7 	b.w	25cfe <memset>
}
   129b0:	bd10      	pop	{r4, pc}
   129b2:	bf00      	nop
   129b4:	20000908 	.word	0x20000908
   129b8:	20006b48 	.word	0x20006b48
   129bc:	20006dc8 	.word	0x20006dc8
   129c0:	00027b1f 	.word	0x00027b1f
   129c4:	2000090c 	.word	0x2000090c

000129c8 <bt_mesh_attention>:
const struct bt_mesh_model_cb bt_mesh_health_srv_cb = {
	.init = health_srv_init,
};

void bt_mesh_attention(struct bt_mesh_model *model, u8_t time)
{
   129c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   129cc:	460e      	mov	r6, r1
	struct bt_mesh_health_srv *srv;

	if (!model) {
   129ce:	4604      	mov	r4, r0
   129d0:	bb08      	cbnz	r0, 12a16 <bt_mesh_attention+0x4e>
		srv = health_srv;
   129d2:	4b18      	ldr	r3, [pc, #96]	; (12a34 <bt_mesh_attention+0x6c>)
   129d4:	681d      	ldr	r5, [r3, #0]
		if (!srv) {
   129d6:	b95d      	cbnz	r5, 129f0 <bt_mesh_attention+0x28>
   129d8:	4917      	ldr	r1, [pc, #92]	; (12a38 <bt_mesh_attention+0x70>)
   129da:	4b18      	ldr	r3, [pc, #96]	; (12a3c <bt_mesh_attention+0x74>)
			BT_WARN("No Health Server available");
   129dc:	4818      	ldr	r0, [pc, #96]	; (12a40 <bt_mesh_attention+0x78>)
   129de:	1ac9      	subs	r1, r1, r3
   129e0:	08c9      	lsrs	r1, r1, #3
   129e2:	0189      	lsls	r1, r1, #6

		if (srv->cb && srv->cb->attn_off) {
			srv->cb->attn_off(model);
		}
	}
}
   129e4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			BT_WARN("No Health Server available");
   129e8:	f041 0102 	orr.w	r1, r1, #2
   129ec:	f011 baea 	b.w	23fc4 <log_0>
		model = srv->model;
   129f0:	682c      	ldr	r4, [r5, #0]
	if (time) {
   129f2:	f105 0708 	add.w	r7, r5, #8
   129f6:	b186      	cbz	r6, 12a1a <bt_mesh_attention+0x52>
		if (srv->cb && srv->cb->attn_on) {
   129f8:	686b      	ldr	r3, [r5, #4]
   129fa:	b11b      	cbz	r3, 12a04 <bt_mesh_attention+0x3c>
   129fc:	691b      	ldr	r3, [r3, #16]
   129fe:	b10b      	cbz	r3, 12a04 <bt_mesh_attention+0x3c>
			srv->cb->attn_on(model);
   12a00:	4620      	mov	r0, r4
   12a02:	4798      	blx	r3
   12a04:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   12a08:	4372      	muls	r2, r6
   12a0a:	4639      	mov	r1, r7
   12a0c:	480d      	ldr	r0, [pc, #52]	; (12a44 <bt_mesh_attention+0x7c>)
}
   12a0e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   12a12:	f010 b8a5 	b.w	22b60 <k_delayed_work_submit_to_queue>
		srv = model->user_data;
   12a16:	69c5      	ldr	r5, [r0, #28]
   12a18:	e7eb      	b.n	129f2 <bt_mesh_attention+0x2a>
		k_delayed_work_cancel(&srv->attn_timer);
   12a1a:	4638      	mov	r0, r7
   12a1c:	f010 f930 	bl	22c80 <k_delayed_work_cancel>
		if (srv->cb && srv->cb->attn_off) {
   12a20:	686b      	ldr	r3, [r5, #4]
   12a22:	b12b      	cbz	r3, 12a30 <bt_mesh_attention+0x68>
   12a24:	695b      	ldr	r3, [r3, #20]
   12a26:	b11b      	cbz	r3, 12a30 <bt_mesh_attention+0x68>
			srv->cb->attn_off(model);
   12a28:	4620      	mov	r0, r4
}
   12a2a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			srv->cb->attn_off(model);
   12a2e:	4718      	bx	r3
}
   12a30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12a34:	20000924 	.word	0x20000924
   12a38:	00029948 	.word	0x00029948
   12a3c:	00029830 	.word	0x00029830
   12a40:	0002e2f5 	.word	0x0002e2f5
   12a44:	20001dc4 	.word	0x20001dc4

00012a48 <key_update_find>:
	schedule_store(BT_MESH_RPL_PENDING);
}

static struct key_update *key_update_find(bool app_key, u16_t key_idx,
					  struct key_update **free_slot)
{
   12a48:	b5f0      	push	{r4, r5, r6, r7, lr}
   12a4a:	4c0f      	ldr	r4, [pc, #60]	; (12a88 <key_update_find+0x40>)
	struct key_update *match;
	int i;

	match = NULL;
	*free_slot = NULL;
   12a4c:	2300      	movs	r3, #0
{
   12a4e:	4606      	mov	r6, r0
	*free_slot = NULL;
   12a50:	6013      	str	r3, [r2, #0]
	match = NULL;
   12a52:	4618      	mov	r0, r3
   12a54:	4627      	mov	r7, r4

	for (i = 0; i < ARRAY_SIZE(key_updates); i++) {
		struct key_update *update = &key_updates[i];

		if (!update->valid) {
   12a56:	eb07 0543 	add.w	r5, r7, r3, lsl #1
   12a5a:	786d      	ldrb	r5, [r5, #1]
   12a5c:	f015 0f10 	tst.w	r5, #16
   12a60:	d106      	bne.n	12a70 <key_update_find+0x28>
			*free_slot = update;
   12a62:	6014      	str	r4, [r2, #0]
	for (i = 0; i < ARRAY_SIZE(key_updates); i++) {
   12a64:	3301      	adds	r3, #1
   12a66:	2b04      	cmp	r3, #4
   12a68:	f104 0402 	add.w	r4, r4, #2
   12a6c:	d1f3      	bne.n	12a56 <key_update_find+0xe>
			match = update;
		}
	}

	return match;
}
   12a6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (update->app_key != app_key) {
   12a70:	f3c5 1540 	ubfx	r5, r5, #5, #1
   12a74:	42b5      	cmp	r5, r6
   12a76:	d1f5      	bne.n	12a64 <key_update_find+0x1c>
		if (update->key_idx == key_idx) {
   12a78:	f837 5013 	ldrh.w	r5, [r7, r3, lsl #1]
   12a7c:	f3c5 050b 	ubfx	r5, r5, #0, #12
			match = update;
   12a80:	428d      	cmp	r5, r1
   12a82:	bf08      	it	eq
   12a84:	4620      	moveq	r0, r4
   12a86:	e7ed      	b.n	12a64 <key_update_find+0x1c>
   12a88:	20001f24 	.word	0x20001f24

00012a8c <mesh_x_set>:
{
   12a8c:	b538      	push	{r3, r4, r5, lr}
   12a8e:	4604      	mov	r4, r0
   12a90:	4608      	mov	r0, r1
   12a92:	4611      	mov	r1, r2
	len = read_cb(cb_arg, out, read_len);
   12a94:	461a      	mov	r2, r3
{
   12a96:	461d      	mov	r5, r3
	len = read_cb(cb_arg, out, read_len);
   12a98:	47a0      	blx	r4
	if (len < 0) {
   12a9a:	1e04      	subs	r4, r0, #0
   12a9c:	da0c      	bge.n	12ab8 <mesh_x_set+0x2c>
   12a9e:	4a10      	ldr	r2, [pc, #64]	; (12ae0 <mesh_x_set+0x54>)
   12aa0:	4b10      	ldr	r3, [pc, #64]	; (12ae4 <mesh_x_set+0x58>)
		BT_ERR("Failed to read value (err %zu)", len);
   12aa2:	4811      	ldr	r0, [pc, #68]	; (12ae8 <mesh_x_set+0x5c>)
   12aa4:	1ad2      	subs	r2, r2, r3
   12aa6:	08d2      	lsrs	r2, r2, #3
   12aa8:	0192      	lsls	r2, r2, #6
   12aaa:	f042 0201 	orr.w	r2, r2, #1
   12aae:	4621      	mov	r1, r4
   12ab0:	f011 fa95 	bl	23fde <log_1>
}
   12ab4:	4620      	mov	r0, r4
   12ab6:	bd38      	pop	{r3, r4, r5, pc}
	if (len != read_len) {
   12ab8:	42a5      	cmp	r5, r4
   12aba:	d00e      	beq.n	12ada <mesh_x_set+0x4e>
   12abc:	4b09      	ldr	r3, [pc, #36]	; (12ae4 <mesh_x_set+0x58>)
   12abe:	4908      	ldr	r1, [pc, #32]	; (12ae0 <mesh_x_set+0x54>)
		BT_ERR("Unexpected value length (%zu != %zu)", len, read_len);
   12ac0:	480a      	ldr	r0, [pc, #40]	; (12aec <mesh_x_set+0x60>)
   12ac2:	1ac9      	subs	r1, r1, r3
   12ac4:	08c9      	lsrs	r1, r1, #3
   12ac6:	0189      	lsls	r1, r1, #6
   12ac8:	f041 0301 	orr.w	r3, r1, #1
   12acc:	462a      	mov	r2, r5
   12ace:	4621      	mov	r1, r4
   12ad0:	f011 fa99 	bl	24006 <log_2>
		return -EINVAL;
   12ad4:	f06f 0415 	mvn.w	r4, #21
   12ad8:	e7ec      	b.n	12ab4 <mesh_x_set+0x28>
	return 0;
   12ada:	2400      	movs	r4, #0
   12adc:	e7ea      	b.n	12ab4 <mesh_x_set+0x28>
   12ade:	bf00      	nop
   12ae0:	00029980 	.word	0x00029980
   12ae4:	00029830 	.word	0x00029830
   12ae8:	0002e323 	.word	0x0002e323
   12aec:	0002e342 	.word	0x0002e342

00012af0 <va_set>:
{
   12af0:	b5f0      	push	{r4, r5, r6, r7, lr}
   12af2:	460c      	mov	r4, r1
   12af4:	b087      	sub	sp, #28
   12af6:	4616      	mov	r6, r2
   12af8:	461f      	mov	r7, r3
	if (!name) {
   12afa:	b970      	cbnz	r0, 12b1a <va_set+0x2a>
   12afc:	4b2d      	ldr	r3, [pc, #180]	; (12bb4 <va_set+0xc4>)
   12afe:	492e      	ldr	r1, [pc, #184]	; (12bb8 <va_set+0xc8>)
		BT_ERR("Insufficient number of arguments");
   12b00:	482e      	ldr	r0, [pc, #184]	; (12bbc <va_set+0xcc>)
   12b02:	1ac9      	subs	r1, r1, r3
   12b04:	08c9      	lsrs	r1, r1, #3
   12b06:	0189      	lsls	r1, r1, #6
   12b08:	f041 0101 	orr.w	r1, r1, #1
   12b0c:	f011 fa5a 	bl	23fc4 <log_0>
		return -ENOENT;
   12b10:	f06f 0401 	mvn.w	r4, #1
}
   12b14:	4620      	mov	r0, r4
   12b16:	b007      	add	sp, #28
   12b18:	bdf0      	pop	{r4, r5, r6, r7, pc}
	index = strtol(name, NULL, 16);
   12b1a:	2210      	movs	r2, #16
   12b1c:	2100      	movs	r1, #0
   12b1e:	f012 fff0 	bl	25b02 <strtol>
   12b22:	4605      	mov	r5, r0
	if (len_rd == 0) {
   12b24:	b954      	cbnz	r4, 12b3c <va_set+0x4c>
   12b26:	4923      	ldr	r1, [pc, #140]	; (12bb4 <va_set+0xc4>)
   12b28:	4b23      	ldr	r3, [pc, #140]	; (12bb8 <va_set+0xc8>)
		BT_WARN("Mesh Virtual Address length = 0");
   12b2a:	4825      	ldr	r0, [pc, #148]	; (12bc0 <va_set+0xd0>)
   12b2c:	1a5b      	subs	r3, r3, r1
   12b2e:	08db      	lsrs	r3, r3, #3
   12b30:	019b      	lsls	r3, r3, #6
   12b32:	f043 0102 	orr.w	r1, r3, #2
		BT_WARN("Ignore Mesh Virtual Address ref = 0");
   12b36:	f011 fa45 	bl	23fc4 <log_0>
		return 0;
   12b3a:	e7eb      	b.n	12b14 <va_set+0x24>
	err = mesh_x_set(read_cb, cb_arg, &va, sizeof(va));
   12b3c:	2314      	movs	r3, #20
   12b3e:	aa01      	add	r2, sp, #4
   12b40:	4639      	mov	r1, r7
   12b42:	4630      	mov	r0, r6
   12b44:	f7ff ffa2 	bl	12a8c <mesh_x_set>
	if (err) {
   12b48:	4604      	mov	r4, r0
   12b4a:	b140      	cbz	r0, 12b5e <va_set+0x6e>
   12b4c:	491a      	ldr	r1, [pc, #104]	; (12bb8 <va_set+0xc8>)
   12b4e:	4b19      	ldr	r3, [pc, #100]	; (12bb4 <va_set+0xc4>)
		BT_ERR("Failed to set \'virtual address\'");
   12b50:	481c      	ldr	r0, [pc, #112]	; (12bc4 <va_set+0xd4>)
   12b52:	1ac9      	subs	r1, r1, r3
   12b54:	08c9      	lsrs	r1, r1, #3
   12b56:	0189      	lsls	r1, r1, #6
   12b58:	f041 0101 	orr.w	r1, r1, #1
   12b5c:	e7eb      	b.n	12b36 <va_set+0x46>
	if (va.ref == 0) {
   12b5e:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   12b62:	b943      	cbnz	r3, 12b76 <va_set+0x86>
   12b64:	4914      	ldr	r1, [pc, #80]	; (12bb8 <va_set+0xc8>)
   12b66:	4b13      	ldr	r3, [pc, #76]	; (12bb4 <va_set+0xc4>)
		BT_WARN("Ignore Mesh Virtual Address ref = 0");
   12b68:	4817      	ldr	r0, [pc, #92]	; (12bc8 <va_set+0xd8>)
   12b6a:	1ac9      	subs	r1, r1, r3
   12b6c:	08c9      	lsrs	r1, r1, #3
   12b6e:	0189      	lsls	r1, r1, #6
   12b70:	f041 0102 	orr.w	r1, r1, #2
   12b74:	e7df      	b.n	12b36 <va_set+0x46>
	lab = get_label(index);
   12b76:	b2a8      	uxth	r0, r5
   12b78:	f7ff fad0 	bl	1211c <get_label>
	if (lab == NULL) {
   12b7c:	4605      	mov	r5, r0
   12b7e:	b960      	cbnz	r0, 12b9a <va_set+0xaa>
   12b80:	4b0c      	ldr	r3, [pc, #48]	; (12bb4 <va_set+0xc4>)
   12b82:	490d      	ldr	r1, [pc, #52]	; (12bb8 <va_set+0xc8>)
		BT_WARN("Out of labels buffers");
   12b84:	4811      	ldr	r0, [pc, #68]	; (12bcc <va_set+0xdc>)
   12b86:	1ac9      	subs	r1, r1, r3
   12b88:	08c9      	lsrs	r1, r1, #3
   12b8a:	0189      	lsls	r1, r1, #6
   12b8c:	f041 0102 	orr.w	r1, r1, #2
   12b90:	f011 fa18 	bl	23fc4 <log_0>
		return -ENOBUFS;
   12b94:	f06f 0436 	mvn.w	r4, #54	; 0x36
   12b98:	e7bc      	b.n	12b14 <va_set+0x24>
	memcpy(lab->uuid, va.uuid, 16);
   12b9a:	2210      	movs	r2, #16
   12b9c:	a902      	add	r1, sp, #8
   12b9e:	3004      	adds	r0, #4
   12ba0:	f013 f882 	bl	25ca8 <memcpy>
	lab->addr = va.addr;
   12ba4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   12ba8:	806b      	strh	r3, [r5, #2]
	lab->ref = va.ref;
   12baa:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   12bae:	802b      	strh	r3, [r5, #0]
	return 0;
   12bb0:	e7b0      	b.n	12b14 <va_set+0x24>
   12bb2:	bf00      	nop
   12bb4:	00029830 	.word	0x00029830
   12bb8:	00029980 	.word	0x00029980
   12bbc:	0002ba0e 	.word	0x0002ba0e
   12bc0:	0002e367 	.word	0x0002e367
   12bc4:	0002e387 	.word	0x0002e387
   12bc8:	0002e3a7 	.word	0x0002e3a7
   12bcc:	0002e3cb 	.word	0x0002e3cb

00012bd0 <rpl_set>:
{
   12bd0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12bd2:	460d      	mov	r5, r1
   12bd4:	4616      	mov	r6, r2
   12bd6:	461f      	mov	r7, r3
	if (!name) {
   12bd8:	b970      	cbnz	r0, 12bf8 <rpl_set+0x28>
   12bda:	4b38      	ldr	r3, [pc, #224]	; (12cbc <rpl_set+0xec>)
   12bdc:	4938      	ldr	r1, [pc, #224]	; (12cc0 <rpl_set+0xf0>)
		BT_ERR("Insufficient number of arguments");
   12bde:	4839      	ldr	r0, [pc, #228]	; (12cc4 <rpl_set+0xf4>)
   12be0:	1ac9      	subs	r1, r1, r3
   12be2:	08c9      	lsrs	r1, r1, #3
   12be4:	0189      	lsls	r1, r1, #6
   12be6:	f041 0101 	orr.w	r1, r1, #1
   12bea:	f011 f9eb 	bl	23fc4 <log_0>
		return -ENOENT;
   12bee:	f06f 0501 	mvn.w	r5, #1
}
   12bf2:	4628      	mov	r0, r5
   12bf4:	b003      	add	sp, #12
   12bf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	src = strtol(name, NULL, 16);
   12bf8:	2210      	movs	r2, #16
   12bfa:	2100      	movs	r1, #0
   12bfc:	f012 ff81 	bl	25b02 <strtol>
		if (bt_mesh.rpl[i].src == src) {
   12c00:	4a31      	ldr	r2, [pc, #196]	; (12cc8 <rpl_set+0xf8>)
	src = strtol(name, NULL, 16);
   12c02:	b283      	uxth	r3, r0
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
   12c04:	2100      	movs	r1, #0
   12c06:	4614      	mov	r4, r2
		if (bt_mesh.rpl[i].src == src) {
   12c08:	f832 c031 	ldrh.w	ip, [r2, r1, lsl #3]
   12c0c:	459c      	cmp	ip, r3
   12c0e:	d118      	bne.n	12c42 <rpl_set+0x72>
			return &bt_mesh.rpl[i];
   12c10:	4c2d      	ldr	r4, [pc, #180]	; (12cc8 <rpl_set+0xf8>)
   12c12:	eb04 04c1 	add.w	r4, r4, r1, lsl #3
	if (len_rd == 0) {
   12c16:	b31d      	cbz	r5, 12c60 <rpl_set+0x90>
	err = mesh_x_set(read_cb, cb_arg, &rpl, sizeof(rpl));
   12c18:	2304      	movs	r3, #4
   12c1a:	eb0d 0203 	add.w	r2, sp, r3
   12c1e:	4639      	mov	r1, r7
   12c20:	4630      	mov	r0, r6
   12c22:	f7ff ff33 	bl	12a8c <mesh_x_set>
	if (err) {
   12c26:	4605      	mov	r5, r0
   12c28:	2800      	cmp	r0, #0
   12c2a:	d03c      	beq.n	12ca6 <rpl_set+0xd6>
   12c2c:	4b23      	ldr	r3, [pc, #140]	; (12cbc <rpl_set+0xec>)
   12c2e:	4924      	ldr	r1, [pc, #144]	; (12cc0 <rpl_set+0xf0>)
		BT_ERR("Failed to set `net`");
   12c30:	4826      	ldr	r0, [pc, #152]	; (12ccc <rpl_set+0xfc>)
   12c32:	1ac9      	subs	r1, r1, r3
   12c34:	08c9      	lsrs	r1, r1, #3
   12c36:	0189      	lsls	r1, r1, #6
   12c38:	f041 0101 	orr.w	r1, r1, #1
   12c3c:	f011 f9c2 	bl	23fc4 <log_0>
		return err;
   12c40:	e7d7      	b.n	12bf2 <rpl_set+0x22>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
   12c42:	3101      	adds	r1, #1
   12c44:	290a      	cmp	r1, #10
   12c46:	d1df      	bne.n	12c08 <rpl_set+0x38>
	if (len_rd == 0) {
   12c48:	b185      	cbz	r5, 12c6c <rpl_set+0x9c>
   12c4a:	2500      	movs	r5, #0
		if (!bt_mesh.rpl[i].src) {
   12c4c:	f834 2035 	ldrh.w	r2, [r4, r5, lsl #3]
   12c50:	b9c2      	cbnz	r2, 12c84 <rpl_set+0xb4>
			bt_mesh.rpl[i].src = src;
   12c52:	4c1f      	ldr	r4, [pc, #124]	; (12cd0 <rpl_set+0x100>)
   12c54:	356c      	adds	r5, #108	; 0x6c
   12c56:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
			return &bt_mesh.rpl[i];
   12c5a:	1d14      	adds	r4, r2, #4
			bt_mesh.rpl[i].src = src;
   12c5c:	8093      	strh	r3, [r2, #4]
		if (!entry) {
   12c5e:	e7db      	b.n	12c18 <rpl_set+0x48>
			(void)memset(entry, 0, sizeof(*entry));
   12c60:	2208      	movs	r2, #8
   12c62:	4629      	mov	r1, r5
   12c64:	4620      	mov	r0, r4
   12c66:	f013 f84a 	bl	25cfe <memset>
   12c6a:	e7c2      	b.n	12bf2 <rpl_set+0x22>
   12c6c:	4b13      	ldr	r3, [pc, #76]	; (12cbc <rpl_set+0xec>)
   12c6e:	4a14      	ldr	r2, [pc, #80]	; (12cc0 <rpl_set+0xf0>)
   12c70:	1ad2      	subs	r2, r2, r3
   12c72:	08d2      	lsrs	r2, r2, #3
			BT_WARN("Unable to find RPL entry for 0x%04x", src);
   12c74:	0192      	lsls	r2, r2, #6
   12c76:	b281      	uxth	r1, r0
   12c78:	f042 0202 	orr.w	r2, r2, #2
   12c7c:	4815      	ldr	r0, [pc, #84]	; (12cd4 <rpl_set+0x104>)
   12c7e:	f011 f9ae 	bl	23fde <log_1>
   12c82:	e7b6      	b.n	12bf2 <rpl_set+0x22>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
   12c84:	3501      	adds	r5, #1
   12c86:	2d0a      	cmp	r5, #10
   12c88:	d1e0      	bne.n	12c4c <rpl_set+0x7c>
   12c8a:	4b0c      	ldr	r3, [pc, #48]	; (12cbc <rpl_set+0xec>)
   12c8c:	4a0c      	ldr	r2, [pc, #48]	; (12cc0 <rpl_set+0xf0>)
   12c8e:	1ad2      	subs	r2, r2, r3
   12c90:	08d2      	lsrs	r2, r2, #3
			BT_ERR("Unable to allocate RPL entry for 0x%04x", src);
   12c92:	0192      	lsls	r2, r2, #6
   12c94:	b281      	uxth	r1, r0
   12c96:	f042 0201 	orr.w	r2, r2, #1
   12c9a:	480f      	ldr	r0, [pc, #60]	; (12cd8 <rpl_set+0x108>)
   12c9c:	f011 f99f 	bl	23fde <log_1>
			return -ENOMEM;
   12ca0:	f06f 050b 	mvn.w	r5, #11
   12ca4:	e7a5      	b.n	12bf2 <rpl_set+0x22>
	entry->seq = rpl.seq;
   12ca6:	9b01      	ldr	r3, [sp, #4]
   12ca8:	f3c3 0317 	ubfx	r3, r3, #0, #24
   12cac:	6063      	str	r3, [r4, #4]
	entry->old_iv = rpl.old_iv;
   12cae:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12cb2:	f3c3 0300 	ubfx	r3, r3, #0, #1
   12cb6:	70a3      	strb	r3, [r4, #2]
	return 0;
   12cb8:	e79b      	b.n	12bf2 <rpl_set+0x22>
   12cba:	bf00      	nop
   12cbc:	00029830 	.word	0x00029830
   12cc0:	00029980 	.word	0x00029980
   12cc4:	0002ba0e 	.word	0x0002ba0e
   12cc8:	20006eac 	.word	0x20006eac
   12ccc:	0002e405 	.word	0x0002e405
   12cd0:	20006b48 	.word	0x20006b48
   12cd4:	0002e3e1 	.word	0x0002e3e1
   12cd8:	0002e419 	.word	0x0002e419

00012cdc <hb_pub_set>:
{
   12cdc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12cde:	460c      	mov	r4, r1
   12ce0:	4616      	mov	r6, r2
   12ce2:	461f      	mov	r7, r3
	struct bt_mesh_hb_pub *pub = bt_mesh_hb_pub_get();
   12ce4:	f7ff fdb8 	bl	12858 <bt_mesh_hb_pub_get>
	if (!pub) {
   12ce8:	4605      	mov	r5, r0
   12cea:	b378      	cbz	r0, 12d4c <hb_pub_set+0x70>
	if (len_rd == 0) {
   12cec:	b924      	cbnz	r4, 12cf8 <hb_pub_set+0x1c>
		pub->period = 0U;
   12cee:	e9c0 4408 	strd	r4, r4, [r0, #32]
}
   12cf2:	4620      	mov	r0, r4
   12cf4:	b003      	add	sp, #12
   12cf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = mesh_x_set(read_cb, cb_arg, &hb_val, sizeof(hb_val));
   12cf8:	2308      	movs	r3, #8
   12cfa:	466a      	mov	r2, sp
   12cfc:	4639      	mov	r1, r7
   12cfe:	4630      	mov	r0, r6
   12d00:	f7ff fec4 	bl	12a8c <mesh_x_set>
	if (err) {
   12d04:	4604      	mov	r4, r0
   12d06:	b150      	cbz	r0, 12d1e <hb_pub_set+0x42>
   12d08:	4b12      	ldr	r3, [pc, #72]	; (12d54 <hb_pub_set+0x78>)
   12d0a:	4913      	ldr	r1, [pc, #76]	; (12d58 <hb_pub_set+0x7c>)
		BT_ERR("Failed to set \'hb_val\'");
   12d0c:	4813      	ldr	r0, [pc, #76]	; (12d5c <hb_pub_set+0x80>)
   12d0e:	1ac9      	subs	r1, r1, r3
   12d10:	08c9      	lsrs	r1, r1, #3
   12d12:	0189      	lsls	r1, r1, #6
   12d14:	f041 0101 	orr.w	r1, r1, #1
   12d18:	f011 f954 	bl	23fc4 <log_0>
		return err;
   12d1c:	e7e9      	b.n	12cf2 <hb_pub_set+0x16>
	pub->dst = hb_val.dst;
   12d1e:	f8bd 3000 	ldrh.w	r3, [sp]
   12d22:	842b      	strh	r3, [r5, #32]
	pub->feat = hb_val.feat;
   12d24:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   12d28:	84eb      	strh	r3, [r5, #38]	; 0x26
	pub->net_idx = hb_val.net_idx;
   12d2a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
	pub->period = hb_val.period;
   12d2e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   12d32:	84aa      	strh	r2, [r5, #36]	; 0x24
	pub->net_idx = hb_val.net_idx;
   12d34:	f3c3 030b 	ubfx	r3, r3, #0, #12
   12d38:	852b      	strh	r3, [r5, #40]	; 0x28
	if (hb_val.indefinite) {
   12d3a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12d3e:	06db      	lsls	r3, r3, #27
		pub->count = 0xffff;
   12d40:	bf46      	itte	mi
   12d42:	f64f 73ff 	movwmi	r3, #65535	; 0xffff
   12d46:	846b      	strhmi	r3, [r5, #34]	; 0x22
		pub->count = 0U;
   12d48:	8468      	strhpl	r0, [r5, #34]	; 0x22
   12d4a:	e7d2      	b.n	12cf2 <hb_pub_set+0x16>
		return -ENOENT;
   12d4c:	f06f 0401 	mvn.w	r4, #1
   12d50:	e7cf      	b.n	12cf2 <hb_pub_set+0x16>
   12d52:	bf00      	nop
   12d54:	00029830 	.word	0x00029830
   12d58:	00029980 	.word	0x00029980
   12d5c:	0002e441 	.word	0x0002e441

00012d60 <net_key_set>:
{
   12d60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12d64:	460c      	mov	r4, r1
   12d66:	b08b      	sub	sp, #44	; 0x2c
   12d68:	4690      	mov	r8, r2
   12d6a:	4699      	mov	r9, r3
	if (!name) {
   12d6c:	b978      	cbnz	r0, 12d8e <net_key_set+0x2e>
   12d6e:	4948      	ldr	r1, [pc, #288]	; (12e90 <net_key_set+0x130>)
   12d70:	4b48      	ldr	r3, [pc, #288]	; (12e94 <net_key_set+0x134>)
		BT_ERR("Insufficient number of arguments");
   12d72:	4849      	ldr	r0, [pc, #292]	; (12e98 <net_key_set+0x138>)
   12d74:	1ac9      	subs	r1, r1, r3
   12d76:	08c9      	lsrs	r1, r1, #3
   12d78:	0189      	lsls	r1, r1, #6
   12d7a:	f041 0101 	orr.w	r1, r1, #1
   12d7e:	f011 f921 	bl	23fc4 <log_0>
			return -ENOENT;
   12d82:	f06f 0401 	mvn.w	r4, #1
}
   12d86:	4620      	mov	r0, r4
   12d88:	b00b      	add	sp, #44	; 0x2c
   12d8a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	net_idx = strtol(name, NULL, 16);
   12d8e:	2210      	movs	r2, #16
   12d90:	2100      	movs	r1, #0
   12d92:	f012 feb6 	bl	25b02 <strtol>
   12d96:	b287      	uxth	r7, r0
	sub = bt_mesh_subnet_get(net_idx);
   12d98:	4638      	mov	r0, r7
   12d9a:	f7f9 fe27 	bl	c9ec <bt_mesh_subnet_get>
   12d9e:	4605      	mov	r5, r0
	if (len_rd == 0) {
   12da0:	b984      	cbnz	r4, 12dc4 <net_key_set+0x64>
		if (!sub) {
   12da2:	b958      	cbnz	r0, 12dbc <net_key_set+0x5c>
   12da4:	4b3b      	ldr	r3, [pc, #236]	; (12e94 <net_key_set+0x134>)
   12da6:	4a3a      	ldr	r2, [pc, #232]	; (12e90 <net_key_set+0x130>)
			BT_ERR("No subnet with NetKeyIndex 0x%03x", net_idx);
   12da8:	483c      	ldr	r0, [pc, #240]	; (12e9c <net_key_set+0x13c>)
   12daa:	1ad2      	subs	r2, r2, r3
   12dac:	08d2      	lsrs	r2, r2, #3
   12dae:	0192      	lsls	r2, r2, #6
   12db0:	f042 0201 	orr.w	r2, r2, #1
   12db4:	4639      	mov	r1, r7
   12db6:	f011 f912 	bl	23fde <log_1>
   12dba:	e7e2      	b.n	12d82 <net_key_set+0x22>
		bt_mesh_subnet_del(sub, false);
   12dbc:	4621      	mov	r1, r4
   12dbe:	f7ff fd59 	bl	12874 <bt_mesh_subnet_del>
		return 0;
   12dc2:	e7e0      	b.n	12d86 <net_key_set+0x26>
	err = mesh_x_set(read_cb, cb_arg, &key, sizeof(key));
   12dc4:	2321      	movs	r3, #33	; 0x21
   12dc6:	aa01      	add	r2, sp, #4
   12dc8:	4649      	mov	r1, r9
   12dca:	4640      	mov	r0, r8
   12dcc:	f7ff fe5e 	bl	12a8c <mesh_x_set>
	if (err) {
   12dd0:	4604      	mov	r4, r0
   12dd2:	b150      	cbz	r0, 12dea <net_key_set+0x8a>
   12dd4:	4b2f      	ldr	r3, [pc, #188]	; (12e94 <net_key_set+0x134>)
   12dd6:	492e      	ldr	r1, [pc, #184]	; (12e90 <net_key_set+0x130>)
		BT_ERR("Failed to set \'net-key\'");
   12dd8:	4831      	ldr	r0, [pc, #196]	; (12ea0 <net_key_set+0x140>)
   12dda:	1ac9      	subs	r1, r1, r3
   12ddc:	08c9      	lsrs	r1, r1, #3
   12dde:	0189      	lsls	r1, r1, #6
   12de0:	f041 0101 	orr.w	r1, r1, #1
   12de4:	f011 f8ee 	bl	23fc4 <log_0>
		return err;
   12de8:	e7cd      	b.n	12d86 <net_key_set+0x26>
	if (sub) {
   12dea:	bb55      	cbnz	r5, 12e42 <net_key_set+0xe2>
		if (bt_mesh.sub[i].net_idx == BT_MESH_KEY_UNUSED) {
   12dec:	4b2d      	ldr	r3, [pc, #180]	; (12ea4 <net_key_set+0x144>)
   12dee:	f8b3 11b8 	ldrh.w	r1, [r3, #440]	; 0x1b8
   12df2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   12df6:	4291      	cmp	r1, r2
   12df8:	461e      	mov	r6, r3
   12dfa:	d004      	beq.n	12e06 <net_key_set+0xa6>
   12dfc:	f8b3 329c 	ldrh.w	r3, [r3, #668]	; 0x29c
   12e00:	4293      	cmp	r3, r2
   12e02:	d137      	bne.n	12e74 <net_key_set+0x114>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
   12e04:	2001      	movs	r0, #1
			sub = &bt_mesh.sub[i];
   12e06:	25e4      	movs	r5, #228	; 0xe4
	sub->kr_flag = key.kr_flag;
   12e08:	f89d 3004 	ldrb.w	r3, [sp, #4]
   12e0c:	4345      	muls	r5, r0
	sub->net_idx = net_idx;
   12e0e:	1972      	adds	r2, r6, r5
	sub->kr_flag = key.kr_flag;
   12e10:	f3c3 0100 	ubfx	r1, r3, #0, #1
	memcpy(sub->keys[0].net, &key.val[0], 16);
   12e14:	f505 70e6 	add.w	r0, r5, #460	; 0x1cc
	sub->kr_phase = key.kr_phase;
   12e18:	f3c3 0346 	ubfx	r3, r3, #1, #7
	sub->kr_flag = key.kr_flag;
   12e1c:	f882 11ba 	strb.w	r1, [r2, #442]	; 0x1ba
	sub->net_idx = net_idx;
   12e20:	f8a2 71b8 	strh.w	r7, [r2, #440]	; 0x1b8
	sub->kr_phase = key.kr_phase;
   12e24:	f882 31bb 	strb.w	r3, [r2, #443]	; 0x1bb
	memcpy(sub->keys[0].net, &key.val[0], 16);
   12e28:	f10d 0105 	add.w	r1, sp, #5
   12e2c:	2210      	movs	r2, #16
   12e2e:	4430      	add	r0, r6
   12e30:	f012 ff3a 	bl	25ca8 <memcpy>
	memcpy(sub->keys[1].net, &key.val[1], 16);
   12e34:	f205 2025 	addw	r0, r5, #549	; 0x225
   12e38:	2210      	movs	r2, #16
   12e3a:	f10d 0115 	add.w	r1, sp, #21
   12e3e:	4430      	add	r0, r6
   12e40:	e015      	b.n	12e6e <net_key_set+0x10e>
		sub->kr_flag = key.kr_flag;
   12e42:	f89d 3004 	ldrb.w	r3, [sp, #4]
   12e46:	f3c3 0300 	ubfx	r3, r3, #0, #1
   12e4a:	77ab      	strb	r3, [r5, #30]
		sub->kr_phase = key.kr_phase;
   12e4c:	f89d 3004 	ldrb.w	r3, [sp, #4]
   12e50:	f3c3 0346 	ubfx	r3, r3, #1, #7
		memcpy(sub->keys[0].net, &key.val[0], 16);
   12e54:	2210      	movs	r2, #16
   12e56:	f10d 0105 	add.w	r1, sp, #5
		sub->kr_phase = key.kr_phase;
   12e5a:	77eb      	strb	r3, [r5, #31]
		memcpy(sub->keys[0].net, &key.val[0], 16);
   12e5c:	f105 0030 	add.w	r0, r5, #48	; 0x30
   12e60:	f012 ff22 	bl	25ca8 <memcpy>
		memcpy(sub->keys[1].net, &key.val[1], 16);
   12e64:	2210      	movs	r2, #16
   12e66:	f10d 0115 	add.w	r1, sp, #21
   12e6a:	f105 0089 	add.w	r0, r5, #137	; 0x89
	memcpy(sub->keys[1].net, &key.val[1], 16);
   12e6e:	f012 ff1b 	bl	25ca8 <memcpy>
	return 0;
   12e72:	e788      	b.n	12d86 <net_key_set+0x26>
   12e74:	4b07      	ldr	r3, [pc, #28]	; (12e94 <net_key_set+0x134>)
   12e76:	4906      	ldr	r1, [pc, #24]	; (12e90 <net_key_set+0x130>)
		BT_ERR("No space to allocate a new subnet");
   12e78:	480b      	ldr	r0, [pc, #44]	; (12ea8 <net_key_set+0x148>)
   12e7a:	1ac9      	subs	r1, r1, r3
   12e7c:	08c9      	lsrs	r1, r1, #3
   12e7e:	0189      	lsls	r1, r1, #6
   12e80:	f041 0101 	orr.w	r1, r1, #1
   12e84:	f011 f89e 	bl	23fc4 <log_0>
		return -ENOMEM;
   12e88:	f06f 040b 	mvn.w	r4, #11
   12e8c:	e77b      	b.n	12d86 <net_key_set+0x26>
   12e8e:	bf00      	nop
   12e90:	00029980 	.word	0x00029980
   12e94:	00029830 	.word	0x00029830
   12e98:	0002ba0e 	.word	0x0002ba0e
   12e9c:	0002e458 	.word	0x0002e458
   12ea0:	0002e47a 	.word	0x0002e47a
   12ea4:	20006b48 	.word	0x20006b48
   12ea8:	0002e492 	.word	0x0002e492

00012eac <commit_mod>:
	if (mod->pub && mod->pub->update &&
   12eac:	6883      	ldr	r3, [r0, #8]
{
   12eae:	b510      	push	{r4, lr}
   12eb0:	4604      	mov	r4, r0
	if (mod->pub && mod->pub->update &&
   12eb2:	b173      	cbz	r3, 12ed2 <commit_mod+0x26>
   12eb4:	695a      	ldr	r2, [r3, #20]
   12eb6:	b162      	cbz	r2, 12ed2 <commit_mod+0x26>
   12eb8:	889b      	ldrh	r3, [r3, #4]
   12eba:	b153      	cbz	r3, 12ed2 <commit_mod+0x26>
		s32_t ms = bt_mesh_model_pub_period_get(mod);
   12ebc:	f7fc fd1a 	bl	f8f4 <bt_mesh_model_pub_period_get>
		if (ms) {
   12ec0:	4602      	mov	r2, r0
   12ec2:	b130      	cbz	r0, 12ed2 <commit_mod+0x26>
			k_delayed_work_submit(&mod->pub->timer, ms);
   12ec4:	68a1      	ldr	r1, [r4, #8]
   12ec6:	4803      	ldr	r0, [pc, #12]	; (12ed4 <commit_mod+0x28>)
}
   12ec8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   12ecc:	3118      	adds	r1, #24
   12ece:	f00f be47 	b.w	22b60 <k_delayed_work_submit_to_queue>
   12ed2:	bd10      	pop	{r4, pc}
   12ed4:	20001dc4 	.word	0x20001dc4

00012ed8 <mesh_set>:
{
   12ed8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   12edc:	4688      	mov	r8, r1
   12ede:	4691      	mov	r9, r2
   12ee0:	469a      	mov	sl, r3
	if (!name) {
   12ee2:	4605      	mov	r5, r0
   12ee4:	b970      	cbnz	r0, 12f04 <mesh_set+0x2c>
   12ee6:	4b1d      	ldr	r3, [pc, #116]	; (12f5c <mesh_set+0x84>)
   12ee8:	491d      	ldr	r1, [pc, #116]	; (12f60 <mesh_set+0x88>)
		BT_ERR("Insufficient number of arguments");
   12eea:	481e      	ldr	r0, [pc, #120]	; (12f64 <mesh_set+0x8c>)
   12eec:	1ac9      	subs	r1, r1, r3
   12eee:	08c9      	lsrs	r1, r1, #3
   12ef0:	0189      	lsls	r1, r1, #6
   12ef2:	f041 0101 	orr.w	r1, r1, #1
   12ef6:	f011 f865 	bl	23fc4 <log_0>
		return -EINVAL;
   12efa:	f06f 0015 	mvn.w	r0, #21
}
   12efe:	b002      	add	sp, #8
   12f00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	len = settings_name_next(name, &next);
   12f04:	a901      	add	r1, sp, #4
   12f06:	f011 fc3a 	bl	2477e <settings_name_next>
		if (!strncmp(settings[i].name, name, len)) {
   12f0a:	4e17      	ldr	r6, [pc, #92]	; (12f68 <mesh_set+0x90>)
	len = settings_name_next(name, &next);
   12f0c:	4607      	mov	r7, r0
	for (i = 0; i < ARRAY_SIZE(settings); i++) {
   12f0e:	2400      	movs	r4, #0
		if (!strncmp(settings[i].name, name, len)) {
   12f10:	f856 0034 	ldr.w	r0, [r6, r4, lsl #3]
   12f14:	463a      	mov	r2, r7
   12f16:	4629      	mov	r1, r5
   12f18:	f012 fea7 	bl	25c6a <strncmp>
   12f1c:	b940      	cbnz	r0, 12f30 <mesh_set+0x58>
			return settings[i].func(next, len_rd, read_cb, cb_arg);
   12f1e:	eb06 04c4 	add.w	r4, r6, r4, lsl #3
   12f22:	9801      	ldr	r0, [sp, #4]
   12f24:	6864      	ldr	r4, [r4, #4]
   12f26:	4653      	mov	r3, sl
   12f28:	464a      	mov	r2, r9
   12f2a:	4641      	mov	r1, r8
   12f2c:	47a0      	blx	r4
   12f2e:	e7e6      	b.n	12efe <mesh_set+0x26>
	for (i = 0; i < ARRAY_SIZE(settings); i++) {
   12f30:	3401      	adds	r4, #1
   12f32:	2c0b      	cmp	r4, #11
   12f34:	d1ec      	bne.n	12f10 <mesh_set+0x38>
   12f36:	4a09      	ldr	r2, [pc, #36]	; (12f5c <mesh_set+0x84>)
   12f38:	4c09      	ldr	r4, [pc, #36]	; (12f60 <mesh_set+0x88>)
	BT_WARN("No matching handler for key %s", log_strdup(name));
   12f3a:	4628      	mov	r0, r5
   12f3c:	1aa4      	subs	r4, r4, r2
   12f3e:	08e4      	lsrs	r4, r4, #3
   12f40:	f7ef fb4e 	bl	25e0 <log_strdup>
   12f44:	01a4      	lsls	r4, r4, #6
   12f46:	f044 0402 	orr.w	r4, r4, #2
   12f4a:	4601      	mov	r1, r0
   12f4c:	4622      	mov	r2, r4
   12f4e:	4807      	ldr	r0, [pc, #28]	; (12f6c <mesh_set+0x94>)
   12f50:	f011 f845 	bl	23fde <log_1>
	return -ENOENT;
   12f54:	f06f 0001 	mvn.w	r0, #1
   12f58:	e7d1      	b.n	12efe <mesh_set+0x26>
   12f5a:	bf00      	nop
   12f5c:	00029830 	.word	0x00029830
   12f60:	00029980 	.word	0x00029980
   12f64:	0002ba0e 	.word	0x0002ba0e
   12f68:	0002a2fc 	.word	0x0002a2fc
   12f6c:	0002e4b4 	.word	0x0002e4b4

00012f70 <store_app_key>:
{
   12f70:	b510      	push	{r4, lr}
   12f72:	b08e      	sub	sp, #56	; 0x38
	key.net_idx = app->net_idx;
   12f74:	8803      	ldrh	r3, [r0, #0]
   12f76:	f8ad 3014 	strh.w	r3, [sp, #20]
{
   12f7a:	4604      	mov	r4, r0
	key.updated = app->updated;
   12f7c:	7903      	ldrb	r3, [r0, #4]
   12f7e:	f88d 3016 	strb.w	r3, [sp, #22]
	memcpy(key.val[0], app->keys[0].val, 16);
   12f82:	1d81      	adds	r1, r0, #6
   12f84:	2210      	movs	r2, #16
   12f86:	f10d 0017 	add.w	r0, sp, #23
   12f8a:	f012 fe8d 	bl	25ca8 <memcpy>
	memcpy(key.val[1], app->keys[1].val, 16);
   12f8e:	2210      	movs	r2, #16
   12f90:	f104 0117 	add.w	r1, r4, #23
   12f94:	f10d 0027 	add.w	r0, sp, #39	; 0x27
   12f98:	f012 fe86 	bl	25ca8 <memcpy>
	snprintk(path, sizeof(path), "bt/mesh/AppKey/%x", app->app_idx);
   12f9c:	4a0e      	ldr	r2, [pc, #56]	; (12fd8 <store_app_key+0x68>)
   12f9e:	8863      	ldrh	r3, [r4, #2]
   12fa0:	2114      	movs	r1, #20
   12fa2:	4668      	mov	r0, sp
   12fa4:	f010 ffaa 	bl	23efc <snprintk>
	err = settings_save_one(path, &key, sizeof(key));
   12fa8:	2223      	movs	r2, #35	; 0x23
   12faa:	a905      	add	r1, sp, #20
   12fac:	4668      	mov	r0, sp
   12fae:	f7f0 fcb5 	bl	391c <settings_save_one>
	if (err) {
   12fb2:	b170      	cbz	r0, 12fd2 <store_app_key+0x62>
   12fb4:	4a09      	ldr	r2, [pc, #36]	; (12fdc <store_app_key+0x6c>)
   12fb6:	4c0a      	ldr	r4, [pc, #40]	; (12fe0 <store_app_key+0x70>)
		BT_ERR("Failed to store AppKey %s value", log_strdup(path));
   12fb8:	4668      	mov	r0, sp
   12fba:	1aa4      	subs	r4, r4, r2
   12fbc:	08e4      	lsrs	r4, r4, #3
   12fbe:	f7ef fb0f 	bl	25e0 <log_strdup>
   12fc2:	01a4      	lsls	r4, r4, #6
   12fc4:	f044 0401 	orr.w	r4, r4, #1
   12fc8:	4601      	mov	r1, r0
   12fca:	4622      	mov	r2, r4
   12fcc:	4805      	ldr	r0, [pc, #20]	; (12fe4 <store_app_key+0x74>)
   12fce:	f011 f806 	bl	23fde <log_1>
}
   12fd2:	b00e      	add	sp, #56	; 0x38
   12fd4:	bd10      	pop	{r4, pc}
   12fd6:	bf00      	nop
   12fd8:	0002e4d3 	.word	0x0002e4d3
   12fdc:	00029830 	.word	0x00029830
   12fe0:	00029980 	.word	0x00029980
   12fe4:	0002e4e5 	.word	0x0002e4e5

00012fe8 <mod_set>:
{
   12fe8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   12fec:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
   12ff0:	4605      	mov	r5, r0
   12ff2:	4616      	mov	r6, r2
   12ff4:	461f      	mov	r7, r3
	if (!name) {
   12ff6:	468a      	mov	sl, r1
   12ff8:	b951      	cbnz	r1, 13010 <mod_set+0x28>
   12ffa:	4b6c      	ldr	r3, [pc, #432]	; (131ac <mod_set+0x1c4>)
   12ffc:	496c      	ldr	r1, [pc, #432]	; (131b0 <mod_set+0x1c8>)
		BT_ERR("Insufficient number of arguments");
   12ffe:	486d      	ldr	r0, [pc, #436]	; (131b4 <mod_set+0x1cc>)
   13000:	1ac9      	subs	r1, r1, r3
   13002:	08c9      	lsrs	r1, r1, #3
   13004:	0189      	lsls	r1, r1, #6
   13006:	f041 0101 	orr.w	r1, r1, #1
   1300a:	f010 ffdb 	bl	23fc4 <log_0>
		return -ENOENT;
   1300e:	e01b      	b.n	13048 <mod_set+0x60>
	mod_key = strtol(name, NULL, 16);
   13010:	2210      	movs	r2, #16
   13012:	2100      	movs	r1, #0
   13014:	4650      	mov	r0, sl
   13016:	f012 fd74 	bl	25b02 <strtol>
	elem_idx = mod_key >> 8;
   1301a:	f3c0 2407 	ubfx	r4, r0, #8, #8
	mod = bt_mesh_model_get(vnd, elem_idx, mod_idx);
   1301e:	fa5f f880 	uxtb.w	r8, r0
   13022:	4642      	mov	r2, r8
   13024:	4628      	mov	r0, r5
   13026:	4621      	mov	r1, r4
   13028:	f7fc fcc8 	bl	f9bc <bt_mesh_model_get>
	if (!mod) {
   1302c:	4605      	mov	r5, r0
   1302e:	b970      	cbnz	r0, 1304e <mod_set+0x66>
   13030:	4a5e      	ldr	r2, [pc, #376]	; (131ac <mod_set+0x1c4>)
   13032:	4b5f      	ldr	r3, [pc, #380]	; (131b0 <mod_set+0x1c8>)
		BT_ERR("Failed to get model for elem_idx %u mod_idx %u",
   13034:	4860      	ldr	r0, [pc, #384]	; (131b8 <mod_set+0x1d0>)
   13036:	1a9b      	subs	r3, r3, r2
   13038:	08db      	lsrs	r3, r3, #3
   1303a:	019b      	lsls	r3, r3, #6
   1303c:	f043 0301 	orr.w	r3, r3, #1
   13040:	4642      	mov	r2, r8
   13042:	4621      	mov	r1, r4
   13044:	f010 ffdf 	bl	24006 <log_2>
	return -ENOENT;
   13048:	f06f 0401 	mvn.w	r4, #1
   1304c:	e011      	b.n	13072 <mod_set+0x8a>
	len = settings_name_next(name, &next);
   1304e:	a901      	add	r1, sp, #4
   13050:	4650      	mov	r0, sl
   13052:	f011 fb94 	bl	2477e <settings_name_next>
   13056:	4680      	mov	r8, r0
	if (!next) {
   13058:	9801      	ldr	r0, [sp, #4]
   1305a:	2800      	cmp	r0, #0
   1305c:	d0cd      	beq.n	12ffa <mod_set+0x12>
	if (!strncmp(next, "bind", len)) {
   1305e:	4957      	ldr	r1, [pc, #348]	; (131bc <mod_set+0x1d4>)
   13060:	4642      	mov	r2, r8
   13062:	f012 fe02 	bl	25c6a <strncmp>
   13066:	b9d8      	cbnz	r0, 130a0 <mod_set+0xb8>
		mod->keys[i] = BT_MESH_KEY_UNUSED;
   13068:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1306c:	60eb      	str	r3, [r5, #12]
	if (len_rd == 0) {
   1306e:	b926      	cbnz	r6, 1307a <mod_set+0x92>
		return 0;
   13070:	2400      	movs	r4, #0
}
   13072:	4620      	mov	r0, r4
   13074:	b004      	add	sp, #16
   13076:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	len = read_cb(cb_arg, mod->keys, sizeof(mod->keys));
   1307a:	2204      	movs	r2, #4
   1307c:	f105 010c 	add.w	r1, r5, #12
	len = read_cb(cb_arg, mod->groups, sizeof(mod->groups));
   13080:	4648      	mov	r0, r9
   13082:	47b8      	blx	r7
	if (len < 0) {
   13084:	1e04      	subs	r4, r0, #0
   13086:	daf3      	bge.n	13070 <mod_set+0x88>
   13088:	4b48      	ldr	r3, [pc, #288]	; (131ac <mod_set+0x1c4>)
   1308a:	4a49      	ldr	r2, [pc, #292]	; (131b0 <mod_set+0x1c8>)
		BT_ERR("Failed to read value (err %zu)", len);
   1308c:	484c      	ldr	r0, [pc, #304]	; (131c0 <mod_set+0x1d8>)
   1308e:	1ad2      	subs	r2, r2, r3
   13090:	08d2      	lsrs	r2, r2, #3
   13092:	0192      	lsls	r2, r2, #6
   13094:	f042 0201 	orr.w	r2, r2, #1
   13098:	4621      	mov	r1, r4
   1309a:	f010 ffa0 	bl	23fde <log_1>
		return len;
   1309e:	e7e8      	b.n	13072 <mod_set+0x8a>
	if (!strncmp(next, "sub", len)) {
   130a0:	4948      	ldr	r1, [pc, #288]	; (131c4 <mod_set+0x1dc>)
   130a2:	9801      	ldr	r0, [sp, #4]
   130a4:	4642      	mov	r2, r8
   130a6:	f012 fde0 	bl	25c6a <strncmp>
   130aa:	4601      	mov	r1, r0
   130ac:	b948      	cbnz	r0, 130c2 <mod_set+0xda>
	(void)memset(mod->groups, 0, sizeof(mod->groups));
   130ae:	3510      	adds	r5, #16
   130b0:	2204      	movs	r2, #4
   130b2:	4628      	mov	r0, r5
   130b4:	f012 fe23 	bl	25cfe <memset>
	if (len_rd == 0) {
   130b8:	2e00      	cmp	r6, #0
   130ba:	d0d9      	beq.n	13070 <mod_set+0x88>
	len = read_cb(cb_arg, mod->groups, sizeof(mod->groups));
   130bc:	2204      	movs	r2, #4
   130be:	4629      	mov	r1, r5
   130c0:	e7de      	b.n	13080 <mod_set+0x98>
	if (!strncmp(next, "pub", len)) {
   130c2:	4941      	ldr	r1, [pc, #260]	; (131c8 <mod_set+0x1e0>)
   130c4:	9801      	ldr	r0, [sp, #4]
   130c6:	4642      	mov	r2, r8
   130c8:	f012 fdcf 	bl	25c6a <strncmp>
   130cc:	4604      	mov	r4, r0
   130ce:	2800      	cmp	r0, #0
   130d0:	d14a      	bne.n	13168 <mod_set+0x180>
	if (!mod->pub) {
   130d2:	68ab      	ldr	r3, [r5, #8]
   130d4:	b963      	cbnz	r3, 130f0 <mod_set+0x108>
   130d6:	4b35      	ldr	r3, [pc, #212]	; (131ac <mod_set+0x1c4>)
   130d8:	4935      	ldr	r1, [pc, #212]	; (131b0 <mod_set+0x1c8>)
		BT_WARN("Model has no publication context!");
   130da:	483c      	ldr	r0, [pc, #240]	; (131cc <mod_set+0x1e4>)
   130dc:	1ac9      	subs	r1, r1, r3
   130de:	08c9      	lsrs	r1, r1, #3
   130e0:	0189      	lsls	r1, r1, #6
   130e2:	f041 0102 	orr.w	r1, r1, #2
   130e6:	f010 ff6d 	bl	23fc4 <log_0>
		return -EINVAL;
   130ea:	f06f 0415 	mvn.w	r4, #21
   130ee:	e7c0      	b.n	13072 <mod_set+0x8a>
	if (len_rd == 0) {
   130f0:	b946      	cbnz	r6, 13104 <mod_set+0x11c>
		mod->pub->addr = BT_MESH_ADDR_UNASSIGNED;
   130f2:	685a      	ldr	r2, [r3, #4]
   130f4:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
   130f8:	605a      	str	r2, [r3, #4]
		mod->pub->ttl = 0U;
   130fa:	689a      	ldr	r2, [r3, #8]
   130fc:	f002 52f8 	and.w	r2, r2, #520093696	; 0x1f000000
   13100:	609a      	str	r2, [r3, #8]
		return 0;
   13102:	e7b6      	b.n	13072 <mod_set+0x8a>
	err = mesh_x_set(read_cb, cb_arg, &pub, sizeof(pub));
   13104:	2308      	movs	r3, #8
   13106:	eb0d 0203 	add.w	r2, sp, r3
   1310a:	4649      	mov	r1, r9
   1310c:	4638      	mov	r0, r7
   1310e:	f7ff fcbd 	bl	12a8c <mesh_x_set>
	if (err) {
   13112:	4604      	mov	r4, r0
   13114:	b150      	cbz	r0, 1312c <mod_set+0x144>
   13116:	4b25      	ldr	r3, [pc, #148]	; (131ac <mod_set+0x1c4>)
   13118:	4925      	ldr	r1, [pc, #148]	; (131b0 <mod_set+0x1c8>)
		BT_ERR("Failed to set \'model-pub\'");
   1311a:	482d      	ldr	r0, [pc, #180]	; (131d0 <mod_set+0x1e8>)
   1311c:	1ac9      	subs	r1, r1, r3
   1311e:	08c9      	lsrs	r1, r1, #3
   13120:	0189      	lsls	r1, r1, #6
   13122:	f041 0101 	orr.w	r1, r1, #1
   13126:	f010 ff4d 	bl	23fc4 <log_0>
		return err;
   1312a:	e7a2      	b.n	13072 <mod_set+0x8a>
	mod->pub->addr = pub.addr;
   1312c:	68ab      	ldr	r3, [r5, #8]
   1312e:	f8bd 2008 	ldrh.w	r2, [sp, #8]
   13132:	809a      	strh	r2, [r3, #4]
	mod->pub->cred = pub.cred;
   13134:	f89d 200f 	ldrb.w	r2, [sp, #15]
	mod->pub->key = pub.key;
   13138:	f3c2 1100 	ubfx	r1, r2, #4, #1
   1313c:	f8bd 200a 	ldrh.w	r2, [sp, #10]
   13140:	f3c2 020b 	ubfx	r2, r2, #0, #12
   13144:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
   13148:	88d9      	ldrh	r1, [r3, #6]
   1314a:	f401 4160 	and.w	r1, r1, #57344	; 0xe000
   1314e:	430a      	orrs	r2, r1
   13150:	80da      	strh	r2, [r3, #6]
	mod->pub->period = pub.period;
   13152:	f89d 200e 	ldrb.w	r2, [sp, #14]
   13156:	729a      	strb	r2, [r3, #10]
	mod->pub->count = 0U;
   13158:	7ada      	ldrb	r2, [r3, #11]
	mod->pub->ttl = pub.ttl;
   1315a:	f8bd 100c 	ldrh.w	r1, [sp, #12]
   1315e:	8119      	strh	r1, [r3, #8]
	mod->pub->count = 0U;
   13160:	f360 1247 	bfi	r2, r0, #5, #3
   13164:	72da      	strb	r2, [r3, #11]
		return mod_set_pub(mod, len_rd, read_cb, cb_arg);
   13166:	e784      	b.n	13072 <mod_set+0x8a>
	if (!strncmp(next, "data", len)) {
   13168:	491a      	ldr	r1, [pc, #104]	; (131d4 <mod_set+0x1ec>)
   1316a:	9801      	ldr	r0, [sp, #4]
   1316c:	4642      	mov	r2, r8
   1316e:	f012 fd7c 	bl	25c6a <strncmp>
   13172:	b970      	cbnz	r0, 13192 <mod_set+0x1aa>
		mod->flags |= BT_MESH_MOD_DATA_PRESENT;
   13174:	88eb      	ldrh	r3, [r5, #6]
   13176:	f043 0308 	orr.w	r3, r3, #8
   1317a:	80eb      	strh	r3, [r5, #6]
		if (mod->cb && mod->cb->settings_set) {
   1317c:	69ab      	ldr	r3, [r5, #24]
   1317e:	b143      	cbz	r3, 13192 <mod_set+0x1aa>
   13180:	681c      	ldr	r4, [r3, #0]
   13182:	b134      	cbz	r4, 13192 <mod_set+0x1aa>
			return mod->cb->settings_set(mod, len_rd, read_cb, cb_arg);
   13184:	464b      	mov	r3, r9
   13186:	463a      	mov	r2, r7
   13188:	4631      	mov	r1, r6
   1318a:	4628      	mov	r0, r5
   1318c:	47a0      	blx	r4
   1318e:	4604      	mov	r4, r0
   13190:	e76f      	b.n	13072 <mod_set+0x8a>
   13192:	4b06      	ldr	r3, [pc, #24]	; (131ac <mod_set+0x1c4>)
   13194:	4a06      	ldr	r2, [pc, #24]	; (131b0 <mod_set+0x1c8>)
	BT_WARN("Unknown module key %s", next);
   13196:	9901      	ldr	r1, [sp, #4]
   13198:	480f      	ldr	r0, [pc, #60]	; (131d8 <mod_set+0x1f0>)
   1319a:	1ad2      	subs	r2, r2, r3
   1319c:	08d2      	lsrs	r2, r2, #3
   1319e:	0192      	lsls	r2, r2, #6
   131a0:	f042 0202 	orr.w	r2, r2, #2
   131a4:	f010 ff1b 	bl	23fde <log_1>
   131a8:	e74e      	b.n	13048 <mod_set+0x60>
   131aa:	bf00      	nop
   131ac:	00029830 	.word	0x00029830
   131b0:	00029980 	.word	0x00029980
   131b4:	0002ba0e 	.word	0x0002ba0e
   131b8:	0002e505 	.word	0x0002e505
   131bc:	0002e534 	.word	0x0002e534
   131c0:	0002e323 	.word	0x0002e323
   131c4:	0002e539 	.word	0x0002e539
   131c8:	0002e53d 	.word	0x0002e53d
   131cc:	0002e541 	.word	0x0002e541
   131d0:	0002e563 	.word	0x0002e563
   131d4:	0002c4c6 	.word	0x0002c4c6
   131d8:	0002e57d 	.word	0x0002e57d

000131dc <seq_set>:
{
   131dc:	b513      	push	{r0, r1, r4, lr}
   131de:	460c      	mov	r4, r1
   131e0:	4610      	mov	r0, r2
   131e2:	4619      	mov	r1, r3
	if (len_rd == 0) {
   131e4:	b924      	cbnz	r4, 131f0 <seq_set+0x14>
		bt_mesh.seq = 0U;
   131e6:	4b13      	ldr	r3, [pc, #76]	; (13234 <seq_set+0x58>)
   131e8:	605c      	str	r4, [r3, #4]
}
   131ea:	4620      	mov	r0, r4
   131ec:	b002      	add	sp, #8
   131ee:	bd10      	pop	{r4, pc}
	err = mesh_x_set(read_cb, cb_arg, &seq, sizeof(seq));
   131f0:	2303      	movs	r3, #3
   131f2:	aa01      	add	r2, sp, #4
   131f4:	f7ff fc4a 	bl	12a8c <mesh_x_set>
	if (err) {
   131f8:	4604      	mov	r4, r0
   131fa:	b150      	cbz	r0, 13212 <seq_set+0x36>
   131fc:	4b0e      	ldr	r3, [pc, #56]	; (13238 <seq_set+0x5c>)
   131fe:	490f      	ldr	r1, [pc, #60]	; (1323c <seq_set+0x60>)
		BT_ERR("Failed to set \'seq\'");
   13200:	480f      	ldr	r0, [pc, #60]	; (13240 <seq_set+0x64>)
   13202:	1ac9      	subs	r1, r1, r3
   13204:	08c9      	lsrs	r1, r1, #3
   13206:	0189      	lsls	r1, r1, #6
   13208:	f041 0101 	orr.w	r1, r1, #1
   1320c:	f010 feda 	bl	23fc4 <log_0>
		return err;
   13210:	e7eb      	b.n	131ea <seq_set+0xe>
	return ((u16_t)src[1] << 8) | src[0];
   13212:	f89d 2005 	ldrb.w	r2, [sp, #5]
   13216:	f89d 3004 	ldrb.w	r3, [sp, #4]
	return ((u32_t)src[2] << 16) | sys_get_le16(&src[0]);
   1321a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1321e:	f89d 2006 	ldrb.w	r2, [sp, #6]
   13222:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
		bt_mesh.seq += (CONFIG_BT_MESH_SEQ_STORE_RATE -
   13226:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
		bt_mesh.seq--;
   1322a:	4a02      	ldr	r2, [pc, #8]	; (13234 <seq_set+0x58>)
   1322c:	337f      	adds	r3, #127	; 0x7f
   1322e:	6053      	str	r3, [r2, #4]
	return 0;
   13230:	e7db      	b.n	131ea <seq_set+0xe>
   13232:	bf00      	nop
   13234:	20006b48 	.word	0x20006b48
   13238:	00029830 	.word	0x00029830
   1323c:	00029980 	.word	0x00029980
   13240:	0002e593 	.word	0x0002e593

00013244 <cfg_set>:
{
   13244:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13246:	460c      	mov	r4, r1
   13248:	4616      	mov	r6, r2
   1324a:	461f      	mov	r7, r3
	struct bt_mesh_cfg_srv *cfg = bt_mesh_cfg_get();
   1324c:	f7ff fb0c 	bl	12868 <bt_mesh_cfg_get>
	if (!cfg) {
   13250:	b1d0      	cbz	r0, 13288 <cfg_set+0x44>
	if (len_rd == 0) {
   13252:	4d0f      	ldr	r5, [pc, #60]	; (13290 <cfg_set+0x4c>)
   13254:	b914      	cbnz	r4, 1325c <cfg_set+0x18>
		stored_cfg.valid = false;
   13256:	702c      	strb	r4, [r5, #0]
}
   13258:	4620      	mov	r0, r4
   1325a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	err = mesh_x_set(read_cb, cb_arg, &stored_cfg.cfg,
   1325c:	2307      	movs	r3, #7
   1325e:	1c6a      	adds	r2, r5, #1
   13260:	4639      	mov	r1, r7
   13262:	4630      	mov	r0, r6
   13264:	f7ff fc12 	bl	12a8c <mesh_x_set>
	if (err) {
   13268:	4604      	mov	r4, r0
   1326a:	b150      	cbz	r0, 13282 <cfg_set+0x3e>
   1326c:	4b09      	ldr	r3, [pc, #36]	; (13294 <cfg_set+0x50>)
   1326e:	490a      	ldr	r1, [pc, #40]	; (13298 <cfg_set+0x54>)
		BT_ERR("Failed to set \'cfg\'");
   13270:	480a      	ldr	r0, [pc, #40]	; (1329c <cfg_set+0x58>)
   13272:	1ac9      	subs	r1, r1, r3
   13274:	08c9      	lsrs	r1, r1, #3
   13276:	0189      	lsls	r1, r1, #6
   13278:	f041 0101 	orr.w	r1, r1, #1
   1327c:	f010 fea2 	bl	23fc4 <log_0>
		return err;
   13280:	e7ea      	b.n	13258 <cfg_set+0x14>
	stored_cfg.valid = true;
   13282:	2301      	movs	r3, #1
   13284:	702b      	strb	r3, [r5, #0]
	return 0;
   13286:	e7e7      	b.n	13258 <cfg_set+0x14>
		return -ENOENT;
   13288:	f06f 0401 	mvn.w	r4, #1
   1328c:	e7e4      	b.n	13258 <cfg_set+0x14>
   1328e:	bf00      	nop
   13290:	200024bd 	.word	0x200024bd
   13294:	00029830 	.word	0x00029830
   13298:	00029980 	.word	0x00029980
   1329c:	0002e5a7 	.word	0x0002e5a7

000132a0 <net_set>:
{
   132a0:	b510      	push	{r4, lr}
   132a2:	460c      	mov	r4, r1
   132a4:	b086      	sub	sp, #24
   132a6:	4610      	mov	r0, r2
   132a8:	4619      	mov	r1, r3
	if (len_rd == 0) {
   132aa:	b94c      	cbnz	r4, 132c0 <net_set+0x20>
		bt_mesh_comp_unprovision();
   132ac:	f7fc fbf4 	bl	fa98 <bt_mesh_comp_unprovision>
		(void)memset(bt_mesh.dev_key, 0, sizeof(bt_mesh.dev_key));
   132b0:	4811      	ldr	r0, [pc, #68]	; (132f8 <net_set+0x58>)
   132b2:	2210      	movs	r2, #16
   132b4:	4621      	mov	r1, r4
   132b6:	f012 fd22 	bl	25cfe <memset>
}
   132ba:	4620      	mov	r0, r4
   132bc:	b006      	add	sp, #24
   132be:	bd10      	pop	{r4, pc}
	err = mesh_x_set(read_cb, cb_arg, &net, sizeof(net));
   132c0:	2312      	movs	r3, #18
   132c2:	aa01      	add	r2, sp, #4
   132c4:	f7ff fbe2 	bl	12a8c <mesh_x_set>
	if (err) {
   132c8:	4604      	mov	r4, r0
   132ca:	b150      	cbz	r0, 132e2 <net_set+0x42>
   132cc:	4b0b      	ldr	r3, [pc, #44]	; (132fc <net_set+0x5c>)
   132ce:	490c      	ldr	r1, [pc, #48]	; (13300 <net_set+0x60>)
		BT_ERR("Failed to set \'net\'");
   132d0:	480c      	ldr	r0, [pc, #48]	; (13304 <net_set+0x64>)
   132d2:	1ac9      	subs	r1, r1, r3
   132d4:	08c9      	lsrs	r1, r1, #3
   132d6:	0189      	lsls	r1, r1, #6
   132d8:	f041 0101 	orr.w	r1, r1, #1
   132dc:	f010 fe72 	bl	23fc4 <log_0>
		return err;
   132e0:	e7eb      	b.n	132ba <net_set+0x1a>
	memcpy(bt_mesh.dev_key, net.dev_key, sizeof(bt_mesh.dev_key));
   132e2:	2210      	movs	r2, #16
   132e4:	f10d 0106 	add.w	r1, sp, #6
   132e8:	4803      	ldr	r0, [pc, #12]	; (132f8 <net_set+0x58>)
   132ea:	f012 fcdd 	bl	25ca8 <memcpy>
	bt_mesh_comp_provision(net.primary_addr);
   132ee:	f8bd 0004 	ldrh.w	r0, [sp, #4]
   132f2:	f7fc fbbb 	bl	fa6c <bt_mesh_comp_provision>
	return 0;
   132f6:	e7e0      	b.n	132ba <net_set+0x1a>
   132f8:	20006c84 	.word	0x20006c84
   132fc:	00029830 	.word	0x00029830
   13300:	00029980 	.word	0x00029980
   13304:	0002e5bb 	.word	0x0002e5bb

00013308 <store_net_key>:
{
   13308:	b510      	push	{r4, lr}
   1330a:	b08e      	sub	sp, #56	; 0x38
   1330c:	4604      	mov	r4, r0
	memcpy(&key.val[0], sub->keys[0].net, 16);
   1330e:	f100 0130 	add.w	r1, r0, #48	; 0x30
   13312:	2210      	movs	r2, #16
   13314:	f10d 0015 	add.w	r0, sp, #21
   13318:	f012 fcc6 	bl	25ca8 <memcpy>
	memcpy(&key.val[1], sub->keys[1].net, 16);
   1331c:	2210      	movs	r2, #16
   1331e:	f104 0189 	add.w	r1, r4, #137	; 0x89
   13322:	f10d 0025 	add.w	r0, sp, #37	; 0x25
   13326:	f012 fcbf 	bl	25ca8 <memcpy>
	key.kr_flag = sub->kr_flag;
   1332a:	7fe2      	ldrb	r2, [r4, #31]
   1332c:	7fa3      	ldrb	r3, [r4, #30]
   1332e:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
   13332:	f88d 3014 	strb.w	r3, [sp, #20]
	snprintk(path, sizeof(path), "bt/mesh/NetKey/%x", sub->net_idx);
   13336:	4a0c      	ldr	r2, [pc, #48]	; (13368 <store_net_key+0x60>)
   13338:	8ba3      	ldrh	r3, [r4, #28]
   1333a:	2114      	movs	r1, #20
   1333c:	4668      	mov	r0, sp
   1333e:	f010 fddd 	bl	23efc <snprintk>
	err = settings_save_one(path, &key, sizeof(key));
   13342:	2221      	movs	r2, #33	; 0x21
   13344:	a905      	add	r1, sp, #20
   13346:	4668      	mov	r0, sp
   13348:	f7f0 fae8 	bl	391c <settings_save_one>
	if (err) {
   1334c:	b148      	cbz	r0, 13362 <store_net_key+0x5a>
   1334e:	4907      	ldr	r1, [pc, #28]	; (1336c <store_net_key+0x64>)
   13350:	4b07      	ldr	r3, [pc, #28]	; (13370 <store_net_key+0x68>)
		BT_ERR("Failed to store NetKey value");
   13352:	4808      	ldr	r0, [pc, #32]	; (13374 <store_net_key+0x6c>)
   13354:	1ac9      	subs	r1, r1, r3
   13356:	08c9      	lsrs	r1, r1, #3
   13358:	0189      	lsls	r1, r1, #6
   1335a:	f041 0101 	orr.w	r1, r1, #1
   1335e:	f010 fe31 	bl	23fc4 <log_0>
}
   13362:	b00e      	add	sp, #56	; 0x38
   13364:	bd10      	pop	{r4, pc}
   13366:	bf00      	nop
   13368:	0002e5cf 	.word	0x0002e5cf
   1336c:	00029980 	.word	0x00029980
   13370:	00029830 	.word	0x00029830
   13374:	0002e5e1 	.word	0x0002e5e1

00013378 <clear_net_key>:
{
   13378:	b510      	push	{r4, lr}
   1337a:	b086      	sub	sp, #24
	snprintk(path, sizeof(path), "bt/mesh/NetKey/%x", net_idx);
   1337c:	4603      	mov	r3, r0
   1337e:	4a0b      	ldr	r2, [pc, #44]	; (133ac <clear_net_key+0x34>)
{
   13380:	4604      	mov	r4, r0
	snprintk(path, sizeof(path), "bt/mesh/NetKey/%x", net_idx);
   13382:	2114      	movs	r1, #20
   13384:	a801      	add	r0, sp, #4
   13386:	f010 fdb9 	bl	23efc <snprintk>
	err = settings_delete(path);
   1338a:	a801      	add	r0, sp, #4
   1338c:	f011 f9d0 	bl	24730 <settings_delete>
	if (err) {
   13390:	b150      	cbz	r0, 133a8 <clear_net_key+0x30>
   13392:	4a07      	ldr	r2, [pc, #28]	; (133b0 <clear_net_key+0x38>)
   13394:	4b07      	ldr	r3, [pc, #28]	; (133b4 <clear_net_key+0x3c>)
		BT_ERR("Failed to clear NetKeyIndex 0x%03x", net_idx);
   13396:	4808      	ldr	r0, [pc, #32]	; (133b8 <clear_net_key+0x40>)
   13398:	1ad2      	subs	r2, r2, r3
   1339a:	08d2      	lsrs	r2, r2, #3
   1339c:	0192      	lsls	r2, r2, #6
   1339e:	f042 0201 	orr.w	r2, r2, #1
   133a2:	4621      	mov	r1, r4
   133a4:	f010 fe1b 	bl	23fde <log_1>
}
   133a8:	b006      	add	sp, #24
   133aa:	bd10      	pop	{r4, pc}
   133ac:	0002e5cf 	.word	0x0002e5cf
   133b0:	00029980 	.word	0x00029980
   133b4:	00029830 	.word	0x00029830
   133b8:	0002e5fe 	.word	0x0002e5fe

000133bc <clear_app_key>:
{
   133bc:	b510      	push	{r4, lr}
   133be:	b086      	sub	sp, #24
	snprintk(path, sizeof(path), "bt/mesh/AppKey/%x", app_idx);
   133c0:	4603      	mov	r3, r0
   133c2:	4a0b      	ldr	r2, [pc, #44]	; (133f0 <clear_app_key+0x34>)
{
   133c4:	4604      	mov	r4, r0
	snprintk(path, sizeof(path), "bt/mesh/AppKey/%x", app_idx);
   133c6:	2114      	movs	r1, #20
   133c8:	a801      	add	r0, sp, #4
   133ca:	f010 fd97 	bl	23efc <snprintk>
	err = settings_delete(path);
   133ce:	a801      	add	r0, sp, #4
   133d0:	f011 f9ae 	bl	24730 <settings_delete>
	if (err) {
   133d4:	b150      	cbz	r0, 133ec <clear_app_key+0x30>
   133d6:	4a07      	ldr	r2, [pc, #28]	; (133f4 <clear_app_key+0x38>)
   133d8:	4b07      	ldr	r3, [pc, #28]	; (133f8 <clear_app_key+0x3c>)
		BT_ERR("Failed to clear AppKeyIndex 0x%03x", app_idx);
   133da:	4808      	ldr	r0, [pc, #32]	; (133fc <clear_app_key+0x40>)
   133dc:	1ad2      	subs	r2, r2, r3
   133de:	08d2      	lsrs	r2, r2, #3
   133e0:	0192      	lsls	r2, r2, #6
   133e2:	f042 0201 	orr.w	r2, r2, #1
   133e6:	4621      	mov	r1, r4
   133e8:	f010 fdf9 	bl	23fde <log_1>
}
   133ec:	b006      	add	sp, #24
   133ee:	bd10      	pop	{r4, pc}
   133f0:	0002e4d3 	.word	0x0002e4d3
   133f4:	00029980 	.word	0x00029980
   133f8:	00029830 	.word	0x00029830
   133fc:	0002e621 	.word	0x0002e621

00013400 <encode_mod_path.constprop.0>:
static void encode_mod_path(struct bt_mesh_model *mod, bool vnd,
   13400:	b537      	push	{r0, r1, r2, r4, r5, lr}
   13402:	4604      	mov	r4, r0
   13404:	4618      	mov	r0, r3
	u16_t mod_key = (((u16_t)mod->elem_idx << 8) | mod->mod_idx);
   13406:	7925      	ldrb	r5, [r4, #4]
   13408:	7963      	ldrb	r3, [r4, #5]
		snprintk(path, path_len, "bt/mesh/v/%x/%s", mod_key, key);
   1340a:	9200      	str	r2, [sp, #0]
   1340c:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	if (vnd) {
   13410:	b129      	cbz	r1, 1341e <encode_mod_path.constprop.0+0x1e>
		snprintk(path, path_len, "bt/mesh/v/%x/%s", mod_key, key);
   13412:	4a04      	ldr	r2, [pc, #16]	; (13424 <encode_mod_path.constprop.0+0x24>)
		snprintk(path, path_len, "bt/mesh/s/%x/%s", mod_key, key);
   13414:	2114      	movs	r1, #20
   13416:	f010 fd71 	bl	23efc <snprintk>
}
   1341a:	b003      	add	sp, #12
   1341c:	bd30      	pop	{r4, r5, pc}
		snprintk(path, path_len, "bt/mesh/s/%x/%s", mod_key, key);
   1341e:	4a02      	ldr	r2, [pc, #8]	; (13428 <encode_mod_path.constprop.0+0x28>)
   13420:	e7f8      	b.n	13414 <encode_mod_path.constprop.0+0x14>
   13422:	bf00      	nop
   13424:	0002e644 	.word	0x0002e644
   13428:	0002e654 	.word	0x0002e654

0001342c <store_pending_mod>:
{
   1342c:	b570      	push	{r4, r5, r6, lr}
	if (!mod->flags) {
   1342e:	88c3      	ldrh	r3, [r0, #6]
{
   13430:	b088      	sub	sp, #32
   13432:	4604      	mov	r4, r0
   13434:	4616      	mov	r6, r2
	if (!mod->flags) {
   13436:	2b00      	cmp	r3, #0
   13438:	f000 8089 	beq.w	1354e <store_pending_mod+0x122>
	if (mod->flags & BT_MESH_MOD_BIND_PENDING) {
   1343c:	07d8      	lsls	r0, r3, #31
   1343e:	d533      	bpl.n	134a8 <store_pending_mod+0x7c>
		if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   13440:	89a2      	ldrh	r2, [r4, #12]
		mod->flags &= ~BT_MESH_MOD_BIND_PENDING;
   13442:	f023 0301 	bic.w	r3, r3, #1
   13446:	80e3      	strh	r3, [r4, #6]
		if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   13448:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1344c:	429a      	cmp	r2, r3
			keys[count++] = mod->keys[i];
   1344e:	bf18      	it	ne
   13450:	f8ad 2004 	strhne.w	r2, [sp, #4]
		if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   13454:	89e2      	ldrh	r2, [r4, #14]
			keys[count++] = mod->keys[i];
   13456:	bf14      	ite	ne
   13458:	2501      	movne	r5, #1
	for (i = 0, count = 0; i < ARRAY_SIZE(mod->keys); i++) {
   1345a:	2500      	moveq	r5, #0
		if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   1345c:	429a      	cmp	r2, r3
			keys[count++] = mod->keys[i];
   1345e:	bf1c      	itt	ne
   13460:	ab08      	addne	r3, sp, #32
   13462:	eb03 0345 	addne.w	r3, r3, r5, lsl #1
	encode_mod_path(mod, vnd, "bind", path, sizeof(path));
   13466:	4631      	mov	r1, r6
			keys[count++] = mod->keys[i];
   13468:	bf1c      	itt	ne
   1346a:	f823 2c1c 	strhne.w	r2, [r3, #-28]
   1346e:	3501      	addne	r5, #1
	encode_mod_path(mod, vnd, "bind", path, sizeof(path));
   13470:	4a4b      	ldr	r2, [pc, #300]	; (135a0 <store_pending_mod+0x174>)
   13472:	ab03      	add	r3, sp, #12
   13474:	4620      	mov	r0, r4
   13476:	f7ff ffc3 	bl	13400 <encode_mod_path.constprop.0>
	if (count) {
   1347a:	2d00      	cmp	r5, #0
   1347c:	d069      	beq.n	13552 <store_pending_mod+0x126>
		err = settings_save_one(path, keys, count * sizeof(keys[0]));
   1347e:	006a      	lsls	r2, r5, #1
   13480:	a901      	add	r1, sp, #4
   13482:	a803      	add	r0, sp, #12
   13484:	f7f0 fa4a 	bl	391c <settings_save_one>
	if (err) {
   13488:	b170      	cbz	r0, 134a8 <store_pending_mod+0x7c>
   1348a:	4a46      	ldr	r2, [pc, #280]	; (135a4 <store_pending_mod+0x178>)
   1348c:	4d46      	ldr	r5, [pc, #280]	; (135a8 <store_pending_mod+0x17c>)
		BT_ERR("Failed to store %s value", log_strdup(path));
   1348e:	a803      	add	r0, sp, #12
   13490:	1aad      	subs	r5, r5, r2
   13492:	08ed      	lsrs	r5, r5, #3
   13494:	f7ef f8a4 	bl	25e0 <log_strdup>
   13498:	01ad      	lsls	r5, r5, #6
   1349a:	f045 0501 	orr.w	r5, r5, #1
   1349e:	4601      	mov	r1, r0
   134a0:	462a      	mov	r2, r5
   134a2:	4842      	ldr	r0, [pc, #264]	; (135ac <store_pending_mod+0x180>)
   134a4:	f010 fd9b 	bl	23fde <log_1>
	if (mod->flags & BT_MESH_MOD_SUB_PENDING) {
   134a8:	88e3      	ldrh	r3, [r4, #6]
   134aa:	0799      	lsls	r1, r3, #30
   134ac:	d52c      	bpl.n	13508 <store_pending_mod+0xdc>
		if (mod->groups[i] != BT_MESH_ADDR_UNASSIGNED) {
   134ae:	8a25      	ldrh	r5, [r4, #16]
		mod->flags &= ~BT_MESH_MOD_SUB_PENDING;
   134b0:	f023 0302 	bic.w	r3, r3, #2
   134b4:	80e3      	strh	r3, [r4, #6]
		if (mod->groups[i] != BT_MESH_ADDR_UNASSIGNED) {
   134b6:	b115      	cbz	r5, 134be <store_pending_mod+0x92>
			groups[count++] = mod->groups[i];
   134b8:	f8ad 5004 	strh.w	r5, [sp, #4]
   134bc:	2501      	movs	r5, #1
		if (mod->groups[i] != BT_MESH_ADDR_UNASSIGNED) {
   134be:	8a63      	ldrh	r3, [r4, #18]
   134c0:	b12b      	cbz	r3, 134ce <store_pending_mod+0xa2>
			groups[count++] = mod->groups[i];
   134c2:	aa08      	add	r2, sp, #32
   134c4:	eb02 0245 	add.w	r2, r2, r5, lsl #1
   134c8:	3501      	adds	r5, #1
   134ca:	f822 3c1c 	strh.w	r3, [r2, #-28]
	encode_mod_path(mod, vnd, "sub", path, sizeof(path));
   134ce:	4a38      	ldr	r2, [pc, #224]	; (135b0 <store_pending_mod+0x184>)
   134d0:	ab03      	add	r3, sp, #12
   134d2:	4631      	mov	r1, r6
   134d4:	4620      	mov	r0, r4
   134d6:	f7ff ff93 	bl	13400 <encode_mod_path.constprop.0>
	if (count) {
   134da:	2d00      	cmp	r5, #0
   134dc:	d03d      	beq.n	1355a <store_pending_mod+0x12e>
		err = settings_save_one(path, groups,
   134de:	006a      	lsls	r2, r5, #1
   134e0:	a901      	add	r1, sp, #4
   134e2:	a803      	add	r0, sp, #12
   134e4:	f7f0 fa1a 	bl	391c <settings_save_one>
	if (err) {
   134e8:	b170      	cbz	r0, 13508 <store_pending_mod+0xdc>
   134ea:	4a2e      	ldr	r2, [pc, #184]	; (135a4 <store_pending_mod+0x178>)
   134ec:	4d2e      	ldr	r5, [pc, #184]	; (135a8 <store_pending_mod+0x17c>)
		BT_ERR("Failed to store %s value", log_strdup(path));
   134ee:	a803      	add	r0, sp, #12
   134f0:	1aad      	subs	r5, r5, r2
   134f2:	08ed      	lsrs	r5, r5, #3
   134f4:	f7ef f874 	bl	25e0 <log_strdup>
   134f8:	01ad      	lsls	r5, r5, #6
   134fa:	f045 0501 	orr.w	r5, r5, #1
   134fe:	4601      	mov	r1, r0
   13500:	462a      	mov	r2, r5
   13502:	482a      	ldr	r0, [pc, #168]	; (135ac <store_pending_mod+0x180>)
   13504:	f010 fd6b 	bl	23fde <log_1>
	if (mod->flags & BT_MESH_MOD_PUB_PENDING) {
   13508:	88e3      	ldrh	r3, [r4, #6]
   1350a:	075a      	lsls	r2, r3, #29
   1350c:	d51f      	bpl.n	1354e <store_pending_mod+0x122>
		mod->flags &= ~BT_MESH_MOD_PUB_PENDING;
   1350e:	f023 0304 	bic.w	r3, r3, #4
   13512:	80e3      	strh	r3, [r4, #6]
	encode_mod_path(mod, vnd, "pub", path, sizeof(path));
   13514:	4a27      	ldr	r2, [pc, #156]	; (135b4 <store_pending_mod+0x188>)
   13516:	ab03      	add	r3, sp, #12
   13518:	4631      	mov	r1, r6
   1351a:	4620      	mov	r0, r4
   1351c:	f7ff ff70 	bl	13400 <encode_mod_path.constprop.0>
	if (!mod->pub || mod->pub->addr == BT_MESH_ADDR_UNASSIGNED) {
   13520:	68a3      	ldr	r3, [r4, #8]
   13522:	b10b      	cbz	r3, 13528 <store_pending_mod+0xfc>
   13524:	889a      	ldrh	r2, [r3, #4]
   13526:	b9e2      	cbnz	r2, 13562 <store_pending_mod+0x136>
		err = settings_delete(path);
   13528:	a803      	add	r0, sp, #12
   1352a:	f011 f901 	bl	24730 <settings_delete>
	if (err) {
   1352e:	b170      	cbz	r0, 1354e <store_pending_mod+0x122>
   13530:	4a1c      	ldr	r2, [pc, #112]	; (135a4 <store_pending_mod+0x178>)
   13532:	4c1d      	ldr	r4, [pc, #116]	; (135a8 <store_pending_mod+0x17c>)
		BT_ERR("Failed to store %s value", log_strdup(path));
   13534:	a803      	add	r0, sp, #12
   13536:	1aa4      	subs	r4, r4, r2
   13538:	08e4      	lsrs	r4, r4, #3
   1353a:	f7ef f851 	bl	25e0 <log_strdup>
   1353e:	01a4      	lsls	r4, r4, #6
   13540:	f044 0401 	orr.w	r4, r4, #1
   13544:	4601      	mov	r1, r0
   13546:	4622      	mov	r2, r4
   13548:	4818      	ldr	r0, [pc, #96]	; (135ac <store_pending_mod+0x180>)
   1354a:	f010 fd48 	bl	23fde <log_1>
}
   1354e:	b008      	add	sp, #32
   13550:	bd70      	pop	{r4, r5, r6, pc}
		err = settings_delete(path);
   13552:	a803      	add	r0, sp, #12
   13554:	f011 f8ec 	bl	24730 <settings_delete>
   13558:	e796      	b.n	13488 <store_pending_mod+0x5c>
		err = settings_delete(path);
   1355a:	a803      	add	r0, sp, #12
   1355c:	f011 f8e8 	bl	24730 <settings_delete>
   13560:	e7c2      	b.n	134e8 <store_pending_mod+0xbc>
		pub.addr = mod->pub->addr;
   13562:	f8ad 2004 	strh.w	r2, [sp, #4]
		pub.key = mod->pub->key;
   13566:	88da      	ldrh	r2, [r3, #6]
   13568:	f3c2 020b 	ubfx	r2, r2, #0, #12
   1356c:	f8ad 2006 	strh.w	r2, [sp, #6]
		pub.ttl = mod->pub->ttl;
   13570:	6899      	ldr	r1, [r3, #8]
   13572:	9a02      	ldr	r2, [sp, #8]
   13574:	f021 4170 	bic.w	r1, r1, #4026531840	; 0xf0000000
   13578:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
   1357c:	430a      	orrs	r2, r1
   1357e:	9202      	str	r2, [sp, #8]
		pub.cred = mod->pub->cred;
   13580:	79db      	ldrb	r3, [r3, #7]
   13582:	f89d 200b 	ldrb.w	r2, [sp, #11]
   13586:	f3c3 1300 	ubfx	r3, r3, #4, #1
   1358a:	f363 1204 	bfi	r2, r3, #4, #1
   1358e:	f88d 200b 	strb.w	r2, [sp, #11]
		err = settings_save_one(path, &pub, sizeof(pub));
   13592:	a901      	add	r1, sp, #4
   13594:	2208      	movs	r2, #8
   13596:	a803      	add	r0, sp, #12
   13598:	f7f0 f9c0 	bl	391c <settings_save_one>
   1359c:	e7c7      	b.n	1352e <store_pending_mod+0x102>
   1359e:	bf00      	nop
   135a0:	0002e534 	.word	0x0002e534
   135a4:	00029830 	.word	0x00029830
   135a8:	00029980 	.word	0x00029980
   135ac:	0002e664 	.word	0x0002e664
   135b0:	0002e539 	.word	0x0002e539
   135b4:	0002e53d 	.word	0x0002e53d

000135b8 <store_pending>:
{
   135b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_RPL_PENDING)) {
   135bc:	48b4      	ldr	r0, [pc, #720]	; (13890 <store_pending+0x2d8>)
   135be:	4db4      	ldr	r5, [pc, #720]	; (13890 <store_pending+0x2d8>)
{
   135c0:	b08c      	sub	sp, #48	; 0x30
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_RPL_PENDING)) {
   135c2:	2106      	movs	r1, #6
   135c4:	f014 faee 	bl	27ba4 <atomic_test_and_clear_bit>
   135c8:	2800      	cmp	r0, #0
   135ca:	f040 80fb 	bne.w	137c4 <store_pending+0x20c>
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_KEYS_PENDING)) {
   135ce:	48b0      	ldr	r0, [pc, #704]	; (13890 <store_pending+0x2d8>)
   135d0:	2107      	movs	r1, #7
   135d2:	f014 fae7 	bl	27ba4 <atomic_test_and_clear_bit>
   135d6:	b338      	cbz	r0, 13628 <store_pending+0x70>
   135d8:	4eae      	ldr	r6, [pc, #696]	; (13894 <store_pending+0x2dc>)
   135da:	4baf      	ldr	r3, [pc, #700]	; (13898 <store_pending+0x2e0>)
		if (!update->valid) {
   135dc:	4faf      	ldr	r7, [pc, #700]	; (1389c <store_pending+0x2e4>)
					BT_WARN("NetKeyIndex 0x%03x not found",
   135de:	f8df a2fc 	ldr.w	sl, [pc, #764]	; 138dc <store_pending+0x324>
   135e2:	1af6      	subs	r6, r6, r3
   135e4:	08f6      	lsrs	r6, r6, #3
	for (i = 0; i < ARRAY_SIZE(key_updates); i++) {
   135e6:	2400      	movs	r4, #0
   135e8:	46b9      	mov	r9, r7
		if (!update->valid) {
   135ea:	eb07 0344 	add.w	r3, r7, r4, lsl #1
   135ee:	ea4f 0844 	mov.w	r8, r4, lsl #1
   135f2:	785b      	ldrb	r3, [r3, #1]
   135f4:	06da      	lsls	r2, r3, #27
   135f6:	d514      	bpl.n	13622 <store_pending+0x6a>
		if (update->clear) {
   135f8:	f837 0014 	ldrh.w	r0, [r7, r4, lsl #1]
   135fc:	f003 0220 	and.w	r2, r3, #32
   13600:	065b      	lsls	r3, r3, #25
   13602:	f3c0 000b 	ubfx	r0, r0, #0, #12
   13606:	f140 8172 	bpl.w	138ee <store_pending+0x336>
			if (update->app_key) {
   1360a:	2a00      	cmp	r2, #0
   1360c:	f000 816c 	beq.w	138e8 <store_pending+0x330>
				clear_app_key(update->key_idx);
   13610:	f7ff fed4 	bl	133bc <clear_app_key>
		update->valid = 0U;
   13614:	44c8      	add	r8, r9
   13616:	f898 3001 	ldrb.w	r3, [r8, #1]
   1361a:	f36f 1304 	bfc	r3, #4, #1
   1361e:	f888 3001 	strb.w	r3, [r8, #1]
	for (i = 0; i < ARRAY_SIZE(key_updates); i++) {
   13622:	3401      	adds	r4, #1
   13624:	2c04      	cmp	r4, #4
   13626:	d1e0      	bne.n	135ea <store_pending+0x32>
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_NET_PENDING)) {
   13628:	4899      	ldr	r0, [pc, #612]	; (13890 <store_pending+0x2d8>)
   1362a:	2108      	movs	r1, #8
   1362c:	f014 faba 	bl	27ba4 <atomic_test_and_clear_bit>
   13630:	b1f8      	cbz	r0, 13672 <store_pending+0xba>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   13632:	4897      	ldr	r0, [pc, #604]	; (13890 <store_pending+0x2d8>)
   13634:	f014 fa9a 	bl	27b6c <atomic_get>
		if (atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
   13638:	07c7      	lsls	r7, r0, #31
   1363a:	f140 8179 	bpl.w	13930 <store_pending+0x378>
	net.primary_addr = bt_mesh_primary_addr();
   1363e:	f7fc fa35 	bl	faac <bt_mesh_primary_addr>
	memcpy(net.dev_key, bt_mesh.dev_key, 16);
   13642:	4997      	ldr	r1, [pc, #604]	; (138a0 <store_pending+0x2e8>)
	net.primary_addr = bt_mesh_primary_addr();
   13644:	f8ad 001c 	strh.w	r0, [sp, #28]
	memcpy(net.dev_key, bt_mesh.dev_key, 16);
   13648:	2210      	movs	r2, #16
   1364a:	f10d 001e 	add.w	r0, sp, #30
   1364e:	f012 fb2b 	bl	25ca8 <memcpy>
	err = settings_save_one("bt/mesh/Net", &net, sizeof(net));
   13652:	4894      	ldr	r0, [pc, #592]	; (138a4 <store_pending+0x2ec>)
   13654:	2212      	movs	r2, #18
   13656:	a907      	add	r1, sp, #28
   13658:	f7f0 f960 	bl	391c <settings_save_one>
	if (err) {
   1365c:	b148      	cbz	r0, 13672 <store_pending+0xba>
   1365e:	498d      	ldr	r1, [pc, #564]	; (13894 <store_pending+0x2dc>)
   13660:	4b8d      	ldr	r3, [pc, #564]	; (13898 <store_pending+0x2e0>)
		BT_ERR("Failed to store Network value");
   13662:	4891      	ldr	r0, [pc, #580]	; (138a8 <store_pending+0x2f0>)
   13664:	1ac9      	subs	r1, r1, r3
   13666:	08c9      	lsrs	r1, r1, #3
   13668:	0189      	lsls	r1, r1, #6
   1366a:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Failed to clear Network");
   1366e:	f010 fca9 	bl	23fc4 <log_0>
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_IV_PENDING)) {
   13672:	4887      	ldr	r0, [pc, #540]	; (13890 <store_pending+0x2d8>)
   13674:	2109      	movs	r1, #9
   13676:	f014 fa95 	bl	27ba4 <atomic_test_and_clear_bit>
   1367a:	b328      	cbz	r0, 136c8 <store_pending+0x110>
   1367c:	4884      	ldr	r0, [pc, #528]	; (13890 <store_pending+0x2d8>)
   1367e:	f014 fa75 	bl	27b6c <atomic_get>
		if (atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
   13682:	07c6      	lsls	r6, r0, #31
   13684:	f140 8163 	bpl.w	1394e <store_pending+0x396>
	iv.iv_index = bt_mesh.iv_index;
   13688:	4b88      	ldr	r3, [pc, #544]	; (138ac <store_pending+0x2f4>)
   1368a:	f855 2c08 	ldr.w	r2, [r5, #-8]
   1368e:	9207      	str	r2, [sp, #28]
   13690:	f103 0008 	add.w	r0, r3, #8
   13694:	f014 fa6a 	bl	27b6c <atomic_get>
	iv.iv_update = atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS);
   13698:	f893 3118 	ldrb.w	r3, [r3, #280]	; 0x118
   1369c:	f3c0 0080 	ubfx	r0, r0, #2, #1
   136a0:	ea40 0043 	orr.w	r0, r0, r3, lsl #1
   136a4:	f88d 0020 	strb.w	r0, [sp, #32]
	err = settings_save_one("bt/mesh/IV", &iv, sizeof(iv));
   136a8:	2205      	movs	r2, #5
   136aa:	4881      	ldr	r0, [pc, #516]	; (138b0 <store_pending+0x2f8>)
   136ac:	a907      	add	r1, sp, #28
   136ae:	f7f0 f935 	bl	391c <settings_save_one>
	if (err) {
   136b2:	b148      	cbz	r0, 136c8 <store_pending+0x110>
   136b4:	4977      	ldr	r1, [pc, #476]	; (13894 <store_pending+0x2dc>)
   136b6:	4b78      	ldr	r3, [pc, #480]	; (13898 <store_pending+0x2e0>)
		BT_ERR("Failed to store IV value");
   136b8:	487e      	ldr	r0, [pc, #504]	; (138b4 <store_pending+0x2fc>)
   136ba:	1ac9      	subs	r1, r1, r3
   136bc:	08c9      	lsrs	r1, r1, #3
   136be:	0189      	lsls	r1, r1, #6
   136c0:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Failed to clear IV");
   136c4:	f010 fc7e 	bl	23fc4 <log_0>
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_SEQ_PENDING)) {
   136c8:	4871      	ldr	r0, [pc, #452]	; (13890 <store_pending+0x2d8>)
   136ca:	210a      	movs	r1, #10
   136cc:	f014 fa6a 	bl	27ba4 <atomic_test_and_clear_bit>
   136d0:	b1b0      	cbz	r0, 13700 <store_pending+0x148>
	sys_put_le24(bt_mesh.seq, seq.val);
   136d2:	4b76      	ldr	r3, [pc, #472]	; (138ac <store_pending+0x2f4>)
	err = settings_save_one("bt/mesh/Seq", &seq, sizeof(seq));
   136d4:	4878      	ldr	r0, [pc, #480]	; (138b8 <store_pending+0x300>)
	dst[0] = val;
   136d6:	889a      	ldrh	r2, [r3, #4]
   136d8:	f8ad 201c 	strh.w	r2, [sp, #28]
	dst[2] = val >> 16;
   136dc:	88db      	ldrh	r3, [r3, #6]
   136de:	f88d 301e 	strb.w	r3, [sp, #30]
   136e2:	2203      	movs	r2, #3
   136e4:	a907      	add	r1, sp, #28
   136e6:	f7f0 f919 	bl	391c <settings_save_one>
	if (err) {
   136ea:	b148      	cbz	r0, 13700 <store_pending+0x148>
   136ec:	4969      	ldr	r1, [pc, #420]	; (13894 <store_pending+0x2dc>)
   136ee:	4b6a      	ldr	r3, [pc, #424]	; (13898 <store_pending+0x2e0>)
		BT_ERR("Failed to stor Seq value");
   136f0:	4872      	ldr	r0, [pc, #456]	; (138bc <store_pending+0x304>)
   136f2:	1ac9      	subs	r1, r1, r3
   136f4:	08c9      	lsrs	r1, r1, #3
   136f6:	0189      	lsls	r1, r1, #6
   136f8:	f041 0101 	orr.w	r1, r1, #1
   136fc:	f010 fc62 	bl	23fc4 <log_0>
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_HB_PUB_PENDING)) {
   13700:	4863      	ldr	r0, [pc, #396]	; (13890 <store_pending+0x2d8>)
   13702:	210b      	movs	r1, #11
   13704:	f014 fa4e 	bl	27ba4 <atomic_test_and_clear_bit>
   13708:	b1a0      	cbz	r0, 13734 <store_pending+0x17c>
	struct bt_mesh_hb_pub *pub = bt_mesh_hb_pub_get();
   1370a:	f7ff f8a5 	bl	12858 <bt_mesh_hb_pub_get>
	if (!pub) {
   1370e:	b188      	cbz	r0, 13734 <store_pending+0x17c>
	if (pub->dst == BT_MESH_ADDR_UNASSIGNED) {
   13710:	8c01      	ldrh	r1, [r0, #32]
   13712:	2900      	cmp	r1, #0
   13714:	f040 812a 	bne.w	1396c <store_pending+0x3b4>
		err = settings_delete("bt/mesh/HBPub");
   13718:	4869      	ldr	r0, [pc, #420]	; (138c0 <store_pending+0x308>)
   1371a:	f011 f809 	bl	24730 <settings_delete>
	if (err) {
   1371e:	b148      	cbz	r0, 13734 <store_pending+0x17c>
   13720:	495c      	ldr	r1, [pc, #368]	; (13894 <store_pending+0x2dc>)
   13722:	4b5d      	ldr	r3, [pc, #372]	; (13898 <store_pending+0x2e0>)
		BT_ERR("Failed to store Heartbeat Publication");
   13724:	4867      	ldr	r0, [pc, #412]	; (138c4 <store_pending+0x30c>)
   13726:	1ac9      	subs	r1, r1, r3
   13728:	08c9      	lsrs	r1, r1, #3
   1372a:	0189      	lsls	r1, r1, #6
   1372c:	f041 0101 	orr.w	r1, r1, #1
   13730:	f010 fc48 	bl	23fc4 <log_0>
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_CFG_PENDING)) {
   13734:	4856      	ldr	r0, [pc, #344]	; (13890 <store_pending+0x2d8>)
   13736:	210c      	movs	r1, #12
   13738:	f014 fa34 	bl	27ba4 <atomic_test_and_clear_bit>
   1373c:	b300      	cbz	r0, 13780 <store_pending+0x1c8>
   1373e:	4854      	ldr	r0, [pc, #336]	; (13890 <store_pending+0x2d8>)
   13740:	f014 fa14 	bl	27b6c <atomic_get>
		if (atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
   13744:	07c3      	lsls	r3, r0, #31
   13746:	f140 8131 	bpl.w	139ac <store_pending+0x3f4>
	struct bt_mesh_cfg_srv *cfg = bt_mesh_cfg_get();
   1374a:	f7ff f88d 	bl	12868 <bt_mesh_cfg_get>
	if (!cfg) {
   1374e:	b1b8      	cbz	r0, 13780 <store_pending+0x1c8>
	val.net_transmit = cfg->net_transmit;
   13750:	6843      	ldr	r3, [r0, #4]
   13752:	9307      	str	r3, [sp, #28]
	val.gatt_proxy = cfg->gatt_proxy;
   13754:	8902      	ldrh	r2, [r0, #8]
	val.default_ttl = cfg->default_ttl;
   13756:	7a83      	ldrb	r3, [r0, #10]
	val.gatt_proxy = cfg->gatt_proxy;
   13758:	f8ad 2020 	strh.w	r2, [sp, #32]
	err = settings_save_one("bt/mesh/Cfg", &val, sizeof(val));
   1375c:	485a      	ldr	r0, [pc, #360]	; (138c8 <store_pending+0x310>)
	val.default_ttl = cfg->default_ttl;
   1375e:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
	err = settings_save_one("bt/mesh/Cfg", &val, sizeof(val));
   13762:	2207      	movs	r2, #7
   13764:	a907      	add	r1, sp, #28
   13766:	f7f0 f8d9 	bl	391c <settings_save_one>
	if (err) {
   1376a:	b148      	cbz	r0, 13780 <store_pending+0x1c8>
   1376c:	4949      	ldr	r1, [pc, #292]	; (13894 <store_pending+0x2dc>)
   1376e:	4b4a      	ldr	r3, [pc, #296]	; (13898 <store_pending+0x2e0>)
		BT_ERR("Failed to store configuration value");
   13770:	4856      	ldr	r0, [pc, #344]	; (138cc <store_pending+0x314>)
   13772:	1ac9      	subs	r1, r1, r3
   13774:	08c9      	lsrs	r1, r1, #3
   13776:	0189      	lsls	r1, r1, #6
   13778:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Failed to clear configuration");
   1377c:	f010 fc22 	bl	23fc4 <log_0>
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_MOD_PENDING)) {
   13780:	4843      	ldr	r0, [pc, #268]	; (13890 <store_pending+0x2d8>)
   13782:	210d      	movs	r1, #13
   13784:	f014 fa0e 	bl	27ba4 <atomic_test_and_clear_bit>
   13788:	b118      	cbz	r0, 13792 <store_pending+0x1da>
		bt_mesh_model_foreach(store_pending_mod, NULL);
   1378a:	4851      	ldr	r0, [pc, #324]	; (138d0 <store_pending+0x318>)
   1378c:	2100      	movs	r1, #0
   1378e:	f7fc f877 	bl	f880 <bt_mesh_model_foreach>
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_VA_PENDING)) {
   13792:	483f      	ldr	r0, [pc, #252]	; (13890 <store_pending+0x2d8>)
   13794:	210e      	movs	r1, #14
   13796:	f014 fa05 	bl	27ba4 <atomic_test_and_clear_bit>
   1379a:	b180      	cbz	r0, 137be <store_pending+0x206>
   1379c:	4c3d      	ldr	r4, [pc, #244]	; (13894 <store_pending+0x2dc>)
   1379e:	4b3e      	ldr	r3, [pc, #248]	; (13898 <store_pending+0x2e0>)
		snprintk(path, sizeof(path), "bt/mesh/Va/%x", i);
   137a0:	f8df 813c 	ldr.w	r8, [pc, #316]	; 138e0 <store_pending+0x328>
   137a4:	1ae4      	subs	r4, r4, r3
   137a6:	08e4      	lsrs	r4, r4, #3
			BT_ERR("Failed to %s %s value (err %d)",
   137a8:	01a4      	lsls	r4, r4, #6
   137aa:	2700      	movs	r7, #0
   137ac:	f044 0401 	orr.w	r4, r4, #1
	for (i = 0; (lab = get_label(i)) != NULL; i++) {
   137b0:	b2b8      	uxth	r0, r7
   137b2:	f7fe fcb3 	bl	1211c <get_label>
   137b6:	4605      	mov	r5, r0
   137b8:	2800      	cmp	r0, #0
   137ba:	f040 8106 	bne.w	139ca <store_pending+0x412>
}
   137be:	b00c      	add	sp, #48	; 0x30
   137c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   137c4:	4628      	mov	r0, r5
   137c6:	f014 f9d1 	bl	27b6c <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   137ca:	4b32      	ldr	r3, [pc, #200]	; (13894 <store_pending+0x2dc>)
   137cc:	4a32      	ldr	r2, [pc, #200]	; (13898 <store_pending+0x2e0>)
		if (atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
   137ce:	f010 0601 	ands.w	r6, r0, #1
   137d2:	eba3 0302 	sub.w	r3, r3, r2
   137d6:	ea4f 03d3 	mov.w	r3, r3, lsr #3
   137da:	d036      	beq.n	1384a <store_pending+0x292>
		BT_ERR("Failed to store RPL %s value", log_strdup(path));
   137dc:	019b      	lsls	r3, r3, #6
	snprintk(path, sizeof(path), "bt/mesh/RPL/%x", entry->src);
   137de:	f8df 8104 	ldr.w	r8, [pc, #260]	; 138e4 <store_pending+0x32c>
   137e2:	f1a5 0608 	sub.w	r6, r5, #8
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
   137e6:	2700      	movs	r7, #0
		BT_ERR("Failed to store RPL %s value", log_strdup(path));
   137e8:	f043 0401 	orr.w	r4, r3, #1
		if (rpl->store) {
   137ec:	f896 3367 	ldrb.w	r3, [r6, #871]	; 0x367
   137f0:	b32b      	cbz	r3, 1383e <store_pending+0x286>
			rpl->store = false;
   137f2:	2300      	movs	r3, #0
   137f4:	f886 3367 	strb.w	r3, [r6, #871]	; 0x367
	rpl.seq = entry->seq;
   137f8:	9b02      	ldr	r3, [sp, #8]
   137fa:	f8d6 2368 	ldr.w	r2, [r6, #872]	; 0x368
   137fe:	f362 0317 	bfi	r3, r2, #0, #24
   13802:	9302      	str	r3, [sp, #8]
	rpl.old_iv = entry->old_iv;
   13804:	f896 2366 	ldrb.w	r2, [r6, #870]	; 0x366
   13808:	f3c3 6307 	ubfx	r3, r3, #24, #8
   1380c:	f362 0300 	bfi	r3, r2, #0, #1
   13810:	f88d 300b 	strb.w	r3, [sp, #11]
	snprintk(path, sizeof(path), "bt/mesh/RPL/%x", entry->src);
   13814:	4642      	mov	r2, r8
   13816:	2112      	movs	r1, #18
   13818:	f8b6 3364 	ldrh.w	r3, [r6, #868]	; 0x364
   1381c:	a807      	add	r0, sp, #28
   1381e:	f010 fb6d 	bl	23efc <snprintk>
	err = settings_save_one(path, &rpl, sizeof(rpl));
   13822:	2204      	movs	r2, #4
   13824:	a902      	add	r1, sp, #8
   13826:	a807      	add	r0, sp, #28
   13828:	f7f0 f878 	bl	391c <settings_save_one>
	if (err) {
   1382c:	b138      	cbz	r0, 1383e <store_pending+0x286>
		BT_ERR("Failed to store RPL %s value", log_strdup(path));
   1382e:	a807      	add	r0, sp, #28
   13830:	f7ee fed6 	bl	25e0 <log_strdup>
   13834:	4622      	mov	r2, r4
   13836:	4601      	mov	r1, r0
   13838:	4826      	ldr	r0, [pc, #152]	; (138d4 <store_pending+0x31c>)
   1383a:	f010 fbd0 	bl	23fde <log_1>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
   1383e:	3701      	adds	r7, #1
   13840:	2f0a      	cmp	r7, #10
   13842:	f106 0608 	add.w	r6, r6, #8
   13846:	d1d1      	bne.n	137ec <store_pending+0x234>
   13848:	e6c1      	b.n	135ce <store_pending+0x16>
			BT_ERR("Failed to clear RPL");
   1384a:	019b      	lsls	r3, r3, #6
		snprintk(path, sizeof(path), "bt/mesh/RPL/%x", rpl->src);
   1384c:	f8df 8094 	ldr.w	r8, [pc, #148]	; 138e4 <store_pending+0x32c>
   13850:	f1a5 0708 	sub.w	r7, r5, #8
			BT_ERR("Failed to clear RPL");
   13854:	f043 0401 	orr.w	r4, r3, #1
		if (!rpl->src) {
   13858:	f8b7 3364 	ldrh.w	r3, [r7, #868]	; 0x364
   1385c:	b193      	cbz	r3, 13884 <store_pending+0x2cc>
		snprintk(path, sizeof(path), "bt/mesh/RPL/%x", rpl->src);
   1385e:	4642      	mov	r2, r8
   13860:	2112      	movs	r1, #18
   13862:	a807      	add	r0, sp, #28
   13864:	f010 fb4a 	bl	23efc <snprintk>
		err = settings_delete(path);
   13868:	a807      	add	r0, sp, #28
   1386a:	f010 ff61 	bl	24730 <settings_delete>
		if (err) {
   1386e:	b118      	cbz	r0, 13878 <store_pending+0x2c0>
			BT_ERR("Failed to clear RPL");
   13870:	4819      	ldr	r0, [pc, #100]	; (138d8 <store_pending+0x320>)
   13872:	4621      	mov	r1, r4
   13874:	f010 fba6 	bl	23fc4 <log_0>
		(void)memset(rpl, 0, sizeof(*rpl));
   13878:	2208      	movs	r2, #8
   1387a:	2100      	movs	r1, #0
   1387c:	f507 7059 	add.w	r0, r7, #868	; 0x364
   13880:	f012 fa3d 	bl	25cfe <memset>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.rpl); i++) {
   13884:	3601      	adds	r6, #1
   13886:	2e0a      	cmp	r6, #10
   13888:	f107 0708 	add.w	r7, r7, #8
   1388c:	d1e4      	bne.n	13858 <store_pending+0x2a0>
   1388e:	e69e      	b.n	135ce <store_pending+0x16>
   13890:	20006b50 	.word	0x20006b50
   13894:	00029980 	.word	0x00029980
   13898:	00029830 	.word	0x00029830
   1389c:	20001f24 	.word	0x20001f24
   138a0:	20006c84 	.word	0x20006c84
   138a4:	0002e6f7 	.word	0x0002e6f7
   138a8:	0002e703 	.word	0x0002e703
   138ac:	20006b48 	.word	0x20006b48
   138b0:	0002e739 	.word	0x0002e739
   138b4:	0002e744 	.word	0x0002e744
   138b8:	0002e770 	.word	0x0002e770
   138bc:	0002e77c 	.word	0x0002e77c
   138c0:	0002e795 	.word	0x0002e795
   138c4:	0002e7a3 	.word	0x0002e7a3
   138c8:	0002e7c9 	.word	0x0002e7c9
   138cc:	0002e7d5 	.word	0x0002e7d5
   138d0:	0001342d 	.word	0x0001342d
   138d4:	0002e68c 	.word	0x0002e68c
   138d8:	0002e6a9 	.word	0x0002e6a9
   138dc:	0002e6da 	.word	0x0002e6da
   138e0:	0002e817 	.word	0x0002e817
   138e4:	0002e67d 	.word	0x0002e67d
				clear_net_key(update->key_idx);
   138e8:	f7ff fd46 	bl	13378 <clear_net_key>
   138ec:	e692      	b.n	13614 <store_pending+0x5c>
			if (update->app_key) {
   138ee:	b182      	cbz	r2, 13912 <store_pending+0x35a>
				key = bt_mesh_app_key_find(update->key_idx);
   138f0:	f7fa ff80 	bl	e7f4 <bt_mesh_app_key_find>
				if (key) {
   138f4:	b110      	cbz	r0, 138fc <store_pending+0x344>
					store_app_key(key);
   138f6:	f7ff fb3b 	bl	12f70 <store_app_key>
   138fa:	e68b      	b.n	13614 <store_pending+0x5c>
					BT_WARN("AppKeyIndex 0x%03x not found",
   138fc:	f837 1014 	ldrh.w	r1, [r7, r4, lsl #1]
   13900:	484d      	ldr	r0, [pc, #308]	; (13a38 <store_pending+0x480>)
   13902:	01b2      	lsls	r2, r6, #6
   13904:	f042 0202 	orr.w	r2, r2, #2
   13908:	f3c1 010b 	ubfx	r1, r1, #0, #12
					BT_WARN("NetKeyIndex 0x%03x not found",
   1390c:	f010 fb67 	bl	23fde <log_1>
   13910:	e680      	b.n	13614 <store_pending+0x5c>
				sub = bt_mesh_subnet_get(update->key_idx);
   13912:	f7f9 f86b 	bl	c9ec <bt_mesh_subnet_get>
				if (sub) {
   13916:	b110      	cbz	r0, 1391e <store_pending+0x366>
					store_net_key(sub);
   13918:	f7ff fcf6 	bl	13308 <store_net_key>
   1391c:	e67a      	b.n	13614 <store_pending+0x5c>
					BT_WARN("NetKeyIndex 0x%03x not found",
   1391e:	f837 1014 	ldrh.w	r1, [r7, r4, lsl #1]
   13922:	01b2      	lsls	r2, r6, #6
   13924:	f042 0202 	orr.w	r2, r2, #2
   13928:	f3c1 010b 	ubfx	r1, r1, #0, #12
   1392c:	4650      	mov	r0, sl
   1392e:	e7ed      	b.n	1390c <store_pending+0x354>
	err = settings_delete("bt/mesh/Net");
   13930:	4842      	ldr	r0, [pc, #264]	; (13a3c <store_pending+0x484>)
   13932:	f010 fefd 	bl	24730 <settings_delete>
	if (err) {
   13936:	2800      	cmp	r0, #0
   13938:	f43f ae9b 	beq.w	13672 <store_pending+0xba>
   1393c:	4940      	ldr	r1, [pc, #256]	; (13a40 <store_pending+0x488>)
   1393e:	4b41      	ldr	r3, [pc, #260]	; (13a44 <store_pending+0x48c>)
		BT_ERR("Failed to clear Network");
   13940:	4841      	ldr	r0, [pc, #260]	; (13a48 <store_pending+0x490>)
   13942:	1ac9      	subs	r1, r1, r3
   13944:	08c9      	lsrs	r1, r1, #3
   13946:	0189      	lsls	r1, r1, #6
   13948:	f041 0101 	orr.w	r1, r1, #1
   1394c:	e68f      	b.n	1366e <store_pending+0xb6>
	err = settings_delete("bt/mesh/IV");
   1394e:	483f      	ldr	r0, [pc, #252]	; (13a4c <store_pending+0x494>)
   13950:	f010 feee 	bl	24730 <settings_delete>
	if (err) {
   13954:	2800      	cmp	r0, #0
   13956:	f43f aeb7 	beq.w	136c8 <store_pending+0x110>
   1395a:	4939      	ldr	r1, [pc, #228]	; (13a40 <store_pending+0x488>)
   1395c:	4b39      	ldr	r3, [pc, #228]	; (13a44 <store_pending+0x48c>)
		BT_ERR("Failed to clear IV");
   1395e:	483c      	ldr	r0, [pc, #240]	; (13a50 <store_pending+0x498>)
   13960:	1ac9      	subs	r1, r1, r3
   13962:	08c9      	lsrs	r1, r1, #3
   13964:	0189      	lsls	r1, r1, #6
   13966:	f041 0101 	orr.w	r1, r1, #1
   1396a:	e6ab      	b.n	136c4 <store_pending+0x10c>
		val.indefinite = (pub->count == 0xffff);
   1396c:	8c43      	ldrh	r3, [r0, #34]	; 0x22
		val.dst = pub->dst;
   1396e:	f8ad 101c 	strh.w	r1, [sp, #28]
		val.period = pub->period;
   13972:	8c81      	ldrh	r1, [r0, #36]	; 0x24
		val.indefinite = (pub->count == 0xffff);
   13974:	f64f 72ff 	movw	r2, #65535	; 0xffff
   13978:	1a9c      	subs	r4, r3, r2
		val.feat = pub->feat;
   1397a:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
		val.period = pub->period;
   1397c:	f8ad 101e 	strh.w	r1, [sp, #30]
		val.feat = pub->feat;
   13980:	f8ad 3020 	strh.w	r3, [sp, #32]
		val.net_idx = pub->net_idx;
   13984:	8d03      	ldrh	r3, [r0, #40]	; 0x28
		err = settings_save_one("bt/mesh/HBPub", &val, sizeof(val));
   13986:	4833      	ldr	r0, [pc, #204]	; (13a54 <store_pending+0x49c>)
		val.indefinite = (pub->count == 0xffff);
   13988:	4262      	negs	r2, r4
   1398a:	4162      	adcs	r2, r4
		val.net_idx = pub->net_idx;
   1398c:	f3c3 030b 	ubfx	r3, r3, #0, #12
   13990:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
   13994:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
   13998:	f402 4260 	and.w	r2, r2, #57344	; 0xe000
   1399c:	4313      	orrs	r3, r2
		err = settings_save_one("bt/mesh/HBPub", &val, sizeof(val));
   1399e:	a907      	add	r1, sp, #28
   139a0:	2208      	movs	r2, #8
		val.net_idx = pub->net_idx;
   139a2:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
		err = settings_save_one("bt/mesh/HBPub", &val, sizeof(val));
   139a6:	f7ef ffb9 	bl	391c <settings_save_one>
   139aa:	e6b8      	b.n	1371e <store_pending+0x166>
	err = settings_delete("bt/mesh/Cfg");
   139ac:	482a      	ldr	r0, [pc, #168]	; (13a58 <store_pending+0x4a0>)
   139ae:	f010 febf 	bl	24730 <settings_delete>
	if (err) {
   139b2:	2800      	cmp	r0, #0
   139b4:	f43f aee4 	beq.w	13780 <store_pending+0x1c8>
   139b8:	4921      	ldr	r1, [pc, #132]	; (13a40 <store_pending+0x488>)
   139ba:	4b22      	ldr	r3, [pc, #136]	; (13a44 <store_pending+0x48c>)
		BT_ERR("Failed to clear configuration");
   139bc:	4827      	ldr	r0, [pc, #156]	; (13a5c <store_pending+0x4a4>)
   139be:	1ac9      	subs	r1, r1, r3
   139c0:	08c9      	lsrs	r1, r1, #3
   139c2:	0189      	lsls	r1, r1, #6
   139c4:	f041 0101 	orr.w	r1, r1, #1
   139c8:	e6d8      	b.n	1377c <store_pending+0x1c4>
		if (!atomic_test_and_clear_bit(lab->flags,
   139ca:	2100      	movs	r1, #0
   139cc:	f105 0014 	add.w	r0, r5, #20
   139d0:	f014 f8e8 	bl	27ba4 <atomic_test_and_clear_bit>
   139d4:	b1e8      	cbz	r0, 13a12 <store_pending+0x45a>
		snprintk(path, sizeof(path), "bt/mesh/Va/%x", i);
   139d6:	b2bb      	uxth	r3, r7
   139d8:	4642      	mov	r2, r8
   139da:	2112      	movs	r1, #18
   139dc:	a802      	add	r0, sp, #8
   139de:	f010 fa8d 	bl	23efc <snprintk>
		if (IS_VA_DEL(lab)) {
   139e2:	882b      	ldrh	r3, [r5, #0]
   139e4:	b9bb      	cbnz	r3, 13a16 <store_pending+0x45e>
			err = settings_delete(path);
   139e6:	a802      	add	r0, sp, #8
   139e8:	f010 fea2 	bl	24730 <settings_delete>
			err = settings_save_one(path, &va, sizeof(va));
   139ec:	4606      	mov	r6, r0
		if (err) {
   139ee:	b180      	cbz	r0, 13a12 <store_pending+0x45a>
			BT_ERR("Failed to %s %s value (err %d)",
   139f0:	882b      	ldrh	r3, [r5, #0]
   139f2:	491b      	ldr	r1, [pc, #108]	; (13a60 <store_pending+0x4a8>)
   139f4:	4d1b      	ldr	r5, [pc, #108]	; (13a64 <store_pending+0x4ac>)
   139f6:	a802      	add	r0, sp, #8
   139f8:	2b00      	cmp	r3, #0
   139fa:	bf08      	it	eq
   139fc:	460d      	moveq	r5, r1
   139fe:	f7ee fdef 	bl	25e0 <log_strdup>
   13a02:	f8ad 4000 	strh.w	r4, [sp]
   13a06:	4602      	mov	r2, r0
   13a08:	4633      	mov	r3, r6
   13a0a:	4817      	ldr	r0, [pc, #92]	; (13a68 <store_pending+0x4b0>)
   13a0c:	4629      	mov	r1, r5
   13a0e:	f010 fb13 	bl	24038 <log_3>
	for (i = 0; (lab = get_label(i)) != NULL; i++) {
   13a12:	3701      	adds	r7, #1
   13a14:	e6cc      	b.n	137b0 <store_pending+0x1f8>
			va.ref = lab->ref;
   13a16:	f8ad 301c 	strh.w	r3, [sp, #28]
			memcpy(va.uuid, lab->uuid, 16);
   13a1a:	1d29      	adds	r1, r5, #4
			va.addr = lab->addr;
   13a1c:	886b      	ldrh	r3, [r5, #2]
   13a1e:	f8ad 301e 	strh.w	r3, [sp, #30]
			memcpy(va.uuid, lab->uuid, 16);
   13a22:	2210      	movs	r2, #16
   13a24:	a808      	add	r0, sp, #32
   13a26:	f012 f93f 	bl	25ca8 <memcpy>
			err = settings_save_one(path, &va, sizeof(va));
   13a2a:	2214      	movs	r2, #20
   13a2c:	a907      	add	r1, sp, #28
   13a2e:	a802      	add	r0, sp, #8
   13a30:	f7ef ff74 	bl	391c <settings_save_one>
   13a34:	e7da      	b.n	139ec <store_pending+0x434>
   13a36:	bf00      	nop
   13a38:	0002e6bd 	.word	0x0002e6bd
   13a3c:	0002e6f7 	.word	0x0002e6f7
   13a40:	00029980 	.word	0x00029980
   13a44:	00029830 	.word	0x00029830
   13a48:	0002e721 	.word	0x0002e721
   13a4c:	0002e739 	.word	0x0002e739
   13a50:	0002e75d 	.word	0x0002e75d
   13a54:	0002e795 	.word	0x0002e795
   13a58:	0002e7c9 	.word	0x0002e7c9
   13a5c:	0002e7f9 	.word	0x0002e7f9
   13a60:	0002e825 	.word	0x0002e825
   13a64:	0002e82c 	.word	0x0002e82c
   13a68:	0002e832 	.word	0x0002e832

00013a6c <iv_set>:
{
   13a6c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   13a6e:	460c      	mov	r4, r1
   13a70:	4610      	mov	r0, r2
   13a72:	4619      	mov	r1, r3
	if (len_rd == 0) {
   13a74:	b98c      	cbnz	r4, 13a9a <iv_set+0x2e>
		bt_mesh.iv_index = 0U;
   13a76:	4b22      	ldr	r3, [pc, #136]	; (13b00 <iv_set+0x94>)
   13a78:	f843 4b08 	str.w	r4, [r3], #8
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   13a7c:	f3bf 8f5b 	dmb	ish
   13a80:	e853 2f00 	ldrex	r2, [r3]
   13a84:	f022 0204 	bic.w	r2, r2, #4
   13a88:	e843 2100 	strex	r1, r2, [r3]
   13a8c:	2900      	cmp	r1, #0
   13a8e:	d1f7      	bne.n	13a80 <iv_set+0x14>
   13a90:	f3bf 8f5b 	dmb	ish
}
   13a94:	4620      	mov	r0, r4
   13a96:	b003      	add	sp, #12
   13a98:	bd30      	pop	{r4, r5, pc}
	err = mesh_x_set(read_cb, cb_arg, &iv, sizeof(iv));
   13a9a:	2305      	movs	r3, #5
   13a9c:	466a      	mov	r2, sp
   13a9e:	f7fe fff5 	bl	12a8c <mesh_x_set>
	if (err) {
   13aa2:	4604      	mov	r4, r0
   13aa4:	b150      	cbz	r0, 13abc <iv_set+0x50>
   13aa6:	4b17      	ldr	r3, [pc, #92]	; (13b04 <iv_set+0x98>)
   13aa8:	4917      	ldr	r1, [pc, #92]	; (13b08 <iv_set+0x9c>)
		BT_ERR("Failed to set \'iv\'");
   13aaa:	4818      	ldr	r0, [pc, #96]	; (13b0c <iv_set+0xa0>)
   13aac:	1ac9      	subs	r1, r1, r3
   13aae:	08c9      	lsrs	r1, r1, #3
   13ab0:	0189      	lsls	r1, r1, #6
   13ab2:	f041 0101 	orr.w	r1, r1, #1
   13ab6:	f010 fa85 	bl	23fc4 <log_0>
		return err;
   13aba:	e7eb      	b.n	13a94 <iv_set+0x28>
	bt_mesh.iv_index = iv.iv_index;
   13abc:	4d10      	ldr	r5, [pc, #64]	; (13b00 <iv_set+0x94>)
   13abe:	9b00      	ldr	r3, [sp, #0]
   13ac0:	602b      	str	r3, [r5, #0]
	atomic_set_bit_to(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS, iv.iv_update);
   13ac2:	f89d 3004 	ldrb.w	r3, [sp, #4]
	if (val) {
   13ac6:	f013 0f01 	tst.w	r3, #1
   13aca:	f105 0008 	add.w	r0, r5, #8
   13ace:	d009      	beq.n	13ae4 <iv_set+0x78>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   13ad0:	2104      	movs	r1, #4
   13ad2:	f014 f83c 	bl	27b4e <atomic_or>
	bt_mesh.ivu_duration = iv.iv_duration;
   13ad6:	f89d 3004 	ldrb.w	r3, [sp, #4]
   13ada:	f3c3 0346 	ubfx	r3, r3, #1, #7
   13ade:	f885 3118 	strb.w	r3, [r5, #280]	; 0x118
	return 0;
   13ae2:	e7d7      	b.n	13a94 <iv_set+0x28>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   13ae4:	f3bf 8f5b 	dmb	ish
   13ae8:	e850 3f00 	ldrex	r3, [r0]
   13aec:	f023 0304 	bic.w	r3, r3, #4
   13af0:	e840 3200 	strex	r2, r3, [r0]
   13af4:	2a00      	cmp	r2, #0
   13af6:	d1f7      	bne.n	13ae8 <iv_set+0x7c>
   13af8:	f3bf 8f5b 	dmb	ish
   13afc:	e7eb      	b.n	13ad6 <iv_set+0x6a>
   13afe:	bf00      	nop
   13b00:	20006b48 	.word	0x20006b48
   13b04:	00029830 	.word	0x00029830
   13b08:	00029980 	.word	0x00029980
   13b0c:	0002e851 	.word	0x0002e851

00013b10 <schedule_store>:
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   13b10:	2101      	movs	r1, #1
   13b12:	4081      	lsls	r1, r0
{
   13b14:	b510      	push	{r4, lr}
   13b16:	4818      	ldr	r0, [pc, #96]	; (13b78 <schedule_store+0x68>)
   13b18:	f014 f819 	bl	27b4e <atomic_or>
	if (atomic_get(bt_mesh.flags) & NO_WAIT_PENDING_BITS) {
   13b1c:	4816      	ldr	r0, [pc, #88]	; (13b78 <schedule_store+0x68>)
   13b1e:	f014 f825 	bl	27b6c <atomic_get>
   13b22:	f410 6fe0 	tst.w	r0, #1792	; 0x700
   13b26:	d120      	bne.n	13b6a <schedule_store+0x5a>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   13b28:	4813      	ldr	r0, [pc, #76]	; (13b78 <schedule_store+0x68>)
   13b2a:	f014 f81f 	bl	27b6c <atomic_get>
	} else if (atomic_test_bit(bt_mesh.flags, BT_MESH_RPL_PENDING) &&
   13b2e:	0643      	lsls	r3, r0, #25
   13b30:	d505      	bpl.n	13b3e <schedule_store+0x2e>
		   (!(atomic_get(bt_mesh.flags) & GENERIC_PENDING_BITS) ||
   13b32:	4811      	ldr	r0, [pc, #68]	; (13b78 <schedule_store+0x68>)
   13b34:	f014 f81a 	bl	27b6c <atomic_get>
	} else if (atomic_test_bit(bt_mesh.flags, BT_MESH_RPL_PENDING) &&
   13b38:	f410 5f62 	tst.w	r0, #14464	; 0x3880
   13b3c:	d017      	beq.n	13b6e <schedule_store+0x5e>
		timeout = K_SECONDS(CONFIG_BT_MESH_STORE_TIMEOUT);
   13b3e:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0
	return k_ticks_to_ms_floor32(z_timeout_remaining(&work->timeout));
   13b42:	480e      	ldr	r0, [pc, #56]	; (13b7c <schedule_store+0x6c>)
   13b44:	f00f fa38 	bl	22fb8 <z_timeout_remaining>
			return (u32_t)((t * to_hz + off) / from_hz);
   13b48:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   13b4c:	fba0 0103 	umull	r0, r1, r0, r3
   13b50:	0bc3      	lsrs	r3, r0, #15
	if (remaining && remaining < timeout) {
   13b52:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   13b56:	d001      	beq.n	13b5c <schedule_store+0x4c>
   13b58:	429c      	cmp	r4, r3
   13b5a:	dc0b      	bgt.n	13b74 <schedule_store+0x64>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   13b5c:	4622      	mov	r2, r4
   13b5e:	4908      	ldr	r1, [pc, #32]	; (13b80 <schedule_store+0x70>)
   13b60:	4808      	ldr	r0, [pc, #32]	; (13b84 <schedule_store+0x74>)
}
   13b62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   13b66:	f00e bffb 	b.w	22b60 <k_delayed_work_submit_to_queue>
		timeout = K_NO_WAIT;
   13b6a:	2400      	movs	r4, #0
   13b6c:	e7e9      	b.n	13b42 <schedule_store+0x32>
		timeout = K_SECONDS(CONFIG_BT_MESH_RPL_STORE_TIMEOUT);
   13b6e:	f241 3488 	movw	r4, #5000	; 0x1388
   13b72:	e7e6      	b.n	13b42 <schedule_store+0x32>
}
   13b74:	bd10      	pop	{r4, pc}
   13b76:	bf00      	nop
   13b78:	20006b50 	.word	0x20006b50
   13b7c:	20000934 	.word	0x20000934
   13b80:	20000928 	.word	0x20000928
   13b84:	20001dc4 	.word	0x20001dc4

00013b88 <app_key_set>:
{
   13b88:	b5f0      	push	{r4, r5, r6, r7, lr}
   13b8a:	460c      	mov	r4, r1
   13b8c:	b08b      	sub	sp, #44	; 0x2c
   13b8e:	4615      	mov	r5, r2
   13b90:	461f      	mov	r7, r3
	if (!name) {
   13b92:	b970      	cbnz	r0, 13bb2 <app_key_set+0x2a>
   13b94:	4b34      	ldr	r3, [pc, #208]	; (13c68 <app_key_set+0xe0>)
   13b96:	4935      	ldr	r1, [pc, #212]	; (13c6c <app_key_set+0xe4>)
		BT_ERR("Insufficient number of arguments");
   13b98:	4835      	ldr	r0, [pc, #212]	; (13c70 <app_key_set+0xe8>)
   13b9a:	1ac9      	subs	r1, r1, r3
   13b9c:	08c9      	lsrs	r1, r1, #3
   13b9e:	0189      	lsls	r1, r1, #6
   13ba0:	f041 0101 	orr.w	r1, r1, #1
   13ba4:	f010 fa0e 	bl	23fc4 <log_0>
		return -ENOENT;
   13ba8:	f06f 0501 	mvn.w	r5, #1
}
   13bac:	4628      	mov	r0, r5
   13bae:	b00b      	add	sp, #44	; 0x2c
   13bb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	app_idx = strtol(name, NULL, 16);
   13bb2:	2210      	movs	r2, #16
   13bb4:	2100      	movs	r1, #0
   13bb6:	f011 ffa4 	bl	25b02 <strtol>
   13bba:	b286      	uxth	r6, r0
	if (len_rd == 0) {
   13bbc:	b954      	cbnz	r4, 13bd4 <app_key_set+0x4c>
		app = bt_mesh_app_key_find(app_idx);
   13bbe:	4630      	mov	r0, r6
   13bc0:	f7fa fe18 	bl	e7f4 <bt_mesh_app_key_find>
   13bc4:	4605      	mov	r5, r0
		if (app) {
   13bc6:	2800      	cmp	r0, #0
   13bc8:	d0f0      	beq.n	13bac <app_key_set+0x24>
			bt_mesh_app_key_del(app, false);
   13bca:	4621      	mov	r1, r4
   13bcc:	f7fe fa36 	bl	1203c <bt_mesh_app_key_del>
		return 0;
   13bd0:	4625      	mov	r5, r4
   13bd2:	e7eb      	b.n	13bac <app_key_set+0x24>
	err = mesh_x_set(read_cb, cb_arg, &key, sizeof(key));
   13bd4:	4628      	mov	r0, r5
   13bd6:	2323      	movs	r3, #35	; 0x23
   13bd8:	aa01      	add	r2, sp, #4
   13bda:	4639      	mov	r1, r7
   13bdc:	f7fe ff56 	bl	12a8c <mesh_x_set>
	if (err) {
   13be0:	4605      	mov	r5, r0
   13be2:	b150      	cbz	r0, 13bfa <app_key_set+0x72>
   13be4:	4b20      	ldr	r3, [pc, #128]	; (13c68 <app_key_set+0xe0>)
   13be6:	4921      	ldr	r1, [pc, #132]	; (13c6c <app_key_set+0xe4>)
		BT_ERR("Failed to set \'app-key\'");
   13be8:	4822      	ldr	r0, [pc, #136]	; (13c74 <app_key_set+0xec>)
   13bea:	1ac9      	subs	r1, r1, r3
   13bec:	08c9      	lsrs	r1, r1, #3
   13bee:	0189      	lsls	r1, r1, #6
   13bf0:	f041 0101 	orr.w	r1, r1, #1
   13bf4:	f010 f9e6 	bl	23fc4 <log_0>
		return err;
   13bf8:	e7d8      	b.n	13bac <app_key_set+0x24>
	app = bt_mesh_app_key_find(app_idx);
   13bfa:	4630      	mov	r0, r6
   13bfc:	f7fa fdfa 	bl	e7f4 <bt_mesh_app_key_find>
	if (!app) {
   13c00:	4604      	mov	r4, r0
   13c02:	b988      	cbnz	r0, 13c28 <app_key_set+0xa0>
		app = bt_mesh_app_key_alloc(app_idx);
   13c04:	4630      	mov	r0, r6
   13c06:	f7fe f97d 	bl	11f04 <bt_mesh_app_key_alloc>
	if (!app) {
   13c0a:	4604      	mov	r4, r0
   13c0c:	b960      	cbnz	r0, 13c28 <app_key_set+0xa0>
   13c0e:	4b16      	ldr	r3, [pc, #88]	; (13c68 <app_key_set+0xe0>)
   13c10:	4916      	ldr	r1, [pc, #88]	; (13c6c <app_key_set+0xe4>)
		BT_ERR("No space for a new app key");
   13c12:	4819      	ldr	r0, [pc, #100]	; (13c78 <app_key_set+0xf0>)
   13c14:	1ac9      	subs	r1, r1, r3
   13c16:	08c9      	lsrs	r1, r1, #3
   13c18:	0189      	lsls	r1, r1, #6
   13c1a:	f041 0101 	orr.w	r1, r1, #1
   13c1e:	f010 f9d1 	bl	23fc4 <log_0>
		return -ENOMEM;
   13c22:	f06f 050b 	mvn.w	r5, #11
   13c26:	e7c1      	b.n	13bac <app_key_set+0x24>
	app->net_idx = key.net_idx;
   13c28:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   13c2c:	8023      	strh	r3, [r4, #0]
	memcpy(app->keys[0].val, key.val[0], 16);
   13c2e:	1da7      	adds	r7, r4, #6
	app->updated = key.updated;
   13c30:	f89d 3006 	ldrb.w	r3, [sp, #6]
   13c34:	7123      	strb	r3, [r4, #4]
	app->app_idx = app_idx;
   13c36:	8066      	strh	r6, [r4, #2]
	memcpy(app->keys[0].val, key.val[0], 16);
   13c38:	f10d 0107 	add.w	r1, sp, #7
	memcpy(app->keys[1].val, key.val[1], 16);
   13c3c:	f104 0617 	add.w	r6, r4, #23
	memcpy(app->keys[0].val, key.val[0], 16);
   13c40:	2210      	movs	r2, #16
   13c42:	4638      	mov	r0, r7
   13c44:	f012 f830 	bl	25ca8 <memcpy>
	memcpy(app->keys[1].val, key.val[1], 16);
   13c48:	2210      	movs	r2, #16
   13c4a:	f10d 0117 	add.w	r1, sp, #23
   13c4e:	4630      	mov	r0, r6
   13c50:	f012 f82a 	bl	25ca8 <memcpy>
			const u8_t net_id[16], u32_t iv_index,
			u8_t auth[8]);

static inline int bt_mesh_app_id(const u8_t app_key[16], u8_t app_id[1])
{
	return bt_mesh_k4(app_key, app_id);
   13c54:	1d61      	adds	r1, r4, #5
   13c56:	4638      	mov	r0, r7
   13c58:	f7fb fc8a 	bl	f570 <bt_mesh_k4>
   13c5c:	f104 0116 	add.w	r1, r4, #22
   13c60:	4630      	mov	r0, r6
   13c62:	f7fb fc85 	bl	f570 <bt_mesh_k4>
   13c66:	e7a1      	b.n	13bac <app_key_set+0x24>
   13c68:	00029830 	.word	0x00029830
   13c6c:	00029980 	.word	0x00029980
   13c70:	0002ba0e 	.word	0x0002ba0e
   13c74:	0002e864 	.word	0x0002e864
   13c78:	0002e87c 	.word	0x0002e87c

00013c7c <mesh_commit>:
{
   13c7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (bt_mesh.sub[0].net_idx == BT_MESH_KEY_UNUSED) {
   13c80:	4e47      	ldr	r6, [pc, #284]	; (13da0 <mesh_commit+0x124>)
   13c82:	f8b6 21b8 	ldrh.w	r2, [r6, #440]	; 0x1b8
   13c86:	f64f 73ff 	movw	r3, #65535	; 0xffff
   13c8a:	429a      	cmp	r2, r3
   13c8c:	f000 8085 	beq.w	13d9a <mesh_commit+0x11e>
		bt_mesh_proxy_prov_disable(true);
   13c90:	2001      	movs	r0, #1
   13c92:	f003 ff2f 	bl	17af4 <bt_mesh_proxy_prov_disable>
   13c96:	4c43      	ldr	r4, [pc, #268]	; (13da4 <mesh_commit+0x128>)
   13c98:	4b43      	ldr	r3, [pc, #268]	; (13da8 <mesh_commit+0x12c>)
			BT_ERR("Failed to init subnet 0x%03x", sub->net_idx);
   13c9a:	f8df a12c 	ldr.w	sl, [pc, #300]	; 13dc8 <mesh_commit+0x14c>
   13c9e:	1ae4      	subs	r4, r4, r3
   13ca0:	08e4      	lsrs	r4, r4, #3
   13ca2:	01a4      	lsls	r4, r4, #6
   13ca4:	4635      	mov	r5, r6
	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
   13ca6:	f04f 0900 	mov.w	r9, #0
			BT_ERR("Failed to init subnet 0x%03x", sub->net_idx);
   13caa:	f044 0401 	orr.w	r4, r4, #1
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   13cae:	f8b5 21b8 	ldrh.w	r2, [r5, #440]	; 0x1b8
   13cb2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   13cb6:	429a      	cmp	r2, r3
   13cb8:	d02f      	beq.n	13d1a <mesh_commit+0x9e>
	err = bt_mesh_net_keys_create(&sub->keys[0], sub->keys[0].net);
   13cba:	f505 78e6 	add.w	r8, r5, #460	; 0x1cc
   13cbe:	4641      	mov	r1, r8
   13cc0:	4640      	mov	r0, r8
   13cc2:	f7f8 feb3 	bl	ca2c <bt_mesh_net_keys_create>
	if (err) {
   13cc6:	4607      	mov	r7, r0
   13cc8:	b168      	cbz	r0, 13ce6 <mesh_commit+0x6a>
		BT_ERR("Unable to generate keys for subnet");
   13cca:	4838      	ldr	r0, [pc, #224]	; (13dac <mesh_commit+0x130>)
   13ccc:	4621      	mov	r1, r4
   13cce:	f010 f979 	bl	23fc4 <log_0>
			BT_ERR("Failed to init subnet 0x%03x", sub->net_idx);
   13cd2:	f8b5 11b8 	ldrh.w	r1, [r5, #440]	; 0x1b8
   13cd6:	4622      	mov	r2, r4
   13cd8:	4650      	mov	r0, sl
   13cda:	f010 f980 	bl	23fde <log_1>
   13cde:	e01c      	b.n	13d1a <mesh_commit+0x9e>
   13ce0:	f04f 0901 	mov.w	r9, #1
   13ce4:	e7e3      	b.n	13cae <mesh_commit+0x32>
	if (sub->kr_phase != BT_MESH_KR_NORMAL) {
   13ce6:	f895 31bb 	ldrb.w	r3, [r5, #443]	; 0x1bb
   13cea:	b17b      	cbz	r3, 13d0c <mesh_commit+0x90>
		err = bt_mesh_net_keys_create(&sub->keys[1], sub->keys[1].net);
   13cec:	f205 2125 	addw	r1, r5, #549	; 0x225
   13cf0:	4608      	mov	r0, r1
   13cf2:	f7f8 fe9b 	bl	ca2c <bt_mesh_net_keys_create>
		if (err) {
   13cf6:	b148      	cbz	r0, 13d0c <mesh_commit+0x90>
			BT_ERR("Unable to generate keys for subnet");
   13cf8:	4621      	mov	r1, r4
   13cfa:	482c      	ldr	r0, [pc, #176]	; (13dac <mesh_commit+0x130>)
   13cfc:	f010 f962 	bl	23fc4 <log_0>
			(void)memset(&sub->keys[0], 0, sizeof(sub->keys[0]));
   13d00:	2259      	movs	r2, #89	; 0x59
   13d02:	4639      	mov	r1, r7
   13d04:	4640      	mov	r0, r8
   13d06:	f011 fffa 	bl	25cfe <memset>
		if (err) {
   13d0a:	e7e2      	b.n	13cd2 <mesh_commit+0x56>
		sub->node_id = BT_MESH_NODE_IDENTITY_STOPPED;
   13d0c:	2300      	movs	r3, #0
   13d0e:	f885 31bc 	strb.w	r3, [r5, #444]	; 0x1bc
	bt_mesh_net_beacon_update(sub);
   13d12:	f505 70ce 	add.w	r0, r5, #412	; 0x19c
   13d16:	f7f9 f839 	bl	cd8c <bt_mesh_net_beacon_update>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.sub); i++) {
   13d1a:	35e4      	adds	r5, #228	; 0xe4
   13d1c:	f1b9 0f00 	cmp.w	r9, #0
   13d20:	d0de      	beq.n	13ce0 <mesh_commit+0x64>
	if (bt_mesh.ivu_duration < BT_MESH_IVU_MIN_HOURS) {
   13d22:	f896 3118 	ldrb.w	r3, [r6, #280]	; 0x118
   13d26:	2b5f      	cmp	r3, #95	; 0x5f
   13d28:	d804      	bhi.n	13d34 <mesh_commit+0xb8>
   13d2a:	4a21      	ldr	r2, [pc, #132]	; (13db0 <mesh_commit+0x134>)
   13d2c:	4921      	ldr	r1, [pc, #132]	; (13db4 <mesh_commit+0x138>)
   13d2e:	4822      	ldr	r0, [pc, #136]	; (13db8 <mesh_commit+0x13c>)
   13d30:	f00e ff16 	bl	22b60 <k_delayed_work_submit_to_queue>
	bt_mesh_model_foreach(commit_mod, NULL);
   13d34:	4821      	ldr	r0, [pc, #132]	; (13dbc <mesh_commit+0x140>)
   13d36:	2100      	movs	r1, #0
   13d38:	f7fb fda2 	bl	f880 <bt_mesh_model_foreach>
	hb_pub = bt_mesh_hb_pub_get();
   13d3c:	f7fe fd8c 	bl	12858 <bt_mesh_hb_pub_get>
	if (hb_pub && hb_pub->dst != BT_MESH_ADDR_UNASSIGNED &&
   13d40:	4604      	mov	r4, r0
   13d42:	b180      	cbz	r0, 13d66 <mesh_commit+0xea>
   13d44:	8c03      	ldrh	r3, [r0, #32]
   13d46:	b173      	cbz	r3, 13d66 <mesh_commit+0xea>
   13d48:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   13d4a:	b163      	cbz	r3, 13d66 <mesh_commit+0xea>
	    hb_pub->count && hb_pub->period) {
   13d4c:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   13d50:	b14b      	cbz	r3, 13d66 <mesh_commit+0xea>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   13d52:	2101      	movs	r1, #1
   13d54:	3008      	adds	r0, #8
   13d56:	f013 fefa 	bl	27b4e <atomic_or>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   13d5a:	07c3      	lsls	r3, r0, #31
   13d5c:	d403      	bmi.n	13d66 <mesh_commit+0xea>
		k_queue_append(&work_q->queue, work);
   13d5e:	4816      	ldr	r0, [pc, #88]	; (13db8 <mesh_commit+0x13c>)
   13d60:	4621      	mov	r1, r4
   13d62:	f015 fa76 	bl	29252 <k_queue_append>
	cfg = bt_mesh_cfg_get();
   13d66:	f7fe fd7f 	bl	12868 <bt_mesh_cfg_get>
	if (cfg && stored_cfg.valid) {
   13d6a:	b180      	cbz	r0, 13d8e <mesh_commit+0x112>
   13d6c:	4b14      	ldr	r3, [pc, #80]	; (13dc0 <mesh_commit+0x144>)
   13d6e:	781a      	ldrb	r2, [r3, #0]
   13d70:	b16a      	cbz	r2, 13d8e <mesh_commit+0x112>
		cfg->net_transmit = stored_cfg.cfg.net_transmit;
   13d72:	785a      	ldrb	r2, [r3, #1]
   13d74:	7102      	strb	r2, [r0, #4]
		cfg->relay = stored_cfg.cfg.relay;
   13d76:	789a      	ldrb	r2, [r3, #2]
   13d78:	7142      	strb	r2, [r0, #5]
		cfg->relay_retransmit = stored_cfg.cfg.relay_retransmit;
   13d7a:	78da      	ldrb	r2, [r3, #3]
   13d7c:	7182      	strb	r2, [r0, #6]
		cfg->beacon = stored_cfg.cfg.beacon;
   13d7e:	791a      	ldrb	r2, [r3, #4]
   13d80:	71c2      	strb	r2, [r0, #7]
		cfg->gatt_proxy = stored_cfg.cfg.gatt_proxy;
   13d82:	795a      	ldrb	r2, [r3, #5]
   13d84:	7202      	strb	r2, [r0, #8]
		cfg->frnd = stored_cfg.cfg.frnd;
   13d86:	799a      	ldrb	r2, [r3, #6]
		cfg->default_ttl = stored_cfg.cfg.default_ttl;
   13d88:	79db      	ldrb	r3, [r3, #7]
		cfg->frnd = stored_cfg.cfg.frnd;
   13d8a:	7242      	strb	r2, [r0, #9]
		cfg->default_ttl = stored_cfg.cfg.default_ttl;
   13d8c:	7283      	strb	r3, [r0, #10]
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   13d8e:	2101      	movs	r1, #1
   13d90:	480c      	ldr	r0, [pc, #48]	; (13dc4 <mesh_commit+0x148>)
   13d92:	f013 fedc 	bl	27b4e <atomic_or>
	bt_mesh_start();
   13d96:	f7f8 f815 	bl	bdc4 <bt_mesh_start>
}
   13d9a:	2000      	movs	r0, #0
   13d9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13da0:	20006b48 	.word	0x20006b48
   13da4:	00029980 	.word	0x00029980
   13da8:	00029830 	.word	0x00029830
   13dac:	0002e897 	.word	0x0002e897
   13db0:	05265c00 	.word	0x05265c00
   13db4:	20006c64 	.word	0x20006c64
   13db8:	20001dc4 	.word	0x20001dc4
   13dbc:	00012ead 	.word	0x00012ead
   13dc0:	200024bd 	.word	0x200024bd
   13dc4:	20006b50 	.word	0x20006b50
   13dc8:	0002e8ba 	.word	0x0002e8ba

00013dcc <bt_mesh_store_seq>:
	    (bt_mesh.seq % CONFIG_BT_MESH_SEQ_STORE_RATE)) {
   13dcc:	4b03      	ldr	r3, [pc, #12]	; (13ddc <bt_mesh_store_seq+0x10>)
   13dce:	685b      	ldr	r3, [r3, #4]
	if (CONFIG_BT_MESH_SEQ_STORE_RATE &&
   13dd0:	065b      	lsls	r3, r3, #25
   13dd2:	d102      	bne.n	13dda <bt_mesh_store_seq+0xe>
	schedule_store(BT_MESH_SEQ_PENDING);
   13dd4:	200a      	movs	r0, #10
   13dd6:	f7ff be9b 	b.w	13b10 <schedule_store>
}
   13dda:	4770      	bx	lr
   13ddc:	20006b48 	.word	0x20006b48

00013de0 <bt_mesh_model_data_store>:
	schedule_cdb_store(BT_MESH_CDB_KEYS_PENDING);
}

int bt_mesh_model_data_store(struct bt_mesh_model *mod, bool vnd,
			     const void *data, size_t data_len)
{
   13de0:	b570      	push	{r4, r5, r6, lr}
   13de2:	4605      	mov	r5, r0
   13de4:	b086      	sub	sp, #24
   13de6:	4616      	mov	r6, r2
   13de8:	461c      	mov	r4, r3
	char path[20];
	int err;

	encode_mod_path(mod, vnd, "data", path, sizeof(path));
   13dea:	4a16      	ldr	r2, [pc, #88]	; (13e44 <bt_mesh_model_data_store+0x64>)
   13dec:	ab01      	add	r3, sp, #4
   13dee:	f7ff fb07 	bl	13400 <encode_mod_path.constprop.0>

	if (data_len) {
		mod->flags |= BT_MESH_MOD_DATA_PRESENT;
   13df2:	88eb      	ldrh	r3, [r5, #6]
	if (data_len) {
   13df4:	b1dc      	cbz	r4, 13e2e <bt_mesh_model_data_store+0x4e>
		mod->flags |= BT_MESH_MOD_DATA_PRESENT;
   13df6:	f043 0308 	orr.w	r3, r3, #8
   13dfa:	80eb      	strh	r3, [r5, #6]
		err = settings_save_one(path, data, data_len);
   13dfc:	4622      	mov	r2, r4
   13dfe:	4631      	mov	r1, r6
   13e00:	a801      	add	r0, sp, #4
   13e02:	f7ef fd8b 	bl	391c <settings_save_one>
	} else if (mod->flags & BT_MESH_MOD_DATA_PRESENT) {
		mod->flags &= ~BT_MESH_MOD_DATA_PRESENT;
		err = settings_delete(path);
   13e06:	4604      	mov	r4, r0
	} else {
		/* Nothing to delete */
		err = 0;
	}

	if (err) {
   13e08:	b170      	cbz	r0, 13e28 <bt_mesh_model_data_store+0x48>
   13e0a:	4a0f      	ldr	r2, [pc, #60]	; (13e48 <bt_mesh_model_data_store+0x68>)
   13e0c:	4d0f      	ldr	r5, [pc, #60]	; (13e4c <bt_mesh_model_data_store+0x6c>)
		BT_ERR("Failed to store %s value", log_strdup(path));
   13e0e:	a801      	add	r0, sp, #4
   13e10:	1aad      	subs	r5, r5, r2
   13e12:	08ed      	lsrs	r5, r5, #3
   13e14:	f7ee fbe4 	bl	25e0 <log_strdup>
   13e18:	01ad      	lsls	r5, r5, #6
   13e1a:	f045 0501 	orr.w	r5, r5, #1
   13e1e:	4601      	mov	r1, r0
   13e20:	462a      	mov	r2, r5
   13e22:	480b      	ldr	r0, [pc, #44]	; (13e50 <bt_mesh_model_data_store+0x70>)
   13e24:	f010 f8db 	bl	23fde <log_1>
	} else {
		BT_DBG("Stored %s value", log_strdup(path));
	}
	return err;
}
   13e28:	4620      	mov	r0, r4
   13e2a:	b006      	add	sp, #24
   13e2c:	bd70      	pop	{r4, r5, r6, pc}
	} else if (mod->flags & BT_MESH_MOD_DATA_PRESENT) {
   13e2e:	f013 0408 	ands.w	r4, r3, #8
   13e32:	d0f9      	beq.n	13e28 <bt_mesh_model_data_store+0x48>
		mod->flags &= ~BT_MESH_MOD_DATA_PRESENT;
   13e34:	f023 0308 	bic.w	r3, r3, #8
   13e38:	80eb      	strh	r3, [r5, #6]
		err = settings_delete(path);
   13e3a:	a801      	add	r0, sp, #4
   13e3c:	f010 fc78 	bl	24730 <settings_delete>
   13e40:	e7e1      	b.n	13e06 <bt_mesh_model_data_store+0x26>
   13e42:	bf00      	nop
   13e44:	0002c4c6 	.word	0x0002c4c6
   13e48:	00029830 	.word	0x00029830
   13e4c:	00029980 	.word	0x00029980
   13e50:	0002e664 	.word	0x0002e664

00013e54 <bt_mesh_settings_init>:

void bt_mesh_settings_init(void)
{
	k_delayed_work_init(&pending_store, store_pending);
   13e54:	4901      	ldr	r1, [pc, #4]	; (13e5c <bt_mesh_settings_init+0x8>)
   13e56:	4802      	ldr	r0, [pc, #8]	; (13e60 <bt_mesh_settings_init+0xc>)
   13e58:	f015 bacf 	b.w	293fa <k_delayed_work_init>
   13e5c:	000135b9 	.word	0x000135b9
   13e60:	20000928 	.word	0x20000928

00013e64 <adv_alloc>:
	u16_t app_idx;
} adv_pool[FRIEND_BUF_COUNT];

static struct bt_mesh_adv *adv_alloc(int id)
{
	adv_pool[id].app_idx = BT_MESH_KEY_UNUSED;
   13e64:	4b03      	ldr	r3, [pc, #12]	; (13e74 <adv_alloc+0x10>)
   13e66:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   13e6a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   13e6e:	8183      	strh	r3, [r0, #12]
	return &adv_pool[id].adv;
}
   13e70:	4770      	bx	lr
   13e72:	bf00      	nop
   13e74:	20000948 	.word	0x20000948

00013e78 <send_friend_clear>:
static const struct bt_mesh_send_cb clear_sent_cb = {
	.end = friend_clear_sent,
};

static void send_friend_clear(struct bt_mesh_friend *frnd)
{
   13e78:	b510      	push	{r4, lr}
   13e7a:	4604      	mov	r4, r0
   13e7c:	b08a      	sub	sp, #40	; 0x28
	struct bt_mesh_msg_ctx ctx = {
   13e7e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   13e82:	f8ad 2012 	strh.w	r2, [sp, #18]
   13e86:	f8b4 2058 	ldrh.w	r2, [r4, #88]	; 0x58
   13e8a:	f8ad 2014 	strh.w	r2, [sp, #20]
   13e8e:	2300      	movs	r3, #0
   13e90:	227f      	movs	r2, #127	; 0x7f
		.net_idx  = frnd->net_idx,
   13e92:	89c0      	ldrh	r0, [r0, #14]
	struct bt_mesh_msg_ctx ctx = {
   13e94:	f88d 201b 	strb.w	r2, [sp, #27]
		.app_idx  = BT_MESH_KEY_UNUSED,
		.addr     = frnd->clear.frnd,
		.send_ttl = BT_MESH_TTL_MAX,
	};
	struct bt_mesh_net_tx tx = {
   13e98:	e9cd 3307 	strd	r3, r3, [sp, #28]
	struct bt_mesh_msg_ctx ctx = {
   13e9c:	f8cd 3016 	str.w	r3, [sp, #22]
   13ea0:	f88d 301a 	strb.w	r3, [sp, #26]
	struct bt_mesh_net_tx tx = {
   13ea4:	9309      	str	r3, [sp, #36]	; 0x24
	struct bt_mesh_msg_ctx ctx = {
   13ea6:	f8ad 0010 	strh.w	r0, [sp, #16]
		.sub  = bt_mesh_subnet_get(frnd->net_idx),
   13eaa:	f7f8 fd9f 	bl	c9ec <bt_mesh_subnet_get>
	struct bt_mesh_net_tx tx = {
   13eae:	ab04      	add	r3, sp, #16
   13eb0:	9308      	str	r3, [sp, #32]
   13eb2:	9007      	str	r0, [sp, #28]
		.ctx  = &ctx,
		.src  = bt_mesh_primary_addr(),
   13eb4:	f7fb fdfa 	bl	faac <bt_mesh_primary_addr>
	struct bt_mesh_net_tx tx = {
   13eb8:	f8ad 0024 	strh.w	r0, [sp, #36]	; 0x24
		.xmit = bt_mesh_net_transmit_get(),
   13ebc:	f7fe f9a2 	bl	12204 <bt_mesh_net_transmit_get>
	};
	struct bt_mesh_ctl_friend_clear req = {
		.lpn_addr    = sys_cpu_to_be16(frnd->lpn),
   13ec0:	8822      	ldrh	r2, [r4, #0]
	struct bt_mesh_net_tx tx = {
   13ec2:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
		.lpn_addr    = sys_cpu_to_be16(frnd->lpn),
   13ec6:	0213      	lsls	r3, r2, #8
   13ec8:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
		.lpn_counter = sys_cpu_to_be16(frnd->lpn_counter),
   13ecc:	8962      	ldrh	r2, [r4, #10]
	struct bt_mesh_ctl_friend_clear req = {
   13ece:	f8ad 300c 	strh.w	r3, [sp, #12]
		.lpn_counter = sys_cpu_to_be16(frnd->lpn_counter),
   13ed2:	0213      	lsls	r3, r2, #8
   13ed4:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
	struct bt_mesh_ctl_friend_clear req = {
   13ed8:	f8ad 300e 	strh.w	r3, [sp, #14]
   13edc:	4a0a      	ldr	r2, [pc, #40]	; (13f08 <send_friend_clear+0x90>)
   13ede:	4b0b      	ldr	r3, [pc, #44]	; (13f0c <send_friend_clear+0x94>)
	};

	BT_DBG("");
   13ee0:	490b      	ldr	r1, [pc, #44]	; (13f10 <send_friend_clear+0x98>)
   13ee2:	480c      	ldr	r0, [pc, #48]	; (13f14 <send_friend_clear+0x9c>)
   13ee4:	1ad2      	subs	r2, r2, r3
   13ee6:	08d2      	lsrs	r2, r2, #3
   13ee8:	0192      	lsls	r2, r2, #6
   13eea:	f042 0204 	orr.w	r2, r2, #4
   13eee:	f010 f876 	bl	23fde <log_1>

	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_FRIEND_CLEAR, &req,
   13ef2:	4b09      	ldr	r3, [pc, #36]	; (13f18 <send_friend_clear+0xa0>)
   13ef4:	9300      	str	r3, [sp, #0]
   13ef6:	9401      	str	r4, [sp, #4]
   13ef8:	2304      	movs	r3, #4
   13efa:	aa03      	add	r2, sp, #12
   13efc:	2105      	movs	r1, #5
   13efe:	a807      	add	r0, sp, #28
   13f00:	f013 f980 	bl	27204 <bt_mesh_ctl_send>
			 sizeof(req), &clear_sent_cb, frnd);
}
   13f04:	b00a      	add	sp, #40	; 0x28
   13f06:	bd10      	pop	{r4, pc}
   13f08:	00029938 	.word	0x00029938
   13f0c:	00029830 	.word	0x00029830
   13f10:	0002f3c0 	.word	0x0002f3c0
   13f14:	0002aa84 	.word	0x0002aa84
   13f18:	0002a35c 	.word	0x0002a35c

00013f1c <k_delayed_work_submit>:
{
   13f1c:	460a      	mov	r2, r1
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   13f1e:	4601      	mov	r1, r0
   13f20:	4801      	ldr	r0, [pc, #4]	; (13f28 <k_delayed_work_submit+0xc>)
   13f22:	f00e be1d 	b.w	22b60 <k_delayed_work_submit_to_queue>
   13f26:	bf00      	nop
   13f28:	20001dc4 	.word	0x20001dc4

00013f2c <friend_recv_delay>:
{
   13f2c:	b510      	push	{r4, lr}
	frnd->pending_req = 1U;
   13f2e:	78c3      	ldrb	r3, [r0, #3]
	return (s32_t)frnd->recv_delay + (CONFIG_BT_MESH_FRIEND_RECV_WIN / 5);
   13f30:	7881      	ldrb	r1, [r0, #2]
	frnd->pending_req = 1U;
   13f32:	f043 0304 	orr.w	r3, r3, #4
{
   13f36:	4604      	mov	r4, r0
	frnd->pending_req = 1U;
   13f38:	70c3      	strb	r3, [r0, #3]
	k_delayed_work_submit(&frnd->timer, recv_delay(frnd));
   13f3a:	3133      	adds	r1, #51	; 0x33
   13f3c:	3018      	adds	r0, #24
   13f3e:	f7ff ffed 	bl	13f1c <k_delayed_work_submit>
   13f42:	4a07      	ldr	r2, [pc, #28]	; (13f60 <friend_recv_delay+0x34>)
   13f44:	4b07      	ldr	r3, [pc, #28]	; (13f64 <friend_recv_delay+0x38>)
	BT_DBG("Waiting RecvDelay of %d ms", recv_delay(frnd));
   13f46:	4908      	ldr	r1, [pc, #32]	; (13f68 <friend_recv_delay+0x3c>)
   13f48:	4808      	ldr	r0, [pc, #32]	; (13f6c <friend_recv_delay+0x40>)
   13f4a:	1a9b      	subs	r3, r3, r2
   13f4c:	08db      	lsrs	r3, r3, #3
	return (s32_t)frnd->recv_delay + (CONFIG_BT_MESH_FRIEND_RECV_WIN / 5);
   13f4e:	78a2      	ldrb	r2, [r4, #2]
	BT_DBG("Waiting RecvDelay of %d ms", recv_delay(frnd));
   13f50:	019b      	lsls	r3, r3, #6
}
   13f52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	BT_DBG("Waiting RecvDelay of %d ms", recv_delay(frnd));
   13f56:	f043 0304 	orr.w	r3, r3, #4
   13f5a:	3233      	adds	r2, #51	; 0x33
   13f5c:	f010 b853 	b.w	24006 <log_2>
   13f60:	00029830 	.word	0x00029830
   13f64:	00029938 	.word	0x00029938
   13f68:	0002f39a 	.word	0x0002f39a
   13f6c:	0002e8fa 	.word	0x0002e8fa

00013f70 <buf_send_end>:
		frnd->last = NULL;
	}
}

static void buf_send_end(int err, void *user_data)
{
   13f70:	b570      	push	{r4, r5, r6, lr}
   13f72:	4b19      	ldr	r3, [pc, #100]	; (13fd8 <buf_send_end+0x68>)
   13f74:	4c19      	ldr	r4, [pc, #100]	; (13fdc <buf_send_end+0x6c>)
   13f76:	1ae4      	subs	r4, r4, r3
   13f78:	08e4      	lsrs	r4, r4, #3
	struct bt_mesh_friend *frnd = user_data;

	BT_DBG("err %d", err);
   13f7a:	01a4      	lsls	r4, r4, #6
{
   13f7c:	460d      	mov	r5, r1
	BT_DBG("err %d", err);
   13f7e:	f044 0604 	orr.w	r6, r4, #4
{
   13f82:	4602      	mov	r2, r0
	BT_DBG("err %d", err);
   13f84:	4633      	mov	r3, r6
   13f86:	4916      	ldr	r1, [pc, #88]	; (13fe0 <buf_send_end+0x70>)
   13f88:	4816      	ldr	r0, [pc, #88]	; (13fe4 <buf_send_end+0x74>)
   13f8a:	f010 f83c 	bl	24006 <log_2>

	if (frnd->pending_req) {
   13f8e:	78eb      	ldrb	r3, [r5, #3]
   13f90:	075a      	lsls	r2, r3, #29
   13f92:	d506      	bpl.n	13fa2 <buf_send_end+0x32>
		BT_WARN("Another request before previous completed sending");
   13f94:	f044 0102 	orr.w	r1, r4, #2
   13f98:	4813      	ldr	r0, [pc, #76]	; (13fe8 <buf_send_end+0x78>)
	} else {
		/* Friend offer timeout is 1 second */
		k_delayed_work_submit(&frnd->timer, K_SECONDS(1));
		BT_DBG("Waiting for first poll");
	}
}
   13f9a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("Another request before previous completed sending");
   13f9e:	f010 b811 	b.w	23fc4 <log_0>
	if (frnd->established) {
   13fa2:	069b      	lsls	r3, r3, #26
   13fa4:	f105 0018 	add.w	r0, r5, #24
   13fa8:	d50a      	bpl.n	13fc0 <buf_send_end+0x50>
		k_delayed_work_submit(&frnd->timer, frnd->poll_to);
   13faa:	6869      	ldr	r1, [r5, #4]
   13fac:	f7ff ffb6 	bl	13f1c <k_delayed_work_submit>
		BT_DBG("Waiting %u ms for next poll", frnd->poll_to);
   13fb0:	686a      	ldr	r2, [r5, #4]
   13fb2:	490b      	ldr	r1, [pc, #44]	; (13fe0 <buf_send_end+0x70>)
   13fb4:	480d      	ldr	r0, [pc, #52]	; (13fec <buf_send_end+0x7c>)
   13fb6:	4633      	mov	r3, r6
}
   13fb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_DBG("Waiting %u ms for next poll", frnd->poll_to);
   13fbc:	f010 b823 	b.w	24006 <log_2>
		k_delayed_work_submit(&frnd->timer, K_SECONDS(1));
   13fc0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   13fc4:	f7ff ffaa 	bl	13f1c <k_delayed_work_submit>
		BT_DBG("Waiting for first poll");
   13fc8:	4632      	mov	r2, r6
   13fca:	4905      	ldr	r1, [pc, #20]	; (13fe0 <buf_send_end+0x70>)
   13fcc:	4808      	ldr	r0, [pc, #32]	; (13ff0 <buf_send_end+0x80>)
}
   13fce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_DBG("Waiting for first poll");
   13fd2:	f010 b804 	b.w	23fde <log_1>
   13fd6:	bf00      	nop
   13fd8:	00029830 	.word	0x00029830
   13fdc:	00029938 	.word	0x00029938
   13fe0:	0002f45e 	.word	0x0002f45e
   13fe4:	0002e919 	.word	0x0002e919
   13fe8:	0002e924 	.word	0x0002e924
   13fec:	0002e956 	.word	0x0002e956
   13ff0:	0002e976 	.word	0x0002e976

00013ff4 <buf_send_start>:
{
   13ff4:	b538      	push	{r3, r4, r5, lr}
   13ff6:	4614      	mov	r4, r2
   13ff8:	4b0b      	ldr	r3, [pc, #44]	; (14028 <buf_send_start+0x34>)
   13ffa:	4a0c      	ldr	r2, [pc, #48]	; (1402c <buf_send_start+0x38>)
	BT_DBG("err %d", err);
   13ffc:	480c      	ldr	r0, [pc, #48]	; (14030 <buf_send_start+0x3c>)
   13ffe:	1a9b      	subs	r3, r3, r2
   14000:	08db      	lsrs	r3, r3, #3
   14002:	019b      	lsls	r3, r3, #6
   14004:	f043 0304 	orr.w	r3, r3, #4
   14008:	460a      	mov	r2, r1
   1400a:	490a      	ldr	r1, [pc, #40]	; (14034 <buf_send_start+0x40>)
   1400c:	f00f fffb 	bl	24006 <log_2>
	frnd->pending_buf = 0U;
   14010:	78e3      	ldrb	r3, [r4, #3]
   14012:	f36f 03c3 	bfc	r3, #3, #1
	if (!frnd->established) {
   14016:	f013 0520 	ands.w	r5, r3, #32
	frnd->pending_buf = 0U;
   1401a:	70e3      	strb	r3, [r4, #3]
	if (!frnd->established) {
   1401c:	d103      	bne.n	14026 <buf_send_start+0x32>
		net_buf_unref(frnd->last);
   1401e:	6c60      	ldr	r0, [r4, #68]	; 0x44
   14020:	f00b f852 	bl	1f0c8 <net_buf_unref>
		frnd->last = NULL;
   14024:	6465      	str	r5, [r4, #68]	; 0x44
}
   14026:	bd38      	pop	{r3, r4, r5, pc}
   14028:	00029938 	.word	0x00029938
   1402c:	00029830 	.word	0x00029830
   14030:	0002e919 	.word	0x0002e919
   14034:	0002f44f 	.word	0x0002f44f

00014038 <create_friend_pdu.isra.0>:
static struct net_buf *create_friend_pdu(struct bt_mesh_friend *frnd,
   14038:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	buf = bt_mesh_adv_create_from_pool(&friend_buf_pool, adv_alloc,
   1403a:	2300      	movs	r3, #0
   1403c:	9300      	str	r3, [sp, #0]
static struct net_buf *create_friend_pdu(struct bt_mesh_friend *frnd,
   1403e:	4604      	mov	r4, r0
   14040:	460f      	mov	r7, r1
	buf = bt_mesh_adv_create_from_pool(&friend_buf_pool, adv_alloc,
   14042:	4819      	ldr	r0, [pc, #100]	; (140a8 <create_friend_pdu.isra.0+0x70>)
   14044:	4919      	ldr	r1, [pc, #100]	; (140ac <create_friend_pdu.isra.0+0x74>)
   14046:	2308      	movs	r3, #8
   14048:	2201      	movs	r2, #1
   1404a:	f7f8 f843 	bl	c0d4 <bt_mesh_adv_create_from_pool>
	if (!buf) {
   1404e:	4606      	mov	r6, r0
   14050:	b330      	cbz	r0, 140a0 <create_friend_pdu.isra.0+0x68>
	net_buf_add_u8(buf, (info->iv_index & 1) << 7); /* Will be reset in encryption */
   14052:	68a1      	ldr	r1, [r4, #8]
   14054:	f100 0508 	add.w	r5, r0, #8
   14058:	01c9      	lsls	r1, r1, #7
   1405a:	f001 0180 	and.w	r1, r1, #128	; 0x80
   1405e:	4628      	mov	r0, r5
   14060:	f014 feb5 	bl	28dce <net_buf_simple_add_u8>
	if (info->ctl) {
   14064:	f994 3007 	ldrsb.w	r3, [r4, #7]
   14068:	79e1      	ldrb	r1, [r4, #7]
   1406a:	2b00      	cmp	r3, #0
		net_buf_add_u8(buf, info->ttl | 0x80);
   1406c:	f001 017f 	and.w	r1, r1, #127	; 0x7f
   14070:	bfb8      	it	lt
   14072:	f041 0180 	orrlt.w	r1, r1, #128	; 0x80
		net_buf_add_u8(buf, info->ttl);
   14076:	4628      	mov	r0, r5
   14078:	f014 fea9 	bl	28dce <net_buf_simple_add_u8>
	net_buf_add_mem(buf, info->seq, sizeof(info->seq));
   1407c:	2203      	movs	r2, #3
   1407e:	1d21      	adds	r1, r4, #4
   14080:	4628      	mov	r0, r5
   14082:	f014 fe98 	bl	28db6 <net_buf_simple_add_mem>
	net_buf_add_be16(buf, info->src);
   14086:	8821      	ldrh	r1, [r4, #0]
   14088:	4628      	mov	r0, r5
   1408a:	f014 feb0 	bl	28dee <net_buf_simple_add_be16>
	net_buf_add_be16(buf, info->dst);
   1408e:	8861      	ldrh	r1, [r4, #2]
   14090:	4628      	mov	r0, r5
   14092:	f014 feac 	bl	28dee <net_buf_simple_add_be16>
	net_buf_add_mem(buf, sdu->data, sdu->len);
   14096:	88ba      	ldrh	r2, [r7, #4]
   14098:	6839      	ldr	r1, [r7, #0]
   1409a:	4628      	mov	r0, r5
   1409c:	f014 fe8b 	bl	28db6 <net_buf_simple_add_mem>
}
   140a0:	4630      	mov	r0, r6
   140a2:	b003      	add	sp, #12
   140a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   140a6:	bf00      	nop
   140a8:	20007724 	.word	0x20007724
   140ac:	00013e65 	.word	0x00013e65

000140b0 <friend_clear>:
{
   140b0:	b538      	push	{r3, r4, r5, lr}
   140b2:	4a1d      	ldr	r2, [pc, #116]	; (14128 <friend_clear+0x78>)
   140b4:	4b1d      	ldr	r3, [pc, #116]	; (1412c <friend_clear+0x7c>)
	BT_DBG("LPN 0x%04x", frnd->lpn);
   140b6:	491e      	ldr	r1, [pc, #120]	; (14130 <friend_clear+0x80>)
   140b8:	4605      	mov	r5, r0
   140ba:	1a9b      	subs	r3, r3, r2
   140bc:	08db      	lsrs	r3, r3, #3
   140be:	f835 2b18 	ldrh.w	r2, [r5], #24
   140c2:	019b      	lsls	r3, r3, #6
{
   140c4:	4604      	mov	r4, r0
	BT_DBG("LPN 0x%04x", frnd->lpn);
   140c6:	f043 0304 	orr.w	r3, r3, #4
   140ca:	481a      	ldr	r0, [pc, #104]	; (14134 <friend_clear+0x84>)
   140cc:	f00f ff9b 	bl	24006 <log_2>
	k_delayed_work_cancel(&frnd->timer);
   140d0:	4628      	mov	r0, r5
   140d2:	f00e fdd5 	bl	22c80 <k_delayed_work_cancel>
	friend_cred_del(frnd->net_idx, frnd->lpn);
   140d6:	8821      	ldrh	r1, [r4, #0]
   140d8:	89e0      	ldrh	r0, [r4, #14]
   140da:	f7f8 fdfb 	bl	ccd4 <friend_cred_del>
	if (frnd->last) {
   140de:	6c60      	ldr	r0, [r4, #68]	; 0x44
   140e0:	b158      	cbz	r0, 140fa <friend_clear+0x4a>
		if (frnd->pending_buf) {
   140e2:	78e3      	ldrb	r3, [r4, #3]
   140e4:	071b      	lsls	r3, r3, #28
			BT_MESH_ADV(frnd->last)->busy = 0U;
   140e6:	bf41      	itttt	mi
   140e8:	6943      	ldrmi	r3, [r0, #20]
   140ea:	7a1a      	ldrbmi	r2, [r3, #8]
   140ec:	f36f 0282 	bfcmi	r2, #2, #1
   140f0:	721a      	strbmi	r2, [r3, #8]
		net_buf_unref(frnd->last);
   140f2:	f00a ffe9 	bl	1f0c8 <net_buf_unref>
		frnd->last = NULL;
   140f6:	2300      	movs	r3, #0
   140f8:	6463      	str	r3, [r4, #68]	; 0x44
	purge_buffers(&frnd->queue);
   140fa:	f104 0048 	add.w	r0, r4, #72	; 0x48
   140fe:	f013 fe7b 	bl	27df8 <purge_buffers>
		purge_buffers(&seg->queue);
   14102:	f104 0038 	add.w	r0, r4, #56	; 0x38
   14106:	f013 fe77 	bl	27df8 <purge_buffers>
	frnd->fsn = 0U;
   1410a:	78e3      	ldrb	r3, [r4, #3]
		seg->seg_count = 0U;
   1410c:	2100      	movs	r1, #0
	frnd->fsn = 0U;
   1410e:	f023 033d 	bic.w	r3, r3, #61	; 0x3d
		seg->seg_count = 0U;
   14112:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
	frnd->queue_size = 0U;
   14116:	6521      	str	r1, [r4, #80]	; 0x50
	frnd->fsn = 0U;
   14118:	70e3      	strb	r3, [r4, #3]
	(void)memset(frnd->sub_list, 0, sizeof(frnd->sub_list));
   1411a:	f104 0010 	add.w	r0, r4, #16
   1411e:	2206      	movs	r2, #6
}
   14120:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	(void)memset(frnd->sub_list, 0, sizeof(frnd->sub_list));
   14124:	f011 bdeb 	b.w	25cfe <memset>
   14128:	00029830 	.word	0x00029830
   1412c:	00029938 	.word	0x00029938
   14130:	0002f311 	.word	0x0002f311
   14134:	0002e991 	.word	0x0002e991

00014138 <clear_timeout>:
{
   14138:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1413a:	4b1b      	ldr	r3, [pc, #108]	; (141a8 <clear_timeout+0x70>)
   1413c:	4c1b      	ldr	r4, [pc, #108]	; (141ac <clear_timeout+0x74>)
	BT_DBG("LPN 0x%04x (old) Friend 0x%04x", frnd->lpn, frnd->clear.frnd);
   1413e:	491c      	ldr	r1, [pc, #112]	; (141b0 <clear_timeout+0x78>)
   14140:	1ae4      	subs	r4, r4, r3
   14142:	08e4      	lsrs	r4, r4, #3
   14144:	01a4      	lsls	r4, r4, #6
   14146:	f044 0404 	orr.w	r4, r4, #4
   1414a:	f8ad 4000 	strh.w	r4, [sp]
   1414e:	f830 3c04 	ldrh.w	r3, [r0, #-4]
   14152:	f830 2c5c 	ldrh.w	r2, [r0, #-92]
{
   14156:	4605      	mov	r5, r0
	BT_DBG("LPN 0x%04x (old) Friend 0x%04x", frnd->lpn, frnd->clear.frnd);
   14158:	4816      	ldr	r0, [pc, #88]	; (141b4 <clear_timeout+0x7c>)
   1415a:	f00f ff6d 	bl	24038 <log_3>
   1415e:	f015 f958 	bl	29412 <z_impl_k_uptime_ticks>
			return (t * to_hz + off) / from_hz;
   14162:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   14166:	460a      	mov	r2, r1
   14168:	fba0 0103 	umull	r0, r1, r0, r3
   1416c:	fb03 1102 	mla	r1, r3, r2, r1
	duration = k_uptime_get_32() - frnd->clear.start;
   14170:	f855 2c08 	ldr.w	r2, [r5, #-8]
   14174:	0bc3      	lsrs	r3, r0, #15
   14176:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
   1417a:	1a9b      	subs	r3, r3, r2
	if (duration > 2 * frnd->poll_to) {
   1417c:	f855 2c58 	ldr.w	r2, [r5, #-88]
   14180:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
   14184:	d909      	bls.n	1419a <clear_timeout+0x62>
		BT_DBG("Clear Procedure timer expired");
   14186:	490a      	ldr	r1, [pc, #40]	; (141b0 <clear_timeout+0x78>)
   14188:	480b      	ldr	r0, [pc, #44]	; (141b8 <clear_timeout+0x80>)
   1418a:	4622      	mov	r2, r4
   1418c:	f00f ff27 	bl	23fde <log_1>
		frnd->clear.frnd = BT_MESH_ADDR_UNASSIGNED;
   14190:	2300      	movs	r3, #0
   14192:	f825 3c04 	strh.w	r3, [r5, #-4]
}
   14196:	b003      	add	sp, #12
   14198:	bd30      	pop	{r4, r5, pc}
	send_friend_clear(frnd);
   1419a:	f1a5 005c 	sub.w	r0, r5, #92	; 0x5c
}
   1419e:	b003      	add	sp, #12
   141a0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	send_friend_clear(frnd);
   141a4:	f7ff be68 	b.w	13e78 <send_friend_clear>
   141a8:	00029830 	.word	0x00029830
   141ac:	00029938 	.word	0x00029938
   141b0:	0002f3d2 	.word	0x0002f3d2
   141b4:	0002e9a0 	.word	0x0002e9a0
   141b8:	0002e9c3 	.word	0x0002e9c3

000141bc <encode_friend_ctl.isra.0>:
static struct net_buf *encode_friend_ctl(struct bt_mesh_friend *frnd,
   141bc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   141be:	4614      	mov	r4, r2
   141c0:	4b18      	ldr	r3, [pc, #96]	; (14224 <encode_friend_ctl.isra.0+0x68>)
   141c2:	4a19      	ldr	r2, [pc, #100]	; (14228 <encode_friend_ctl.isra.0+0x6c>)
   141c4:	1a9b      	subs	r3, r3, r2
   141c6:	08db      	lsrs	r3, r3, #3
	BT_DBG("LPN 0x%04x", frnd->lpn);
   141c8:	019b      	lsls	r3, r3, #6
   141ca:	8802      	ldrh	r2, [r0, #0]
   141cc:	f043 0304 	orr.w	r3, r3, #4
static struct net_buf *encode_friend_ctl(struct bt_mesh_friend *frnd,
   141d0:	4605      	mov	r5, r0
   141d2:	460e      	mov	r6, r1
	BT_DBG("LPN 0x%04x", frnd->lpn);
   141d4:	4815      	ldr	r0, [pc, #84]	; (1422c <encode_friend_ctl.isra.0+0x70>)
   141d6:	4916      	ldr	r1, [pc, #88]	; (14230 <encode_friend_ctl.isra.0+0x74>)
   141d8:	f00f ff15 	bl	24006 <log_2>
	net_buf_simple_push_u8(sdu, TRANS_CTL_HDR(ctl_op, 0));
   141dc:	4631      	mov	r1, r6
   141de:	4620      	mov	r0, r4
   141e0:	f014 fda6 	bl	28d30 <net_buf_simple_push_u8>
	info.src = bt_mesh_primary_addr();
   141e4:	f7fb fc62 	bl	faac <bt_mesh_primary_addr>
	info.dst = frnd->lpn;
   141e8:	882b      	ldrh	r3, [r5, #0]
	info.src = bt_mesh_primary_addr();
   141ea:	f8ad 0004 	strh.w	r0, [sp, #4]
	info.dst = frnd->lpn;
   141ee:	f8ad 3006 	strh.w	r3, [sp, #6]
	memset(info.seq, 0, sizeof(info.seq));
   141f2:	2203      	movs	r2, #3
	info.ttl = 0U;
   141f4:	2380      	movs	r3, #128	; 0x80
	memset(info.seq, 0, sizeof(info.seq));
   141f6:	2100      	movs	r1, #0
   141f8:	a802      	add	r0, sp, #8
	info.ttl = 0U;
   141fa:	f88d 300b 	strb.w	r3, [sp, #11]
	memset(info.seq, 0, sizeof(info.seq));
   141fe:	f011 fd7e 	bl	25cfe <memset>
	info.iv_index = BT_MESH_NET_IVI_TX;
   14202:	4a0c      	ldr	r2, [pc, #48]	; (14234 <encode_friend_ctl.isra.0+0x78>)
   14204:	6813      	ldr	r3, [r2, #0]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   14206:	f3bf 8f5b 	dmb	ish
   1420a:	6892      	ldr	r2, [r2, #8]
   1420c:	f3bf 8f5b 	dmb	ish
   14210:	f3c2 0280 	ubfx	r2, r2, #2, #1
   14214:	1a9b      	subs	r3, r3, r2
	return create_friend_pdu(frnd, &info, sdu);
   14216:	4621      	mov	r1, r4
   14218:	a801      	add	r0, sp, #4
	info.iv_index = BT_MESH_NET_IVI_TX;
   1421a:	9303      	str	r3, [sp, #12]
	return create_friend_pdu(frnd, &info, sdu);
   1421c:	f7ff ff0c 	bl	14038 <create_friend_pdu.isra.0>
}
   14220:	b004      	add	sp, #16
   14222:	bd70      	pop	{r4, r5, r6, pc}
   14224:	00029938 	.word	0x00029938
   14228:	00029830 	.word	0x00029830
   1422c:	0002e991 	.word	0x0002e991
   14230:	0002f36a 	.word	0x0002f36a
   14234:	20006b48 	.word	0x20006b48

00014238 <friend_queue_prepare_space>:
				   const u64_t *seq_auth, u8_t seg_count)
{
	u32_t total = 0;
	int i;

	if (seg_count > CONFIG_BT_MESH_FRIEND_QUEUE_SIZE) {
   14238:	2b10      	cmp	r3, #16
	return someone_has_space;
}

static bool friend_queue_prepare_space(struct bt_mesh_friend *frnd, u16_t addr,
				       const u64_t *seq_auth, u8_t seg_count)
{
   1423a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1423e:	4605      	mov	r5, r0
   14240:	461f      	mov	r7, r3
	if (seg_count > CONFIG_BT_MESH_FRIEND_QUEUE_SIZE) {
   14242:	d904      	bls.n	1424e <friend_queue_prepare_space+0x16>
	bool pending_segments;
	u8_t avail_space;

	if (!friend_queue_has_space(frnd, addr, seq_auth, seg_count)) {
		return false;
   14244:	f04f 0900 	mov.w	r9, #0

		net_buf_unref(buf);
	}

	return true;
}
   14248:	4648      	mov	r0, r9
   1424a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1424e:	f013 fe17 	bl	27e80 <friend_queue_has_space.part.0>
	if (!friend_queue_has_space(frnd, addr, seq_auth, seg_count)) {
   14252:	4681      	mov	r9, r0
   14254:	2800      	cmp	r0, #0
   14256:	d0f5      	beq.n	14244 <friend_queue_prepare_space+0xc>
	avail_space = CONFIG_BT_MESH_FRIEND_QUEUE_SIZE - frnd->queue_size;
   14258:	6d2c      	ldr	r4, [r5, #80]	; 0x50
	pending_segments = false;
   1425a:	f04f 0800 	mov.w	r8, #0
	avail_space = CONFIG_BT_MESH_FRIEND_QUEUE_SIZE - frnd->queue_size;
   1425e:	f1c4 0410 	rsb	r4, r4, #16
   14262:	b2e4      	uxtb	r4, r4
		buf->frags = NULL;
   14264:	46c2      	mov	sl, r8
	while (pending_segments || avail_space < seg_count) {
   14266:	f1b8 0f00 	cmp.w	r8, #0
   1426a:	d101      	bne.n	14270 <friend_queue_prepare_space+0x38>
   1426c:	42bc      	cmp	r4, r7
   1426e:	d2eb      	bcs.n	14248 <friend_queue_prepare_space+0x10>
Z_GENLIST_IS_EMPTY(slist)
   14270:	6cae      	ldr	r6, [r5, #72]	; 0x48
Z_GENLIST_GET(slist, snode)
   14272:	b956      	cbnz	r6, 1428a <friend_queue_prepare_space+0x52>
   14274:	4b10      	ldr	r3, [pc, #64]	; (142b8 <friend_queue_prepare_space+0x80>)
   14276:	4911      	ldr	r1, [pc, #68]	; (142bc <friend_queue_prepare_space+0x84>)
			BT_ERR("Unable to free up enough buffers");
   14278:	4811      	ldr	r0, [pc, #68]	; (142c0 <friend_queue_prepare_space+0x88>)
   1427a:	1ac9      	subs	r1, r1, r3
   1427c:	08c9      	lsrs	r1, r1, #3
   1427e:	0189      	lsls	r1, r1, #6
   14280:	f041 0101 	orr.w	r1, r1, #1
   14284:	f00f fe9e 	bl	23fc4 <log_0>
			return false;
   14288:	e7dc      	b.n	14244 <friend_queue_prepare_space+0xc>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1428a:	6cea      	ldr	r2, [r5, #76]	; 0x4c
   1428c:	6833      	ldr	r3, [r6, #0]
	list->head = node;
   1428e:	64ab      	str	r3, [r5, #72]	; 0x48
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   14290:	4296      	cmp	r6, r2
   14292:	d100      	bne.n	14296 <friend_queue_prepare_space+0x5e>
	list->tail = node;
   14294:	64eb      	str	r3, [r5, #76]	; 0x4c
		frnd->queue_size--;
   14296:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   14298:	3b01      	subs	r3, #1
   1429a:	652b      	str	r3, [r5, #80]	; 0x50
		pending_segments = (buf->flags & NET_BUF_FRAGS);
   1429c:	7972      	ldrb	r2, [r6, #5]
		buf->frags = NULL;
   1429e:	f8c6 a000 	str.w	sl, [r6]
		pending_segments = (buf->flags & NET_BUF_FRAGS);
   142a2:	f002 0801 	and.w	r8, r2, #1
		buf->flags &= ~NET_BUF_FRAGS;
   142a6:	f022 0201 	bic.w	r2, r2, #1
		avail_space++;
   142aa:	3401      	adds	r4, #1
		buf->flags &= ~NET_BUF_FRAGS;
   142ac:	7172      	strb	r2, [r6, #5]
		net_buf_unref(buf);
   142ae:	4630      	mov	r0, r6
		avail_space++;
   142b0:	b2e4      	uxtb	r4, r4
		net_buf_unref(buf);
   142b2:	f00a ff09 	bl	1f0c8 <net_buf_unref>
   142b6:	e7d6      	b.n	14266 <friend_queue_prepare_space+0x2e>
   142b8:	00029830 	.word	0x00029830
   142bc:	00029938 	.word	0x00029938
   142c0:	0002e9e5 	.word	0x0002e9e5

000142c4 <enqueue_friend_pdu>:
{
   142c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   142c8:	4d2d      	ldr	r5, [pc, #180]	; (14380 <enqueue_friend_pdu+0xbc>)
   142ca:	9e08      	ldr	r6, [sp, #32]
   142cc:	4699      	mov	r9, r3
   142ce:	4b2d      	ldr	r3, [pc, #180]	; (14384 <enqueue_friend_pdu+0xc0>)
   142d0:	1aed      	subs	r5, r5, r3
   142d2:	08ed      	lsrs	r5, r5, #3
	BT_DBG("type %u", type);
   142d4:	01ad      	lsls	r5, r5, #6
{
   142d6:	460f      	mov	r7, r1
   142d8:	4604      	mov	r4, r0
   142da:	4690      	mov	r8, r2
	BT_DBG("type %u", type);
   142dc:	482a      	ldr	r0, [pc, #168]	; (14388 <enqueue_friend_pdu+0xc4>)
   142de:	460a      	mov	r2, r1
   142e0:	f045 0304 	orr.w	r3, r5, #4
   142e4:	4929      	ldr	r1, [pc, #164]	; (1438c <enqueue_friend_pdu+0xc8>)
   142e6:	f00f fe8e 	bl	24006 <log_2>
	if (type == BT_MESH_FRIEND_PDU_SINGLE) {
   142ea:	b94f      	cbnz	r7, 14300 <enqueue_friend_pdu+0x3c>
	net_buf_slist_put(&frnd->queue, buf);
   142ec:	4631      	mov	r1, r6
   142ee:	f104 0048 	add.w	r0, r4, #72	; 0x48
   142f2:	f00a fe0f 	bl	1ef14 <net_buf_slist_put>
	frnd->queue_size++;
   142f6:	6d23      	ldr	r3, [r4, #80]	; 0x50
   142f8:	3301      	adds	r3, #1
   142fa:	6523      	str	r3, [r4, #80]	; 0x50
}
   142fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	u16_t seq_zero = (((buf->data[10] << 8 | buf->data[11]) >> 2) & TRANS_SEQ_ZERO_MASK);
   14300:	68b3      	ldr	r3, [r6, #8]
   14302:	895a      	ldrh	r2, [r3, #10]
		struct bt_mesh_friend_seg *seg = &frnd->seg[i];
   14304:	f104 0a38 	add.w	sl, r4, #56	; 0x38
	u16_t seq_zero = (((buf->data[10] << 8 | buf->data[11]) >> 2) & TRANS_SEQ_ZERO_MASK);
   14308:	ba52      	rev16	r2, r2
		if (is_seg(seg, src, seq_zero)) {
   1430a:	f3c2 028c 	ubfx	r2, r2, #2, #13
   1430e:	4641      	mov	r1, r8
   14310:	4650      	mov	r0, sl
   14312:	f013 fd85 	bl	27e20 <is_seg>
   14316:	b9e8      	cbnz	r0, 14354 <enqueue_friend_pdu+0x90>
		if (!unassigned && !sys_slist_peek_head(&seg->queue)) {
   14318:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1431a:	b9f3      	cbnz	r3, 1435a <enqueue_friend_pdu+0x96>
	if (unassigned) {
   1431c:	f1ba 0f00 	cmp.w	sl, #0
   14320:	d01b      	beq.n	1435a <enqueue_friend_pdu+0x96>
		unassigned->seg_count = seg_count;
   14322:	f884 9040 	strb.w	r9, [r4, #64]	; 0x40
	net_buf_slist_put(&seg->queue, buf);
   14326:	4631      	mov	r1, r6
   14328:	4650      	mov	r0, sl
   1432a:	f00a fdf3 	bl	1ef14 <net_buf_slist_put>
	if (type == BT_MESH_FRIEND_PDU_COMPLETE) {
   1432e:	2f02      	cmp	r7, #2
   14330:	d120      	bne.n	14374 <enqueue_friend_pdu+0xb0>
Z_GENLIST_APPEND_LIST(slist, snode)
   14332:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
Z_GENLIST_MERGE_LIST(slist, snode)
   14334:	e9d4 210e 	ldrd	r2, r1, [r4, #56]	; 0x38
Z_GENLIST_APPEND_LIST(slist, snode)
   14338:	b9d3      	cbnz	r3, 14370 <enqueue_friend_pdu+0xac>
	list->head = node;
   1433a:	64a2      	str	r2, [r4, #72]	; 0x48
		frnd->queue_size += seg->seg_count;
   1433c:	6d22      	ldr	r2, [r4, #80]	; 0x50
	list->tail = node;
   1433e:	64e1      	str	r1, [r4, #76]	; 0x4c
   14340:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
	list->head = NULL;
   14344:	2300      	movs	r3, #0
   14346:	440a      	add	r2, r1
	list->tail = NULL;
   14348:	e9c4 330e 	strd	r3, r3, [r4, #56]	; 0x38
   1434c:	6522      	str	r2, [r4, #80]	; 0x50
		seg->seg_count = 0U;
   1434e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
   14352:	e7d3      	b.n	142fc <enqueue_friend_pdu+0x38>
	if (!seg) {
   14354:	f1ba 0f00 	cmp.w	sl, #0
   14358:	d1e5      	bne.n	14326 <enqueue_friend_pdu+0x62>
		BT_ERR("No free friend segment RX contexts for 0x%04x", src);
   1435a:	480d      	ldr	r0, [pc, #52]	; (14390 <enqueue_friend_pdu+0xcc>)
   1435c:	f045 0201 	orr.w	r2, r5, #1
   14360:	4641      	mov	r1, r8
   14362:	f00f fe3c 	bl	23fde <log_1>
		net_buf_unref(buf);
   14366:	4630      	mov	r0, r6
}
   14368:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		net_buf_unref(buf);
   1436c:	f00a beac 	b.w	1f0c8 <net_buf_unref>
	parent->next = child;
   14370:	601a      	str	r2, [r3, #0]
}
   14372:	e7e3      	b.n	1433c <enqueue_friend_pdu+0x78>
		buf->flags |= NET_BUF_FRAGS;
   14374:	7973      	ldrb	r3, [r6, #5]
   14376:	f043 0301 	orr.w	r3, r3, #1
   1437a:	7173      	strb	r3, [r6, #5]
   1437c:	e7be      	b.n	142fc <enqueue_friend_pdu+0x38>
   1437e:	bf00      	nop
   14380:	00029938 	.word	0x00029938
   14384:	00029830 	.word	0x00029830
   14388:	0002ea06 	.word	0x0002ea06
   1438c:	0002f43c 	.word	0x0002f43c
   14390:	0002ea12 	.word	0x0002ea12

00014394 <encrypt_friend_pdu>:
{
   14394:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14398:	4604      	mov	r4, r0
   1439a:	b096      	sub	sp, #88	; 0x58
	struct bt_mesh_subnet *sub = bt_mesh_subnet_get(frnd->net_idx);
   1439c:	89c0      	ldrh	r0, [r0, #14]
{
   1439e:	460d      	mov	r5, r1
   143a0:	4616      	mov	r6, r2
	struct bt_mesh_subnet *sub = bt_mesh_subnet_get(frnd->net_idx);
   143a2:	f7f8 fb23 	bl	c9ec <bt_mesh_subnet_get>
   143a6:	4603      	mov	r3, r0
	if (master_cred) {
   143a8:	2e00      	cmp	r6, #0
   143aa:	f000 8092 	beq.w	144d2 <encrypt_friend_pdu+0x13e>
		enc = sub->keys[sub->kr_flag].enc;
   143ae:	7f82      	ldrb	r2, [r0, #30]
   143b0:	2059      	movs	r0, #89	; 0x59
   143b2:	4350      	muls	r0, r2
   143b4:	f100 0241 	add.w	r2, r0, #65	; 0x41
   143b8:	441a      	add	r2, r3
   143ba:	9207      	str	r2, [sp, #28]
		priv = sub->keys[sub->kr_flag].privacy;
   143bc:	f100 0269 	add.w	r2, r0, #105	; 0x69
   143c0:	441a      	add	r2, r3
		nid = sub->keys[sub->kr_flag].nid;
   143c2:	4403      	add	r3, r0
		priv = sub->keys[sub->kr_flag].privacy;
   143c4:	9208      	str	r2, [sp, #32]
		nid = sub->keys[sub->kr_flag].nid;
   143c6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
   143ca:	f88d 301b 	strb.w	r3, [sp, #27]
	src = sys_get_be16(&buf->data[5]);
   143ce:	462f      	mov	r7, r5
   143d0:	f857 3f08 	ldr.w	r3, [r7, #8]!
	return ((u16_t)src[0] << 8) | src[1];
   143d4:	7958      	ldrb	r0, [r3, #5]
   143d6:	799b      	ldrb	r3, [r3, #6]
	if (bt_mesh_elem_find(src)) {
   143d8:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
   143dc:	f7fb fb6c 	bl	fab8 <bt_mesh_elem_find>
   143e0:	2800      	cmp	r0, #0
   143e2:	f000 80f8 	beq.w	145d6 <encrypt_friend_pdu+0x242>
		if (FRIEND_ADV(buf)->app_idx != BT_MESH_KEY_UNUSED) {
   143e6:	696b      	ldr	r3, [r5, #20]
   143e8:	899e      	ldrh	r6, [r3, #12]
   143ea:	f64f 73ff 	movw	r3, #65535	; 0xffff
   143ee:	429e      	cmp	r6, r3
   143f0:	f000 80c0 	beq.w	14574 <encrypt_friend_pdu+0x1e0>
	meta->subnet = bt_mesh_subnet_get(frnd->net_idx);
   143f4:	89e0      	ldrh	r0, [r4, #14]
   143f6:	f7f8 faf9 	bl	c9ec <bt_mesh_subnet_get>
	meta->is_dev_key = BT_MESH_IS_DEV_KEY(app_idx);
   143fa:	1cf3      	adds	r3, r6, #3
   143fc:	b29b      	uxth	r3, r3
   143fe:	2b01      	cmp	r3, #1
   14400:	bf8c      	ite	hi
   14402:	2300      	movhi	r3, #0
   14404:	2301      	movls	r3, #1
	meta->subnet = bt_mesh_subnet_get(frnd->net_idx);
   14406:	9013      	str	r0, [sp, #76]	; 0x4c
	bt_mesh_net_header_parse(&buf->b, &meta->net);
   14408:	a90c      	add	r1, sp, #48	; 0x30
   1440a:	4638      	mov	r0, r7
	meta->is_dev_key = BT_MESH_IS_DEV_KEY(app_idx);
   1440c:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
	bt_mesh_net_header_parse(&buf->b, &meta->net);
   14410:	f7f9 f85e 	bl	d4d0 <bt_mesh_net_header_parse>
	err = bt_mesh_app_key_get(meta->subnet, app_idx, meta->net.ctx.recv_dst,
   14414:	f10d 0351 	add.w	r3, sp, #81	; 0x51
   14418:	9300      	str	r3, [sp, #0]
   1441a:	f8bd 203a 	ldrh.w	r2, [sp, #58]	; 0x3a
   1441e:	9813      	ldr	r0, [sp, #76]	; 0x4c
   14420:	ab12      	add	r3, sp, #72	; 0x48
   14422:	4631      	mov	r1, r6
   14424:	f7fa ff3a 	bl	f29c <bt_mesh_app_key_get>
	if (err) {
   14428:	4604      	mov	r4, r0
   1442a:	2800      	cmp	r0, #0
   1442c:	d14d      	bne.n	144ca <encrypt_friend_pdu+0x136>
	if (BT_MESH_ADDR_IS_VIRTUAL(meta->net.ctx.recv_dst)) {
   1442e:	f8bd 003a 	ldrh.w	r0, [sp, #58]	; 0x3a
   14432:	f480 4300 	eor.w	r3, r0, #32768	; 0x8000
   14436:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   1443a:	d262      	bcs.n	14502 <encrypt_friend_pdu+0x16e>
		meta->ad = bt_mesh_label_uuid_get(meta->net.ctx.recv_dst);
   1443c:	f7fe f9ba 	bl	127b4 <bt_mesh_label_uuid_get>
   14440:	9015      	str	r0, [sp, #84]	; 0x54
		if (!meta->ad) {
   14442:	2800      	cmp	r0, #0
   14444:	d05a      	beq.n	144fc <encrypt_friend_pdu+0x168>
	if (meta.net.seq == bt_mesh.seq) {
   14446:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 14624 <encrypt_friend_pdu+0x290>
   1444a:	9a10      	ldr	r2, [sp, #64]	; 0x40
   1444c:	f8d8 3004 	ldr.w	r3, [r8, #4]
   14450:	429a      	cmp	r2, r3
   14452:	f000 808f 	beq.w	14574 <encrypt_friend_pdu+0x1e0>
	net_buf_simple_clone(&buf->b, &sdu);
   14456:	ae09      	add	r6, sp, #36	; 0x24
   14458:	4631      	mov	r1, r6
   1445a:	4638      	mov	r0, r7
   1445c:	f014 fc59 	bl	28d12 <net_buf_simple_clone>
	net_buf_simple_pull(&sdu, 10);
   14460:	210a      	movs	r1, #10
   14462:	4630      	mov	r0, r6
   14464:	f00a fef6 	bl	1f254 <net_buf_simple_pull>
	sdu.len -= 4;
   14468:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
				   meta->ad, meta->net.ctx.addr,
   1446c:	9c15      	ldr	r4, [sp, #84]	; 0x54
	return bt_mesh_app_decrypt(meta->key, meta->is_dev_key, 0, &sdu, &sdu,
   1446e:	f8bd c038 	ldrh.w	ip, [sp, #56]	; 0x38
   14472:	f8bd e03a 	ldrh.w	lr, [sp, #58]	; 0x3a
   14476:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
   1447a:	9812      	ldr	r0, [sp, #72]	; 0x48
   1447c:	f89d 1050 	ldrb.w	r1, [sp, #80]	; 0x50
	sdu.len -= 4;
   14480:	3b04      	subs	r3, #4
   14482:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
				   BT_MESH_NET_IVI_TX);
   14486:	f8d8 3000 	ldr.w	r3, [r8]
   1448a:	f3bf 8f5b 	dmb	ish
   1448e:	f8d8 2008 	ldr.w	r2, [r8, #8]
   14492:	f3bf 8f5b 	dmb	ish
   14496:	f3c2 0280 	ubfx	r2, r2, #2, #1
	return bt_mesh_app_decrypt(meta->key, meta->is_dev_key, 0, &sdu, &sdu,
   1449a:	1a9b      	subs	r3, r3, r2
   1449c:	e9cd 9304 	strd	r9, r3, [sp, #16]
   144a0:	e9cd 6400 	strd	r6, r4, [sp]
   144a4:	e9cd ce02 	strd	ip, lr, [sp, #8]
   144a8:	4633      	mov	r3, r6
   144aa:	2200      	movs	r2, #0
   144ac:	f013 f8b7 	bl	2761e <bt_mesh_app_decrypt>
	if (err) {
   144b0:	4604      	mov	r4, r0
   144b2:	b340      	cbz	r0, 14506 <encrypt_friend_pdu+0x172>
   144b4:	4a56      	ldr	r2, [pc, #344]	; (14610 <encrypt_friend_pdu+0x27c>)
   144b6:	4b57      	ldr	r3, [pc, #348]	; (14614 <encrypt_friend_pdu+0x280>)
   144b8:	1ad2      	subs	r2, r2, r3
   144ba:	08d2      	lsrs	r2, r2, #3
		BT_WARN("Decryption failed! %d", err);
   144bc:	0192      	lsls	r2, r2, #6
   144be:	4601      	mov	r1, r0
   144c0:	4855      	ldr	r0, [pc, #340]	; (14618 <encrypt_friend_pdu+0x284>)
   144c2:	f042 0202 	orr.w	r2, r2, #2
		BT_WARN("Re-encryption failed! %d", err);
   144c6:	f00f fd8a 	bl	23fde <log_1>
}
   144ca:	4620      	mov	r0, r4
   144cc:	b016      	add	sp, #88	; 0x58
   144ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (friend_cred_get(sub, frnd->lpn, &nid, &enc, &priv)) {
   144d2:	ab08      	add	r3, sp, #32
   144d4:	9300      	str	r3, [sp, #0]
   144d6:	8821      	ldrh	r1, [r4, #0]
   144d8:	ab07      	add	r3, sp, #28
   144da:	f10d 021b 	add.w	r2, sp, #27
   144de:	f7f8 fc17 	bl	cd10 <friend_cred_get>
   144e2:	2800      	cmp	r0, #0
   144e4:	f43f af73 	beq.w	143ce <encrypt_friend_pdu+0x3a>
   144e8:	4949      	ldr	r1, [pc, #292]	; (14610 <encrypt_friend_pdu+0x27c>)
   144ea:	4b4a      	ldr	r3, [pc, #296]	; (14614 <encrypt_friend_pdu+0x280>)
			BT_ERR("friend_cred_get failed");
   144ec:	484b      	ldr	r0, [pc, #300]	; (1461c <encrypt_friend_pdu+0x288>)
   144ee:	1ac9      	subs	r1, r1, r3
   144f0:	08c9      	lsrs	r1, r1, #3
   144f2:	0189      	lsls	r1, r1, #6
   144f4:	f041 0101 	orr.w	r1, r1, #1
   144f8:	f00f fd64 	bl	23fc4 <log_0>
			return -ENOENT;
   144fc:	f06f 0401 	mvn.w	r4, #1
			if (err) {
   14500:	e7e3      	b.n	144ca <encrypt_friend_pdu+0x136>
		meta->ad = NULL;
   14502:	9415      	str	r4, [sp, #84]	; 0x54
	if (err) {
   14504:	e79f      	b.n	14446 <encrypt_friend_pdu+0xb2>
	net_buf_simple_clone(&buf->b, &sdu);
   14506:	4631      	mov	r1, r6
   14508:	4638      	mov	r0, r7
   1450a:	f014 fc02 	bl	28d12 <net_buf_simple_clone>
	net_buf_simple_pull(&sdu, 10);
   1450e:	210a      	movs	r1, #10
   14510:	4630      	mov	r0, r6
   14512:	f00a fe9f 	bl	1f254 <net_buf_simple_pull>
	sdu.len -= 4;
   14516:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
				   meta->ad, meta->net.ctx.addr,
   1451a:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
	return bt_mesh_app_encrypt(meta->key, meta->is_dev_key, 0, &sdu,
   1451e:	f8bd e038 	ldrh.w	lr, [sp, #56]	; 0x38
   14522:	f8bd 903a 	ldrh.w	r9, [sp, #58]	; 0x3a
   14526:	9812      	ldr	r0, [sp, #72]	; 0x48
   14528:	f89d 1050 	ldrb.w	r1, [sp, #80]	; 0x50
	sdu.len -= 4;
   1452c:	3b04      	subs	r3, #4
   1452e:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
				   BT_MESH_NET_IVI_TX);
   14532:	e9d8 3a00 	ldrd	r3, sl, [r8]
   14536:	f3bf 8f5b 	dmb	ish
   1453a:	f8d8 2008 	ldr.w	r2, [r8, #8]
   1453e:	f3bf 8f5b 	dmb	ish
   14542:	f3c2 0280 	ubfx	r2, r2, #2, #1
	return bt_mesh_app_encrypt(meta->key, meta->is_dev_key, 0, &sdu,
   14546:	1a9b      	subs	r3, r3, r2
   14548:	e9cd a303 	strd	sl, r3, [sp, #12]
   1454c:	4622      	mov	r2, r4
   1454e:	e9cd e901 	strd	lr, r9, [sp, #4]
   14552:	f8cd c000 	str.w	ip, [sp]
   14556:	4633      	mov	r3, r6
   14558:	f013 f81b 	bl	27592 <bt_mesh_app_encrypt>
	if (err) {
   1455c:	4604      	mov	r4, r0
   1455e:	b148      	cbz	r0, 14574 <encrypt_friend_pdu+0x1e0>
   14560:	4a2b      	ldr	r2, [pc, #172]	; (14610 <encrypt_friend_pdu+0x27c>)
   14562:	4b2c      	ldr	r3, [pc, #176]	; (14614 <encrypt_friend_pdu+0x280>)
   14564:	1ad2      	subs	r2, r2, r3
   14566:	08d2      	lsrs	r2, r2, #3
		BT_WARN("Re-encryption failed! %d", err);
   14568:	0192      	lsls	r2, r2, #6
   1456a:	4601      	mov	r1, r0
   1456c:	f042 0202 	orr.w	r2, r2, #2
   14570:	482b      	ldr	r0, [pc, #172]	; (14620 <encrypt_friend_pdu+0x28c>)
   14572:	e7a8      	b.n	144c6 <encrypt_friend_pdu+0x132>
		seq = bt_mesh_next_seq();
   14574:	f7f8 fe24 	bl	d1c0 <bt_mesh_next_seq>
		sys_put_be24(seq, &buf->data[2]);
   14578:	68ab      	ldr	r3, [r5, #8]
	dst[0] = val >> 16;
   1457a:	0c02      	lsrs	r2, r0, #16
   1457c:	709a      	strb	r2, [r3, #2]
	dst[0] = val >> 8;
   1457e:	f3c0 2207 	ubfx	r2, r0, #8, #8
   14582:	70da      	strb	r2, [r3, #3]
	dst[1] = val;
   14584:	7118      	strb	r0, [r3, #4]
		iv_index = BT_MESH_NET_IVI_TX;
   14586:	4b27      	ldr	r3, [pc, #156]	; (14624 <encrypt_friend_pdu+0x290>)
   14588:	681c      	ldr	r4, [r3, #0]
   1458a:	f3bf 8f5b 	dmb	ish
   1458e:	689b      	ldr	r3, [r3, #8]
   14590:	f3bf 8f5b 	dmb	ish
   14594:	f3c3 0380 	ubfx	r3, r3, #2, #1
   14598:	1ae4      	subs	r4, r4, r3
		FRIEND_ADV(buf)->app_idx = BT_MESH_KEY_UNUSED;
   1459a:	696b      	ldr	r3, [r5, #20]
   1459c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   145a0:	819a      	strh	r2, [r3, #12]
	buf->data[0] = (nid | (iv_index & 1) << 7);
   145a2:	f89d 301b 	ldrb.w	r3, [sp, #27]
   145a6:	68aa      	ldr	r2, [r5, #8]
   145a8:	ea43 13c4 	orr.w	r3, r3, r4, lsl #7
   145ac:	7013      	strb	r3, [r2, #0]
	if (bt_mesh_net_encrypt(enc, &buf->b, iv_index, false)) {
   145ae:	9807      	ldr	r0, [sp, #28]
   145b0:	2300      	movs	r3, #0
   145b2:	4622      	mov	r2, r4
   145b4:	4639      	mov	r1, r7
   145b6:	f012 ff48 	bl	2744a <bt_mesh_net_encrypt>
   145ba:	b1b0      	cbz	r0, 145ea <encrypt_friend_pdu+0x256>
   145bc:	4914      	ldr	r1, [pc, #80]	; (14610 <encrypt_friend_pdu+0x27c>)
   145be:	4b15      	ldr	r3, [pc, #84]	; (14614 <encrypt_friend_pdu+0x280>)
		BT_ERR("Encrypting failed");
   145c0:	4819      	ldr	r0, [pc, #100]	; (14628 <encrypt_friend_pdu+0x294>)
   145c2:	1ac9      	subs	r1, r1, r3
   145c4:	08c9      	lsrs	r1, r1, #3
   145c6:	0189      	lsls	r1, r1, #6
   145c8:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Obfuscating failed");
   145cc:	f00f fcfa 	bl	23fc4 <log_0>
		return -EINVAL;
   145d0:	f06f 0415 	mvn.w	r4, #21
   145d4:	e779      	b.n	144ca <encrypt_friend_pdu+0x136>
		iv_index = (bt_mesh.iv_index - ((bt_mesh.iv_index & 1) != ivi));
   145d6:	4b13      	ldr	r3, [pc, #76]	; (14624 <encrypt_friend_pdu+0x290>)
   145d8:	681c      	ldr	r4, [r3, #0]
		u8_t ivi = (buf->data[0] >> 7);
   145da:	68ab      	ldr	r3, [r5, #8]
   145dc:	781a      	ldrb	r2, [r3, #0]
		iv_index = (bt_mesh.iv_index - ((bt_mesh.iv_index & 1) != ivi));
   145de:	f004 0301 	and.w	r3, r4, #1
   145e2:	ea83 13d2 	eor.w	r3, r3, r2, lsr #7
   145e6:	1ae4      	subs	r4, r4, r3
   145e8:	e7db      	b.n	145a2 <encrypt_friend_pdu+0x20e>
	if (bt_mesh_net_obfuscate(buf->data, iv_index, priv)) {
   145ea:	4621      	mov	r1, r4
   145ec:	9a08      	ldr	r2, [sp, #32]
   145ee:	68a8      	ldr	r0, [r5, #8]
   145f0:	f7fa fffc 	bl	f5ec <bt_mesh_net_obfuscate>
   145f4:	4604      	mov	r4, r0
   145f6:	2800      	cmp	r0, #0
   145f8:	f43f af67 	beq.w	144ca <encrypt_friend_pdu+0x136>
   145fc:	4904      	ldr	r1, [pc, #16]	; (14610 <encrypt_friend_pdu+0x27c>)
   145fe:	4b05      	ldr	r3, [pc, #20]	; (14614 <encrypt_friend_pdu+0x280>)
		BT_ERR("Obfuscating failed");
   14600:	480a      	ldr	r0, [pc, #40]	; (1462c <encrypt_friend_pdu+0x298>)
   14602:	1ac9      	subs	r1, r1, r3
   14604:	08c9      	lsrs	r1, r1, #3
   14606:	0189      	lsls	r1, r1, #6
   14608:	f041 0101 	orr.w	r1, r1, #1
   1460c:	e7de      	b.n	145cc <encrypt_friend_pdu+0x238>
   1460e:	bf00      	nop
   14610:	00029938 	.word	0x00029938
   14614:	00029830 	.word	0x00029830
   14618:	0002ea57 	.word	0x0002ea57
   1461c:	0002ea40 	.word	0x0002ea40
   14620:	0002ea6d 	.word	0x0002ea6d
   14624:	20006b48 	.word	0x20006b48
   14628:	0002ea86 	.word	0x0002ea86
   1462c:	0002ea98 	.word	0x0002ea98

00014630 <enqueue_sub_cfm>:
{
   14630:	b5f0      	push	{r4, r5, r6, r7, lr}
   14632:	b087      	sub	sp, #28
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*cfm));
   14634:	ab02      	add	r3, sp, #8
   14636:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   1463a:	e9cd 2304 	strd	r2, r3, [sp, #16]
   1463e:	9303      	str	r3, [sp, #12]
   14640:	4d1f      	ldr	r5, [pc, #124]	; (146c0 <enqueue_sub_cfm+0x90>)
   14642:	4b20      	ldr	r3, [pc, #128]	; (146c4 <enqueue_sub_cfm+0x94>)
   14644:	1aed      	subs	r5, r5, r3
   14646:	08ed      	lsrs	r5, r5, #3
	BT_DBG("lpn 0x%04x xact 0x%02x", frnd->lpn, xact);
   14648:	01ad      	lsls	r5, r5, #6
   1464a:	f045 0704 	orr.w	r7, r5, #4
   1464e:	f8ad 7000 	strh.w	r7, [sp]
   14652:	8802      	ldrh	r2, [r0, #0]
   14654:	460b      	mov	r3, r1
{
   14656:	460e      	mov	r6, r1
   14658:	4604      	mov	r4, r0
	BT_DBG("lpn 0x%04x xact 0x%02x", frnd->lpn, xact);
   1465a:	491b      	ldr	r1, [pc, #108]	; (146c8 <enqueue_sub_cfm+0x98>)
   1465c:	481b      	ldr	r0, [pc, #108]	; (146cc <enqueue_sub_cfm+0x9c>)
   1465e:	f00f fceb 	bl	24038 <log_3>
	net_buf_simple_reserve(&sdu, 1);
   14662:	2101      	movs	r1, #1
   14664:	a803      	add	r0, sp, #12
   14666:	f00a fc2b 	bl	1eec0 <net_buf_simple_reserve>
	cfm = net_buf_simple_add(&sdu, sizeof(*cfm));
   1466a:	2101      	movs	r1, #1
   1466c:	a803      	add	r0, sp, #12
   1466e:	f00a fe33 	bl	1f2d8 <net_buf_simple_add>
	buf = encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_SUB_CFM, &sdu);
   14672:	aa03      	add	r2, sp, #12
	cfm->xact = xact;
   14674:	7006      	strb	r6, [r0, #0]
	buf = encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_SUB_CFM, &sdu);
   14676:	2109      	movs	r1, #9
   14678:	4620      	mov	r0, r4
   1467a:	f7ff fd9f 	bl	141bc <encode_friend_ctl.isra.0>
	if (!buf) {
   1467e:	4606      	mov	r6, r0
   14680:	b930      	cbnz	r0, 14690 <enqueue_sub_cfm+0x60>
		BT_ERR("Unable to encode Subscription List Confirmation");
   14682:	4813      	ldr	r0, [pc, #76]	; (146d0 <enqueue_sub_cfm+0xa0>)
   14684:	f045 0101 	orr.w	r1, r5, #1
   14688:	f00f fc9c 	bl	23fc4 <log_0>
}
   1468c:	b007      	add	sp, #28
   1468e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (encrypt_friend_pdu(frnd, buf, false)) {
   14690:	4601      	mov	r1, r0
   14692:	2200      	movs	r2, #0
   14694:	4620      	mov	r0, r4
   14696:	f7ff fe7d 	bl	14394 <encrypt_friend_pdu>
   1469a:	2800      	cmp	r0, #0
   1469c:	d1f6      	bne.n	1468c <enqueue_sub_cfm+0x5c>
	if (frnd->last) {
   1469e:	6c63      	ldr	r3, [r4, #68]	; 0x44
   146a0:	b13b      	cbz	r3, 146b2 <enqueue_sub_cfm+0x82>
		BT_DBG("Discarding last PDU");
   146a2:	480c      	ldr	r0, [pc, #48]	; (146d4 <enqueue_sub_cfm+0xa4>)
   146a4:	4908      	ldr	r1, [pc, #32]	; (146c8 <enqueue_sub_cfm+0x98>)
   146a6:	463a      	mov	r2, r7
   146a8:	f00f fc99 	bl	23fde <log_1>
		net_buf_unref(frnd->last);
   146ac:	6c60      	ldr	r0, [r4, #68]	; 0x44
   146ae:	f00a fd0b 	bl	1f0c8 <net_buf_unref>
	frnd->send_last = 1U;
   146b2:	78e3      	ldrb	r3, [r4, #3]
	frnd->last = buf;
   146b4:	6466      	str	r6, [r4, #68]	; 0x44
	frnd->send_last = 1U;
   146b6:	f043 0302 	orr.w	r3, r3, #2
   146ba:	70e3      	strb	r3, [r4, #3]
   146bc:	e7e6      	b.n	1468c <enqueue_sub_cfm+0x5c>
   146be:	bf00      	nop
   146c0:	00029938 	.word	0x00029938
   146c4:	00029830 	.word	0x00029830
   146c8:	0002f38a 	.word	0x0002f38a
   146cc:	0002eaab 	.word	0x0002eaab
   146d0:	0002eac6 	.word	0x0002eac6
   146d4:	0002eaf6 	.word	0x0002eaf6

000146d8 <friend_timeout>:
{
   146d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__ASSERT_NO_MSG(frnd->pending_buf == 0U);
   146dc:	f810 3c15 	ldrb.w	r3, [r0, #-21]
   146e0:	0719      	lsls	r1, r3, #28
{
   146e2:	b087      	sub	sp, #28
   146e4:	4604      	mov	r4, r0
	struct bt_mesh_friend *frnd = CONTAINER_OF(work, struct bt_mesh_friend,
   146e6:	f1a0 0818 	sub.w	r8, r0, #24
	__ASSERT_NO_MSG(frnd->pending_buf == 0U);
   146ea:	d50b      	bpl.n	14704 <friend_timeout+0x2c>
   146ec:	495d      	ldr	r1, [pc, #372]	; (14864 <friend_timeout+0x18c>)
   146ee:	485e      	ldr	r0, [pc, #376]	; (14868 <friend_timeout+0x190>)
   146f0:	4a5e      	ldr	r2, [pc, #376]	; (1486c <friend_timeout+0x194>)
   146f2:	f240 438a 	movw	r3, #1162	; 0x48a
   146f6:	f00f fbf4 	bl	23ee2 <printk>
   146fa:	485c      	ldr	r0, [pc, #368]	; (1486c <friend_timeout+0x194>)
   146fc:	f240 418a 	movw	r1, #1162	; 0x48a
   14700:	f00f fc32 	bl	23f68 <assert_post_action>
   14704:	4b5a      	ldr	r3, [pc, #360]	; (14870 <friend_timeout+0x198>)
   14706:	4d5b      	ldr	r5, [pc, #364]	; (14874 <friend_timeout+0x19c>)
	BT_DBG("lpn 0x%04x send_last %u last %p", frnd->lpn,
   14708:	4e5b      	ldr	r6, [pc, #364]	; (14878 <friend_timeout+0x1a0>)
   1470a:	485c      	ldr	r0, [pc, #368]	; (1487c <friend_timeout+0x1a4>)
   1470c:	9602      	str	r6, [sp, #8]
   1470e:	1aed      	subs	r5, r5, r3
   14710:	f834 3c18 	ldrh.w	r3, [r4, #-24]
   14714:	9303      	str	r3, [sp, #12]
   14716:	f814 3c15 	ldrb.w	r3, [r4, #-21]
   1471a:	08ed      	lsrs	r5, r5, #3
   1471c:	f3c3 0340 	ubfx	r3, r3, #1, #1
   14720:	01ad      	lsls	r5, r5, #6
   14722:	9304      	str	r3, [sp, #16]
   14724:	f045 0704 	orr.w	r7, r5, #4
   14728:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1472a:	9305      	str	r3, [sp, #20]
   1472c:	2204      	movs	r2, #4
   1472e:	463b      	mov	r3, r7
   14730:	a902      	add	r1, sp, #8
   14732:	f00f fc9d 	bl	24070 <log_n>
	if (frnd->send_last && frnd->last) {
   14736:	f814 3c15 	ldrb.w	r3, [r4, #-21]
   1473a:	079a      	lsls	r2, r3, #30
   1473c:	d51a      	bpl.n	14774 <friend_timeout+0x9c>
   1473e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   14740:	b1c2      	cbz	r2, 14774 <friend_timeout+0x9c>
		BT_DBG("Sending frnd->last %p", frnd->last);
   14742:	463b      	mov	r3, r7
   14744:	484e      	ldr	r0, [pc, #312]	; (14880 <friend_timeout+0x1a8>)
   14746:	4631      	mov	r1, r6
   14748:	f00f fc5d 	bl	24006 <log_2>
		frnd->send_last = 0U;
   1474c:	f814 3c15 	ldrb.w	r3, [r4, #-21]
   14750:	f36f 0341 	bfc	r3, #1, #1
   14754:	f804 3c15 	strb.w	r3, [r4, #-21]
	frnd->pending_req = 0U;
   14758:	f814 3c15 	ldrb.w	r3, [r4, #-21]
	bt_mesh_adv_send(frnd->last, &buf_sent_cb, frnd);
   1475c:	4949      	ldr	r1, [pc, #292]	; (14884 <friend_timeout+0x1ac>)
   1475e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	frnd->pending_buf = 1U;
   14760:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   14764:	f043 0308 	orr.w	r3, r3, #8
   14768:	f804 3c15 	strb.w	r3, [r4, #-21]
	bt_mesh_adv_send(frnd->last, &buf_sent_cb, frnd);
   1476c:	4642      	mov	r2, r8
   1476e:	f7f7 fcfb 	bl	c168 <bt_mesh_adv_send>
   14772:	e00d      	b.n	14790 <friend_timeout+0xb8>
	if (frnd->established && !frnd->pending_req) {
   14774:	f003 0324 	and.w	r3, r3, #36	; 0x24
   14778:	2b20      	cmp	r3, #32
   1477a:	d10c      	bne.n	14796 <friend_timeout+0xbe>
		BT_WARN("Friendship lost with 0x%04x", frnd->lpn);
   1477c:	f834 1c18 	ldrh.w	r1, [r4, #-24]
   14780:	4841      	ldr	r0, [pc, #260]	; (14888 <friend_timeout+0x1b0>)
   14782:	f045 0202 	orr.w	r2, r5, #2
		BT_WARN("Friendship not established with 0x%04x",
   14786:	f00f fc2a 	bl	23fde <log_1>
		friend_clear(frnd);
   1478a:	4640      	mov	r0, r8
   1478c:	f7ff fc90 	bl	140b0 <friend_clear>
}
   14790:	b007      	add	sp, #28
   14792:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
Z_GENLIST_IS_EMPTY(slist)
   14796:	6b26      	ldr	r6, [r4, #48]	; 0x30
Z_GENLIST_GET(slist, snode)
   14798:	b936      	cbnz	r6, 147a8 <friend_timeout+0xd0>
		BT_WARN("Friendship not established with 0x%04x",
   1479a:	f834 1c18 	ldrh.w	r1, [r4, #-24]
   1479e:	483b      	ldr	r0, [pc, #236]	; (1488c <friend_timeout+0x1b4>)
	frnd->last = (void *)sys_slist_get(&frnd->queue);
   147a0:	62e6      	str	r6, [r4, #44]	; 0x2c
		BT_WARN("Friendship not established with 0x%04x",
   147a2:	f045 0202 	orr.w	r2, r5, #2
   147a6:	e7ee      	b.n	14786 <friend_timeout+0xae>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   147a8:	6b63      	ldr	r3, [r4, #52]	; 0x34
   147aa:	6837      	ldr	r7, [r6, #0]
	list->head = node;
   147ac:	6327      	str	r7, [r4, #48]	; 0x30
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   147ae:	429e      	cmp	r6, r3
	if (buf->len != 16) {
   147b0:	89b3      	ldrh	r3, [r6, #12]
	list->tail = node;
   147b2:	bf08      	it	eq
   147b4:	6367      	streq	r7, [r4, #52]	; 0x34
   147b6:	2b10      	cmp	r3, #16
	frnd->last = (void *)sys_slist_get(&frnd->queue);
   147b8:	62e6      	str	r6, [r4, #44]	; 0x2c
	if (buf->len != 16) {
   147ba:	d138      	bne.n	1482e <friend_timeout+0x156>
	net_buf_simple_save(&buf->b, &state);
   147bc:	f106 0a08 	add.w	sl, r6, #8
	state->offset = net_buf_simple_headroom(buf);
   147c0:	4650      	mov	r0, sl
   147c2:	f014 faec 	bl	28d9e <net_buf_simple_headroom>
	net_buf_skip(buf, 1); /* skip IVI, NID */
   147c6:	2101      	movs	r1, #1
   147c8:	4681      	mov	r9, r0
   147ca:	4630      	mov	r0, r6
	state->len = buf->len;
   147cc:	f8b6 b00c 	ldrh.w	fp, [r6, #12]
   147d0:	f013 fad8 	bl	27d84 <net_buf_skip>
	if (!(net_buf_pull_u8(buf) >> 7)) {
   147d4:	4650      	mov	r0, sl
   147d6:	f014 fabe 	bl	28d56 <net_buf_simple_pull_u8>
   147da:	0603      	lsls	r3, r0, #24
   147dc:	d521      	bpl.n	14822 <friend_timeout+0x14a>
	net_buf_skip(buf, 7); /* skip seqnum src dec*/
   147de:	2107      	movs	r1, #7
   147e0:	4630      	mov	r0, r6
   147e2:	f013 facf 	bl	27d84 <net_buf_skip>
	if (TRANS_CTL_OP((u8_t *) net_buf_pull_mem(buf, 1))
   147e6:	2101      	movs	r1, #1
   147e8:	4650      	mov	r0, sl
   147ea:	f00a fd53 	bl	1f294 <net_buf_simple_pull_mem>
   147ee:	7803      	ldrb	r3, [r0, #0]
   147f0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   147f4:	2b02      	cmp	r3, #2
   147f6:	d114      	bne.n	14822 <friend_timeout+0x14a>
	md = (u8_t)(sys_slist_peek_head(&frnd->queue) != NULL);
   147f8:	3f00      	subs	r7, #0
	upd = net_buf_pull_mem(buf, sizeof(*upd));
   147fa:	f04f 0106 	mov.w	r1, #6
   147fe:	4650      	mov	r0, sl
	md = (u8_t)(sys_slist_peek_head(&frnd->queue) != NULL);
   14800:	bf18      	it	ne
   14802:	2701      	movne	r7, #1
	upd = net_buf_pull_mem(buf, sizeof(*upd));
   14804:	f00a fd46 	bl	1f294 <net_buf_simple_pull_mem>
	BT_DBG("Update Previous Friend Update MD 0x%02x -> 0x%02x", upd->md, md);
   14808:	f045 0304 	orr.w	r3, r5, #4
	upd = net_buf_pull_mem(buf, sizeof(*upd));
   1480c:	4682      	mov	sl, r0
	BT_DBG("Update Previous Friend Update MD 0x%02x -> 0x%02x", upd->md, md);
   1480e:	7942      	ldrb	r2, [r0, #5]
   14810:	491f      	ldr	r1, [pc, #124]	; (14890 <friend_timeout+0x1b8>)
   14812:	f8ad 3000 	strh.w	r3, [sp]
   14816:	481f      	ldr	r0, [pc, #124]	; (14894 <friend_timeout+0x1bc>)
   14818:	463b      	mov	r3, r7
   1481a:	f00f fc0d 	bl	24038 <log_3>
	upd->md = md;
   1481e:	f88a 7005 	strb.w	r7, [sl, #5]
	buf->data = buf->__buf + state->offset;
   14822:	6930      	ldr	r0, [r6, #16]
	buf->len = state->len;
   14824:	f8a6 b00c 	strh.w	fp, [r6, #12]
	buf->data = buf->__buf + state->offset;
   14828:	fa10 f089 	uxtah	r0, r0, r9
   1482c:	60b0      	str	r0, [r6, #8]
	if (encrypt_friend_pdu(frnd, frnd->last, false)) {
   1482e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   14830:	2200      	movs	r2, #0
   14832:	4640      	mov	r0, r8
   14834:	f7ff fdae 	bl	14394 <encrypt_friend_pdu>
   14838:	2800      	cmp	r0, #0
   1483a:	d1a9      	bne.n	14790 <friend_timeout+0xb8>
	frnd->last->flags &= ~NET_BUF_FRAGS;
   1483c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	BT_DBG("Sending buf %p from Friend Queue of LPN 0x%04x",
   1483e:	490e      	ldr	r1, [pc, #56]	; (14878 <friend_timeout+0x1a0>)
	frnd->last->flags &= ~NET_BUF_FRAGS;
   14840:	7953      	ldrb	r3, [r2, #5]
	frnd->last->frags = NULL;
   14842:	6010      	str	r0, [r2, #0]
	frnd->last->flags &= ~NET_BUF_FRAGS;
   14844:	f023 0301 	bic.w	r3, r3, #1
   14848:	7153      	strb	r3, [r2, #5]
	BT_DBG("Sending buf %p from Friend Queue of LPN 0x%04x",
   1484a:	f045 0504 	orr.w	r5, r5, #4
   1484e:	f834 3c18 	ldrh.w	r3, [r4, #-24]
   14852:	4811      	ldr	r0, [pc, #68]	; (14898 <friend_timeout+0x1c0>)
   14854:	f8ad 5000 	strh.w	r5, [sp]
   14858:	f00f fbee 	bl	24038 <log_3>
	frnd->queue_size--;
   1485c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1485e:	3b01      	subs	r3, #1
   14860:	63a3      	str	r3, [r4, #56]	; 0x38
   14862:	e779      	b.n	14758 <friend_timeout+0x80>
   14864:	0002eb40 	.word	0x0002eb40
   14868:	0002a5e8 	.word	0x0002a5e8
   1486c:	0002eb0e 	.word	0x0002eb0e
   14870:	00029830 	.word	0x00029830
   14874:	00029938 	.word	0x00029938
   14878:	0002f47c 	.word	0x0002f47c
   1487c:	0002eb58 	.word	0x0002eb58
   14880:	0002eb7c 	.word	0x0002eb7c
   14884:	0002a354 	.word	0x0002a354
   14888:	0002eb96 	.word	0x0002eb96
   1488c:	0002ebb2 	.word	0x0002ebb2
   14890:	0002f46b 	.word	0x0002f46b
   14894:	0002ebd9 	.word	0x0002ebd9
   14898:	0002ec0f 	.word	0x0002ec0f

0001489c <enqueue_update.constprop.0>:
static void enqueue_update(struct bt_mesh_friend *frnd, u8_t md)
   1489c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1489e:	b089      	sub	sp, #36	; 0x24
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*upd));
   148a0:	ab03      	add	r3, sp, #12
   148a2:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
static void enqueue_update(struct bt_mesh_friend *frnd, u8_t md)
   148a6:	4604      	mov	r4, r0
	struct bt_mesh_subnet *sub = bt_mesh_subnet_get(frnd->net_idx);
   148a8:	89c0      	ldrh	r0, [r0, #14]
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*upd));
   148aa:	9305      	str	r3, [sp, #20]
   148ac:	e9cd 2306 	strd	r2, r3, [sp, #24]
	struct bt_mesh_subnet *sub = bt_mesh_subnet_get(frnd->net_idx);
   148b0:	f7f8 f89c 	bl	c9ec <bt_mesh_subnet_get>
	__ASSERT_NO_MSG(sub != NULL);
   148b4:	4607      	mov	r7, r0
   148b6:	b958      	cbnz	r0, 148d0 <enqueue_update.constprop.0+0x34>
   148b8:	4922      	ldr	r1, [pc, #136]	; (14944 <enqueue_update.constprop.0+0xa8>)
   148ba:	4823      	ldr	r0, [pc, #140]	; (14948 <enqueue_update.constprop.0+0xac>)
   148bc:	4a23      	ldr	r2, [pc, #140]	; (1494c <enqueue_update.constprop.0+0xb0>)
   148be:	f240 2305 	movw	r3, #517	; 0x205
   148c2:	f00f fb0e 	bl	23ee2 <printk>
   148c6:	4821      	ldr	r0, [pc, #132]	; (1494c <enqueue_update.constprop.0+0xb0>)
   148c8:	f240 2105 	movw	r1, #517	; 0x205
   148cc:	f00f fb4c 	bl	23f68 <assert_post_action>
   148d0:	4b1f      	ldr	r3, [pc, #124]	; (14950 <enqueue_update.constprop.0+0xb4>)
   148d2:	4d20      	ldr	r5, [pc, #128]	; (14954 <enqueue_update.constprop.0+0xb8>)
	BT_DBG("lpn 0x%04x md 0x%02x", frnd->lpn, md);
   148d4:	8822      	ldrh	r2, [r4, #0]
   148d6:	4920      	ldr	r1, [pc, #128]	; (14958 <enqueue_update.constprop.0+0xbc>)
   148d8:	4820      	ldr	r0, [pc, #128]	; (1495c <enqueue_update.constprop.0+0xc0>)
   148da:	1aed      	subs	r5, r5, r3
   148dc:	08ed      	lsrs	r5, r5, #3
   148de:	01ad      	lsls	r5, r5, #6
   148e0:	f045 0304 	orr.w	r3, r5, #4
   148e4:	f8ad 3000 	strh.w	r3, [sp]
   148e8:	2300      	movs	r3, #0
   148ea:	f00f fba5 	bl	24038 <log_3>
	net_buf_simple_reserve(&sdu, 1);
   148ee:	2101      	movs	r1, #1
   148f0:	a805      	add	r0, sp, #20
   148f2:	f00a fae5 	bl	1eec0 <net_buf_simple_reserve>
	upd = net_buf_simple_add(&sdu, sizeof(*upd));
   148f6:	2106      	movs	r1, #6
   148f8:	a805      	add	r0, sp, #20
   148fa:	f00a fced 	bl	1f2d8 <net_buf_simple_add>
   148fe:	4606      	mov	r6, r0
	upd->flags = bt_mesh_net_flags(sub);
   14900:	4638      	mov	r0, r7
   14902:	f012 fba2 	bl	2704a <bt_mesh_net_flags>
   14906:	4b16      	ldr	r3, [pc, #88]	; (14960 <enqueue_update.constprop.0+0xc4>)
   14908:	7030      	strb	r0, [r6, #0]
	upd->iv_index = sys_cpu_to_be32(bt_mesh.iv_index);
   1490a:	681b      	ldr	r3, [r3, #0]
   1490c:	ba1b      	rev	r3, r3
   1490e:	f8c6 3001 	str.w	r3, [r6, #1]
	upd->md = md;
   14912:	2300      	movs	r3, #0
	return encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_UPDATE, &sdu);
   14914:	2102      	movs	r1, #2
	upd->md = md;
   14916:	7173      	strb	r3, [r6, #5]
	return encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_UPDATE, &sdu);
   14918:	aa05      	add	r2, sp, #20
   1491a:	4620      	mov	r0, r4
   1491c:	f7ff fc4e 	bl	141bc <encode_friend_ctl.isra.0>
	if (!buf) {
   14920:	4601      	mov	r1, r0
   14922:	b930      	cbnz	r0, 14932 <enqueue_update.constprop.0+0x96>
		BT_ERR("Unable to encode Friend Update");
   14924:	480f      	ldr	r0, [pc, #60]	; (14964 <enqueue_update.constprop.0+0xc8>)
   14926:	f045 0101 	orr.w	r1, r5, #1
   1492a:	f00f fb4b 	bl	23fc4 <log_0>
}
   1492e:	b009      	add	sp, #36	; 0x24
   14930:	bdf0      	pop	{r4, r5, r6, r7, pc}
	net_buf_slist_put(&frnd->queue, buf);
   14932:	f104 0048 	add.w	r0, r4, #72	; 0x48
   14936:	f00a faed 	bl	1ef14 <net_buf_slist_put>
	frnd->queue_size++;
   1493a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   1493c:	3301      	adds	r3, #1
   1493e:	6523      	str	r3, [r4, #80]	; 0x50
}
   14940:	e7f5      	b.n	1492e <enqueue_update.constprop.0+0x92>
   14942:	bf00      	nop
   14944:	0002ec42 	.word	0x0002ec42
   14948:	0002a5e8 	.word	0x0002a5e8
   1494c:	0002eb0e 	.word	0x0002eb0e
   14950:	00029830 	.word	0x00029830
   14954:	00029938 	.word	0x00029938
   14958:	0002f37c 	.word	0x0002f37c
   1495c:	0002ec55 	.word	0x0002ec55
   14960:	20006b48 	.word	0x20006b48
   14964:	0002ec6e 	.word	0x0002ec6e

00014968 <friend_purge_old_ack>:
{
   14968:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1496c:	4b3f      	ldr	r3, [pc, #252]	; (14a6c <friend_purge_old_ack+0x104>)
   1496e:	4d40      	ldr	r5, [pc, #256]	; (14a70 <friend_purge_old_ack+0x108>)
   14970:	1aed      	subs	r5, r5, r3
   14972:	08ed      	lsrs	r5, r5, #3
   14974:	b085      	sub	sp, #20
	BT_DBG("SeqAuth %llx src 0x%04x", *seq_auth, src);
   14976:	ea4f 1b85 	mov.w	fp, r5, lsl #6
   1497a:	f04b 0304 	orr.w	r3, fp, #4
   1497e:	f8ad 3000 	strh.w	r3, [sp]
{
   14982:	4604      	mov	r4, r0
	BT_DBG("SeqAuth %llx src 0x%04x", *seq_auth, src);
   14984:	4613      	mov	r3, r2
   14986:	483b      	ldr	r0, [pc, #236]	; (14a74 <friend_purge_old_ack+0x10c>)
{
   14988:	4689      	mov	r9, r1
   1498a:	4692      	mov	sl, r2
	BT_DBG("SeqAuth %llx src 0x%04x", *seq_auth, src);
   1498c:	680a      	ldr	r2, [r1, #0]
   1498e:	493a      	ldr	r1, [pc, #232]	; (14a78 <friend_purge_old_ack+0x110>)
   14990:	f00f fb52 	bl	24038 <log_3>
	for (cur = sys_slist_peek_head(&frnd->queue);
   14994:	6ca5      	ldr	r5, [r4, #72]	; 0x48
	sys_snode_t *cur, *prev = NULL;
   14996:	f04f 0800 	mov.w	r8, #0
	for (cur = sys_slist_peek_head(&frnd->queue);
   1499a:	b915      	cbnz	r5, 149a2 <friend_purge_old_ack+0x3a>
}
   1499c:	b005      	add	sp, #20
   1499e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (buf->len != 16) {
   149a2:	89aa      	ldrh	r2, [r5, #12]
   149a4:	2a10      	cmp	r2, #16
   149a6:	d15d      	bne.n	14a64 <friend_purge_old_ack+0xfc>
	net_buf_simple_save(&buf->b, &state);
   149a8:	f105 0608 	add.w	r6, r5, #8
	state->offset = net_buf_simple_headroom(buf);
   149ac:	4630      	mov	r0, r6
   149ae:	f014 f9f6 	bl	28d9e <net_buf_simple_headroom>
	state->len = buf->len;
   149b2:	89ab      	ldrh	r3, [r5, #12]
   149b4:	9303      	str	r3, [sp, #12]
	net_buf_skip(buf, 1); /* skip IVI, NID */
   149b6:	2101      	movs	r1, #1
	state->offset = net_buf_simple_headroom(buf);
   149b8:	4607      	mov	r7, r0
   149ba:	4628      	mov	r0, r5
   149bc:	f013 f9e2 	bl	27d84 <net_buf_skip>
	if (!(net_buf_pull_u8(buf) >> 7)) {
   149c0:	4630      	mov	r0, r6
   149c2:	f014 f9c8 	bl	28d56 <net_buf_simple_pull_u8>
   149c6:	0602      	lsls	r2, r0, #24
   149c8:	d422      	bmi.n	14a10 <friend_purge_old_ack+0xa8>
	bool found = false;
   149ca:	2200      	movs	r2, #0
	buf->data = buf->__buf + state->offset;
   149cc:	6928      	ldr	r0, [r5, #16]
	buf->len = state->len;
   149ce:	9b03      	ldr	r3, [sp, #12]
   149d0:	81ab      	strh	r3, [r5, #12]
	buf->data = buf->__buf + state->offset;
   149d2:	fa10 f787 	uxtah	r7, r0, r7
   149d6:	60af      	str	r7, [r5, #8]
		if (is_segack(buf, seq_auth, src)) {
   149d8:	2a00      	cmp	r2, #0
   149da:	d043      	beq.n	14a64 <friend_purge_old_ack+0xfc>
			BT_DBG("Removing old ack from Friend Queue");
   149dc:	f04b 0204 	orr.w	r2, fp, #4
   149e0:	4925      	ldr	r1, [pc, #148]	; (14a78 <friend_purge_old_ack+0x110>)
   149e2:	4826      	ldr	r0, [pc, #152]	; (14a7c <friend_purge_old_ack+0x114>)
   149e4:	f00f fafb 	bl	23fde <log_1>
Z_GENLIST_REMOVE(slist, snode)
   149e8:	682a      	ldr	r2, [r5, #0]
   149ea:	f1b8 0f00 	cmp.w	r8, #0
   149ee:	d131      	bne.n	14a54 <friend_purge_old_ack+0xec>
   149f0:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
	list->head = node;
   149f2:	64a2      	str	r2, [r4, #72]	; 0x48
Z_GENLIST_REMOVE(slist, snode)
   149f4:	428d      	cmp	r5, r1
   149f6:	d100      	bne.n	149fa <friend_purge_old_ack+0x92>
	list->tail = node;
   149f8:	64e2      	str	r2, [r4, #76]	; 0x4c
			frnd->queue_size--;
   149fa:	6d22      	ldr	r2, [r4, #80]	; 0x50
   149fc:	3a01      	subs	r2, #1
   149fe:	6522      	str	r2, [r4, #80]	; 0x50
			net_buf_unref(buf);
   14a00:	4628      	mov	r0, r5
			buf->frags = NULL;
   14a02:	2200      	movs	r2, #0
   14a04:	602a      	str	r2, [r5, #0]
}
   14a06:	b005      	add	sp, #20
   14a08:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			net_buf_unref(buf);
   14a0c:	f00a bb5c 	b.w	1f0c8 <net_buf_unref>
	net_buf_pull(buf, 3); /* skip SEQNUM */
   14a10:	2103      	movs	r1, #3
   14a12:	4630      	mov	r0, r6
   14a14:	f00a fc1e 	bl	1f254 <net_buf_simple_pull>
	if (src != net_buf_pull_be16(buf)) {
   14a18:	4630      	mov	r0, r6
   14a1a:	f014 f9ac 	bl	28d76 <net_buf_simple_pull_be16>
   14a1e:	4582      	cmp	sl, r0
   14a20:	d1d3      	bne.n	149ca <friend_purge_old_ack+0x62>
	net_buf_skip(buf, 2); /* skip dst */
   14a22:	2102      	movs	r1, #2
   14a24:	4628      	mov	r0, r5
   14a26:	f013 f9ad 	bl	27d84 <net_buf_skip>
	if (TRANS_CTL_OP((u8_t *) net_buf_pull_mem(buf, 1)) != TRANS_CTL_OP_ACK) {
   14a2a:	2101      	movs	r1, #1
   14a2c:	4630      	mov	r0, r6
   14a2e:	f00a fc31 	bl	1f294 <net_buf_simple_pull_mem>
   14a32:	7802      	ldrb	r2, [r0, #0]
   14a34:	0653      	lsls	r3, r2, #25
   14a36:	d1c8      	bne.n	149ca <friend_purge_old_ack+0x62>
	found = ((net_buf_pull_be16(buf) >> 2) & TRANS_SEQ_ZERO_MASK) ==
   14a38:	4630      	mov	r0, r6
   14a3a:	f014 f99c 	bl	28d76 <net_buf_simple_pull_be16>
   14a3e:	f3c0 028f 	ubfx	r2, r0, #2, #16
   14a42:	f8d9 0000 	ldr.w	r0, [r9]
   14a46:	4042      	eors	r2, r0
   14a48:	f3c2 020c 	ubfx	r2, r2, #0, #13
   14a4c:	fab2 f282 	clz	r2, r2
   14a50:	0952      	lsrs	r2, r2, #5
   14a52:	e7bb      	b.n	149cc <friend_purge_old_ack+0x64>
	parent->next = child;
   14a54:	f8c8 2000 	str.w	r2, [r8]
Z_GENLIST_REMOVE(slist, snode)
   14a58:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
   14a5a:	4295      	cmp	r5, r2
	list->tail = node;
   14a5c:	bf08      	it	eq
   14a5e:	f8c4 804c 	streq.w	r8, [r4, #76]	; 0x4c
}
   14a62:	e7ca      	b.n	149fa <friend_purge_old_ack+0x92>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   14a64:	46a8      	mov	r8, r5
	     cur != NULL; prev = cur, cur = sys_slist_peek_next(cur)) {
   14a66:	682d      	ldr	r5, [r5, #0]
   14a68:	e797      	b.n	1499a <friend_purge_old_ack+0x32>
   14a6a:	bf00      	nop
   14a6c:	00029830 	.word	0x00029830
   14a70:	00029938 	.word	0x00029938
   14a74:	0002ec8d 	.word	0x0002ec8d
   14a78:	0002f48b 	.word	0x0002f48b
   14a7c:	0002eca9 	.word	0x0002eca9

00014a80 <bt_mesh_friend_find>:
{
   14a80:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   14a84:	4c22      	ldr	r4, [pc, #136]	; (14b10 <bt_mesh_friend_find+0x90>)
   14a86:	4698      	mov	r8, r3
   14a88:	4b22      	ldr	r3, [pc, #136]	; (14b14 <bt_mesh_friend_find+0x94>)
   14a8a:	1ae4      	subs	r4, r4, r3
   14a8c:	08e4      	lsrs	r4, r4, #3
	BT_DBG("net_idx 0x%04x lpn_addr 0x%04x", net_idx, lpn_addr);
   14a8e:	01a4      	lsls	r4, r4, #6
   14a90:	f044 0404 	orr.w	r4, r4, #4
   14a94:	460b      	mov	r3, r1
{
   14a96:	4605      	mov	r5, r0
   14a98:	460e      	mov	r6, r1
   14a9a:	4617      	mov	r7, r2
	BT_DBG("net_idx 0x%04x lpn_addr 0x%04x", net_idx, lpn_addr);
   14a9c:	491e      	ldr	r1, [pc, #120]	; (14b18 <bt_mesh_friend_find+0x98>)
   14a9e:	f8ad 4000 	strh.w	r4, [sp]
   14aa2:	4602      	mov	r2, r0
   14aa4:	481d      	ldr	r0, [pc, #116]	; (14b1c <bt_mesh_friend_find+0x9c>)
   14aa6:	f00f fac7 	bl	24038 <log_3>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   14aaa:	4b1d      	ldr	r3, [pc, #116]	; (14b20 <bt_mesh_friend_find+0xa0>)
   14aac:	2200      	movs	r2, #0
   14aae:	4619      	mov	r1, r3
		if (net_idx != BT_MESH_KEY_ANY && frnd->net_idx != net_idx) {
   14ab0:	f64f 7eff 	movw	lr, #65535	; 0xffff
		if (established && !frnd->established) {
   14ab4:	f04f 0c7c 	mov.w	ip, #124	; 0x7c
		if (valid && !frnd->valid) {
   14ab8:	b12f      	cbz	r7, 14ac6 <bt_mesh_friend_find+0x46>
   14aba:	fb0c 1002 	mla	r0, ip, r2, r1
   14abe:	f890 0023 	ldrb.w	r0, [r0, #35]	; 0x23
   14ac2:	06c4      	lsls	r4, r0, #27
   14ac4:	d51f      	bpl.n	14b06 <bt_mesh_friend_find+0x86>
		if (established && !frnd->established) {
   14ac6:	f1b8 0f00 	cmp.w	r8, #0
   14aca:	d005      	beq.n	14ad8 <bt_mesh_friend_find+0x58>
   14acc:	fb0c 1002 	mla	r0, ip, r2, r1
   14ad0:	f890 0023 	ldrb.w	r0, [r0, #35]	; 0x23
   14ad4:	0680      	lsls	r0, r0, #26
   14ad6:	d516      	bpl.n	14b06 <bt_mesh_friend_find+0x86>
		if (net_idx != BT_MESH_KEY_ANY && frnd->net_idx != net_idx) {
   14ad8:	4575      	cmp	r5, lr
   14ada:	d002      	beq.n	14ae2 <bt_mesh_friend_find+0x62>
   14adc:	8dd8      	ldrh	r0, [r3, #46]	; 0x2e
   14ade:	42a8      	cmp	r0, r5
   14ae0:	d111      	bne.n	14b06 <bt_mesh_friend_find+0x86>
	if (frnd->lpn == BT_MESH_ADDR_UNASSIGNED) {
   14ae2:	8c1c      	ldrh	r4, [r3, #32]
   14ae4:	b17c      	cbz	r4, 14b06 <bt_mesh_friend_find+0x86>
	return (addr >= frnd->lpn && addr < (frnd->lpn + frnd->num_elem));
   14ae6:	42a6      	cmp	r6, r4
   14ae8:	d30d      	bcc.n	14b06 <bt_mesh_friend_find+0x86>
   14aea:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
   14aee:	4420      	add	r0, r4
   14af0:	4286      	cmp	r6, r0
   14af2:	da08      	bge.n	14b06 <bt_mesh_friend_find+0x86>
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];
   14af4:	207c      	movs	r0, #124	; 0x7c
   14af6:	fb00 1002 	mla	r0, r0, r2, r1
   14afa:	3020      	adds	r0, #32
}
   14afc:	b002      	add	sp, #8
   14afe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14b02:	2201      	movs	r2, #1
   14b04:	e7d8      	b.n	14ab8 <bt_mesh_friend_find+0x38>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   14b06:	337c      	adds	r3, #124	; 0x7c
   14b08:	2a00      	cmp	r2, #0
   14b0a:	d0fa      	beq.n	14b02 <bt_mesh_friend_find+0x82>
	return NULL;
   14b0c:	2000      	movs	r0, #0
   14b0e:	e7f5      	b.n	14afc <bt_mesh_friend_find+0x7c>
   14b10:	00029938 	.word	0x00029938
   14b14:	00029830 	.word	0x00029830
   14b18:	0002f2fd 	.word	0x0002f2fd
   14b1c:	0002ecd0 	.word	0x0002ecd0
   14b20:	20006b48 	.word	0x20006b48

00014b24 <bt_mesh_friend_clear_net_idx>:
{
   14b24:	b538      	push	{r3, r4, r5, lr}
   14b26:	4a15      	ldr	r2, [pc, #84]	; (14b7c <bt_mesh_friend_clear_net_idx+0x58>)
   14b28:	4b15      	ldr	r3, [pc, #84]	; (14b80 <bt_mesh_friend_clear_net_idx+0x5c>)
		if (frnd->net_idx == BT_MESH_KEY_UNUSED) {
   14b2a:	4d16      	ldr	r5, [pc, #88]	; (14b84 <bt_mesh_friend_clear_net_idx+0x60>)
	BT_DBG("net_idx 0x%04x", net_idx);
   14b2c:	4916      	ldr	r1, [pc, #88]	; (14b88 <bt_mesh_friend_clear_net_idx+0x64>)
   14b2e:	1a9b      	subs	r3, r3, r2
   14b30:	08db      	lsrs	r3, r3, #3
   14b32:	019b      	lsls	r3, r3, #6
   14b34:	4602      	mov	r2, r0
{
   14b36:	4604      	mov	r4, r0
	BT_DBG("net_idx 0x%04x", net_idx);
   14b38:	f043 0304 	orr.w	r3, r3, #4
   14b3c:	4813      	ldr	r0, [pc, #76]	; (14b8c <bt_mesh_friend_clear_net_idx+0x68>)
   14b3e:	f00f fa62 	bl	24006 <log_2>
		if (frnd->net_idx == BT_MESH_KEY_UNUSED) {
   14b42:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
   14b44:	f64f 71ff 	movw	r1, #65535	; 0xffff
   14b48:	428a      	cmp	r2, r1
   14b4a:	d004      	beq.n	14b56 <bt_mesh_friend_clear_net_idx+0x32>
		if (net_idx == BT_MESH_KEY_ANY || frnd->net_idx == net_idx) {
   14b4c:	428c      	cmp	r4, r1
   14b4e:	d10f      	bne.n	14b70 <bt_mesh_friend_clear_net_idx+0x4c>
			friend_clear(frnd);
   14b50:	480f      	ldr	r0, [pc, #60]	; (14b90 <bt_mesh_friend_clear_net_idx+0x6c>)
   14b52:	f7ff faad 	bl	140b0 <friend_clear>
		if (frnd->net_idx == BT_MESH_KEY_UNUSED) {
   14b56:	f8b5 30aa 	ldrh.w	r3, [r5, #170]	; 0xaa
   14b5a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   14b5e:	4293      	cmp	r3, r2
   14b60:	d00b      	beq.n	14b7a <bt_mesh_friend_clear_net_idx+0x56>
		if (net_idx == BT_MESH_KEY_ANY || frnd->net_idx == net_idx) {
   14b62:	4294      	cmp	r4, r2
   14b64:	d107      	bne.n	14b76 <bt_mesh_friend_clear_net_idx+0x52>
}
   14b66:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			friend_clear(frnd);
   14b6a:	480a      	ldr	r0, [pc, #40]	; (14b94 <bt_mesh_friend_clear_net_idx+0x70>)
   14b6c:	f7ff baa0 	b.w	140b0 <friend_clear>
		if (net_idx == BT_MESH_KEY_ANY || frnd->net_idx == net_idx) {
   14b70:	4294      	cmp	r4, r2
   14b72:	d1f0      	bne.n	14b56 <bt_mesh_friend_clear_net_idx+0x32>
   14b74:	e7ec      	b.n	14b50 <bt_mesh_friend_clear_net_idx+0x2c>
   14b76:	429c      	cmp	r4, r3
   14b78:	d0f5      	beq.n	14b66 <bt_mesh_friend_clear_net_idx+0x42>
}
   14b7a:	bd38      	pop	{r3, r4, r5, pc}
   14b7c:	00029830 	.word	0x00029830
   14b80:	00029938 	.word	0x00029938
   14b84:	20006b48 	.word	0x20006b48
   14b88:	0002f31e 	.word	0x0002f31e
   14b8c:	0002ecf3 	.word	0x0002ecf3
   14b90:	20006b68 	.word	0x20006b68
   14b94:	20006be4 	.word	0x20006be4

00014b98 <bt_mesh_friend_sec_update>:
{
   14b98:	b538      	push	{r3, r4, r5, lr}
   14b9a:	4a15      	ldr	r2, [pc, #84]	; (14bf0 <bt_mesh_friend_sec_update+0x58>)
   14b9c:	4b15      	ldr	r3, [pc, #84]	; (14bf4 <bt_mesh_friend_sec_update+0x5c>)
		if (frnd->net_idx == BT_MESH_KEY_UNUSED) {
   14b9e:	4d16      	ldr	r5, [pc, #88]	; (14bf8 <bt_mesh_friend_sec_update+0x60>)
	BT_DBG("net_idx 0x%04x", net_idx);
   14ba0:	4916      	ldr	r1, [pc, #88]	; (14bfc <bt_mesh_friend_sec_update+0x64>)
   14ba2:	1a9b      	subs	r3, r3, r2
   14ba4:	08db      	lsrs	r3, r3, #3
   14ba6:	019b      	lsls	r3, r3, #6
   14ba8:	4602      	mov	r2, r0
{
   14baa:	4604      	mov	r4, r0
	BT_DBG("net_idx 0x%04x", net_idx);
   14bac:	f043 0304 	orr.w	r3, r3, #4
   14bb0:	4813      	ldr	r0, [pc, #76]	; (14c00 <bt_mesh_friend_sec_update+0x68>)
   14bb2:	f00f fa28 	bl	24006 <log_2>
		if (frnd->net_idx == BT_MESH_KEY_UNUSED) {
   14bb6:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
   14bb8:	f64f 71ff 	movw	r1, #65535	; 0xffff
   14bbc:	428a      	cmp	r2, r1
   14bbe:	d004      	beq.n	14bca <bt_mesh_friend_sec_update+0x32>
		if (net_idx == BT_MESH_KEY_ANY || frnd->net_idx == net_idx) {
   14bc0:	428c      	cmp	r4, r1
   14bc2:	d10f      	bne.n	14be4 <bt_mesh_friend_sec_update+0x4c>
			enqueue_update(frnd, 0x00);
   14bc4:	480f      	ldr	r0, [pc, #60]	; (14c04 <bt_mesh_friend_sec_update+0x6c>)
   14bc6:	f7ff fe69 	bl	1489c <enqueue_update.constprop.0>
		if (frnd->net_idx == BT_MESH_KEY_UNUSED) {
   14bca:	f8b5 30aa 	ldrh.w	r3, [r5, #170]	; 0xaa
   14bce:	f64f 72ff 	movw	r2, #65535	; 0xffff
   14bd2:	4293      	cmp	r3, r2
   14bd4:	d00b      	beq.n	14bee <bt_mesh_friend_sec_update+0x56>
		if (net_idx == BT_MESH_KEY_ANY || frnd->net_idx == net_idx) {
   14bd6:	4294      	cmp	r4, r2
   14bd8:	d107      	bne.n	14bea <bt_mesh_friend_sec_update+0x52>
}
   14bda:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			enqueue_update(frnd, 0x00);
   14bde:	480a      	ldr	r0, [pc, #40]	; (14c08 <bt_mesh_friend_sec_update+0x70>)
   14be0:	f7ff be5c 	b.w	1489c <enqueue_update.constprop.0>
		if (net_idx == BT_MESH_KEY_ANY || frnd->net_idx == net_idx) {
   14be4:	4294      	cmp	r4, r2
   14be6:	d1f0      	bne.n	14bca <bt_mesh_friend_sec_update+0x32>
   14be8:	e7ec      	b.n	14bc4 <bt_mesh_friend_sec_update+0x2c>
   14bea:	429c      	cmp	r4, r3
   14bec:	d0f5      	beq.n	14bda <bt_mesh_friend_sec_update+0x42>
}
   14bee:	bd38      	pop	{r3, r4, r5, pc}
   14bf0:	00029830 	.word	0x00029830
   14bf4:	00029938 	.word	0x00029938
   14bf8:	20006b48 	.word	0x20006b48
   14bfc:	0002f33b 	.word	0x0002f33b
   14c00:	0002ecf3 	.word	0x0002ecf3
   14c04:	20006b68 	.word	0x20006b68
   14c08:	20006be4 	.word	0x20006be4

00014c0c <bt_mesh_friend_clear>:
{
   14c0c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_mesh_net_tx tx = {
   14c10:	4603      	mov	r3, r0
{
   14c12:	b087      	sub	sp, #28
	struct bt_mesh_net_tx tx = {
   14c14:	f853 2b04 	ldr.w	r2, [r3], #4
	struct bt_mesh_ctl_friend_clear *msg = (void *)buf->data;
   14c18:	f8d1 8000 	ldr.w	r8, [r1]
	struct bt_mesh_net_tx tx = {
   14c1c:	4d3a      	ldr	r5, [pc, #232]	; (14d08 <bt_mesh_friend_clear+0xfc>)
   14c1e:	2400      	movs	r4, #0
   14c20:	e9cd 2303 	strd	r2, r3, [sp, #12]
{
   14c24:	460e      	mov	r6, r1
   14c26:	4607      	mov	r7, r0
	struct bt_mesh_net_tx tx = {
   14c28:	9405      	str	r4, [sp, #20]
		.src  = bt_mesh_primary_addr(),
   14c2a:	f7fa ff3f 	bl	faac <bt_mesh_primary_addr>
	struct bt_mesh_net_tx tx = {
   14c2e:	f8ad 0014 	strh.w	r0, [sp, #20]
		.xmit = bt_mesh_net_transmit_get(),
   14c32:	f7fd fae7 	bl	12204 <bt_mesh_net_transmit_get>
   14c36:	4b35      	ldr	r3, [pc, #212]	; (14d0c <bt_mesh_friend_clear+0x100>)
	struct bt_mesh_net_tx tx = {
   14c38:	f88d 0016 	strb.w	r0, [sp, #22]
	if (buf->len < sizeof(*msg)) {
   14c3c:	1aed      	subs	r5, r5, r3
   14c3e:	88b3      	ldrh	r3, [r6, #4]
   14c40:	08ed      	lsrs	r5, r5, #3
   14c42:	2b03      	cmp	r3, #3
   14c44:	ea4f 1585 	mov.w	r5, r5, lsl #6
   14c48:	d809      	bhi.n	14c5e <bt_mesh_friend_clear+0x52>
		BT_WARN("Too short Friend Clear");
   14c4a:	4831      	ldr	r0, [pc, #196]	; (14d10 <bt_mesh_friend_clear+0x104>)
   14c4c:	f045 0102 	orr.w	r1, r5, #2
   14c50:	f00f f9b8 	bl	23fc4 <log_0>
		return -EINVAL;
   14c54:	f06f 0015 	mvn.w	r0, #21
}
   14c58:	b007      	add	sp, #28
   14c5a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	lpn_addr = sys_be16_to_cpu(msg->lpn_addr);
   14c5e:	f8b8 3000 	ldrh.w	r3, [r8]
	BT_DBG("LPN addr 0x%04x counter 0x%04x", lpn_addr, lpn_counter);
   14c62:	492c      	ldr	r1, [pc, #176]	; (14d14 <bt_mesh_friend_clear+0x108>)
   14c64:	482c      	ldr	r0, [pc, #176]	; (14d18 <bt_mesh_friend_clear+0x10c>)
	lpn_addr = sys_be16_to_cpu(msg->lpn_addr);
   14c66:	ea4f 2903 	mov.w	r9, r3, lsl #8
   14c6a:	ea49 2913 	orr.w	r9, r9, r3, lsr #8
	lpn_counter = sys_be16_to_cpu(msg->lpn_counter);
   14c6e:	f8b8 3002 	ldrh.w	r3, [r8, #2]
   14c72:	021e      	lsls	r6, r3, #8
   14c74:	ea46 2613 	orr.w	r6, r6, r3, lsr #8
	lpn_addr = sys_be16_to_cpu(msg->lpn_addr);
   14c78:	fa1f f989 	uxth.w	r9, r9
	BT_DBG("LPN addr 0x%04x counter 0x%04x", lpn_addr, lpn_counter);
   14c7c:	f045 0304 	orr.w	r3, r5, #4
	lpn_counter = sys_be16_to_cpu(msg->lpn_counter);
   14c80:	b2b6      	uxth	r6, r6
	BT_DBG("LPN addr 0x%04x counter 0x%04x", lpn_addr, lpn_counter);
   14c82:	f8ad 3000 	strh.w	r3, [sp]
   14c86:	464a      	mov	r2, r9
   14c88:	4633      	mov	r3, r6
   14c8a:	f00f f9d5 	bl	24038 <log_3>
	frnd = bt_mesh_friend_find(rx->sub->net_idx, lpn_addr, false, false);
   14c8e:	6838      	ldr	r0, [r7, #0]
   14c90:	4623      	mov	r3, r4
   14c92:	8b80      	ldrh	r0, [r0, #28]
   14c94:	4622      	mov	r2, r4
   14c96:	4649      	mov	r1, r9
   14c98:	f7ff fef2 	bl	14a80 <bt_mesh_friend_find>
	if (!frnd) {
   14c9c:	4607      	mov	r7, r0
   14c9e:	b938      	cbnz	r0, 14cb0 <bt_mesh_friend_clear+0xa4>
		BT_WARN("No matching LPN addr 0x%04x", lpn_addr);
   14ca0:	481e      	ldr	r0, [pc, #120]	; (14d1c <bt_mesh_friend_clear+0x110>)
   14ca2:	f045 0202 	orr.w	r2, r5, #2
   14ca6:	4649      	mov	r1, r9
   14ca8:	f00f f999 	bl	23fde <log_1>
		return 0;
   14cac:	4638      	mov	r0, r7
   14cae:	e7d3      	b.n	14c58 <bt_mesh_friend_clear+0x4c>
	if (lpn_counter - frnd->lpn_counter > 255) {
   14cb0:	8941      	ldrh	r1, [r0, #10]
   14cb2:	1a73      	subs	r3, r6, r1
   14cb4:	2bff      	cmp	r3, #255	; 0xff
   14cb6:	dd07      	ble.n	14cc8 <bt_mesh_friend_clear+0xbc>
		BT_WARN("LPN Counter out of range (old %u new %u)",
   14cb8:	4819      	ldr	r0, [pc, #100]	; (14d20 <bt_mesh_friend_clear+0x114>)
   14cba:	f045 0302 	orr.w	r3, r5, #2
   14cbe:	4632      	mov	r2, r6
   14cc0:	f00f f9a1 	bl	24006 <log_2>
	return 0;
   14cc4:	4620      	mov	r0, r4
   14cc6:	e7c7      	b.n	14c58 <bt_mesh_friend_clear+0x4c>
	tx.ctx->send_ttl = BT_MESH_TTL_MAX;
   14cc8:	9b04      	ldr	r3, [sp, #16]
   14cca:	227f      	movs	r2, #127	; 0x7f
   14ccc:	72da      	strb	r2, [r3, #11]
	cfm.lpn_addr    = msg->lpn_addr;
   14cce:	f898 2001 	ldrb.w	r2, [r8, #1]
   14cd2:	f898 3000 	ldrb.w	r3, [r8]
   14cd6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   14cda:	f8ad 3008 	strh.w	r3, [sp, #8]
	cfm.lpn_counter = msg->lpn_counter;
   14cde:	f898 2003 	ldrb.w	r2, [r8, #3]
   14ce2:	f898 3002 	ldrb.w	r3, [r8, #2]
   14ce6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   14cea:	f8ad 300a 	strh.w	r3, [sp, #10]
	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_FRIEND_CLEAR_CFM, &cfm,
   14cee:	e9cd 4400 	strd	r4, r4, [sp]
   14cf2:	2304      	movs	r3, #4
   14cf4:	aa02      	add	r2, sp, #8
   14cf6:	2106      	movs	r1, #6
   14cf8:	a803      	add	r0, sp, #12
   14cfa:	f012 fa83 	bl	27204 <bt_mesh_ctl_send>
	friend_clear(frnd);
   14cfe:	4638      	mov	r0, r7
   14d00:	f7ff f9d6 	bl	140b0 <friend_clear>
   14d04:	e7de      	b.n	14cc4 <bt_mesh_friend_clear+0xb8>
   14d06:	bf00      	nop
   14d08:	00029938 	.word	0x00029938
   14d0c:	00029830 	.word	0x00029830
   14d10:	0002ed06 	.word	0x0002ed06
   14d14:	0002f355 	.word	0x0002f355
   14d18:	0002ed1d 	.word	0x0002ed1d
   14d1c:	0002ed40 	.word	0x0002ed40
   14d20:	0002ed5c 	.word	0x0002ed5c

00014d24 <bt_mesh_friend_sub_add>:
{
   14d24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14d28:	460d      	mov	r5, r1
   14d2a:	4c2b      	ldr	r4, [pc, #172]	; (14dd8 <bt_mesh_friend_sub_add+0xb4>)
   14d2c:	492b      	ldr	r1, [pc, #172]	; (14ddc <bt_mesh_friend_sub_add+0xb8>)
	if (buf->len < BT_MESH_FRIEND_SUB_MIN_LEN) {
   14d2e:	88ab      	ldrh	r3, [r5, #4]
   14d30:	1a64      	subs	r4, r4, r1
   14d32:	2b02      	cmp	r3, #2
{
   14d34:	4606      	mov	r6, r0
   14d36:	ea4f 04d4 	mov.w	r4, r4, lsr #3
	if (buf->len < BT_MESH_FRIEND_SUB_MIN_LEN) {
   14d3a:	d809      	bhi.n	14d50 <bt_mesh_friend_sub_add+0x2c>
		BT_WARN("Too short Friend Subscription Add");
   14d3c:	01a1      	lsls	r1, r4, #6
   14d3e:	4828      	ldr	r0, [pc, #160]	; (14de0 <bt_mesh_friend_sub_add+0xbc>)
   14d40:	f041 0102 	orr.w	r1, r1, #2
   14d44:	f00f f93e 	bl	23fc4 <log_0>
		return -EINVAL;
   14d48:	f06f 0015 	mvn.w	r0, #21
}
   14d4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	frnd = bt_mesh_friend_find(rx->sub->net_idx, rx->ctx.addr, true, true);
   14d50:	6800      	ldr	r0, [r0, #0]
   14d52:	8931      	ldrh	r1, [r6, #8]
   14d54:	8b80      	ldrh	r0, [r0, #28]
   14d56:	2301      	movs	r3, #1
   14d58:	461a      	mov	r2, r3
   14d5a:	f7ff fe91 	bl	14a80 <bt_mesh_friend_find>
	if (!frnd) {
   14d5e:	4607      	mov	r7, r0
   14d60:	b940      	cbnz	r0, 14d74 <bt_mesh_friend_sub_add+0x50>
		BT_WARN("No matching LPN addr 0x%04x", rx->ctx.addr);
   14d62:	01a2      	lsls	r2, r4, #6
   14d64:	8931      	ldrh	r1, [r6, #8]
   14d66:	481f      	ldr	r0, [pc, #124]	; (14de4 <bt_mesh_friend_sub_add+0xc0>)
   14d68:	f042 0202 	orr.w	r2, r2, #2
   14d6c:	f00f f937 	bl	23fde <log_1>
	return 0;
   14d70:	2000      	movs	r0, #0
   14d72:	e7eb      	b.n	14d4c <bt_mesh_friend_sub_add+0x28>
	if (frnd->pending_buf) {
   14d74:	78c3      	ldrb	r3, [r0, #3]
   14d76:	071b      	lsls	r3, r3, #28
   14d78:	d506      	bpl.n	14d88 <bt_mesh_friend_sub_add+0x64>
		BT_WARN("Previous buffer not yet sent!");
   14d7a:	01a1      	lsls	r1, r4, #6
   14d7c:	481a      	ldr	r0, [pc, #104]	; (14de8 <bt_mesh_friend_sub_add+0xc4>)
   14d7e:	f041 0102 	orr.w	r1, r1, #2
   14d82:	f00f f91f 	bl	23fc4 <log_0>
		return 0;
   14d86:	e7f3      	b.n	14d70 <bt_mesh_friend_sub_add+0x4c>
	friend_recv_delay(frnd);
   14d88:	f7ff f8d0 	bl	13f2c <friend_recv_delay>
	xact = net_buf_simple_pull_u8(buf);
   14d8c:	4628      	mov	r0, r5
   14d8e:	f013 ffe2 	bl	28d56 <net_buf_simple_pull_u8>
	BT_WARN("No space in friend subscription list");
   14d92:	01a4      	lsls	r4, r4, #6
   14d94:	f8df 8054 	ldr.w	r8, [pc, #84]	; 14dec <bt_mesh_friend_sub_add+0xc8>
	xact = net_buf_simple_pull_u8(buf);
   14d98:	4606      	mov	r6, r0
	BT_WARN("No space in friend subscription list");
   14d9a:	f044 0402 	orr.w	r4, r4, #2
	while (buf->len >= 2U) {
   14d9e:	88ab      	ldrh	r3, [r5, #4]
   14da0:	2b01      	cmp	r3, #1
   14da2:	d804      	bhi.n	14dae <bt_mesh_friend_sub_add+0x8a>
	enqueue_sub_cfm(frnd, xact);
   14da4:	4631      	mov	r1, r6
   14da6:	4638      	mov	r0, r7
   14da8:	f7ff fc42 	bl	14630 <enqueue_sub_cfm>
   14dac:	e7e0      	b.n	14d70 <bt_mesh_friend_sub_add+0x4c>
		friend_sub_add(frnd, net_buf_simple_pull_be16(buf));
   14dae:	4628      	mov	r0, r5
   14db0:	f013 ffe1 	bl	28d76 <net_buf_simple_pull_be16>
		if (frnd->sub_list[i] == BT_MESH_ADDR_UNASSIGNED) {
   14db4:	8a3b      	ldrh	r3, [r7, #16]
   14db6:	b123      	cbz	r3, 14dc2 <bt_mesh_friend_sub_add+0x9e>
   14db8:	8a7b      	ldrh	r3, [r7, #18]
   14dba:	b133      	cbz	r3, 14dca <bt_mesh_friend_sub_add+0xa6>
   14dbc:	8abb      	ldrh	r3, [r7, #20]
   14dbe:	b933      	cbnz	r3, 14dce <bt_mesh_friend_sub_add+0xaa>
	for (i = 0; i < ARRAY_SIZE(frnd->sub_list); i++) {
   14dc0:	2302      	movs	r3, #2
			frnd->sub_list[i] = addr;
   14dc2:	3308      	adds	r3, #8
   14dc4:	f827 0013 	strh.w	r0, [r7, r3, lsl #1]
			return;
   14dc8:	e7e9      	b.n	14d9e <bt_mesh_friend_sub_add+0x7a>
	for (i = 0; i < ARRAY_SIZE(frnd->sub_list); i++) {
   14dca:	2301      	movs	r3, #1
   14dcc:	e7f9      	b.n	14dc2 <bt_mesh_friend_sub_add+0x9e>
	BT_WARN("No space in friend subscription list");
   14dce:	4621      	mov	r1, r4
   14dd0:	4640      	mov	r0, r8
   14dd2:	f00f f8f7 	bl	23fc4 <log_0>
   14dd6:	e7e2      	b.n	14d9e <bt_mesh_friend_sub_add+0x7a>
   14dd8:	00029938 	.word	0x00029938
   14ddc:	00029830 	.word	0x00029830
   14de0:	0002ed85 	.word	0x0002ed85
   14de4:	0002ed40 	.word	0x0002ed40
   14de8:	0002eda7 	.word	0x0002eda7
   14dec:	0002edc5 	.word	0x0002edc5

00014df0 <bt_mesh_friend_sub_rem>:
{
   14df0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buf->len < BT_MESH_FRIEND_SUB_MIN_LEN) {
   14df2:	888b      	ldrh	r3, [r1, #4]
   14df4:	2b02      	cmp	r3, #2
{
   14df6:	4606      	mov	r6, r0
   14df8:	460d      	mov	r5, r1
	if (buf->len < BT_MESH_FRIEND_SUB_MIN_LEN) {
   14dfa:	d80c      	bhi.n	14e16 <bt_mesh_friend_sub_rem+0x26>
   14dfc:	4b2a      	ldr	r3, [pc, #168]	; (14ea8 <bt_mesh_friend_sub_rem+0xb8>)
   14dfe:	492b      	ldr	r1, [pc, #172]	; (14eac <bt_mesh_friend_sub_rem+0xbc>)
		BT_WARN("Too short Friend Subscription Remove");
   14e00:	482b      	ldr	r0, [pc, #172]	; (14eb0 <bt_mesh_friend_sub_rem+0xc0>)
   14e02:	1ac9      	subs	r1, r1, r3
   14e04:	08c9      	lsrs	r1, r1, #3
   14e06:	0189      	lsls	r1, r1, #6
   14e08:	f041 0102 	orr.w	r1, r1, #2
   14e0c:	f00f f8da 	bl	23fc4 <log_0>
		return -EINVAL;
   14e10:	f06f 0015 	mvn.w	r0, #21
}
   14e14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	frnd = bt_mesh_friend_find(rx->sub->net_idx, rx->ctx.addr, true, true);
   14e16:	6800      	ldr	r0, [r0, #0]
   14e18:	8931      	ldrh	r1, [r6, #8]
   14e1a:	8b80      	ldrh	r0, [r0, #28]
   14e1c:	2301      	movs	r3, #1
   14e1e:	461a      	mov	r2, r3
   14e20:	f7ff fe2e 	bl	14a80 <bt_mesh_friend_find>
	if (!frnd) {
   14e24:	4604      	mov	r4, r0
   14e26:	b960      	cbnz	r0, 14e42 <bt_mesh_friend_sub_rem+0x52>
   14e28:	4a20      	ldr	r2, [pc, #128]	; (14eac <bt_mesh_friend_sub_rem+0xbc>)
   14e2a:	4b1f      	ldr	r3, [pc, #124]	; (14ea8 <bt_mesh_friend_sub_rem+0xb8>)
		BT_WARN("No matching LPN addr 0x%04x", rx->ctx.addr);
   14e2c:	8931      	ldrh	r1, [r6, #8]
   14e2e:	4821      	ldr	r0, [pc, #132]	; (14eb4 <bt_mesh_friend_sub_rem+0xc4>)
   14e30:	1ad2      	subs	r2, r2, r3
   14e32:	08d2      	lsrs	r2, r2, #3
   14e34:	0192      	lsls	r2, r2, #6
   14e36:	f042 0202 	orr.w	r2, r2, #2
   14e3a:	f00f f8d0 	bl	23fde <log_1>
	return 0;
   14e3e:	2000      	movs	r0, #0
   14e40:	e7e8      	b.n	14e14 <bt_mesh_friend_sub_rem+0x24>
	if (frnd->pending_buf) {
   14e42:	78c3      	ldrb	r3, [r0, #3]
   14e44:	f013 0608 	ands.w	r6, r3, #8
   14e48:	d00a      	beq.n	14e60 <bt_mesh_friend_sub_rem+0x70>
   14e4a:	4b17      	ldr	r3, [pc, #92]	; (14ea8 <bt_mesh_friend_sub_rem+0xb8>)
   14e4c:	4917      	ldr	r1, [pc, #92]	; (14eac <bt_mesh_friend_sub_rem+0xbc>)
		BT_WARN("Previous buffer not yet sent!");
   14e4e:	481a      	ldr	r0, [pc, #104]	; (14eb8 <bt_mesh_friend_sub_rem+0xc8>)
   14e50:	1ac9      	subs	r1, r1, r3
   14e52:	08c9      	lsrs	r1, r1, #3
   14e54:	0189      	lsls	r1, r1, #6
   14e56:	f041 0102 	orr.w	r1, r1, #2
   14e5a:	f00f f8b3 	bl	23fc4 <log_0>
		return 0;
   14e5e:	e7ee      	b.n	14e3e <bt_mesh_friend_sub_rem+0x4e>
	friend_recv_delay(frnd);
   14e60:	f7ff f864 	bl	13f2c <friend_recv_delay>
	xact = net_buf_simple_pull_u8(buf);
   14e64:	4628      	mov	r0, r5
   14e66:	f013 ff76 	bl	28d56 <net_buf_simple_pull_u8>
   14e6a:	4607      	mov	r7, r0
	while (buf->len >= 2U) {
   14e6c:	88ab      	ldrh	r3, [r5, #4]
   14e6e:	2b01      	cmp	r3, #1
   14e70:	d804      	bhi.n	14e7c <bt_mesh_friend_sub_rem+0x8c>
	enqueue_sub_cfm(frnd, xact);
   14e72:	4639      	mov	r1, r7
   14e74:	4620      	mov	r0, r4
   14e76:	f7ff fbdb 	bl	14630 <enqueue_sub_cfm>
   14e7a:	e7e0      	b.n	14e3e <bt_mesh_friend_sub_rem+0x4e>
		friend_sub_rem(frnd, net_buf_simple_pull_be16(buf));
   14e7c:	4628      	mov	r0, r5
   14e7e:	f013 ff7a 	bl	28d76 <net_buf_simple_pull_be16>
		if (frnd->sub_list[i] == addr) {
   14e82:	8a23      	ldrh	r3, [r4, #16]
   14e84:	4283      	cmp	r3, r0
   14e86:	d00a      	beq.n	14e9e <bt_mesh_friend_sub_rem+0xae>
   14e88:	8a63      	ldrh	r3, [r4, #18]
   14e8a:	4283      	cmp	r3, r0
   14e8c:	d009      	beq.n	14ea2 <bt_mesh_friend_sub_rem+0xb2>
   14e8e:	8aa3      	ldrh	r3, [r4, #20]
   14e90:	4283      	cmp	r3, r0
   14e92:	d1eb      	bne.n	14e6c <bt_mesh_friend_sub_rem+0x7c>
	for (i = 0; i < ARRAY_SIZE(frnd->sub_list); i++) {
   14e94:	2302      	movs	r3, #2
			frnd->sub_list[i] = BT_MESH_ADDR_UNASSIGNED;
   14e96:	3308      	adds	r3, #8
   14e98:	f824 6013 	strh.w	r6, [r4, r3, lsl #1]
			return;
   14e9c:	e7e6      	b.n	14e6c <bt_mesh_friend_sub_rem+0x7c>
	for (i = 0; i < ARRAY_SIZE(frnd->sub_list); i++) {
   14e9e:	2300      	movs	r3, #0
   14ea0:	e7f9      	b.n	14e96 <bt_mesh_friend_sub_rem+0xa6>
   14ea2:	2301      	movs	r3, #1
   14ea4:	e7f7      	b.n	14e96 <bt_mesh_friend_sub_rem+0xa6>
   14ea6:	bf00      	nop
   14ea8:	00029830 	.word	0x00029830
   14eac:	00029938 	.word	0x00029938
   14eb0:	0002edea 	.word	0x0002edea
   14eb4:	0002ed40 	.word	0x0002ed40
   14eb8:	0002eda7 	.word	0x0002eda7

00014ebc <bt_mesh_friend_poll>:
{
   14ebc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   14ec0:	4b3d      	ldr	r3, [pc, #244]	; (14fb8 <bt_mesh_friend_poll+0xfc>)
   14ec2:	4d3e      	ldr	r5, [pc, #248]	; (14fbc <bt_mesh_friend_poll+0x100>)
	struct bt_mesh_ctl_friend_poll *msg = (void *)buf->data;
   14ec4:	680f      	ldr	r7, [r1, #0]
	if (buf->len < sizeof(*msg)) {
   14ec6:	1aed      	subs	r5, r5, r3
   14ec8:	888b      	ldrh	r3, [r1, #4]
   14eca:	08ed      	lsrs	r5, r5, #3
{
   14ecc:	4606      	mov	r6, r0
   14ece:	01ad      	lsls	r5, r5, #6
	if (buf->len < sizeof(*msg)) {
   14ed0:	b93b      	cbnz	r3, 14ee2 <bt_mesh_friend_poll+0x26>
		BT_WARN("Too short Friend Poll");
   14ed2:	483b      	ldr	r0, [pc, #236]	; (14fc0 <bt_mesh_friend_poll+0x104>)
   14ed4:	f045 0102 	orr.w	r1, r5, #2
		BT_WARN("Prohibited (non-zero) padding bits");
   14ed8:	f00f f874 	bl	23fc4 <log_0>
		return -EINVAL;
   14edc:	f06f 0615 	mvn.w	r6, #21
   14ee0:	e00f      	b.n	14f02 <bt_mesh_friend_poll+0x46>
	frnd = bt_mesh_friend_find(rx->sub->net_idx, rx->ctx.addr, true, false);
   14ee2:	6800      	ldr	r0, [r0, #0]
   14ee4:	8931      	ldrh	r1, [r6, #8]
   14ee6:	8b80      	ldrh	r0, [r0, #28]
   14ee8:	2300      	movs	r3, #0
   14eea:	2201      	movs	r2, #1
   14eec:	f7ff fdc8 	bl	14a80 <bt_mesh_friend_find>
	if (!frnd) {
   14ef0:	4604      	mov	r4, r0
   14ef2:	b950      	cbnz	r0, 14f0a <bt_mesh_friend_poll+0x4e>
		BT_WARN("No matching LPN addr 0x%04x", rx->ctx.addr);
   14ef4:	8931      	ldrh	r1, [r6, #8]
   14ef6:	4833      	ldr	r0, [pc, #204]	; (14fc4 <bt_mesh_friend_poll+0x108>)
   14ef8:	f045 0202 	orr.w	r2, r5, #2
   14efc:	f00f f86f 	bl	23fde <log_1>
		return 0;
   14f00:	4626      	mov	r6, r4
}
   14f02:	4630      	mov	r0, r6
   14f04:	b002      	add	sp, #8
   14f06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (msg->fsn & ~1) {
   14f0a:	783a      	ldrb	r2, [r7, #0]
   14f0c:	f032 0601 	bics.w	r6, r2, #1
   14f10:	d003      	beq.n	14f1a <bt_mesh_friend_poll+0x5e>
		BT_WARN("Prohibited (non-zero) padding bits");
   14f12:	482d      	ldr	r0, [pc, #180]	; (14fc8 <bt_mesh_friend_poll+0x10c>)
   14f14:	f045 0102 	orr.w	r1, r5, #2
   14f18:	e7de      	b.n	14ed8 <bt_mesh_friend_poll+0x1c>
	if (frnd->pending_buf) {
   14f1a:	78c3      	ldrb	r3, [r0, #3]
   14f1c:	0719      	lsls	r1, r3, #28
   14f1e:	d505      	bpl.n	14f2c <bt_mesh_friend_poll+0x70>
		BT_WARN("Previous buffer not yet sent");
   14f20:	482a      	ldr	r0, [pc, #168]	; (14fcc <bt_mesh_friend_poll+0x110>)
   14f22:	f045 0102 	orr.w	r1, r5, #2
   14f26:	f00f f84d 	bl	23fc4 <log_0>
		return 0;
   14f2a:	e7ea      	b.n	14f02 <bt_mesh_friend_poll+0x46>
	BT_DBG("msg->fsn %u frnd->fsn %u", (msg->fsn & 1), frnd->fsn);
   14f2c:	f045 0804 	orr.w	r8, r5, #4
   14f30:	f003 0301 	and.w	r3, r3, #1
   14f34:	4926      	ldr	r1, [pc, #152]	; (14fd0 <bt_mesh_friend_poll+0x114>)
   14f36:	4827      	ldr	r0, [pc, #156]	; (14fd4 <bt_mesh_friend_poll+0x118>)
   14f38:	f8ad 8000 	strh.w	r8, [sp]
   14f3c:	f002 0201 	and.w	r2, r2, #1
   14f40:	f00f f87a 	bl	24038 <log_3>
	friend_recv_delay(frnd);
   14f44:	4620      	mov	r0, r4
   14f46:	f7fe fff1 	bl	13f2c <friend_recv_delay>
	if (!frnd->established) {
   14f4a:	78e3      	ldrb	r3, [r4, #3]
   14f4c:	069b      	lsls	r3, r3, #26
   14f4e:	d409      	bmi.n	14f64 <bt_mesh_friend_poll+0xa8>
		BT_DBG("Friendship established with 0x%04x", frnd->lpn);
   14f50:	4643      	mov	r3, r8
   14f52:	8822      	ldrh	r2, [r4, #0]
   14f54:	491e      	ldr	r1, [pc, #120]	; (14fd0 <bt_mesh_friend_poll+0x114>)
   14f56:	4820      	ldr	r0, [pc, #128]	; (14fd8 <bt_mesh_friend_poll+0x11c>)
   14f58:	f00f f855 	bl	24006 <log_2>
		frnd->established = 1U;
   14f5c:	78e3      	ldrb	r3, [r4, #3]
   14f5e:	f043 0320 	orr.w	r3, r3, #32
   14f62:	70e3      	strb	r3, [r4, #3]
	if (msg->fsn == frnd->fsn && frnd->last) {
   14f64:	78e3      	ldrb	r3, [r4, #3]
   14f66:	783a      	ldrb	r2, [r7, #0]
   14f68:	6c60      	ldr	r0, [r4, #68]	; 0x44
   14f6a:	f003 0301 	and.w	r3, r3, #1
   14f6e:	429a      	cmp	r2, r3
   14f70:	d10b      	bne.n	14f8a <bt_mesh_friend_poll+0xce>
   14f72:	b178      	cbz	r0, 14f94 <bt_mesh_friend_poll+0xd8>
		BT_DBG("Re-sending last PDU");
   14f74:	4916      	ldr	r1, [pc, #88]	; (14fd0 <bt_mesh_friend_poll+0x114>)
   14f76:	4819      	ldr	r0, [pc, #100]	; (14fdc <bt_mesh_friend_poll+0x120>)
   14f78:	f045 0204 	orr.w	r2, r5, #4
   14f7c:	f00f f82f 	bl	23fde <log_1>
		frnd->send_last = 1U;
   14f80:	78e3      	ldrb	r3, [r4, #3]
   14f82:	f043 0302 	orr.w	r3, r3, #2
   14f86:	70e3      	strb	r3, [r4, #3]
   14f88:	e7bb      	b.n	14f02 <bt_mesh_friend_poll+0x46>
		if (frnd->last) {
   14f8a:	b118      	cbz	r0, 14f94 <bt_mesh_friend_poll+0xd8>
			net_buf_unref(frnd->last);
   14f8c:	f00a f89c 	bl	1f0c8 <net_buf_unref>
			frnd->last = NULL;
   14f90:	2300      	movs	r3, #0
   14f92:	6463      	str	r3, [r4, #68]	; 0x44
		frnd->fsn = msg->fsn;
   14f94:	78e3      	ldrb	r3, [r4, #3]
   14f96:	783a      	ldrb	r2, [r7, #0]
   14f98:	f362 0300 	bfi	r3, r2, #0, #1
   14f9c:	70e3      	strb	r3, [r4, #3]
		if (sys_slist_is_empty(&frnd->queue)) {
   14f9e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   14fa0:	2b00      	cmp	r3, #0
   14fa2:	d1ae      	bne.n	14f02 <bt_mesh_friend_poll+0x46>
			enqueue_update(frnd, 0);
   14fa4:	4620      	mov	r0, r4
   14fa6:	f7ff fc79 	bl	1489c <enqueue_update.constprop.0>
			BT_DBG("Enqueued Friend Update to empty queue");
   14faa:	4909      	ldr	r1, [pc, #36]	; (14fd0 <bt_mesh_friend_poll+0x114>)
   14fac:	480c      	ldr	r0, [pc, #48]	; (14fe0 <bt_mesh_friend_poll+0x124>)
   14fae:	f045 0204 	orr.w	r2, r5, #4
   14fb2:	f00f f814 	bl	23fde <log_1>
   14fb6:	e7a4      	b.n	14f02 <bt_mesh_friend_poll+0x46>
   14fb8:	00029830 	.word	0x00029830
   14fbc:	00029938 	.word	0x00029938
   14fc0:	0002ee0f 	.word	0x0002ee0f
   14fc4:	0002ed40 	.word	0x0002ed40
   14fc8:	0002ee25 	.word	0x0002ee25
   14fcc:	0002ee48 	.word	0x0002ee48
   14fd0:	0002f3ac 	.word	0x0002f3ac
   14fd4:	0002ee65 	.word	0x0002ee65
   14fd8:	0002ee82 	.word	0x0002ee82
   14fdc:	0002eea9 	.word	0x0002eea9
   14fe0:	0002eec1 	.word	0x0002eec1

00014fe4 <bt_mesh_friend_clear_cfm>:
{
   14fe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14fe6:	4b27      	ldr	r3, [pc, #156]	; (15084 <bt_mesh_friend_clear_cfm+0xa0>)
   14fe8:	4c27      	ldr	r4, [pc, #156]	; (15088 <bt_mesh_friend_clear_cfm+0xa4>)
	struct bt_mesh_ctl_friend_clear_confirm *msg = (void *)buf->data;
   14fea:	680e      	ldr	r6, [r1, #0]
   14fec:	1ae4      	subs	r4, r4, r3
   14fee:	08e4      	lsrs	r4, r4, #3
{
   14ff0:	460d      	mov	r5, r1
	BT_DBG("");
   14ff2:	01a4      	lsls	r4, r4, #6
   14ff4:	4925      	ldr	r1, [pc, #148]	; (1508c <bt_mesh_friend_clear_cfm+0xa8>)
{
   14ff6:	4607      	mov	r7, r0
	BT_DBG("");
   14ff8:	f044 0204 	orr.w	r2, r4, #4
   14ffc:	4824      	ldr	r0, [pc, #144]	; (15090 <bt_mesh_friend_clear_cfm+0xac>)
   14ffe:	f00e ffee 	bl	23fde <log_1>
	if (buf->len < sizeof(*msg)) {
   15002:	88ab      	ldrh	r3, [r5, #4]
   15004:	2b03      	cmp	r3, #3
   15006:	d807      	bhi.n	15018 <bt_mesh_friend_clear_cfm+0x34>
		BT_WARN("Too short Friend Clear Confirm");
   15008:	4822      	ldr	r0, [pc, #136]	; (15094 <bt_mesh_friend_clear_cfm+0xb0>)
   1500a:	f044 0102 	orr.w	r1, r4, #2
   1500e:	f00e ffd9 	bl	23fc4 <log_0>
		return -EINVAL;
   15012:	f06f 0015 	mvn.w	r0, #21
}
   15016:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (frnd->clear.frnd == prev_friend) {
   15018:	4d1f      	ldr	r5, [pc, #124]	; (15098 <bt_mesh_friend_clear_cfm+0xb4>)
	frnd = find_clear(rx->ctx.addr);
   1501a:	8939      	ldrh	r1, [r7, #8]
		if (frnd->clear.frnd == prev_friend) {
   1501c:	f8b5 3078 	ldrh.w	r3, [r5, #120]	; 0x78
   15020:	428b      	cmp	r3, r1
   15022:	d01e      	beq.n	15062 <bt_mesh_friend_clear_cfm+0x7e>
   15024:	f8b5 30f4 	ldrh.w	r3, [r5, #244]	; 0xf4
   15028:	428b      	cmp	r3, r1
   1502a:	d029      	beq.n	15080 <bt_mesh_friend_clear_cfm+0x9c>
		BT_WARN("No pending clear procedure for 0x%02x", rx->ctx.addr);
   1502c:	481b      	ldr	r0, [pc, #108]	; (1509c <bt_mesh_friend_clear_cfm+0xb8>)
   1502e:	f044 0202 	orr.w	r2, r4, #2
   15032:	f00e ffd4 	bl	23fde <log_1>
		return 0;
   15036:	2000      	movs	r0, #0
   15038:	e7ed      	b.n	15016 <bt_mesh_friend_clear_cfm+0x32>
	lpn_counter = sys_be16_to_cpu(msg->lpn_counter);
   1503a:	8873      	ldrh	r3, [r6, #2]
	if (lpn_counter != frnd->lpn_counter) {
   1503c:	896a      	ldrh	r2, [r5, #10]
	lpn_counter = sys_be16_to_cpu(msg->lpn_counter);
   1503e:	0219      	lsls	r1, r3, #8
   15040:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
   15044:	b289      	uxth	r1, r1
	if (lpn_counter != frnd->lpn_counter) {
   15046:	4291      	cmp	r1, r2
   15048:	d003      	beq.n	15052 <bt_mesh_friend_clear_cfm+0x6e>
		BT_WARN("LPN counter mismatch (0x%04x != 0x%04x)",
   1504a:	4815      	ldr	r0, [pc, #84]	; (150a0 <bt_mesh_friend_clear_cfm+0xbc>)
   1504c:	f044 0302 	orr.w	r3, r4, #2
   15050:	e013      	b.n	1507a <bt_mesh_friend_clear_cfm+0x96>
	k_delayed_work_cancel(&frnd->clear.timer);
   15052:	f105 005c 	add.w	r0, r5, #92	; 0x5c
   15056:	f00d fe13 	bl	22c80 <k_delayed_work_cancel>
	frnd->clear.frnd = BT_MESH_ADDR_UNASSIGNED;
   1505a:	2000      	movs	r0, #0
   1505c:	f8a5 0058 	strh.w	r0, [r5, #88]	; 0x58
	return 0;
   15060:	e7d9      	b.n	15016 <bt_mesh_friend_clear_cfm+0x32>
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];
   15062:	3520      	adds	r5, #32
	lpn_addr = sys_be16_to_cpu(msg->lpn_addr);
   15064:	8833      	ldrh	r3, [r6, #0]
	if (lpn_addr != frnd->lpn) {
   15066:	882a      	ldrh	r2, [r5, #0]
	lpn_addr = sys_be16_to_cpu(msg->lpn_addr);
   15068:	0219      	lsls	r1, r3, #8
   1506a:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
   1506e:	b289      	uxth	r1, r1
	if (lpn_addr != frnd->lpn) {
   15070:	428a      	cmp	r2, r1
   15072:	d0e2      	beq.n	1503a <bt_mesh_friend_clear_cfm+0x56>
		BT_WARN("LPN address mismatch (0x%04x != 0x%04x)",
   15074:	480b      	ldr	r0, [pc, #44]	; (150a4 <bt_mesh_friend_clear_cfm+0xc0>)
   15076:	f044 0302 	orr.w	r3, r4, #2
		BT_WARN("LPN counter mismatch (0x%04x != 0x%04x)",
   1507a:	f00e ffc4 	bl	24006 <log_2>
   1507e:	e7da      	b.n	15036 <bt_mesh_friend_clear_cfm+0x52>
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];
   15080:	359c      	adds	r5, #156	; 0x9c
   15082:	e7ef      	b.n	15064 <bt_mesh_friend_clear_cfm+0x80>
   15084:	00029830 	.word	0x00029830
   15088:	00029938 	.word	0x00029938
   1508c:	0002f3f6 	.word	0x0002f3f6
   15090:	0002aa84 	.word	0x0002aa84
   15094:	0002eeeb 	.word	0x0002eeeb
   15098:	20006b48 	.word	0x20006b48
   1509c:	0002ef0a 	.word	0x0002ef0a
   150a0:	0002ef58 	.word	0x0002ef58
   150a4:	0002ef30 	.word	0x0002ef30

000150a8 <bt_mesh_friend_req>:
{
   150a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   150ac:	4bac      	ldr	r3, [pc, #688]	; (15360 <bt_mesh_friend_req+0x2b8>)
   150ae:	4dad      	ldr	r5, [pc, #692]	; (15364 <bt_mesh_friend_req+0x2bc>)
	struct bt_mesh_ctl_friend_req *msg = (void *)buf->data;
   150b0:	680f      	ldr	r7, [r1, #0]
	if (buf->len < sizeof(*msg)) {
   150b2:	1aed      	subs	r5, r5, r3
   150b4:	888b      	ldrh	r3, [r1, #4]
   150b6:	08ed      	lsrs	r5, r5, #3
   150b8:	2b09      	cmp	r3, #9
{
   150ba:	b08b      	sub	sp, #44	; 0x2c
   150bc:	4606      	mov	r6, r0
   150be:	ea4f 1585 	mov.w	r5, r5, lsl #6
	if (buf->len < sizeof(*msg)) {
   150c2:	d805      	bhi.n	150d0 <bt_mesh_friend_req+0x28>
		BT_WARN("Too short Friend Request");
   150c4:	48a8      	ldr	r0, [pc, #672]	; (15368 <bt_mesh_friend_req+0x2c0>)
   150c6:	f045 0102 	orr.w	r1, r5, #2
		BT_WARN("Prohibited Minimum Queue Size in Friend Request");
   150ca:	f00e ff7b 	bl	23fc4 <log_0>
		return -EINVAL;
   150ce:	e007      	b.n	150e0 <bt_mesh_friend_req+0x38>
	if (msg->recv_delay <= 0x09) {
   150d0:	7879      	ldrb	r1, [r7, #1]
   150d2:	2909      	cmp	r1, #9
   150d4:	d80a      	bhi.n	150ec <bt_mesh_friend_req+0x44>
		BT_WARN("Prohibited ReceiveDelay (0x%02x)", msg->recv_delay);
   150d6:	48a5      	ldr	r0, [pc, #660]	; (1536c <bt_mesh_friend_req+0x2c4>)
   150d8:	f045 0202 	orr.w	r2, r5, #2
   150dc:	f00e ff7f 	bl	23fde <log_1>
		return -EINVAL;
   150e0:	f06f 0515 	mvn.w	r5, #21
}
   150e4:	4628      	mov	r0, r5
   150e6:	b00b      	add	sp, #44	; 0x2c
   150e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return ((u16_t)src[0] << 8) | src[1];
   150ec:	78fb      	ldrb	r3, [r7, #3]
   150ee:	f897 8004 	ldrb.w	r8, [r7, #4]
	return ((u32_t)src[0] << 16) | sys_get_be16(&src[1]);
   150f2:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
   150f6:	78bb      	ldrb	r3, [r7, #2]
   150f8:	ea48 4803 	orr.w	r8, r8, r3, lsl #16
	if (poll_to <= 0x000009 || poll_to >= 0x34bc00) {
   150fc:	4b9c      	ldr	r3, [pc, #624]	; (15370 <bt_mesh_friend_req+0x2c8>)
   150fe:	f1a8 020a 	sub.w	r2, r8, #10
   15102:	429a      	cmp	r2, r3
   15104:	d904      	bls.n	15110 <bt_mesh_friend_req+0x68>
		BT_WARN("Prohibited PollTimeout (0x%06x)", poll_to);
   15106:	489b      	ldr	r0, [pc, #620]	; (15374 <bt_mesh_friend_req+0x2cc>)
   15108:	f045 0202 	orr.w	r2, r5, #2
   1510c:	4641      	mov	r1, r8
   1510e:	e7e5      	b.n	150dc <bt_mesh_friend_req+0x34>
	if (msg->num_elem == 0x00) {
   15110:	79fb      	ldrb	r3, [r7, #7]
   15112:	b91b      	cbnz	r3, 1511c <bt_mesh_friend_req+0x74>
		BT_WARN("Prohibited NumElements value (0x00)");
   15114:	4898      	ldr	r0, [pc, #608]	; (15378 <bt_mesh_friend_req+0x2d0>)
   15116:	f045 0102 	orr.w	r1, r5, #2
   1511a:	e7d6      	b.n	150ca <bt_mesh_friend_req+0x22>
	if (!BT_MESH_ADDR_IS_UNICAST(rx->ctx.addr + msg->num_elem - 1)) {
   1511c:	8901      	ldrh	r1, [r0, #8]
   1511e:	440b      	add	r3, r1
   15120:	2b01      	cmp	r3, #1
   15122:	d003      	beq.n	1512c <bt_mesh_friend_req+0x84>
   15124:	3b01      	subs	r3, #1
   15126:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1512a:	db03      	blt.n	15134 <bt_mesh_friend_req+0x8c>
		BT_WARN("LPN elements stretch outside of unicast range");
   1512c:	4893      	ldr	r0, [pc, #588]	; (1537c <bt_mesh_friend_req+0x2d4>)
   1512e:	f045 0102 	orr.w	r1, r5, #2
   15132:	e7ca      	b.n	150ca <bt_mesh_friend_req+0x22>
	if (!MIN_QUEUE_SIZE_LOG(msg->criteria)) {
   15134:	783a      	ldrb	r2, [r7, #0]
   15136:	f012 0307 	ands.w	r3, r2, #7
   1513a:	d103      	bne.n	15144 <bt_mesh_friend_req+0x9c>
		BT_WARN("Prohibited Minimum Queue Size in Friend Request");
   1513c:	4890      	ldr	r0, [pc, #576]	; (15380 <bt_mesh_friend_req+0x2d8>)
   1513e:	f045 0102 	orr.w	r1, r5, #2
   15142:	e7c2      	b.n	150ca <bt_mesh_friend_req+0x22>
	if (CONFIG_BT_MESH_FRIEND_QUEUE_SIZE < MIN_QUEUE_SIZE(msg->criteria)) {
   15144:	2401      	movs	r4, #1
   15146:	fa04 f203 	lsl.w	r2, r4, r3
   1514a:	2a10      	cmp	r2, #16
   1514c:	d907      	bls.n	1515e <bt_mesh_friend_req+0xb6>
		BT_WARN("We have a too small Friend Queue size (%u < %u)",
   1514e:	488d      	ldr	r0, [pc, #564]	; (15384 <bt_mesh_friend_req+0x2dc>)
   15150:	f045 0302 	orr.w	r3, r5, #2
   15154:	2110      	movs	r1, #16
   15156:	f00e ff56 	bl	24006 <log_2>
	return 0;
   1515a:	2500      	movs	r5, #0
   1515c:	e7c2      	b.n	150e4 <bt_mesh_friend_req+0x3c>
	frnd = bt_mesh_friend_find(rx->sub->net_idx, rx->ctx.addr, true, false);
   1515e:	6800      	ldr	r0, [r0, #0]
   15160:	4622      	mov	r2, r4
   15162:	8b80      	ldrh	r0, [r0, #28]
   15164:	2300      	movs	r3, #0
   15166:	f7ff fc8b 	bl	14a80 <bt_mesh_friend_find>
	if (frnd) {
   1516a:	4604      	mov	r4, r0
   1516c:	b990      	cbnz	r0, 15194 <bt_mesh_friend_req+0xec>
		if (!bt_mesh.frnd[i].valid) {
   1516e:	4b86      	ldr	r3, [pc, #536]	; (15388 <bt_mesh_friend_req+0x2e0>)
   15170:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
   15174:	06d1      	lsls	r1, r2, #27
   15176:	f140 80cd 	bpl.w	15314 <bt_mesh_friend_req+0x26c>
   1517a:	f893 209f 	ldrb.w	r2, [r3, #159]	; 0x9f
   1517e:	06d2      	lsls	r2, r2, #27
   15180:	f140 80d6 	bpl.w	15330 <bt_mesh_friend_req+0x288>
		BT_WARN("No free Friend contexts for new LPN");
   15184:	f045 0102 	orr.w	r1, r5, #2
   15188:	4880      	ldr	r0, [pc, #512]	; (1538c <bt_mesh_friend_req+0x2e4>)
   1518a:	f00e ff1b 	bl	23fc4 <log_0>
		return -ENOMEM;
   1518e:	f06f 050b 	mvn.w	r5, #11
   15192:	e7a7      	b.n	150e4 <bt_mesh_friend_req+0x3c>
		BT_WARN("Existing LPN re-requesting Friendship");
   15194:	487e      	ldr	r0, [pc, #504]	; (15390 <bt_mesh_friend_req+0x2e8>)
   15196:	f045 0102 	orr.w	r1, r5, #2
   1519a:	f00e ff13 	bl	23fc4 <log_0>
		friend_clear(frnd);
   1519e:	4620      	mov	r0, r4
   151a0:	f7fe ff86 	bl	140b0 <friend_clear>
	frnd->lpn = rx->ctx.addr;
   151a4:	8930      	ldrh	r0, [r6, #8]
   151a6:	8020      	strh	r0, [r4, #0]
	frnd->num_elem = msg->num_elem;
   151a8:	79fb      	ldrb	r3, [r7, #7]
   151aa:	7223      	strb	r3, [r4, #8]
	frnd->net_idx = rx->sub->net_idx;
   151ac:	6833      	ldr	r3, [r6, #0]
   151ae:	8b9b      	ldrh	r3, [r3, #28]
   151b0:	81e3      	strh	r3, [r4, #14]
	frnd->poll_to = poll_to * 100U;
   151b2:	2364      	movs	r3, #100	; 0x64
	frnd->recv_delay = msg->recv_delay;
   151b4:	7879      	ldrb	r1, [r7, #1]
   151b6:	70a1      	strb	r1, [r4, #2]
	frnd->poll_to = poll_to * 100U;
   151b8:	fb03 f308 	mul.w	r3, r3, r8
   151bc:	6063      	str	r3, [r4, #4]
	frnd->lpn_counter = sys_be16_to_cpu(msg->lpn_counter);
   151be:	f8b7 c008 	ldrh.w	ip, [r7, #8]
   151c2:	ea4f 220c 	mov.w	r2, ip, lsl #8
   151c6:	ea42 221c 	orr.w	r2, r2, ip, lsr #8
   151ca:	8162      	strh	r2, [r4, #10]
	frnd->clear.frnd = sys_be16_to_cpu(msg->prev_addr);
   151cc:	f8b7 c005 	ldrh.w	ip, [r7, #5]
   151d0:	ea4f 220c 	mov.w	r2, ip, lsl #8
   151d4:	ea42 221c 	orr.w	r2, r2, ip, lsr #8
   151d8:	f8a4 2058 	strh.w	r2, [r4, #88]	; 0x58
	BT_DBG("LPN 0x%04x rssi %d recv_delay %u poll_to %ums",
   151dc:	4a6d      	ldr	r2, [pc, #436]	; (15394 <bt_mesh_friend_req+0x2ec>)
   151de:	9309      	str	r3, [sp, #36]	; 0x24
   151e0:	e9cd 2005 	strd	r2, r0, [sp, #20]
   151e4:	f996 200c 	ldrsb.w	r2, [r6, #12]
   151e8:	486b      	ldr	r0, [pc, #428]	; (15398 <bt_mesh_friend_req+0x2f0>)
   151ea:	f045 0804 	orr.w	r8, r5, #4
   151ee:	e9cd 2107 	strd	r2, r1, [sp, #28]
   151f2:	4643      	mov	r3, r8
   151f4:	2205      	movs	r2, #5
   151f6:	a905      	add	r1, sp, #20
   151f8:	f00e ff3a 	bl	24070 <log_n>
	if (BT_MESH_ADDR_IS_UNICAST(frnd->clear.frnd) &&
   151fc:	f9b4 3058 	ldrsh.w	r3, [r4, #88]	; 0x58
   15200:	f8b4 0058 	ldrh.w	r0, [r4, #88]	; 0x58
   15204:	2b00      	cmp	r3, #0
   15206:	dd1e      	ble.n	15246 <bt_mesh_friend_req+0x19e>
	    !bt_mesh_elem_find(frnd->clear.frnd)) {
   15208:	f7fa fc56 	bl	fab8 <bt_mesh_elem_find>
	if (BT_MESH_ADDR_IS_UNICAST(frnd->clear.frnd) &&
   1520c:	b9d8      	cbnz	r0, 15246 <bt_mesh_friend_req+0x19e>
	BT_DBG("LPN 0x%04x (old) Friend 0x%04x", frnd->lpn, frnd->clear.frnd);
   1520e:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   15212:	8822      	ldrh	r2, [r4, #0]
   15214:	4961      	ldr	r1, [pc, #388]	; (1539c <bt_mesh_friend_req+0x2f4>)
   15216:	4862      	ldr	r0, [pc, #392]	; (153a0 <bt_mesh_friend_req+0x2f8>)
   15218:	f8ad 8000 	strh.w	r8, [sp]
   1521c:	f00e ff0c 	bl	24038 <log_3>
   15220:	f014 f8f7 	bl	29412 <z_impl_k_uptime_ticks>
   15224:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   15228:	460a      	mov	r2, r1
   1522a:	fba0 0103 	umull	r0, r1, r0, r3
   1522e:	fb03 1102 	mla	r1, r3, r2, r1
   15232:	0bc3      	lsrs	r3, r0, #15
   15234:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
	return (u32_t)k_uptime_get();
   15238:	6563      	str	r3, [r4, #84]	; 0x54
	frnd->clear.repeat_sec = 1U;
   1523a:	2301      	movs	r3, #1
   1523c:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
	send_friend_clear(frnd);
   15240:	4620      	mov	r0, r4
   15242:	f7fe fe19 	bl	13e78 <send_friend_clear>
	k_delayed_work_submit(&frnd->timer,
   15246:	783b      	ldrb	r3, [r7, #0]
	BT_DBG("ReceiveWindowFactor %u ReceiveWindow %u RSSIFactor %u RSSI %d",
   15248:	4a56      	ldr	r2, [pc, #344]	; (153a4 <bt_mesh_friend_req+0x2fc>)
	k_delayed_work_submit(&frnd->timer,
   1524a:	f996 a00c 	ldrsb.w	sl, [r6, #12]
	BT_DBG("ReceiveWindowFactor %u ReceiveWindow %u RSSIFactor %u RSSI %d",
   1524e:	f8df 916c 	ldr.w	r9, [pc, #364]	; 153bc <bt_mesh_friend_req+0x314>
   15252:	4855      	ldr	r0, [pc, #340]	; (153a8 <bt_mesh_friend_req+0x300>)
   15254:	f8cd 9014 	str.w	r9, [sp, #20]
   15258:	f3c3 01c1 	ubfx	r1, r3, #3, #2
   1525c:	f3c3 1341 	ubfx	r3, r3, #5, #2
   15260:	5c57      	ldrb	r7, [r2, r1]
   15262:	f812 b003 	ldrb.w	fp, [r2, r3]
   15266:	9706      	str	r7, [sp, #24]
   15268:	f045 0804 	orr.w	r8, r5, #4
   1526c:	21ff      	movs	r1, #255	; 0xff
   1526e:	9107      	str	r1, [sp, #28]
   15270:	4643      	mov	r3, r8
   15272:	2205      	movs	r2, #5
   15274:	a905      	add	r1, sp, #20
	delay = (s32_t)fact[RECV_WIN_FACT(crit)] * RECV_WIN;
   15276:	ebc7 2707 	rsb	r7, r7, r7, lsl #8
	BT_DBG("ReceiveWindowFactor %u ReceiveWindow %u RSSIFactor %u RSSI %d",
   1527a:	e9cd ba08 	strd	fp, sl, [sp, #32]
   1527e:	f00e fef7 	bl	24070 <log_n>
	delay -= (s32_t)fact[RSSI_FACT(crit)] * rssi;
   15282:	fb0b 7a1a 	mls	sl, fp, sl, r7
	BT_DBG("Local Delay calculated as %d ms", delay);
   15286:	4649      	mov	r1, r9
   15288:	4643      	mov	r3, r8
   1528a:	4848      	ldr	r0, [pc, #288]	; (153ac <bt_mesh_friend_req+0x304>)
	delay /= 10;
   1528c:	270a      	movs	r7, #10
   1528e:	fb9a f7f7 	sdiv	r7, sl, r7
	BT_DBG("Local Delay calculated as %d ms", delay);
   15292:	463a      	mov	r2, r7
   15294:	f00e feb7 	bl	24006 <log_2>
		return K_MSEC(100);
   15298:	f5ba 7f7a 	cmp.w	sl, #1000	; 0x3e8
	k_delayed_work_submit(&frnd->timer,
   1529c:	bfac      	ite	ge
   1529e:	4639      	movge	r1, r7
   152a0:	2164      	movlt	r1, #100	; 0x64
   152a2:	f104 0018 	add.w	r0, r4, #24
   152a6:	f7fe fe39 	bl	13f1c <k_delayed_work_submit>
	friend_cred_create(rx->sub, frnd->lpn, frnd->lpn_counter,
   152aa:	89a3      	ldrh	r3, [r4, #12]
   152ac:	8962      	ldrh	r2, [r4, #10]
   152ae:	8821      	ldrh	r1, [r4, #0]
   152b0:	6830      	ldr	r0, [r6, #0]
   152b2:	f7f7 fcbd 	bl	cc30 <friend_cred_create>
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*off));
   152b6:	ab03      	add	r3, sp, #12
   152b8:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
   152bc:	e9cd 2306 	strd	r2, r3, [sp, #24]
	BT_DBG("");
   152c0:	493b      	ldr	r1, [pc, #236]	; (153b0 <bt_mesh_friend_req+0x308>)
   152c2:	483c      	ldr	r0, [pc, #240]	; (153b4 <bt_mesh_friend_req+0x30c>)
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*off));
   152c4:	9305      	str	r3, [sp, #20]
	BT_DBG("");
   152c6:	4642      	mov	r2, r8
	enqueue_offer(frnd, rx->ctx.recv_rssi);
   152c8:	f996 600c 	ldrsb.w	r6, [r6, #12]
	BT_DBG("");
   152cc:	f00e fe87 	bl	23fde <log_1>
	net_buf_simple_reserve(&sdu, 1);
   152d0:	2101      	movs	r1, #1
   152d2:	a805      	add	r0, sp, #20
   152d4:	f009 fdf4 	bl	1eec0 <net_buf_simple_reserve>
	off = net_buf_simple_add(&sdu, sizeof(*off));
   152d8:	2106      	movs	r1, #6
   152da:	a805      	add	r0, sp, #20
   152dc:	f009 fffc 	bl	1f2d8 <net_buf_simple_add>
	off->recv_win = CONFIG_BT_MESH_FRIEND_RECV_WIN,
   152e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   152e4:	7003      	strb	r3, [r0, #0]
	off->queue_size = CONFIG_BT_MESH_FRIEND_QUEUE_SIZE,
   152e6:	2310      	movs	r3, #16
   152e8:	7043      	strb	r3, [r0, #1]
	off->sub_list_size = ARRAY_SIZE(frnd->sub_list),
   152ea:	2303      	movs	r3, #3
   152ec:	7083      	strb	r3, [r0, #2]
	off->rssi = rssi,
   152ee:	70c6      	strb	r6, [r0, #3]
	off->frnd_counter = sys_cpu_to_be16(frnd->counter);
   152f0:	89a2      	ldrh	r2, [r4, #12]
   152f2:	0213      	lsls	r3, r2, #8
   152f4:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
   152f8:	8083      	strh	r3, [r0, #4]
	buf = encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_OFFER, &sdu);
   152fa:	aa05      	add	r2, sp, #20
   152fc:	2104      	movs	r1, #4
   152fe:	4620      	mov	r0, r4
   15300:	f7fe ff5c 	bl	141bc <encode_friend_ctl.isra.0>
	if (!buf) {
   15304:	4606      	mov	r6, r0
   15306:	b9a8      	cbnz	r0, 15334 <bt_mesh_friend_req+0x28c>
		BT_ERR("Unable to encode Friend Offer");
   15308:	482b      	ldr	r0, [pc, #172]	; (153b8 <bt_mesh_friend_req+0x310>)
   1530a:	f045 0101 	orr.w	r1, r5, #1
   1530e:	f00e fe59 	bl	23fc4 <log_0>
		return;
   15312:	e722      	b.n	1515a <bt_mesh_friend_req+0xb2>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   15314:	2100      	movs	r1, #0
			frnd = &bt_mesh.frnd[i];
   15316:	227c      	movs	r2, #124	; 0x7c
   15318:	434a      	muls	r2, r1
   1531a:	f102 0420 	add.w	r4, r2, #32
   1531e:	441c      	add	r4, r3
			frnd->valid = 1U;
   15320:	4413      	add	r3, r2
   15322:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
   15326:	f042 0210 	orr.w	r2, r2, #16
   1532a:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	if (!frnd) {
   1532e:	e739      	b.n	151a4 <bt_mesh_friend_req+0xfc>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   15330:	2101      	movs	r1, #1
   15332:	e7f0      	b.n	15316 <bt_mesh_friend_req+0x26e>
	if (encrypt_friend_pdu(frnd, buf, true)) {
   15334:	4601      	mov	r1, r0
   15336:	2201      	movs	r2, #1
   15338:	4620      	mov	r0, r4
   1533a:	f7ff f82b 	bl	14394 <encrypt_friend_pdu>
   1533e:	4605      	mov	r5, r0
   15340:	2800      	cmp	r0, #0
   15342:	f47f af0a 	bne.w	1515a <bt_mesh_friend_req+0xb2>
	frnd->counter++;
   15346:	89a3      	ldrh	r3, [r4, #12]
	if (frnd->last) {
   15348:	6c60      	ldr	r0, [r4, #68]	; 0x44
	frnd->counter++;
   1534a:	3301      	adds	r3, #1
   1534c:	81a3      	strh	r3, [r4, #12]
	if (frnd->last) {
   1534e:	b108      	cbz	r0, 15354 <bt_mesh_friend_req+0x2ac>
		net_buf_unref(frnd->last);
   15350:	f009 feba 	bl	1f0c8 <net_buf_unref>
	frnd->send_last = 1U;
   15354:	78e3      	ldrb	r3, [r4, #3]
	frnd->last = buf;
   15356:	6466      	str	r6, [r4, #68]	; 0x44
	frnd->send_last = 1U;
   15358:	f043 0302 	orr.w	r3, r3, #2
   1535c:	70e3      	strb	r3, [r4, #3]
   1535e:	e6c1      	b.n	150e4 <bt_mesh_friend_req+0x3c>
   15360:	00029830 	.word	0x00029830
   15364:	00029938 	.word	0x00029938
   15368:	0002ef80 	.word	0x0002ef80
   1536c:	0002ef99 	.word	0x0002ef99
   15370:	0034bbf5 	.word	0x0034bbf5
   15374:	0002efba 	.word	0x0002efba
   15378:	0002efda 	.word	0x0002efda
   1537c:	0002effe 	.word	0x0002effe
   15380:	0002f02c 	.word	0x0002f02c
   15384:	0002f05c 	.word	0x0002f05c
   15388:	20006b48 	.word	0x20006b48
   1538c:	0002f08c 	.word	0x0002f08c
   15390:	0002f0b0 	.word	0x0002f0b0
   15394:	0002f429 	.word	0x0002f429
   15398:	0002f0d6 	.word	0x0002f0d6
   1539c:	0002f3e0 	.word	0x0002f3e0
   153a0:	0002e9a0 	.word	0x0002e9a0
   153a4:	0002f535 	.word	0x0002f535
   153a8:	0002f108 	.word	0x0002f108
   153ac:	0002f14a 	.word	0x0002f14a
   153b0:	0002f40f 	.word	0x0002f40f
   153b4:	0002aa84 	.word	0x0002aa84
   153b8:	0002f16e 	.word	0x0002f16e
   153bc:	0002f41d 	.word	0x0002f41d

000153c0 <bt_mesh_friend_init>:
{
   153c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		frnd->net_idx = BT_MESH_KEY_UNUSED;
   153c4:	4c14      	ldr	r4, [pc, #80]	; (15418 <bt_mesh_friend_init+0x58>)
		k_delayed_work_init(&frnd->timer, friend_timeout);
   153c6:	4f15      	ldr	r7, [pc, #84]	; (1541c <bt_mesh_friend_init+0x5c>)
		k_delayed_work_init(&frnd->clear.timer, clear_timeout);
   153c8:	4e15      	ldr	r6, [pc, #84]	; (15420 <bt_mesh_friend_init+0x60>)
	list->head = NULL;
   153ca:	2500      	movs	r5, #0
		frnd->net_idx = BT_MESH_KEY_UNUSED;
   153cc:	f64f 78ff 	movw	r8, #65535	; 0xffff
		k_delayed_work_init(&frnd->timer, friend_timeout);
   153d0:	4639      	mov	r1, r7
   153d2:	f104 0038 	add.w	r0, r4, #56	; 0x38
	list->tail = NULL;
   153d6:	e9c4 551a 	strd	r5, r5, [r4, #104]	; 0x68
		frnd->net_idx = BT_MESH_KEY_UNUSED;
   153da:	f8a4 802e 	strh.w	r8, [r4, #46]	; 0x2e
		k_delayed_work_init(&frnd->timer, friend_timeout);
   153de:	f014 f80c 	bl	293fa <k_delayed_work_init>
		k_delayed_work_init(&frnd->clear.timer, clear_timeout);
   153e2:	4631      	mov	r1, r6
   153e4:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   153e8:	f014 f807 	bl	293fa <k_delayed_work_init>
		k_delayed_work_init(&frnd->timer, friend_timeout);
   153ec:	4639      	mov	r1, r7
   153ee:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
   153f2:	e9c4 5516 	strd	r5, r5, [r4, #88]	; 0x58
   153f6:	e9c4 5539 	strd	r5, r5, [r4, #228]	; 0xe4
		frnd->net_idx = BT_MESH_KEY_UNUSED;
   153fa:	f8a4 80aa 	strh.w	r8, [r4, #170]	; 0xaa
		k_delayed_work_init(&frnd->timer, friend_timeout);
   153fe:	f013 fffc 	bl	293fa <k_delayed_work_init>
		k_delayed_work_init(&frnd->clear.timer, clear_timeout);
   15402:	f104 00f8 	add.w	r0, r4, #248	; 0xf8
   15406:	4631      	mov	r1, r6
   15408:	f013 fff7 	bl	293fa <k_delayed_work_init>
   1540c:	e9c4 5535 	strd	r5, r5, [r4, #212]	; 0xd4
}
   15410:	4628      	mov	r0, r5
   15412:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15416:	bf00      	nop
   15418:	20006b48 	.word	0x20006b48
   1541c:	000146d9 	.word	0x000146d9
   15420:	00014139 	.word	0x00014139

00015424 <bt_mesh_friend_match>:
{
   15424:	b537      	push	{r0, r1, r2, r4, r5, lr}
   15426:	460a      	mov	r2, r1
		if (friend_lpn_matches(frnd, net_idx, addr)) {
   15428:	4601      	mov	r1, r0
   1542a:	4815      	ldr	r0, [pc, #84]	; (15480 <bt_mesh_friend_match+0x5c>)
   1542c:	4c15      	ldr	r4, [pc, #84]	; (15484 <bt_mesh_friend_match+0x60>)
   1542e:	f012 fcbc 	bl	27daa <friend_lpn_matches>
   15432:	4b15      	ldr	r3, [pc, #84]	; (15488 <bt_mesh_friend_match+0x64>)
   15434:	1ae4      	subs	r4, r4, r3
   15436:	08e4      	lsrs	r4, r4, #3
   15438:	01a4      	lsls	r4, r4, #6
   1543a:	b968      	cbnz	r0, 15458 <bt_mesh_friend_match+0x34>
   1543c:	4813      	ldr	r0, [pc, #76]	; (1548c <bt_mesh_friend_match+0x68>)
   1543e:	f012 fcb4 	bl	27daa <friend_lpn_matches>
   15442:	4605      	mov	r5, r0
   15444:	b9c8      	cbnz	r0, 1547a <bt_mesh_friend_match+0x56>
	BT_DBG("No matching LPN for address 0x%04x", addr);
   15446:	4912      	ldr	r1, [pc, #72]	; (15490 <bt_mesh_friend_match+0x6c>)
   15448:	4812      	ldr	r0, [pc, #72]	; (15494 <bt_mesh_friend_match+0x70>)
   1544a:	f044 0304 	orr.w	r3, r4, #4
   1544e:	f00e fdda 	bl	24006 <log_2>
}
   15452:	4628      	mov	r0, r5
   15454:	b003      	add	sp, #12
   15456:	bd30      	pop	{r4, r5, pc}
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   15458:	2300      	movs	r3, #0
			BT_DBG("LPN 0x%04x matched address 0x%04x",
   1545a:	490f      	ldr	r1, [pc, #60]	; (15498 <bt_mesh_friend_match+0x74>)
   1545c:	207c      	movs	r0, #124	; 0x7c
   1545e:	fb00 1103 	mla	r1, r0, r3, r1
   15462:	f044 0404 	orr.w	r4, r4, #4
   15466:	f8ad 4000 	strh.w	r4, [sp]
   1546a:	4613      	mov	r3, r2
   1546c:	480b      	ldr	r0, [pc, #44]	; (1549c <bt_mesh_friend_match+0x78>)
   1546e:	8c0a      	ldrh	r2, [r1, #32]
   15470:	4907      	ldr	r1, [pc, #28]	; (15490 <bt_mesh_friend_match+0x6c>)
   15472:	f00e fde1 	bl	24038 <log_3>
			return true;
   15476:	2501      	movs	r5, #1
   15478:	e7eb      	b.n	15452 <bt_mesh_friend_match+0x2e>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   1547a:	2301      	movs	r3, #1
   1547c:	e7ed      	b.n	1545a <bt_mesh_friend_match+0x36>
   1547e:	bf00      	nop
   15480:	20006b68 	.word	0x20006b68
   15484:	00029938 	.word	0x00029938
   15488:	00029830 	.word	0x00029830
   1548c:	20006be4 	.word	0x20006be4
   15490:	0002f4cc 	.word	0x0002f4cc
   15494:	0002f18c 	.word	0x0002f18c
   15498:	20006b48 	.word	0x20006b48
   1549c:	0002f1b3 	.word	0x0002f1b3

000154a0 <bt_mesh_friend_queue_has_space>:
{
   154a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   154a4:	4681      	mov	r9, r0
   154a6:	460e      	mov	r6, r1
		if (!friend_lpn_matches(frnd, net_idx, dst)) {
   154a8:	4601      	mov	r1, r0
   154aa:	4817      	ldr	r0, [pc, #92]	; (15508 <bt_mesh_friend_queue_has_space+0x68>)
{
   154ac:	f89d 8020 	ldrb.w	r8, [sp, #32]
   154b0:	4692      	mov	sl, r2
   154b2:	461f      	mov	r7, r3
		if (!friend_lpn_matches(frnd, net_idx, dst)) {
   154b4:	f012 fc79 	bl	27daa <friend_lpn_matches>
   154b8:	4605      	mov	r5, r0
   154ba:	b1f0      	cbz	r0, 154fa <bt_mesh_friend_queue_has_space+0x5a>
	if (seg_count > CONFIG_BT_MESH_FRIEND_QUEUE_SIZE) {
   154bc:	f1b8 0f10 	cmp.w	r8, #16
   154c0:	d81b      	bhi.n	154fa <bt_mesh_friend_queue_has_space+0x5a>
   154c2:	4811      	ldr	r0, [pc, #68]	; (15508 <bt_mesh_friend_queue_has_space+0x68>)
   154c4:	4643      	mov	r3, r8
   154c6:	463a      	mov	r2, r7
   154c8:	4631      	mov	r1, r6
   154ca:	f012 fcd9 	bl	27e80 <friend_queue_has_space.part.0>
   154ce:	4604      	mov	r4, r0
		if (!friend_lpn_matches(frnd, net_idx, dst)) {
   154d0:	480e      	ldr	r0, [pc, #56]	; (1550c <bt_mesh_friend_queue_has_space+0x6c>)
   154d2:	4652      	mov	r2, sl
   154d4:	4649      	mov	r1, r9
   154d6:	f012 fc68 	bl	27daa <friend_lpn_matches>
   154da:	b180      	cbz	r0, 154fe <bt_mesh_friend_queue_has_space+0x5e>
	if (seg_count > CONFIG_BT_MESH_FRIEND_QUEUE_SIZE) {
   154dc:	f1b8 0f10 	cmp.w	r8, #16
   154e0:	d808      	bhi.n	154f4 <bt_mesh_friend_queue_has_space+0x54>
   154e2:	480a      	ldr	r0, [pc, #40]	; (1550c <bt_mesh_friend_queue_has_space+0x6c>)
   154e4:	4643      	mov	r3, r8
   154e6:	463a      	mov	r2, r7
   154e8:	4631      	mov	r1, r6
   154ea:	f012 fcc9 	bl	27e80 <friend_queue_has_space.part.0>
			someone_has_space = true;
   154ee:	2800      	cmp	r0, #0
   154f0:	bf18      	it	ne
   154f2:	4604      	movne	r4, r0
}
   154f4:	4620      	mov	r0, r4
   154f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	bool someone_has_space = false, friend_match = false;
   154fa:	2400      	movs	r4, #0
   154fc:	e7e8      	b.n	154d0 <bt_mesh_friend_queue_has_space+0x30>
	if (!friend_match) {
   154fe:	2d00      	cmp	r5, #0
		return true;
   15500:	bf08      	it	eq
   15502:	2401      	moveq	r4, #1
   15504:	e7f6      	b.n	154f4 <bt_mesh_friend_queue_has_space+0x54>
   15506:	bf00      	nop
   15508:	20006b68 	.word	0x20006b68
   1550c:	20006be4 	.word	0x20006be4

00015510 <bt_mesh_friend_enqueue_rx>:

void bt_mesh_friend_enqueue_rx(struct bt_mesh_net_rx *rx,
			       enum bt_mesh_friend_pdu_type type,
			       const u64_t *seq_auth, u8_t seg_count,
			       struct net_buf_simple *sbuf)
{
   15510:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15514:	4617      	mov	r7, r2
	int i;

	if (!rx->friend_match ||
   15516:	f990 2014 	ldrsb.w	r2, [r0, #20]
   1551a:	2a00      	cmp	r2, #0
{
   1551c:	4699      	mov	r9, r3
   1551e:	b08b      	sub	sp, #44	; 0x2c
	if (!rx->friend_match ||
   15520:	7d03      	ldrb	r3, [r0, #20]
{
   15522:	4604      	mov	r4, r0
   15524:	4688      	mov	r8, r1
	if (!rx->friend_match ||
   15526:	da7f      	bge.n	15628 <bt_mesh_friend_enqueue_rx+0x118>
   15528:	7b42      	ldrb	r2, [r0, #13]
   1552a:	2a01      	cmp	r2, #1
   1552c:	d803      	bhi.n	15536 <bt_mesh_friend_enqueue_rx+0x26>
	    (rx->ctx.recv_ttl <= 1U && rx->net_if != BT_MESH_NET_IF_LOCAL) ||
   1552e:	f003 0330 	and.w	r3, r3, #48	; 0x30
   15532:	2b10      	cmp	r3, #16
   15534:	d178      	bne.n	15628 <bt_mesh_friend_enqueue_rx+0x118>
	    bt_mesh_friend_get() != BT_MESH_FRIEND_ENABLED) {
   15536:	f7fc feeb 	bl	12310 <bt_mesh_friend_get>
	    (rx->ctx.recv_ttl <= 1U && rx->net_if != BT_MESH_NET_IF_LOCAL) ||
   1553a:	2801      	cmp	r0, #1
   1553c:	d174      	bne.n	15628 <bt_mesh_friend_enqueue_rx+0x118>
   1553e:	4b47      	ldr	r3, [pc, #284]	; (1565c <bt_mesh_friend_enqueue_rx+0x14c>)
   15540:	4e47      	ldr	r6, [pc, #284]	; (15660 <bt_mesh_friend_enqueue_rx+0x150>)
		return;
	}

	BT_DBG("recv_ttl %u net_idx 0x%04x src 0x%04x dst 0x%04x",
   15542:	4848      	ldr	r0, [pc, #288]	; (15664 <bt_mesh_friend_enqueue_rx+0x154>)
   15544:	4d48      	ldr	r5, [pc, #288]	; (15668 <bt_mesh_friend_enqueue_rx+0x158>)
	BT_DBG("LPN 0x%04x queue_size %u", frnd->lpn, frnd->queue_size);
   15546:	f8df a134 	ldr.w	sl, [pc, #308]	; 1567c <bt_mesh_friend_enqueue_rx+0x16c>
   1554a:	1af6      	subs	r6, r6, r3
	BT_DBG("recv_ttl %u net_idx 0x%04x src 0x%04x dst 0x%04x",
   1554c:	4b47      	ldr	r3, [pc, #284]	; (1566c <bt_mesh_friend_enqueue_rx+0x15c>)
   1554e:	9305      	str	r3, [sp, #20]
   15550:	7b63      	ldrb	r3, [r4, #13]
   15552:	9306      	str	r3, [sp, #24]
   15554:	6823      	ldr	r3, [r4, #0]
   15556:	8b9b      	ldrh	r3, [r3, #28]
   15558:	9307      	str	r3, [sp, #28]
   1555a:	08f6      	lsrs	r6, r6, #3
   1555c:	8923      	ldrh	r3, [r4, #8]
   1555e:	9308      	str	r3, [sp, #32]
   15560:	01b6      	lsls	r6, r6, #6
   15562:	8963      	ldrh	r3, [r4, #10]
   15564:	9309      	str	r3, [sp, #36]	; 0x24
   15566:	2205      	movs	r2, #5
   15568:	f046 0304 	orr.w	r3, r6, #4
   1556c:	a905      	add	r1, sp, #20
   1556e:	f00e fd7f 	bl	24070 <log_n>
	       rx->ctx.recv_ttl, rx->sub->net_idx, rx->ctx.addr,
	       rx->ctx.recv_dst);

	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   15572:	2300      	movs	r3, #0
   15574:	9303      	str	r3, [sp, #12]
	info.iv_index = BT_MESH_NET_IVI_RX(rx);
   15576:	f1a5 0b20 	sub.w	fp, r5, #32
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];

		if (!friend_lpn_matches(frnd, rx->sub->net_idx,
   1557a:	6823      	ldr	r3, [r4, #0]
   1557c:	8962      	ldrh	r2, [r4, #10]
   1557e:	8b99      	ldrh	r1, [r3, #28]
   15580:	4628      	mov	r0, r5
   15582:	f012 fc12 	bl	27daa <friend_lpn_matches>
   15586:	2800      	cmp	r0, #0
   15588:	d04b      	beq.n	15622 <bt_mesh_friend_enqueue_rx+0x112>
					rx->ctx.recv_dst)) {
			continue;
		}

		if (!friend_queue_prepare_space(frnd, rx->ctx.addr, seq_auth,
   1558a:	8921      	ldrh	r1, [r4, #8]
   1558c:	464b      	mov	r3, r9
   1558e:	463a      	mov	r2, r7
   15590:	4628      	mov	r0, r5
   15592:	f7fe fe51 	bl	14238 <friend_queue_prepare_space>
   15596:	2800      	cmp	r0, #0
   15598:	d043      	beq.n	15622 <bt_mesh_friend_enqueue_rx+0x112>
	if (bt_mesh_elem_find(rx->ctx.addr)) {
   1559a:	8920      	ldrh	r0, [r4, #8]
   1559c:	f7fa fa8c 	bl	fab8 <bt_mesh_elem_find>
   155a0:	2800      	cmp	r0, #0
   155a2:	d13e      	bne.n	15622 <bt_mesh_friend_enqueue_rx+0x112>
	BT_DBG("LPN 0x%04x queue_size %u", frnd->lpn, frnd->queue_size);
   155a4:	f046 0304 	orr.w	r3, r6, #4
   155a8:	f8ad 3000 	strh.w	r3, [sp]
   155ac:	882a      	ldrh	r2, [r5, #0]
   155ae:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   155b0:	482f      	ldr	r0, [pc, #188]	; (15670 <bt_mesh_friend_enqueue_rx+0x160>)
   155b2:	4651      	mov	r1, sl
   155b4:	f00e fd40 	bl	24038 <log_3>
	if (type == BT_MESH_FRIEND_PDU_SINGLE && seq_auth) {
   155b8:	f1b8 0f00 	cmp.w	r8, #0
   155bc:	d105      	bne.n	155ca <bt_mesh_friend_enqueue_rx+0xba>
   155be:	b127      	cbz	r7, 155ca <bt_mesh_friend_enqueue_rx+0xba>
		friend_purge_old_ack(frnd, seq_auth, rx->ctx.addr);
   155c0:	8922      	ldrh	r2, [r4, #8]
   155c2:	4639      	mov	r1, r7
   155c4:	4628      	mov	r0, r5
   155c6:	f7ff f9cf 	bl	14968 <friend_purge_old_ack>
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
   155ca:	7d22      	ldrb	r2, [r4, #20]
	info.src = rx->ctx.addr;
   155cc:	68a3      	ldr	r3, [r4, #8]
   155ce:	9305      	str	r3, [sp, #20]
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
   155d0:	f002 0130 	and.w	r1, r2, #48	; 0x30
   155d4:	7b63      	ldrb	r3, [r4, #13]
   155d6:	2910      	cmp	r1, #16
		info.ttl = rx->ctx.recv_ttl - 1U;
   155d8:	bf18      	it	ne
   155da:	f103 33ff 	addne.w	r3, r3, #4294967295	; 0xffffffff
	info.ctl = rx->ctl;
   155de:	f3c2 01c0 	ubfx	r1, r2, #3, #1
		info.ttl = rx->ctx.recv_ttl - 1U;
   155e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	info.ctl = rx->ctl;
   155e6:	ea43 13c1 	orr.w	r3, r3, r1, lsl #7
   155ea:	f88d 301b 	strb.w	r3, [sp, #27]
	sys_put_be24(rx->seq, info.seq);
   155ee:	6923      	ldr	r3, [r4, #16]
	dst[1] = val;
   155f0:	f88d 301a 	strb.w	r3, [sp, #26]
	dst[0] = val >> 16;
   155f4:	0c19      	lsrs	r1, r3, #16
   155f6:	f88d 1018 	strb.w	r1, [sp, #24]
	dst[0] = val >> 8;
   155fa:	f3c3 2107 	ubfx	r1, r3, #8, #8
	info.iv_index = BT_MESH_NET_IVI_RX(rx);
   155fe:	f8db 3000 	ldr.w	r3, [fp]
   15602:	f88d 1019 	strb.w	r1, [sp, #25]
   15606:	f002 0201 	and.w	r2, r2, #1
   1560a:	1a9a      	subs	r2, r3, r2
	buf = create_friend_pdu(frnd, &info, sbuf);
   1560c:	9914      	ldr	r1, [sp, #80]	; 0x50
	info.iv_index = BT_MESH_NET_IVI_RX(rx);
   1560e:	9207      	str	r2, [sp, #28]
	buf = create_friend_pdu(frnd, &info, sbuf);
   15610:	a805      	add	r0, sp, #20
   15612:	f7fe fd11 	bl	14038 <create_friend_pdu.isra.0>
	if (!buf) {
   15616:	b968      	cbnz	r0, 15634 <bt_mesh_friend_enqueue_rx+0x124>
		BT_ERR("Failed to encode Friend buffer");
   15618:	4816      	ldr	r0, [pc, #88]	; (15674 <bt_mesh_friend_enqueue_rx+0x164>)
   1561a:	f046 0101 	orr.w	r1, r6, #1
   1561e:	f00e fcd1 	bl	23fc4 <log_0>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   15622:	9b03      	ldr	r3, [sp, #12]
   15624:	357c      	adds	r5, #124	; 0x7c
   15626:	b113      	cbz	r3, 1562e <bt_mesh_friend_enqueue_rx+0x11e>
		}

		friend_lpn_enqueue_rx(frnd, rx, type, seq_auth, seg_count,
				      sbuf);
	}
}
   15628:	b00b      	add	sp, #44	; 0x2c
   1562a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1562e:	2301      	movs	r3, #1
   15630:	9303      	str	r3, [sp, #12]
   15632:	e7a2      	b.n	1557a <bt_mesh_friend_enqueue_rx+0x6a>
	enqueue_friend_pdu(frnd, type, info.src, seg_count, buf);
   15634:	f8bd 2014 	ldrh.w	r2, [sp, #20]
   15638:	9000      	str	r0, [sp, #0]
   1563a:	464b      	mov	r3, r9
   1563c:	4641      	mov	r1, r8
   1563e:	4628      	mov	r0, r5
   15640:	f7fe fe40 	bl	142c4 <enqueue_friend_pdu>
	BT_DBG("Queued message for LPN 0x%04x, queue_size %u",
   15644:	f046 0304 	orr.w	r3, r6, #4
   15648:	f8ad 3000 	strh.w	r3, [sp]
   1564c:	882a      	ldrh	r2, [r5, #0]
   1564e:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   15650:	4809      	ldr	r0, [pc, #36]	; (15678 <bt_mesh_friend_enqueue_rx+0x168>)
   15652:	4651      	mov	r1, sl
   15654:	f00e fcf0 	bl	24038 <log_3>
   15658:	e7e3      	b.n	15622 <bt_mesh_friend_enqueue_rx+0x112>
   1565a:	bf00      	nop
   1565c:	00029830 	.word	0x00029830
   15660:	00029938 	.word	0x00029938
   15664:	0002f1d9 	.word	0x0002f1d9
   15668:	20006b68 	.word	0x20006b68
   1566c:	0002f4e1 	.word	0x0002f4e1
   15670:	0002f20e 	.word	0x0002f20e
   15674:	0002f22b 	.word	0x0002f22b
   15678:	0002f24a 	.word	0x0002f24a
   1567c:	0002f4a0 	.word	0x0002f4a0

00015680 <bt_mesh_friend_enqueue_tx>:

bool bt_mesh_friend_enqueue_tx(struct bt_mesh_net_tx *tx,
			       enum bt_mesh_friend_pdu_type type,
			       const u64_t *seq_auth, u8_t seg_count,
			       struct net_buf_simple *sbuf)
{
   15680:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15684:	4690      	mov	r8, r2
   15686:	4699      	mov	r9, r3
	bool matched = false;
	int i;

	if (!bt_mesh_friend_match(tx->sub->net_idx, tx->ctx->addr) ||
   15688:	e9d0 3200 	ldrd	r3, r2, [r0]
{
   1568c:	b089      	sub	sp, #36	; 0x24
   1568e:	4604      	mov	r4, r0
   15690:	460f      	mov	r7, r1
	if (!bt_mesh_friend_match(tx->sub->net_idx, tx->ctx->addr) ||
   15692:	8b98      	ldrh	r0, [r3, #28]
   15694:	8891      	ldrh	r1, [r2, #4]
   15696:	f7ff fec5 	bl	15424 <bt_mesh_friend_match>
   1569a:	b928      	cbnz	r0, 156a8 <bt_mesh_friend_enqueue_tx+0x28>
	    bt_mesh_friend_get() != BT_MESH_FRIEND_ENABLED) {
		return matched;
   1569c:	f04f 0a00 	mov.w	sl, #0
				      sbuf);
		matched = true;
	}

	return matched;
}
   156a0:	4650      	mov	r0, sl
   156a2:	b009      	add	sp, #36	; 0x24
   156a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    bt_mesh_friend_get() != BT_MESH_FRIEND_ENABLED) {
   156a8:	f7fc fe32 	bl	12310 <bt_mesh_friend_get>
	if (!bt_mesh_friend_match(tx->sub->net_idx, tx->ctx->addr) ||
   156ac:	2801      	cmp	r0, #1
   156ae:	d1f5      	bne.n	1569c <bt_mesh_friend_enqueue_tx+0x1c>
   156b0:	4b47      	ldr	r3, [pc, #284]	; (157d0 <bt_mesh_friend_enqueue_tx+0x150>)
   156b2:	4d48      	ldr	r5, [pc, #288]	; (157d4 <bt_mesh_friend_enqueue_tx+0x154>)
	BT_DBG("net_idx 0x%04x dst 0x%04x src 0x%04x", tx->sub->net_idx,
   156b4:	4848      	ldr	r0, [pc, #288]	; (157d8 <bt_mesh_friend_enqueue_tx+0x158>)
   156b6:	4e49      	ldr	r6, [pc, #292]	; (157dc <bt_mesh_friend_enqueue_tx+0x15c>)
   156b8:	1aed      	subs	r5, r5, r3
   156ba:	4b49      	ldr	r3, [pc, #292]	; (157e0 <bt_mesh_friend_enqueue_tx+0x160>)
   156bc:	9304      	str	r3, [sp, #16]
   156be:	6823      	ldr	r3, [r4, #0]
   156c0:	8b9b      	ldrh	r3, [r3, #28]
   156c2:	9305      	str	r3, [sp, #20]
   156c4:	6863      	ldr	r3, [r4, #4]
   156c6:	08ed      	lsrs	r5, r5, #3
   156c8:	889b      	ldrh	r3, [r3, #4]
   156ca:	9306      	str	r3, [sp, #24]
   156cc:	01ad      	lsls	r5, r5, #6
   156ce:	8923      	ldrh	r3, [r4, #8]
   156d0:	9307      	str	r3, [sp, #28]
   156d2:	2204      	movs	r2, #4
   156d4:	f045 0304 	orr.w	r3, r5, #4
   156d8:	a904      	add	r1, sp, #16
   156da:	f00e fcc9 	bl	24070 <log_n>
	bool matched = false;
   156de:	f04f 0a00 	mov.w	sl, #0
		if (!friend_lpn_matches(frnd, tx->sub->net_idx,
   156e2:	e9d4 3200 	ldrd	r3, r2, [r4]
   156e6:	f106 0b20 	add.w	fp, r6, #32
   156ea:	8892      	ldrh	r2, [r2, #4]
   156ec:	8b99      	ldrh	r1, [r3, #28]
   156ee:	4658      	mov	r0, fp
   156f0:	f012 fb5b 	bl	27daa <friend_lpn_matches>
   156f4:	2800      	cmp	r0, #0
   156f6:	d04d      	beq.n	15794 <bt_mesh_friend_enqueue_tx+0x114>
		if (!friend_queue_prepare_space(frnd, tx->src, seq_auth,
   156f8:	8921      	ldrh	r1, [r4, #8]
   156fa:	464b      	mov	r3, r9
   156fc:	4642      	mov	r2, r8
   156fe:	4658      	mov	r0, fp
   15700:	f7fe fd9a 	bl	14238 <friend_queue_prepare_space>
   15704:	9003      	str	r0, [sp, #12]
   15706:	2800      	cmp	r0, #0
   15708:	d044      	beq.n	15794 <bt_mesh_friend_enqueue_tx+0x114>
	BT_DBG("LPN 0x%04x", frnd->lpn);
   1570a:	8c32      	ldrh	r2, [r6, #32]
   1570c:	4935      	ldr	r1, [pc, #212]	; (157e4 <bt_mesh_friend_enqueue_tx+0x164>)
   1570e:	4836      	ldr	r0, [pc, #216]	; (157e8 <bt_mesh_friend_enqueue_tx+0x168>)
   15710:	f045 0304 	orr.w	r3, r5, #4
   15714:	f00e fc77 	bl	24006 <log_2>
	if (type == BT_MESH_FRIEND_PDU_SINGLE && seq_auth) {
   15718:	b93f      	cbnz	r7, 1572a <bt_mesh_friend_enqueue_tx+0xaa>
   1571a:	f1b8 0f00 	cmp.w	r8, #0
   1571e:	d004      	beq.n	1572a <bt_mesh_friend_enqueue_tx+0xaa>
		friend_purge_old_ack(frnd, seq_auth, tx->src);
   15720:	8922      	ldrh	r2, [r4, #8]
   15722:	4641      	mov	r1, r8
   15724:	4658      	mov	r0, fp
   15726:	f7ff f91f 	bl	14968 <friend_purge_old_ack>
	info.dst = tx->ctx->addr;
   1572a:	6861      	ldr	r1, [r4, #4]
	info.src = tx->src;
   1572c:	8923      	ldrh	r3, [r4, #8]
   1572e:	f8ad 3010 	strh.w	r3, [sp, #16]
	info.dst = tx->ctx->addr;
   15732:	888b      	ldrh	r3, [r1, #4]
   15734:	f8ad 3012 	strh.w	r3, [sp, #18]
	info.ctl = (tx->ctx->app_idx == BT_MESH_KEY_UNUSED);
   15738:	884b      	ldrh	r3, [r1, #2]
   1573a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1573e:	1a9b      	subs	r3, r3, r2
   15740:	425a      	negs	r2, r3
   15742:	415a      	adcs	r2, r3
	info.ttl = tx->ctx->send_ttl;
   15744:	7acb      	ldrb	r3, [r1, #11]
	sys_put_be24(bt_mesh.seq, info.seq);
   15746:	4925      	ldr	r1, [pc, #148]	; (157dc <bt_mesh_friend_enqueue_tx+0x15c>)
	info.ttl = tx->ctx->send_ttl;
   15748:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1574c:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   15750:	f88d 3017 	strb.w	r3, [sp, #23]
	sys_put_be24(bt_mesh.seq, info.seq);
   15754:	684b      	ldr	r3, [r1, #4]
	dst[1] = val;
   15756:	f88d 3016 	strb.w	r3, [sp, #22]
	dst[0] = val >> 16;
   1575a:	0c1a      	lsrs	r2, r3, #16
   1575c:	f88d 2014 	strb.w	r2, [sp, #20]
	dst[0] = val >> 8;
   15760:	f3c3 2207 	ubfx	r2, r3, #8, #8
   15764:	f88d 2015 	strb.w	r2, [sp, #21]
	info.iv_index = BT_MESH_NET_IVI_TX;
   15768:	680b      	ldr	r3, [r1, #0]
   1576a:	f3bf 8f5b 	dmb	ish
   1576e:	688a      	ldr	r2, [r1, #8]
   15770:	f3bf 8f5b 	dmb	ish
   15774:	f3c2 0280 	ubfx	r2, r2, #2, #1
   15778:	1a9b      	subs	r3, r3, r2
	buf = create_friend_pdu(frnd, &info, sbuf);
   1577a:	9912      	ldr	r1, [sp, #72]	; 0x48
	info.iv_index = BT_MESH_NET_IVI_TX;
   1577c:	9306      	str	r3, [sp, #24]
	buf = create_friend_pdu(frnd, &info, sbuf);
   1577e:	a804      	add	r0, sp, #16
   15780:	f7fe fc5a 	bl	14038 <create_friend_pdu.isra.0>
	if (!buf) {
   15784:	b958      	cbnz	r0, 1579e <bt_mesh_friend_enqueue_tx+0x11e>
		BT_ERR("Failed to encode Friend buffer");
   15786:	4819      	ldr	r0, [pc, #100]	; (157ec <bt_mesh_friend_enqueue_tx+0x16c>)
   15788:	f045 0101 	orr.w	r1, r5, #1
   1578c:	f00e fc1a 	bl	23fc4 <log_0>
		matched = true;
   15790:	f8dd a00c 	ldr.w	sl, [sp, #12]
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   15794:	4b16      	ldr	r3, [pc, #88]	; (157f0 <bt_mesh_friend_enqueue_tx+0x170>)
   15796:	367c      	adds	r6, #124	; 0x7c
   15798:	42b3      	cmp	r3, r6
   1579a:	d1a2      	bne.n	156e2 <bt_mesh_friend_enqueue_tx+0x62>
   1579c:	e780      	b.n	156a0 <bt_mesh_friend_enqueue_tx+0x20>
	if (type == BT_MESH_FRIEND_PDU_SINGLE && !info.ctl) {
   1579e:	b93f      	cbnz	r7, 157b0 <bt_mesh_friend_enqueue_tx+0x130>
   157a0:	f99d 3017 	ldrsb.w	r3, [sp, #23]
   157a4:	2b00      	cmp	r3, #0
		FRIEND_ADV(buf)->app_idx = tx->ctx->app_idx;
   157a6:	bfa1      	itttt	ge
   157a8:	6862      	ldrge	r2, [r4, #4]
   157aa:	6943      	ldrge	r3, [r0, #20]
   157ac:	8852      	ldrhge	r2, [r2, #2]
   157ae:	819a      	strhge	r2, [r3, #12]
	enqueue_friend_pdu(frnd, type, info.src, seg_count, buf);
   157b0:	f8bd 2010 	ldrh.w	r2, [sp, #16]
   157b4:	9000      	str	r0, [sp, #0]
   157b6:	464b      	mov	r3, r9
   157b8:	4639      	mov	r1, r7
   157ba:	4658      	mov	r0, fp
   157bc:	f7fe fd82 	bl	142c4 <enqueue_friend_pdu>
	BT_DBG("Queued message for LPN 0x%04x", frnd->lpn);
   157c0:	8c32      	ldrh	r2, [r6, #32]
   157c2:	4908      	ldr	r1, [pc, #32]	; (157e4 <bt_mesh_friend_enqueue_tx+0x164>)
   157c4:	480b      	ldr	r0, [pc, #44]	; (157f4 <bt_mesh_friend_enqueue_tx+0x174>)
   157c6:	f045 0304 	orr.w	r3, r5, #4
   157ca:	f00e fc1c 	bl	24006 <log_2>
   157ce:	e7df      	b.n	15790 <bt_mesh_friend_enqueue_tx+0x110>
   157d0:	00029830 	.word	0x00029830
   157d4:	00029938 	.word	0x00029938
   157d8:	0002f27b 	.word	0x0002f27b
   157dc:	20006b48 	.word	0x20006b48
   157e0:	0002f4fb 	.word	0x0002f4fb
   157e4:	0002f4b6 	.word	0x0002f4b6
   157e8:	0002e991 	.word	0x0002e991
   157ec:	0002f22b 	.word	0x0002f22b
   157f0:	20006c40 	.word	0x20006c40
   157f4:	0002f2a4 	.word	0x0002f2a4

000157f8 <bt_mesh_friend_clear_incomplete>:

void bt_mesh_friend_clear_incomplete(struct bt_mesh_subnet *sub, u16_t src,
				     u16_t dst, u64_t *seq_auth)
{
   157f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   157fc:	4c23      	ldr	r4, [pc, #140]	; (1588c <bt_mesh_friend_clear_incomplete+0x94>)
   157fe:	461e      	mov	r6, r3
   15800:	4b23      	ldr	r3, [pc, #140]	; (15890 <bt_mesh_friend_clear_incomplete+0x98>)
   15802:	1ae4      	subs	r4, r4, r3
   15804:	08e4      	lsrs	r4, r4, #3
   15806:	4607      	mov	r7, r0
	int i;

	BT_DBG("");
   15808:	01a4      	lsls	r4, r4, #6
   1580a:	4822      	ldr	r0, [pc, #136]	; (15894 <bt_mesh_friend_clear_incomplete+0x9c>)
{
   1580c:	4690      	mov	r8, r2
   1580e:	460d      	mov	r5, r1
	BT_DBG("");
   15810:	f044 0204 	orr.w	r2, r4, #4
   15814:	4920      	ldr	r1, [pc, #128]	; (15898 <bt_mesh_friend_clear_incomplete+0xa0>)
   15816:	f00e fbe2 	bl	23fde <log_1>

	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];
		int j;

		if (!friend_lpn_matches(frnd, sub->net_idx, dst)) {
   1581a:	8bb9      	ldrh	r1, [r7, #28]
   1581c:	481f      	ldr	r0, [pc, #124]	; (1589c <bt_mesh_friend_clear_incomplete+0xa4>)
   1581e:	4642      	mov	r2, r8
   15820:	f012 fac3 	bl	27daa <friend_lpn_matches>
   15824:	b1a0      	cbz	r0, 15850 <bt_mesh_friend_clear_incomplete+0x58>
		}

		for (j = 0; j < ARRAY_SIZE(frnd->seg); j++) {
			struct bt_mesh_friend_seg *seg = &frnd->seg[j];

			if (!is_seg(seg, src, *seq_auth & TRANS_SEQ_ZERO_MASK)) {
   15826:	8832      	ldrh	r2, [r6, #0]
   15828:	481d      	ldr	r0, [pc, #116]	; (158a0 <bt_mesh_friend_clear_incomplete+0xa8>)
   1582a:	f3c2 020c 	ubfx	r2, r2, #0, #13
   1582e:	4629      	mov	r1, r5
   15830:	f012 faf6 	bl	27e20 <is_seg>
   15834:	b160      	cbz	r0, 15850 <bt_mesh_friend_clear_incomplete+0x58>
				continue;
			}

			BT_WARN("Clearing incomplete segments for 0x%04x", src);
   15836:	f044 0202 	orr.w	r2, r4, #2
   1583a:	481a      	ldr	r0, [pc, #104]	; (158a4 <bt_mesh_friend_clear_incomplete+0xac>)
   1583c:	4629      	mov	r1, r5
   1583e:	f00e fbce 	bl	23fde <log_1>

			purge_buffers(&seg->queue);
   15842:	4817      	ldr	r0, [pc, #92]	; (158a0 <bt_mesh_friend_clear_incomplete+0xa8>)
   15844:	f012 fad8 	bl	27df8 <purge_buffers>
			seg->seg_count = 0U;
   15848:	4b17      	ldr	r3, [pc, #92]	; (158a8 <bt_mesh_friend_clear_incomplete+0xb0>)
   1584a:	2200      	movs	r2, #0
   1584c:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
		if (!friend_lpn_matches(frnd, sub->net_idx, dst)) {
   15850:	8bb9      	ldrh	r1, [r7, #28]
   15852:	4816      	ldr	r0, [pc, #88]	; (158ac <bt_mesh_friend_clear_incomplete+0xb4>)
   15854:	4642      	mov	r2, r8
   15856:	f012 faa8 	bl	27daa <friend_lpn_matches>
   1585a:	b1a0      	cbz	r0, 15886 <bt_mesh_friend_clear_incomplete+0x8e>
			if (!is_seg(seg, src, *seq_auth & TRANS_SEQ_ZERO_MASK)) {
   1585c:	8832      	ldrh	r2, [r6, #0]
   1585e:	4814      	ldr	r0, [pc, #80]	; (158b0 <bt_mesh_friend_clear_incomplete+0xb8>)
   15860:	f3c2 020c 	ubfx	r2, r2, #0, #13
   15864:	4629      	mov	r1, r5
   15866:	f012 fadb 	bl	27e20 <is_seg>
   1586a:	b160      	cbz	r0, 15886 <bt_mesh_friend_clear_incomplete+0x8e>
			BT_WARN("Clearing incomplete segments for 0x%04x", src);
   1586c:	f044 0202 	orr.w	r2, r4, #2
   15870:	480c      	ldr	r0, [pc, #48]	; (158a4 <bt_mesh_friend_clear_incomplete+0xac>)
   15872:	4629      	mov	r1, r5
   15874:	f00e fbb3 	bl	23fde <log_1>
			purge_buffers(&seg->queue);
   15878:	480d      	ldr	r0, [pc, #52]	; (158b0 <bt_mesh_friend_clear_incomplete+0xb8>)
   1587a:	f012 fabd 	bl	27df8 <purge_buffers>
			seg->seg_count = 0U;
   1587e:	4b0a      	ldr	r3, [pc, #40]	; (158a8 <bt_mesh_friend_clear_incomplete+0xb0>)
   15880:	2200      	movs	r2, #0
   15882:	f883 20dc 	strb.w	r2, [r3, #220]	; 0xdc
			break;
		}
	}
}
   15886:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1588a:	bf00      	nop
   1588c:	00029938 	.word	0x00029938
   15890:	00029830 	.word	0x00029830
   15894:	0002aa84 	.word	0x0002aa84
   15898:	0002f515 	.word	0x0002f515
   1589c:	20006b68 	.word	0x20006b68
   158a0:	20006ba0 	.word	0x20006ba0
   158a4:	0002f2c6 	.word	0x0002f2c6
   158a8:	20006b48 	.word	0x20006b48
   158ac:	20006be4 	.word	0x20006be4
   158b0:	20006c1c 	.word	0x20006c1c

000158b4 <reset_state>:
static void send_pub_key(void);
static void pub_key_ready(const u8_t *pkey);
static void start_sent(int err, void *cb_data);

static int reset_state(void)
{
   158b4:	b510      	push	{r4, lr}
		.func = pub_key_ready,
	};
	int err;

	/* Disable Attention Timer if it was set */
	if (link.conf_inputs[0]) {
   158b6:	4b10      	ldr	r3, [pc, #64]	; (158f8 <reset_state+0x44>)
   158b8:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
   158bc:	b11b      	cbz	r3, 158c6 <reset_state+0x12>
		bt_mesh_attention(NULL, 0);
   158be:	2100      	movs	r1, #0
   158c0:	4608      	mov	r0, r1
   158c2:	f7fd f881 	bl	129c8 <bt_mesh_attention>
	if (IS_ENABLED(CONFIG_BT_MESH_PROVISIONER) &&
	    link.provisioner->node != NULL) {
		bt_mesh_cdb_node_del(link.provisioner->node, false);
	}

	memset(&link, 0, sizeof(link));
   158c6:	f44f 7290 	mov.w	r2, #288	; 0x120
   158ca:	2100      	movs	r1, #0
   158cc:	480a      	ldr	r0, [pc, #40]	; (158f8 <reset_state+0x44>)
   158ce:	f010 fa16 	bl	25cfe <memset>

	err = bt_pub_key_gen(&pub_key_cb);
   158d2:	480a      	ldr	r0, [pc, #40]	; (158fc <reset_state+0x48>)
   158d4:	f7f3 f8c0 	bl	8a58 <bt_pub_key_gen>
	if (err) {
   158d8:	4604      	mov	r4, r0
   158da:	b150      	cbz	r0, 158f2 <reset_state+0x3e>
   158dc:	4a08      	ldr	r2, [pc, #32]	; (15900 <reset_state+0x4c>)
   158de:	4b09      	ldr	r3, [pc, #36]	; (15904 <reset_state+0x50>)
   158e0:	1ad2      	subs	r2, r2, r3
   158e2:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Failed to generate public key (%d)", err);
   158e4:	0192      	lsls	r2, r2, #6
   158e6:	4601      	mov	r1, r0
   158e8:	f042 0201 	orr.w	r2, r2, #1
   158ec:	4806      	ldr	r0, [pc, #24]	; (15908 <reset_state+0x54>)
   158ee:	f00e fb76 	bl	23fde <log_1>
		return err;
	}

	return 0;
}
   158f2:	4620      	mov	r0, r4
   158f4:	bd10      	pop	{r4, pc}
   158f6:	bf00      	nop
   158f8:	20000b68 	.word	0x20000b68
   158fc:	20006efc 	.word	0x20006efc
   15900:	00029970 	.word	0x00029970
   15904:	00029830 	.word	0x00029830
   15908:	0002f539 	.word	0x0002f539

0001590c <prov_failed>:
		bt_mesh_proxy_identity_enable();
	}
}

static void prov_failed(const u8_t *data)
{
   1590c:	b508      	push	{r3, lr}
   1590e:	4a07      	ldr	r2, [pc, #28]	; (1592c <prov_failed+0x20>)
   15910:	4b07      	ldr	r3, [pc, #28]	; (15930 <prov_failed+0x24>)
	BT_WARN("Error: 0x%02x", data[0]);
   15912:	7801      	ldrb	r1, [r0, #0]
   15914:	4807      	ldr	r0, [pc, #28]	; (15934 <prov_failed+0x28>)
   15916:	1ad2      	subs	r2, r2, r3
   15918:	08d2      	lsrs	r2, r2, #3
   1591a:	0192      	lsls	r2, r2, #6
   1591c:	f042 0202 	orr.w	r2, r2, #2
   15920:	f00e fb5d 	bl	23fde <log_1>
	reset_state();
}
   15924:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	reset_state();
   15928:	f7ff bfc4 	b.w	158b4 <reset_state>
   1592c:	00029970 	.word	0x00029970
   15930:	00029830 	.word	0x00029830
   15934:	0002f55c 	.word	0x0002f55c

00015938 <prov_link_closed>:
	}
}

static void prov_link_closed(const struct prov_bearer *bearer, void *cb_data,
			     enum prov_bearer_link_status reason)
{
   15938:	b510      	push	{r4, lr}
   1593a:	4604      	mov	r4, r0
	/* Reset state before calling link_close, so a new provisioning
	 * procedure can be started from the callback.
	 */
	reset_state();
   1593c:	f7ff ffba 	bl	158b4 <reset_state>

	BT_DBG("%u", reason);

	if (prov->link_close) {
   15940:	4b04      	ldr	r3, [pc, #16]	; (15954 <prov_link_closed+0x1c>)
   15942:	681b      	ldr	r3, [r3, #0]
   15944:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   15946:	b11b      	cbz	r3, 15950 <prov_link_closed+0x18>
		prov->link_close(bearer->type);
   15948:	7820      	ldrb	r0, [r4, #0]
	}
}
   1594a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		prov->link_close(bearer->type);
   1594e:	4718      	bx	r3
}
   15950:	bd10      	pop	{r4, pc}
   15952:	bf00      	nop
   15954:	20000c88 	.word	0x20000c88

00015958 <prov_send.constprop.0>:
	return link.bearer->send(buf, cb, NULL);
   15958:	4b03      	ldr	r3, [pc, #12]	; (15968 <prov_send.constprop.0+0x10>)
   1595a:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
   1595e:	2200      	movs	r2, #0
   15960:	689b      	ldr	r3, [r3, #8]
   15962:	4611      	mov	r1, r2
   15964:	4718      	bx	r3
   15966:	bf00      	nop
   15968:	20000b68 	.word	0x20000b68

0001596c <prov_invite>:
{
   1596c:	b530      	push	{r4, r5, lr}
   1596e:	b089      	sub	sp, #36	; 0x24
	if (data[0]) {
   15970:	7801      	ldrb	r1, [r0, #0]
	PROV_BUF(buf, 12);
   15972:	ab03      	add	r3, sp, #12
   15974:	f44f 1288 	mov.w	r2, #1114112	; 0x110000
   15978:	e9cd 2301 	strd	r2, r3, [sp, #4]
{
   1597c:	4604      	mov	r4, r0
	PROV_BUF(buf, 12);
   1597e:	9300      	str	r3, [sp, #0]
	if (data[0]) {
   15980:	b111      	cbz	r1, 15988 <prov_invite+0x1c>
		bt_mesh_attention(NULL, data[0]);
   15982:	2000      	movs	r0, #0
   15984:	f7fd f820 	bl	129c8 <bt_mesh_attention>
	link.conf_inputs[0] = data[0];
   15988:	4d26      	ldr	r5, [pc, #152]	; (15a24 <prov_invite+0xb8>)
   1598a:	7823      	ldrb	r3, [r4, #0]
   1598c:	f885 3078 	strb.w	r3, [r5, #120]	; 0x78
	prov_buf_init(&buf, PROV_CAPABILITIES);
   15990:	2101      	movs	r1, #1
   15992:	4668      	mov	r0, sp
   15994:	f012 fa8b 	bl	27eae <prov_buf_init>
	net_buf_simple_add_u8(&buf, bt_mesh_elem_count());
   15998:	f7fa f8dc 	bl	fb54 <bt_mesh_elem_count>
   1599c:	4601      	mov	r1, r0
   1599e:	4668      	mov	r0, sp
   159a0:	f013 fa15 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&buf, prov->static_val ? BIT(0) : 0x00);
   159a4:	4c20      	ldr	r4, [pc, #128]	; (15a28 <prov_invite+0xbc>)
	net_buf_simple_add_be16(&buf, BIT(PROV_ALG_P256));
   159a6:	2101      	movs	r1, #1
   159a8:	4668      	mov	r0, sp
   159aa:	f013 fa20 	bl	28dee <net_buf_simple_add_be16>
	net_buf_simple_add_u8(&buf, PUB_KEY_NO_OOB);
   159ae:	2100      	movs	r1, #0
   159b0:	4668      	mov	r0, sp
   159b2:	f013 fa0c 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&buf, prov->static_val ? BIT(0) : 0x00);
   159b6:	6823      	ldr	r3, [r4, #0]
   159b8:	68d9      	ldr	r1, [r3, #12]
   159ba:	3900      	subs	r1, #0
   159bc:	bf18      	it	ne
   159be:	2101      	movne	r1, #1
   159c0:	4668      	mov	r0, sp
   159c2:	f013 fa04 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&buf, prov->output_size);
   159c6:	6823      	ldr	r3, [r4, #0]
   159c8:	4668      	mov	r0, sp
   159ca:	7c59      	ldrb	r1, [r3, #17]
   159cc:	f013 f9ff 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_be16(&buf, prov->output_actions);
   159d0:	6823      	ldr	r3, [r4, #0]
   159d2:	4668      	mov	r0, sp
   159d4:	8a59      	ldrh	r1, [r3, #18]
   159d6:	f013 fa0a 	bl	28dee <net_buf_simple_add_be16>
	net_buf_simple_add_u8(&buf, prov->input_size);
   159da:	6823      	ldr	r3, [r4, #0]
   159dc:	4668      	mov	r0, sp
   159de:	7d19      	ldrb	r1, [r3, #20]
   159e0:	f013 f9f5 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_be16(&buf, prov->input_actions);
   159e4:	6823      	ldr	r3, [r4, #0]
   159e6:	4668      	mov	r0, sp
   159e8:	8ad9      	ldrh	r1, [r3, #22]
   159ea:	f013 fa00 	bl	28dee <net_buf_simple_add_be16>
	memcpy(&link.conf_inputs[1], &buf.data[1], 11);
   159ee:	9900      	ldr	r1, [sp, #0]
   159f0:	220b      	movs	r2, #11
   159f2:	3101      	adds	r1, #1
   159f4:	f105 0079 	add.w	r0, r5, #121	; 0x79
   159f8:	f010 f956 	bl	25ca8 <memcpy>
	if (prov_send(&buf, NULL)) {
   159fc:	4668      	mov	r0, sp
   159fe:	f7ff ffab 	bl	15958 <prov_send.constprop.0>
   15a02:	b158      	cbz	r0, 15a1c <prov_invite+0xb0>
   15a04:	4909      	ldr	r1, [pc, #36]	; (15a2c <prov_invite+0xc0>)
   15a06:	4b0a      	ldr	r3, [pc, #40]	; (15a30 <prov_invite+0xc4>)
		BT_ERR("Failed to send capabilities");
   15a08:	480a      	ldr	r0, [pc, #40]	; (15a34 <prov_invite+0xc8>)
   15a0a:	1ac9      	subs	r1, r1, r3
   15a0c:	08c9      	lsrs	r1, r1, #3
   15a0e:	0189      	lsls	r1, r1, #6
   15a10:	f041 0101 	orr.w	r1, r1, #1
   15a14:	f00e fad6 	bl	23fc4 <log_0>
}
   15a18:	b009      	add	sp, #36	; 0x24
   15a1a:	bd30      	pop	{r4, r5, pc}
	link.expect = PROV_START;
   15a1c:	2302      	movs	r3, #2
   15a1e:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
   15a22:	e7f9      	b.n	15a18 <prov_invite+0xac>
   15a24:	20000b68 	.word	0x20000b68
   15a28:	20000c88 	.word	0x20000c88
   15a2c:	00029970 	.word	0x00029970
   15a30:	00029830 	.word	0x00029830
   15a34:	0002f56a 	.word	0x0002f56a

00015a38 <sys_memcpy_swap.constprop.0>:
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
   15a38:	4288      	cmp	r0, r1
static inline void sys_memcpy_swap(void *dst, const void *src, size_t length)
   15a3a:	b570      	push	{r4, r5, r6, lr}
   15a3c:	4604      	mov	r4, r0
   15a3e:	460d      	mov	r5, r1
   15a40:	f101 0620 	add.w	r6, r1, #32
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
   15a44:	d919      	bls.n	15a7a <sys_memcpy_swap.constprop.0+0x42>
   15a46:	42b0      	cmp	r0, r6
   15a48:	d20e      	bcs.n	15a68 <sys_memcpy_swap.constprop.0+0x30>
   15a4a:	490e      	ldr	r1, [pc, #56]	; (15a84 <sys_memcpy_swap.constprop.0+0x4c>)
   15a4c:	4a0e      	ldr	r2, [pc, #56]	; (15a88 <sys_memcpy_swap.constprop.0+0x50>)
   15a4e:	480f      	ldr	r0, [pc, #60]	; (15a8c <sys_memcpy_swap.constprop.0+0x54>)
   15a50:	f240 2317 	movw	r3, #535	; 0x217
   15a54:	f00e fa45 	bl	23ee2 <printk>
   15a58:	480d      	ldr	r0, [pc, #52]	; (15a90 <sys_memcpy_swap.constprop.0+0x58>)
   15a5a:	f00e fa42 	bl	23ee2 <printk>
   15a5e:	480a      	ldr	r0, [pc, #40]	; (15a88 <sys_memcpy_swap.constprop.0+0x50>)
   15a60:	f240 2117 	movw	r1, #535	; 0x217
   15a64:	f00e fa80 	bl	23f68 <assert_post_action>
	for (; length > 0; length--) {
   15a68:	4633      	mov	r3, r6
   15a6a:	3c01      	subs	r4, #1
		*pdst++ = *psrc--;
   15a6c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   15a70:	f804 2f01 	strb.w	r2, [r4, #1]!
	for (; length > 0; length--) {
   15a74:	42ab      	cmp	r3, r5
   15a76:	d1f9      	bne.n	15a6c <sys_memcpy_swap.constprop.0+0x34>
}
   15a78:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
   15a7a:	d0e6      	beq.n	15a4a <sys_memcpy_swap.constprop.0+0x12>
   15a7c:	f100 0320 	add.w	r3, r0, #32
   15a80:	4299      	cmp	r1, r3
   15a82:	e7e1      	b.n	15a48 <sys_memcpy_swap.constprop.0+0x10>
   15a84:	0002b8b3 	.word	0x0002b8b3
   15a88:	0002b88c 	.word	0x0002b88c
   15a8c:	0002a5e8 	.word	0x0002a5e8
   15a90:	0002b90a 	.word	0x0002b90a

00015a94 <atomic_get.constprop.0>:
   15a94:	4b03      	ldr	r3, [pc, #12]	; (15aa4 <atomic_get.constprop.0+0x10>)
   15a96:	f3bf 8f5b 	dmb	ish
   15a9a:	6818      	ldr	r0, [r3, #0]
   15a9c:	f3bf 8f5b 	dmb	ish
}
   15aa0:	4770      	bx	lr
   15aa2:	bf00      	nop
   15aa4:	20000b68 	.word	0x20000b68

00015aa8 <prov_link_opened>:
{
   15aa8:	b530      	push	{r4, r5, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   15aaa:	2102      	movs	r1, #2
   15aac:	b087      	sub	sp, #28
   15aae:	4605      	mov	r5, r0
   15ab0:	481b      	ldr	r0, [pc, #108]	; (15b20 <prov_link_opened+0x78>)
   15ab2:	f012 fa08 	bl	27ec6 <atomic_or>
	if (prov->link_open) {
   15ab6:	4b1b      	ldr	r3, [pc, #108]	; (15b24 <prov_link_opened+0x7c>)
   15ab8:	681b      	ldr	r3, [r3, #0]
   15aba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15abc:	b10b      	cbz	r3, 15ac2 <prov_link_opened+0x1a>
		prov->link_open(bearer->type);
   15abe:	7828      	ldrb	r0, [r5, #0]
   15ac0:	4798      	blx	r3
	link.bearer = bearer;
   15ac2:	4c17      	ldr	r4, [pc, #92]	; (15b20 <prov_link_opened+0x78>)
   15ac4:	f8c4 511c 	str.w	r5, [r4, #284]	; 0x11c
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   15ac8:	f7ff ffe4 	bl	15a94 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   15acc:	0682      	lsls	r2, r0, #26
   15ace:	f3c0 1340 	ubfx	r3, r0, #5, #1
   15ad2:	d521      	bpl.n	15b18 <prov_link_opened+0x70>
	PROV_BUF(inv, 2);
   15ad4:	ab01      	add	r3, sp, #4
   15ad6:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
	prov_buf_init(&inv, PROV_INVITE);
   15ada:	2100      	movs	r1, #0
   15adc:	a803      	add	r0, sp, #12
	PROV_BUF(inv, 2);
   15ade:	e9cd 2304 	strd	r2, r3, [sp, #16]
   15ae2:	9303      	str	r3, [sp, #12]
	prov_buf_init(&inv, PROV_INVITE);
   15ae4:	f012 f9e3 	bl	27eae <prov_buf_init>
	net_buf_simple_add_u8(&inv, link.provisioner->attention_duration);
   15ae8:	7b21      	ldrb	r1, [r4, #12]
   15aea:	a803      	add	r0, sp, #12
   15aec:	f013 f96f 	bl	28dce <net_buf_simple_add_u8>
	link.conf_inputs[0] = link.provisioner->attention_duration;
   15af0:	7b23      	ldrb	r3, [r4, #12]
   15af2:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
	if (prov_send(&inv, NULL)) {
   15af6:	a803      	add	r0, sp, #12
   15af8:	f7ff ff2e 	bl	15958 <prov_send.constprop.0>
   15afc:	b158      	cbz	r0, 15b16 <prov_link_opened+0x6e>
   15afe:	490a      	ldr	r1, [pc, #40]	; (15b28 <prov_link_opened+0x80>)
   15b00:	4b0a      	ldr	r3, [pc, #40]	; (15b2c <prov_link_opened+0x84>)
		BT_ERR("Failed to send invite");
   15b02:	480b      	ldr	r0, [pc, #44]	; (15b30 <prov_link_opened+0x88>)
   15b04:	1ac9      	subs	r1, r1, r3
   15b06:	08c9      	lsrs	r1, r1, #3
   15b08:	0189      	lsls	r1, r1, #6
   15b0a:	f041 0101 	orr.w	r1, r1, #1
   15b0e:	f00e fa59 	bl	23fc4 <log_0>
}
   15b12:	b007      	add	sp, #28
   15b14:	bd30      	pop	{r4, r5, pc}
	link.expect = PROV_CAPABILITIES;
   15b16:	2301      	movs	r3, #1
		link.expect = PROV_INVITE;
   15b18:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
   15b1c:	e7f9      	b.n	15b12 <prov_link_opened+0x6a>
   15b1e:	bf00      	nop
   15b20:	20000b68 	.word	0x20000b68
   15b24:	20000c88 	.word	0x20000c88
   15b28:	00029970 	.word	0x00029970
   15b2c:	00029830 	.word	0x00029830
   15b30:	0002f586 	.word	0x0002f586

00015b34 <send_random>:
{
   15b34:	b500      	push	{lr}
   15b36:	b08b      	sub	sp, #44	; 0x2c
	PROV_BUF(rnd, 17);
   15b38:	ab04      	add	r3, sp, #16
   15b3a:	f44f 12b0 	mov.w	r2, #1441792	; 0x160000
	prov_buf_init(&rnd, PROV_RANDOM);
   15b3e:	2106      	movs	r1, #6
   15b40:	a801      	add	r0, sp, #4
	PROV_BUF(rnd, 17);
   15b42:	e9cd 2302 	strd	r2, r3, [sp, #8]
   15b46:	9301      	str	r3, [sp, #4]
	prov_buf_init(&rnd, PROV_RANDOM);
   15b48:	f012 f9b1 	bl	27eae <prov_buf_init>
	net_buf_simple_add_mem(&rnd, link.rand, 16);
   15b4c:	4910      	ldr	r1, [pc, #64]	; (15b90 <send_random+0x5c>)
   15b4e:	2210      	movs	r2, #16
   15b50:	a801      	add	r0, sp, #4
   15b52:	f013 f930 	bl	28db6 <net_buf_simple_add_mem>
	if (prov_send(&rnd, NULL)) {
   15b56:	a801      	add	r0, sp, #4
   15b58:	f7ff fefe 	bl	15958 <prov_send.constprop.0>
   15b5c:	b160      	cbz	r0, 15b78 <send_random+0x44>
   15b5e:	490d      	ldr	r1, [pc, #52]	; (15b94 <send_random+0x60>)
   15b60:	4b0d      	ldr	r3, [pc, #52]	; (15b98 <send_random+0x64>)
		BT_ERR("Failed to send Provisioning Random");
   15b62:	480e      	ldr	r0, [pc, #56]	; (15b9c <send_random+0x68>)
   15b64:	1ac9      	subs	r1, r1, r3
   15b66:	08c9      	lsrs	r1, r1, #3
   15b68:	0189      	lsls	r1, r1, #6
   15b6a:	f041 0101 	orr.w	r1, r1, #1
   15b6e:	f00e fa29 	bl	23fc4 <log_0>
}
   15b72:	b00b      	add	sp, #44	; 0x2c
   15b74:	f85d fb04 	ldr.w	pc, [sp], #4
   15b78:	f7ff ff8c 	bl	15a94 <atomic_get.constprop.0>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   15b7c:	4b08      	ldr	r3, [pc, #32]	; (15ba0 <send_random+0x6c>)
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   15b7e:	f010 0f20 	tst.w	r0, #32
		link.expect = PROV_DATA;
   15b82:	bf14      	ite	ne
   15b84:	2206      	movne	r2, #6
   15b86:	2207      	moveq	r2, #7
   15b88:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
   15b8c:	e7f1      	b.n	15b72 <send_random+0x3e>
   15b8e:	bf00      	nop
   15b90:	20000ba0 	.word	0x20000ba0
   15b94:	00029970 	.word	0x00029970
   15b98:	00029830 	.word	0x00029830
   15b9c:	0002f59c 	.word	0x0002f59c
   15ba0:	20000b68 	.word	0x20000b68

00015ba4 <prov_fail>:
{
   15ba4:	b510      	push	{r4, lr}
   15ba6:	b086      	sub	sp, #24
   15ba8:	4604      	mov	r4, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   15baa:	f7ff ff73 	bl	15a94 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   15bae:	f010 0f20 	tst.w	r0, #32
   15bb2:	4b16      	ldr	r3, [pc, #88]	; (15c0c <prov_fail+0x68>)
   15bb4:	d009      	beq.n	15bca <prov_fail+0x26>
	link.expect = PROV_NO_PDU;
   15bb6:	22ff      	movs	r2, #255	; 0xff
   15bb8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
	link.bearer->link_close(status);
   15bbc:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
   15bc0:	2002      	movs	r0, #2
   15bc2:	695b      	ldr	r3, [r3, #20]
   15bc4:	4798      	blx	r3
}
   15bc6:	b006      	add	sp, #24
   15bc8:	bd10      	pop	{r4, pc}
	PROV_BUF(buf, 2);
   15bca:	aa01      	add	r2, sp, #4
   15bcc:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   15bd0:	e9cd 1204 	strd	r1, r2, [sp, #16]
   15bd4:	9203      	str	r2, [sp, #12]
	prov_buf_init(&buf, PROV_FAILED);
   15bd6:	2109      	movs	r1, #9
	link.expect = PROV_NO_PDU;
   15bd8:	22ff      	movs	r2, #255	; 0xff
	prov_buf_init(&buf, PROV_FAILED);
   15bda:	a803      	add	r0, sp, #12
	link.expect = PROV_NO_PDU;
   15bdc:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
	prov_buf_init(&buf, PROV_FAILED);
   15be0:	f012 f965 	bl	27eae <prov_buf_init>
	net_buf_simple_add_u8(&buf, err);
   15be4:	4621      	mov	r1, r4
   15be6:	a803      	add	r0, sp, #12
   15be8:	f013 f8f1 	bl	28dce <net_buf_simple_add_u8>
	if (prov_send(&buf, NULL)) {
   15bec:	a803      	add	r0, sp, #12
   15bee:	f7ff feb3 	bl	15958 <prov_send.constprop.0>
   15bf2:	2800      	cmp	r0, #0
   15bf4:	d0e7      	beq.n	15bc6 <prov_fail+0x22>
   15bf6:	4b06      	ldr	r3, [pc, #24]	; (15c10 <prov_fail+0x6c>)
   15bf8:	4906      	ldr	r1, [pc, #24]	; (15c14 <prov_fail+0x70>)
		BT_ERR("Failed to send Provisioning Failed message");
   15bfa:	4807      	ldr	r0, [pc, #28]	; (15c18 <prov_fail+0x74>)
   15bfc:	1ac9      	subs	r1, r1, r3
   15bfe:	08c9      	lsrs	r1, r1, #3
   15c00:	0189      	lsls	r1, r1, #6
   15c02:	f041 0101 	orr.w	r1, r1, #1
   15c06:	f00e f9dd 	bl	23fc4 <log_0>
}
   15c0a:	e7dc      	b.n	15bc6 <prov_fail+0x22>
   15c0c:	20000b68 	.word	0x20000b68
   15c10:	00029830 	.word	0x00029830
   15c14:	00029970 	.word	0x00029970
   15c18:	0002f5bf 	.word	0x0002f5bf

00015c1c <prov_recv>:
{
   15c1c:	b510      	push	{r4, lr}
	u8_t type = buf->data[0];
   15c1e:	6810      	ldr	r0, [r2, #0]
   15c20:	7804      	ldrb	r4, [r0, #0]
	if (type != PROV_FAILED && type != link.expect) {
   15c22:	2c09      	cmp	r4, #9
   15c24:	d023      	beq.n	15c6e <prov_recv+0x52>
   15c26:	4b1f      	ldr	r3, [pc, #124]	; (15ca4 <prov_recv+0x88>)
   15c28:	f893 1024 	ldrb.w	r1, [r3, #36]	; 0x24
   15c2c:	42a1      	cmp	r1, r4
   15c2e:	d010      	beq.n	15c52 <prov_recv+0x36>
   15c30:	4a1d      	ldr	r2, [pc, #116]	; (15ca8 <prov_recv+0x8c>)
   15c32:	4b1e      	ldr	r3, [pc, #120]	; (15cac <prov_recv+0x90>)
		BT_WARN("Unexpected msg 0x%02x != 0x%02x", type, link.expect);
   15c34:	481e      	ldr	r0, [pc, #120]	; (15cb0 <prov_recv+0x94>)
   15c36:	1a9b      	subs	r3, r3, r2
   15c38:	08db      	lsrs	r3, r3, #3
   15c3a:	019b      	lsls	r3, r3, #6
   15c3c:	460a      	mov	r2, r1
   15c3e:	f043 0302 	orr.w	r3, r3, #2
   15c42:	4621      	mov	r1, r4
   15c44:	f00e f9df 	bl	24006 <log_2>
		prov_fail(PROV_ERR_UNEXP_PDU);
   15c48:	2003      	movs	r0, #3
}
   15c4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		prov_fail(PROV_ERR_NVAL_PDU);
   15c4e:	f7ff bfa9 	b.w	15ba4 <prov_fail>
	if (type >= ARRAY_SIZE(prov_handlers)) {
   15c52:	2909      	cmp	r1, #9
   15c54:	d90b      	bls.n	15c6e <prov_recv+0x52>
   15c56:	4b14      	ldr	r3, [pc, #80]	; (15ca8 <prov_recv+0x8c>)
   15c58:	4a14      	ldr	r2, [pc, #80]	; (15cac <prov_recv+0x90>)
		BT_ERR("Unknown provisioning PDU type 0x%02x", type);
   15c5a:	4816      	ldr	r0, [pc, #88]	; (15cb4 <prov_recv+0x98>)
   15c5c:	1ad2      	subs	r2, r2, r3
   15c5e:	08d2      	lsrs	r2, r2, #3
   15c60:	0192      	lsls	r2, r2, #6
   15c62:	f042 0201 	orr.w	r2, r2, #1
   15c66:	f00e f9ba 	bl	23fde <log_1>
		prov_fail(PROV_ERR_NVAL_PDU);
   15c6a:	2001      	movs	r0, #1
   15c6c:	e7ed      	b.n	15c4a <prov_recv+0x2e>
	if (1 + prov_handlers[type].len != buf->len) {
   15c6e:	8891      	ldrh	r1, [r2, #4]
   15c70:	4a11      	ldr	r2, [pc, #68]	; (15cb8 <prov_recv+0x9c>)
   15c72:	eb02 03c4 	add.w	r3, r2, r4, lsl #3
   15c76:	889b      	ldrh	r3, [r3, #4]
   15c78:	3301      	adds	r3, #1
   15c7a:	428b      	cmp	r3, r1
   15c7c:	d00c      	beq.n	15c98 <prov_recv+0x7c>
   15c7e:	4a0a      	ldr	r2, [pc, #40]	; (15ca8 <prov_recv+0x8c>)
   15c80:	4b0a      	ldr	r3, [pc, #40]	; (15cac <prov_recv+0x90>)
		BT_ERR("Invalid length %u for type 0x%02x", buf->len, type);
   15c82:	480e      	ldr	r0, [pc, #56]	; (15cbc <prov_recv+0xa0>)
   15c84:	1a9b      	subs	r3, r3, r2
   15c86:	08db      	lsrs	r3, r3, #3
   15c88:	019b      	lsls	r3, r3, #6
   15c8a:	f043 0301 	orr.w	r3, r3, #1
   15c8e:	4622      	mov	r2, r4
   15c90:	f00e f9b9 	bl	24006 <log_2>
		prov_fail(PROV_ERR_NVAL_FMT);
   15c94:	2002      	movs	r0, #2
   15c96:	e7d8      	b.n	15c4a <prov_recv+0x2e>
	prov_handlers[type].func(&buf->data[1]);
   15c98:	f852 3034 	ldr.w	r3, [r2, r4, lsl #3]
   15c9c:	3001      	adds	r0, #1
}
   15c9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prov_handlers[type].func(&buf->data[1]);
   15ca2:	4718      	bx	r3
   15ca4:	20000b68 	.word	0x20000b68
   15ca8:	00029830 	.word	0x00029830
   15cac:	00029970 	.word	0x00029970
   15cb0:	0002f5ea 	.word	0x0002f5ea
   15cb4:	0002f60a 	.word	0x0002f60a
   15cb8:	0002a384 	.word	0x0002a384
   15cbc:	0002f62f 	.word	0x0002f62f

00015cc0 <send_pub_key>:
{
   15cc0:	b510      	push	{r4, lr}
   15cc2:	b096      	sub	sp, #88	; 0x58
	PROV_BUF(buf, 65);
   15cc4:	ab04      	add	r3, sp, #16
   15cc6:	f44f 028c 	mov.w	r2, #4587520	; 0x460000
   15cca:	e9cd 2302 	strd	r2, r3, [sp, #8]
   15cce:	9301      	str	r3, [sp, #4]
	key = bt_pub_key_get();
   15cd0:	f7f2 ff12 	bl	8af8 <bt_pub_key_get>
	if (!key) {
   15cd4:	4604      	mov	r4, r0
   15cd6:	b970      	cbnz	r0, 15cf6 <send_pub_key+0x36>
   15cd8:	4b29      	ldr	r3, [pc, #164]	; (15d80 <send_pub_key+0xc0>)
   15cda:	492a      	ldr	r1, [pc, #168]	; (15d84 <send_pub_key+0xc4>)
		BT_ERR("No public key available");
   15cdc:	482a      	ldr	r0, [pc, #168]	; (15d88 <send_pub_key+0xc8>)
   15cde:	1ac9      	subs	r1, r1, r3
   15ce0:	08c9      	lsrs	r1, r1, #3
   15ce2:	0189      	lsls	r1, r1, #6
   15ce4:	f041 0101 	orr.w	r1, r1, #1
   15ce8:	f00e f96c 	bl	23fc4 <log_0>
		prov_fail(PROV_ERR_UNEXP_ERR);
   15cec:	2007      	movs	r0, #7
   15cee:	f7ff ff59 	bl	15ba4 <prov_fail>
}
   15cf2:	b016      	add	sp, #88	; 0x58
   15cf4:	bd10      	pop	{r4, pc}
	prov_buf_init(&buf, PROV_PUB_KEY);
   15cf6:	2103      	movs	r1, #3
   15cf8:	a801      	add	r0, sp, #4
   15cfa:	f012 f8d8 	bl	27eae <prov_buf_init>
	sys_memcpy_swap(net_buf_simple_add(&buf, 32), key, 32);
   15cfe:	2120      	movs	r1, #32
   15d00:	a801      	add	r0, sp, #4
   15d02:	f009 fae9 	bl	1f2d8 <net_buf_simple_add>
   15d06:	4621      	mov	r1, r4
   15d08:	f7ff fe96 	bl	15a38 <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(net_buf_simple_add(&buf, 32), &key[32], 32);
   15d0c:	2120      	movs	r1, #32
   15d0e:	a801      	add	r0, sp, #4
   15d10:	f009 fae2 	bl	1f2d8 <net_buf_simple_add>
   15d14:	f104 0120 	add.w	r1, r4, #32
   15d18:	f7ff fe8e 	bl	15a38 <sys_memcpy_swap.constprop.0>
   15d1c:	f7ff feba 	bl	15a94 <atomic_get.constprop.0>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   15d20:	9901      	ldr	r1, [sp, #4]
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   15d22:	f010 0f20 	tst.w	r0, #32
		memcpy(&link.conf_inputs[17], &buf.data[1], 64);
   15d26:	bf14      	ite	ne
   15d28:	4818      	ldrne	r0, [pc, #96]	; (15d8c <send_pub_key+0xcc>)
		memcpy(&link.conf_inputs[81], &buf.data[1], 64);
   15d2a:	4819      	ldreq	r0, [pc, #100]	; (15d90 <send_pub_key+0xd0>)
		memcpy(&link.conf_inputs[17], &buf.data[1], 64);
   15d2c:	2240      	movs	r2, #64	; 0x40
   15d2e:	3101      	adds	r1, #1
		memcpy(&link.conf_inputs[81], &buf.data[1], 64);
   15d30:	f00f ffba 	bl	25ca8 <memcpy>
	if (prov_send(&buf, NULL)) {
   15d34:	a801      	add	r0, sp, #4
   15d36:	f7ff fe0f 	bl	15958 <prov_send.constprop.0>
   15d3a:	b150      	cbz	r0, 15d52 <send_pub_key+0x92>
   15d3c:	4b10      	ldr	r3, [pc, #64]	; (15d80 <send_pub_key+0xc0>)
   15d3e:	4911      	ldr	r1, [pc, #68]	; (15d84 <send_pub_key+0xc4>)
		BT_ERR("Failed to send Public Key");
   15d40:	4814      	ldr	r0, [pc, #80]	; (15d94 <send_pub_key+0xd4>)
   15d42:	1ac9      	subs	r1, r1, r3
   15d44:	08c9      	lsrs	r1, r1, #3
   15d46:	0189      	lsls	r1, r1, #6
   15d48:	f041 0101 	orr.w	r1, r1, #1
   15d4c:	f00e f93a 	bl	23fc4 <log_0>
		return;
   15d50:	e7cf      	b.n	15cf2 <send_pub_key+0x32>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   15d52:	f7ff fe9f 	bl	15a94 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   15d56:	f010 0f20 	tst.w	r0, #32
   15d5a:	4a0f      	ldr	r2, [pc, #60]	; (15d98 <send_pub_key+0xd8>)
   15d5c:	d003      	beq.n	15d66 <send_pub_key+0xa6>
		link.expect = PROV_PUB_KEY;
   15d5e:	2303      	movs	r3, #3
			link.expect = PROV_CONFIRM;
   15d60:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
   15d64:	e7c5      	b.n	15cf2 <send_pub_key+0x32>
   15d66:	f7ff fe95 	bl	15a94 <atomic_get.constprop.0>
		if (atomic_test_bit(link.flags, WAIT_NUMBER) ||
   15d6a:	0741      	lsls	r1, r0, #29
   15d6c:	d501      	bpl.n	15d72 <send_pub_key+0xb2>
			link.expect = PROV_NO_PDU; /* Wait for input */
   15d6e:	23ff      	movs	r3, #255	; 0xff
   15d70:	e7f6      	b.n	15d60 <send_pub_key+0xa0>
   15d72:	f7ff fe8f 	bl	15a94 <atomic_get.constprop.0>
		if (atomic_test_bit(link.flags, WAIT_NUMBER) ||
   15d76:	0703      	lsls	r3, r0, #28
   15d78:	d4f9      	bmi.n	15d6e <send_pub_key+0xae>
			link.expect = PROV_CONFIRM;
   15d7a:	2305      	movs	r3, #5
   15d7c:	e7f0      	b.n	15d60 <send_pub_key+0xa0>
   15d7e:	bf00      	nop
   15d80:	00029830 	.word	0x00029830
   15d84:	00029970 	.word	0x00029970
   15d88:	0002f651 	.word	0x0002f651
   15d8c:	20000bf1 	.word	0x20000bf1
   15d90:	20000c31 	.word	0x20000c31
   15d94:	0002f669 	.word	0x0002f669
   15d98:	20000b68 	.word	0x20000b68

00015d9c <prov_dh_key_gen>:
{
   15d9c:	b510      	push	{r4, lr}
   15d9e:	b090      	sub	sp, #64	; 0x40
   15da0:	f7ff fe78 	bl	15a94 <atomic_get.constprop.0>
		remote_pk = &link.conf_inputs[17];
   15da4:	4c11      	ldr	r4, [pc, #68]	; (15dec <prov_dh_key_gen+0x50>)
   15da6:	f010 0f20 	tst.w	r0, #32
   15daa:	f1a4 0140 	sub.w	r1, r4, #64	; 0x40
   15dae:	bf08      	it	eq
   15db0:	460c      	moveq	r4, r1
	sys_memcpy_swap(remote_pk_le, remote_pk, 32);
   15db2:	4621      	mov	r1, r4
   15db4:	4668      	mov	r0, sp
   15db6:	f7ff fe3f 	bl	15a38 <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(&remote_pk_le[32], &remote_pk[32], 32);
   15dba:	f104 0120 	add.w	r1, r4, #32
   15dbe:	a808      	add	r0, sp, #32
   15dc0:	f7ff fe3a 	bl	15a38 <sys_memcpy_swap.constprop.0>
	if (bt_dh_key_gen(remote_pk_le, prov_dh_key_cb)) {
   15dc4:	490a      	ldr	r1, [pc, #40]	; (15df0 <prov_dh_key_gen+0x54>)
   15dc6:	4668      	mov	r0, sp
   15dc8:	f7f2 fea4 	bl	8b14 <bt_dh_key_gen>
   15dcc:	b160      	cbz	r0, 15de8 <prov_dh_key_gen+0x4c>
   15dce:	4b09      	ldr	r3, [pc, #36]	; (15df4 <prov_dh_key_gen+0x58>)
   15dd0:	4909      	ldr	r1, [pc, #36]	; (15df8 <prov_dh_key_gen+0x5c>)
		BT_ERR("Failed to generate DHKey");
   15dd2:	480a      	ldr	r0, [pc, #40]	; (15dfc <prov_dh_key_gen+0x60>)
   15dd4:	1ac9      	subs	r1, r1, r3
   15dd6:	08c9      	lsrs	r1, r1, #3
   15dd8:	0189      	lsls	r1, r1, #6
   15dda:	f041 0101 	orr.w	r1, r1, #1
   15dde:	f00e f8f1 	bl	23fc4 <log_0>
		prov_fail(PROV_ERR_UNEXP_ERR);
   15de2:	2007      	movs	r0, #7
   15de4:	f7ff fede 	bl	15ba4 <prov_fail>
}
   15de8:	b010      	add	sp, #64	; 0x40
   15dea:	bd10      	pop	{r4, pc}
   15dec:	20000c31 	.word	0x20000c31
   15df0:	00015f7d 	.word	0x00015f7d
   15df4:	00029830 	.word	0x00029830
   15df8:	00029970 	.word	0x00029970
   15dfc:	0002f683 	.word	0x0002f683

00015e00 <prov_pub_key>:
{
   15e00:	b510      	push	{r4, lr}
   15e02:	4601      	mov	r1, r0
   15e04:	f7ff fe46 	bl	15a94 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   15e08:	f010 0f20 	tst.w	r0, #32
   15e0c:	4c15      	ldr	r4, [pc, #84]	; (15e64 <prov_pub_key+0x64>)
		memcpy(&link.conf_inputs[81], data, 64);
   15e0e:	f04f 0240 	mov.w	r2, #64	; 0x40
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   15e12:	d00b      	beq.n	15e2c <prov_pub_key+0x2c>
		memcpy(&link.conf_inputs[81], data, 64);
   15e14:	f104 00c9 	add.w	r0, r4, #201	; 0xc9
   15e18:	f00f ff46 	bl	25ca8 <memcpy>
		link.bearer->clear_tx();
   15e1c:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   15e20:	68db      	ldr	r3, [r3, #12]
   15e22:	4798      	blx	r3
}
   15e24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prov_dh_key_gen();
   15e28:	f7ff bfb8 	b.w	15d9c <prov_dh_key_gen>
		memcpy(&link.conf_inputs[17], data, 64);
   15e2c:	f104 0089 	add.w	r0, r4, #137	; 0x89
   15e30:	f00f ff3a 	bl	25ca8 <memcpy>
		if (!bt_pub_key_get()) {
   15e34:	f7f2 fe60 	bl	8af8 <bt_pub_key_get>
   15e38:	2800      	cmp	r0, #0
   15e3a:	d1f3      	bne.n	15e24 <prov_pub_key+0x24>
			link.bearer->clear_tx();
   15e3c:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   15e40:	68db      	ldr	r3, [r3, #12]
   15e42:	4798      	blx	r3
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   15e44:	2101      	movs	r1, #1
   15e46:	4620      	mov	r0, r4
   15e48:	f012 f83d 	bl	27ec6 <atomic_or>
   15e4c:	4906      	ldr	r1, [pc, #24]	; (15e68 <prov_pub_key+0x68>)
   15e4e:	4b07      	ldr	r3, [pc, #28]	; (15e6c <prov_pub_key+0x6c>)
			BT_WARN("Waiting for local public key");
   15e50:	4807      	ldr	r0, [pc, #28]	; (15e70 <prov_pub_key+0x70>)
   15e52:	1ac9      	subs	r1, r1, r3
   15e54:	08c9      	lsrs	r1, r1, #3
   15e56:	0189      	lsls	r1, r1, #6
}
   15e58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			BT_WARN("Waiting for local public key");
   15e5c:	f041 0102 	orr.w	r1, r1, #2
   15e60:	f00e b8b0 	b.w	23fc4 <log_0>
   15e64:	20000b68 	.word	0x20000b68
   15e68:	00029970 	.word	0x00029970
   15e6c:	00029830 	.word	0x00029830
   15e70:	0002f69c 	.word	0x0002f69c

00015e74 <send_confirm>:
{
   15e74:	b510      	push	{r4, lr}
	if (bt_mesh_prov_conf_salt(link.conf_inputs, link.conf_salt)) {
   15e76:	4938      	ldr	r1, [pc, #224]	; (15f58 <send_confirm+0xe4>)
   15e78:	4c38      	ldr	r4, [pc, #224]	; (15f5c <send_confirm+0xe8>)
{
   15e7a:	b08a      	sub	sp, #40	; 0x28
	PROV_BUF(cfm, 17);
   15e7c:	ab04      	add	r3, sp, #16
   15e7e:	f44f 12b0 	mov.w	r2, #1441792	; 0x160000
	if (bt_mesh_prov_conf_salt(link.conf_inputs, link.conf_salt)) {
   15e82:	f101 0020 	add.w	r0, r1, #32
	PROV_BUF(cfm, 17);
   15e86:	e9cd 2302 	strd	r2, r3, [sp, #8]
   15e8a:	9301      	str	r3, [sp, #4]
	if (bt_mesh_prov_conf_salt(link.conf_inputs, link.conf_salt)) {
   15e8c:	f011 fc0f 	bl	276ae <bt_mesh_prov_conf_salt>
   15e90:	b170      	cbz	r0, 15eb0 <send_confirm+0x3c>
   15e92:	4933      	ldr	r1, [pc, #204]	; (15f60 <send_confirm+0xec>)
   15e94:	4b33      	ldr	r3, [pc, #204]	; (15f64 <send_confirm+0xf0>)
		BT_ERR("Unable to generate confirmation salt");
   15e96:	4834      	ldr	r0, [pc, #208]	; (15f68 <send_confirm+0xf4>)
   15e98:	1ac9      	subs	r1, r1, r3
   15e9a:	08c9      	lsrs	r1, r1, #3
   15e9c:	0189      	lsls	r1, r1, #6
   15e9e:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Unable to generate confirmation value");
   15ea2:	f00e f88f 	bl	23fc4 <log_0>
		prov_fail(PROV_ERR_UNEXP_ERR);
   15ea6:	2007      	movs	r0, #7
   15ea8:	f7ff fe7c 	bl	15ba4 <prov_fail>
}
   15eac:	b00a      	add	sp, #40	; 0x28
   15eae:	bd10      	pop	{r4, pc}
	if (bt_mesh_prov_conf_key(link.dhkey, link.conf_salt, link.conf_key)) {
   15eb0:	f104 0268 	add.w	r2, r4, #104	; 0x68
   15eb4:	f104 0158 	add.w	r1, r4, #88	; 0x58
   15eb8:	1d20      	adds	r0, r4, #4
   15eba:	f7f9 fc15 	bl	f6e8 <bt_mesh_prov_conf_key>
   15ebe:	b140      	cbz	r0, 15ed2 <send_confirm+0x5e>
   15ec0:	4927      	ldr	r1, [pc, #156]	; (15f60 <send_confirm+0xec>)
   15ec2:	4b28      	ldr	r3, [pc, #160]	; (15f64 <send_confirm+0xf0>)
		BT_ERR("Unable to generate confirmation key");
   15ec4:	4829      	ldr	r0, [pc, #164]	; (15f6c <send_confirm+0xf8>)
   15ec6:	1ac9      	subs	r1, r1, r3
   15ec8:	08c9      	lsrs	r1, r1, #3
   15eca:	0189      	lsls	r1, r1, #6
   15ecc:	f041 0101 	orr.w	r1, r1, #1
   15ed0:	e7e7      	b.n	15ea2 <send_confirm+0x2e>
	if (bt_rand(link.rand, 16)) {
   15ed2:	2110      	movs	r1, #16
   15ed4:	f104 0038 	add.w	r0, r4, #56	; 0x38
   15ed8:	f012 fa5b 	bl	28392 <bt_rand>
   15edc:	b140      	cbz	r0, 15ef0 <send_confirm+0x7c>
   15ede:	4920      	ldr	r1, [pc, #128]	; (15f60 <send_confirm+0xec>)
   15ee0:	4b20      	ldr	r3, [pc, #128]	; (15f64 <send_confirm+0xf0>)
		BT_ERR("Unable to generate random number");
   15ee2:	4823      	ldr	r0, [pc, #140]	; (15f70 <send_confirm+0xfc>)
   15ee4:	1ac9      	subs	r1, r1, r3
   15ee6:	08c9      	lsrs	r1, r1, #3
   15ee8:	0189      	lsls	r1, r1, #6
   15eea:	f041 0101 	orr.w	r1, r1, #1
   15eee:	e7d8      	b.n	15ea2 <send_confirm+0x2e>
	prov_buf_init(&cfm, PROV_CONFIRM);
   15ef0:	2105      	movs	r1, #5
   15ef2:	a801      	add	r0, sp, #4
   15ef4:	f011 ffdb 	bl	27eae <prov_buf_init>
			      net_buf_simple_add(&cfm, 16))) {
   15ef8:	2110      	movs	r1, #16
   15efa:	a801      	add	r0, sp, #4
   15efc:	f009 f9ec 	bl	1f2d8 <net_buf_simple_add>
	if (bt_mesh_prov_conf(link.conf_key, link.rand, link.auth,
   15f00:	f104 0248 	add.w	r2, r4, #72	; 0x48
			      net_buf_simple_add(&cfm, 16))) {
   15f04:	4603      	mov	r3, r0
	if (bt_mesh_prov_conf(link.conf_key, link.rand, link.auth,
   15f06:	f104 0138 	add.w	r1, r4, #56	; 0x38
   15f0a:	f104 0068 	add.w	r0, r4, #104	; 0x68
   15f0e:	f011 fbdd 	bl	276cc <bt_mesh_prov_conf>
   15f12:	b140      	cbz	r0, 15f26 <send_confirm+0xb2>
   15f14:	4912      	ldr	r1, [pc, #72]	; (15f60 <send_confirm+0xec>)
   15f16:	4b13      	ldr	r3, [pc, #76]	; (15f64 <send_confirm+0xf0>)
		BT_ERR("Unable to generate confirmation value");
   15f18:	4816      	ldr	r0, [pc, #88]	; (15f74 <send_confirm+0x100>)
   15f1a:	1ac9      	subs	r1, r1, r3
   15f1c:	08c9      	lsrs	r1, r1, #3
   15f1e:	0189      	lsls	r1, r1, #6
   15f20:	f041 0101 	orr.w	r1, r1, #1
   15f24:	e7bd      	b.n	15ea2 <send_confirm+0x2e>
	if (prov_send(&cfm, NULL)) {
   15f26:	a801      	add	r0, sp, #4
   15f28:	f7ff fd16 	bl	15958 <prov_send.constprop.0>
   15f2c:	b150      	cbz	r0, 15f44 <send_confirm+0xd0>
   15f2e:	4b0d      	ldr	r3, [pc, #52]	; (15f64 <send_confirm+0xf0>)
   15f30:	490b      	ldr	r1, [pc, #44]	; (15f60 <send_confirm+0xec>)
		BT_ERR("Failed to send Provisioning Confirm");
   15f32:	4811      	ldr	r0, [pc, #68]	; (15f78 <send_confirm+0x104>)
   15f34:	1ac9      	subs	r1, r1, r3
   15f36:	08c9      	lsrs	r1, r1, #3
   15f38:	0189      	lsls	r1, r1, #6
   15f3a:	f041 0101 	orr.w	r1, r1, #1
   15f3e:	f00e f841 	bl	23fc4 <log_0>
		return;
   15f42:	e7b3      	b.n	15eac <send_confirm+0x38>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   15f44:	f7ff fda6 	bl	15a94 <atomic_get.constprop.0>
		link.expect = PROV_RANDOM;
   15f48:	f010 0f20 	tst.w	r0, #32
   15f4c:	bf14      	ite	ne
   15f4e:	2305      	movne	r3, #5
   15f50:	2306      	moveq	r3, #6
   15f52:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
   15f56:	e7a9      	b.n	15eac <send_confirm+0x38>
   15f58:	20000bc0 	.word	0x20000bc0
   15f5c:	20000b68 	.word	0x20000b68
   15f60:	00029970 	.word	0x00029970
   15f64:	00029830 	.word	0x00029830
   15f68:	0002f6b9 	.word	0x0002f6b9
   15f6c:	0002f6de 	.word	0x0002f6de
   15f70:	0002f702 	.word	0x0002f702
   15f74:	0002f723 	.word	0x0002f723
   15f78:	0002f749 	.word	0x0002f749

00015f7c <prov_dh_key_cb>:
{
   15f7c:	b508      	push	{r3, lr}
	if (!dhkey) {
   15f7e:	4601      	mov	r1, r0
   15f80:	b970      	cbnz	r0, 15fa0 <prov_dh_key_cb+0x24>
   15f82:	4b0f      	ldr	r3, [pc, #60]	; (15fc0 <prov_dh_key_cb+0x44>)
   15f84:	490f      	ldr	r1, [pc, #60]	; (15fc4 <prov_dh_key_cb+0x48>)
		BT_ERR("DHKey generation failed");
   15f86:	4810      	ldr	r0, [pc, #64]	; (15fc8 <prov_dh_key_cb+0x4c>)
   15f88:	1ac9      	subs	r1, r1, r3
   15f8a:	08c9      	lsrs	r1, r1, #3
   15f8c:	0189      	lsls	r1, r1, #6
   15f8e:	f041 0101 	orr.w	r1, r1, #1
   15f92:	f00e f817 	bl	23fc4 <log_0>
}
   15f96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		prov_fail(PROV_ERR_UNEXP_ERR);
   15f9a:	2007      	movs	r0, #7
   15f9c:	f7ff be02 	b.w	15ba4 <prov_fail>
	sys_memcpy_swap(link.dhkey, dhkey, 32);
   15fa0:	480a      	ldr	r0, [pc, #40]	; (15fcc <prov_dh_key_cb+0x50>)
   15fa2:	f7ff fd49 	bl	15a38 <sys_memcpy_swap.constprop.0>
   15fa6:	f7ff fd75 	bl	15a94 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   15faa:	0683      	lsls	r3, r0, #26
   15fac:	d503      	bpl.n	15fb6 <prov_dh_key_cb+0x3a>
}
   15fae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		send_confirm();
   15fb2:	f7ff bf5f 	b.w	15e74 <send_confirm>
}
   15fb6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		send_pub_key();
   15fba:	f7ff be81 	b.w	15cc0 <send_pub_key>
   15fbe:	bf00      	nop
   15fc0:	00029830 	.word	0x00029830
   15fc4:	00029970 	.word	0x00029970
   15fc8:	0002f76d 	.word	0x0002f76d
   15fcc:	20000b6c 	.word	0x20000b6c

00015fd0 <prov_data>:
{
   15fd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

static inline int bt_mesh_session_key(const u8_t dhkey[32],
				      const u8_t prov_salt[16],
				      u8_t session_key[16])
{
	return bt_mesh_k1(dhkey, 32, prov_salt, "prsk", session_key);
   15fd4:	4c5f      	ldr	r4, [pc, #380]	; (16154 <prov_data+0x184>)
   15fd6:	b09f      	sub	sp, #124	; 0x7c
	PROV_BUF(msg, 1);
   15fd8:	ab06      	add	r3, sp, #24
   15fda:	f44f 22c0 	mov.w	r2, #393216	; 0x60000
   15fde:	af0f      	add	r7, sp, #60	; 0x3c
   15fe0:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
{
   15fe4:	4605      	mov	r5, r0
	PROV_BUF(msg, 1);
   15fe6:	9308      	str	r3, [sp, #32]
   15fe8:	9700      	str	r7, [sp, #0]
   15fea:	4b5b      	ldr	r3, [pc, #364]	; (16158 <prov_data+0x188>)
   15fec:	f204 1209 	addw	r2, r4, #265	; 0x109
   15ff0:	2120      	movs	r1, #32
   15ff2:	1d20      	adds	r0, r4, #4
   15ff4:	f011 fa11 	bl	2741a <bt_mesh_k1>
	if (err) {
   15ff8:	b158      	cbz	r0, 16012 <prov_data+0x42>
   15ffa:	4958      	ldr	r1, [pc, #352]	; (1615c <prov_data+0x18c>)
   15ffc:	4b58      	ldr	r3, [pc, #352]	; (16160 <prov_data+0x190>)
		BT_ERR("Unable to generate session key");
   15ffe:	4859      	ldr	r0, [pc, #356]	; (16164 <prov_data+0x194>)
   16000:	1ac9      	subs	r1, r1, r3
   16002:	08c9      	lsrs	r1, r1, #3
   16004:	0189      	lsls	r1, r1, #6
   16006:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Unable to generate session nonce");
   1600a:	f00d ffdb 	bl	23fc4 <log_0>
		prov_fail(PROV_ERR_UNEXP_ERR);
   1600e:	2007      	movs	r0, #7
   16010:	e023      	b.n	1605a <prov_data+0x8a>
				      u8_t nonce[13])
{
	u8_t tmp[16];
	int err;

	err = bt_mesh_k1(dhkey, 32, prov_salt, "prsn", tmp);
   16012:	ae17      	add	r6, sp, #92	; 0x5c
   16014:	4b54      	ldr	r3, [pc, #336]	; (16168 <prov_data+0x198>)
   16016:	9600      	str	r6, [sp, #0]
   16018:	f204 1209 	addw	r2, r4, #265	; 0x109
   1601c:	2120      	movs	r1, #32
   1601e:	1d20      	adds	r0, r4, #4
   16020:	f011 f9fb 	bl	2741a <bt_mesh_k1>
	if (!err) {
   16024:	2800      	cmp	r0, #0
   16026:	f040 808b 	bne.w	16140 <prov_data+0x170>
		memcpy(nonce, tmp + 3, 13);
   1602a:	220d      	movs	r2, #13
   1602c:	f10d 015f 	add.w	r1, sp, #95	; 0x5f
   16030:	a80b      	add	r0, sp, #44	; 0x2c
   16032:	f00f fe39 	bl	25ca8 <memcpy>
	err = bt_mesh_prov_decrypt(session_key, nonce, data, pdu);
   16036:	4633      	mov	r3, r6
   16038:	462a      	mov	r2, r5
   1603a:	a90b      	add	r1, sp, #44	; 0x2c
   1603c:	4638      	mov	r0, r7
   1603e:	f011 fb52 	bl	276e6 <bt_mesh_prov_decrypt>
	if (err) {
   16042:	b168      	cbz	r0, 16060 <prov_data+0x90>
   16044:	4b46      	ldr	r3, [pc, #280]	; (16160 <prov_data+0x190>)
   16046:	4945      	ldr	r1, [pc, #276]	; (1615c <prov_data+0x18c>)
		BT_ERR("Unable to decrypt provisioning data");
   16048:	4848      	ldr	r0, [pc, #288]	; (1616c <prov_data+0x19c>)
   1604a:	1ac9      	subs	r1, r1, r3
   1604c:	08c9      	lsrs	r1, r1, #3
   1604e:	0189      	lsls	r1, r1, #6
   16050:	f041 0101 	orr.w	r1, r1, #1
   16054:	f00d ffb6 	bl	23fc4 <log_0>
		prov_fail(PROV_ERR_DECRYPT);
   16058:	2006      	movs	r0, #6
		prov_fail(PROV_ERR_UNEXP_ERR);
   1605a:	f7ff fda3 	bl	15ba4 <prov_fail>
		return;
   1605e:	e03d      	b.n	160dc <prov_data+0x10c>

static inline int bt_mesh_dev_key(const u8_t dhkey[32],
				  const u8_t prov_salt[16],
				  u8_t dev_key[16])
{
	return bt_mesh_k1(dhkey, 32, prov_salt, "prdk", dev_key);
   16060:	ab13      	add	r3, sp, #76	; 0x4c
   16062:	9300      	str	r3, [sp, #0]
   16064:	f204 1209 	addw	r2, r4, #265	; 0x109
   16068:	4b41      	ldr	r3, [pc, #260]	; (16170 <prov_data+0x1a0>)
   1606a:	2120      	movs	r1, #32
   1606c:	1d20      	adds	r0, r4, #4
   1606e:	f011 f9d4 	bl	2741a <bt_mesh_k1>
	if (err) {
   16072:	b140      	cbz	r0, 16086 <prov_data+0xb6>
   16074:	4939      	ldr	r1, [pc, #228]	; (1615c <prov_data+0x18c>)
   16076:	4b3a      	ldr	r3, [pc, #232]	; (16160 <prov_data+0x190>)
		BT_ERR("Unable to generate device key");
   16078:	483e      	ldr	r0, [pc, #248]	; (16174 <prov_data+0x1a4>)
   1607a:	1ac9      	subs	r1, r1, r3
   1607c:	08c9      	lsrs	r1, r1, #3
   1607e:	0189      	lsls	r1, r1, #6
   16080:	f041 0101 	orr.w	r1, r1, #1
   16084:	e7c1      	b.n	1600a <prov_data+0x3a>
	return ((u16_t)src[0] << 8) | src[1];
   16086:	f89d 306f 	ldrb.w	r3, [sp, #111]	; 0x6f
   1608a:	9305      	str	r3, [sp, #20]
   1608c:	f89d 3073 	ldrb.w	r3, [sp, #115]	; 0x73
   16090:	f89d 2071 	ldrb.w	r2, [sp, #113]	; 0x71
   16094:	9303      	str	r3, [sp, #12]
	prov_buf_init(&msg, PROV_COMPLETE);
   16096:	2108      	movs	r1, #8
   16098:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
   1609c:	9204      	str	r2, [sp, #16]
   1609e:	a808      	add	r0, sp, #32
   160a0:	9302      	str	r3, [sp, #8]
   160a2:	f89d a06c 	ldrb.w	sl, [sp, #108]	; 0x6c
   160a6:	f89d 906d 	ldrb.w	r9, [sp, #109]	; 0x6d
	flags = pdu[18];
   160aa:	f89d b06e 	ldrb.w	fp, [sp, #110]	; 0x6e
   160ae:	f89d 8070 	ldrb.w	r8, [sp, #112]	; 0x70
   160b2:	f89d 7072 	ldrb.w	r7, [sp, #114]	; 0x72
	prov_buf_init(&msg, PROV_COMPLETE);
   160b6:	f011 fefa 	bl	27eae <prov_buf_init>
	if (prov_send(&msg, NULL)) {
   160ba:	a808      	add	r0, sp, #32
   160bc:	f7ff fc4c 	bl	15958 <prov_send.constprop.0>
   160c0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   160c4:	4605      	mov	r5, r0
   160c6:	b160      	cbz	r0, 160e2 <prov_data+0x112>
   160c8:	4924      	ldr	r1, [pc, #144]	; (1615c <prov_data+0x18c>)
   160ca:	4b25      	ldr	r3, [pc, #148]	; (16160 <prov_data+0x190>)
		BT_ERR("Failed to send Provisioning Complete");
   160cc:	482a      	ldr	r0, [pc, #168]	; (16178 <prov_data+0x1a8>)
   160ce:	1ac9      	subs	r1, r1, r3
   160d0:	08c9      	lsrs	r1, r1, #3
   160d2:	0189      	lsls	r1, r1, #6
   160d4:	f041 0101 	orr.w	r1, r1, #1
   160d8:	f00d ff74 	bl	23fc4 <log_0>
}
   160dc:	b01f      	add	sp, #124	; 0x7c
   160de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	link.expect = PROV_NO_PDU;
   160e2:	21ff      	movs	r1, #255	; 0xff
   160e4:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
	return link.bearer && link.bearer->type == BT_MESH_PROV_GATT;
   160e8:	f8d4 111c 	ldr.w	r1, [r4, #284]	; 0x11c
   160ec:	b119      	cbz	r1, 160f6 <prov_data+0x126>
   160ee:	780d      	ldrb	r5, [r1, #0]
   160f0:	1ea9      	subs	r1, r5, #2
   160f2:	424d      	negs	r5, r1
   160f4:	414d      	adcs	r5, r1
	return ((u32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
   160f6:	ea47 2702 	orr.w	r7, r7, r2, lsl #8
	err = bt_mesh_provision(pdu, net_idx, flags, iv_index, addr, dev_key);
   160fa:	aa13      	add	r2, sp, #76	; 0x4c
   160fc:	9201      	str	r2, [sp, #4]
   160fe:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
   16102:	ea48 2303 	orr.w	r3, r8, r3, lsl #8
   16106:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   1610a:	9200      	str	r2, [sp, #0]
   1610c:	ea49 210a 	orr.w	r1, r9, sl, lsl #8
   16110:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
   16114:	465a      	mov	r2, fp
   16116:	4630      	mov	r0, r6
   16118:	f7f5 fe60 	bl	bddc <bt_mesh_provision>
	if (err) {
   1611c:	4601      	mov	r1, r0
   1611e:	b150      	cbz	r0, 16136 <prov_data+0x166>
   16120:	4b0f      	ldr	r3, [pc, #60]	; (16160 <prov_data+0x190>)
   16122:	4a0e      	ldr	r2, [pc, #56]	; (1615c <prov_data+0x18c>)
		BT_ERR("Failed to provision (err %d)", err);
   16124:	4815      	ldr	r0, [pc, #84]	; (1617c <prov_data+0x1ac>)
   16126:	1ad2      	subs	r2, r2, r3
   16128:	08d2      	lsrs	r2, r2, #3
   1612a:	0192      	lsls	r2, r2, #6
   1612c:	f042 0201 	orr.w	r2, r2, #1
   16130:	f00d ff55 	bl	23fde <log_1>
		return;
   16134:	e7d2      	b.n	160dc <prov_data+0x10c>
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) && identity_enable) {
   16136:	2d00      	cmp	r5, #0
   16138:	d0d0      	beq.n	160dc <prov_data+0x10c>
		bt_mesh_proxy_identity_enable();
   1613a:	f001 fc7d 	bl	17a38 <bt_mesh_proxy_identity_enable>
   1613e:	e7cd      	b.n	160dc <prov_data+0x10c>
   16140:	4906      	ldr	r1, [pc, #24]	; (1615c <prov_data+0x18c>)
   16142:	4b07      	ldr	r3, [pc, #28]	; (16160 <prov_data+0x190>)
		BT_ERR("Unable to generate session nonce");
   16144:	480e      	ldr	r0, [pc, #56]	; (16180 <prov_data+0x1b0>)
   16146:	1ac9      	subs	r1, r1, r3
   16148:	08c9      	lsrs	r1, r1, #3
   1614a:	0189      	lsls	r1, r1, #6
   1614c:	f041 0101 	orr.w	r1, r1, #1
   16150:	e75b      	b.n	1600a <prov_data+0x3a>
   16152:	bf00      	nop
   16154:	20000b68 	.word	0x20000b68
   16158:	0002f785 	.word	0x0002f785
   1615c:	00029970 	.word	0x00029970
   16160:	00029830 	.word	0x00029830
   16164:	0002f78a 	.word	0x0002f78a
   16168:	0002f7a9 	.word	0x0002f7a9
   1616c:	0002f7ae 	.word	0x0002f7ae
   16170:	0002f7d2 	.word	0x0002f7d2
   16174:	0002f7d7 	.word	0x0002f7d7
   16178:	0002f7f5 	.word	0x0002f7f5
   1617c:	0002f81a 	.word	0x0002f81a
   16180:	0002f837 	.word	0x0002f837

00016184 <prov_random>:
{
   16184:	b510      	push	{r4, lr}
	if (bt_mesh_prov_conf(link.conf_key, data, link.auth, conf_verify)) {
   16186:	4a29      	ldr	r2, [pc, #164]	; (1622c <prov_random+0xa8>)
{
   16188:	b08e      	sub	sp, #56	; 0x38
   1618a:	4604      	mov	r4, r0
	if (bt_mesh_prov_conf(link.conf_key, data, link.auth, conf_verify)) {
   1618c:	4601      	mov	r1, r0
   1618e:	466b      	mov	r3, sp
   16190:	f102 0020 	add.w	r0, r2, #32
   16194:	f011 fa9a 	bl	276cc <bt_mesh_prov_conf>
   16198:	b158      	cbz	r0, 161b2 <prov_random+0x2e>
   1619a:	4925      	ldr	r1, [pc, #148]	; (16230 <prov_random+0xac>)
   1619c:	4b25      	ldr	r3, [pc, #148]	; (16234 <prov_random+0xb0>)
		BT_ERR("Unable to calculate confirmation verification");
   1619e:	4826      	ldr	r0, [pc, #152]	; (16238 <prov_random+0xb4>)
   161a0:	1ac9      	subs	r1, r1, r3
   161a2:	08c9      	lsrs	r1, r1, #3
   161a4:	0189      	lsls	r1, r1, #6
   161a6:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Failed to generate provisioning salt");
   161aa:	f00d ff0b 	bl	23fc4 <log_0>
		prov_fail(PROV_ERR_UNEXP_ERR);
   161ae:	2007      	movs	r0, #7
   161b0:	e010      	b.n	161d4 <prov_random+0x50>
	if (memcmp(conf_verify, link.conf, 16)) {
   161b2:	4922      	ldr	r1, [pc, #136]	; (1623c <prov_random+0xb8>)
   161b4:	2210      	movs	r2, #16
   161b6:	4668      	mov	r0, sp
   161b8:	f00f fd66 	bl	25c88 <memcmp>
   161bc:	b170      	cbz	r0, 161dc <prov_random+0x58>
   161be:	4b1d      	ldr	r3, [pc, #116]	; (16234 <prov_random+0xb0>)
   161c0:	491b      	ldr	r1, [pc, #108]	; (16230 <prov_random+0xac>)
		BT_ERR("Invalid confirmation value");
   161c2:	481f      	ldr	r0, [pc, #124]	; (16240 <prov_random+0xbc>)
   161c4:	1ac9      	subs	r1, r1, r3
   161c6:	08c9      	lsrs	r1, r1, #3
   161c8:	0189      	lsls	r1, r1, #6
   161ca:	f041 0101 	orr.w	r1, r1, #1
   161ce:	f00d fef9 	bl	23fc4 <log_0>
		prov_fail(PROV_ERR_CFM_FAILED);
   161d2:	2004      	movs	r0, #4
		prov_fail(PROV_ERR_UNEXP_ERR);
   161d4:	f7ff fce6 	bl	15ba4 <prov_fail>
}
   161d8:	b00e      	add	sp, #56	; 0x38
   161da:	bd10      	pop	{r4, pc}
   161dc:	f7ff fc5a 	bl	15a94 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   161e0:	0683      	lsls	r3, r0, #26
static inline int bt_mesh_prov_salt(const u8_t conf_salt[16],
				    const u8_t prov_rand[16],
				    const u8_t dev_rand[16],
				    u8_t prov_salt[16])
{
	const u8_t prov_salt_key[16] = { 0 };
   161e2:	f04f 0300 	mov.w	r3, #0
		prov_rand = data;
   161e6:	bf56      	itet	pl
   161e8:	4621      	movpl	r1, r4
		prov_rand = link.rand;
   161ea:	4916      	ldrmi	r1, [pc, #88]	; (16244 <prov_random+0xc0>)
		dev_rand = link.rand;
   161ec:	4c15      	ldrpl	r4, [pc, #84]	; (16244 <prov_random+0xc0>)
   161ee:	e9cd 3304 	strd	r3, r3, [sp, #16]
   161f2:	e9cd 3306 	strd	r3, r3, [sp, #24]
	struct bt_mesh_sg sg[] = {
   161f6:	4b14      	ldr	r3, [pc, #80]	; (16248 <prov_random+0xc4>)
   161f8:	9308      	str	r3, [sp, #32]
   161fa:	2210      	movs	r2, #16
   161fc:	e9cd 2109 	strd	r2, r1, [sp, #36]	; 0x24
   16200:	e9cd 240b 	strd	r2, r4, [sp, #44]	; 0x2c
   16204:	920d      	str	r2, [sp, #52]	; 0x34
		{ conf_salt, 16 },
		{ prov_rand, 16 },
		{ dev_rand, 16 },
	};

	return bt_mesh_aes_cmac(prov_salt_key, sg, ARRAY_SIZE(sg), prov_salt);
   16206:	33b1      	adds	r3, #177	; 0xb1
   16208:	2203      	movs	r2, #3
   1620a:	a908      	add	r1, sp, #32
   1620c:	a804      	add	r0, sp, #16
   1620e:	f011 f8c2 	bl	27396 <bt_mesh_aes_cmac>
	if (bt_mesh_prov_salt(link.conf_salt, prov_rand, dev_rand,
   16212:	b140      	cbz	r0, 16226 <prov_random+0xa2>
   16214:	4906      	ldr	r1, [pc, #24]	; (16230 <prov_random+0xac>)
   16216:	4b07      	ldr	r3, [pc, #28]	; (16234 <prov_random+0xb0>)
		BT_ERR("Failed to generate provisioning salt");
   16218:	480c      	ldr	r0, [pc, #48]	; (1624c <prov_random+0xc8>)
   1621a:	1ac9      	subs	r1, r1, r3
   1621c:	08c9      	lsrs	r1, r1, #3
   1621e:	0189      	lsls	r1, r1, #6
   16220:	f041 0101 	orr.w	r1, r1, #1
   16224:	e7c1      	b.n	161aa <prov_random+0x26>
		send_random();
   16226:	f7ff fc85 	bl	15b34 <send_random>
   1622a:	e7d5      	b.n	161d8 <prov_random+0x54>
   1622c:	20000bb0 	.word	0x20000bb0
   16230:	00029970 	.word	0x00029970
   16234:	00029830 	.word	0x00029830
   16238:	0002f858 	.word	0x0002f858
   1623c:	20000b90 	.word	0x20000b90
   16240:	0002f886 	.word	0x0002f886
   16244:	20000ba0 	.word	0x20000ba0
   16248:	20000bc0 	.word	0x20000bc0
   1624c:	0002f8a1 	.word	0x0002f8a1

00016250 <prov_start>:
{
   16250:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (data[0] != PROV_ALG_P256) {
   16254:	7801      	ldrb	r1, [r0, #0]
{
   16256:	b08c      	sub	sp, #48	; 0x30
   16258:	4606      	mov	r6, r0
	if (data[0] != PROV_ALG_P256) {
   1625a:	b169      	cbz	r1, 16278 <prov_start+0x28>
   1625c:	4a72      	ldr	r2, [pc, #456]	; (16428 <prov_start+0x1d8>)
   1625e:	4b73      	ldr	r3, [pc, #460]	; (1642c <prov_start+0x1dc>)
		BT_ERR("Unknown algorithm 0x%02x", data[0]);
   16260:	4873      	ldr	r0, [pc, #460]	; (16430 <prov_start+0x1e0>)
   16262:	1ad2      	subs	r2, r2, r3
   16264:	08d2      	lsrs	r2, r2, #3
   16266:	0192      	lsls	r2, r2, #6
   16268:	f042 0201 	orr.w	r2, r2, #1
		BT_ERR("Invalid public key type: 0x%02x", data[1]);
   1626c:	f00d feb7 	bl	23fde <log_1>
		prov_fail(PROV_ERR_NVAL_FMT);
   16270:	2002      	movs	r0, #2
   16272:	f7ff fc97 	bl	15ba4 <prov_fail>
   16276:	e024      	b.n	162c2 <prov_start+0x72>
	if (data[1] != PUB_KEY_NO_OOB) {
   16278:	7841      	ldrb	r1, [r0, #1]
   1627a:	b141      	cbz	r1, 1628e <prov_start+0x3e>
   1627c:	4a6a      	ldr	r2, [pc, #424]	; (16428 <prov_start+0x1d8>)
   1627e:	4b6b      	ldr	r3, [pc, #428]	; (1642c <prov_start+0x1dc>)
		BT_ERR("Invalid public key type: 0x%02x", data[1]);
   16280:	486c      	ldr	r0, [pc, #432]	; (16434 <prov_start+0x1e4>)
   16282:	1ad2      	subs	r2, r2, r3
   16284:	08d2      	lsrs	r2, r2, #3
   16286:	0192      	lsls	r2, r2, #6
   16288:	f042 0201 	orr.w	r2, r2, #1
   1628c:	e7ee      	b.n	1626c <prov_start+0x1c>
	memcpy(&link.conf_inputs[12], data, 5);
   1628e:	4d6a      	ldr	r5, [pc, #424]	; (16438 <prov_start+0x1e8>)
   16290:	4601      	mov	r1, r0
   16292:	2205      	movs	r2, #5
   16294:	f105 0084 	add.w	r0, r5, #132	; 0x84
   16298:	f00f fd06 	bl	25ca8 <memcpy>
	link.expect = PROV_PUB_KEY;
   1629c:	2303      	movs	r3, #3
   1629e:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
	if (prov_auth(data[2], data[3], data[4]) < 0) {
   162a2:	78b3      	ldrb	r3, [r6, #2]
   162a4:	78f1      	ldrb	r1, [r6, #3]
   162a6:	7934      	ldrb	r4, [r6, #4]
	switch (method) {
   162a8:	46a8      	mov	r8, r5
   162aa:	2b03      	cmp	r3, #3
   162ac:	d85c      	bhi.n	16368 <prov_start+0x118>
   162ae:	e8df f003 	tbb	[pc, r3]
   162b2:	0b02      	.short	0x0b02
   162b4:	a11e      	.short	0xa11e
		if (action || size) {
   162b6:	4321      	orrs	r1, r4
   162b8:	d156      	bne.n	16368 <prov_start+0x118>
		(void)memset(link.auth, 0, sizeof(link.auth));
   162ba:	4860      	ldr	r0, [pc, #384]	; (1643c <prov_start+0x1ec>)
   162bc:	2210      	movs	r2, #16
		(void)memset(link.auth, 0,
   162be:	f00f fd1e 	bl	25cfe <memset>
}
   162c2:	b00c      	add	sp, #48	; 0x30
   162c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (action || size) {
   162c8:	430c      	orrs	r4, r1
   162ca:	d14d      	bne.n	16368 <prov_start+0x118>
		memcpy(link.auth + 16 - prov->static_val_len,
   162cc:	4e5c      	ldr	r6, [pc, #368]	; (16440 <prov_start+0x1f0>)
   162ce:	4d5b      	ldr	r5, [pc, #364]	; (1643c <prov_start+0x1ec>)
   162d0:	6833      	ldr	r3, [r6, #0]
   162d2:	7c1a      	ldrb	r2, [r3, #16]
   162d4:	68d9      	ldr	r1, [r3, #12]
   162d6:	f1c2 0010 	rsb	r0, r2, #16
   162da:	4428      	add	r0, r5
   162dc:	f00f fce4 	bl	25ca8 <memcpy>
			     sizeof(link.auth) - prov->static_val_len);
   162e0:	6833      	ldr	r3, [r6, #0]
   162e2:	7c1a      	ldrb	r2, [r3, #16]
		(void)memset(link.auth, 0,
   162e4:	4621      	mov	r1, r4
   162e6:	f1c2 0210 	rsb	r2, r2, #16
   162ea:	4628      	mov	r0, r5
   162ec:	e7e7      	b.n	162be <prov_start+0x6e>
	switch (action) {
   162ee:	2904      	cmp	r1, #4
   162f0:	d83a      	bhi.n	16368 <prov_start+0x118>
   162f2:	4b54      	ldr	r3, [pc, #336]	; (16444 <prov_start+0x1f4>)
   162f4:	f813 9001 	ldrb.w	r9, [r3, r1]
		if (!output) {
   162f8:	f1b9 0f00 	cmp.w	r9, #0
   162fc:	d034      	beq.n	16368 <prov_start+0x118>
		if (!(prov->output_actions & output)) {
   162fe:	f8df a140 	ldr.w	sl, [pc, #320]	; 16440 <prov_start+0x1f0>
   16302:	f8da 3000 	ldr.w	r3, [sl]
   16306:	8a5a      	ldrh	r2, [r3, #18]
   16308:	ea12 0f09 	tst.w	r2, r9
   1630c:	4655      	mov	r5, sl
   1630e:	d02b      	beq.n	16368 <prov_start+0x118>
		if (size > prov->output_size) {
   16310:	7c5b      	ldrb	r3, [r3, #17]
   16312:	42a3      	cmp	r3, r4
   16314:	d328      	bcc.n	16368 <prov_start+0x118>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   16316:	4848      	ldr	r0, [pc, #288]	; (16438 <prov_start+0x1e8>)
   16318:	2110      	movs	r1, #16
   1631a:	f011 fdd4 	bl	27ec6 <atomic_or>
		if (output == BT_MESH_DISPLAY_STRING) {
   1631e:	f1b9 0f10 	cmp.w	r9, #16
   16322:	d141      	bne.n	163a8 <prov_start+0x158>
			bt_rand(str, size);
   16324:	4621      	mov	r1, r4
   16326:	a804      	add	r0, sp, #16
   16328:	f012 f833 	bl	28392 <bt_rand>
			for (i = 0U; i < size; i++) {
   1632c:	a904      	add	r1, sp, #16
   1632e:	2200      	movs	r2, #0
				str[i] %= 36;
   16330:	2024      	movs	r0, #36	; 0x24
			for (i = 0U; i < size; i++) {
   16332:	b2d3      	uxtb	r3, r2
   16334:	429c      	cmp	r4, r3
   16336:	d827      	bhi.n	16388 <prov_start+0x138>
			memcpy(link.auth, str, size);
   16338:	4f40      	ldr	r7, [pc, #256]	; (1643c <prov_start+0x1ec>)
			str[size] = '\0';
   1633a:	ab0c      	add	r3, sp, #48	; 0x30
   1633c:	4423      	add	r3, r4
   1633e:	f04f 0800 	mov.w	r8, #0
			memcpy(link.auth, str, size);
   16342:	4622      	mov	r2, r4
   16344:	a904      	add	r1, sp, #16
   16346:	4638      	mov	r0, r7
			str[size] = '\0';
   16348:	f803 8c20 	strb.w	r8, [r3, #-32]
			memcpy(link.auth, str, size);
   1634c:	f00f fcac 	bl	25ca8 <memcpy>
			(void)memset(link.auth + size, 0,
   16350:	f1c4 0210 	rsb	r2, r4, #16
   16354:	4641      	mov	r1, r8
   16356:	1938      	adds	r0, r7, r4
   16358:	f00f fcd1 	bl	25cfe <memset>
			return prov->output_string((char *)str);
   1635c:	682b      	ldr	r3, [r5, #0]
   1635e:	a804      	add	r0, sp, #16
   16360:	69db      	ldr	r3, [r3, #28]
   16362:	4798      	blx	r3
	if (prov_auth(data[2], data[3], data[4]) < 0) {
   16364:	2800      	cmp	r0, #0
   16366:	daac      	bge.n	162c2 <prov_start+0x72>
   16368:	4a30      	ldr	r2, [pc, #192]	; (1642c <prov_start+0x1dc>)
   1636a:	4b2f      	ldr	r3, [pc, #188]	; (16428 <prov_start+0x1d8>)
		BT_ERR("Invalid authentication method: 0x%02x; "
   1636c:	4836      	ldr	r0, [pc, #216]	; (16448 <prov_start+0x1f8>)
   1636e:	1a9b      	subs	r3, r3, r2
   16370:	08db      	lsrs	r3, r3, #3
   16372:	019b      	lsls	r3, r3, #6
   16374:	f043 0301 	orr.w	r3, r3, #1
   16378:	f8ad 3000 	strh.w	r3, [sp]
   1637c:	7933      	ldrb	r3, [r6, #4]
   1637e:	78f2      	ldrb	r2, [r6, #3]
   16380:	78b1      	ldrb	r1, [r6, #2]
   16382:	f00d fe59 	bl	24038 <log_3>
   16386:	e773      	b.n	16270 <prov_start+0x20>
				str[i] %= 36;
   16388:	780f      	ldrb	r7, [r1, #0]
   1638a:	fbb7 f3f0 	udiv	r3, r7, r0
   1638e:	fb00 7313 	mls	r3, r0, r3, r7
   16392:	b2df      	uxtb	r7, r3
				if (str[i] < 10) {
   16394:	2f09      	cmp	r7, #9
					str[i] += '0';
   16396:	b25b      	sxtb	r3, r3
   16398:	bf94      	ite	ls
   1639a:	3330      	addls	r3, #48	; 0x30
					str[i] += 'A' - 10;
   1639c:	3337      	addhi	r3, #55	; 0x37
   1639e:	b2db      	uxtb	r3, r3
   163a0:	f801 3b01 	strb.w	r3, [r1], #1
			for (i = 0U; i < size; i++) {
   163a4:	3201      	adds	r2, #1
   163a6:	e7c4      	b.n	16332 <prov_start+0xe2>
			u32_t div[8] = { 10, 100, 1000, 10000, 100000,
   163a8:	4f28      	ldr	r7, [pc, #160]	; (1644c <prov_start+0x1fc>)
   163aa:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   163ac:	ad04      	add	r5, sp, #16
   163ae:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   163b0:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
   163b4:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
			bt_rand(&num, sizeof(num));
   163b8:	2104      	movs	r1, #4
   163ba:	a803      	add	r0, sp, #12
   163bc:	f011 ffe9 	bl	28392 <bt_rand>
			num %= div[size - 1];
   163c0:	ab0c      	add	r3, sp, #48	; 0x30
   163c2:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   163c6:	9803      	ldr	r0, [sp, #12]
   163c8:	f854 2c24 	ldr.w	r2, [r4, #-36]
   163cc:	fbb0 f3f2 	udiv	r3, r0, r2
   163d0:	fb02 0313 	mls	r3, r2, r3, r0
   163d4:	9303      	str	r3, [sp, #12]
	dst[1] = val;
   163d6:	ba1b      	rev	r3, r3
	dst[0] = val >> 8;
   163d8:	f8c8 3054 	str.w	r3, [r8, #84]	; 0x54
			(void)memset(link.auth, 0, 12);
   163dc:	220c      	movs	r2, #12
   163de:	2100      	movs	r1, #0
   163e0:	4816      	ldr	r0, [pc, #88]	; (1643c <prov_start+0x1ec>)
   163e2:	f00f fc8c 	bl	25cfe <memset>
			return prov->output_number(output, num);
   163e6:	f8da 3000 	ldr.w	r3, [sl]
   163ea:	9903      	ldr	r1, [sp, #12]
   163ec:	699b      	ldr	r3, [r3, #24]
   163ee:	4648      	mov	r0, r9
   163f0:	4798      	blx	r3
   163f2:	e7b7      	b.n	16364 <prov_start+0x114>
	switch (action) {
   163f4:	2903      	cmp	r1, #3
   163f6:	d8b7      	bhi.n	16368 <prov_start+0x118>
   163f8:	4b15      	ldr	r3, [pc, #84]	; (16450 <prov_start+0x200>)
   163fa:	5c5d      	ldrb	r5, [r3, r1]
		if (!input) {
   163fc:	2d00      	cmp	r5, #0
   163fe:	d0b3      	beq.n	16368 <prov_start+0x118>
		if (!(prov->input_actions & input)) {
   16400:	4b0f      	ldr	r3, [pc, #60]	; (16440 <prov_start+0x1f0>)
   16402:	681f      	ldr	r7, [r3, #0]
   16404:	8afb      	ldrh	r3, [r7, #22]
   16406:	422b      	tst	r3, r5
   16408:	d0ae      	beq.n	16368 <prov_start+0x118>
		if (size > prov->input_size) {
   1640a:	7d3b      	ldrb	r3, [r7, #20]
   1640c:	42a3      	cmp	r3, r4
   1640e:	d3ab      	bcc.n	16368 <prov_start+0x118>
		if (input == BT_MESH_ENTER_STRING) {
   16410:	2d08      	cmp	r5, #8
   16412:	bf0c      	ite	eq
   16414:	4629      	moveq	r1, r5
   16416:	2104      	movne	r1, #4
   16418:	4807      	ldr	r0, [pc, #28]	; (16438 <prov_start+0x1e8>)
   1641a:	f011 fd54 	bl	27ec6 <atomic_or>
		return prov->input(input, size);
   1641e:	6a3b      	ldr	r3, [r7, #32]
   16420:	4621      	mov	r1, r4
   16422:	4628      	mov	r0, r5
   16424:	4798      	blx	r3
   16426:	e79d      	b.n	16364 <prov_start+0x114>
   16428:	00029970 	.word	0x00029970
   1642c:	00029830 	.word	0x00029830
   16430:	0002f8c6 	.word	0x0002f8c6
   16434:	0002f8df 	.word	0x0002f8df
   16438:	20000b68 	.word	0x20000b68
   1643c:	20000bb0 	.word	0x20000bb0
   16440:	20000c88 	.word	0x20000c88
   16444:	0002f99a 	.word	0x0002f99a
   16448:	0002f8ff 	.word	0x0002f8ff
   1644c:	00029a74 	.word	0x00029a74
   16450:	0002f99f 	.word	0x0002f99f

00016454 <pub_key_ready>:
{
   16454:	b508      	push	{r3, lr}
	if (!pkey) {
   16456:	b958      	cbnz	r0, 16470 <pub_key_ready+0x1c>
   16458:	4b13      	ldr	r3, [pc, #76]	; (164a8 <pub_key_ready+0x54>)
   1645a:	4914      	ldr	r1, [pc, #80]	; (164ac <pub_key_ready+0x58>)
		BT_WARN("Public key not available");
   1645c:	4814      	ldr	r0, [pc, #80]	; (164b0 <pub_key_ready+0x5c>)
   1645e:	1ac9      	subs	r1, r1, r3
   16460:	08c9      	lsrs	r1, r1, #3
   16462:	0189      	lsls	r1, r1, #6
}
   16464:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		BT_WARN("Public key not available");
   16468:	f041 0102 	orr.w	r1, r1, #2
   1646c:	f00d bdaa 	b.w	23fc4 <log_0>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   16470:	4b10      	ldr	r3, [pc, #64]	; (164b4 <pub_key_ready+0x60>)
   16472:	f3bf 8f5b 	dmb	ish
   16476:	e853 2f00 	ldrex	r2, [r3]
   1647a:	f022 0101 	bic.w	r1, r2, #1
   1647e:	e843 1000 	strex	r0, r1, [r3]
   16482:	2800      	cmp	r0, #0
   16484:	d1f7      	bne.n	16476 <pub_key_ready+0x22>
   16486:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(link.flags, WAIT_PUB_KEY)) {
   1648a:	07d2      	lsls	r2, r2, #31
   1648c:	d50b      	bpl.n	164a6 <pub_key_ready+0x52>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   1648e:	f7ff fb01 	bl	15a94 <atomic_get.constprop.0>
		if (atomic_test_bit(link.flags, PROVISIONER)) {
   16492:	0683      	lsls	r3, r0, #26
   16494:	d503      	bpl.n	1649e <pub_key_ready+0x4a>
}
   16496:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			send_pub_key();
   1649a:	f7ff bc11 	b.w	15cc0 <send_pub_key>
}
   1649e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			prov_dh_key_gen();
   164a2:	f7ff bc7b 	b.w	15d9c <prov_dh_key_gen>
}
   164a6:	bd08      	pop	{r3, pc}
   164a8:	00029830 	.word	0x00029830
   164ac:	00029970 	.word	0x00029970
   164b0:	0002f943 	.word	0x0002f943
   164b4:	20000b68 	.word	0x20000b68

000164b8 <notify_input_complete>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   164b8:	4b0a      	ldr	r3, [pc, #40]	; (164e4 <notify_input_complete+0x2c>)
   164ba:	f3bf 8f5b 	dmb	ish
   164be:	e853 2f00 	ldrex	r2, [r3]
   164c2:	f022 0110 	bic.w	r1, r2, #16
   164c6:	e843 1000 	strex	r0, r1, [r3]
   164ca:	2800      	cmp	r0, #0
   164cc:	d1f7      	bne.n	164be <notify_input_complete+0x6>
   164ce:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(link.flags, NOTIFY_INPUT_COMPLETE) &&
   164d2:	06d3      	lsls	r3, r2, #27
   164d4:	d504      	bpl.n	164e0 <notify_input_complete+0x28>
	    prov->input_complete) {
   164d6:	4b04      	ldr	r3, [pc, #16]	; (164e8 <notify_input_complete+0x30>)
   164d8:	681b      	ldr	r3, [r3, #0]
   164da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	if (atomic_test_and_clear_bit(link.flags, NOTIFY_INPUT_COMPLETE) &&
   164dc:	b103      	cbz	r3, 164e0 <notify_input_complete+0x28>
		prov->input_complete();
   164de:	4718      	bx	r3
}
   164e0:	4770      	bx	lr
   164e2:	bf00      	nop
   164e4:	20000b68 	.word	0x20000b68
   164e8:	20000c88 	.word	0x20000c88

000164ec <prov_confirm>:
{
   164ec:	b508      	push	{r3, lr}
   164ee:	4601      	mov	r1, r0
	memcpy(link.conf, data, 16);
   164f0:	2210      	movs	r2, #16
   164f2:	4808      	ldr	r0, [pc, #32]	; (16514 <prov_confirm+0x28>)
   164f4:	f00f fbd8 	bl	25ca8 <memcpy>
	notify_input_complete();
   164f8:	f7ff ffde 	bl	164b8 <notify_input_complete>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   164fc:	f7ff faca 	bl	15a94 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   16500:	0683      	lsls	r3, r0, #26
   16502:	d503      	bpl.n	1650c <prov_confirm+0x20>
}
   16504:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		send_random();
   16508:	f7ff bb14 	b.w	15b34 <send_random>
}
   1650c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		send_confirm();
   16510:	f7ff bcb0 	b.w	15e74 <send_confirm>
   16514:	20000b90 	.word	0x20000b90

00016518 <bt_mesh_prov_get>:
#endif

const struct bt_mesh_prov *bt_mesh_prov_get(void)
{
	return prov;
}
   16518:	4b01      	ldr	r3, [pc, #4]	; (16520 <bt_mesh_prov_get+0x8>)
   1651a:	6818      	ldr	r0, [r3, #0]
   1651c:	4770      	bx	lr
   1651e:	bf00      	nop
   16520:	20000c88 	.word	0x20000c88

00016524 <bt_mesh_prov_init>:
{
	return atomic_test_bit(link.flags, LINK_ACTIVE);
}

int bt_mesh_prov_init(const struct bt_mesh_prov *prov_info)
{
   16524:	b508      	push	{r3, lr}
	if (!prov_info) {
   16526:	b148      	cbz	r0, 1653c <bt_mesh_prov_init+0x18>
		BT_ERR("No provisioning context provided");
		return -EINVAL;
	}

	prov = prov_info;
   16528:	4b0b      	ldr	r3, [pc, #44]	; (16558 <bt_mesh_prov_init+0x34>)
   1652a:	6018      	str	r0, [r3, #0]

	if (IS_ENABLED(CONFIG_BT_MESH_PB_ADV)) {
		pb_adv_init();
   1652c:	f000 fdfa 	bl	17124 <pb_adv_init>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_PB_GATT)) {
		pb_gatt_init();
   16530:	f000 fee4 	bl	172fc <pb_gatt_init>
	}

	return reset_state();
}
   16534:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return reset_state();
   16538:	f7ff b9bc 	b.w	158b4 <reset_state>
   1653c:	4b07      	ldr	r3, [pc, #28]	; (1655c <bt_mesh_prov_init+0x38>)
   1653e:	4908      	ldr	r1, [pc, #32]	; (16560 <bt_mesh_prov_init+0x3c>)
		BT_ERR("No provisioning context provided");
   16540:	4808      	ldr	r0, [pc, #32]	; (16564 <bt_mesh_prov_init+0x40>)
   16542:	1ac9      	subs	r1, r1, r3
   16544:	08c9      	lsrs	r1, r1, #3
   16546:	0189      	lsls	r1, r1, #6
   16548:	f041 0101 	orr.w	r1, r1, #1
   1654c:	f00d fd3a 	bl	23fc4 <log_0>
}
   16550:	f06f 0015 	mvn.w	r0, #21
   16554:	bd08      	pop	{r3, pc}
   16556:	bf00      	nop
   16558:	20000c88 	.word	0x20000c88
   1655c:	00029830 	.word	0x00029830
   16560:	00029970 	.word	0x00029970
   16564:	0002f95c 	.word	0x0002f95c

00016568 <bt_mesh_prov_enable>:

int bt_mesh_prov_enable(bt_mesh_prov_bearer_t bearers)
{
   16568:	b570      	push	{r4, r5, r6, lr}
   1656a:	b086      	sub	sp, #24
   1656c:	4604      	mov	r4, r0
	if (bt_mesh_is_provisioned()) {
   1656e:	f7f5 fc1d 	bl	bdac <bt_mesh_is_provisioned>
   16572:	4606      	mov	r6, r0
   16574:	2800      	cmp	r0, #0
   16576:	d132      	bne.n	165de <bt_mesh_prov_enable+0x76>
	return prov;
   16578:	4b1a      	ldr	r3, [pc, #104]	; (165e4 <bt_mesh_prov_enable+0x7c>)
		return -EALREADY;
	}

	if (IS_ENABLED(CONFIG_BT_DEBUG)) {
		const struct bt_mesh_prov *prov = bt_mesh_prov_get();
		struct bt_uuid_128 uuid = { .uuid = { BT_UUID_TYPE_128 } };
   1657a:	4601      	mov	r1, r0
   1657c:	2211      	movs	r2, #17
   1657e:	a801      	add	r0, sp, #4
	return prov;
   16580:	681d      	ldr	r5, [r3, #0]
		struct bt_uuid_128 uuid = { .uuid = { BT_UUID_TYPE_128 } };
   16582:	f00f fbbc 	bl	25cfe <memset>
   16586:	2302      	movs	r3, #2
   16588:	f88d 3004 	strb.w	r3, [sp, #4]

		memcpy(uuid.val, prov->uuid, 16);
   1658c:	6829      	ldr	r1, [r5, #0]
   1658e:	4d16      	ldr	r5, [pc, #88]	; (165e8 <bt_mesh_prov_enable+0x80>)
   16590:	2210      	movs	r2, #16
   16592:	f10d 0005 	add.w	r0, sp, #5
   16596:	f00f fb87 	bl	25ca8 <memcpy>
   1659a:	4a14      	ldr	r2, [pc, #80]	; (165ec <bt_mesh_prov_enable+0x84>)
		BT_INFO("Device UUID: %s", bt_uuid_str(&uuid.uuid));
   1659c:	a801      	add	r0, sp, #4
   1659e:	1aad      	subs	r5, r5, r2
   165a0:	f7ef fd10 	bl	5fc4 <bt_uuid_str_real>
   165a4:	f7ec f81c 	bl	25e0 <log_strdup>
   165a8:	08ed      	lsrs	r5, r5, #3
   165aa:	01ad      	lsls	r5, r5, #6
   165ac:	f045 0503 	orr.w	r5, r5, #3
   165b0:	4601      	mov	r1, r0
   165b2:	462a      	mov	r2, r5
   165b4:	480e      	ldr	r0, [pc, #56]	; (165f0 <bt_mesh_prov_enable+0x88>)
   165b6:	f00d fd12 	bl	23fde <log_1>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_PB_ADV) &&
   165ba:	07e3      	lsls	r3, r4, #31
   165bc:	d504      	bpl.n	165c8 <bt_mesh_prov_enable+0x60>
	    (bearers & BT_MESH_PROV_ADV)) {
		pb_adv.link_accept(&prov_bearer_cb, NULL);
   165be:	4b0d      	ldr	r3, [pc, #52]	; (165f4 <bt_mesh_prov_enable+0x8c>)
   165c0:	480d      	ldr	r0, [pc, #52]	; (165f8 <bt_mesh_prov_enable+0x90>)
   165c2:	685b      	ldr	r3, [r3, #4]
   165c4:	4631      	mov	r1, r6
   165c6:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_BT_MESH_PB_GATT) &&
   165c8:	f014 0002 	ands.w	r0, r4, #2
   165cc:	d005      	beq.n	165da <bt_mesh_prov_enable+0x72>
	    (bearers & BT_MESH_PROV_GATT)) {
		pb_gatt.link_accept(&prov_bearer_cb, NULL);
   165ce:	4b0b      	ldr	r3, [pc, #44]	; (165fc <bt_mesh_prov_enable+0x94>)
   165d0:	4809      	ldr	r0, [pc, #36]	; (165f8 <bt_mesh_prov_enable+0x90>)
   165d2:	685b      	ldr	r3, [r3, #4]
   165d4:	2100      	movs	r1, #0
   165d6:	4798      	blx	r3
	}

	return 0;
   165d8:	2000      	movs	r0, #0
}
   165da:	b006      	add	sp, #24
   165dc:	bd70      	pop	{r4, r5, r6, pc}
		return -EALREADY;
   165de:	f06f 0044 	mvn.w	r0, #68	; 0x44
   165e2:	e7fa      	b.n	165da <bt_mesh_prov_enable+0x72>
   165e4:	20000c88 	.word	0x20000c88
   165e8:	00029970 	.word	0x00029970
   165ec:	00029830 	.word	0x00029830
   165f0:	0002f97d 	.word	0x0002f97d
   165f4:	0002a3fc 	.word	0x0002a3fc
   165f8:	0002a374 	.word	0x0002a374
   165fc:	0002a414 	.word	0x0002a414

00016600 <bt_mesh_prov_complete>:
	return 0;
}

void bt_mesh_prov_complete(u16_t net_idx, u16_t addr)
{
	if (prov->complete) {
   16600:	4b02      	ldr	r3, [pc, #8]	; (1660c <bt_mesh_prov_complete+0xc>)
   16602:	681b      	ldr	r3, [r3, #0]
   16604:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   16606:	b103      	cbz	r3, 1660a <bt_mesh_prov_complete+0xa>
		prov->complete(net_idx, addr);
   16608:	4718      	bx	r3
	}
}
   1660a:	4770      	bx	lr
   1660c:	20000c88 	.word	0x20000c88

00016610 <bt_mesh_prov_reset>:

void bt_mesh_prov_reset(void)
{
	if (prov->reset) {
   16610:	4b02      	ldr	r3, [pc, #8]	; (1661c <bt_mesh_prov_reset+0xc>)
   16612:	681b      	ldr	r3, [r3, #0]
   16614:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   16616:	b103      	cbz	r3, 1661a <bt_mesh_prov_reset+0xa>
		prov->reset();
   16618:	4718      	bx	r3
	}
}
   1661a:	4770      	bx	lr
   1661c:	20000c88 	.word	0x20000c88

00016620 <free_segments>:

	return 1 + (len / CONT_PAYLOAD_MAX);
}

static void free_segments(void)
{
   16620:	b570      	push	{r4, r5, r6, lr}
	int i;

	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   16622:	2400      	movs	r4, #0
   16624:	4d08      	ldr	r5, [pc, #32]	; (16648 <free_segments+0x28>)

		if (!buf) {
			break;
		}

		link.tx.buf[i] = NULL;
   16626:	4626      	mov	r6, r4
		struct net_buf *buf = link.tx.buf[i];
   16628:	f855 0b04 	ldr.w	r0, [r5], #4
		if (!buf) {
   1662c:	b158      	cbz	r0, 16646 <free_segments+0x26>
		/* Mark as canceled */
		BT_MESH_ADV(buf)->busy = 0U;
   1662e:	6943      	ldr	r3, [r0, #20]
		link.tx.buf[i] = NULL;
   16630:	f845 6c04 	str.w	r6, [r5, #-4]
		BT_MESH_ADV(buf)->busy = 0U;
   16634:	7a1a      	ldrb	r2, [r3, #8]
   16636:	f366 0282 	bfi	r2, r6, #2, #1
   1663a:	721a      	strb	r2, [r3, #8]
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   1663c:	3401      	adds	r4, #1
		net_buf_unref(buf);
   1663e:	f008 fd43 	bl	1f0c8 <net_buf_unref>
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   16642:	2c03      	cmp	r4, #3
   16644:	d1f0      	bne.n	16628 <free_segments+0x8>
	}
}
   16646:	bd70      	pop	{r4, r5, r6, pc}
   16648:	2000699c 	.word	0x2000699c

0001664c <prov_clear_tx>:
{
	return (((id + 1) & 0x7f) | (id & 0x80));
}

static void prov_clear_tx(void)
{
   1664c:	b508      	push	{r3, lr}
	BT_DBG("");

	k_delayed_work_cancel(&link.tx.retransmit);
   1664e:	4803      	ldr	r0, [pc, #12]	; (1665c <prov_clear_tx+0x10>)
   16650:	f00c fb16 	bl	22c80 <k_delayed_work_cancel>

	free_segments();
}
   16654:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	free_segments();
   16658:	f7ff bfe2 	b.w	16620 <free_segments>
   1665c:	200069b0 	.word	0x200069b0

00016660 <close_link>:
	link.rx.buf = &rx_buf;
	net_buf_simple_reset(link.rx.buf);
}

static void close_link(enum prov_bearer_link_status reason)
{
   16660:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct prov_bearer_cb *cb = link.cb;
   16664:	4c0f      	ldr	r4, [pc, #60]	; (166a4 <close_link+0x44>)
{
   16666:	4605      	mov	r5, r0
	void *cb_data = link.cb_data;
   16668:	e9d4 7602 	ldrd	r7, r6, [r4, #8]
	prov_clear_tx();
   1666c:	f7ff ffee 	bl	1664c <prov_clear_tx>
	k_delayed_work_cancel(&link.prot_timer);
   16670:	f104 0058 	add.w	r0, r4, #88	; 0x58
   16674:	f00c fb04 	bl	22c80 <k_delayed_work_cancel>
	(void)memset(&link, 0, offsetof(struct pb_adv, tx.retransmit));
   16678:	2238      	movs	r2, #56	; 0x38
   1667a:	2100      	movs	r1, #0
   1667c:	4620      	mov	r0, r4
   1667e:	f00f fb3e 	bl	25cfe <memset>
	link.rx.id = XACT_NVAL;
   16682:	23ff      	movs	r3, #255	; 0xff
   16684:	7423      	strb	r3, [r4, #16]
	link.tx.pending_ack = XACT_NVAL;
   16686:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	link.rx.buf = &rx_buf;
   1668a:	4b07      	ldr	r3, [pc, #28]	; (166a8 <close_link+0x48>)
   1668c:	6163      	str	r3, [r4, #20]
	buf->len  = 0U;
   1668e:	2200      	movs	r2, #0
   16690:	809a      	strh	r2, [r3, #4]
	buf->data = buf->__buf;
   16692:	689a      	ldr	r2, [r3, #8]
   16694:	601a      	str	r2, [r3, #0]

	reset_adv_link();
	cb->link_closed(&pb_adv, cb_data, reason);
   16696:	4631      	mov	r1, r6
   16698:	687b      	ldr	r3, [r7, #4]
   1669a:	4804      	ldr	r0, [pc, #16]	; (166ac <close_link+0x4c>)
   1669c:	462a      	mov	r2, r5
}
   1669e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	cb->link_closed(&pb_adv, cb_data, reason);
   166a2:	4718      	bx	r3
   166a4:	20006978 	.word	0x20006978
   166a8:	20006f0c 	.word	0x20006f0c
   166ac:	0002a3fc 	.word	0x0002a3fc

000166b0 <protocol_timeout>:

static void protocol_timeout(struct k_work *work)
{
	BT_DBG("");

	link.rx.seg = 0U;
   166b0:	4b02      	ldr	r3, [pc, #8]	; (166bc <protocol_timeout+0xc>)
   166b2:	2200      	movs	r2, #0
	close_link(PROV_BEARER_LINK_STATUS_TIMEOUT);
   166b4:	2001      	movs	r0, #1
	link.rx.seg = 0U;
   166b6:	745a      	strb	r2, [r3, #17]
	close_link(PROV_BEARER_LINK_STATUS_TIMEOUT);
   166b8:	f7ff bfd2 	b.w	16660 <close_link>
   166bc:	20006978 	.word	0x20006978

000166c0 <adv_buf_create>:
{
   166c0:	b510      	push	{r4, lr}
	buf = bt_mesh_adv_create(BT_MESH_ADV_PROV,
   166c2:	f040 0108 	orr.w	r1, r0, #8
   166c6:	f44f 72c8 	mov.w	r2, #400	; 0x190
   166ca:	2000      	movs	r0, #0
   166cc:	f7f5 fd3c 	bl	c148 <bt_mesh_adv_create>
	if (!buf) {
   166d0:	4604      	mov	r4, r0
   166d2:	b948      	cbnz	r0, 166e8 <adv_buf_create+0x28>
   166d4:	4905      	ldr	r1, [pc, #20]	; (166ec <adv_buf_create+0x2c>)
   166d6:	4b06      	ldr	r3, [pc, #24]	; (166f0 <adv_buf_create+0x30>)
		BT_ERR("Out of provisioning buffers");
   166d8:	4806      	ldr	r0, [pc, #24]	; (166f4 <adv_buf_create+0x34>)
   166da:	1ac9      	subs	r1, r1, r3
   166dc:	08c9      	lsrs	r1, r1, #3
   166de:	0189      	lsls	r1, r1, #6
   166e0:	f041 0101 	orr.w	r1, r1, #1
   166e4:	f00d fc6e 	bl	23fc4 <log_0>
}
   166e8:	4620      	mov	r0, r4
   166ea:	bd10      	pop	{r4, pc}
   166ec:	00029960 	.word	0x00029960
   166f0:	00029830 	.word	0x00029830
   166f4:	0002f9a3 	.word	0x0002f9a3

000166f8 <ack_complete>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   166f8:	4b06      	ldr	r3, [pc, #24]	; (16714 <ack_complete+0x1c>)
   166fa:	f3bf 8f5b 	dmb	ish
   166fe:	e853 2f00 	ldrex	r2, [r3]
   16702:	f022 0210 	bic.w	r2, r2, #16
   16706:	e843 2100 	strex	r1, r2, [r3]
   1670a:	2900      	cmp	r1, #0
   1670c:	d1f7      	bne.n	166fe <ack_complete+0x6>
   1670e:	f3bf 8f5b 	dmb	ish
}
   16712:	4770      	bx	lr
   16714:	2000697c 	.word	0x2000697c

00016718 <atomic_get.constprop.0>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   16718:	4b03      	ldr	r3, [pc, #12]	; (16728 <atomic_get.constprop.0+0x10>)
   1671a:	f3bf 8f5b 	dmb	ish
   1671e:	6858      	ldr	r0, [r3, #4]
   16720:	f3bf 8f5b 	dmb	ish
}
   16724:	4770      	bx	lr
   16726:	bf00      	nop
   16728:	20006978 	.word	0x20006978

0001672c <prov_link_accept>:

	return 0;
}

static int prov_link_accept(const struct prov_bearer_cb *cb, void *cb_data)
{
   1672c:	b510      	push	{r4, lr}
   1672e:	4602      	mov	r2, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   16730:	f7ff fff2 	bl	16718 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, LINK_ACTIVE)) {
   16734:	f010 0401 	ands.w	r4, r0, #1
   16738:	d10d      	bne.n	16756 <prov_link_accept+0x2a>
		return -EBUSY;
	}

	link.rx.id = 0x7F;
   1673a:	4b08      	ldr	r3, [pc, #32]	; (1675c <prov_link_accept+0x30>)
   1673c:	207f      	movs	r0, #127	; 0x7f
   1673e:	7418      	strb	r0, [r3, #16]
	link.tx.id = 0xFF;
   16740:	20ff      	movs	r0, #255	; 0xff
	link.cb = cb;
	link.cb_data = cb_data;
   16742:	e9c3 2102 	strd	r2, r1, [r3, #8]
	link.tx.id = 0xFF;
   16746:	f883 0020 	strb.w	r0, [r3, #32]

	/* Make sure we're scanning for provisioning inviations */
	bt_mesh_scan_enable();
   1674a:	f7f5 fd43 	bl	c1d4 <bt_mesh_scan_enable>
	/* Enable unprovisioned beacon sending */
	bt_mesh_beacon_enable();
   1674e:	f7f6 f84b 	bl	c7e8 <bt_mesh_beacon_enable>

	return 0;
   16752:	4620      	mov	r0, r4
}
   16754:	bd10      	pop	{r4, pc}
		return -EBUSY;
   16756:	f06f 000f 	mvn.w	r0, #15
   1675a:	e7fb      	b.n	16754 <prov_link_accept+0x28>
   1675c:	20006978 	.word	0x20006978

00016760 <prov_retransmit>:
{
   16760:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16762:	f7ff ffd9 	bl	16718 <atomic_get.constprop.0>
	if (!atomic_test_bit(link.flags, LINK_ACTIVE)) {
   16766:	07c2      	lsls	r2, r0, #31
   16768:	d40b      	bmi.n	16782 <prov_retransmit+0x22>
   1676a:	4b2f      	ldr	r3, [pc, #188]	; (16828 <prov_retransmit+0xc8>)
   1676c:	492f      	ldr	r1, [pc, #188]	; (1682c <prov_retransmit+0xcc>)
		BT_WARN("Link not active");
   1676e:	4830      	ldr	r0, [pc, #192]	; (16830 <prov_retransmit+0xd0>)
   16770:	1ac9      	subs	r1, r1, r3
   16772:	08c9      	lsrs	r1, r1, #3
   16774:	0189      	lsls	r1, r1, #6
}
   16776:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		BT_WARN("Link not active");
   1677a:	f041 0102 	orr.w	r1, r1, #2
   1677e:	f00d bc21 	b.w	23fc4 <log_0>
   16782:	f7ff ffc9 	bl	16718 <atomic_get.constprop.0>
		timeout = TRANSACTION_TIMEOUT;
   16786:	f640 32b8 	movw	r2, #3000	; 0xbb8
   1678a:	f010 0f04 	tst.w	r0, #4
   1678e:	f247 5330 	movw	r3, #30000	; 0x7530
   16792:	bf14      	ite	ne
   16794:	4615      	movne	r5, r2
   16796:	461d      	moveq	r5, r3
   16798:	f012 fe3b 	bl	29412 <z_impl_k_uptime_ticks>
   1679c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   167a0:	460a      	mov	r2, r1
	if (k_uptime_get() - link.tx.start > timeout) {
   167a2:	4c24      	ldr	r4, [pc, #144]	; (16834 <prov_retransmit+0xd4>)
   167a4:	fba0 0103 	umull	r0, r1, r0, r3
   167a8:	fb03 1102 	mla	r1, r3, r2, r1
   167ac:	0bc3      	lsrs	r3, r0, #15
   167ae:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
   167b2:	0bca      	lsrs	r2, r1, #15
   167b4:	e9d4 1006 	ldrd	r1, r0, [r4, #24]
   167b8:	1a5e      	subs	r6, r3, r1
   167ba:	eb62 0700 	sbc.w	r7, r2, r0
   167be:	17eb      	asrs	r3, r5, #31
   167c0:	42b5      	cmp	r5, r6
   167c2:	41bb      	sbcs	r3, r7
   167c4:	da14      	bge.n	167f0 <prov_retransmit+0x90>
   167c6:	f7ff ffa7 	bl	16718 <atomic_get.constprop.0>
		if (atomic_test_bit(link.flags, LINK_CLOSING)) {
   167ca:	0743      	lsls	r3, r0, #29
   167cc:	d504      	bpl.n	167d8 <prov_retransmit+0x78>
			close_link(PROV_BEARER_LINK_STATUS_SUCCESS);
   167ce:	2000      	movs	r0, #0
}
   167d0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			close_link(PROV_BEARER_LINK_STATUS_TIMEOUT);
   167d4:	f7ff bf44 	b.w	16660 <close_link>
   167d8:	4b13      	ldr	r3, [pc, #76]	; (16828 <prov_retransmit+0xc8>)
   167da:	4914      	ldr	r1, [pc, #80]	; (1682c <prov_retransmit+0xcc>)
			BT_WARN("Giving up transaction");
   167dc:	4816      	ldr	r0, [pc, #88]	; (16838 <prov_retransmit+0xd8>)
   167de:	1ac9      	subs	r1, r1, r3
   167e0:	08c9      	lsrs	r1, r1, #3
   167e2:	0189      	lsls	r1, r1, #6
   167e4:	f041 0102 	orr.w	r1, r1, #2
   167e8:	f00d fbec 	bl	23fc4 <log_0>
			close_link(PROV_BEARER_LINK_STATUS_TIMEOUT);
   167ec:	2001      	movs	r0, #1
   167ee:	e7ef      	b.n	167d0 <prov_retransmit+0x70>
			bt_mesh_adv_send(buf, &buf_sent_cb, NULL);
   167f0:	4e12      	ldr	r6, [pc, #72]	; (1683c <prov_retransmit+0xdc>)
   167f2:	3424      	adds	r4, #36	; 0x24
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   167f4:	2500      	movs	r5, #0
		struct net_buf *buf = link.tx.buf[i];
   167f6:	f854 0b04 	ldr.w	r0, [r4], #4
		if (!buf) {
   167fa:	b1a0      	cbz	r0, 16826 <prov_retransmit+0xc6>
		if (BT_MESH_ADV(buf)->busy) {
   167fc:	6943      	ldr	r3, [r0, #20]
   167fe:	7a1a      	ldrb	r2, [r3, #8]
   16800:	f012 0204 	ands.w	r2, r2, #4
   16804:	f105 0501 	add.w	r5, r5, #1
   16808:	d10b      	bne.n	16822 <prov_retransmit+0xc2>
		if (i + 1 < ARRAY_SIZE(link.tx.buf) && link.tx.buf[i + 1]) {
   1680a:	2d03      	cmp	r5, #3
   1680c:	d005      	beq.n	1681a <prov_retransmit+0xba>
   1680e:	6823      	ldr	r3, [r4, #0]
   16810:	b11b      	cbz	r3, 1681a <prov_retransmit+0xba>
			bt_mesh_adv_send(buf, NULL, NULL);
   16812:	4611      	mov	r1, r2
   16814:	f7f5 fca8 	bl	c168 <bt_mesh_adv_send>
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   16818:	e7ed      	b.n	167f6 <prov_retransmit+0x96>
			bt_mesh_adv_send(buf, &buf_sent_cb, NULL);
   1681a:	2200      	movs	r2, #0
   1681c:	4631      	mov	r1, r6
   1681e:	f7f5 fca3 	bl	c168 <bt_mesh_adv_send>
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   16822:	2d03      	cmp	r5, #3
   16824:	d1e7      	bne.n	167f6 <prov_retransmit+0x96>
}
   16826:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   16828:	00029830 	.word	0x00029830
   1682c:	00029960 	.word	0x00029960
   16830:	0002f9bf 	.word	0x0002f9bf
   16834:	20006978 	.word	0x20006978
   16838:	0002f9cf 	.word	0x0002f9cf
   1683c:	20006f04 	.word	0x20006f04

00016840 <gen_prov_ack>:
{
   16840:	b510      	push	{r4, lr}
	if (!link.tx.buf[0]) {
   16842:	4c0b      	ldr	r4, [pc, #44]	; (16870 <gen_prov_ack+0x30>)
   16844:	6a63      	ldr	r3, [r4, #36]	; 0x24
   16846:	b18b      	cbz	r3, 1686c <gen_prov_ack+0x2c>
	if (rx->xact_id == link.tx.id) {
   16848:	7902      	ldrb	r2, [r0, #4]
   1684a:	f894 3020 	ldrb.w	r3, [r4, #32]
   1684e:	429a      	cmp	r2, r3
   16850:	d10c      	bne.n	1686c <gen_prov_ack+0x2c>
   16852:	f7ff ff61 	bl	16718 <atomic_get.constprop.0>
		if (!atomic_test_bit(link.flags, LINK_CLOSING)) {
   16856:	0743      	lsls	r3, r0, #29
   16858:	d401      	bmi.n	1685e <gen_prov_ack+0x1e>
			prov_clear_tx();
   1685a:	f7ff fef7 	bl	1664c <prov_clear_tx>
		if (link.tx.cb && link.tx.cb) {
   1685e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   16860:	b123      	cbz	r3, 1686c <gen_prov_ack+0x2c>
			link.tx.cb(0, link.tx.cb_data);
   16862:	6b61      	ldr	r1, [r4, #52]	; 0x34
   16864:	2000      	movs	r0, #0
}
   16866:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			link.tx.cb(0, link.tx.cb_data);
   1686a:	4718      	bx	r3
}
   1686c:	bd10      	pop	{r4, pc}
   1686e:	bf00      	nop
   16870:	20006978 	.word	0x20006978

00016874 <buf_sent>:
	if (!link.tx.buf[0]) {
   16874:	4904      	ldr	r1, [pc, #16]	; (16888 <buf_sent+0x14>)
   16876:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   16878:	b12b      	cbz	r3, 16886 <buf_sent+0x12>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   1687a:	4804      	ldr	r0, [pc, #16]	; (1688c <buf_sent+0x18>)
   1687c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   16880:	3138      	adds	r1, #56	; 0x38
   16882:	f00c b96d 	b.w	22b60 <k_delayed_work_submit_to_queue>
}
   16886:	4770      	bx	lr
   16888:	20006978 	.word	0x20006978
   1688c:	20001dc4 	.word	0x20001dc4

00016890 <prov_failed>:
{
   16890:	b510      	push	{r4, lr}
	link.cb->error(&pb_adv, link.cb_data, err);
   16892:	4c0a      	ldr	r4, [pc, #40]	; (168bc <prov_failed+0x2c>)
   16894:	68a3      	ldr	r3, [r4, #8]
   16896:	68e1      	ldr	r1, [r4, #12]
   16898:	689b      	ldr	r3, [r3, #8]
{
   1689a:	4602      	mov	r2, r0
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1689c:	3404      	adds	r4, #4
	link.cb->error(&pb_adv, link.cb_data, err);
   1689e:	4808      	ldr	r0, [pc, #32]	; (168c0 <prov_failed+0x30>)
   168a0:	4798      	blx	r3
   168a2:	f3bf 8f5b 	dmb	ish
   168a6:	e854 3f00 	ldrex	r3, [r4]
   168aa:	f043 0308 	orr.w	r3, r3, #8
   168ae:	e844 3200 	strex	r2, r3, [r4]
   168b2:	2a00      	cmp	r2, #0
   168b4:	d1f7      	bne.n	168a6 <prov_failed+0x16>
   168b6:	f3bf 8f5b 	dmb	ish
}
   168ba:	bd10      	pop	{r4, pc}
   168bc:	20006978 	.word	0x20006978
   168c0:	0002a3fc 	.word	0x0002a3fc

000168c4 <gen_prov_ack_send>:
{
   168c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   168c8:	4e25      	ldr	r6, [pc, #148]	; (16960 <gen_prov_ack_send+0x9c>)
   168ca:	f3bf 8f5b 	dmb	ish
   168ce:	4607      	mov	r7, r0
   168d0:	1d33      	adds	r3, r6, #4
   168d2:	e853 2f00 	ldrex	r2, [r3]
   168d6:	f042 0110 	orr.w	r1, r2, #16
   168da:	e843 1000 	strex	r0, r1, [r3]
   168de:	2800      	cmp	r0, #0
   168e0:	d1f7      	bne.n	168d2 <gen_prov_ack_send+0xe>
   168e2:	f3bf 8f5b 	dmb	ish
	if (pending && link.tx.pending_ack == xact_id) {
   168e6:	f012 0810 	ands.w	r8, r2, #16
   168ea:	461c      	mov	r4, r3
   168ec:	d003      	beq.n	168f6 <gen_prov_ack_send+0x32>
   168ee:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   168f2:	42bb      	cmp	r3, r7
   168f4:	d010      	beq.n	16918 <gen_prov_ack_send+0x54>
	buf = adv_buf_create(RETRANSMITS_ACK);
   168f6:	2002      	movs	r0, #2
   168f8:	f7ff fee2 	bl	166c0 <adv_buf_create>
	if (!buf) {
   168fc:	4605      	mov	r5, r0
   168fe:	b968      	cbnz	r0, 1691c <gen_prov_ack_send+0x58>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   16900:	f3bf 8f5b 	dmb	ish
   16904:	e854 3f00 	ldrex	r3, [r4]
   16908:	f023 0310 	bic.w	r3, r3, #16
   1690c:	e844 3200 	strex	r2, r3, [r4]
   16910:	2a00      	cmp	r2, #0
   16912:	d1f7      	bne.n	16904 <gen_prov_ack_send+0x40>
   16914:	f3bf 8f5b 	dmb	ish
}
   16918:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (pending) {
   1691c:	f1b8 0f00 	cmp.w	r8, #0
   16920:	d11b      	bne.n	1695a <gen_prov_ack_send+0x96>
		complete = &cb;
   16922:	f8df 8040 	ldr.w	r8, [pc, #64]	; 16964 <gen_prov_ack_send+0xa0>
		link.tx.pending_ack = xact_id;
   16926:	f886 7021 	strb.w	r7, [r6, #33]	; 0x21
	net_buf_add_be32(buf, link.id);
   1692a:	f105 0408 	add.w	r4, r5, #8
   1692e:	6831      	ldr	r1, [r6, #0]
   16930:	4620      	mov	r0, r4
   16932:	f012 fa71 	bl	28e18 <net_buf_simple_add_be32>
	net_buf_add_u8(buf, xact_id);
   16936:	4639      	mov	r1, r7
   16938:	4620      	mov	r0, r4
   1693a:	f012 fa48 	bl	28dce <net_buf_simple_add_u8>
	net_buf_add_u8(buf, GPC_ACK);
   1693e:	2101      	movs	r1, #1
   16940:	4620      	mov	r0, r4
   16942:	f012 fa44 	bl	28dce <net_buf_simple_add_u8>
	bt_mesh_adv_send(buf, complete, NULL);
   16946:	4628      	mov	r0, r5
   16948:	4641      	mov	r1, r8
   1694a:	2200      	movs	r2, #0
   1694c:	f7f5 fc0c 	bl	c168 <bt_mesh_adv_send>
	net_buf_unref(buf);
   16950:	4628      	mov	r0, r5
}
   16952:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	net_buf_unref(buf);
   16956:	f008 bbb7 	b.w	1f0c8 <net_buf_unref>
		complete = NULL;
   1695a:	f04f 0800 	mov.w	r8, #0
   1695e:	e7e4      	b.n	1692a <gen_prov_ack_send+0x66>
   16960:	20006978 	.word	0x20006978
   16964:	0002a3d4 	.word	0x0002a3d4

00016968 <prov_msg_recv>:
{
   16968:	b510      	push	{r4, lr}
   1696a:	4c1d      	ldr	r4, [pc, #116]	; (169e0 <prov_msg_recv+0x78>)
   1696c:	481d      	ldr	r0, [pc, #116]	; (169e4 <prov_msg_recv+0x7c>)
   1696e:	f104 0158 	add.w	r1, r4, #88	; 0x58
   16972:	f64e 2260 	movw	r2, #60000	; 0xea60
   16976:	f00c f8f3 	bl	22b60 <k_delayed_work_submit_to_queue>
	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
   1697a:	7ce1      	ldrb	r1, [r4, #19]
   1697c:	6960      	ldr	r0, [r4, #20]
   1697e:	f7f8 fe79 	bl	f674 <bt_mesh_fcs_check>
   16982:	b958      	cbnz	r0, 1699c <prov_msg_recv+0x34>
   16984:	4918      	ldr	r1, [pc, #96]	; (169e8 <prov_msg_recv+0x80>)
   16986:	4b19      	ldr	r3, [pc, #100]	; (169ec <prov_msg_recv+0x84>)
		BT_ERR("Incorrect FCS");
   16988:	4819      	ldr	r0, [pc, #100]	; (169f0 <prov_msg_recv+0x88>)
   1698a:	1ac9      	subs	r1, r1, r3
   1698c:	08c9      	lsrs	r1, r1, #3
   1698e:	0189      	lsls	r1, r1, #6
}
   16990:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_ERR("Incorrect FCS");
   16994:	f041 0101 	orr.w	r1, r1, #1
   16998:	f00d bb14 	b.w	23fc4 <log_0>
	gen_prov_ack_send(link.rx.id);
   1699c:	7c20      	ldrb	r0, [r4, #16]
   1699e:	f7ff ff91 	bl	168c4 <gen_prov_ack_send>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   169a2:	f7ff feb9 	bl	16718 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, LINK_INVALID)) {
   169a6:	0703      	lsls	r3, r0, #28
   169a8:	d511      	bpl.n	169ce <prov_msg_recv+0x66>
   169aa:	4b10      	ldr	r3, [pc, #64]	; (169ec <prov_msg_recv+0x84>)
   169ac:	4a0e      	ldr	r2, [pc, #56]	; (169e8 <prov_msg_recv+0x80>)
		BT_WARN("Unexpected msg 0x%02x on invalidated link",
   169ae:	4811      	ldr	r0, [pc, #68]	; (169f4 <prov_msg_recv+0x8c>)
   169b0:	1ad2      	subs	r2, r2, r3
   169b2:	6963      	ldr	r3, [r4, #20]
   169b4:	08d2      	lsrs	r2, r2, #3
   169b6:	681b      	ldr	r3, [r3, #0]
   169b8:	0192      	lsls	r2, r2, #6
   169ba:	7819      	ldrb	r1, [r3, #0]
   169bc:	f042 0202 	orr.w	r2, r2, #2
   169c0:	f00d fb0d 	bl	23fde <log_1>
}
   169c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		prov_failed(PROV_ERR_UNEXP_PDU);
   169c8:	2003      	movs	r0, #3
   169ca:	f7ff bf61 	b.w	16890 <prov_failed>
	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
   169ce:	68a3      	ldr	r3, [r4, #8]
   169d0:	6962      	ldr	r2, [r4, #20]
   169d2:	68e1      	ldr	r1, [r4, #12]
   169d4:	68db      	ldr	r3, [r3, #12]
   169d6:	4808      	ldr	r0, [pc, #32]	; (169f8 <prov_msg_recv+0x90>)
}
   169d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
   169dc:	4718      	bx	r3
   169de:	bf00      	nop
   169e0:	20006978 	.word	0x20006978
   169e4:	20001dc4 	.word	0x20001dc4
   169e8:	00029960 	.word	0x00029960
   169ec:	00029830 	.word	0x00029830
   169f0:	0002f9e5 	.word	0x0002f9e5
   169f4:	0002f9f3 	.word	0x0002f9f3
   169f8:	0002a3fc 	.word	0x0002a3fc

000169fc <gen_prov_start>:
{
   169fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u8_t expected_id = next_transaction_id(link.rx.id);
   16a00:	4d49      	ldr	r5, [pc, #292]	; (16b28 <gen_prov_start+0x12c>)
{
   16a02:	4604      	mov	r4, r0
   16a04:	460e      	mov	r6, r1
   16a06:	7901      	ldrb	r1, [r0, #4]
	if (link.rx.seg) {
   16a08:	7c68      	ldrb	r0, [r5, #17]
	u8_t expected_id = next_transaction_id(link.rx.id);
   16a0a:	7c2a      	ldrb	r2, [r5, #16]
	if (link.rx.seg) {
   16a0c:	462f      	mov	r7, r5
   16a0e:	b170      	cbz	r0, 16a2e <gen_prov_start+0x32>
		if (rx->xact_id != link.rx.id) {
   16a10:	428a      	cmp	r2, r1
   16a12:	f000 8086 	beq.w	16b22 <gen_prov_start+0x126>
   16a16:	4945      	ldr	r1, [pc, #276]	; (16b2c <gen_prov_start+0x130>)
   16a18:	4b45      	ldr	r3, [pc, #276]	; (16b30 <gen_prov_start+0x134>)
			BT_WARN("Got Start while there are unreceived "
   16a1a:	4846      	ldr	r0, [pc, #280]	; (16b34 <gen_prov_start+0x138>)
   16a1c:	1ac9      	subs	r1, r1, r3
   16a1e:	08c9      	lsrs	r1, r1, #3
   16a20:	0189      	lsls	r1, r1, #6
}
   16a22:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			BT_WARN("Got Start while there are unreceived "
   16a26:	f041 0102 	orr.w	r1, r1, #2
   16a2a:	f00d bacb 	b.w	23fc4 <log_0>
	if (rx->xact_id == link.rx.id) {
   16a2e:	428a      	cmp	r2, r1
   16a30:	d108      	bne.n	16a44 <gen_prov_start+0x48>
   16a32:	f7ff fe71 	bl	16718 <atomic_get.constprop.0>
		if (!ack_pending()) {
   16a36:	06c3      	lsls	r3, r0, #27
   16a38:	d473      	bmi.n	16b22 <gen_prov_start+0x126>
			gen_prov_ack_send(rx->xact_id);
   16a3a:	7920      	ldrb	r0, [r4, #4]
}
   16a3c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			gen_prov_ack_send(rx->xact_id);
   16a40:	f7ff bf40 	b.w	168c4 <gen_prov_ack_send>
	return (((id + 1) & 0x7f) | (id & 0x80));
   16a44:	b252      	sxtb	r2, r2
   16a46:	1c53      	adds	r3, r2, #1
   16a48:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   16a4c:	f002 0280 	and.w	r2, r2, #128	; 0x80
   16a50:	431a      	orrs	r2, r3
	if (rx->xact_id != expected_id) {
   16a52:	4291      	cmp	r1, r2
   16a54:	d00b      	beq.n	16a6e <gen_prov_start+0x72>
   16a56:	4836      	ldr	r0, [pc, #216]	; (16b30 <gen_prov_start+0x134>)
   16a58:	4b34      	ldr	r3, [pc, #208]	; (16b2c <gen_prov_start+0x130>)
   16a5a:	1a1b      	subs	r3, r3, r0
   16a5c:	08db      	lsrs	r3, r3, #3
		BT_WARN("Unexpected xact 0x%x, expected 0x%x", rx->xact_id,
   16a5e:	019b      	lsls	r3, r3, #6
}
   16a60:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		BT_WARN("Unexpected xact 0x%x, expected 0x%x", rx->xact_id,
   16a64:	4834      	ldr	r0, [pc, #208]	; (16b38 <gen_prov_start+0x13c>)
   16a66:	f043 0302 	orr.w	r3, r3, #2
   16a6a:	f00d bacc 	b.w	24006 <log_2>
	net_buf_simple_reset(link.rx.buf);
   16a6e:	f8d5 8014 	ldr.w	r8, [r5, #20]
   16a72:	f8d8 3008 	ldr.w	r3, [r8, #8]
	buf->len  = 0U;
   16a76:	f8a8 0004 	strh.w	r0, [r8, #4]
	buf->data = buf->__buf;
   16a7a:	f8c8 3000 	str.w	r3, [r8]
	link.rx.buf->len = net_buf_simple_pull_be16(buf);
   16a7e:	4630      	mov	r0, r6
   16a80:	f012 f979 	bl	28d76 <net_buf_simple_pull_be16>
   16a84:	f8a8 0004 	strh.w	r0, [r8, #4]
	link.rx.id = rx->xact_id;
   16a88:	7923      	ldrb	r3, [r4, #4]
   16a8a:	742b      	strb	r3, [r5, #16]
	link.rx.fcs = net_buf_simple_pull_u8(buf);
   16a8c:	4630      	mov	r0, r6
   16a8e:	f012 f962 	bl	28d56 <net_buf_simple_pull_u8>
	if (link.rx.buf->len < 1) {
   16a92:	696b      	ldr	r3, [r5, #20]
	link.rx.fcs = net_buf_simple_pull_u8(buf);
   16a94:	74e8      	strb	r0, [r5, #19]
	if (link.rx.buf->len < 1) {
   16a96:	8899      	ldrh	r1, [r3, #4]
   16a98:	b951      	cbnz	r1, 16ab0 <gen_prov_start+0xb4>
   16a9a:	4924      	ldr	r1, [pc, #144]	; (16b2c <gen_prov_start+0x130>)
   16a9c:	4b24      	ldr	r3, [pc, #144]	; (16b30 <gen_prov_start+0x134>)
		BT_ERR("Ignoring zero-length provisioning PDU");
   16a9e:	4827      	ldr	r0, [pc, #156]	; (16b3c <gen_prov_start+0x140>)
   16aa0:	1ac9      	subs	r1, r1, r3
   16aa2:	08c9      	lsrs	r1, r1, #3
   16aa4:	0189      	lsls	r1, r1, #6
   16aa6:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Too small total length for multi-segment PDU");
   16aaa:	f00d fa8b 	bl	23fc4 <log_0>
		prov_failed(PROV_ERR_NVAL_FMT);
   16aae:	e00c      	b.n	16aca <gen_prov_start+0xce>
	if (link.rx.buf->len > link.rx.buf->size) {
   16ab0:	88db      	ldrh	r3, [r3, #6]
   16ab2:	428b      	cmp	r3, r1
   16ab4:	d20e      	bcs.n	16ad4 <gen_prov_start+0xd8>
   16ab6:	4a1d      	ldr	r2, [pc, #116]	; (16b2c <gen_prov_start+0x130>)
   16ab8:	4b1d      	ldr	r3, [pc, #116]	; (16b30 <gen_prov_start+0x134>)
		BT_ERR("Too large provisioning PDU (%u bytes)",
   16aba:	4821      	ldr	r0, [pc, #132]	; (16b40 <gen_prov_start+0x144>)
   16abc:	1ad2      	subs	r2, r2, r3
   16abe:	08d2      	lsrs	r2, r2, #3
   16ac0:	0192      	lsls	r2, r2, #6
   16ac2:	f042 0201 	orr.w	r2, r2, #1
   16ac6:	f00d fa8a 	bl	23fde <log_1>
}
   16aca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		prov_failed(PROV_ERR_NVAL_FMT);
   16ace:	2002      	movs	r0, #2
   16ad0:	f7ff bede 	b.w	16890 <prov_failed>
	if (START_LAST_SEG(rx->gpc) > 0 && link.rx.buf->len <= 20U) {
   16ad4:	7963      	ldrb	r3, [r4, #5]
   16ad6:	089b      	lsrs	r3, r3, #2
   16ad8:	d00a      	beq.n	16af0 <gen_prov_start+0xf4>
   16ada:	2914      	cmp	r1, #20
   16adc:	d808      	bhi.n	16af0 <gen_prov_start+0xf4>
   16ade:	4913      	ldr	r1, [pc, #76]	; (16b2c <gen_prov_start+0x130>)
   16ae0:	4b13      	ldr	r3, [pc, #76]	; (16b30 <gen_prov_start+0x134>)
		BT_ERR("Too small total length for multi-segment PDU");
   16ae2:	4818      	ldr	r0, [pc, #96]	; (16b44 <gen_prov_start+0x148>)
   16ae4:	1ac9      	subs	r1, r1, r3
   16ae6:	08c9      	lsrs	r1, r1, #3
   16ae8:	0189      	lsls	r1, r1, #6
   16aea:	f041 0101 	orr.w	r1, r1, #1
   16aee:	e7dc      	b.n	16aaa <gen_prov_start+0xae>
	prov_clear_tx();
   16af0:	f7ff fdac 	bl	1664c <prov_clear_tx>
	link.rx.seg = (1 << (START_LAST_SEG(rx->gpc) + 1)) - 1;
   16af4:	7962      	ldrb	r2, [r4, #5]
   16af6:	0892      	lsrs	r2, r2, #2
   16af8:	1c51      	adds	r1, r2, #1
   16afa:	2301      	movs	r3, #1
   16afc:	408b      	lsls	r3, r1
   16afe:	3b01      	subs	r3, #1
   16b00:	747b      	strb	r3, [r7, #17]
	memcpy(link.rx.buf->data, buf->data, buf->len);
   16b02:	697b      	ldr	r3, [r7, #20]
	link.rx.last_seg = START_LAST_SEG(rx->gpc);
   16b04:	74ba      	strb	r2, [r7, #18]
	memcpy(link.rx.buf->data, buf->data, buf->len);
   16b06:	6818      	ldr	r0, [r3, #0]
   16b08:	88b2      	ldrh	r2, [r6, #4]
   16b0a:	6831      	ldr	r1, [r6, #0]
   16b0c:	f00f f8cc 	bl	25ca8 <memcpy>
	XACT_SEG_RECV(0);
   16b10:	7c7b      	ldrb	r3, [r7, #17]
   16b12:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   16b16:	747b      	strb	r3, [r7, #17]
	if (!link.rx.seg) {
   16b18:	b91b      	cbnz	r3, 16b22 <gen_prov_start+0x126>
}
   16b1a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		prov_msg_recv();
   16b1e:	f7ff bf23 	b.w	16968 <prov_msg_recv>
}
   16b22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   16b26:	bf00      	nop
   16b28:	20006978 	.word	0x20006978
   16b2c:	00029960 	.word	0x00029960
   16b30:	00029830 	.word	0x00029830
   16b34:	0002fa1d 	.word	0x0002fa1d
   16b38:	0002fa4b 	.word	0x0002fa4b
   16b3c:	0002fa6f 	.word	0x0002fa6f
   16b40:	0002fa95 	.word	0x0002fa95
   16b44:	0002fabb 	.word	0x0002fabb

00016b48 <send_reliable>:
{
   16b48:	b570      	push	{r4, r5, r6, lr}
   16b4a:	f012 fc62 	bl	29412 <z_impl_k_uptime_ticks>
   16b4e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   16b52:	460a      	mov	r2, r1
   16b54:	fba0 0103 	umull	r0, r1, r0, r3
   16b58:	fb03 1102 	mla	r1, r3, r2, r1
	link.tx.start = k_uptime_get();
   16b5c:	4c0e      	ldr	r4, [pc, #56]	; (16b98 <send_reliable+0x50>)
			bt_mesh_adv_send(buf, &buf_sent_cb, NULL);
   16b5e:	4e0f      	ldr	r6, [pc, #60]	; (16b9c <send_reliable+0x54>)
   16b60:	0bc3      	lsrs	r3, r0, #15
   16b62:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
   16b66:	0bca      	lsrs	r2, r1, #15
	link.tx.start = k_uptime_get();
   16b68:	e9c4 3206 	strd	r3, r2, [r4, #24]
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   16b6c:	2500      	movs	r5, #0
   16b6e:	3424      	adds	r4, #36	; 0x24
		struct net_buf *buf = link.tx.buf[i];
   16b70:	f854 0b04 	ldr.w	r0, [r4], #4
		if (!buf) {
   16b74:	b178      	cbz	r0, 16b96 <send_reliable+0x4e>
		if (i + 1 < ARRAY_SIZE(link.tx.buf) && link.tx.buf[i + 1]) {
   16b76:	3501      	adds	r5, #1
   16b78:	2d03      	cmp	r5, #3
			bt_mesh_adv_send(buf, NULL, NULL);
   16b7a:	f04f 0200 	mov.w	r2, #0
		if (i + 1 < ARRAY_SIZE(link.tx.buf) && link.tx.buf[i + 1]) {
   16b7e:	d005      	beq.n	16b8c <send_reliable+0x44>
   16b80:	6823      	ldr	r3, [r4, #0]
   16b82:	b11b      	cbz	r3, 16b8c <send_reliable+0x44>
			bt_mesh_adv_send(buf, NULL, NULL);
   16b84:	4611      	mov	r1, r2
   16b86:	f7f5 faef 	bl	c168 <bt_mesh_adv_send>
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   16b8a:	e7f1      	b.n	16b70 <send_reliable+0x28>
			bt_mesh_adv_send(buf, &buf_sent_cb, NULL);
   16b8c:	4631      	mov	r1, r6
   16b8e:	f7f5 faeb 	bl	c168 <bt_mesh_adv_send>
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   16b92:	2d03      	cmp	r5, #3
   16b94:	d1ec      	bne.n	16b70 <send_reliable+0x28>
}
   16b96:	bd70      	pop	{r4, r5, r6, pc}
   16b98:	20006978 	.word	0x20006978
   16b9c:	20006f04 	.word	0x20006f04

00016ba0 <bearer_ctl_send>:
{
   16ba0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   16ba4:	461c      	mov	r4, r3
   16ba6:	4605      	mov	r5, r0
   16ba8:	4688      	mov	r8, r1
   16baa:	4691      	mov	r9, r2
	prov_clear_tx();
   16bac:	f7ff fd4e 	bl	1664c <prov_clear_tx>
	buf = adv_buf_create(reliable ? RETRANSMITS_RELIABLE :
   16bb0:	2c00      	cmp	r4, #0
   16bb2:	bf0c      	ite	eq
   16bb4:	2002      	moveq	r0, #2
   16bb6:	2000      	movne	r0, #0
   16bb8:	f7ff fd82 	bl	166c0 <adv_buf_create>
	if (!buf) {
   16bbc:	4607      	mov	r7, r0
   16bbe:	b330      	cbz	r0, 16c0e <bearer_ctl_send+0x6e>
	net_buf_add_be32(buf, link.id);
   16bc0:	f8df a054 	ldr.w	sl, [pc, #84]	; 16c18 <bearer_ctl_send+0x78>
   16bc4:	f100 0608 	add.w	r6, r0, #8
   16bc8:	f8da 1000 	ldr.w	r1, [sl]
   16bcc:	4630      	mov	r0, r6
	net_buf_add_u8(buf, GPC_CTL(op));
   16bce:	00ad      	lsls	r5, r5, #2
	net_buf_add_be32(buf, link.id);
   16bd0:	f012 f922 	bl	28e18 <net_buf_simple_add_be32>
	net_buf_add_u8(buf, GPC_CTL(op));
   16bd4:	f045 0503 	orr.w	r5, r5, #3
	net_buf_add_u8(buf, 0x00);
   16bd8:	2100      	movs	r1, #0
   16bda:	4630      	mov	r0, r6
   16bdc:	f012 f8f7 	bl	28dce <net_buf_simple_add_u8>
	net_buf_add_u8(buf, GPC_CTL(op));
   16be0:	b2e9      	uxtb	r1, r5
   16be2:	4630      	mov	r0, r6
   16be4:	f012 f8f3 	bl	28dce <net_buf_simple_add_u8>
	net_buf_add_mem(buf, data, data_len);
   16be8:	464a      	mov	r2, r9
   16bea:	4641      	mov	r1, r8
   16bec:	4630      	mov	r0, r6
   16bee:	f012 f8e2 	bl	28db6 <net_buf_simple_add_mem>
	if (reliable) {
   16bf2:	b134      	cbz	r4, 16c02 <bearer_ctl_send+0x62>
		link.tx.buf[0] = buf;
   16bf4:	f8ca 7024 	str.w	r7, [sl, #36]	; 0x24
		send_reliable();
   16bf8:	f7ff ffa6 	bl	16b48 <send_reliable>
	return 0;
   16bfc:	2000      	movs	r0, #0
}
   16bfe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bt_mesh_adv_send(buf, &buf_sent_cb, NULL);
   16c02:	4904      	ldr	r1, [pc, #16]	; (16c14 <bearer_ctl_send+0x74>)
   16c04:	4622      	mov	r2, r4
   16c06:	4638      	mov	r0, r7
   16c08:	f7f5 faae 	bl	c168 <bt_mesh_adv_send>
   16c0c:	e7f6      	b.n	16bfc <bearer_ctl_send+0x5c>
		return -ENOBUFS;
   16c0e:	f06f 0036 	mvn.w	r0, #54	; 0x36
   16c12:	e7f4      	b.n	16bfe <bearer_ctl_send+0x5e>
   16c14:	20006f04 	.word	0x20006f04
   16c18:	20006978 	.word	0x20006978

00016c1c <gen_prov_ctl>:
{
   16c1c:	b570      	push	{r4, r5, r6, lr}
	switch (BEARER_CTL(rx->gpc)) {
   16c1e:	7944      	ldrb	r4, [r0, #5]
   16c20:	08a4      	lsrs	r4, r4, #2
   16c22:	2c01      	cmp	r4, #1
{
   16c24:	4605      	mov	r5, r0
   16c26:	460a      	mov	r2, r1
	switch (BEARER_CTL(rx->gpc)) {
   16c28:	d053      	beq.n	16cd2 <gen_prov_ctl+0xb6>
   16c2a:	2c02      	cmp	r4, #2
   16c2c:	d06c      	beq.n	16d08 <gen_prov_ctl+0xec>
   16c2e:	2c00      	cmp	r4, #0
   16c30:	d178      	bne.n	16d24 <gen_prov_ctl+0x108>
	if (buf->len < 16) {
   16c32:	8889      	ldrh	r1, [r1, #4]
   16c34:	290f      	cmp	r1, #15
   16c36:	d80b      	bhi.n	16c50 <gen_prov_ctl+0x34>
   16c38:	4a40      	ldr	r2, [pc, #256]	; (16d3c <gen_prov_ctl+0x120>)
   16c3a:	4b41      	ldr	r3, [pc, #260]	; (16d40 <gen_prov_ctl+0x124>)
		BT_ERR("Too short bearer open message (len %u)", buf->len);
   16c3c:	4841      	ldr	r0, [pc, #260]	; (16d44 <gen_prov_ctl+0x128>)
   16c3e:	1ad2      	subs	r2, r2, r3
   16c40:	08d2      	lsrs	r2, r2, #3
   16c42:	0192      	lsls	r2, r2, #6
   16c44:	f042 0201 	orr.w	r2, r2, #1
}
   16c48:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unknown bearer opcode: 0x%02x", BEARER_CTL(rx->gpc));
   16c4c:	f00d b9c7 	b.w	23fde <log_1>
   16c50:	f7ff fd62 	bl	16718 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, LINK_ACTIVE)) {
   16c54:	07c6      	lsls	r6, r0, #31
   16c56:	d510      	bpl.n	16c7a <gen_prov_ctl+0x5e>
		if (link.id == rx->link_id && link.tx.id == 0x7F) {
   16c58:	4b3b      	ldr	r3, [pc, #236]	; (16d48 <gen_prov_ctl+0x12c>)
   16c5a:	682a      	ldr	r2, [r5, #0]
   16c5c:	6819      	ldr	r1, [r3, #0]
   16c5e:	4291      	cmp	r1, r2
   16c60:	d16a      	bne.n	16d38 <gen_prov_ctl+0x11c>
   16c62:	f893 3020 	ldrb.w	r3, [r3, #32]
   16c66:	2b7f      	cmp	r3, #127	; 0x7f
   16c68:	d166      	bne.n	16d38 <gen_prov_ctl+0x11c>
			bearer_ctl_send(LINK_ACK, NULL, 0, false);
   16c6a:	4623      	mov	r3, r4
   16c6c:	4622      	mov	r2, r4
   16c6e:	4621      	mov	r1, r4
   16c70:	2001      	movs	r0, #1
}
   16c72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			bearer_ctl_send(LINK_ACK, NULL, 0, false);
   16c76:	f7ff bf93 	b.w	16ba0 <bearer_ctl_send>
	if (memcmp(buf->data, bt_mesh_prov_get()->uuid, 16)) {
   16c7a:	6814      	ldr	r4, [r2, #0]
   16c7c:	f7ff fc4c 	bl	16518 <bt_mesh_prov_get>
   16c80:	2210      	movs	r2, #16
   16c82:	6801      	ldr	r1, [r0, #0]
   16c84:	4620      	mov	r0, r4
   16c86:	f00e ffff 	bl	25c88 <memcmp>
   16c8a:	4603      	mov	r3, r0
   16c8c:	2800      	cmp	r0, #0
   16c8e:	d153      	bne.n	16d38 <gen_prov_ctl+0x11c>
	link.id = rx->link_id;
   16c90:	4c2d      	ldr	r4, [pc, #180]	; (16d48 <gen_prov_ctl+0x12c>)
   16c92:	6829      	ldr	r1, [r5, #0]
   16c94:	4622      	mov	r2, r4
   16c96:	f842 1b04 	str.w	r1, [r2], #4
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   16c9a:	f3bf 8f5b 	dmb	ish
   16c9e:	e852 1f00 	ldrex	r1, [r2]
   16ca2:	f041 0101 	orr.w	r1, r1, #1
   16ca6:	e842 1000 	strex	r0, r1, [r2]
   16caa:	2800      	cmp	r0, #0
   16cac:	d1f7      	bne.n	16c9e <gen_prov_ctl+0x82>
   16cae:	f3bf 8f5b 	dmb	ish
	net_buf_simple_reset(link.rx.buf);
   16cb2:	6962      	ldr	r2, [r4, #20]
   16cb4:	6891      	ldr	r1, [r2, #8]
   16cb6:	6011      	str	r1, [r2, #0]
	buf->len  = 0U;
   16cb8:	8093      	strh	r3, [r2, #4]
	bearer_ctl_send(LINK_ACK, NULL, 0, false);
   16cba:	4619      	mov	r1, r3
   16cbc:	461a      	mov	r2, r3
   16cbe:	2001      	movs	r0, #1
   16cc0:	f7ff ff6e 	bl	16ba0 <bearer_ctl_send>
		link.cb->link_opened(&pb_adv, link.cb_data);
   16cc4:	68a3      	ldr	r3, [r4, #8]
   16cc6:	68e1      	ldr	r1, [r4, #12]
   16cc8:	681b      	ldr	r3, [r3, #0]
   16cca:	4820      	ldr	r0, [pc, #128]	; (16d4c <gen_prov_ctl+0x130>)
}
   16ccc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		link.cb->link_opened(&pb_adv, link.cb_data);
   16cd0:	4718      	bx	r3
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   16cd2:	f7ff fd21 	bl	16718 <atomic_get.constprop.0>
		if (!atomic_test_bit(link.flags, LINK_ACTIVE)) {
   16cd6:	07c0      	lsls	r0, r0, #31
   16cd8:	d52e      	bpl.n	16d38 <gen_prov_ctl+0x11c>
   16cda:	f7ff fd1d 	bl	16718 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, PROVISIONER)) {
   16cde:	0681      	lsls	r1, r0, #26
   16ce0:	d52a      	bpl.n	16d38 <gen_prov_ctl+0x11c>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   16ce2:	f3bf 8f5b 	dmb	ish
   16ce6:	4c18      	ldr	r4, [pc, #96]	; (16d48 <gen_prov_ctl+0x12c>)
   16ce8:	1d23      	adds	r3, r4, #4
   16cea:	e853 2f00 	ldrex	r2, [r3]
   16cee:	f042 0102 	orr.w	r1, r2, #2
   16cf2:	e843 1000 	strex	r0, r1, [r3]
   16cf6:	2800      	cmp	r0, #0
   16cf8:	d1f7      	bne.n	16cea <gen_prov_ctl+0xce>
   16cfa:	f3bf 8f5b 	dmb	ish
		if (atomic_test_and_set_bit(link.flags, LINK_ACK_RECVD)) {
   16cfe:	0792      	lsls	r2, r2, #30
   16d00:	d41a      	bmi.n	16d38 <gen_prov_ctl+0x11c>
		prov_clear_tx();
   16d02:	f7ff fca3 	bl	1664c <prov_clear_tx>
   16d06:	e7dd      	b.n	16cc4 <gen_prov_ctl+0xa8>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   16d08:	f7ff fd06 	bl	16718 <atomic_get.constprop.0>
		if (!atomic_test_bit(link.flags, LINK_ACTIVE)) {
   16d0c:	07c3      	lsls	r3, r0, #31
   16d0e:	d513      	bpl.n	16d38 <gen_prov_ctl+0x11c>
	if (buf->len != 1) {
   16d10:	888b      	ldrh	r3, [r1, #4]
   16d12:	2b01      	cmp	r3, #1
   16d14:	d110      	bne.n	16d38 <gen_prov_ctl+0x11c>
	close_link(net_buf_simple_pull_u8(buf));
   16d16:	4608      	mov	r0, r1
   16d18:	f012 f81d 	bl	28d56 <net_buf_simple_pull_u8>
}
   16d1c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	close_link(net_buf_simple_pull_u8(buf));
   16d20:	f7ff bc9e 	b.w	16660 <close_link>
   16d24:	4a05      	ldr	r2, [pc, #20]	; (16d3c <gen_prov_ctl+0x120>)
   16d26:	4b06      	ldr	r3, [pc, #24]	; (16d40 <gen_prov_ctl+0x124>)
		BT_ERR("Unknown bearer opcode: 0x%02x", BEARER_CTL(rx->gpc));
   16d28:	4809      	ldr	r0, [pc, #36]	; (16d50 <gen_prov_ctl+0x134>)
   16d2a:	1ad2      	subs	r2, r2, r3
   16d2c:	08d2      	lsrs	r2, r2, #3
   16d2e:	0192      	lsls	r2, r2, #6
   16d30:	f042 0201 	orr.w	r2, r2, #1
   16d34:	4621      	mov	r1, r4
   16d36:	e787      	b.n	16c48 <gen_prov_ctl+0x2c>
}
   16d38:	bd70      	pop	{r4, r5, r6, pc}
   16d3a:	bf00      	nop
   16d3c:	00029960 	.word	0x00029960
   16d40:	00029830 	.word	0x00029830
   16d44:	0002fae8 	.word	0x0002fae8
   16d48:	20006978 	.word	0x20006978
   16d4c:	0002a3fc 	.word	0x0002a3fc
   16d50:	0002fb0f 	.word	0x0002fb0f

00016d54 <prov_link_close>:

static void prov_link_close(enum prov_bearer_link_status status)
{
   16d54:	b507      	push	{r0, r1, r2, lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   16d56:	4b0d      	ldr	r3, [pc, #52]	; (16d8c <prov_link_close+0x38>)
   16d58:	f88d 0007 	strb.w	r0, [sp, #7]
   16d5c:	f3bf 8f5b 	dmb	ish
   16d60:	e853 2f00 	ldrex	r2, [r3]
   16d64:	f042 0104 	orr.w	r1, r2, #4
   16d68:	e843 1000 	strex	r0, r1, [r3]
   16d6c:	2800      	cmp	r0, #0
   16d6e:	d1f7      	bne.n	16d60 <prov_link_close+0xc>
   16d70:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(link.flags, LINK_CLOSING)) {
   16d74:	0753      	lsls	r3, r2, #29
   16d76:	d406      	bmi.n	16d86 <prov_link_close+0x32>
		return;
	}

	bearer_ctl_send(LINK_CLOSE, &status, 1, true);
   16d78:	2301      	movs	r3, #1
   16d7a:	461a      	mov	r2, r3
   16d7c:	f10d 0107 	add.w	r1, sp, #7
   16d80:	2002      	movs	r0, #2
   16d82:	f7ff ff0d 	bl	16ba0 <bearer_ctl_send>
}
   16d86:	b003      	add	sp, #12
   16d88:	f85d fb04 	ldr.w	pc, [sp], #4
   16d8c:	2000697c 	.word	0x2000697c

00016d90 <prov_link_open>:
{
   16d90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16d94:	4d1d      	ldr	r5, [pc, #116]	; (16e0c <prov_link_open+0x7c>)
   16d96:	f3bf 8f5b 	dmb	ish
   16d9a:	4606      	mov	r6, r0
   16d9c:	4690      	mov	r8, r2
   16d9e:	461f      	mov	r7, r3
   16da0:	1d29      	adds	r1, r5, #4
   16da2:	e851 4f00 	ldrex	r4, [r1]
   16da6:	f044 0301 	orr.w	r3, r4, #1
   16daa:	e841 3200 	strex	r2, r3, [r1]
   16dae:	2a00      	cmp	r2, #0
   16db0:	d1f7      	bne.n	16da2 <prov_link_open+0x12>
   16db2:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(link.flags, LINK_ACTIVE)) {
   16db6:	f014 0401 	ands.w	r4, r4, #1
   16dba:	d123      	bne.n	16e04 <prov_link_open+0x74>
   16dbc:	f3bf 8f5b 	dmb	ish
   16dc0:	e851 3f00 	ldrex	r3, [r1]
   16dc4:	f043 0320 	orr.w	r3, r3, #32
   16dc8:	e841 3200 	strex	r2, r3, [r1]
   16dcc:	2a00      	cmp	r2, #0
   16dce:	d1f7      	bne.n	16dc0 <prov_link_open+0x30>
   16dd0:	f3bf 8f5b 	dmb	ish
	bt_rand(&link.id, sizeof(link.id));
   16dd4:	2104      	movs	r1, #4
   16dd6:	4628      	mov	r0, r5
   16dd8:	f011 fadb 	bl	28392 <bt_rand>
	link.tx.id = 0x7F;
   16ddc:	237f      	movs	r3, #127	; 0x7f
   16dde:	f885 3020 	strb.w	r3, [r5, #32]
	link.rx.id = 0xFF;
   16de2:	23ff      	movs	r3, #255	; 0xff
   16de4:	742b      	strb	r3, [r5, #16]
	net_buf_simple_reset(link.rx.buf);
   16de6:	696b      	ldr	r3, [r5, #20]
	buf->data = buf->__buf;
   16de8:	689a      	ldr	r2, [r3, #8]
	link.cb_data = cb_data;
   16dea:	e9c5 8702 	strd	r8, r7, [r5, #8]
	bearer_ctl_send(LINK_OPEN, uuid, 16, true);
   16dee:	4631      	mov	r1, r6
   16df0:	601a      	str	r2, [r3, #0]
	buf->len  = 0U;
   16df2:	809c      	strh	r4, [r3, #4]
   16df4:	2210      	movs	r2, #16
   16df6:	2301      	movs	r3, #1
   16df8:	4620      	mov	r0, r4
   16dfa:	f7ff fed1 	bl	16ba0 <bearer_ctl_send>
}
   16dfe:	4620      	mov	r0, r4
   16e00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EBUSY;
   16e04:	f06f 040f 	mvn.w	r4, #15
   16e08:	e7f9      	b.n	16dfe <prov_link_open+0x6e>
   16e0a:	bf00      	nop
   16e0c:	20006978 	.word	0x20006978

00016e10 <prov_send_adv>:
{
   16e10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   16e14:	4d50      	ldr	r5, [pc, #320]	; (16f58 <prov_send_adv+0x148>)
   16e16:	4604      	mov	r4, r0
   16e18:	460f      	mov	r7, r1
   16e1a:	4616      	mov	r6, r2
	prov_clear_tx();
   16e1c:	f7ff fc16 	bl	1664c <prov_clear_tx>
   16e20:	f64e 2260 	movw	r2, #60000	; 0xea60
   16e24:	f105 0158 	add.w	r1, r5, #88	; 0x58
   16e28:	484c      	ldr	r0, [pc, #304]	; (16f5c <prov_send_adv+0x14c>)
   16e2a:	f00b fe99 	bl	22b60 <k_delayed_work_submit_to_queue>
	start = adv_buf_create(RETRANSMITS_RELIABLE);
   16e2e:	2000      	movs	r0, #0
   16e30:	f7ff fc46 	bl	166c0 <adv_buf_create>
	if (!start) {
   16e34:	4681      	mov	r9, r0
   16e36:	2800      	cmp	r0, #0
   16e38:	d066      	beq.n	16f08 <prov_send_adv+0xf8>
	return (((id + 1) & 0x7f) | (id & 0x80));
   16e3a:	f995 2020 	ldrsb.w	r2, [r5, #32]
	net_buf_add_be32(start, link.id);
   16e3e:	6829      	ldr	r1, [r5, #0]
	return (((id + 1) & 0x7f) | (id & 0x80));
   16e40:	1c53      	adds	r3, r2, #1
	net_buf_add_be32(start, link.id);
   16e42:	f100 0808 	add.w	r8, r0, #8
	return (((id + 1) & 0x7f) | (id & 0x80));
   16e46:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   16e4a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   16e4e:	4313      	orrs	r3, r2
	net_buf_add_be32(start, link.id);
   16e50:	4640      	mov	r0, r8
	link.tx.id = next_transaction_id(link.tx.id);
   16e52:	f885 3020 	strb.w	r3, [r5, #32]
	net_buf_add_be32(start, link.id);
   16e56:	f011 ffdf 	bl	28e18 <net_buf_simple_add_be32>
	net_buf_add_u8(start, link.tx.id);
   16e5a:	f895 1020 	ldrb.w	r1, [r5, #32]
   16e5e:	4640      	mov	r0, r8
   16e60:	f011 ffb5 	bl	28dce <net_buf_simple_add_u8>
	if (len <= START_PAYLOAD_MAX) {
   16e64:	7922      	ldrb	r2, [r4, #4]
	net_buf_add_u8(start, GPC_START(last_seg(msg->len)));
   16e66:	88a3      	ldrh	r3, [r4, #4]
	if (len <= START_PAYLOAD_MAX) {
   16e68:	2a14      	cmp	r2, #20
	len -= START_PAYLOAD_MAX;
   16e6a:	bf81      	itttt	hi
   16e6c:	3b14      	subhi	r3, #20
	return 1 + (len / CONT_PAYLOAD_MAX);
   16e6e:	b2db      	uxtbhi	r3, r3
   16e70:	2117      	movhi	r1, #23
   16e72:	fbb3 f3f1 	udivhi	r3, r3, r1
   16e76:	bf86      	itte	hi
   16e78:	3301      	addhi	r3, #1
   16e7a:	b2db      	uxtbhi	r3, r3
		return 0;
   16e7c:	2300      	movls	r3, #0
	net_buf_add_u8(start, GPC_START(last_seg(msg->len)));
   16e7e:	009b      	lsls	r3, r3, #2
   16e80:	f003 01fc 	and.w	r1, r3, #252	; 0xfc
   16e84:	4640      	mov	r0, r8
   16e86:	f011 ffa2 	bl	28dce <net_buf_simple_add_u8>
	net_buf_add_be16(start, msg->len);
   16e8a:	4640      	mov	r0, r8
   16e8c:	88a1      	ldrh	r1, [r4, #4]
   16e8e:	f011 ffae 	bl	28dee <net_buf_simple_add_be16>
	net_buf_add_u8(start, bt_mesh_fcs_calc(msg->data, msg->len));
   16e92:	7921      	ldrb	r1, [r4, #4]
   16e94:	6820      	ldr	r0, [r4, #0]
   16e96:	f7f8 fbdd 	bl	f654 <bt_mesh_fcs_calc>
   16e9a:	4601      	mov	r1, r0
   16e9c:	4640      	mov	r0, r8
   16e9e:	f011 ff96 	bl	28dce <net_buf_simple_add_u8>
	link.tx.cb_data = cb_data;
   16ea2:	e9c5 760c 	strd	r7, r6, [r5, #48]	; 0x30
	seg_len = MIN(msg->len, START_PAYLOAD_MAX);
   16ea6:	88a6      	ldrh	r6, [r4, #4]
	net_buf_add_mem(start, msg->data, seg_len);
   16ea8:	6821      	ldr	r1, [r4, #0]
	link.tx.buf[0] = start;
   16eaa:	f8c5 9024 	str.w	r9, [r5, #36]	; 0x24
	net_buf_add_mem(start, msg->data, seg_len);
   16eae:	2e14      	cmp	r6, #20
   16eb0:	bf28      	it	cs
   16eb2:	2614      	movcs	r6, #20
   16eb4:	4632      	mov	r2, r6
   16eb6:	4640      	mov	r0, r8
   16eb8:	f011 ff7d 	bl	28db6 <net_buf_simple_add_mem>
	net_buf_simple_pull(msg, seg_len);
   16ebc:	4631      	mov	r1, r6
   16ebe:	4620      	mov	r0, r4
   16ec0:	f008 f9c8 	bl	1f254 <net_buf_simple_pull>
	for (seg_id = 1U; msg->len > 0; seg_id++) {
   16ec4:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 16f6c <prov_send_adv+0x15c>
   16ec8:	2700      	movs	r7, #0
   16eca:	88a6      	ldrh	r6, [r4, #4]
   16ecc:	b91e      	cbnz	r6, 16ed6 <prov_send_adv+0xc6>
	send_reliable();
   16ece:	f7ff fe3b 	bl	16b48 <send_reliable>
	return 0;
   16ed2:	4630      	mov	r0, r6
   16ed4:	e00f      	b.n	16ef6 <prov_send_adv+0xe6>
		if (seg_id >= ARRAY_SIZE(link.tx.buf)) {
   16ed6:	2f08      	cmp	r7, #8
   16ed8:	d10f      	bne.n	16efa <prov_send_adv+0xea>
   16eda:	4b21      	ldr	r3, [pc, #132]	; (16f60 <prov_send_adv+0x150>)
   16edc:	4921      	ldr	r1, [pc, #132]	; (16f64 <prov_send_adv+0x154>)
			BT_ERR("Too big message");
   16ede:	4822      	ldr	r0, [pc, #136]	; (16f68 <prov_send_adv+0x158>)
   16ee0:	1ac9      	subs	r1, r1, r3
   16ee2:	08c9      	lsrs	r1, r1, #3
   16ee4:	0189      	lsls	r1, r1, #6
   16ee6:	f041 0101 	orr.w	r1, r1, #1
   16eea:	f00d f86b 	bl	23fc4 <log_0>
			free_segments();
   16eee:	f7ff fb97 	bl	16620 <free_segments>
			return -E2BIG;
   16ef2:	f06f 0006 	mvn.w	r0, #6
}
   16ef6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		buf = adv_buf_create(RETRANSMITS_RELIABLE);
   16efa:	2000      	movs	r0, #0
   16efc:	f7ff fbe0 	bl	166c0 <adv_buf_create>
		if (!buf) {
   16f00:	3704      	adds	r7, #4
   16f02:	b920      	cbnz	r0, 16f0e <prov_send_adv+0xfe>
			free_segments();
   16f04:	f7ff fb8c 	bl	16620 <free_segments>
		return -ENOBUFS;
   16f08:	f06f 0036 	mvn.w	r0, #54	; 0x36
   16f0c:	e7f3      	b.n	16ef6 <prov_send_adv+0xe6>
		seg_len = MIN(msg->len, CONT_PAYLOAD_MAX);
   16f0e:	f8b4 9004 	ldrh.w	r9, [r4, #4]
		link.tx.buf[seg_id] = buf;
   16f12:	f848 0b04 	str.w	r0, [r8], #4
		net_buf_add_be32(buf, link.id);
   16f16:	f100 0608 	add.w	r6, r0, #8
		seg_len = MIN(msg->len, CONT_PAYLOAD_MAX);
   16f1a:	f1b9 0f17 	cmp.w	r9, #23
		net_buf_add_be32(buf, link.id);
   16f1e:	6829      	ldr	r1, [r5, #0]
   16f20:	4630      	mov	r0, r6
		seg_len = MIN(msg->len, CONT_PAYLOAD_MAX);
   16f22:	bf28      	it	cs
   16f24:	f04f 0917 	movcs.w	r9, #23
		net_buf_add_be32(buf, link.id);
   16f28:	f011 ff76 	bl	28e18 <net_buf_simple_add_be32>
		net_buf_add_u8(buf, link.tx.id);
   16f2c:	f895 1020 	ldrb.w	r1, [r5, #32]
   16f30:	4630      	mov	r0, r6
   16f32:	f011 ff4c 	bl	28dce <net_buf_simple_add_u8>
		net_buf_add_u8(buf, GPC_CONT(seg_id));
   16f36:	f047 0102 	orr.w	r1, r7, #2
   16f3a:	b2c9      	uxtb	r1, r1
   16f3c:	4630      	mov	r0, r6
   16f3e:	f011 ff46 	bl	28dce <net_buf_simple_add_u8>
		net_buf_add_mem(buf, msg->data, seg_len);
   16f42:	6821      	ldr	r1, [r4, #0]
   16f44:	464a      	mov	r2, r9
   16f46:	4630      	mov	r0, r6
   16f48:	f011 ff35 	bl	28db6 <net_buf_simple_add_mem>
		net_buf_simple_pull(msg, seg_len);
   16f4c:	4649      	mov	r1, r9
   16f4e:	4620      	mov	r0, r4
   16f50:	f008 f980 	bl	1f254 <net_buf_simple_pull>
	for (seg_id = 1U; msg->len > 0; seg_id++) {
   16f54:	e7b9      	b.n	16eca <prov_send_adv+0xba>
   16f56:	bf00      	nop
   16f58:	20006978 	.word	0x20006978
   16f5c:	20001dc4 	.word	0x20001dc4
   16f60:	00029830 	.word	0x00029830
   16f64:	00029960 	.word	0x00029960
   16f68:	0002d913 	.word	0x0002d913
   16f6c:	200069a0 	.word	0x200069a0

00016f70 <gen_prov_cont>:
{
   16f70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!link.rx.seg && link.rx.id == rx->xact_id) {
   16f74:	4f35      	ldr	r7, [pc, #212]	; (1704c <gen_prov_cont+0xdc>)
{
   16f76:	4604      	mov	r4, r0
	if (!link.rx.seg && link.rx.id == rx->xact_id) {
   16f78:	7c78      	ldrb	r0, [r7, #17]
   16f7a:	7c3a      	ldrb	r2, [r7, #16]
{
   16f7c:	460e      	mov	r6, r1
   16f7e:	463d      	mov	r5, r7
   16f80:	7921      	ldrb	r1, [r4, #4]
	if (!link.rx.seg && link.rx.id == rx->xact_id) {
   16f82:	b950      	cbnz	r0, 16f9a <gen_prov_cont+0x2a>
   16f84:	428a      	cmp	r2, r1
   16f86:	d10a      	bne.n	16f9e <gen_prov_cont+0x2e>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   16f88:	f7ff fbc6 	bl	16718 <atomic_get.constprop.0>
		if (!ack_pending()) {
   16f8c:	06c2      	lsls	r2, r0, #27
   16f8e:	d45a      	bmi.n	17046 <gen_prov_cont+0xd6>
			gen_prov_ack_send(rx->xact_id);
   16f90:	7920      	ldrb	r0, [r4, #4]
}
   16f92:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			gen_prov_ack_send(rx->xact_id);
   16f96:	f7ff bc95 	b.w	168c4 <gen_prov_ack_send>
	if (rx->xact_id != link.rx.id) {
   16f9a:	428a      	cmp	r2, r1
   16f9c:	d00b      	beq.n	16fb6 <gen_prov_cont+0x46>
   16f9e:	482c      	ldr	r0, [pc, #176]	; (17050 <gen_prov_cont+0xe0>)
   16fa0:	4b2c      	ldr	r3, [pc, #176]	; (17054 <gen_prov_cont+0xe4>)
   16fa2:	1a1b      	subs	r3, r3, r0
   16fa4:	08db      	lsrs	r3, r3, #3
		BT_WARN("Data for unknown transaction (0x%x != 0x%x)",
   16fa6:	019b      	lsls	r3, r3, #6
}
   16fa8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		BT_WARN("Data for unknown transaction (0x%x != 0x%x)",
   16fac:	482a      	ldr	r0, [pc, #168]	; (17058 <gen_prov_cont+0xe8>)
   16fae:	f043 0302 	orr.w	r3, r3, #2
   16fb2:	f00d b828 	b.w	24006 <log_2>
	u8_t seg = CONT_SEG_INDEX(rx->gpc);
   16fb6:	7964      	ldrb	r4, [r4, #5]
	if (seg > link.rx.last_seg) {
   16fb8:	7cbb      	ldrb	r3, [r7, #18]
	u8_t seg = CONT_SEG_INDEX(rx->gpc);
   16fba:	08a4      	lsrs	r4, r4, #2
	if (seg > link.rx.last_seg) {
   16fbc:	42a3      	cmp	r3, r4
   16fbe:	d20f      	bcs.n	16fe0 <gen_prov_cont+0x70>
   16fc0:	4a24      	ldr	r2, [pc, #144]	; (17054 <gen_prov_cont+0xe4>)
   16fc2:	4b23      	ldr	r3, [pc, #140]	; (17050 <gen_prov_cont+0xe0>)
		BT_ERR("Invalid segment index %u", seg);
   16fc4:	4825      	ldr	r0, [pc, #148]	; (1705c <gen_prov_cont+0xec>)
   16fc6:	1ad2      	subs	r2, r2, r3
   16fc8:	08d2      	lsrs	r2, r2, #3
   16fca:	0192      	lsls	r2, r2, #6
   16fcc:	f042 0201 	orr.w	r2, r2, #1
   16fd0:	4621      	mov	r1, r4
   16fd2:	f00d f804 	bl	23fde <log_1>
}
   16fd6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			prov_failed(PROV_ERR_NVAL_FMT);
   16fda:	2002      	movs	r0, #2
   16fdc:	f7ff bc58 	b.w	16890 <prov_failed>
	} else if (seg == link.rx.last_seg) {
   16fe0:	d118      	bne.n	17014 <gen_prov_cont+0xa4>
		expect_len = (link.rx.buf->len - 20U -
   16fe2:	6979      	ldr	r1, [r7, #20]
   16fe4:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
   16fe8:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   16fec:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   16ff0:	790a      	ldrb	r2, [r1, #4]
   16ff2:	3303      	adds	r3, #3
   16ff4:	4413      	add	r3, r2
		if (expect_len != buf->len) {
   16ff6:	88b2      	ldrh	r2, [r6, #4]
		expect_len = (link.rx.buf->len - 20U -
   16ff8:	b2d9      	uxtb	r1, r3
		if (expect_len != buf->len) {
   16ffa:	4291      	cmp	r1, r2
   16ffc:	d00a      	beq.n	17014 <gen_prov_cont+0xa4>
   16ffe:	4814      	ldr	r0, [pc, #80]	; (17050 <gen_prov_cont+0xe0>)
   17000:	4b14      	ldr	r3, [pc, #80]	; (17054 <gen_prov_cont+0xe4>)
   17002:	1a1b      	subs	r3, r3, r0
   17004:	08db      	lsrs	r3, r3, #3
			BT_ERR("Incorrect last seg len: %u != %u", expect_len,
   17006:	019b      	lsls	r3, r3, #6
   17008:	4815      	ldr	r0, [pc, #84]	; (17060 <gen_prov_cont+0xf0>)
   1700a:	f043 0301 	orr.w	r3, r3, #1
   1700e:	f00c fffa 	bl	24006 <log_2>
   17012:	e7e0      	b.n	16fd6 <gen_prov_cont+0x66>
	if (!(link.rx.seg & BIT(seg))) {
   17014:	40e0      	lsrs	r0, r4
   17016:	07c3      	lsls	r3, r0, #31
   17018:	d515      	bpl.n	17046 <gen_prov_cont+0xd6>
	memcpy(XACT_SEG_DATA(seg), buf->data, buf->len);
   1701a:	696a      	ldr	r2, [r5, #20]
   1701c:	6831      	ldr	r1, [r6, #0]
   1701e:	1e60      	subs	r0, r4, #1
   17020:	2317      	movs	r3, #23
   17022:	4343      	muls	r3, r0
   17024:	6810      	ldr	r0, [r2, #0]
   17026:	88b2      	ldrh	r2, [r6, #4]
   17028:	3314      	adds	r3, #20
   1702a:	4418      	add	r0, r3
   1702c:	f00e fe3c 	bl	25ca8 <memcpy>
	XACT_SEG_RECV(seg);
   17030:	2301      	movs	r3, #1
   17032:	40a3      	lsls	r3, r4
   17034:	7c6c      	ldrb	r4, [r5, #17]
   17036:	ea24 0403 	bic.w	r4, r4, r3
   1703a:	746c      	strb	r4, [r5, #17]
	if (!link.rx.seg) {
   1703c:	b91c      	cbnz	r4, 17046 <gen_prov_cont+0xd6>
}
   1703e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		prov_msg_recv();
   17042:	f7ff bc91 	b.w	16968 <prov_msg_recv>
}
   17046:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1704a:	bf00      	nop
   1704c:	20006978 	.word	0x20006978
   17050:	00029830 	.word	0x00029830
   17054:	00029960 	.word	0x00029960
   17058:	0002fb2d 	.word	0x0002fb2d
   1705c:	0002fb59 	.word	0x0002fb59
   17060:	0002fb72 	.word	0x0002fb72

00017064 <bt_mesh_pb_adv_recv>:
{
   17064:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (!link.cb) {
   17066:	4d29      	ldr	r5, [pc, #164]	; (1710c <bt_mesh_pb_adv_recv+0xa8>)
   17068:	68ab      	ldr	r3, [r5, #8]
{
   1706a:	4604      	mov	r4, r0
	if (!link.cb) {
   1706c:	b163      	cbz	r3, 17088 <bt_mesh_pb_adv_recv+0x24>
	if (buf->len < 6) {
   1706e:	8881      	ldrh	r1, [r0, #4]
   17070:	2905      	cmp	r1, #5
   17072:	d80b      	bhi.n	1708c <bt_mesh_pb_adv_recv+0x28>
   17074:	4a26      	ldr	r2, [pc, #152]	; (17110 <bt_mesh_pb_adv_recv+0xac>)
   17076:	4b27      	ldr	r3, [pc, #156]	; (17114 <bt_mesh_pb_adv_recv+0xb0>)
		BT_WARN("Too short provisioning packet (len %u)", buf->len);
   17078:	4827      	ldr	r0, [pc, #156]	; (17118 <bt_mesh_pb_adv_recv+0xb4>)
   1707a:	1ad2      	subs	r2, r2, r3
   1707c:	08d2      	lsrs	r2, r2, #3
   1707e:	0192      	lsls	r2, r2, #6
   17080:	f042 0202 	orr.w	r2, r2, #2
		BT_ERR("Too short GPC message type %u", GPCF(rx->gpc));
   17084:	f00c ffab 	bl	23fde <log_1>
}
   17088:	b003      	add	sp, #12
   1708a:	bd30      	pop	{r4, r5, pc}
	rx.link_id = net_buf_simple_pull_be32(buf);
   1708c:	f011 fe7e 	bl	28d8c <net_buf_simple_pull_be32>
   17090:	9000      	str	r0, [sp, #0]
	rx.xact_id = net_buf_simple_pull_u8(buf);
   17092:	4620      	mov	r0, r4
   17094:	f011 fe5f 	bl	28d56 <net_buf_simple_pull_u8>
   17098:	f88d 0004 	strb.w	r0, [sp, #4]
	rx.gpc = net_buf_simple_pull_u8(buf);
   1709c:	4620      	mov	r0, r4
   1709e:	f011 fe5a 	bl	28d56 <net_buf_simple_pull_u8>
   170a2:	f88d 0005 	strb.w	r0, [sp, #5]
   170a6:	f7ff fb37 	bl	16718 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, LINK_ACTIVE) && link.id != rx.link_id) {
   170aa:	07c3      	lsls	r3, r0, #31
   170ac:	d503      	bpl.n	170b6 <bt_mesh_pb_adv_recv+0x52>
   170ae:	682a      	ldr	r2, [r5, #0]
   170b0:	9b00      	ldr	r3, [sp, #0]
   170b2:	429a      	cmp	r2, r3
   170b4:	d1e8      	bne.n	17088 <bt_mesh_pb_adv_recv+0x24>
	if (buf->len < gen_prov[GPCF(rx->gpc)].min_len) {
   170b6:	f89d 1005 	ldrb.w	r1, [sp, #5]
   170ba:	4a18      	ldr	r2, [pc, #96]	; (1711c <bt_mesh_pb_adv_recv+0xb8>)
   170bc:	88a0      	ldrh	r0, [r4, #4]
   170be:	f001 0103 	and.w	r1, r1, #3
   170c2:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
   170c6:	795b      	ldrb	r3, [r3, #5]
   170c8:	4298      	cmp	r0, r3
   170ca:	d208      	bcs.n	170de <bt_mesh_pb_adv_recv+0x7a>
   170cc:	4a10      	ldr	r2, [pc, #64]	; (17110 <bt_mesh_pb_adv_recv+0xac>)
   170ce:	4b11      	ldr	r3, [pc, #68]	; (17114 <bt_mesh_pb_adv_recv+0xb0>)
		BT_ERR("Too short GPC message type %u", GPCF(rx->gpc));
   170d0:	4813      	ldr	r0, [pc, #76]	; (17120 <bt_mesh_pb_adv_recv+0xbc>)
   170d2:	1ad2      	subs	r2, r2, r3
   170d4:	08d2      	lsrs	r2, r2, #3
   170d6:	0192      	lsls	r2, r2, #6
   170d8:	f042 0201 	orr.w	r2, r2, #1
   170dc:	e7d2      	b.n	17084 <bt_mesh_pb_adv_recv+0x20>
   170de:	f7ff fb1b 	bl	16718 <atomic_get.constprop.0>
	if (!atomic_test_bit(link.flags, LINK_ACTIVE) &&
   170e2:	f010 0f01 	tst.w	r0, #1
   170e6:	f89d 3005 	ldrb.w	r3, [sp, #5]
   170ea:	d106      	bne.n	170fa <bt_mesh_pb_adv_recv+0x96>
	    gen_prov[GPCF(rx->gpc)].require_link) {
   170ec:	f003 0103 	and.w	r1, r3, #3
   170f0:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
	if (!atomic_test_bit(link.flags, LINK_ACTIVE) &&
   170f4:	7909      	ldrb	r1, [r1, #4]
   170f6:	2900      	cmp	r1, #0
   170f8:	d1c6      	bne.n	17088 <bt_mesh_pb_adv_recv+0x24>
	gen_prov[GPCF(rx->gpc)].func(rx, buf);
   170fa:	f003 0303 	and.w	r3, r3, #3
   170fe:	4621      	mov	r1, r4
   17100:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   17104:	4668      	mov	r0, sp
   17106:	4798      	blx	r3
   17108:	e7be      	b.n	17088 <bt_mesh_pb_adv_recv+0x24>
   1710a:	bf00      	nop
   1710c:	20006978 	.word	0x20006978
   17110:	00029960 	.word	0x00029960
   17114:	00029830 	.word	0x00029830
   17118:	0002fb93 	.word	0x0002fb93
   1711c:	0002a3dc 	.word	0x0002a3dc
   17120:	0002fbba 	.word	0x0002fbba

00017124 <pb_adv_init>:

void pb_adv_init(void)
{
   17124:	b510      	push	{r4, lr}
	k_delayed_work_init(&link.prot_timer, protocol_timeout);
   17126:	4c06      	ldr	r4, [pc, #24]	; (17140 <pb_adv_init+0x1c>)
   17128:	4906      	ldr	r1, [pc, #24]	; (17144 <pb_adv_init+0x20>)
   1712a:	f104 0058 	add.w	r0, r4, #88	; 0x58
   1712e:	f012 f964 	bl	293fa <k_delayed_work_init>
	k_delayed_work_init(&link.tx.retransmit, prov_retransmit);
   17132:	f104 0038 	add.w	r0, r4, #56	; 0x38
   17136:	4904      	ldr	r1, [pc, #16]	; (17148 <pb_adv_init+0x24>)
}
   17138:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_delayed_work_init(&link.tx.retransmit, prov_retransmit);
   1713c:	f012 b95d 	b.w	293fa <k_delayed_work_init>
   17140:	20006978 	.word	0x20006978
   17144:	000166b1 	.word	0x000166b1
   17148:	00016761 	.word	0x00016761

0001714c <reset_state>:
};

static struct prov_link link;

static void reset_state(void)
{
   1714c:	b510      	push	{r4, lr}
	if (link.conn) {
   1714e:	4c08      	ldr	r4, [pc, #32]	; (17170 <reset_state+0x24>)
   17150:	6820      	ldr	r0, [r4, #0]
   17152:	b108      	cbz	r0, 17158 <reset_state+0xc>
		bt_conn_unref(link.conn);
   17154:	f00f fa2f 	bl	265b6 <bt_conn_unref>
	}

	k_delayed_work_cancel(&link.prot_timer);
   17158:	4806      	ldr	r0, [pc, #24]	; (17174 <reset_state+0x28>)
   1715a:	f00b fd91 	bl	22c80 <k_delayed_work_cancel>
	memset(&link, 0, offsetof(struct prov_link, prot_timer));
   1715e:	2210      	movs	r2, #16
   17160:	2100      	movs	r1, #0
   17162:	4803      	ldr	r0, [pc, #12]	; (17170 <reset_state+0x24>)
   17164:	f00e fdcb 	bl	25cfe <memset>

	link.rx_buf = bt_mesh_proxy_get_buf();
   17168:	f000 fc98 	bl	17a9c <bt_mesh_proxy_get_buf>
   1716c:	60e0      	str	r0, [r4, #12]
}
   1716e:	bd10      	pop	{r4, pc}
   17170:	20000c8c 	.word	0x20000c8c
   17174:	20000c9c 	.word	0x20000c9c

00017178 <link_accept>:

	return 0;
}

static int link_accept(const struct prov_bearer_cb *cb, void *cb_data)
{
   17178:	b538      	push	{r3, r4, r5, lr}
   1717a:	460c      	mov	r4, r1
   1717c:	4605      	mov	r5, r0
	bt_mesh_proxy_prov_enable();
   1717e:	f000 fc97 	bl	17ab0 <bt_mesh_proxy_prov_enable>
	bt_mesh_adv_update();
   17182:	f7f4 ffa1 	bl	c0c8 <bt_mesh_adv_update>

	link.cb = cb;
   17186:	4b02      	ldr	r3, [pc, #8]	; (17190 <link_accept+0x18>)
	link.cb_data = cb_data;

	return 0;
}
   17188:	2000      	movs	r0, #0
	link.cb_data = cb_data;
   1718a:	e9c3 5401 	strd	r5, r4, [r3, #4]
}
   1718e:	bd38      	pop	{r3, r4, r5, pc}
   17190:	20000c8c 	.word	0x20000c8c

00017194 <buf_send>:

static int buf_send(struct net_buf_simple *buf, prov_bearer_send_complete_t cb,
		    void *cb_data)
{
   17194:	b538      	push	{r3, r4, r5, lr}
	if (!link.conn) {
   17196:	4c0a      	ldr	r4, [pc, #40]	; (171c0 <buf_send+0x2c>)
   17198:	6823      	ldr	r3, [r4, #0]
{
   1719a:	4605      	mov	r5, r0
	if (!link.conn) {
   1719c:	b16b      	cbz	r3, 171ba <buf_send+0x26>
   1719e:	f104 0110 	add.w	r1, r4, #16
   171a2:	f64e 2260 	movw	r2, #60000	; 0xea60
   171a6:	4807      	ldr	r0, [pc, #28]	; (171c4 <buf_send+0x30>)
   171a8:	f00b fcda 	bl	22b60 <k_delayed_work_submit_to_queue>
		return -ENOTCONN;
	}

	k_delayed_work_submit(&link.prot_timer, PROTOCOL_TIMEOUT);

	return bt_mesh_proxy_send(link.conn, BT_MESH_PROXY_PROV, buf);
   171ac:	6820      	ldr	r0, [r4, #0]
   171ae:	462a      	mov	r2, r5
   171b0:	2103      	movs	r1, #3
}
   171b2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_mesh_proxy_send(link.conn, BT_MESH_PROXY_PROV, buf);
   171b6:	f000 bd0f 	b.w	17bd8 <bt_mesh_proxy_send>
}
   171ba:	f06f 0038 	mvn.w	r0, #56	; 0x38
   171be:	bd38      	pop	{r3, r4, r5, pc}
   171c0:	20000c8c 	.word	0x20000c8c
   171c4:	20001dc4 	.word	0x20001dc4

000171c8 <bt_mesh_pb_gatt_recv>:
{
   171c8:	b538      	push	{r3, r4, r5, lr}
	if (link.conn != conn || !link.cb) {
   171ca:	4c19      	ldr	r4, [pc, #100]	; (17230 <bt_mesh_pb_gatt_recv+0x68>)
   171cc:	6823      	ldr	r3, [r4, #0]
   171ce:	4283      	cmp	r3, r0
{
   171d0:	460d      	mov	r5, r1
	if (link.conn != conn || !link.cb) {
   171d2:	d101      	bne.n	171d8 <bt_mesh_pb_gatt_recv+0x10>
   171d4:	6863      	ldr	r3, [r4, #4]
   171d6:	b963      	cbnz	r3, 171f2 <bt_mesh_pb_gatt_recv+0x2a>
   171d8:	4b16      	ldr	r3, [pc, #88]	; (17234 <bt_mesh_pb_gatt_recv+0x6c>)
   171da:	4917      	ldr	r1, [pc, #92]	; (17238 <bt_mesh_pb_gatt_recv+0x70>)
		BT_WARN("Data for unexpected connection");
   171dc:	4817      	ldr	r0, [pc, #92]	; (1723c <bt_mesh_pb_gatt_recv+0x74>)
   171de:	1ac9      	subs	r1, r1, r3
   171e0:	08c9      	lsrs	r1, r1, #3
   171e2:	0189      	lsls	r1, r1, #6
   171e4:	f041 0102 	orr.w	r1, r1, #2
   171e8:	f00c feec 	bl	23fc4 <log_0>
		return -ENOTCONN;
   171ec:	f06f 0038 	mvn.w	r0, #56	; 0x38
}
   171f0:	bd38      	pop	{r3, r4, r5, pc}
	if (buf->len < 1) {
   171f2:	8889      	ldrh	r1, [r1, #4]
   171f4:	b961      	cbnz	r1, 17210 <bt_mesh_pb_gatt_recv+0x48>
   171f6:	4b0f      	ldr	r3, [pc, #60]	; (17234 <bt_mesh_pb_gatt_recv+0x6c>)
   171f8:	4a0f      	ldr	r2, [pc, #60]	; (17238 <bt_mesh_pb_gatt_recv+0x70>)
		BT_WARN("Too short provisioning packet (len %u)", buf->len);
   171fa:	4811      	ldr	r0, [pc, #68]	; (17240 <bt_mesh_pb_gatt_recv+0x78>)
   171fc:	1ad2      	subs	r2, r2, r3
   171fe:	08d2      	lsrs	r2, r2, #3
   17200:	0192      	lsls	r2, r2, #6
   17202:	f042 0202 	orr.w	r2, r2, #2
   17206:	f00c feea 	bl	23fde <log_1>
		return -EINVAL;
   1720a:	f06f 0015 	mvn.w	r0, #21
   1720e:	e7ef      	b.n	171f0 <bt_mesh_pb_gatt_recv+0x28>
   17210:	f64e 2260 	movw	r2, #60000	; 0xea60
   17214:	f104 0110 	add.w	r1, r4, #16
   17218:	480a      	ldr	r0, [pc, #40]	; (17244 <bt_mesh_pb_gatt_recv+0x7c>)
   1721a:	f00b fca1 	bl	22b60 <k_delayed_work_submit_to_queue>
	link.cb->recv(&pb_gatt, link.cb_data, buf);
   1721e:	6863      	ldr	r3, [r4, #4]
   17220:	4809      	ldr	r0, [pc, #36]	; (17248 <bt_mesh_pb_gatt_recv+0x80>)
   17222:	68db      	ldr	r3, [r3, #12]
   17224:	68a1      	ldr	r1, [r4, #8]
   17226:	462a      	mov	r2, r5
   17228:	4798      	blx	r3
	return 0;
   1722a:	2000      	movs	r0, #0
   1722c:	e7e0      	b.n	171f0 <bt_mesh_pb_gatt_recv+0x28>
   1722e:	bf00      	nop
   17230:	20000c8c 	.word	0x20000c8c
   17234:	00029830 	.word	0x00029830
   17238:	00029968 	.word	0x00029968
   1723c:	0002fbe7 	.word	0x0002fbe7
   17240:	0002fb93 	.word	0x0002fb93
   17244:	20001dc4 	.word	0x20001dc4
   17248:	0002a414 	.word	0x0002a414

0001724c <bt_mesh_pb_gatt_open>:
{
   1724c:	b538      	push	{r3, r4, r5, lr}
	if (link.conn) {
   1724e:	4d0b      	ldr	r5, [pc, #44]	; (1727c <bt_mesh_pb_gatt_open+0x30>)
   17250:	682c      	ldr	r4, [r5, #0]
   17252:	b984      	cbnz	r4, 17276 <bt_mesh_pb_gatt_open+0x2a>
	link.conn = bt_conn_ref(conn);
   17254:	f00f f9a8 	bl	265a8 <bt_conn_ref>
   17258:	4629      	mov	r1, r5
   1725a:	f64e 2260 	movw	r2, #60000	; 0xea60
   1725e:	f841 0b10 	str.w	r0, [r1], #16
   17262:	4807      	ldr	r0, [pc, #28]	; (17280 <bt_mesh_pb_gatt_open+0x34>)
   17264:	f00b fc7c 	bl	22b60 <k_delayed_work_submit_to_queue>
	link.cb->link_opened(&pb_gatt, link.cb_data);
   17268:	686b      	ldr	r3, [r5, #4]
   1726a:	4806      	ldr	r0, [pc, #24]	; (17284 <bt_mesh_pb_gatt_open+0x38>)
   1726c:	681b      	ldr	r3, [r3, #0]
   1726e:	68a9      	ldr	r1, [r5, #8]
   17270:	4798      	blx	r3
	return 0;
   17272:	4620      	mov	r0, r4
}
   17274:	bd38      	pop	{r3, r4, r5, pc}
		return -EBUSY;
   17276:	f06f 000f 	mvn.w	r0, #15
   1727a:	e7fb      	b.n	17274 <bt_mesh_pb_gatt_open+0x28>
   1727c:	20000c8c 	.word	0x20000c8c
   17280:	20001dc4 	.word	0x20001dc4
   17284:	0002a414 	.word	0x0002a414

00017288 <bt_mesh_pb_gatt_close>:
	if (link.conn != conn) {
   17288:	4b0d      	ldr	r3, [pc, #52]	; (172c0 <bt_mesh_pb_gatt_close+0x38>)
   1728a:	681a      	ldr	r2, [r3, #0]
   1728c:	4282      	cmp	r2, r0
{
   1728e:	b510      	push	{r4, lr}
	if (link.conn != conn) {
   17290:	d00c      	beq.n	172ac <bt_mesh_pb_gatt_close+0x24>
   17292:	4b0c      	ldr	r3, [pc, #48]	; (172c4 <bt_mesh_pb_gatt_close+0x3c>)
   17294:	490c      	ldr	r1, [pc, #48]	; (172c8 <bt_mesh_pb_gatt_close+0x40>)
		BT_ERR("Not connected");
   17296:	480d      	ldr	r0, [pc, #52]	; (172cc <bt_mesh_pb_gatt_close+0x44>)
   17298:	1ac9      	subs	r1, r1, r3
   1729a:	08c9      	lsrs	r1, r1, #3
   1729c:	0189      	lsls	r1, r1, #6
   1729e:	f041 0101 	orr.w	r1, r1, #1
   172a2:	f00c fe8f 	bl	23fc4 <log_0>
		return -ENOTCONN;
   172a6:	f06f 0038 	mvn.w	r0, #56	; 0x38
}
   172aa:	bd10      	pop	{r4, pc}
	link.cb->link_closed(&pb_gatt, link.cb_data,
   172ac:	685a      	ldr	r2, [r3, #4]
   172ae:	4808      	ldr	r0, [pc, #32]	; (172d0 <bt_mesh_pb_gatt_close+0x48>)
   172b0:	6854      	ldr	r4, [r2, #4]
   172b2:	6899      	ldr	r1, [r3, #8]
   172b4:	2200      	movs	r2, #0
   172b6:	47a0      	blx	r4
	reset_state();
   172b8:	f7ff ff48 	bl	1714c <reset_state>
	return 0;
   172bc:	2000      	movs	r0, #0
   172be:	e7f4      	b.n	172aa <bt_mesh_pb_gatt_close+0x22>
   172c0:	20000c8c 	.word	0x20000c8c
   172c4:	00029830 	.word	0x00029830
   172c8:	00029968 	.word	0x00029968
   172cc:	0002c883 	.word	0x0002c883
   172d0:	0002a414 	.word	0x0002a414

000172d4 <protocol_timeout>:
{
   172d4:	b570      	push	{r4, r5, r6, lr}
	const struct prov_bearer_cb *cb = link.cb;
   172d6:	4c07      	ldr	r4, [pc, #28]	; (172f4 <protocol_timeout+0x20>)
	if (link.conn) {
   172d8:	e9d4 0500 	ldrd	r0, r5, [r4]
   172dc:	b108      	cbz	r0, 172e2 <protocol_timeout+0xe>
		bt_mesh_pb_gatt_close(link.conn);
   172de:	f7ff ffd3 	bl	17288 <bt_mesh_pb_gatt_close>
	reset_state();
   172e2:	f7ff ff33 	bl	1714c <reset_state>
	cb->link_closed(&pb_gatt, link.cb_data,
   172e6:	686b      	ldr	r3, [r5, #4]
   172e8:	68a1      	ldr	r1, [r4, #8]
   172ea:	4803      	ldr	r0, [pc, #12]	; (172f8 <protocol_timeout+0x24>)
}
   172ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	cb->link_closed(&pb_gatt, link.cb_data,
   172f0:	2201      	movs	r2, #1
   172f2:	4718      	bx	r3
   172f4:	20000c8c 	.word	0x20000c8c
   172f8:	0002a414 	.word	0x0002a414

000172fc <pb_gatt_init>:
	/* No action */
}

void pb_gatt_init(void)
{
	k_delayed_work_init(&link.prot_timer, protocol_timeout);
   172fc:	4901      	ldr	r1, [pc, #4]	; (17304 <pb_gatt_init+0x8>)
   172fe:	4802      	ldr	r0, [pc, #8]	; (17308 <pb_gatt_init+0xc>)
   17300:	f012 b87b 	b.w	293fa <k_delayed_work_init>
   17304:	000172d5 	.word	0x000172d5
   17308:	20000c9c 	.word	0x20000c9c

0001730c <proxy_sar_timeout>:
   1730c:	4b0a      	ldr	r3, [pc, #40]	; (17338 <proxy_sar_timeout+0x2c>)
   1730e:	490b      	ldr	r1, [pc, #44]	; (1733c <proxy_sar_timeout+0x30>)
   17310:	1ac9      	subs	r1, r1, r3
   17312:	08c9      	lsrs	r1, r1, #3

	return NULL;
}

static void proxy_sar_timeout(struct k_work *work)
{
   17314:	b510      	push	{r4, lr}
	struct bt_mesh_proxy_client *client;

	BT_WARN("Proxy SAR timeout");
   17316:	0189      	lsls	r1, r1, #6
{
   17318:	4604      	mov	r4, r0
	BT_WARN("Proxy SAR timeout");
   1731a:	f041 0102 	orr.w	r1, r1, #2
   1731e:	4808      	ldr	r0, [pc, #32]	; (17340 <proxy_sar_timeout+0x34>)
   17320:	f00c fe50 	bl	23fc4 <log_0>

	client = CONTAINER_OF(work, struct bt_mesh_proxy_client, sar_timer);
	if (client->conn) {
   17324:	f854 0c18 	ldr.w	r0, [r4, #-24]
   17328:	b120      	cbz	r0, 17334 <proxy_sar_timeout+0x28>
		bt_conn_disconnect(client->conn,
				   BT_HCI_ERR_REMOTE_USER_TERM_CONN);
	}
}
   1732a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_conn_disconnect(client->conn,
   1732e:	2113      	movs	r1, #19
   17330:	f00f b944 	b.w	265bc <bt_conn_disconnect>
}
   17334:	bd10      	pop	{r4, pc}
   17336:	bf00      	nop
   17338:	00029830 	.word	0x00029830
   1733c:	00029978 	.word	0x00029978
   17340:	0002fc16 	.word	0x0002fc16

00017344 <proxy_disconnected>:
{
	int i;

	BT_DBG("conn %p reason 0x%02x", conn, reason);

	conn_count--;
   17344:	4a0c      	ldr	r2, [pc, #48]	; (17378 <proxy_disconnected+0x34>)
   17346:	6813      	ldr	r3, [r2, #0]
{
   17348:	b510      	push	{r4, lr}

	for (i = 0; i < ARRAY_SIZE(clients); i++) {
		struct bt_mesh_proxy_client *client = &clients[i];

		if (client->conn == conn) {
   1734a:	4c0c      	ldr	r4, [pc, #48]	; (1737c <proxy_disconnected+0x38>)
	conn_count--;
   1734c:	3b01      	subs	r3, #1
   1734e:	6013      	str	r3, [r2, #0]
		if (client->conn == conn) {
   17350:	6823      	ldr	r3, [r4, #0]
   17352:	4283      	cmp	r3, r0
   17354:	d10c      	bne.n	17370 <proxy_disconnected+0x2c>
			if (IS_ENABLED(CONFIG_BT_MESH_PB_GATT) &&
   17356:	7aa3      	ldrb	r3, [r4, #10]
   17358:	2b03      	cmp	r3, #3
   1735a:	d101      	bne.n	17360 <proxy_disconnected+0x1c>
			    client->filter_type == PROV) {
				bt_mesh_pb_gatt_close(conn);
   1735c:	f7ff ff94 	bl	17288 <bt_mesh_pb_gatt_close>
			}

			k_delayed_work_cancel(&client->sar_timer);
   17360:	4807      	ldr	r0, [pc, #28]	; (17380 <proxy_disconnected+0x3c>)
   17362:	f00b fc8d 	bl	22c80 <k_delayed_work_cancel>
			bt_conn_unref(client->conn);
   17366:	6820      	ldr	r0, [r4, #0]
   17368:	f00f f925 	bl	265b6 <bt_conn_unref>
			client->conn = NULL;
   1736c:	2300      	movs	r3, #0
   1736e:	6023      	str	r3, [r4, #0]
			break;
		}
	}

	bt_mesh_adv_update();
}
   17370:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_mesh_adv_update();
   17374:	f7f4 bea8 	b.w	c0c8 <bt_mesh_adv_update>
   17378:	20000cbc 	.word	0x20000cbc
   1737c:	20006f38 	.word	0x20006f38
   17380:	20006f50 	.word	0x20006f50

00017384 <prov_ccc_write.part.0>:
static void prov_ccc_changed(const struct bt_gatt_attr *attr, u16_t value)
{
	BT_DBG("value 0x%04x", value);
}

static ssize_t prov_ccc_write(struct bt_conn *conn,
   17384:	b508      	push	{r3, lr}
   17386:	4a07      	ldr	r2, [pc, #28]	; (173a4 <prov_ccc_write.part.0+0x20>)
   17388:	4b07      	ldr	r3, [pc, #28]	; (173a8 <prov_ccc_write.part.0+0x24>)
   1738a:	1ad2      	subs	r2, r2, r3
   1738c:	08d2      	lsrs	r2, r2, #3
	struct bt_mesh_proxy_client *client;

	BT_DBG("value 0x%04x", value);

	if (value != BT_GATT_CCC_NOTIFY) {
		BT_WARN("Client wrote 0x%04x instead enabling notify", value);
   1738e:	0192      	lsls	r2, r2, #6
static ssize_t prov_ccc_write(struct bt_conn *conn,
   17390:	4601      	mov	r1, r0
		BT_WARN("Client wrote 0x%04x instead enabling notify", value);
   17392:	f042 0202 	orr.w	r2, r2, #2
   17396:	4805      	ldr	r0, [pc, #20]	; (173ac <prov_ccc_write.part.0+0x28>)
   17398:	f00c fe21 	bl	23fde <log_1>
		client->filter_type = PROV;
		bt_mesh_pb_gatt_open(conn);
	}

	return sizeof(value);
}
   1739c:	f06f 0012 	mvn.w	r0, #18
   173a0:	bd08      	pop	{r3, pc}
   173a2:	bf00      	nop
   173a4:	00029978 	.word	0x00029978
   173a8:	00029830 	.word	0x00029830
   173ac:	0002fc28 	.word	0x0002fc28

000173b0 <proxy_connected>:
	conn_count++;
   173b0:	4a14      	ldr	r2, [pc, #80]	; (17404 <proxy_connected+0x54>)
   173b2:	6813      	ldr	r3, [r2, #0]
   173b4:	3301      	adds	r3, #1
{
   173b6:	b570      	push	{r4, r5, r6, lr}
	proxy_adv_enabled = false;
   173b8:	2100      	movs	r1, #0
	conn_count++;
   173ba:	6013      	str	r3, [r2, #0]
	proxy_adv_enabled = false;
   173bc:	4a12      	ldr	r2, [pc, #72]	; (17408 <proxy_connected+0x58>)
	if (conn_count < CONFIG_BT_MAX_CONN) {
   173be:	428b      	cmp	r3, r1
{
   173c0:	4606      	mov	r6, r0
	proxy_adv_enabled = false;
   173c2:	7011      	strb	r1, [r2, #0]
	if (conn_count < CONFIG_BT_MAX_CONN) {
   173c4:	dc01      	bgt.n	173ca <proxy_connected+0x1a>
		bt_mesh_adv_update();
   173c6:	f7f4 fe7f 	bl	c0c8 <bt_mesh_adv_update>
		if (!clients[i].conn) {
   173ca:	4c10      	ldr	r4, [pc, #64]	; (1740c <proxy_connected+0x5c>)
   173cc:	6825      	ldr	r5, [r4, #0]
   173ce:	b15d      	cbz	r5, 173e8 <proxy_connected+0x38>
   173d0:	490f      	ldr	r1, [pc, #60]	; (17410 <proxy_connected+0x60>)
   173d2:	4b10      	ldr	r3, [pc, #64]	; (17414 <proxy_connected+0x64>)
		BT_ERR("No free Proxy Client objects");
   173d4:	4810      	ldr	r0, [pc, #64]	; (17418 <proxy_connected+0x68>)
   173d6:	1ac9      	subs	r1, r1, r3
   173d8:	08c9      	lsrs	r1, r1, #3
   173da:	0189      	lsls	r1, r1, #6
}
   173dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("No free Proxy Client objects");
   173e0:	f041 0101 	orr.w	r1, r1, #1
   173e4:	f00c bdee 	b.w	23fc4 <log_0>
	client->conn = bt_conn_ref(conn);
   173e8:	4630      	mov	r0, r6
   173ea:	f00f f8dd 	bl	265a8 <bt_conn_ref>
	(void)memset(client->filter, 0, sizeof(client->filter));
   173ee:	2206      	movs	r2, #6
	client->conn = bt_conn_ref(conn);
   173f0:	6020      	str	r0, [r4, #0]
	(void)memset(client->filter, 0, sizeof(client->filter));
   173f2:	4629      	mov	r1, r5
   173f4:	1d20      	adds	r0, r4, #4
	client->filter_type = NONE;
   173f6:	72a5      	strb	r5, [r4, #10]
	(void)memset(client->filter, 0, sizeof(client->filter));
   173f8:	f00e fc81 	bl	25cfe <memset>
	buf->data = buf->__buf;
   173fc:	6c23      	ldr	r3, [r4, #64]	; 0x40
	buf->len  = 0U;
   173fe:	87a5      	strh	r5, [r4, #60]	; 0x3c
	buf->data = buf->__buf;
   17400:	63a3      	str	r3, [r4, #56]	; 0x38
}
   17402:	bd70      	pop	{r4, r5, r6, pc}
   17404:	20000cbc 	.word	0x20000cbc
   17408:	200024c7 	.word	0x200024c7
   1740c:	20006f38 	.word	0x20006f38
   17410:	00029978 	.word	0x00029978
   17414:	00029830 	.word	0x00029830
   17418:	0002fc54 	.word	0x0002fc54

0001741c <proxy_send>:
}

#endif /* CONFIG_BT_MESH_GATT_PROXY */

static int proxy_send(struct bt_conn *conn, const void *data, u16_t len)
{
   1741c:	b570      	push	{r4, r5, r6, lr}
	BT_DBG("%u bytes: %s", len, bt_hex(data, len));

#if defined(CONFIG_BT_MESH_GATT_PROXY)
	if (gatt_svc == MESH_GATT_PROXY) {
   1741e:	4b11      	ldr	r3, [pc, #68]	; (17464 <proxy_send+0x48>)
   17420:	781b      	ldrb	r3, [r3, #0]
   17422:	2b02      	cmp	r3, #2
{
   17424:	b086      	sub	sp, #24
   17426:	4604      	mov	r4, r0
   17428:	460e      	mov	r6, r1
   1742a:	4615      	mov	r5, r2
	if (gatt_svc == MESH_GATT_PROXY) {
   1742c:	d10f      	bne.n	1744e <proxy_send+0x32>
				 const struct bt_gatt_attr *attr,
				 const void *data, u16_t len)
{
	struct bt_gatt_notify_params params;

	memset(&params, 0, sizeof(params));
   1742e:	2218      	movs	r2, #24
   17430:	2100      	movs	r1, #0
   17432:	4668      	mov	r0, sp
   17434:	f00e fc63 	bl	25cfe <memset>

	params.attr = attr;
   17438:	4b0b      	ldr	r3, [pc, #44]	; (17468 <proxy_send+0x4c>)
	params.data = data;
	params.len = len;
   1743a:	f8ad 500c 	strh.w	r5, [sp, #12]

	return bt_gatt_notify_cb(conn, &params);
   1743e:	4669      	mov	r1, sp
   17440:	4620      	mov	r0, r4
	params.data = data;
   17442:	e9cd 3601 	strd	r3, r6, [sp, #4]
	return bt_gatt_notify_cb(conn, &params);
   17446:	f7f4 f9a3 	bl	b790 <bt_gatt_notify_cb>
		return bt_gatt_notify(conn, &prov_attrs[3], data, len);
	}
#endif

	return 0;
}
   1744a:	b006      	add	sp, #24
   1744c:	bd70      	pop	{r4, r5, r6, pc}
	if (gatt_svc == MESH_GATT_PROV) {
   1744e:	2b01      	cmp	r3, #1
   17450:	d106      	bne.n	17460 <proxy_send+0x44>
	memset(&params, 0, sizeof(params));
   17452:	2218      	movs	r2, #24
   17454:	2100      	movs	r1, #0
   17456:	4668      	mov	r0, sp
   17458:	f00e fc51 	bl	25cfe <memset>
	params.attr = attr;
   1745c:	4b03      	ldr	r3, [pc, #12]	; (1746c <proxy_send+0x50>)
   1745e:	e7ec      	b.n	1743a <proxy_send+0x1e>
	return 0;
   17460:	2000      	movs	r0, #0
   17462:	e7f2      	b.n	1744a <proxy_send+0x2e>
   17464:	200024c5 	.word	0x200024c5
   17468:	20007068 	.word	0x20007068
   1746c:	20006fcc 	.word	0x20006fcc

00017470 <proxy_send_beacons>:
{
   17470:	b538      	push	{r3, r4, r5, lr}
		if (sub->net_idx != BT_MESH_KEY_UNUSED) {
   17472:	4c0e      	ldr	r4, [pc, #56]	; (174ac <proxy_send_beacons+0x3c>)
   17474:	f8b4 21b8 	ldrh.w	r2, [r4, #440]	; 0x1b8
   17478:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1747c:	429a      	cmp	r2, r3
{
   1747e:	4605      	mov	r5, r0
		if (sub->net_idx != BT_MESH_KEY_UNUSED) {
   17480:	d005      	beq.n	1748e <proxy_send_beacons+0x1e>
			beacon_send(client->conn, sub);
   17482:	f850 0c0c 	ldr.w	r0, [r0, #-12]
   17486:	f504 71ce 	add.w	r1, r4, #412	; 0x19c
   1748a:	f010 fd98 	bl	27fbe <beacon_send>
		if (sub->net_idx != BT_MESH_KEY_UNUSED) {
   1748e:	f8b4 229c 	ldrh.w	r2, [r4, #668]	; 0x29c
   17492:	f64f 73ff 	movw	r3, #65535	; 0xffff
   17496:	429a      	cmp	r2, r3
   17498:	d006      	beq.n	174a8 <proxy_send_beacons+0x38>
			beacon_send(client->conn, sub);
   1749a:	f855 0c0c 	ldr.w	r0, [r5, #-12]
   1749e:	4904      	ldr	r1, [pc, #16]	; (174b0 <proxy_send_beacons+0x40>)
}
   174a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			beacon_send(client->conn, sub);
   174a4:	f010 bd8b 	b.w	27fbe <beacon_send>
}
   174a8:	bd38      	pop	{r3, r4, r5, pc}
   174aa:	bf00      	nop
   174ac:	20006b48 	.word	0x20006b48
   174b0:	20006dc8 	.word	0x20006dc8

000174b4 <send_filter_status>:
{
   174b4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct bt_mesh_net_tx tx = {
   174b6:	f851 3b04 	ldr.w	r3, [r1], #4
   174ba:	2600      	movs	r6, #0
{
   174bc:	4614      	mov	r4, r2
   174be:	4605      	mov	r5, r0
	struct bt_mesh_net_tx tx = {
   174c0:	e9cd 3101 	strd	r3, r1, [sp, #4]
   174c4:	9603      	str	r6, [sp, #12]
		.src = bt_mesh_primary_addr(),
   174c6:	f7f8 faf1 	bl	faac <bt_mesh_primary_addr>
	tx.ctx->addr = BT_MESH_ADDR_UNASSIGNED;
   174ca:	9b02      	ldr	r3, [sp, #8]
	struct bt_mesh_net_tx tx = {
   174cc:	f8ad 000c 	strh.w	r0, [sp, #12]
	tx.ctx->addr = BT_MESH_ADDR_UNASSIGNED;
   174d0:	809e      	strh	r6, [r3, #4]
   174d2:	68a3      	ldr	r3, [r4, #8]
   174d4:	6023      	str	r3, [r4, #0]
	net_buf_simple_reserve(buf, 10);
   174d6:	210a      	movs	r1, #10
   174d8:	4620      	mov	r0, r4
	buf->len  = 0U;
   174da:	80a6      	strh	r6, [r4, #4]
   174dc:	f007 fcf0 	bl	1eec0 <net_buf_simple_reserve>
	net_buf_simple_add_u8(buf, CFG_FILTER_STATUS);
   174e0:	2103      	movs	r1, #3
   174e2:	4620      	mov	r0, r4
   174e4:	f011 fc73 	bl	28dce <net_buf_simple_add_u8>
	if (client->filter_type == WHITELIST) {
   174e8:	7aab      	ldrb	r3, [r5, #10]
   174ea:	2b01      	cmp	r3, #1
		net_buf_simple_add_u8(buf, 0x00);
   174ec:	bf0c      	ite	eq
   174ee:	4631      	moveq	r1, r6
		net_buf_simple_add_u8(buf, 0x01);
   174f0:	2101      	movne	r1, #1
   174f2:	4620      	mov	r0, r4
   174f4:	f011 fc6b 	bl	28dce <net_buf_simple_add_u8>
		if (client->filter[i] != BT_MESH_ADDR_UNASSIGNED) {
   174f8:	88a9      	ldrh	r1, [r5, #4]
   174fa:	88eb      	ldrh	r3, [r5, #6]
	for (filter_size = 0U, i = 0; i < ARRAY_SIZE(client->filter); i++) {
   174fc:	3900      	subs	r1, #0
   174fe:	bf18      	it	ne
   17500:	2101      	movne	r1, #1
		if (client->filter[i] != BT_MESH_ADDR_UNASSIGNED) {
   17502:	b103      	cbz	r3, 17506 <send_filter_status+0x52>
			filter_size++;
   17504:	3101      	adds	r1, #1
		if (client->filter[i] != BT_MESH_ADDR_UNASSIGNED) {
   17506:	892b      	ldrh	r3, [r5, #8]
   17508:	b10b      	cbz	r3, 1750e <send_filter_status+0x5a>
			filter_size++;
   1750a:	3101      	adds	r1, #1
   1750c:	b289      	uxth	r1, r1
	net_buf_simple_add_be16(buf, filter_size);
   1750e:	4620      	mov	r0, r4
   17510:	f011 fc6d 	bl	28dee <net_buf_simple_add_be16>
	err = bt_mesh_net_encode(&tx, buf, true);
   17514:	4621      	mov	r1, r4
   17516:	2201      	movs	r2, #1
   17518:	a801      	add	r0, sp, #4
   1751a:	f7f5 fe77 	bl	d20c <bt_mesh_net_encode>
	if (err) {
   1751e:	4601      	mov	r1, r0
   17520:	b158      	cbz	r0, 1753a <send_filter_status+0x86>
   17522:	4a0e      	ldr	r2, [pc, #56]	; (1755c <send_filter_status+0xa8>)
   17524:	4b0e      	ldr	r3, [pc, #56]	; (17560 <send_filter_status+0xac>)
		BT_ERR("Encoding Proxy cfg message failed (err %d)", err);
   17526:	480f      	ldr	r0, [pc, #60]	; (17564 <send_filter_status+0xb0>)
   17528:	1ad2      	subs	r2, r2, r3
   1752a:	08d2      	lsrs	r2, r2, #3
   1752c:	0192      	lsls	r2, r2, #6
   1752e:	f042 0201 	orr.w	r2, r2, #1
		BT_ERR("Failed to send proxy cfg message (err %d)", err);
   17532:	f00c fd54 	bl	23fde <log_1>
}
   17536:	b004      	add	sp, #16
   17538:	bd70      	pop	{r4, r5, r6, pc}
	err = proxy_segment_and_send(client->conn, BT_MESH_PROXY_CONFIG, buf);
   1753a:	2102      	movs	r1, #2
   1753c:	6828      	ldr	r0, [r5, #0]
   1753e:	4622      	mov	r2, r4
   17540:	f010 fcf4 	bl	27f2c <proxy_segment_and_send>
	if (err) {
   17544:	4601      	mov	r1, r0
   17546:	2800      	cmp	r0, #0
   17548:	d0f5      	beq.n	17536 <send_filter_status+0x82>
   1754a:	4a04      	ldr	r2, [pc, #16]	; (1755c <send_filter_status+0xa8>)
   1754c:	4b04      	ldr	r3, [pc, #16]	; (17560 <send_filter_status+0xac>)
		BT_ERR("Failed to send proxy cfg message (err %d)", err);
   1754e:	4806      	ldr	r0, [pc, #24]	; (17568 <send_filter_status+0xb4>)
   17550:	1ad2      	subs	r2, r2, r3
   17552:	08d2      	lsrs	r2, r2, #3
   17554:	0192      	lsls	r2, r2, #6
   17556:	f042 0201 	orr.w	r2, r2, #1
   1755a:	e7ea      	b.n	17532 <send_filter_status+0x7e>
   1755c:	00029978 	.word	0x00029978
   17560:	00029830 	.word	0x00029830
   17564:	0002fc71 	.word	0x0002fc71
   17568:	0002fc9c 	.word	0x0002fc9c

0001756c <proxy_ccc_write>:
	if (value != BT_GATT_CCC_NOTIFY) {
   1756c:	2a01      	cmp	r2, #1
{
   1756e:	b508      	push	{r3, lr}
   17570:	4603      	mov	r3, r0
   17572:	4610      	mov	r0, r2
	if (value != BT_GATT_CCC_NOTIFY) {
   17574:	d115      	bne.n	175a2 <proxy_ccc_write+0x36>
		if (clients[i].conn == conn) {
   17576:	491a      	ldr	r1, [pc, #104]	; (175e0 <proxy_ccc_write+0x74>)
   17578:	680a      	ldr	r2, [r1, #0]
   1757a:	4293      	cmp	r3, r2
   1757c:	d015      	beq.n	175aa <proxy_ccc_write+0x3e>
	__ASSERT(client, "No client for connection");
   1757e:	4a19      	ldr	r2, [pc, #100]	; (175e4 <proxy_ccc_write+0x78>)
   17580:	4919      	ldr	r1, [pc, #100]	; (175e8 <proxy_ccc_write+0x7c>)
   17582:	481a      	ldr	r0, [pc, #104]	; (175ec <proxy_ccc_write+0x80>)
   17584:	f44f 733b 	mov.w	r3, #748	; 0x2ec
   17588:	f00c fcab 	bl	23ee2 <printk>
   1758c:	4818      	ldr	r0, [pc, #96]	; (175f0 <proxy_ccc_write+0x84>)
   1758e:	f00c fca8 	bl	23ee2 <printk>
   17592:	4814      	ldr	r0, [pc, #80]	; (175e4 <proxy_ccc_write+0x78>)
   17594:	f44f 713b 	mov.w	r1, #748	; 0x2ec
   17598:	f00c fce6 	bl	23f68 <assert_post_action>
	if (client->filter_type == NONE) {
   1759c:	2300      	movs	r3, #0
   1759e:	7a9b      	ldrb	r3, [r3, #10]
   175a0:	deff      	udf	#255	; 0xff
}
   175a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   175a6:	f7ff beed 	b.w	17384 <prov_ccc_write.part.0>
	if (client->filter_type == NONE) {
   175aa:	7a8b      	ldrb	r3, [r1, #10]
   175ac:	b9ab      	cbnz	r3, 175da <proxy_ccc_write+0x6e>
		client->filter_type = WHITELIST;
   175ae:	7288      	strb	r0, [r1, #10]
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   175b0:	f101 0314 	add.w	r3, r1, #20
   175b4:	f3bf 8f5b 	dmb	ish
   175b8:	e853 2f00 	ldrex	r2, [r3]
   175bc:	f042 0001 	orr.w	r0, r2, #1
   175c0:	e843 0c00 	strex	ip, r0, [r3]
   175c4:	f1bc 0f00 	cmp.w	ip, #0
   175c8:	d1f6      	bne.n	175b8 <proxy_ccc_write+0x4c>
   175ca:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   175ce:	07d3      	lsls	r3, r2, #31
   175d0:	d403      	bmi.n	175da <proxy_ccc_write+0x6e>
		k_queue_append(&work_q->queue, work);
   175d2:	4808      	ldr	r0, [pc, #32]	; (175f4 <proxy_ccc_write+0x88>)
   175d4:	310c      	adds	r1, #12
   175d6:	f011 fe3c 	bl	29252 <k_queue_append>
}
   175da:	2002      	movs	r0, #2
   175dc:	bd08      	pop	{r3, pc}
   175de:	bf00      	nop
   175e0:	20006f38 	.word	0x20006f38
   175e4:	0002fcc6 	.word	0x0002fcc6
   175e8:	0002fcf7 	.word	0x0002fcf7
   175ec:	0002a5e8 	.word	0x0002a5e8
   175f0:	0002fcfe 	.word	0x0002fcfe
   175f4:	20001dc4 	.word	0x20001dc4

000175f8 <prov_ccc_write>:
	if (value != BT_GATT_CCC_NOTIFY) {
   175f8:	2a01      	cmp	r2, #1
{
   175fa:	b508      	push	{r3, lr}
	if (value != BT_GATT_CCC_NOTIFY) {
   175fc:	d115      	bne.n	1762a <prov_ccc_write+0x32>
		if (clients[i].conn == conn) {
   175fe:	4b11      	ldr	r3, [pc, #68]	; (17644 <prov_ccc_write+0x4c>)
   17600:	681a      	ldr	r2, [r3, #0]
   17602:	4290      	cmp	r0, r2
   17604:	d016      	beq.n	17634 <prov_ccc_write+0x3c>
	__ASSERT(client, "No client for connection");
   17606:	4a10      	ldr	r2, [pc, #64]	; (17648 <prov_ccc_write+0x50>)
   17608:	4910      	ldr	r1, [pc, #64]	; (1764c <prov_ccc_write+0x54>)
   1760a:	4811      	ldr	r0, [pc, #68]	; (17650 <prov_ccc_write+0x58>)
   1760c:	f240 2375 	movw	r3, #629	; 0x275
   17610:	f00c fc67 	bl	23ee2 <printk>
   17614:	480f      	ldr	r0, [pc, #60]	; (17654 <prov_ccc_write+0x5c>)
   17616:	f00c fc64 	bl	23ee2 <printk>
   1761a:	480b      	ldr	r0, [pc, #44]	; (17648 <prov_ccc_write+0x50>)
   1761c:	f240 2175 	movw	r1, #629	; 0x275
   17620:	f00c fca2 	bl	23f68 <assert_post_action>
	if (client->filter_type == NONE) {
   17624:	2300      	movs	r3, #0
   17626:	7a9b      	ldrb	r3, [r3, #10]
   17628:	deff      	udf	#255	; 0xff
}
   1762a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   1762e:	4610      	mov	r0, r2
   17630:	f7ff bea8 	b.w	17384 <prov_ccc_write.part.0>
	if (client->filter_type == NONE) {
   17634:	7a9a      	ldrb	r2, [r3, #10]
   17636:	b91a      	cbnz	r2, 17640 <prov_ccc_write+0x48>
		client->filter_type = PROV;
   17638:	2203      	movs	r2, #3
   1763a:	729a      	strb	r2, [r3, #10]
		bt_mesh_pb_gatt_open(conn);
   1763c:	f7ff fe06 	bl	1724c <bt_mesh_pb_gatt_open>
}
   17640:	2002      	movs	r0, #2
   17642:	bd08      	pop	{r3, pc}
   17644:	20006f38 	.word	0x20006f38
   17648:	0002fcc6 	.word	0x0002fcc6
   1764c:	0002fcf7 	.word	0x0002fcf7
   17650:	0002a5e8 	.word	0x0002a5e8
   17654:	0002fcfe 	.word	0x0002fcfe

00017658 <proxy_complete_pdu>:
{
   17658:	b570      	push	{r4, r5, r6, lr}
	switch (client->msg_type) {
   1765a:	7ac1      	ldrb	r1, [r0, #11]
{
   1765c:	b092      	sub	sp, #72	; 0x48
   1765e:	4604      	mov	r4, r0
   17660:	2903      	cmp	r1, #3
   17662:	f200 80b2 	bhi.w	177ca <proxy_complete_pdu+0x172>
   17666:	e8df f001 	tbb	[pc, r1]
   1766a:	0d02      	.short	0x0d02
   1766c:	aa11      	.short	0xaa11
		bt_mesh_net_recv(&client->buf, 0, BT_MESH_NET_IF_PROXY);
   1766e:	2202      	movs	r2, #2
   17670:	2100      	movs	r1, #0
   17672:	3038      	adds	r0, #56	; 0x38
   17674:	f7f6 f8f4 	bl	d860 <bt_mesh_net_recv>
   17678:	2300      	movs	r3, #0
   1767a:	87a3      	strh	r3, [r4, #60]	; 0x3c
	buf->data = buf->__buf;
   1767c:	6c23      	ldr	r3, [r4, #64]	; 0x40
   1767e:	63a3      	str	r3, [r4, #56]	; 0x38
}
   17680:	b012      	add	sp, #72	; 0x48
   17682:	bd70      	pop	{r4, r5, r6, pc}
		bt_mesh_beacon_recv(&client->buf);
   17684:	3038      	adds	r0, #56	; 0x38
   17686:	f7f4 ffa3 	bl	c5d0 <bt_mesh_beacon_recv>
		break;
   1768a:	e7f5      	b.n	17678 <proxy_complete_pdu+0x20>
	NET_BUF_SIMPLE_DEFINE(buf, 29);
   1768c:	ab0a      	add	r3, sp, #40	; 0x28
   1768e:	f44f 12e8 	mov.w	r2, #1900544	; 0x1d0000
   17692:	e9cd 2302 	strd	r2, r3, [sp, #8]
   17696:	9301      	str	r3, [sp, #4]
	err = bt_mesh_net_decode(&client->buf, BT_MESH_NET_IF_PROXY_CFG,
   17698:	aa04      	add	r2, sp, #16
   1769a:	ab01      	add	r3, sp, #4
   1769c:	2103      	movs	r1, #3
   1769e:	3038      	adds	r0, #56	; 0x38
   176a0:	f7f5 ff42 	bl	d528 <bt_mesh_net_decode>
	if (err) {
   176a4:	4606      	mov	r6, r0
   176a6:	b158      	cbz	r0, 176c0 <proxy_complete_pdu+0x68>
   176a8:	4a4c      	ldr	r2, [pc, #304]	; (177dc <proxy_complete_pdu+0x184>)
   176aa:	4b4d      	ldr	r3, [pc, #308]	; (177e0 <proxy_complete_pdu+0x188>)
   176ac:	1ad2      	subs	r2, r2, r3
   176ae:	08d2      	lsrs	r2, r2, #3
		BT_ERR("Failed to decode Proxy Configuration (err %d)", err);
   176b0:	0192      	lsls	r2, r2, #6
   176b2:	4601      	mov	r1, r0
   176b4:	484b      	ldr	r0, [pc, #300]	; (177e4 <proxy_complete_pdu+0x18c>)
   176b6:	f042 0201 	orr.w	r2, r2, #1
		BT_WARN("Unhandled Message Type 0x%02x", client->msg_type);
   176ba:	f00c fc90 	bl	23fde <log_1>
   176be:	e7db      	b.n	17678 <proxy_complete_pdu+0x20>
	net_buf_simple_pull(&buf, BT_MESH_NET_HDR_LEN);
   176c0:	2109      	movs	r1, #9
   176c2:	a801      	add	r0, sp, #4
   176c4:	f007 fdc6 	bl	1f254 <net_buf_simple_pull>
	if (buf.len < 1) {
   176c8:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   176cc:	b953      	cbnz	r3, 176e4 <proxy_complete_pdu+0x8c>
   176ce:	4b44      	ldr	r3, [pc, #272]	; (177e0 <proxy_complete_pdu+0x188>)
   176d0:	4942      	ldr	r1, [pc, #264]	; (177dc <proxy_complete_pdu+0x184>)
		BT_WARN("Too short proxy configuration PDU");
   176d2:	4845      	ldr	r0, [pc, #276]	; (177e8 <proxy_complete_pdu+0x190>)
   176d4:	1ac9      	subs	r1, r1, r3
   176d6:	08c9      	lsrs	r1, r1, #3
   176d8:	0189      	lsls	r1, r1, #6
   176da:	f041 0102 	orr.w	r1, r1, #2
   176de:	f00c fc71 	bl	23fc4 <log_0>
		return;
   176e2:	e7c9      	b.n	17678 <proxy_complete_pdu+0x20>
	opcode = net_buf_simple_pull_u8(&buf);
   176e4:	a801      	add	r0, sp, #4
   176e6:	f011 fb36 	bl	28d56 <net_buf_simple_pull_u8>
	switch (opcode) {
   176ea:	2801      	cmp	r0, #1
	opcode = net_buf_simple_pull_u8(&buf);
   176ec:	4605      	mov	r5, r0
	switch (opcode) {
   176ee:	d03d      	beq.n	1776c <proxy_complete_pdu+0x114>
   176f0:	2802      	cmp	r0, #2
   176f2:	d051      	beq.n	17798 <proxy_complete_pdu+0x140>
   176f4:	2800      	cmp	r0, #0
   176f6:	d158      	bne.n	177aa <proxy_complete_pdu+0x152>
	if (buf->len < 1) {
   176f8:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   176fc:	b97b      	cbnz	r3, 1771e <proxy_complete_pdu+0xc6>
   176fe:	4937      	ldr	r1, [pc, #220]	; (177dc <proxy_complete_pdu+0x184>)
   17700:	4b37      	ldr	r3, [pc, #220]	; (177e0 <proxy_complete_pdu+0x188>)
		BT_WARN("Too short Filter Set message");
   17702:	483a      	ldr	r0, [pc, #232]	; (177ec <proxy_complete_pdu+0x194>)
   17704:	1ac9      	subs	r1, r1, r3
   17706:	08c9      	lsrs	r1, r1, #3
   17708:	0189      	lsls	r1, r1, #6
   1770a:	f041 0102 	orr.w	r1, r1, #2
   1770e:	f00c fc59 	bl	23fc4 <log_0>
		send_filter_status(client, &rx, &buf);
   17712:	aa01      	add	r2, sp, #4
   17714:	a904      	add	r1, sp, #16
   17716:	4620      	mov	r0, r4
   17718:	f7ff fecc 	bl	174b4 <send_filter_status>
		break;
   1771c:	e7ac      	b.n	17678 <proxy_complete_pdu+0x20>
	type = net_buf_simple_pull_u8(buf);
   1771e:	a801      	add	r0, sp, #4
   17720:	f011 fb19 	bl	28d56 <net_buf_simple_pull_u8>
	switch (type) {
   17724:	4601      	mov	r1, r0
   17726:	b160      	cbz	r0, 17742 <proxy_complete_pdu+0xea>
   17728:	2801      	cmp	r0, #1
   1772a:	d011      	beq.n	17750 <proxy_complete_pdu+0xf8>
   1772c:	4b2c      	ldr	r3, [pc, #176]	; (177e0 <proxy_complete_pdu+0x188>)
   1772e:	4a2b      	ldr	r2, [pc, #172]	; (177dc <proxy_complete_pdu+0x184>)
		BT_WARN("Prohibited Filter Type 0x%02x", type);
   17730:	482f      	ldr	r0, [pc, #188]	; (177f0 <proxy_complete_pdu+0x198>)
   17732:	1ad2      	subs	r2, r2, r3
   17734:	08d2      	lsrs	r2, r2, #3
   17736:	0192      	lsls	r2, r2, #6
   17738:	f042 0202 	orr.w	r2, r2, #2
   1773c:	f00c fc4f 	bl	23fde <log_1>
		return -EINVAL;
   17740:	e7e7      	b.n	17712 <proxy_complete_pdu+0xba>
		(void)memset(client->filter, 0, sizeof(client->filter));
   17742:	2206      	movs	r2, #6
   17744:	1d20      	adds	r0, r4, #4
   17746:	f00e fada 	bl	25cfe <memset>
		client->filter_type = WHITELIST;
   1774a:	2301      	movs	r3, #1
		client->filter_type = BLACKLIST;
   1774c:	72a3      	strb	r3, [r4, #10]
		break;
   1774e:	e7e0      	b.n	17712 <proxy_complete_pdu+0xba>
		(void)memset(client->filter, 0, sizeof(client->filter));
   17750:	2206      	movs	r2, #6
   17752:	4629      	mov	r1, r5
   17754:	1d20      	adds	r0, r4, #4
   17756:	f00e fad2 	bl	25cfe <memset>
		client->filter_type = BLACKLIST;
   1775a:	2302      	movs	r3, #2
   1775c:	e7f6      	b.n	1774c <proxy_complete_pdu+0xf4>
			addr = net_buf_simple_pull_be16(&buf);
   1775e:	a801      	add	r0, sp, #4
   17760:	f011 fb09 	bl	28d76 <net_buf_simple_pull_be16>
   17764:	4601      	mov	r1, r0
			filter_add(client, addr);
   17766:	4620      	mov	r0, r4
   17768:	f010 fbca 	bl	27f00 <filter_add>
		while (buf.len >= 2) {
   1776c:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   17770:	2b01      	cmp	r3, #1
   17772:	d8f4      	bhi.n	1775e <proxy_complete_pdu+0x106>
   17774:	e7cd      	b.n	17712 <proxy_complete_pdu+0xba>
			addr = net_buf_simple_pull_be16(&buf);
   17776:	a801      	add	r0, sp, #4
   17778:	f011 fafd 	bl	28d76 <net_buf_simple_pull_be16>
	if (addr == BT_MESH_ADDR_UNASSIGNED) {
   1777c:	b160      	cbz	r0, 17798 <proxy_complete_pdu+0x140>
		if (client->filter[i] == addr) {
   1777e:	88a3      	ldrh	r3, [r4, #4]
   17780:	4283      	cmp	r3, r0
   17782:	d00e      	beq.n	177a2 <proxy_complete_pdu+0x14a>
   17784:	88e3      	ldrh	r3, [r4, #6]
   17786:	4283      	cmp	r3, r0
   17788:	d00d      	beq.n	177a6 <proxy_complete_pdu+0x14e>
   1778a:	8923      	ldrh	r3, [r4, #8]
   1778c:	4283      	cmp	r3, r0
   1778e:	d103      	bne.n	17798 <proxy_complete_pdu+0x140>
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   17790:	2302      	movs	r3, #2
			client->filter[i] = BT_MESH_ADDR_UNASSIGNED;
   17792:	eb04 0343 	add.w	r3, r4, r3, lsl #1
   17796:	809e      	strh	r6, [r3, #4]
		while (buf.len >= 2) {
   17798:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   1779c:	2b01      	cmp	r3, #1
   1779e:	d8ea      	bhi.n	17776 <proxy_complete_pdu+0x11e>
   177a0:	e7b7      	b.n	17712 <proxy_complete_pdu+0xba>
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   177a2:	2300      	movs	r3, #0
   177a4:	e7f5      	b.n	17792 <proxy_complete_pdu+0x13a>
   177a6:	2301      	movs	r3, #1
   177a8:	e7f3      	b.n	17792 <proxy_complete_pdu+0x13a>
   177aa:	4a0c      	ldr	r2, [pc, #48]	; (177dc <proxy_complete_pdu+0x184>)
   177ac:	4b0c      	ldr	r3, [pc, #48]	; (177e0 <proxy_complete_pdu+0x188>)
   177ae:	1ad2      	subs	r2, r2, r3
   177b0:	08d2      	lsrs	r2, r2, #3
		BT_WARN("Unhandled configuration OpCode 0x%02x", opcode);
   177b2:	0192      	lsls	r2, r2, #6
   177b4:	4601      	mov	r1, r0
   177b6:	f042 0202 	orr.w	r2, r2, #2
   177ba:	480e      	ldr	r0, [pc, #56]	; (177f4 <proxy_complete_pdu+0x19c>)
   177bc:	e77d      	b.n	176ba <proxy_complete_pdu+0x62>
		bt_mesh_pb_gatt_recv(client->conn, &client->buf);
   177be:	f100 0138 	add.w	r1, r0, #56	; 0x38
   177c2:	6800      	ldr	r0, [r0, #0]
   177c4:	f7ff fd00 	bl	171c8 <bt_mesh_pb_gatt_recv>
		break;
   177c8:	e756      	b.n	17678 <proxy_complete_pdu+0x20>
   177ca:	4a04      	ldr	r2, [pc, #16]	; (177dc <proxy_complete_pdu+0x184>)
   177cc:	4b04      	ldr	r3, [pc, #16]	; (177e0 <proxy_complete_pdu+0x188>)
		BT_WARN("Unhandled Message Type 0x%02x", client->msg_type);
   177ce:	480a      	ldr	r0, [pc, #40]	; (177f8 <proxy_complete_pdu+0x1a0>)
   177d0:	1ad2      	subs	r2, r2, r3
   177d2:	08d2      	lsrs	r2, r2, #3
   177d4:	0192      	lsls	r2, r2, #6
   177d6:	f042 0202 	orr.w	r2, r2, #2
   177da:	e76e      	b.n	176ba <proxy_complete_pdu+0x62>
   177dc:	00029978 	.word	0x00029978
   177e0:	00029830 	.word	0x00029830
   177e4:	0002fd19 	.word	0x0002fd19
   177e8:	0002fd47 	.word	0x0002fd47
   177ec:	0002fd69 	.word	0x0002fd69
   177f0:	0002fd86 	.word	0x0002fd86
   177f4:	0002fda4 	.word	0x0002fda4
   177f8:	0002fdca 	.word	0x0002fdca

000177fc <proxy_recv>:
{
   177fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if (clients[i].conn == conn) {
   177fe:	4d5c      	ldr	r5, [pc, #368]	; (17970 <proxy_recv+0x174>)
{
   17800:	461c      	mov	r4, r3
		if (clients[i].conn == conn) {
   17802:	682b      	ldr	r3, [r5, #0]
   17804:	4283      	cmp	r3, r0
{
   17806:	4616      	mov	r6, r2
		if (clients[i].conn == conn) {
   17808:	f040 80af 	bne.w	1796a <proxy_recv+0x16e>
	if (len < 1) {
   1780c:	b964      	cbnz	r4, 17828 <proxy_recv+0x2c>
   1780e:	4959      	ldr	r1, [pc, #356]	; (17974 <proxy_recv+0x178>)
   17810:	4b59      	ldr	r3, [pc, #356]	; (17978 <proxy_recv+0x17c>)
		BT_WARN("Too small Proxy PDU");
   17812:	485a      	ldr	r0, [pc, #360]	; (1797c <proxy_recv+0x180>)
   17814:	1ac9      	subs	r1, r1, r3
   17816:	08c9      	lsrs	r1, r1, #3
   17818:	0189      	lsls	r1, r1, #6
   1781a:	f041 0102 	orr.w	r1, r1, #2
			BT_WARN("Unexpected message type in last SAR PDU");
   1781e:	f00c fbd1 	bl	23fc4 <log_0>
			return -EINVAL;
   17822:	f06f 0415 	mvn.w	r4, #21
   17826:	e05f      	b.n	178e8 <proxy_recv+0xec>
	if (ATTR_IS_PROV(attr) != (PDU_TYPE(data) == BT_MESH_PROXY_PROV)) {
   17828:	7812      	ldrb	r2, [r2, #0]
   1782a:	68cb      	ldr	r3, [r1, #12]
   1782c:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   17830:	3b00      	subs	r3, #0
   17832:	f1a2 0103 	sub.w	r1, r2, #3
   17836:	bf18      	it	ne
   17838:	2301      	movne	r3, #1
   1783a:	424a      	negs	r2, r1
   1783c:	414a      	adcs	r2, r1
   1783e:	4293      	cmp	r3, r2
   17840:	d008      	beq.n	17854 <proxy_recv+0x58>
   17842:	494c      	ldr	r1, [pc, #304]	; (17974 <proxy_recv+0x178>)
   17844:	4b4c      	ldr	r3, [pc, #304]	; (17978 <proxy_recv+0x17c>)
		BT_WARN("Proxy PDU type doesn't match GATT service");
   17846:	484e      	ldr	r0, [pc, #312]	; (17980 <proxy_recv+0x184>)
   17848:	1ac9      	subs	r1, r1, r3
   1784a:	08c9      	lsrs	r1, r1, #3
   1784c:	0189      	lsls	r1, r1, #6
   1784e:	f041 0102 	orr.w	r1, r1, #2
   17852:	e7e4      	b.n	1781e <proxy_recv+0x22>
	if (len - 1 > net_buf_simple_tailroom(&client->buf)) {
   17854:	f105 0038 	add.w	r0, r5, #56	; 0x38
   17858:	f011 faa5 	bl	28da6 <net_buf_simple_tailroom>
   1785c:	1e67      	subs	r7, r4, #1
   1785e:	4287      	cmp	r7, r0
   17860:	d908      	bls.n	17874 <proxy_recv+0x78>
   17862:	4944      	ldr	r1, [pc, #272]	; (17974 <proxy_recv+0x178>)
   17864:	4b44      	ldr	r3, [pc, #272]	; (17978 <proxy_recv+0x17c>)
		BT_WARN("Too big proxy PDU");
   17866:	4847      	ldr	r0, [pc, #284]	; (17984 <proxy_recv+0x188>)
   17868:	1ac9      	subs	r1, r1, r3
   1786a:	08c9      	lsrs	r1, r1, #3
   1786c:	0189      	lsls	r1, r1, #6
   1786e:	f041 0102 	orr.w	r1, r1, #2
   17872:	e7d4      	b.n	1781e <proxy_recv+0x22>
	switch (PDU_SAR(data)) {
   17874:	7833      	ldrb	r3, [r6, #0]
   17876:	8faa      	ldrh	r2, [r5, #60]	; 0x3c
   17878:	0999      	lsrs	r1, r3, #6
   1787a:	2902      	cmp	r1, #2
   1787c:	d036      	beq.n	178ec <proxy_recv+0xf0>
   1787e:	2903      	cmp	r1, #3
   17880:	d056      	beq.n	17930 <proxy_recv+0x134>
   17882:	2901      	cmp	r1, #1
   17884:	d014      	beq.n	178b0 <proxy_recv+0xb4>
		if (client->buf.len) {
   17886:	b142      	cbz	r2, 1789a <proxy_recv+0x9e>
   17888:	493a      	ldr	r1, [pc, #232]	; (17974 <proxy_recv+0x178>)
   1788a:	4b3b      	ldr	r3, [pc, #236]	; (17978 <proxy_recv+0x17c>)
			BT_WARN("Complete PDU while a pending incomplete one");
   1788c:	483e      	ldr	r0, [pc, #248]	; (17988 <proxy_recv+0x18c>)
   1788e:	1ac9      	subs	r1, r1, r3
   17890:	08c9      	lsrs	r1, r1, #3
   17892:	0189      	lsls	r1, r1, #6
   17894:	f041 0102 	orr.w	r1, r1, #2
   17898:	e7c1      	b.n	1781e <proxy_recv+0x22>
		client->msg_type = PDU_TYPE(data);
   1789a:	72eb      	strb	r3, [r5, #11]
		net_buf_simple_add_mem(&client->buf, data + 1, len - 1);
   1789c:	463a      	mov	r2, r7
   1789e:	1c71      	adds	r1, r6, #1
   178a0:	f105 0038 	add.w	r0, r5, #56	; 0x38
   178a4:	f011 fa87 	bl	28db6 <net_buf_simple_add_mem>
		proxy_complete_pdu(client);
   178a8:	4628      	mov	r0, r5
   178aa:	f7ff fed5 	bl	17658 <proxy_complete_pdu>
		break;
   178ae:	e01b      	b.n	178e8 <proxy_recv+0xec>
		if (client->buf.len) {
   178b0:	b142      	cbz	r2, 178c4 <proxy_recv+0xc8>
   178b2:	4930      	ldr	r1, [pc, #192]	; (17974 <proxy_recv+0x178>)
   178b4:	4b30      	ldr	r3, [pc, #192]	; (17978 <proxy_recv+0x17c>)
			BT_WARN("First PDU while a pending incomplete one");
   178b6:	4835      	ldr	r0, [pc, #212]	; (1798c <proxy_recv+0x190>)
   178b8:	1ac9      	subs	r1, r1, r3
   178ba:	08c9      	lsrs	r1, r1, #3
   178bc:	0189      	lsls	r1, r1, #6
   178be:	f041 0102 	orr.w	r1, r1, #2
   178c2:	e7ac      	b.n	1781e <proxy_recv+0x22>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   178c4:	f644 6220 	movw	r2, #20000	; 0x4e20
   178c8:	f105 0118 	add.w	r1, r5, #24
   178cc:	4830      	ldr	r0, [pc, #192]	; (17990 <proxy_recv+0x194>)
   178ce:	f00b f947 	bl	22b60 <k_delayed_work_submit_to_queue>
		client->msg_type = PDU_TYPE(data);
   178d2:	4631      	mov	r1, r6
		net_buf_simple_add_mem(&client->buf, data + 1, len - 1);
   178d4:	463a      	mov	r2, r7
		client->msg_type = PDU_TYPE(data);
   178d6:	f811 3b01 	ldrb.w	r3, [r1], #1
   178da:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   178de:	72eb      	strb	r3, [r5, #11]
		net_buf_simple_add_mem(&client->buf, data + 1, len - 1);
   178e0:	f105 0038 	add.w	r0, r5, #56	; 0x38
   178e4:	f011 fa67 	bl	28db6 <net_buf_simple_add_mem>
}
   178e8:	4620      	mov	r0, r4
   178ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (!client->buf.len) {
   178ec:	b942      	cbnz	r2, 17900 <proxy_recv+0x104>
   178ee:	4921      	ldr	r1, [pc, #132]	; (17974 <proxy_recv+0x178>)
   178f0:	4b21      	ldr	r3, [pc, #132]	; (17978 <proxy_recv+0x17c>)
			BT_WARN("Continuation with no prior data");
   178f2:	4828      	ldr	r0, [pc, #160]	; (17994 <proxy_recv+0x198>)
   178f4:	1ac9      	subs	r1, r1, r3
   178f6:	08c9      	lsrs	r1, r1, #3
   178f8:	0189      	lsls	r1, r1, #6
   178fa:	f041 0102 	orr.w	r1, r1, #2
   178fe:	e78e      	b.n	1781e <proxy_recv+0x22>
		if (client->msg_type != PDU_TYPE(data)) {
   17900:	7aea      	ldrb	r2, [r5, #11]
   17902:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   17906:	429a      	cmp	r2, r3
   17908:	d008      	beq.n	1791c <proxy_recv+0x120>
   1790a:	491a      	ldr	r1, [pc, #104]	; (17974 <proxy_recv+0x178>)
   1790c:	4b1a      	ldr	r3, [pc, #104]	; (17978 <proxy_recv+0x17c>)
			BT_WARN("Unexpected message type in continuation");
   1790e:	4822      	ldr	r0, [pc, #136]	; (17998 <proxy_recv+0x19c>)
   17910:	1ac9      	subs	r1, r1, r3
   17912:	08c9      	lsrs	r1, r1, #3
   17914:	0189      	lsls	r1, r1, #6
   17916:	f041 0102 	orr.w	r1, r1, #2
   1791a:	e780      	b.n	1781e <proxy_recv+0x22>
   1791c:	f644 6220 	movw	r2, #20000	; 0x4e20
   17920:	f105 0118 	add.w	r1, r5, #24
   17924:	481a      	ldr	r0, [pc, #104]	; (17990 <proxy_recv+0x194>)
   17926:	f00b f91b 	bl	22b60 <k_delayed_work_submit_to_queue>
		net_buf_simple_add_mem(&client->buf, data + 1, len - 1);
   1792a:	463a      	mov	r2, r7
   1792c:	1c71      	adds	r1, r6, #1
   1792e:	e7d7      	b.n	178e0 <proxy_recv+0xe4>
		if (!client->buf.len) {
   17930:	b942      	cbnz	r2, 17944 <proxy_recv+0x148>
   17932:	4910      	ldr	r1, [pc, #64]	; (17974 <proxy_recv+0x178>)
   17934:	4b10      	ldr	r3, [pc, #64]	; (17978 <proxy_recv+0x17c>)
			BT_WARN("Last SAR PDU with no prior data");
   17936:	4819      	ldr	r0, [pc, #100]	; (1799c <proxy_recv+0x1a0>)
   17938:	1ac9      	subs	r1, r1, r3
   1793a:	08c9      	lsrs	r1, r1, #3
   1793c:	0189      	lsls	r1, r1, #6
   1793e:	f041 0102 	orr.w	r1, r1, #2
   17942:	e76c      	b.n	1781e <proxy_recv+0x22>
		if (client->msg_type != PDU_TYPE(data)) {
   17944:	7aea      	ldrb	r2, [r5, #11]
   17946:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1794a:	429a      	cmp	r2, r3
   1794c:	d008      	beq.n	17960 <proxy_recv+0x164>
   1794e:	4909      	ldr	r1, [pc, #36]	; (17974 <proxy_recv+0x178>)
   17950:	4b09      	ldr	r3, [pc, #36]	; (17978 <proxy_recv+0x17c>)
			BT_WARN("Unexpected message type in last SAR PDU");
   17952:	4813      	ldr	r0, [pc, #76]	; (179a0 <proxy_recv+0x1a4>)
   17954:	1ac9      	subs	r1, r1, r3
   17956:	08c9      	lsrs	r1, r1, #3
   17958:	0189      	lsls	r1, r1, #6
   1795a:	f041 0102 	orr.w	r1, r1, #2
   1795e:	e75e      	b.n	1781e <proxy_recv+0x22>
		k_delayed_work_cancel(&client->sar_timer);
   17960:	f105 0018 	add.w	r0, r5, #24
   17964:	f00b f98c 	bl	22c80 <k_delayed_work_cancel>
   17968:	e798      	b.n	1789c <proxy_recv+0xa0>
		return -ENOTCONN;
   1796a:	f06f 0438 	mvn.w	r4, #56	; 0x38
   1796e:	e7bb      	b.n	178e8 <proxy_recv+0xec>
   17970:	20006f38 	.word	0x20006f38
   17974:	00029978 	.word	0x00029978
   17978:	00029830 	.word	0x00029830
   1797c:	0002fde8 	.word	0x0002fde8
   17980:	0002fdfc 	.word	0x0002fdfc
   17984:	0002fe26 	.word	0x0002fe26
   17988:	0002fe38 	.word	0x0002fe38
   1798c:	0002fe64 	.word	0x0002fe64
   17990:	20001dc4 	.word	0x20001dc4
   17994:	0002fe8d 	.word	0x0002fe8d
   17998:	0002fead 	.word	0x0002fead
   1799c:	0002fed5 	.word	0x0002fed5
   179a0:	0002fef5 	.word	0x0002fef5

000179a4 <bt_mesh_proxy_beacon_send>:
{
   179a4:	b538      	push	{r3, r4, r5, lr}
			if (bt_mesh.sub[i].net_idx != BT_MESH_KEY_UNUSED) {
   179a6:	4c0f      	ldr	r4, [pc, #60]	; (179e4 <bt_mesh_proxy_beacon_send+0x40>)
{
   179a8:	4601      	mov	r1, r0
				bt_mesh_proxy_beacon_send(&bt_mesh.sub[i]);
   179aa:	f504 75ce 	add.w	r5, r4, #412	; 0x19c
	if (!sub) {
   179ae:	b981      	cbnz	r1, 179d2 <bt_mesh_proxy_beacon_send+0x2e>
			if (bt_mesh.sub[i].net_idx != BT_MESH_KEY_UNUSED) {
   179b0:	f8b4 21b8 	ldrh.w	r2, [r4, #440]	; 0x1b8
   179b4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   179b8:	429a      	cmp	r2, r3
   179ba:	d002      	beq.n	179c2 <bt_mesh_proxy_beacon_send+0x1e>
				bt_mesh_proxy_beacon_send(&bt_mesh.sub[i]);
   179bc:	4628      	mov	r0, r5
   179be:	f7ff fff1 	bl	179a4 <bt_mesh_proxy_beacon_send>
			if (bt_mesh.sub[i].net_idx != BT_MESH_KEY_UNUSED) {
   179c2:	f8b4 229c 	ldrh.w	r2, [r4, #668]	; 0x29c
				bt_mesh_proxy_beacon_send(&bt_mesh.sub[i]);
   179c6:	4908      	ldr	r1, [pc, #32]	; (179e8 <bt_mesh_proxy_beacon_send+0x44>)
			if (bt_mesh.sub[i].net_idx != BT_MESH_KEY_UNUSED) {
   179c8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   179cc:	429a      	cmp	r2, r3
   179ce:	d1ee      	bne.n	179ae <bt_mesh_proxy_beacon_send+0xa>
}
   179d0:	bd38      	pop	{r3, r4, r5, pc}
		if (clients[i].conn) {
   179d2:	4b06      	ldr	r3, [pc, #24]	; (179ec <bt_mesh_proxy_beacon_send+0x48>)
   179d4:	6818      	ldr	r0, [r3, #0]
   179d6:	2800      	cmp	r0, #0
   179d8:	d0fa      	beq.n	179d0 <bt_mesh_proxy_beacon_send+0x2c>
}
   179da:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			beacon_send(clients[i].conn, sub);
   179de:	f010 baee 	b.w	27fbe <beacon_send>
   179e2:	bf00      	nop
   179e4:	20006b48 	.word	0x20006b48
   179e8:	20006dc8 	.word	0x20006dc8
   179ec:	20006f38 	.word	0x20006f38

000179f0 <bt_mesh_proxy_identity_start>:
	sub->node_id = BT_MESH_NODE_IDENTITY_RUNNING;
   179f0:	2301      	movs	r3, #1
{
   179f2:	b510      	push	{r4, lr}
   179f4:	4604      	mov	r4, r0
	sub->node_id = BT_MESH_NODE_IDENTITY_RUNNING;
   179f6:	f880 3020 	strb.w	r3, [r0, #32]
   179fa:	f011 fd0a 	bl	29412 <z_impl_k_uptime_ticks>
   179fe:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   17a02:	460a      	mov	r2, r1
   17a04:	fba0 0103 	umull	r0, r1, r0, r3
   17a08:	fb03 1102 	mla	r1, r3, r2, r1
   17a0c:	0bc3      	lsrs	r3, r0, #15
	next_idx = sub - bt_mesh.sub;
   17a0e:	4808      	ldr	r0, [pc, #32]	; (17a30 <bt_mesh_proxy_identity_start+0x40>)
   17a10:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
	return (u32_t)k_uptime_get();
   17a14:	6263      	str	r3, [r4, #36]	; 0x24
   17a16:	1a24      	subs	r4, r4, r0
   17a18:	10a4      	asrs	r4, r4, #2
   17a1a:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
   17a1e:	ebc4 2444 	rsb	r4, r4, r4, lsl #9
   17a22:	4b04      	ldr	r3, [pc, #16]	; (17a34 <bt_mesh_proxy_identity_start+0x44>)
   17a24:	eb04 4484 	add.w	r4, r4, r4, lsl #18
   17a28:	4264      	negs	r4, r4
   17a2a:	601c      	str	r4, [r3, #0]
}
   17a2c:	bd10      	pop	{r4, pc}
   17a2e:	bf00      	nop
   17a30:	20006ce4 	.word	0x20006ce4
   17a34:	20000cc0 	.word	0x20000cc0

00017a38 <bt_mesh_proxy_identity_enable>:
{
   17a38:	b510      	push	{r4, lr}
	if (!bt_mesh_is_provisioned()) {
   17a3a:	f7f4 f9b7 	bl	bdac <bt_mesh_is_provisioned>
   17a3e:	b328      	cbz	r0, 17a8c <bt_mesh_proxy_identity_enable+0x54>
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   17a40:	4c14      	ldr	r4, [pc, #80]	; (17a94 <bt_mesh_proxy_identity_enable+0x5c>)
   17a42:	f8b4 21b8 	ldrh.w	r2, [r4, #440]	; 0x1b8
   17a46:	f64f 73ff 	movw	r3, #65535	; 0xffff
   17a4a:	429a      	cmp	r2, r3
   17a4c:	d019      	beq.n	17a82 <bt_mesh_proxy_identity_enable+0x4a>
		if (sub->node_id == BT_MESH_NODE_IDENTITY_NOT_SUPPORTED) {
   17a4e:	f894 31bc 	ldrb.w	r3, [r4, #444]	; 0x1bc
   17a52:	2b02      	cmp	r3, #2
   17a54:	d015      	beq.n	17a82 <bt_mesh_proxy_identity_enable+0x4a>
		bt_mesh_proxy_identity_start(sub);
   17a56:	f504 70ce 	add.w	r0, r4, #412	; 0x19c
   17a5a:	f7ff ffc9 	bl	179f0 <bt_mesh_proxy_identity_start>
		count++;
   17a5e:	2001      	movs	r0, #1
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   17a60:	f8b4 229c 	ldrh.w	r2, [r4, #668]	; 0x29c
   17a64:	f64f 73ff 	movw	r3, #65535	; 0xffff
   17a68:	429a      	cmp	r2, r3
   17a6a:	d00c      	beq.n	17a86 <bt_mesh_proxy_identity_enable+0x4e>
		if (sub->node_id == BT_MESH_NODE_IDENTITY_NOT_SUPPORTED) {
   17a6c:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
   17a70:	2b02      	cmp	r3, #2
   17a72:	d008      	beq.n	17a86 <bt_mesh_proxy_identity_enable+0x4e>
		bt_mesh_proxy_identity_start(sub);
   17a74:	4808      	ldr	r0, [pc, #32]	; (17a98 <bt_mesh_proxy_identity_enable+0x60>)
   17a76:	f7ff ffbb 	bl	179f0 <bt_mesh_proxy_identity_start>
		bt_mesh_adv_update();
   17a7a:	f7f4 fb25 	bl	c0c8 <bt_mesh_adv_update>
	return 0;
   17a7e:	2000      	movs	r0, #0
   17a80:	e003      	b.n	17a8a <bt_mesh_proxy_identity_enable+0x52>
	int i, count = 0;
   17a82:	2000      	movs	r0, #0
   17a84:	e7ec      	b.n	17a60 <bt_mesh_proxy_identity_enable+0x28>
	if (count) {
   17a86:	2800      	cmp	r0, #0
   17a88:	d1f7      	bne.n	17a7a <bt_mesh_proxy_identity_enable+0x42>
}
   17a8a:	bd10      	pop	{r4, pc}
		return -EAGAIN;
   17a8c:	f06f 000a 	mvn.w	r0, #10
   17a90:	e7fb      	b.n	17a8a <bt_mesh_proxy_identity_enable+0x52>
   17a92:	bf00      	nop
   17a94:	20006b48 	.word	0x20006b48
   17a98:	20006dc8 	.word	0x20006dc8

00017a9c <bt_mesh_proxy_get_buf>:
	buf->len  = 0U;
   17a9c:	4803      	ldr	r0, [pc, #12]	; (17aac <bt_mesh_proxy_get_buf+0x10>)
   17a9e:	2300      	movs	r3, #0
   17aa0:	8783      	strh	r3, [r0, #60]	; 0x3c
	buf->data = buf->__buf;
   17aa2:	6c03      	ldr	r3, [r0, #64]	; 0x40
   17aa4:	f840 3f38 	str.w	r3, [r0, #56]!
}
   17aa8:	4770      	bx	lr
   17aaa:	bf00      	nop
   17aac:	20006f38 	.word	0x20006f38

00017ab0 <bt_mesh_proxy_prov_enable>:
{
   17ab0:	b538      	push	{r3, r4, r5, lr}
	if (gatt_svc == MESH_GATT_PROV) {
   17ab2:	4d0c      	ldr	r5, [pc, #48]	; (17ae4 <bt_mesh_proxy_prov_enable+0x34>)
   17ab4:	782c      	ldrb	r4, [r5, #0]
   17ab6:	2c01      	cmp	r4, #1
   17ab8:	d00e      	beq.n	17ad8 <bt_mesh_proxy_prov_enable+0x28>
	if (gatt_svc != MESH_GATT_NONE) {
   17aba:	b984      	cbnz	r4, 17ade <bt_mesh_proxy_prov_enable+0x2e>
	bt_gatt_service_register(&prov_svc);
   17abc:	480a      	ldr	r0, [pc, #40]	; (17ae8 <bt_mesh_proxy_prov_enable+0x38>)
   17abe:	f7f3 fce1 	bl	b484 <bt_gatt_service_register>
	prov_fast_adv = true;
   17ac2:	4a0a      	ldr	r2, [pc, #40]	; (17aec <bt_mesh_proxy_prov_enable+0x3c>)
	gatt_svc = MESH_GATT_PROV;
   17ac4:	2301      	movs	r3, #1
   17ac6:	702b      	strb	r3, [r5, #0]
	prov_fast_adv = true;
   17ac8:	7013      	strb	r3, [r2, #0]
		if (clients[i].conn) {
   17aca:	4b09      	ldr	r3, [pc, #36]	; (17af0 <bt_mesh_proxy_prov_enable+0x40>)
   17acc:	6818      	ldr	r0, [r3, #0]
   17ace:	b110      	cbz	r0, 17ad6 <bt_mesh_proxy_prov_enable+0x26>
			clients[i].filter_type = PROV;
   17ad0:	2203      	movs	r2, #3
   17ad2:	729a      	strb	r2, [r3, #10]
	return 0;
   17ad4:	4620      	mov	r0, r4
}
   17ad6:	bd38      	pop	{r3, r4, r5, pc}
		return -EALREADY;
   17ad8:	f06f 0044 	mvn.w	r0, #68	; 0x44
   17adc:	e7fb      	b.n	17ad6 <bt_mesh_proxy_prov_enable+0x26>
		return -EBUSY;
   17ade:	f06f 000f 	mvn.w	r0, #15
   17ae2:	e7f8      	b.n	17ad6 <bt_mesh_proxy_prov_enable+0x26>
   17ae4:	200024c5 	.word	0x200024c5
   17ae8:	20007020 	.word	0x20007020
   17aec:	200024c6 	.word	0x200024c6
   17af0:	20006f38 	.word	0x20006f38

00017af4 <bt_mesh_proxy_prov_disable>:
{
   17af4:	b538      	push	{r3, r4, r5, lr}
	if (gatt_svc == MESH_GATT_NONE) {
   17af6:	4d12      	ldr	r5, [pc, #72]	; (17b40 <bt_mesh_proxy_prov_disable+0x4c>)
   17af8:	782b      	ldrb	r3, [r5, #0]
{
   17afa:	4604      	mov	r4, r0
	if (gatt_svc == MESH_GATT_NONE) {
   17afc:	b1cb      	cbz	r3, 17b32 <bt_mesh_proxy_prov_disable+0x3e>
	if (gatt_svc != MESH_GATT_PROV) {
   17afe:	2b01      	cmp	r3, #1
   17b00:	d11a      	bne.n	17b38 <bt_mesh_proxy_prov_disable+0x44>
	bt_gatt_service_unregister(&prov_svc);
   17b02:	4810      	ldr	r0, [pc, #64]	; (17b44 <bt_mesh_proxy_prov_disable+0x50>)
   17b04:	f7f3 fb96 	bl	b234 <bt_gatt_service_unregister>
	gatt_svc = MESH_GATT_NONE;
   17b08:	2300      	movs	r3, #0
   17b0a:	702b      	strb	r3, [r5, #0]
		if (!client->conn || client->filter_type != PROV) {
   17b0c:	4d0e      	ldr	r5, [pc, #56]	; (17b48 <bt_mesh_proxy_prov_disable+0x54>)
   17b0e:	6828      	ldr	r0, [r5, #0]
   17b10:	b110      	cbz	r0, 17b18 <bt_mesh_proxy_prov_disable+0x24>
   17b12:	7aab      	ldrb	r3, [r5, #10]
   17b14:	2b03      	cmp	r3, #3
   17b16:	d003      	beq.n	17b20 <bt_mesh_proxy_prov_disable+0x2c>
	bt_mesh_adv_update();
   17b18:	f7f4 fad6 	bl	c0c8 <bt_mesh_adv_update>
	return 0;
   17b1c:	2000      	movs	r0, #0
}
   17b1e:	bd38      	pop	{r3, r4, r5, pc}
		if (disconnect) {
   17b20:	b11c      	cbz	r4, 17b2a <bt_mesh_proxy_prov_disable+0x36>
			bt_conn_disconnect(client->conn,
   17b22:	2113      	movs	r1, #19
   17b24:	f00e fd4a 	bl	265bc <bt_conn_disconnect>
   17b28:	e7f6      	b.n	17b18 <bt_mesh_proxy_prov_disable+0x24>
			bt_mesh_pb_gatt_close(client->conn);
   17b2a:	f7ff fbad 	bl	17288 <bt_mesh_pb_gatt_close>
			client->filter_type = NONE;
   17b2e:	72ac      	strb	r4, [r5, #10]
   17b30:	e7f2      	b.n	17b18 <bt_mesh_proxy_prov_disable+0x24>
		return -EALREADY;
   17b32:	f06f 0044 	mvn.w	r0, #68	; 0x44
   17b36:	e7f2      	b.n	17b1e <bt_mesh_proxy_prov_disable+0x2a>
		return -EBUSY;
   17b38:	f06f 000f 	mvn.w	r0, #15
   17b3c:	e7ef      	b.n	17b1e <bt_mesh_proxy_prov_disable+0x2a>
   17b3e:	bf00      	nop
   17b40:	200024c5 	.word	0x200024c5
   17b44:	20007020 	.word	0x20007020
   17b48:	20006f38 	.word	0x20006f38

00017b4c <bt_mesh_proxy_gatt_enable>:
{
   17b4c:	b538      	push	{r3, r4, r5, lr}
	if (gatt_svc == MESH_GATT_PROXY) {
   17b4e:	4d0b      	ldr	r5, [pc, #44]	; (17b7c <bt_mesh_proxy_gatt_enable+0x30>)
   17b50:	782c      	ldrb	r4, [r5, #0]
   17b52:	2c02      	cmp	r4, #2
   17b54:	d00c      	beq.n	17b70 <bt_mesh_proxy_gatt_enable+0x24>
	if (gatt_svc != MESH_GATT_NONE) {
   17b56:	b974      	cbnz	r4, 17b76 <bt_mesh_proxy_gatt_enable+0x2a>
	bt_gatt_service_register(&proxy_svc);
   17b58:	4809      	ldr	r0, [pc, #36]	; (17b80 <bt_mesh_proxy_gatt_enable+0x34>)
   17b5a:	f7f3 fc93 	bl	b484 <bt_gatt_service_register>
	gatt_svc = MESH_GATT_PROXY;
   17b5e:	2302      	movs	r3, #2
   17b60:	702b      	strb	r3, [r5, #0]
		if (clients[i].conn) {
   17b62:	4b08      	ldr	r3, [pc, #32]	; (17b84 <bt_mesh_proxy_gatt_enable+0x38>)
   17b64:	6818      	ldr	r0, [r3, #0]
   17b66:	b110      	cbz	r0, 17b6e <bt_mesh_proxy_gatt_enable+0x22>
			clients[i].filter_type = WHITELIST;
   17b68:	2201      	movs	r2, #1
   17b6a:	729a      	strb	r2, [r3, #10]
	return 0;
   17b6c:	4620      	mov	r0, r4
}
   17b6e:	bd38      	pop	{r3, r4, r5, pc}
		return -EALREADY;
   17b70:	f06f 0044 	mvn.w	r0, #68	; 0x44
   17b74:	e7fb      	b.n	17b6e <bt_mesh_proxy_gatt_enable+0x22>
		return -EBUSY;
   17b76:	f06f 000f 	mvn.w	r0, #15
   17b7a:	e7f8      	b.n	17b6e <bt_mesh_proxy_gatt_enable+0x22>
   17b7c:	200024c5 	.word	0x200024c5
   17b80:	200070bc 	.word	0x200070bc
   17b84:	20006f38 	.word	0x20006f38

00017b88 <bt_mesh_proxy_gatt_disconnect>:
		if (client->conn && (client->filter_type == WHITELIST ||
   17b88:	4b06      	ldr	r3, [pc, #24]	; (17ba4 <bt_mesh_proxy_gatt_disconnect+0x1c>)
   17b8a:	6818      	ldr	r0, [r3, #0]
   17b8c:	b140      	cbz	r0, 17ba0 <bt_mesh_proxy_gatt_disconnect+0x18>
   17b8e:	7a9a      	ldrb	r2, [r3, #10]
   17b90:	3a01      	subs	r2, #1
   17b92:	2a01      	cmp	r2, #1
   17b94:	d804      	bhi.n	17ba0 <bt_mesh_proxy_gatt_disconnect+0x18>
			client->filter_type = NONE;
   17b96:	2200      	movs	r2, #0
   17b98:	729a      	strb	r2, [r3, #10]
			bt_conn_disconnect(client->conn,
   17b9a:	2113      	movs	r1, #19
   17b9c:	f00e bd0e 	b.w	265bc <bt_conn_disconnect>
}
   17ba0:	4770      	bx	lr
   17ba2:	bf00      	nop
   17ba4:	20006f38 	.word	0x20006f38

00017ba8 <bt_mesh_proxy_gatt_disable>:
{
   17ba8:	b510      	push	{r4, lr}
	if (gatt_svc == MESH_GATT_NONE) {
   17baa:	4c09      	ldr	r4, [pc, #36]	; (17bd0 <bt_mesh_proxy_gatt_disable+0x28>)
   17bac:	7823      	ldrb	r3, [r4, #0]
   17bae:	b14b      	cbz	r3, 17bc4 <bt_mesh_proxy_gatt_disable+0x1c>
	if (gatt_svc != MESH_GATT_PROXY) {
   17bb0:	2b02      	cmp	r3, #2
   17bb2:	d10a      	bne.n	17bca <bt_mesh_proxy_gatt_disable+0x22>
	bt_mesh_proxy_gatt_disconnect();
   17bb4:	f7ff ffe8 	bl	17b88 <bt_mesh_proxy_gatt_disconnect>
	bt_gatt_service_unregister(&proxy_svc);
   17bb8:	4806      	ldr	r0, [pc, #24]	; (17bd4 <bt_mesh_proxy_gatt_disable+0x2c>)
   17bba:	f7f3 fb3b 	bl	b234 <bt_gatt_service_unregister>
	gatt_svc = MESH_GATT_NONE;
   17bbe:	2000      	movs	r0, #0
   17bc0:	7020      	strb	r0, [r4, #0]
}
   17bc2:	bd10      	pop	{r4, pc}
		return -EALREADY;
   17bc4:	f06f 0044 	mvn.w	r0, #68	; 0x44
   17bc8:	e7fb      	b.n	17bc2 <bt_mesh_proxy_gatt_disable+0x1a>
		return -EBUSY;
   17bca:	f06f 000f 	mvn.w	r0, #15
   17bce:	e7f8      	b.n	17bc2 <bt_mesh_proxy_gatt_disable+0x1a>
   17bd0:	200024c5 	.word	0x200024c5
   17bd4:	200070bc 	.word	0x200070bc

00017bd8 <bt_mesh_proxy_send>:
	return 0;
}

int bt_mesh_proxy_send(struct bt_conn *conn, u8_t type,
		       struct net_buf_simple *msg)
{
   17bd8:	b538      	push	{r3, r4, r5, lr}
		if (clients[i].conn == conn) {
   17bda:	4c17      	ldr	r4, [pc, #92]	; (17c38 <bt_mesh_proxy_send+0x60>)
   17bdc:	6825      	ldr	r5, [r4, #0]
   17bde:	4285      	cmp	r5, r0
   17be0:	d00c      	beq.n	17bfc <bt_mesh_proxy_send+0x24>
   17be2:	4b16      	ldr	r3, [pc, #88]	; (17c3c <bt_mesh_proxy_send+0x64>)
   17be4:	4916      	ldr	r1, [pc, #88]	; (17c40 <bt_mesh_proxy_send+0x68>)
	struct bt_mesh_proxy_client *client = find_client(conn);

	if (!client) {
		BT_ERR("No Proxy Client found");
   17be6:	4817      	ldr	r0, [pc, #92]	; (17c44 <bt_mesh_proxy_send+0x6c>)
   17be8:	1ac9      	subs	r1, r1, r3
   17bea:	08c9      	lsrs	r1, r1, #3
   17bec:	0189      	lsls	r1, r1, #6
   17bee:	f041 0101 	orr.w	r1, r1, #1
   17bf2:	f00c f9e7 	bl	23fc4 <log_0>
		return -ENOTCONN;
   17bf6:	f06f 0038 	mvn.w	r0, #56	; 0x38
		BT_ERR("Invalid PDU type for Proxy Client");
		return -EINVAL;
	}

	return proxy_segment_and_send(conn, type, msg);
}
   17bfa:	bd38      	pop	{r3, r4, r5, pc}
	if ((client->filter_type == PROV) != (type == BT_MESH_PROXY_PROV)) {
   17bfc:	7aa4      	ldrb	r4, [r4, #10]
   17bfe:	1ee5      	subs	r5, r4, #3
   17c00:	426c      	negs	r4, r5
   17c02:	f1a1 0c03 	sub.w	ip, r1, #3
   17c06:	416c      	adcs	r4, r5
   17c08:	f1dc 0300 	rsbs	r3, ip, #0
   17c0c:	eb43 030c 	adc.w	r3, r3, ip
   17c10:	429c      	cmp	r4, r3
   17c12:	d00c      	beq.n	17c2e <bt_mesh_proxy_send+0x56>
   17c14:	4b09      	ldr	r3, [pc, #36]	; (17c3c <bt_mesh_proxy_send+0x64>)
   17c16:	490a      	ldr	r1, [pc, #40]	; (17c40 <bt_mesh_proxy_send+0x68>)
		BT_ERR("Invalid PDU type for Proxy Client");
   17c18:	480b      	ldr	r0, [pc, #44]	; (17c48 <bt_mesh_proxy_send+0x70>)
   17c1a:	1ac9      	subs	r1, r1, r3
   17c1c:	08c9      	lsrs	r1, r1, #3
   17c1e:	0189      	lsls	r1, r1, #6
   17c20:	f041 0101 	orr.w	r1, r1, #1
   17c24:	f00c f9ce 	bl	23fc4 <log_0>
		return -EINVAL;
   17c28:	f06f 0015 	mvn.w	r0, #21
   17c2c:	e7e5      	b.n	17bfa <bt_mesh_proxy_send+0x22>
}
   17c2e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return proxy_segment_and_send(conn, type, msg);
   17c32:	f010 b97b 	b.w	27f2c <proxy_segment_and_send>
   17c36:	bf00      	nop
   17c38:	20006f38 	.word	0x20006f38
   17c3c:	00029830 	.word	0x00029830
   17c40:	00029978 	.word	0x00029978
   17c44:	0002ff1d 	.word	0x0002ff1d
   17c48:	0002ff33 	.word	0x0002ff33

00017c4c <bt_mesh_proxy_relay>:
{
   17c4c:	b530      	push	{r4, r5, lr}
		if (!client->conn) {
   17c4e:	4c1c      	ldr	r4, [pc, #112]	; (17cc0 <bt_mesh_proxy_relay+0x74>)
{
   17c50:	b08d      	sub	sp, #52	; 0x34
		NET_BUF_SIMPLE_DEFINE(msg, 32);
   17c52:	ab04      	add	r3, sp, #16
   17c54:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   17c58:	e9cd 2302 	strd	r2, r3, [sp, #8]
   17c5c:	9301      	str	r3, [sp, #4]
		if (!client->conn) {
   17c5e:	6823      	ldr	r3, [r4, #0]
{
   17c60:	4605      	mov	r5, r0
		if (!client->conn) {
   17c62:	b15b      	cbz	r3, 17c7c <bt_mesh_proxy_relay+0x30>
	if (client->filter_type == BLACKLIST) {
   17c64:	7aa3      	ldrb	r3, [r4, #10]
   17c66:	2b02      	cmp	r3, #2
   17c68:	d10a      	bne.n	17c80 <bt_mesh_proxy_relay+0x34>
			if (client->filter[i] == addr) {
   17c6a:	88a3      	ldrh	r3, [r4, #4]
   17c6c:	428b      	cmp	r3, r1
   17c6e:	d005      	beq.n	17c7c <bt_mesh_proxy_relay+0x30>
   17c70:	88e3      	ldrh	r3, [r4, #6]
   17c72:	428b      	cmp	r3, r1
   17c74:	d002      	beq.n	17c7c <bt_mesh_proxy_relay+0x30>
   17c76:	8923      	ldrh	r3, [r4, #8]
   17c78:	428b      	cmp	r3, r1
   17c7a:	d110      	bne.n	17c9e <bt_mesh_proxy_relay+0x52>
	bool relayed = false;
   17c7c:	2000      	movs	r0, #0
   17c7e:	e01d      	b.n	17cbc <bt_mesh_proxy_relay+0x70>
	if (addr == BT_MESH_ADDR_ALL_NODES) {
   17c80:	f64f 72ff 	movw	r2, #65535	; 0xffff
   17c84:	4291      	cmp	r1, r2
   17c86:	d00a      	beq.n	17c9e <bt_mesh_proxy_relay+0x52>
	if (client->filter_type == WHITELIST) {
   17c88:	2b01      	cmp	r3, #1
   17c8a:	d1f7      	bne.n	17c7c <bt_mesh_proxy_relay+0x30>
			if (client->filter[i] == addr) {
   17c8c:	88a3      	ldrh	r3, [r4, #4]
   17c8e:	428b      	cmp	r3, r1
   17c90:	d005      	beq.n	17c9e <bt_mesh_proxy_relay+0x52>
   17c92:	88e3      	ldrh	r3, [r4, #6]
   17c94:	428b      	cmp	r3, r1
   17c96:	d002      	beq.n	17c9e <bt_mesh_proxy_relay+0x52>
   17c98:	8923      	ldrh	r3, [r4, #8]
   17c9a:	428b      	cmp	r3, r1
   17c9c:	d1ee      	bne.n	17c7c <bt_mesh_proxy_relay+0x30>
		net_buf_simple_reserve(&msg, 1);
   17c9e:	2101      	movs	r1, #1
   17ca0:	a801      	add	r0, sp, #4
   17ca2:	f007 f90d 	bl	1eec0 <net_buf_simple_reserve>
		net_buf_simple_add_mem(&msg, buf->data, buf->len);
   17ca6:	88aa      	ldrh	r2, [r5, #4]
   17ca8:	6829      	ldr	r1, [r5, #0]
   17caa:	a801      	add	r0, sp, #4
   17cac:	f011 f883 	bl	28db6 <net_buf_simple_add_mem>
		bt_mesh_proxy_send(client->conn, BT_MESH_PROXY_NET_PDU, &msg);
   17cb0:	6820      	ldr	r0, [r4, #0]
   17cb2:	aa01      	add	r2, sp, #4
   17cb4:	2100      	movs	r1, #0
   17cb6:	f7ff ff8f 	bl	17bd8 <bt_mesh_proxy_send>
		relayed = true;
   17cba:	2001      	movs	r0, #1
}
   17cbc:	b00d      	add	sp, #52	; 0x34
   17cbe:	bd30      	pop	{r4, r5, pc}
   17cc0:	20006f38 	.word	0x20006f38

00017cc4 <bt_mesh_proxy_adv_start>:
	return prov_sd_len;
}
#endif /* CONFIG_BT_MESH_PB_GATT */

s32_t bt_mesh_proxy_adv_start(void)
{
   17cc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	BT_DBG("");

	if (gatt_svc == MESH_GATT_NONE) {
   17cc8:	4bc1      	ldr	r3, [pc, #772]	; (17fd0 <bt_mesh_proxy_adv_start+0x30c>)
   17cca:	781b      	ldrb	r3, [r3, #0]
{
   17ccc:	b086      	sub	sp, #24
	if (gatt_svc == MESH_GATT_NONE) {
   17cce:	b913      	cbnz	r3, 17cd6 <bt_mesh_proxy_adv_start+0x12>
		return remaining;
   17cd0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   17cd4:	e069      	b.n	17daa <bt_mesh_proxy_adv_start+0xe6>
		return K_FOREVER;
	}

#if defined(CONFIG_BT_MESH_PB_GATT)
	if (!bt_mesh_is_provisioned()) {
   17cd6:	f7f4 f869 	bl	bdac <bt_mesh_is_provisioned>
   17cda:	4681      	mov	r9, r0
   17cdc:	2800      	cmp	r0, #0
   17cde:	d168      	bne.n	17db2 <bt_mesh_proxy_adv_start+0xee>
		const struct bt_le_adv_param *param;
		struct bt_data prov_sd[2];
		size_t prov_sd_len;

		if (prov_fast_adv) {
   17ce0:	4cbc      	ldr	r4, [pc, #752]	; (17fd4 <bt_mesh_proxy_adv_start+0x310>)
			param = &fast_adv_param;
		} else {
			param = &slow_adv_param;
   17ce2:	4bbd      	ldr	r3, [pc, #756]	; (17fd8 <bt_mesh_proxy_adv_start+0x314>)
		if (prov_fast_adv) {
   17ce4:	7822      	ldrb	r2, [r4, #0]
			param = &slow_adv_param;
   17ce6:	4ebd      	ldr	r6, [pc, #756]	; (17fdc <bt_mesh_proxy_adv_start+0x318>)
	memcpy(prov_svc_data + 2, prov->uuid, 16);
   17ce8:	f8df 832c 	ldr.w	r8, [pc, #812]	; 18018 <bt_mesh_proxy_adv_start+0x354>
			param = &slow_adv_param;
   17cec:	2a00      	cmp	r2, #0
   17cee:	bf08      	it	eq
   17cf0:	461e      	moveq	r6, r3
	const struct bt_mesh_prov *prov = bt_mesh_prov_get();
   17cf2:	f7fe fc11 	bl	16518 <bt_mesh_prov_get>
   17cf6:	4682      	mov	sl, r0
	const char *name = bt_get_name();
   17cf8:	f7f0 f960 	bl	7fbc <bt_get_name>
   17cfc:	4607      	mov	r7, r0
	size_t name_len = strlen(name);
   17cfe:	f00d ffa1 	bl	25c44 <strlen>
	memcpy(prov_svc_data + 2, prov->uuid, 16);
   17d02:	2210      	movs	r2, #16
   17d04:	f8da 1000 	ldr.w	r1, [sl]
	size_t name_len = strlen(name);
   17d08:	4605      	mov	r5, r0
	memcpy(prov_svc_data + 2, prov->uuid, 16);
   17d0a:	f108 0002 	add.w	r0, r8, #2
   17d0e:	f00d ffcb 	bl	25ca8 <memcpy>
	sys_put_be16(prov->oob_info, prov_svc_data + 18);
   17d12:	f8ba 3008 	ldrh.w	r3, [sl, #8]
	dst[1] = val;
   17d16:	f888 3013 	strb.w	r3, [r8, #19]
	dst[0] = val >> 8;
   17d1a:	0a1a      	lsrs	r2, r3, #8
   17d1c:	f888 2012 	strb.w	r2, [r8, #18]
	if (prov->uri) {
   17d20:	f8da 0004 	ldr.w	r0, [sl, #4]
   17d24:	f10d 0808 	add.w	r8, sp, #8
   17d28:	b170      	cbz	r0, 17d48 <bt_mesh_proxy_adv_start+0x84>
		size_t uri_len = strlen(prov->uri);
   17d2a:	f00d ff8b 	bl	25c44 <strlen>
		if (uri_len > 29) {
   17d2e:	281d      	cmp	r0, #29
   17d30:	d90c      	bls.n	17d4c <bt_mesh_proxy_adv_start+0x88>
   17d32:	4bab      	ldr	r3, [pc, #684]	; (17fe0 <bt_mesh_proxy_adv_start+0x31c>)
   17d34:	49ab      	ldr	r1, [pc, #684]	; (17fe4 <bt_mesh_proxy_adv_start+0x320>)
			BT_WARN("Too long URI to fit advertising packet");
   17d36:	48ac      	ldr	r0, [pc, #688]	; (17fe8 <bt_mesh_proxy_adv_start+0x324>)
   17d38:	1ac9      	subs	r1, r1, r3
   17d3a:	08c9      	lsrs	r1, r1, #3
   17d3c:	0189      	lsls	r1, r1, #6
   17d3e:	f041 0102 	orr.w	r1, r1, #2
   17d42:	f00c f93f 	bl	23fc4 <log_0>
	size_t prov_sd_len = 0;
   17d46:	4648      	mov	r0, r9
	size_t sd_space = 31;
   17d48:	221f      	movs	r2, #31
   17d4a:	e00d      	b.n	17d68 <bt_mesh_proxy_adv_start+0xa4>
			prov_sd[0].type = BT_DATA_URI;
   17d4c:	2324      	movs	r3, #36	; 0x24
			prov_sd[0].data_len = uri_len;
   17d4e:	f88d 0009 	strb.w	r0, [sp, #9]
			sd_space -= 2 + uri_len;
   17d52:	f1c0 021d 	rsb	r2, r0, #29
			prov_sd[0].type = BT_DATA_URI;
   17d56:	f88d 3008 	strb.w	r3, [sp, #8]
			prov_sd[0].data = prov->uri;
   17d5a:	f8da 3004 	ldr.w	r3, [sl, #4]
   17d5e:	9303      	str	r3, [sp, #12]
	if (sd_space > 2 && name_len > 0) {
   17d60:	2a02      	cmp	r2, #2
			prov_sd_len++;
   17d62:	f04f 0001 	mov.w	r0, #1
	if (sd_space > 2 && name_len > 0) {
   17d66:	d910      	bls.n	17d8a <bt_mesh_proxy_adv_start+0xc6>
   17d68:	b17d      	cbz	r5, 17d8a <bt_mesh_proxy_adv_start+0xc6>
		sd_space -= 2;
   17d6a:	3a02      	subs	r2, #2
		if (sd_space < name_len) {
   17d6c:	4295      	cmp	r5, r2
			prov_sd[prov_sd_len].type = BT_DATA_NAME_SHORTENED;
   17d6e:	eb08 03c0 	add.w	r3, r8, r0, lsl #3
   17d72:	bf8b      	itete	hi
   17d74:	2108      	movhi	r1, #8
			prov_sd[prov_sd_len].type = BT_DATA_NAME_COMPLETE;
   17d76:	2209      	movls	r2, #9
			prov_sd[prov_sd_len].type = BT_DATA_NAME_SHORTENED;
   17d78:	f808 1030 	strbhi.w	r1, [r8, r0, lsl #3]
			prov_sd[prov_sd_len].type = BT_DATA_NAME_COMPLETE;
   17d7c:	f808 2030 	strbls.w	r2, [r8, r0, lsl #3]
			prov_sd[prov_sd_len].data_len = sd_space;
   17d80:	bf8c      	ite	hi
   17d82:	705a      	strbhi	r2, [r3, #1]
			prov_sd[prov_sd_len].data_len = name_len;
   17d84:	705d      	strbls	r5, [r3, #1]
		prov_sd[prov_sd_len].data = name;
   17d86:	605f      	str	r7, [r3, #4]
		prov_sd_len++;
   17d88:	3001      	adds	r0, #1
		}

		prov_sd_len = gatt_prov_adv_create(prov_sd);

		if (bt_le_adv_start(param, prov_ad, ARRAY_SIZE(prov_ad),
   17d8a:	9000      	str	r0, [sp, #0]
   17d8c:	4997      	ldr	r1, [pc, #604]	; (17fec <bt_mesh_proxy_adv_start+0x328>)
   17d8e:	4643      	mov	r3, r8
   17d90:	2203      	movs	r2, #3
   17d92:	4630      	mov	r0, r6
   17d94:	f00e fb4b 	bl	2642e <bt_le_adv_start>
   17d98:	b958      	cbnz	r0, 17db2 <bt_mesh_proxy_adv_start+0xee>
				    prov_sd, prov_sd_len) == 0) {
			proxy_adv_enabled = true;
   17d9a:	4b95      	ldr	r3, [pc, #596]	; (17ff0 <bt_mesh_proxy_adv_start+0x32c>)
   17d9c:	2201      	movs	r2, #1
   17d9e:	701a      	strb	r2, [r3, #0]

			/* Advertise 60 seconds using fast interval */
			if (prov_fast_adv) {
   17da0:	7823      	ldrb	r3, [r4, #0]
   17da2:	b133      	cbz	r3, 17db2 <bt_mesh_proxy_adv_start+0xee>
				prov_fast_adv = false;
   17da4:	7020      	strb	r0, [r4, #0]
				return K_SECONDS(60);
   17da6:	f64e 2560 	movw	r5, #60000	; 0xea60
		return gatt_proxy_advertise(next_sub());
	}
#endif /* GATT_PROXY */

	return K_FOREVER;
}
   17daa:	4628      	mov	r0, r5
   17dac:	b006      	add	sp, #24
   17dae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (bt_mesh_is_provisioned()) {
   17db2:	f7f3 fffb 	bl	bdac <bt_mesh_is_provisioned>
   17db6:	2800      	cmp	r0, #0
   17db8:	d08a      	beq.n	17cd0 <bt_mesh_proxy_adv_start+0xc>
		sub = &bt_mesh.sub[(i + next_idx) % ARRAY_SIZE(bt_mesh.sub)];
   17dba:	4d8e      	ldr	r5, [pc, #568]	; (17ff4 <bt_mesh_proxy_adv_start+0x330>)
	if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   17dbc:	4e8e      	ldr	r6, [pc, #568]	; (17ff8 <bt_mesh_proxy_adv_start+0x334>)
		sub = &bt_mesh.sub[(i + next_idx) % ARRAY_SIZE(bt_mesh.sub)];
   17dbe:	682c      	ldr	r4, [r5, #0]
   17dc0:	2c00      	cmp	r4, #0
   17dc2:	f004 0401 	and.w	r4, r4, #1
   17dc6:	bfb8      	it	lt
   17dc8:	4264      	neglt	r4, r4
	if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   17dca:	23e4      	movs	r3, #228	; 0xe4
   17dcc:	fb03 6304 	mla	r3, r3, r4, r6
   17dd0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   17dd4:	f8b3 11b8 	ldrh.w	r1, [r3, #440]	; 0x1b8
   17dd8:	4291      	cmp	r1, r2
   17dda:	d007      	beq.n	17dec <bt_mesh_proxy_adv_start+0x128>
	return (sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING ||
   17ddc:	f893 31bc 	ldrb.w	r3, [r3, #444]	; 0x1bc
   17de0:	2b01      	cmp	r3, #1
   17de2:	d016      	beq.n	17e12 <bt_mesh_proxy_adv_start+0x14e>
		bt_mesh_gatt_proxy_get() != BT_MESH_GATT_PROXY_NOT_SUPPORTED);
   17de4:	f7fa fbda 	bl	1259c <bt_mesh_gatt_proxy_get>
		if (advertise_subnet(sub)) {
   17de8:	2802      	cmp	r0, #2
   17dea:	d112      	bne.n	17e12 <bt_mesh_proxy_adv_start+0x14e>
		sub = &bt_mesh.sub[(i + next_idx) % ARRAY_SIZE(bt_mesh.sub)];
   17dec:	682c      	ldr	r4, [r5, #0]
   17dee:	3401      	adds	r4, #1
   17df0:	f004 0401 	and.w	r4, r4, #1
   17df4:	bf48      	it	mi
   17df6:	4264      	negmi	r4, r4
	if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   17df8:	23e4      	movs	r3, #228	; 0xe4
   17dfa:	fb03 6304 	mla	r3, r3, r4, r6
   17dfe:	f64f 72ff 	movw	r2, #65535	; 0xffff
   17e02:	f8b3 11b8 	ldrh.w	r1, [r3, #440]	; 0x1b8
   17e06:	4291      	cmp	r1, r2
   17e08:	d025      	beq.n	17e56 <bt_mesh_proxy_adv_start+0x192>
	return (sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING ||
   17e0a:	f893 31bc 	ldrb.w	r3, [r3, #444]	; 0x1bc
   17e0e:	2b01      	cmp	r3, #1
   17e10:	d11d      	bne.n	17e4e <bt_mesh_proxy_adv_start+0x18a>
			next_idx = (next_idx + 1) % ARRAY_SIZE(bt_mesh.sub);
   17e12:	682b      	ldr	r3, [r5, #0]
   17e14:	3301      	adds	r3, #1
   17e16:	f003 0301 	and.w	r3, r3, #1
		sub = &bt_mesh.sub[(i + next_idx) % ARRAY_SIZE(bt_mesh.sub)];
   17e1a:	f04f 01e4 	mov.w	r1, #228	; 0xe4
   17e1e:	fb01 6404 	mla	r4, r1, r4, r6
			next_idx = (next_idx + 1) % ARRAY_SIZE(bt_mesh.sub);
   17e22:	bf48      	it	mi
   17e24:	425b      	negmi	r3, r3
		sub = &bt_mesh.sub[(i + next_idx) % ARRAY_SIZE(bt_mesh.sub)];
   17e26:	f504 74ce 	add.w	r4, r4, #412	; 0x19c
			next_idx = (next_idx + 1) % ARRAY_SIZE(bt_mesh.sub);
   17e2a:	602b      	str	r3, [r5, #0]
	if (conn_count == CONFIG_BT_MAX_CONN) {
   17e2c:	4b73      	ldr	r3, [pc, #460]	; (17ffc <bt_mesh_proxy_adv_start+0x338>)
   17e2e:	681b      	ldr	r3, [r3, #0]
   17e30:	2b01      	cmp	r3, #1
   17e32:	f43f af4d 	beq.w	17cd0 <bt_mesh_proxy_adv_start+0xc>
	if (!sub) {
   17e36:	b984      	cbnz	r4, 17e5a <bt_mesh_proxy_adv_start+0x196>
   17e38:	4b69      	ldr	r3, [pc, #420]	; (17fe0 <bt_mesh_proxy_adv_start+0x31c>)
   17e3a:	496a      	ldr	r1, [pc, #424]	; (17fe4 <bt_mesh_proxy_adv_start+0x320>)
		BT_WARN("No subnets to advertise on");
   17e3c:	4870      	ldr	r0, [pc, #448]	; (18000 <bt_mesh_proxy_adv_start+0x33c>)
   17e3e:	1ac9      	subs	r1, r1, r3
   17e40:	08c9      	lsrs	r1, r1, #3
   17e42:	0189      	lsls	r1, r1, #6
   17e44:	f041 0102 	orr.w	r1, r1, #2
   17e48:	f00c f8bc 	bl	23fc4 <log_0>
   17e4c:	e740      	b.n	17cd0 <bt_mesh_proxy_adv_start+0xc>
		bt_mesh_gatt_proxy_get() != BT_MESH_GATT_PROXY_NOT_SUPPORTED);
   17e4e:	f7fa fba5 	bl	1259c <bt_mesh_gatt_proxy_get>
		if (advertise_subnet(sub)) {
   17e52:	2802      	cmp	r0, #2
   17e54:	d1dd      	bne.n	17e12 <bt_mesh_proxy_adv_start+0x14e>
	return NULL;
   17e56:	2400      	movs	r4, #0
   17e58:	e7e8      	b.n	17e2c <bt_mesh_proxy_adv_start+0x168>
	if (sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING) {
   17e5a:	f894 8020 	ldrb.w	r8, [r4, #32]
   17e5e:	f1b8 0f01 	cmp.w	r8, #1
   17e62:	f040 80a5 	bne.w	17fb0 <bt_mesh_proxy_adv_start+0x2ec>
   17e66:	f011 fad4 	bl	29412 <z_impl_k_uptime_ticks>
   17e6a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   17e6e:	460d      	mov	r5, r1
   17e70:	fba0 0103 	umull	r0, r1, r0, r3
   17e74:	fb03 1105 	mla	r1, r3, r5, r1
   17e78:	0bc3      	lsrs	r3, r0, #15
		u32_t active = k_uptime_get_32() - sub->node_id_start;
   17e7a:	6a65      	ldr	r5, [r4, #36]	; 0x24
   17e7c:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
   17e80:	1b58      	subs	r0, r3, r5
		if (active < NODE_ID_TIMEOUT) {
   17e82:	f242 710f 	movw	r1, #9999	; 0x270f
   17e86:	4288      	cmp	r0, r1
   17e88:	f04f 0200 	mov.w	r2, #0
   17e8c:	f200 808d 	bhi.w	17faa <bt_mesh_proxy_adv_start+0x2e6>
	proxy_svc_data[2] = ID_TYPE_NODE;
   17e90:	f8df 9178 	ldr.w	r9, [pc, #376]	; 1800c <bt_mesh_proxy_adv_start+0x348>
			remaining = NODE_ID_TIMEOUT - active;
   17e94:	f505 551c 	add.w	r5, r5, #9984	; 0x2700
	err = bt_rand(proxy_svc_data + 11, 8);
   17e98:	2108      	movs	r1, #8
			remaining = NODE_ID_TIMEOUT - active;
   17e9a:	3510      	adds	r5, #16
	err = bt_rand(proxy_svc_data + 11, 8);
   17e9c:	f109 000b 	add.w	r0, r9, #11
			remaining = NODE_ID_TIMEOUT - active;
   17ea0:	1aed      	subs	r5, r5, r3
	proxy_svc_data[2] = ID_TYPE_NODE;
   17ea2:	f889 8002 	strb.w	r8, [r9, #2]
	err = bt_rand(proxy_svc_data + 11, 8);
   17ea6:	f010 fa74 	bl	28392 <bt_rand>
	if (err) {
   17eaa:	4601      	mov	r1, r0
   17eac:	2800      	cmp	r0, #0
   17eae:	d134      	bne.n	17f1a <bt_mesh_proxy_adv_start+0x256>
	(void)memset(tmp, 0, 6);
   17eb0:	2206      	movs	r2, #6
   17eb2:	a802      	add	r0, sp, #8
   17eb4:	f00d ff23 	bl	25cfe <memset>
	memcpy(tmp + 6, proxy_svc_data + 11, 8);
   17eb8:	2208      	movs	r2, #8
   17eba:	f109 010b 	add.w	r1, r9, #11
   17ebe:	f10d 000e 	add.w	r0, sp, #14
   17ec2:	f00d fef1 	bl	25ca8 <memcpy>
	sys_put_be16(bt_mesh_primary_addr(), tmp + 14);
   17ec6:	f7f7 fdf1 	bl	faac <bt_mesh_primary_addr>
	err = bt_encrypt_be(sub->keys[sub->kr_flag].identity, tmp, tmp);
   17eca:	7fa3      	ldrb	r3, [r4, #30]
   17ecc:	ba40      	rev16	r0, r0
   17ece:	f8ad 0016 	strh.w	r0, [sp, #22]
   17ed2:	2059      	movs	r0, #89	; 0x59
   17ed4:	fb03 0000 	mla	r0, r3, r0, r0
   17ed8:	aa02      	add	r2, sp, #8
   17eda:	4611      	mov	r1, r2
   17edc:	4420      	add	r0, r4
   17ede:	f010 fa5a 	bl	28396 <bt_encrypt_be>
	if (err) {
   17ee2:	4607      	mov	r7, r0
   17ee4:	b9c8      	cbnz	r0, 17f1a <bt_mesh_proxy_adv_start+0x256>
	memcpy(proxy_svc_data + 3, tmp + 8, 8);
   17ee6:	2208      	movs	r2, #8
   17ee8:	a904      	add	r1, sp, #16
   17eea:	f109 0003 	add.w	r0, r9, #3
   17eee:	f00d fedb 	bl	25ca8 <memcpy>
	err = bt_le_adv_start(&fast_adv_param, node_id_ad,
   17ef2:	4944      	ldr	r1, [pc, #272]	; (18004 <bt_mesh_proxy_adv_start+0x340>)
   17ef4:	4839      	ldr	r0, [pc, #228]	; (17fdc <bt_mesh_proxy_adv_start+0x318>)
   17ef6:	9700      	str	r7, [sp, #0]
   17ef8:	463b      	mov	r3, r7
   17efa:	2203      	movs	r2, #3
   17efc:	f00e fa97 	bl	2642e <bt_le_adv_start>
	if (err) {
   17f00:	4601      	mov	r1, r0
   17f02:	2800      	cmp	r0, #0
   17f04:	d04d      	beq.n	17fa2 <bt_mesh_proxy_adv_start+0x2de>
   17f06:	4a37      	ldr	r2, [pc, #220]	; (17fe4 <bt_mesh_proxy_adv_start+0x320>)
   17f08:	4b35      	ldr	r3, [pc, #212]	; (17fe0 <bt_mesh_proxy_adv_start+0x31c>)
		BT_WARN("Failed to advertise using Node ID (err %d)", err);
   17f0a:	483f      	ldr	r0, [pc, #252]	; (18008 <bt_mesh_proxy_adv_start+0x344>)
   17f0c:	1ad2      	subs	r2, r2, r3
   17f0e:	08d2      	lsrs	r2, r2, #3
   17f10:	0192      	lsls	r2, r2, #6
   17f12:	f042 0202 	orr.w	r2, r2, #2
   17f16:	f00c f862 	bl	23fde <log_1>
	if (sub->node_id == BT_MESH_NODE_IDENTITY_STOPPED) {
   17f1a:	f894 7020 	ldrb.w	r7, [r4, #32]
   17f1e:	b9ef      	cbnz	r7, 17f5c <bt_mesh_proxy_adv_start+0x298>
	memcpy(proxy_svc_data + 3, sub->keys[sub->kr_flag].net_id, 8);
   17f20:	7fa1      	ldrb	r1, [r4, #30]
	proxy_svc_data[2] = ID_TYPE_NET;
   17f22:	483a      	ldr	r0, [pc, #232]	; (1800c <bt_mesh_proxy_adv_start+0x348>)
	memcpy(proxy_svc_data + 3, sub->keys[sub->kr_flag].net_id, 8);
   17f24:	2359      	movs	r3, #89	; 0x59
   17f26:	fb03 4101 	mla	r1, r3, r1, r4
	proxy_svc_data[2] = ID_TYPE_NET;
   17f2a:	7087      	strb	r7, [r0, #2]
	memcpy(proxy_svc_data + 3, sub->keys[sub->kr_flag].net_id, 8);
   17f2c:	2208      	movs	r2, #8
   17f2e:	3151      	adds	r1, #81	; 0x51
   17f30:	3003      	adds	r0, #3
   17f32:	f00d feb9 	bl	25ca8 <memcpy>
	err = bt_le_adv_start(&slow_adv_param, net_id_ad,
   17f36:	4936      	ldr	r1, [pc, #216]	; (18010 <bt_mesh_proxy_adv_start+0x34c>)
   17f38:	4827      	ldr	r0, [pc, #156]	; (17fd8 <bt_mesh_proxy_adv_start+0x314>)
   17f3a:	9700      	str	r7, [sp, #0]
   17f3c:	463b      	mov	r3, r7
   17f3e:	2203      	movs	r2, #3
   17f40:	f00e fa75 	bl	2642e <bt_le_adv_start>
	if (err) {
   17f44:	4601      	mov	r1, r0
   17f46:	b3b0      	cbz	r0, 17fb6 <bt_mesh_proxy_adv_start+0x2f2>
   17f48:	4a26      	ldr	r2, [pc, #152]	; (17fe4 <bt_mesh_proxy_adv_start+0x320>)
   17f4a:	4b25      	ldr	r3, [pc, #148]	; (17fe0 <bt_mesh_proxy_adv_start+0x31c>)
		BT_WARN("Failed to advertise using Network ID (err %d)", err);
   17f4c:	4831      	ldr	r0, [pc, #196]	; (18014 <bt_mesh_proxy_adv_start+0x350>)
   17f4e:	1ad2      	subs	r2, r2, r3
   17f50:	08d2      	lsrs	r2, r2, #3
   17f52:	0192      	lsls	r2, r2, #6
   17f54:	f042 0202 	orr.w	r2, r2, #2
   17f58:	f00c f841 	bl	23fde <log_1>
	if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   17f5c:	f8b6 21b8 	ldrh.w	r2, [r6, #440]	; 0x1b8
   17f60:	f64f 73ff 	movw	r3, #65535	; 0xffff
   17f64:	429a      	cmp	r2, r3
   17f66:	d02a      	beq.n	17fbe <bt_mesh_proxy_adv_start+0x2fa>
	return (sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING ||
   17f68:	f896 31bc 	ldrb.w	r3, [r6, #444]	; 0x1bc
   17f6c:	2b01      	cmp	r3, #1
   17f6e:	d003      	beq.n	17f78 <bt_mesh_proxy_adv_start+0x2b4>
		bt_mesh_gatt_proxy_get() != BT_MESH_GATT_PROXY_NOT_SUPPORTED);
   17f70:	f7fa fb14 	bl	1259c <bt_mesh_gatt_proxy_get>
		if (advertise_subnet(sub)) {
   17f74:	2802      	cmp	r0, #2
   17f76:	d022      	beq.n	17fbe <bt_mesh_proxy_adv_start+0x2fa>
			count++;
   17f78:	2401      	movs	r4, #1
	if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   17f7a:	f8b6 229c 	ldrh.w	r2, [r6, #668]	; 0x29c
   17f7e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   17f82:	429a      	cmp	r2, r3
   17f84:	f43f af11 	beq.w	17daa <bt_mesh_proxy_adv_start+0xe6>
	return (sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING ||
   17f88:	f896 32a0 	ldrb.w	r3, [r6, #672]	; 0x2a0
   17f8c:	2b01      	cmp	r3, #1
   17f8e:	d118      	bne.n	17fc2 <bt_mesh_proxy_adv_start+0x2fe>
	if (subnet_count > 1) {
   17f90:	2c00      	cmp	r4, #0
   17f92:	f43f af0a 	beq.w	17daa <bt_mesh_proxy_adv_start+0xe6>
		if (remaining > max_timeout || remaining < 0) {
   17f96:	f240 6382 	movw	r3, #1666	; 0x682
		max_timeout = MAX(max_timeout, K_SECONDS(1));
   17f9a:	429d      	cmp	r5, r3
   17f9c:	bf28      	it	cs
   17f9e:	461d      	movcs	r5, r3
   17fa0:	e703      	b.n	17daa <bt_mesh_proxy_adv_start+0xe6>
	proxy_adv_enabled = true;
   17fa2:	4b13      	ldr	r3, [pc, #76]	; (17ff0 <bt_mesh_proxy_adv_start+0x32c>)
   17fa4:	f883 8000 	strb.w	r8, [r3]
	return 0;
   17fa8:	e7b7      	b.n	17f1a <bt_mesh_proxy_adv_start+0x256>
	sub->node_id = BT_MESH_NODE_IDENTITY_STOPPED;
   17faa:	f884 2020 	strb.w	r2, [r4, #32]
	sub->node_id_start = 0U;
   17fae:	6262      	str	r2, [r4, #36]	; 0x24
	s32_t remaining = K_FOREVER;
   17fb0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   17fb4:	e7b1      	b.n	17f1a <bt_mesh_proxy_adv_start+0x256>
	proxy_adv_enabled = true;
   17fb6:	4b0e      	ldr	r3, [pc, #56]	; (17ff0 <bt_mesh_proxy_adv_start+0x32c>)
   17fb8:	2201      	movs	r2, #1
   17fba:	701a      	strb	r2, [r3, #0]
	return 0;
   17fbc:	e7ce      	b.n	17f5c <bt_mesh_proxy_adv_start+0x298>
		if (advertise_subnet(sub)) {
   17fbe:	2400      	movs	r4, #0
   17fc0:	e7db      	b.n	17f7a <bt_mesh_proxy_adv_start+0x2b6>
		bt_mesh_gatt_proxy_get() != BT_MESH_GATT_PROXY_NOT_SUPPORTED);
   17fc2:	f7fa faeb 	bl	1259c <bt_mesh_gatt_proxy_get>
		if (advertise_subnet(sub)) {
   17fc6:	2802      	cmp	r0, #2
   17fc8:	f43f aeef 	beq.w	17daa <bt_mesh_proxy_adv_start+0xe6>
   17fcc:	e7e0      	b.n	17f90 <bt_mesh_proxy_adv_start+0x2cc>
   17fce:	bf00      	nop
   17fd0:	200024c5 	.word	0x200024c5
   17fd4:	200024c6 	.word	0x200024c6
   17fd8:	0002a484 	.word	0x0002a484
   17fdc:	0002a42c 	.word	0x0002a42c
   17fe0:	00029830 	.word	0x00029830
   17fe4:	00029978 	.word	0x00029978
   17fe8:	0002ff55 	.word	0x0002ff55
   17fec:	0002a46c 	.word	0x0002a46c
   17ff0:	200024c7 	.word	0x200024c7
   17ff4:	20000cc0 	.word	0x20000cc0
   17ff8:	20006b48 	.word	0x20006b48
   17ffc:	20000cbc 	.word	0x20000cbc
   18000:	0002ff7c 	.word	0x0002ff7c
   18004:	0002a454 	.word	0x0002a454
   18008:	0002ff97 	.word	0x0002ff97
   1800c:	20007481 	.word	0x20007481
   18010:	0002a43c 	.word	0x0002a43c
   18014:	0002ffc2 	.word	0x0002ffc2
   18018:	2000746d 	.word	0x2000746d

0001801c <bt_mesh_proxy_adv_stop>:

void bt_mesh_proxy_adv_stop(void)
{
   1801c:	b510      	push	{r4, lr}
	int err;

	BT_DBG("adv_enabled %u", proxy_adv_enabled);

	if (!proxy_adv_enabled) {
   1801e:	4c0a      	ldr	r4, [pc, #40]	; (18048 <bt_mesh_proxy_adv_stop+0x2c>)
   18020:	7823      	ldrb	r3, [r4, #0]
   18022:	b183      	cbz	r3, 18046 <bt_mesh_proxy_adv_stop+0x2a>
		return;
	}

	err = bt_le_adv_stop();
   18024:	f7f0 fa48 	bl	84b8 <bt_le_adv_stop>
	if (err) {
   18028:	4601      	mov	r1, r0
   1802a:	b158      	cbz	r0, 18044 <bt_mesh_proxy_adv_stop+0x28>
   1802c:	4a07      	ldr	r2, [pc, #28]	; (1804c <bt_mesh_proxy_adv_stop+0x30>)
   1802e:	4b08      	ldr	r3, [pc, #32]	; (18050 <bt_mesh_proxy_adv_stop+0x34>)
		BT_ERR("Failed to stop advertising (err %d)", err);
   18030:	4808      	ldr	r0, [pc, #32]	; (18054 <bt_mesh_proxy_adv_stop+0x38>)
   18032:	1ad2      	subs	r2, r2, r3
   18034:	08d2      	lsrs	r2, r2, #3
   18036:	0192      	lsls	r2, r2, #6
	} else {
		proxy_adv_enabled = false;
	}
}
   18038:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_ERR("Failed to stop advertising (err %d)", err);
   1803c:	f042 0201 	orr.w	r2, r2, #1
   18040:	f00b bfcd 	b.w	23fde <log_1>
		proxy_adv_enabled = false;
   18044:	7020      	strb	r0, [r4, #0]
}
   18046:	bd10      	pop	{r4, pc}
   18048:	200024c7 	.word	0x200024c7
   1804c:	00029978 	.word	0x00029978
   18050:	00029830 	.word	0x00029830
   18054:	0002fff0 	.word	0x0002fff0

00018058 <bt_mesh_proxy_init>:
	.connected = proxy_connected,
	.disconnected = proxy_disconnected,
};

int bt_mesh_proxy_init(void)
{
   18058:	b508      	push	{r3, lr}

	/* Initialize the client receive buffers */
	for (i = 0; i < ARRAY_SIZE(clients); i++) {
		struct bt_mesh_proxy_client *client = &clients[i];

		client->buf.size = CLIENT_BUF_SIZE;
   1805a:	4807      	ldr	r0, [pc, #28]	; (18078 <bt_mesh_proxy_init+0x20>)
		client->buf.__buf = client_buf_data + (i * CLIENT_BUF_SIZE);

		k_delayed_work_init(&client->sar_timer, proxy_sar_timeout);
   1805c:	4907      	ldr	r1, [pc, #28]	; (1807c <bt_mesh_proxy_init+0x24>)
		client->buf.size = CLIENT_BUF_SIZE;
   1805e:	2344      	movs	r3, #68	; 0x44
   18060:	87c3      	strh	r3, [r0, #62]	; 0x3e
		client->buf.__buf = client_buf_data + (i * CLIENT_BUF_SIZE);
   18062:	4b07      	ldr	r3, [pc, #28]	; (18080 <bt_mesh_proxy_init+0x28>)
   18064:	6403      	str	r3, [r0, #64]	; 0x40
		k_delayed_work_init(&client->sar_timer, proxy_sar_timeout);
   18066:	3018      	adds	r0, #24
   18068:	f011 f9c7 	bl	293fa <k_delayed_work_init>
	}

	bt_conn_cb_register(&conn_callbacks);
   1806c:	4805      	ldr	r0, [pc, #20]	; (18084 <bt_mesh_proxy_init+0x2c>)
   1806e:	f7f0 fef7 	bl	8e60 <bt_conn_cb_register>

	return 0;
}
   18072:	2000      	movs	r0, #0
   18074:	bd08      	pop	{r3, pc}
   18076:	bf00      	nop
   18078:	20006f38 	.word	0x20006f38
   1807c:	0001730d 	.word	0x0001730d
   18080:	200067ca 	.word	0x200067ca
   18084:	20006f7c 	.word	0x20006f7c

00018088 <mayfly_init>:
#if defined(MAYFLY_UT)
static u8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
   18088:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	while (callee_id--) {
		u8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
   1808c:	4f11      	ldr	r7, [pc, #68]	; (180d4 <mayfly_init+0x4c>)
   1808e:	f8df a048 	ldr.w	sl, [pc, #72]	; 180d8 <mayfly_init+0x50>
	callee_id = MAYFLY_CALLEE_COUNT;
   18092:	2404      	movs	r4, #4
	while (callee_id--) {
   18094:	3c01      	subs	r4, #1
   18096:	b2e4      	uxtb	r4, r4
   18098:	2cff      	cmp	r4, #255	; 0xff
   1809a:	d018      	beq.n	180ce <mayfly_init+0x46>
   1809c:	eb04 0644 	add.w	r6, r4, r4, lsl #1
   180a0:	ea4f 0984 	mov.w	r9, r4, lsl #2
   180a4:	0136      	lsls	r6, r6, #4
		caller_id = MAYFLY_CALLER_COUNT;
   180a6:	2504      	movs	r5, #4
   180a8:	f04f 080c 	mov.w	r8, #12
   180ac:	e00a      	b.n	180c4 <mayfly_init+0x3c>
			memq_init(&mfl[callee_id][caller_id],
   180ae:	fb18 6105 	smlabb	r1, r8, r5, r6
   180b2:	1d0a      	adds	r2, r1, #4
   180b4:	eb05 0009 	add.w	r0, r5, r9
   180b8:	443a      	add	r2, r7
   180ba:	4439      	add	r1, r7
   180bc:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
   180c0:	f010 f830 	bl	28124 <memq_init>
		while (caller_id--) {
   180c4:	3d01      	subs	r5, #1
   180c6:	b2ed      	uxtb	r5, r5
   180c8:	2dff      	cmp	r5, #255	; 0xff
   180ca:	d1f0      	bne.n	180ae <mayfly_init+0x26>
   180cc:	e7e2      	b.n	18094 <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
   180ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   180d2:	bf00      	nop
   180d4:	20000d44 	.word	0x20000d44
   180d8:	20000cc4 	.word	0x20000cc4

000180dc <mayfly_enable>:

void mayfly_enable(u8_t caller_id, u8_t callee_id, u8_t enable)
{
   180dc:	b4f0      	push	{r4, r5, r6, r7}
   180de:	2630      	movs	r6, #48	; 0x30
   180e0:	240c      	movs	r4, #12
	if (enable) {
		if (mft[callee_id][caller_id].enable_req ==
   180e2:	434e      	muls	r6, r1
   180e4:	4b0f      	ldr	r3, [pc, #60]	; (18124 <mayfly_enable+0x48>)
{
   180e6:	460f      	mov	r7, r1
		if (mft[callee_id][caller_id].enable_req ==
   180e8:	fb04 6600 	mla	r6, r4, r0, r6
	if (enable) {
   180ec:	b152      	cbz	r2, 18104 <mayfly_enable+0x28>
		if (mft[callee_id][caller_id].enable_req ==
   180ee:	199c      	adds	r4, r3, r6
   180f0:	7a21      	ldrb	r1, [r4, #8]
   180f2:	7a63      	ldrb	r3, [r4, #9]
   180f4:	428b      	cmp	r3, r1
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
   180f6:	bf04      	itt	eq
   180f8:	3301      	addeq	r3, #1
   180fa:	7223      	strbeq	r3, [r4, #8]
		}

		mayfly_enable_cb(caller_id, callee_id, enable);
   180fc:	4639      	mov	r1, r7

			/* pend the callee for execution */
			mayfly_pend(caller_id, callee_id);
		}
	}
}
   180fe:	bcf0      	pop	{r4, r5, r6, r7}
		mayfly_enable_cb(caller_id, callee_id, enable);
   18100:	f006 bcbe 	b.w	1ea80 <mayfly_enable_cb>
		if (mft[callee_id][caller_id].disable_req ==
   18104:	4433      	add	r3, r6
   18106:	7a9c      	ldrb	r4, [r3, #10]
   18108:	7ada      	ldrb	r2, [r3, #11]
   1810a:	42a2      	cmp	r2, r4
   1810c:	d107      	bne.n	1811e <mayfly_enable+0x42>
			mft[callee_id][caller_id].disable_req++;
   1810e:	3201      	adds	r2, #1
   18110:	729a      	strb	r2, [r3, #10]
			mfp[callee_id] = 1U;
   18112:	4b05      	ldr	r3, [pc, #20]	; (18128 <mayfly_enable+0x4c>)
   18114:	2201      	movs	r2, #1
   18116:	545a      	strb	r2, [r3, r1]
}
   18118:	bcf0      	pop	{r4, r5, r6, r7}
			mayfly_pend(caller_id, callee_id);
   1811a:	f006 bcf1 	b.w	1eb00 <mayfly_pend>
}
   1811e:	bcf0      	pop	{r4, r5, r6, r7}
   18120:	4770      	bx	lr
   18122:	bf00      	nop
   18124:	20000d44 	.word	0x20000d44
   18128:	200024c8 	.word	0x200024c8

0001812c <mayfly_enqueue>:

u32_t mayfly_enqueue(u8_t caller_id, u8_t callee_id, u8_t chain,
			struct mayfly *m)
{
   1812c:	b570      	push	{r4, r5, r6, lr}
   1812e:	4606      	mov	r6, r0
   18130:	460d      	mov	r5, r1
   18132:	461c      	mov	r4, r3
	u8_t state;
	u8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
   18134:	b1a2      	cbz	r2, 18160 <mayfly_enqueue+0x34>
   18136:	2301      	movs	r3, #1
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
   18138:	7862      	ldrb	r2, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
   1813a:	7820      	ldrb	r0, [r4, #0]
   1813c:	1a80      	subs	r0, r0, r2
	if (state != 0U) {
   1813e:	f010 0003 	ands.w	r0, r0, #3
   18142:	d02c      	beq.n	1819e <mayfly_enqueue+0x72>
		if (chain) {
   18144:	b31b      	cbz	r3, 1818e <mayfly_enqueue+0x62>
			if (state != 1U) {
   18146:	2801      	cmp	r0, #1
   18148:	d028      	beq.n	1819c <mayfly_enqueue+0x70>
				/* mark as ready in queue */
				m->_req = ack + 1;
   1814a:	3201      	adds	r2, #1
   1814c:	b2d2      	uxtb	r2, r2
   1814e:	7022      	strb	r2, [r4, #0]
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
   18150:	4b1c      	ldr	r3, [pc, #112]	; (181c4 <mayfly_enqueue+0x98>)
   18152:	2201      	movs	r2, #1

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
   18154:	4629      	mov	r1, r5
   18156:	4630      	mov	r0, r6
	mfp[callee_id] = 1U;
   18158:	555a      	strb	r2, [r3, r5]
	mayfly_pend(caller_id, callee_id);
   1815a:	f006 fcd1 	bl	1eb00 <mayfly_pend>
   1815e:	e01c      	b.n	1819a <mayfly_enqueue+0x6e>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   18160:	f010 fd0a 	bl	28b78 <mayfly_prio_is_equal>
   18164:	2800      	cmp	r0, #0
   18166:	d0e6      	beq.n	18136 <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
   18168:	4629      	mov	r1, r5
   1816a:	4630      	mov	r0, r6
   1816c:	f006 fca8 	bl	1eac0 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   18170:	2800      	cmp	r0, #0
   18172:	d0e0      	beq.n	18136 <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
   18174:	2330      	movs	r3, #48	; 0x30
   18176:	220c      	movs	r2, #12
   18178:	436b      	muls	r3, r5
   1817a:	fb02 3306 	mla	r3, r2, r6, r3
   1817e:	4a12      	ldr	r2, [pc, #72]	; (181c8 <mayfly_enqueue+0x9c>)
   18180:	441a      	add	r2, r3
		!mayfly_is_enabled(caller_id, callee_id) ||
   18182:	7a93      	ldrb	r3, [r2, #10]
   18184:	7ad2      	ldrb	r2, [r2, #11]
   18186:	1a9b      	subs	r3, r3, r2
   18188:	bf18      	it	ne
   1818a:	2301      	movne	r3, #1
   1818c:	e7d4      	b.n	18138 <mayfly_enqueue+0xc>
		m->_req = ack + 2;
   1818e:	3202      	adds	r2, #2
   18190:	b2d2      	uxtb	r2, r2
   18192:	7022      	strb	r2, [r4, #0]
		m->fp(m->param);
   18194:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
   18198:	4798      	blx	r3

	return 0;
   1819a:	2000      	movs	r0, #0
}
   1819c:	bd70      	pop	{r4, r5, r6, pc}
	if (!chain) {
   1819e:	2b00      	cmp	r3, #0
   181a0:	d0f8      	beq.n	18194 <mayfly_enqueue+0x68>
	m->_req = ack + 1;
   181a2:	3201      	adds	r2, #1
   181a4:	b2d2      	uxtb	r2, r2
   181a6:	7022      	strb	r2, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
   181a8:	2304      	movs	r3, #4
   181aa:	2230      	movs	r2, #48	; 0x30
   181ac:	fb12 3205 	smlabb	r2, r2, r5, r3
   181b0:	230c      	movs	r3, #12
   181b2:	fb13 2306 	smlabb	r3, r3, r6, r2
   181b6:	4a04      	ldr	r2, [pc, #16]	; (181c8 <mayfly_enqueue+0x9c>)
   181b8:	6860      	ldr	r0, [r4, #4]
   181ba:	441a      	add	r2, r3
   181bc:	4621      	mov	r1, r4
   181be:	f00f ffbf 	bl	28140 <memq_enqueue>
   181c2:	e7c5      	b.n	18150 <mayfly_enqueue+0x24>
   181c4:	200024c8 	.word	0x200024c8
   181c8:	20000d44 	.word	0x20000d44

000181cc <mayfly_run>:
		}
	}
}

void mayfly_run(u8_t callee_id)
{
   181cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t disable = 0U;
	u8_t enable = 0U;
	u8_t caller_id;

	if (!mfp[callee_id]) {
   181d0:	4b5b      	ldr	r3, [pc, #364]	; (18340 <mayfly_run+0x174>)
   181d2:	5c1a      	ldrb	r2, [r3, r0]
{
   181d4:	b089      	sub	sp, #36	; 0x24
   181d6:	4604      	mov	r4, r0
	if (!mfp[callee_id]) {
   181d8:	2a00      	cmp	r2, #0
   181da:	f000 80aa 	beq.w	18332 <mayfly_run+0x166>
		return;
	}
	mfp[callee_id] = 0U;
   181de:	2700      	movs	r7, #0
   181e0:	541f      	strb	r7, [r3, r0]

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
   181e2:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   181e6:	011b      	lsls	r3, r3, #4
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   181e8:	f8df b158 	ldr.w	fp, [pc, #344]	; 18344 <mayfly_run+0x178>
   181ec:	9304      	str	r3, [sp, #16]
   181ee:	2504      	movs	r5, #4
   181f0:	233c      	movs	r3, #60	; 0x3c
   181f2:	fb13 5300 	smlabb	r3, r3, r0, r5
   181f6:	445b      	add	r3, fp
   181f8:	9303      	str	r3, [sp, #12]
	u8_t disable = 0U;
   181fa:	9700      	str	r7, [sp, #0]
   181fc:	46da      	mov	sl, fp
	while (caller_id--) {
   181fe:	3d01      	subs	r5, #1
   18200:	b2ed      	uxtb	r5, r5
   18202:	2dff      	cmp	r5, #255	; 0xff
   18204:	d10c      	bne.n	18220 <mayfly_run+0x54>
			mft[callee_id][caller_id].enable_ack =
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
   18206:	9b00      	ldr	r3, [sp, #0]
   18208:	2b00      	cmp	r3, #0
   1820a:	f000 8092 	beq.w	18332 <mayfly_run+0x166>
   1820e:	2f00      	cmp	r7, #0
   18210:	f040 808f 	bne.w	18332 <mayfly_run+0x166>
		mayfly_enable_cb(callee_id, callee_id, 0);
   18214:	463a      	mov	r2, r7
   18216:	4621      	mov	r1, r4
   18218:	4620      	mov	r0, r4
   1821a:	f006 fc31 	bl	1ea80 <mayfly_enable_cb>
   1821e:	e088      	b.n	18332 <mayfly_run+0x166>
		struct mayfly *m = 0;
   18220:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
   18222:	f04f 080c 	mov.w	r8, #12
		struct mayfly *m = 0;
   18226:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
   18228:	fb08 f805 	mul.w	r8, r8, r5
   1822c:	2330      	movs	r3, #48	; 0x30
   1822e:	fb03 8304 	mla	r3, r3, r4, r8
   18232:	eb0a 0103 	add.w	r1, sl, r3
   18236:	f85a 0003 	ldr.w	r0, [sl, r3]
   1823a:	6849      	ldr	r1, [r1, #4]
   1823c:	aa07      	add	r2, sp, #28
   1823e:	f00f ff86 	bl	2814e <memq_peek>
		memq_dequeue(mft[callee_id][caller_id].tail,
   18242:	9a04      	ldr	r2, [sp, #16]
   18244:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   18248:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1824c:	4453      	add	r3, sl
   1824e:	e9cd 8301 	strd	r8, r3, [sp, #4]
		link = memq_peek(mft[callee_id][caller_id].head,
   18252:	4606      	mov	r6, r0
		while (link) {
   18254:	2e00      	cmp	r6, #0
   18256:	d04e      	beq.n	182f6 <mayfly_run+0x12a>
			state = (m->_req - m->_ack) & 0x03;
   18258:	9b07      	ldr	r3, [sp, #28]
   1825a:	f893 9000 	ldrb.w	r9, [r3]
   1825e:	785a      	ldrb	r2, [r3, #1]
   18260:	eba9 0902 	sub.w	r9, r9, r2
   18264:	f009 0903 	and.w	r9, r9, #3
			if (state == 1U) {
   18268:	f1b9 0f01 	cmp.w	r9, #1
   1826c:	d104      	bne.n	18278 <mayfly_run+0xac>
				m->_ack--;
   1826e:	3a01      	subs	r2, #1
   18270:	705a      	strb	r2, [r3, #1]
				m->fp(m->param);
   18272:	e9d3 0202 	ldrd	r0, r2, [r3, #8]
   18276:	4790      	blx	r2
			dequeue(callee_id, caller_id, link, m);
   18278:	f8dd 801c 	ldr.w	r8, [sp, #28]
	req = m->_req;
   1827c:	f898 2000 	ldrb.w	r2, [r8]
	if (((req - m->_ack) & 0x03) != 1U) {
   18280:	f898 1001 	ldrb.w	r1, [r8, #1]
	req = m->_req;
   18284:	b2d3      	uxtb	r3, r2
	if (((req - m->_ack) & 0x03) != 1U) {
   18286:	1a52      	subs	r2, r2, r1
   18288:	f002 0203 	and.w	r2, r2, #3
   1828c:	2a01      	cmp	r2, #1
	req = m->_req;
   1828e:	9305      	str	r3, [sp, #20]
	if (((req - m->_ack) & 0x03) != 1U) {
   18290:	d01f      	beq.n	182d2 <mayfly_run+0x106>
		memq_dequeue(mft[callee_id][caller_id].tail,
   18292:	9b01      	ldr	r3, [sp, #4]
   18294:	9902      	ldr	r1, [sp, #8]
   18296:	2030      	movs	r0, #48	; 0x30
   18298:	fb00 3004 	mla	r0, r0, r4, r3
   1829c:	4b29      	ldr	r3, [pc, #164]	; (18344 <mayfly_run+0x178>)
   1829e:	4418      	add	r0, r3
   182a0:	2200      	movs	r2, #0
   182a2:	6840      	ldr	r0, [r0, #4]
   182a4:	f00f ff5b 	bl	2815e <memq_dequeue>
		m->_ack = req;
   182a8:	9b05      	ldr	r3, [sp, #20]
		ack = m->_ack;
   182aa:	f898 2001 	ldrb.w	r2, [r8, #1]
		m->_ack = req;
   182ae:	f888 3001 	strb.w	r3, [r8, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
   182b2:	f898 3000 	ldrb.w	r3, [r8]
		m->_link = link;
   182b6:	f8c8 6004 	str.w	r6, [r8, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
   182ba:	1a9b      	subs	r3, r3, r2
   182bc:	f003 0303 	and.w	r3, r3, #3
   182c0:	2b01      	cmp	r3, #1
   182c2:	d106      	bne.n	182d2 <mayfly_run+0x106>
			m->_ack = ack;
   182c4:	f888 2001 	strb.w	r2, [r8, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   182c8:	4641      	mov	r1, r8
   182ca:	9a03      	ldr	r2, [sp, #12]
   182cc:	4630      	mov	r0, r6
   182ce:	f00f ff37 	bl	28140 <memq_enqueue>
			link = memq_peek(mft[callee_id][caller_id].head,
   182d2:	9a01      	ldr	r2, [sp, #4]
   182d4:	2330      	movs	r3, #48	; 0x30
   182d6:	fb03 2304 	mla	r3, r3, r4, r2
   182da:	eb0a 0103 	add.w	r1, sl, r3
   182de:	f85a 0003 	ldr.w	r0, [sl, r3]
   182e2:	6849      	ldr	r1, [r1, #4]
   182e4:	aa07      	add	r2, sp, #28
   182e6:	f00f ff32 	bl	2814e <memq_peek>
			if (state == 1U) {
   182ea:	f1b9 0f01 	cmp.w	r9, #1
			link = memq_peek(mft[callee_id][caller_id].head,
   182ee:	4606      	mov	r6, r0
			if (state == 1U) {
   182f0:	d1b0      	bne.n	18254 <mayfly_run+0x88>
				if (caller_id || link) {
   182f2:	b9bd      	cbnz	r5, 18324 <mayfly_run+0x158>
   182f4:	b9b0      	cbnz	r0, 18324 <mayfly_run+0x158>
		if (mft[callee_id][caller_id].disable_req !=
   182f6:	2230      	movs	r2, #48	; 0x30
   182f8:	4912      	ldr	r1, [pc, #72]	; (18344 <mayfly_run+0x178>)
   182fa:	230c      	movs	r3, #12
   182fc:	4362      	muls	r2, r4
   182fe:	fb03 2205 	mla	r2, r3, r5, r2
   18302:	440a      	add	r2, r1
   18304:	7a91      	ldrb	r1, [r2, #10]
   18306:	7ad0      	ldrb	r0, [r2, #11]
   18308:	4288      	cmp	r0, r1
   1830a:	d115      	bne.n	18338 <mayfly_run+0x16c>
		if (mft[callee_id][caller_id].enable_req !=
   1830c:	2230      	movs	r2, #48	; 0x30
   1830e:	4362      	muls	r2, r4
   18310:	fb03 2305 	mla	r3, r3, r5, r2
   18314:	445b      	add	r3, fp
   18316:	7a1a      	ldrb	r2, [r3, #8]
   18318:	7a59      	ldrb	r1, [r3, #9]
   1831a:	4291      	cmp	r1, r2
			mft[callee_id][caller_id].enable_ack =
   1831c:	bf1c      	itt	ne
   1831e:	725a      	strbne	r2, [r3, #9]
			enable = 1U;
   18320:	2701      	movne	r7, #1
   18322:	e76c      	b.n	181fe <mayfly_run+0x32>
					mfp[callee_id] = 1U;
   18324:	4b06      	ldr	r3, [pc, #24]	; (18340 <mayfly_run+0x174>)
   18326:	2201      	movs	r2, #1
					mayfly_pend(callee_id, callee_id);
   18328:	4621      	mov	r1, r4
   1832a:	4620      	mov	r0, r4
					mfp[callee_id] = 1U;
   1832c:	551a      	strb	r2, [r3, r4]
					mayfly_pend(callee_id, callee_id);
   1832e:	f006 fbe7 	bl	1eb00 <mayfly_pend>
	}
}
   18332:	b009      	add	sp, #36	; 0x24
   18334:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mft[callee_id][caller_id].disable_ack =
   18338:	72d1      	strb	r1, [r2, #11]
			disable = 1U;
   1833a:	2201      	movs	r2, #1
   1833c:	9200      	str	r2, [sp, #0]
   1833e:	e7e5      	b.n	1830c <mayfly_run+0x140>
   18340:	200024c8 	.word	0x200024c8
   18344:	20000d44 	.word	0x20000d44

00018348 <util_rand>:

	return one_count;
}

int util_rand(void *buf, size_t len)
{
   18348:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	static struct device *dev;

	if (unlikely(!dev)) {
   1834c:	4d18      	ldr	r5, [pc, #96]	; (183b0 <util_rand+0x68>)
   1834e:	682b      	ldr	r3, [r5, #0]
{
   18350:	4606      	mov	r6, r0
   18352:	460c      	mov	r4, r1
	if (unlikely(!dev)) {
   18354:	b993      	cbnz	r3, 1837c <util_rand+0x34>
   18356:	4817      	ldr	r0, [pc, #92]	; (183b4 <util_rand+0x6c>)
   18358:	f008 f836 	bl	203c8 <z_impl_device_get_binding>
		/* Only one entropy device exists, so this is safe even
		 * if the whole operation isn't atomic.
		 */
		dev = device_get_binding(CONFIG_ENTROPY_NAME);
   1835c:	6028      	str	r0, [r5, #0]
		__ASSERT((dev != NULL),
   1835e:	b968      	cbnz	r0, 1837c <util_rand+0x34>
   18360:	4a15      	ldr	r2, [pc, #84]	; (183b8 <util_rand+0x70>)
   18362:	4916      	ldr	r1, [pc, #88]	; (183bc <util_rand+0x74>)
   18364:	4816      	ldr	r0, [pc, #88]	; (183c0 <util_rand+0x78>)
   18366:	2332      	movs	r3, #50	; 0x32
   18368:	f00b fdbb 	bl	23ee2 <printk>
   1836c:	4911      	ldr	r1, [pc, #68]	; (183b4 <util_rand+0x6c>)
   1836e:	4815      	ldr	r0, [pc, #84]	; (183c4 <util_rand+0x7c>)
   18370:	f00b fdb7 	bl	23ee2 <printk>
   18374:	4810      	ldr	r0, [pc, #64]	; (183b8 <util_rand+0x70>)
   18376:	2132      	movs	r1, #50	; 0x32
   18378:	f00b fdf6 	bl	23f68 <assert_post_action>
			"Device driver for %s (CONFIG_ENTROPY_NAME) not found. "
			"Check your build configuration!",
			CONFIG_ENTROPY_NAME);
	}

	return entropy_get_entropy(dev, (u8_t *)buf, len);
   1837c:	682d      	ldr	r5, [r5, #0]
   1837e:	b2a4      	uxth	r4, r4

static inline int z_impl_entropy_get_entropy(struct device *dev,
					    u8_t *buffer,
					    u16_t length)
{
	const struct entropy_driver_api *api =
   18380:	686f      	ldr	r7, [r5, #4]
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
   18382:	683b      	ldr	r3, [r7, #0]
   18384:	b963      	cbnz	r3, 183a0 <util_rand+0x58>
   18386:	4910      	ldr	r1, [pc, #64]	; (183c8 <util_rand+0x80>)
   18388:	4a10      	ldr	r2, [pc, #64]	; (183cc <util_rand+0x84>)
   1838a:	480d      	ldr	r0, [pc, #52]	; (183c0 <util_rand+0x78>)
   1838c:	234b      	movs	r3, #75	; 0x4b
   1838e:	f00b fda8 	bl	23ee2 <printk>
   18392:	480f      	ldr	r0, [pc, #60]	; (183d0 <util_rand+0x88>)
   18394:	f00b fda5 	bl	23ee2 <printk>
   18398:	480c      	ldr	r0, [pc, #48]	; (183cc <util_rand+0x84>)
   1839a:	214b      	movs	r1, #75	; 0x4b
   1839c:	f00b fde4 	bl	23f68 <assert_post_action>
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
   183a0:	683b      	ldr	r3, [r7, #0]
   183a2:	4622      	mov	r2, r4
   183a4:	4631      	mov	r1, r6
   183a6:	4628      	mov	r0, r5
}
   183a8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   183ac:	4718      	bx	r3
   183ae:	bf00      	nop
   183b0:	20000e04 	.word	0x20000e04
   183b4:	00030045 	.word	0x00030045
   183b8:	0003004f 	.word	0x0003004f
   183bc:	0003008a 	.word	0x0003008a
   183c0:	0002a5e8 	.word	0x0002a5e8
   183c4:	0003009f 	.word	0x0003009f
   183c8:	00030120 	.word	0x00030120
   183cc:	000300f7 	.word	0x000300f7
   183d0:	00030140 	.word	0x00030140

000183d4 <ticker_job_list_insert>:
 *                    handle user operation inserts
 * @internal
 */
static inline void ticker_job_list_insert(struct ticker_instance *instance,
					  u8_t insert_head)
{
   183d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   183d8:	b08f      	sub	sp, #60	; 0x3c
	struct ticker_node *node;
	struct ticker_user *users;
	u8_t count_user;

	node = &instance->nodes[0];
   183da:	6803      	ldr	r3, [r0, #0]
   183dc:	9303      	str	r3, [sp, #12]
	users = &instance->users[0];
   183de:	6843      	ldr	r3, [r0, #4]
   183e0:	930c      	str	r3, [sp, #48]	; 0x30
	count_user = instance->count_user;
   183e2:	7a43      	ldrb	r3, [r0, #9]
   183e4:	9301      	str	r3, [sp, #4]
{
   183e6:	4681      	mov	r9, r0
   183e8:	468b      	mov	fp, r1

	/* Iterate through all user ids */
	while (count_user--) {
   183ea:	9b01      	ldr	r3, [sp, #4]
   183ec:	3b01      	subs	r3, #1
   183ee:	b2db      	uxtb	r3, r3
   183f0:	2bff      	cmp	r3, #255	; 0xff
   183f2:	9301      	str	r3, [sp, #4]
   183f4:	d102      	bne.n	183fc <ticker_job_list_insert+0x28>
			if (user_op) {
				ticker_job_op_cb(user_op, status);
			}
		}
	}
}
   183f6:	b00f      	add	sp, #60	; 0x3c
   183f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		user = &users[count_user];
   183fc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   183fe:	9a01      	ldr	r2, [sp, #4]
   18400:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   18404:	9302      	str	r3, [sp, #8]
		user_ops = (void *)&user->user_op[0];
   18406:	685b      	ldr	r3, [r3, #4]
   18408:	9305      	str	r3, [sp, #20]
		user_ops_first = user->first;
   1840a:	9b02      	ldr	r3, [sp, #8]
   1840c:	f893 a001 	ldrb.w	sl, [r3, #1]
		while ((insert_head != TICKER_NULL) ||
   18410:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
   18414:	d044      	beq.n	184a0 <ticker_job_list_insert+0xcc>
				ticker = &node[id_insert];
   18416:	fa0f f38b 	sxth.w	r3, fp
   1841a:	9a03      	ldr	r2, [sp, #12]
   1841c:	f8cd b000 	str.w	fp, [sp]
   18420:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18424:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
				insert_head = ticker->next;
   18428:	f812 b033 	ldrb.w	fp, [r2, r3, lsl #3]
				user_op = NULL;
   1842c:	2500      	movs	r5, #0
	struct ticker_node *node = &instance->nodes[0];
   1842e:	f8d9 3000 	ldr.w	r3, [r9]
   18432:	9306      	str	r3, [sp, #24]
	ticker->next = TICKER_NULL;
   18434:	23ff      	movs	r3, #255	; 0xff
	if (ticker->lazy_current > ticker->lazy_periodic) {
   18436:	8ba2      	ldrh	r2, [r4, #28]
	ticker->next = TICKER_NULL;
   18438:	7023      	strb	r3, [r4, #0]
	if (ticker->lazy_current > ticker->lazy_periodic) {
   1843a:	8be3      	ldrh	r3, [r4, #30]
   1843c:	4293      	cmp	r3, r2
   1843e:	f240 8092 	bls.w	18566 <ticker_job_list_insert+0x192>
		skip = ticker->lazy_current -
   18442:	1a9b      	subs	r3, r3, r2
   18444:	b29b      	uxth	r3, r3
		skip = 0U;
   18446:	9307      	str	r3, [sp, #28]
	ticker_new = &node[id];
   18448:	f9bd 3000 	ldrsh.w	r3, [sp]
   1844c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18450:	00db      	lsls	r3, r3, #3
   18452:	930d      	str	r3, [sp, #52]	; 0x34
   18454:	e0e8      	b.n	18628 <ticker_job_list_insert+0x254>
				user_op = &user_ops[user_ops_first];
   18456:	9a05      	ldr	r2, [sp, #20]
   18458:	eb0a 054a 	add.w	r5, sl, sl, lsl #1
   1845c:	012b      	lsls	r3, r5, #4
   1845e:	eb02 1505 	add.w	r5, r2, r5, lsl #4
				first = user_ops_first + 1;
   18462:	f10a 0201 	add.w	r2, sl, #1
   18466:	fa5f fa82 	uxtb.w	sl, r2
				if (first == user->count_user_op) {
   1846a:	9a02      	ldr	r2, [sp, #8]
   1846c:	7812      	ldrb	r2, [r2, #0]
					first = 0U;
   1846e:	4552      	cmp	r2, sl
   18470:	bf08      	it	eq
   18472:	f04f 0a00 	moveq.w	sl, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
   18476:	9a05      	ldr	r2, [sp, #20]
   18478:	5cd3      	ldrb	r3, [r2, r3]
   1847a:	2b04      	cmp	r3, #4
   1847c:	d110      	bne.n	184a0 <ticker_job_list_insert+0xcc>
				id_insert = user_op->id;
   1847e:	786b      	ldrb	r3, [r5, #1]
   18480:	9300      	str	r3, [sp, #0]
				ticker = &node[id_insert];
   18482:	eb03 0483 	add.w	r4, r3, r3, lsl #2
   18486:	9b03      	ldr	r3, [sp, #12]
   18488:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
				if (((ticker->req -
   1848c:	7863      	ldrb	r3, [r4, #1]
				      ticker->ack) & 0xff) != 0U) {
   1848e:	78a2      	ldrb	r2, [r4, #2]
				if (((ticker->req -
   18490:	1a9b      	subs	r3, r3, r2
   18492:	f013 0fff 	tst.w	r3, #255	; 0xff
   18496:	d008      	beq.n	184aa <ticker_job_list_insert+0xd6>
					ticker_job_op_cb(user_op,
   18498:	2101      	movs	r1, #1
   1849a:	4628      	mov	r0, r5
   1849c:	f00f fecb 	bl	28236 <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
   184a0:	9b02      	ldr	r3, [sp, #8]
   184a2:	789b      	ldrb	r3, [r3, #2]
   184a4:	4553      	cmp	r3, sl
   184a6:	d1d6      	bne.n	18456 <ticker_job_list_insert+0x82>
   184a8:	e79f      	b.n	183ea <ticker_job_list_insert+0x16>
	LL_ASSERT(start->lazy != TICKER_LAZY_MUST_EXPIRE);
   184aa:	8aaa      	ldrh	r2, [r5, #20]
				ticker_job_op_start(ticker, user_op,
   184ac:	f8d9 6014 	ldr.w	r6, [r9, #20]
	LL_ASSERT(start->lazy != TICKER_LAZY_MUST_EXPIRE);
   184b0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   184b4:	429a      	cmp	r2, r3
   184b6:	d10c      	bne.n	184d2 <ticker_job_list_insert+0xfe>
   184b8:	4a7c      	ldr	r2, [pc, #496]	; (186ac <ticker_job_list_insert+0x2d8>)
   184ba:	497d      	ldr	r1, [pc, #500]	; (186b0 <ticker_job_list_insert+0x2dc>)
   184bc:	487d      	ldr	r0, [pc, #500]	; (186b4 <ticker_job_list_insert+0x2e0>)
   184be:	f44f 63bb 	mov.w	r3, #1496	; 0x5d8
   184c2:	f00b fd0e 	bl	23ee2 <printk>
   184c6:	4040      	eors	r0, r0
   184c8:	f380 8811 	msr	BASEPRI, r0
   184cc:	f04f 0003 	mov.w	r0, #3
   184d0:	df02      	svc	2
	ticker->ticks_periodic = start->ticks_periodic;
   184d2:	68eb      	ldr	r3, [r5, #12]
   184d4:	6063      	str	r3, [r4, #4]
	ticker->remainder_periodic = start->remainder_periodic;
   184d6:	692b      	ldr	r3, [r5, #16]
   184d8:	6223      	str	r3, [r4, #32]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
   184da:	8aab      	ldrh	r3, [r5, #20]
   184dc:	f64f 72ff 	movw	r2, #65535	; 0xffff
   184e0:	4293      	cmp	r3, r2
   184e2:	bf08      	it	eq
   184e4:	2300      	moveq	r3, #0
   184e6:	83a3      	strh	r3, [r4, #28]
	ticker->ticks_slot = start->ticks_slot;
   184e8:	69ab      	ldr	r3, [r5, #24]
   184ea:	61a3      	str	r3, [r4, #24]
	ticker->timeout_func = start->fp_timeout_func;
   184ec:	69eb      	ldr	r3, [r5, #28]
   184ee:	60e3      	str	r3, [r4, #12]
	ticker->context = start->context;
   184f0:	6a2b      	ldr	r3, [r5, #32]
   184f2:	6123      	str	r3, [r4, #16]
	ticker->ticks_to_expire_minus = 0U;
   184f4:	2700      	movs	r7, #0
	ticker->ticks_to_expire = start->ticks_first;
   184f6:	68ab      	ldr	r3, [r5, #8]
   184f8:	60a3      	str	r3, [r4, #8]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   184fa:	686a      	ldr	r2, [r5, #4]
	ticker->ticks_to_expire_minus = 0U;
   184fc:	6167      	str	r7, [r4, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   184fe:	4631      	mov	r1, r6
   18500:	4620      	mov	r0, r4
   18502:	f00f fe7a 	bl	281fa <ticks_to_expire_prep>
	ticker->force = 1U;
   18506:	2301      	movs	r3, #1
	ticker->remainder_current = 0U;
   18508:	6267      	str	r7, [r4, #36]	; 0x24
	ticker->lazy_current = 0U;
   1850a:	83e7      	strh	r7, [r4, #30]
	ticker->force = 1U;
   1850c:	70e3      	strb	r3, [r4, #3]
}
   1850e:	e78e      	b.n	1842e <ticker_job_list_insert+0x5a>
		if (ticker->ticks_periodic != 0U) {
   18510:	6860      	ldr	r0, [r4, #4]
   18512:	2800      	cmp	r0, #0
   18514:	f000 80c7 	beq.w	186a6 <ticker_job_list_insert+0x2d2>
	ticker->remainder_current += ticker->remainder_periodic;
   18518:	e9d4 1208 	ldrd	r1, r2, [r4, #32]
	if ((ticker->remainder_current < BIT(31)) &&
   1851c:	4b66      	ldr	r3, [pc, #408]	; (186b8 <ticker_job_list_insert+0x2e4>)
	ticker->remainder_current += ticker->remainder_periodic;
   1851e:	440a      	add	r2, r1
	if ((ticker->remainder_current < BIT(31)) &&
   18520:	4966      	ldr	r1, [pc, #408]	; (186bc <ticker_job_list_insert+0x2e8>)
   18522:	18d3      	adds	r3, r2, r3
   18524:	428b      	cmp	r3, r1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   18526:	bf9c      	itt	ls
   18528:	f1a2 72e8 	subls.w	r2, r2, #30408704	; 0x1d00000
   1852c:	f5a2 32d4 	subls.w	r2, r2, #108544	; 0x1a800
			ticker->ticks_to_expire += ticker->ticks_periodic +
   18530:	68a3      	ldr	r3, [r4, #8]
	ticker->remainder_current += ticker->remainder_periodic;
   18532:	bf8b      	itete	hi
   18534:	6262      	strhi	r2, [r4, #36]	; 0x24
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   18536:	f5a2 72a5 	subls.w	r2, r2, #330	; 0x14a
	return 0;
   1853a:	2200      	movhi	r2, #0
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   1853c:	6262      	strls	r2, [r4, #36]	; 0x24
			ticker->ticks_to_expire += ticker->ticks_periodic +
   1853e:	4403      	add	r3, r0
		return 1;
   18540:	bf98      	it	ls
   18542:	2201      	movls	r2, #1
			ticker->ticks_to_expire += ticker->ticks_periodic +
   18544:	4413      	add	r3, r2
			ticker->lazy_current++;
   18546:	8be2      	ldrh	r2, [r4, #30]
   18548:	3201      	adds	r2, #1
   1854a:	83e2      	strh	r2, [r4, #30]
			    ticker->ticks_to_expire_minus) {
   1854c:	6962      	ldr	r2, [r4, #20]
			if (ticker->ticks_to_expire >
   1854e:	4293      	cmp	r3, r2
   18550:	f04f 0100 	mov.w	r1, #0
				ticker->ticks_to_expire -=
   18554:	bf89      	itett	hi
   18556:	1a9b      	subhi	r3, r3, r2
				ticker->ticks_to_expire_minus -=
   18558:	1ad3      	subls	r3, r2, r3
				ticker->ticks_to_expire -=
   1855a:	60a3      	strhi	r3, [r4, #8]
				ticker->ticks_to_expire_minus = 0U;
   1855c:	6161      	strhi	r1, [r4, #20]
				ticker->ticks_to_expire_minus -=
   1855e:	bf9c      	itt	ls
   18560:	6163      	strls	r3, [r4, #20]
				ticker->ticks_to_expire = 0U;
   18562:	60a1      	strls	r1, [r4, #8]
   18564:	e060      	b.n	18628 <ticker_job_list_insert+0x254>
		skip = 0U;
   18566:	2300      	movs	r3, #0
   18568:	e76d      	b.n	18446 <ticker_job_list_insert+0x72>
		if (ticker_current->ticks_slot != 0U) {
   1856a:	69b6      	ldr	r6, [r6, #24]
		ticks_to_expire -= ticks_to_expire_current;
   1856c:	1a40      	subs	r0, r0, r1
		if (ticker_current->ticks_slot != 0U) {
   1856e:	b946      	cbnz	r6, 18582 <ticker_job_list_insert+0x1ae>
			if (ticks_slot_previous > ticks_to_expire_current) {
   18570:	4571      	cmp	r1, lr
   18572:	d201      	bcs.n	18578 <ticker_job_list_insert+0x1a4>
				ticks_slot_previous -= ticks_to_expire_current;
   18574:	ebae 0601 	sub.w	r6, lr, r1
		current = ticker_current->next;
   18578:	9304      	str	r3, [sp, #16]
   1857a:	46b6      	mov	lr, r6
   1857c:	f812 3038 	ldrb.w	r3, [r2, r8, lsl #3]
   18580:	e05f      	b.n	18642 <ticker_job_list_insert+0x26e>
   18582:	461f      	mov	r7, r3
   18584:	e7f8      	b.n	18578 <ticker_job_list_insert+0x1a4>
		ticker = &node[ticker_id_head];
   18586:	b20e      	sxth	r6, r1
   18588:	eb06 0686 	add.w	r6, r6, r6, lsl #2
   1858c:	960b      	str	r6, [sp, #44]	; 0x2c
   1858e:	eb02 06c6 	add.w	r6, r2, r6, lsl #3
   18592:	9609      	str	r6, [sp, #36]	; 0x24
		ticks_to_expire = ticker->ticks_to_expire;
   18594:	68b6      	ldr	r6, [r6, #8]
   18596:	960a      	str	r6, [sp, #40]	; 0x28
		if (ticks_slot <= ticks_to_expire) {
   18598:	4546      	cmp	r6, r8
   1859a:	d20a      	bcs.n	185b2 <ticker_job_list_insert+0x1de>
		if (ticker->ticks_slot) {
   1859c:	9e09      	ldr	r6, [sp, #36]	; 0x24
   1859e:	69b6      	ldr	r6, [r6, #24]
   185a0:	2e00      	cmp	r6, #0
   185a2:	d15f      	bne.n	18664 <ticker_job_list_insert+0x290>
		ticks_slot -= ticks_to_expire;
   185a4:	990a      	ldr	r1, [sp, #40]	; 0x28
   185a6:	eba8 0801 	sub.w	r8, r8, r1
		ticker_id_head = ticker->next;
   185aa:	990b      	ldr	r1, [sp, #44]	; 0x2c
   185ac:	f812 1031 	ldrb.w	r1, [r2, r1, lsl #3]
   185b0:	e056      	b.n	18660 <ticker_job_list_insert+0x28c>
			return TICKER_NULL;
   185b2:	21ff      	movs	r1, #255	; 0xff
   185b4:	e056      	b.n	18664 <ticker_job_list_insert+0x290>
	if ((ticker_new->ticks_slot == 0U) ||
   185b6:	4570      	cmp	r0, lr
   185b8:	d30d      	bcc.n	185d6 <ticker_job_list_insert+0x202>
	    ((ticks_slot_previous <= ticks_to_expire) &&
   185ba:	29ff      	cmp	r1, #255	; 0xff
   185bc:	d055      	beq.n	1866a <ticker_job_list_insert+0x296>
	while (id_insert !=
   185be:	9b00      	ldr	r3, [sp, #0]
   185c0:	428b      	cmp	r3, r1
   185c2:	d10e      	bne.n	185e2 <ticker_job_list_insert+0x20e>
   185c4:	e064      	b.n	18690 <ticker_job_list_insert+0x2bc>
			node[previous].next = id;
   185c6:	f9bd 1010 	ldrsh.w	r1, [sp, #16]
   185ca:	9e00      	ldr	r6, [sp, #0]
   185cc:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   185d0:	f802 6031 	strb.w	r6, [r2, r1, lsl #3]
   185d4:	e053      	b.n	1867e <ticker_job_list_insert+0x2aa>
	while (id_insert !=
   185d6:	9b00      	ldr	r3, [sp, #0]
   185d8:	42bb      	cmp	r3, r7
   185da:	d059      	beq.n	18690 <ticker_job_list_insert+0x2bc>
		if (id_collide != TICKER_NULL) {
   185dc:	2fff      	cmp	r7, #255	; 0xff
   185de:	d097      	beq.n	18510 <ticker_job_list_insert+0x13c>
   185e0:	4639      	mov	r1, r7
			struct ticker_node *ticker_collide = &node[id_collide];
   185e2:	9b06      	ldr	r3, [sp, #24]
   185e4:	b20f      	sxth	r7, r1
   185e6:	eb07 0787 	add.w	r7, r7, r7, lsl #2
   185ea:	eb03 06c7 	add.w	r6, r3, r7, lsl #3
			if (ticker_collide->lazy_current >
   185ee:	8bf2      	ldrh	r2, [r6, #30]
			    ticker_collide->lazy_periodic) {
   185f0:	8bb3      	ldrh	r3, [r6, #28]
			if (ticker_collide->lazy_current >
   185f2:	429a      	cmp	r2, r3
				skip_collide = ticker_collide->lazy_current -
   185f4:	bf88      	it	hi
   185f6:	1ad2      	subhi	r2, r2, r3
			if (ticker_collide->ticks_periodic &&
   185f8:	6873      	ldr	r3, [r6, #4]
				skip_collide = ticker_collide->lazy_current -
   185fa:	bf8c      	ite	hi
   185fc:	b292      	uxthhi	r2, r2
				skip_collide = 0U;
   185fe:	2200      	movls	r2, #0
			if (ticker_collide->ticks_periodic &&
   18600:	2b00      	cmp	r3, #0
   18602:	d085      	beq.n	18510 <ticker_job_list_insert+0x13c>
   18604:	9b07      	ldr	r3, [sp, #28]
   18606:	429a      	cmp	r2, r3
   18608:	d882      	bhi.n	18510 <ticker_job_list_insert+0x13c>
			    skip_collide <= skip &&
   1860a:	78f2      	ldrb	r2, [r6, #3]
   1860c:	78e3      	ldrb	r3, [r4, #3]
   1860e:	429a      	cmp	r2, r3
   18610:	f4bf af7e 	bcs.w	18510 <ticker_job_list_insert+0x13c>
					ticker_dequeue(instance, id_collide);
   18614:	4648      	mov	r0, r9
   18616:	f00f fdc4 	bl	281a2 <ticker_dequeue>
				ticker_collide->req = ticker_collide->ack;
   1861a:	78b3      	ldrb	r3, [r6, #2]
   1861c:	7073      	strb	r3, [r6, #1]
				ticker_collide->next = *insert_head;
   1861e:	9b06      	ldr	r3, [sp, #24]
				ticker_collide->ticks_to_expire =
   18620:	60b0      	str	r0, [r6, #8]
				ticker_collide->next = *insert_head;
   18622:	f803 b037 	strb.w	fp, [r3, r7, lsl #3]
				continue;
   18626:	468b      	mov	fp, r1
	ticker_new = &node[id];
   18628:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	node = &instance->nodes[0];
   1862a:	f8d9 2000 	ldr.w	r2, [r9]
	ticks_slot_previous = instance->ticks_slot_previous;
   1862e:	f8d9 e018 	ldr.w	lr, [r9, #24]
	ticker_new = &node[id];
   18632:	eb02 0c03 	add.w	ip, r2, r3
	current = instance->ticker_id_head;
   18636:	f899 301d 	ldrb.w	r3, [r9, #29]
	ticks_to_expire = ticker_new->ticks_to_expire;
   1863a:	f8dc 0008 	ldr.w	r0, [ip, #8]
	previous = current;
   1863e:	9304      	str	r3, [sp, #16]
	collide = ticker_id_slot_previous = TICKER_NULL;
   18640:	27ff      	movs	r7, #255	; 0xff
	while ((current != TICKER_NULL) &&
   18642:	2bff      	cmp	r3, #255	; 0xff
   18644:	d006      	beq.n	18654 <ticker_job_list_insert+0x280>
		 (ticker_current = &node[current])->ticks_to_expire))) {
   18646:	eb03 0883 	add.w	r8, r3, r3, lsl #2
   1864a:	eb02 06c8 	add.w	r6, r2, r8, lsl #3
		(ticks_to_expire_current =
   1864e:	68b1      	ldr	r1, [r6, #8]
	while ((current != TICKER_NULL) &&
   18650:	4288      	cmp	r0, r1
   18652:	d88a      	bhi.n	1856a <ticker_job_list_insert+0x196>
				     ticks_to_expire + ticker_new->ticks_slot);
   18654:	f8dc 1018 	ldr.w	r1, [ip, #24]
   18658:	9108      	str	r1, [sp, #32]
	collide = ticker_by_slot_get(&node[0], current,
   1865a:	eb00 0801 	add.w	r8, r0, r1
	while (ticker_id_head != TICKER_NULL) {
   1865e:	4619      	mov	r1, r3
   18660:	29ff      	cmp	r1, #255	; 0xff
   18662:	d190      	bne.n	18586 <ticker_job_list_insert+0x1b2>
	if ((ticker_new->ticks_slot == 0U) ||
   18664:	9e08      	ldr	r6, [sp, #32]
   18666:	2e00      	cmp	r6, #0
   18668:	d1a5      	bne.n	185b6 <ticker_job_list_insert+0x1e2>
		if (previous == current) {
   1866a:	9904      	ldr	r1, [sp, #16]
		ticker_new->ticks_to_expire = ticks_to_expire;
   1866c:	f8cc 0008 	str.w	r0, [ip, #8]
		if (previous == current) {
   18670:	428b      	cmp	r3, r1
		ticker_new->next = current;
   18672:	f88c 3000 	strb.w	r3, [ip]
		if (previous == current) {
   18676:	d1a6      	bne.n	185c6 <ticker_job_list_insert+0x1f2>
			instance->ticker_id_head = id;
   18678:	9900      	ldr	r1, [sp, #0]
   1867a:	f889 101d 	strb.w	r1, [r9, #29]
		if (current != TICKER_NULL) {
   1867e:	2bff      	cmp	r3, #255	; 0xff
   18680:	d006      	beq.n	18690 <ticker_job_list_insert+0x2bc>
			node[current].ticks_to_expire -= ticks_to_expire;
   18682:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18686:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1868a:	689a      	ldr	r2, [r3, #8]
   1868c:	1a10      	subs	r0, r2, r0
   1868e:	6098      	str	r0, [r3, #8]
	ticker->req = ticker->ack + 1;
   18690:	78a3      	ldrb	r3, [r4, #2]
   18692:	3301      	adds	r3, #1
   18694:	7063      	strb	r3, [r4, #1]
	return TICKER_STATUS_SUCCESS;
   18696:	2100      	movs	r1, #0
			if (user_op) {
   18698:	2d00      	cmp	r5, #0
   1869a:	f43f aeb9 	beq.w	18410 <ticker_job_list_insert+0x3c>
				ticker_job_op_cb(user_op, status);
   1869e:	4628      	mov	r0, r5
   186a0:	f00f fdc9 	bl	28236 <ticker_job_op_cb>
   186a4:	e6b4      	b.n	18410 <ticker_job_list_insert+0x3c>
			return TICKER_STATUS_FAILURE;
   186a6:	2101      	movs	r1, #1
   186a8:	e7f6      	b.n	18698 <ticker_job_list_insert+0x2c4>
   186aa:	bf00      	nop
   186ac:	00030166 	.word	0x00030166
   186b0:	000301a5 	.word	0x000301a5
   186b4:	0002a5e8 	.word	0x0002a5e8
   186b8:	ff172b5a 	.word	0xff172b5a
   186bc:	7f172b59 	.word	0x7f172b59

000186c0 <ticker_job>:
 * @param param Pointer to ticker instance
 *
 * @internal
 */
void ticker_job(void *param)
{
   186c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t flag_compare_update;

	DEBUG_TICKER_JOB(1);

	/* Defer worker, as job is now running */
	if (instance->worker_trigger) {
   186c4:	7fc2      	ldrb	r2, [r0, #31]
{
   186c6:	b08b      	sub	sp, #44	; 0x2c
   186c8:	4604      	mov	r4, r0
	if (instance->worker_trigger) {
   186ca:	2a00      	cmp	r2, #0
   186cc:	f040 826c 	bne.w	18ba8 <ticker_job+0x4e8>
		return;
	}
	instance->job_guard = 1U;

	/* Back up the previous known tick */
	ticks_previous = instance->ticks_current;
   186d0:	6943      	ldr	r3, [r0, #20]
   186d2:	9304      	str	r3, [sp, #16]
	instance->job_guard = 1U;
   186d4:	2101      	movs	r1, #1

	/* Update current tick with the elapsed value from queue, and dequeue */
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   186d6:	7a83      	ldrb	r3, [r0, #10]
	instance->job_guard = 1U;
   186d8:	7781      	strb	r1, [r0, #30]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   186da:	7ac0      	ldrb	r0, [r0, #11]
   186dc:	4298      	cmp	r0, r3
   186de:	d06d      	beq.n	187bc <ticker_job+0xfc>
	u8_t idx = *ticks_elapsed_index + 1;
   186e0:	440b      	add	r3, r1
   186e2:	b2db      	uxtb	r3, r3
		idx = 0U;
   186e4:	2b02      	cmp	r3, #2
   186e6:	bf08      	it	eq
   186e8:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   186ea:	72a3      	strb	r3, [r4, #10]
		ticker_next_elapsed(&instance->ticks_elapsed_first);

		ticks_elapsed =
   186ec:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		    instance->ticks_elapsed[instance->ticks_elapsed_first];

		instance->ticks_current += ticks_elapsed;
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;

		flag_elapsed = 1U;
   186f0:	9100      	str	r1, [sp, #0]
		ticks_elapsed =
   186f2:	68df      	ldr	r7, [r3, #12]
		instance->ticks_current += ticks_elapsed;
   186f4:	9b04      	ldr	r3, [sp, #16]
   186f6:	443b      	add	r3, r7
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
   186f8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   186fc:	6163      	str	r3, [r4, #20]
	flag_compare_update = 0U;

	/* Remember the old head, so as to decide if new compare needs to be
	 * set.
	 */
	ticker_id_old_head = instance->ticker_id_head;
   186fe:	7f63      	ldrb	r3, [r4, #29]
   18700:	9301      	str	r3, [sp, #4]
	node = &instance->nodes[0];
   18702:	6823      	ldr	r3, [r4, #0]
   18704:	9305      	str	r3, [sp, #20]
	users = &instance->users[0];
   18706:	6863      	ldr	r3, [r4, #4]
   18708:	9309      	str	r3, [sp, #36]	; 0x24
	count_user = instance->count_user;
   1870a:	7a63      	ldrb	r3, [r4, #9]
   1870c:	9302      	str	r3, [sp, #8]
	pending = 0U;
   1870e:	2300      	movs	r3, #0
   18710:	9303      	str	r3, [sp, #12]
	insert_head = TICKER_NULL;
   18712:	f04f 0bff 	mov.w	fp, #255	; 0xff
	while (count_user--) {
   18716:	9b02      	ldr	r3, [sp, #8]
   18718:	3b01      	subs	r3, #1
   1871a:	b2db      	uxtb	r3, r3
   1871c:	2bff      	cmp	r3, #255	; 0xff
   1871e:	9302      	str	r3, [sp, #8]
   18720:	d14f      	bne.n	187c2 <ticker_job+0x102>

	/* Manage user operations (updates and deletions) in ticker list */
	pending = ticker_job_list_manage(instance, ticks_elapsed, &insert_head);

	/* Detect change in head of the list */
	if (instance->ticker_id_head != ticker_id_old_head) {
   18722:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
   18724:	9a01      	ldr	r2, [sp, #4]
   18726:	ebb3 0802 	subs.w	r8, r3, r2
	}

	/* Handle expired tickers */
	if (flag_elapsed) {
   1872a:	9b00      	ldr	r3, [sp, #0]
		flag_compare_update = 1U;
   1872c:	bf18      	it	ne
   1872e:	f04f 0801 	movne.w	r8, #1
	if (flag_elapsed) {
   18732:	b1bb      	cbz	r3, 18764 <ticker_job+0xa4>
	node = &instance->nodes[0];
   18734:	6823      	ldr	r3, [r4, #0]
   18736:	9302      	str	r3, [sp, #8]
	ticks_expired = 0U;
   18738:	f04f 0900 	mov.w	r9, #0
	while (instance->ticker_id_head != TICKER_NULL) {
   1873c:	7f65      	ldrb	r5, [r4, #29]
   1873e:	2dff      	cmp	r5, #255	; 0xff
   18740:	d00b      	beq.n	1875a <ticker_job+0x9a>
		ticker = &node[id_expired];
   18742:	9b02      	ldr	r3, [sp, #8]
   18744:	b22e      	sxth	r6, r5
   18746:	eb06 0686 	add.w	r6, r6, r6, lsl #2
   1874a:	eb03 00c6 	add.w	r0, r3, r6, lsl #3
		ticks_to_expire = ticker->ticks_to_expire;
   1874e:	6883      	ldr	r3, [r0, #8]
		if (ticks_elapsed < ticks_to_expire) {
   18750:	42bb      	cmp	r3, r7
   18752:	f240 813c 	bls.w	189ce <ticker_job+0x30e>
			ticker->ticks_to_expire -= ticks_elapsed;
   18756:	1bdf      	subs	r7, r3, r7
   18758:	6087      	str	r7, [r0, #8]
		ticker_job_worker_bh(instance, ticks_previous, ticks_elapsed,
				     &insert_head);

		/* Detect change in head of the list */
		if (instance->ticker_id_head != ticker_id_old_head) {
			flag_compare_update = 1U;
   1875a:	e9dd 3200 	ldrd	r3, r2, [sp]
   1875e:	4295      	cmp	r5, r2
   18760:	bf18      	it	ne
   18762:	4698      	movne	r8, r3
			flag_compare_update = 1U;
		}
#endif /* CONFIG_BT_TICKER_EXT */
	} else {
		/* Handle insertions */
		ticker_job_list_insert(instance, insert_head);
   18764:	4659      	mov	r1, fp
   18766:	4620      	mov	r0, r4
   18768:	f7ff fe34 	bl	183d4 <ticker_job_list_insert>
	}

	/* Detect change in head of the list */
	if (instance->ticker_id_head != ticker_id_old_head) {
   1876c:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
   1876e:	9a01      	ldr	r2, [sp, #4]
   18770:	4293      	cmp	r3, r2
   18772:	bf18      	it	ne
   18774:	f04f 0801 	movne.w	r8, #1
	}

	/* Process any list inquiries */
	if (!pending) {
   18778:	9b03      	ldr	r3, [sp, #12]
   1877a:	2b00      	cmp	r3, #0
   1877c:	f000 8173 	beq.w	18a66 <ticker_job+0x3a6>
		/* Handle inquiries */
		ticker_job_list_inquire(instance);
	}

	/* Permit worker job to run */
	instance->job_guard = 0U;
   18780:	2300      	movs	r3, #0
   18782:	77a3      	strb	r3, [r4, #30]

	/* update compare if head changed */
	if (flag_compare_update) {
   18784:	f1b8 0f00 	cmp.w	r8, #0
   18788:	d00a      	beq.n	187a0 <ticker_job+0xe0>
	if (instance->ticker_id_head == TICKER_NULL) {
   1878a:	7f63      	ldrb	r3, [r4, #29]
   1878c:	2bff      	cmp	r3, #255	; 0xff
   1878e:	f040 81c2 	bne.w	18b16 <ticker_job+0x456>
		if (cntr_stop() == 0) {
   18792:	f005 fdc9 	bl	1e328 <cntr_stop>
   18796:	b918      	cbnz	r0, 187a0 <ticker_job+0xe0>
			instance->ticks_slot_previous = 0U;
   18798:	61a0      	str	r0, [r4, #24]
			instance->ticks_current = cntr_cnt_get();
   1879a:	f005 fdeb 	bl	1e374 <cntr_cnt_get>
   1879e:	6160      	str	r0, [r4, #20]
		ticker_job_compare_update(instance, ticker_id_old_head);
	}

	/* trigger worker if deferred */
	if (instance->worker_trigger) {
   187a0:	7fe3      	ldrb	r3, [r4, #31]
   187a2:	2b00      	cmp	r3, #0
   187a4:	f000 8200 	beq.w	18ba8 <ticker_job+0x4e8>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   187a8:	6a65      	ldr	r5, [r4, #36]	; 0x24
   187aa:	4623      	mov	r3, r4
   187ac:	2201      	movs	r2, #1
   187ae:	2103      	movs	r1, #3
   187b0:	2004      	movs	r0, #4
   187b2:	46ac      	mov	ip, r5
				   instance);
	}

	DEBUG_TICKER_JOB(0);
}
   187b4:	b00b      	add	sp, #44	; 0x2c
   187b6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   187ba:	4760      	bx	ip
		flag_elapsed = 0U;
   187bc:	9200      	str	r2, [sp, #0]
		ticks_elapsed = 0U;
   187be:	4617      	mov	r7, r2
   187c0:	e79d      	b.n	186fe <ticker_job+0x3e>
		user = &users[count_user];
   187c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   187c4:	9a02      	ldr	r2, [sp, #8]
   187c6:	eb03 0ac2 	add.w	sl, r3, r2, lsl #3
		user_ops = &user->user_op[0];
   187ca:	f8da 3004 	ldr.w	r3, [sl, #4]
   187ce:	9306      	str	r3, [sp, #24]
		while (user->middle != user->last) {
   187d0:	f89a 1003 	ldrb.w	r1, [sl, #3]
   187d4:	f89a 8002 	ldrb.w	r8, [sl, #2]
   187d8:	4588      	cmp	r8, r1
   187da:	d09c      	beq.n	18716 <ticker_job+0x56>
			user_op = &user_ops[user->middle];
   187dc:	9b06      	ldr	r3, [sp, #24]
			if (middle == user->count_user_op) {
   187de:	f89a 0000 	ldrb.w	r0, [sl]
			user_op = &user_ops[user->middle];
   187e2:	eb08 0648 	add.w	r6, r8, r8, lsl #1
   187e6:	0132      	lsls	r2, r6, #4
   187e8:	eb03 1606 	add.w	r6, r3, r6, lsl #4
			middle = user->middle + 1;
   187ec:	f108 0301 	add.w	r3, r8, #1
   187f0:	b2db      	uxtb	r3, r3
				middle = 0U;
   187f2:	4298      	cmp	r0, r3
   187f4:	bf08      	it	eq
   187f6:	2300      	moveq	r3, #0
			user->middle = middle;
   187f8:	f88a 3002 	strb.w	r3, [sl, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
   187fc:	9b06      	ldr	r3, [sp, #24]
   187fe:	5c9a      	ldrb	r2, [r3, r2]
   18800:	2a04      	cmp	r2, #4
   18802:	d9e7      	bls.n	187d4 <ticker_job+0x114>
			ticker = &node[user_op->id];
   18804:	7871      	ldrb	r1, [r6, #1]
   18806:	eb01 0381 	add.w	r3, r1, r1, lsl #2
   1880a:	9308      	str	r3, [sp, #32]
   1880c:	9808      	ldr	r0, [sp, #32]
   1880e:	9b05      	ldr	r3, [sp, #20]
   18810:	eb03 05c0 	add.w	r5, r3, r0, lsl #3
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
   18814:	2a07      	cmp	r2, #7
			state = (ticker->req - ticker->ack) & 0xff;
   18816:	786b      	ldrb	r3, [r5, #1]
   18818:	78a8      	ldrb	r0, [r5, #2]
   1881a:	eba3 0300 	sub.w	r3, r3, r0
   1881e:	b2db      	uxtb	r3, r3
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
   18820:	d80e      	bhi.n	18840 <ticker_job+0x180>
   18822:	b16b      	cbz	r3, 18840 <ticker_job+0x180>
			    (state == 0U) ||
   18824:	2a05      	cmp	r2, #5
   18826:	d110      	bne.n	1884a <ticker_job+0x18a>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
   18828:	6872      	ldr	r2, [r6, #4]
   1882a:	b972      	cbnz	r2, 1884a <ticker_job+0x18a>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
   1882c:	68b2      	ldr	r2, [r6, #8]
   1882e:	b962      	cbnz	r2, 1884a <ticker_job+0x18a>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
   18830:	68f2      	ldr	r2, [r6, #12]
   18832:	b952      	cbnz	r2, 1884a <ticker_job+0x18a>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
   18834:	6932      	ldr	r2, [r6, #16]
   18836:	b942      	cbnz	r2, 1884a <ticker_job+0x18a>
			     (user_op->params.update.lazy == 0U) &&
   18838:	6972      	ldr	r2, [r6, #20]
   1883a:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   1883e:	d104      	bne.n	1884a <ticker_job+0x18a>
				ticker_job_op_cb(user_op,
   18840:	2101      	movs	r1, #1
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
   18842:	4630      	mov	r0, r6
   18844:	f00f fcf7 	bl	28236 <ticker_job_op_cb>
}
   18848:	e7c2      	b.n	187d0 <ticker_job+0x110>
			if (state == 1U) {
   1884a:	2b01      	cmp	r3, #1
   1884c:	f040 80b4 	bne.w	189b8 <ticker_job+0x2f8>
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
   18850:	4620      	mov	r0, r4
   18852:	f00f fca6 	bl	281a2 <ticker_dequeue>
   18856:	60a8      	str	r0, [r5, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
   18858:	7833      	ldrb	r3, [r6, #0]
   1885a:	2b05      	cmp	r3, #5
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
   1885c:	4681      	mov	r9, r0
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
   1885e:	f040 8089 	bne.w	18974 <ticker_job+0x2b4>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
   18862:	f8d4 8014 	ldr.w	r8, [r4, #20]
	ticks_now = cntr_cnt_get();
   18866:	f005 fd85 	bl	1e374 <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
u32_t ticker_ticks_diff_get(u32_t ticks_now, u32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1886a:	eba0 0308 	sub.w	r3, r0, r8
   1886e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
   18872:	443b      	add	r3, r7
	if (ticks_to_expire > ticks_elapsed) {
   18874:	4599      	cmp	r9, r3
		ticker->ticks_to_expire_minus += ticks_elapsed -
   18876:	bf98      	it	ls
   18878:	6969      	ldrls	r1, [r5, #20]
	ticks_now = cntr_cnt_get();
   1887a:	9007      	str	r0, [sp, #28]
		ticker->ticks_to_expire_minus += ticks_elapsed -
   1887c:	bf98      	it	ls
   1887e:	eba1 0109 	subls.w	r1, r1, r9
	if ((ticker->ticks_periodic != 0U) &&
   18882:	6868      	ldr	r0, [r5, #4]
		ticker->ticks_to_expire_minus += ticks_elapsed -
   18884:	bf9b      	ittet	ls
   18886:	185b      	addls	r3, r3, r1
   18888:	616b      	strls	r3, [r5, #20]
		ticks_to_expire -= ticks_elapsed;
   1888a:	eba9 0303 	subhi.w	r3, r9, r3
		ticks_to_expire = 0U;
   1888e:	2300      	movls	r3, #0
	if ((ticker->ticks_periodic != 0U) &&
   18890:	b198      	cbz	r0, 188ba <ticker_job+0x1fa>
	    (user_op->params.update.lazy != 0U)) {
   18892:	8ab1      	ldrh	r1, [r6, #20]
	if ((ticker->ticks_periodic != 0U) &&
   18894:	b189      	cbz	r1, 188ba <ticker_job+0x1fa>
		user_op->params.update.lazy--;
   18896:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
   1889a:	fa1f fc8c 	uxth.w	ip, ip
   1889e:	f8a6 c014 	strh.w	ip, [r6, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
   188a2:	4298      	cmp	r0, r3
   188a4:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
   188a8:	d201      	bcs.n	188ae <ticker_job+0x1ee>
   188aa:	45f4      	cmp	ip, lr
   188ac:	d328      	bcc.n	18900 <ticker_job+0x240>
		while (ticker->lazy_current < user_op->params.update.lazy) {
   188ae:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
   188b2:	45f4      	cmp	ip, lr
   188b4:	d843      	bhi.n	1893e <ticker_job+0x27e>
		ticker->lazy_periodic = user_op->params.update.lazy;
   188b6:	f8a5 c01c 	strh.w	ip, [r5, #28]
	ticker->ticks_to_expire = ticks_to_expire +
   188ba:	6870      	ldr	r0, [r6, #4]
	ticker->ticks_to_expire_minus +=
   188bc:	68b1      	ldr	r1, [r6, #8]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
   188be:	9a07      	ldr	r2, [sp, #28]
	ticker->ticks_to_expire = ticks_to_expire +
   188c0:	4403      	add	r3, r0
   188c2:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus +=
   188c4:	696b      	ldr	r3, [r5, #20]
   188c6:	440b      	add	r3, r1
   188c8:	616b      	str	r3, [r5, #20]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
   188ca:	4641      	mov	r1, r8
   188cc:	4628      	mov	r0, r5
   188ce:	f00f fc94 	bl	281fa <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
   188d2:	68f2      	ldr	r2, [r6, #12]
   188d4:	69ab      	ldr	r3, [r5, #24]
   188d6:	4413      	add	r3, r2
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
   188d8:	6932      	ldr	r2, [r6, #16]
   188da:	4293      	cmp	r3, r2
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
   188dc:	bf8c      	ite	hi
   188de:	1a9b      	subhi	r3, r3, r2
		ticker->ticks_slot = 0U;
   188e0:	2300      	movls	r3, #0
   188e2:	61ab      	str	r3, [r5, #24]
	if (user_op->params.update.force != 0U) {
   188e4:	7db3      	ldrb	r3, [r6, #22]
   188e6:	b103      	cbz	r3, 188ea <ticker_job+0x22a>
		ticker->force = user_op->params.update.force;
   188e8:	70eb      	strb	r3, [r5, #3]
	ticker->next = *insert_head;
   188ea:	9b05      	ldr	r3, [sp, #20]
   188ec:	9a08      	ldr	r2, [sp, #32]
   188ee:	f803 b032 	strb.w	fp, [r3, r2, lsl #3]
		ticker->req++;
   188f2:	786b      	ldrb	r3, [r5, #1]
	*insert_head = user_op->id;
   188f4:	f896 b001 	ldrb.w	fp, [r6, #1]
		ticker->req++;
   188f8:	3301      	adds	r3, #1
   188fa:	706b      	strb	r3, [r5, #1]
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
   188fc:	2100      	movs	r1, #0
   188fe:	e7a0      	b.n	18842 <ticker_job+0x182>
	if ((ticker->remainder_current >= BIT(31)) ||
   18900:	6a69      	ldr	r1, [r5, #36]	; 0x24
   18902:	f8df 92b0 	ldr.w	r9, [pc, #688]	; 18bb4 <ticker_job+0x4f4>
   18906:	4aaa      	ldr	r2, [pc, #680]	; (18bb0 <ticker_job+0x4f0>)
   18908:	4489      	add	r9, r1
   1890a:	4591      	cmp	r9, r2
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
   1890c:	bf81      	itttt	hi
   1890e:	f101 71e8 	addhi.w	r1, r1, #30408704	; 0x1d00000
   18912:	f501 31d4 	addhi.w	r1, r1, #108544	; 0x1a800
   18916:	f501 71a5 	addhi.w	r1, r1, #330	; 0x14a
   1891a:	6269      	strhi	r1, [r5, #36]	; 0x24
	ticker->remainder_current -= ticker->remainder_periodic;
   1891c:	e9d5 1208 	ldrd	r1, r2, [r5, #32]
		decrement++;
   18920:	bf8c      	ite	hi
   18922:	f04f 0901 	movhi.w	r9, #1
	u8_t decrement = 0U;
   18926:	f04f 0900 	movls.w	r9, #0
	ticker->remainder_current -= ticker->remainder_periodic;
   1892a:	1a51      	subs	r1, r2, r1
			ticks_to_expire -= ticker->ticks_periodic +
   1892c:	4481      	add	r9, r0
			ticker->lazy_current--;
   1892e:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
	ticker->remainder_current -= ticker->remainder_periodic;
   18932:	6269      	str	r1, [r5, #36]	; 0x24
			ticks_to_expire -= ticker->ticks_periodic +
   18934:	eba3 0309 	sub.w	r3, r3, r9
			ticker->lazy_current--;
   18938:	f8a5 e01e 	strh.w	lr, [r5, #30]
   1893c:	e7b1      	b.n	188a2 <ticker_job+0x1e2>
	ticker->remainder_current += ticker->remainder_periodic;
   1893e:	e9d5 1208 	ldrd	r1, r2, [r5, #32]
	if ((ticker->remainder_current < BIT(31)) &&
   18942:	f8df 9270 	ldr.w	r9, [pc, #624]	; 18bb4 <ticker_job+0x4f4>
	ticker->remainder_current += ticker->remainder_periodic;
   18946:	4411      	add	r1, r2
	if ((ticker->remainder_current < BIT(31)) &&
   18948:	4a99      	ldr	r2, [pc, #612]	; (18bb0 <ticker_job+0x4f0>)
   1894a:	4489      	add	r9, r1
   1894c:	4591      	cmp	r9, r2
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   1894e:	bf9d      	ittte	ls
   18950:	f1a1 71e8 	subls.w	r1, r1, #30408704	; 0x1d00000
   18954:	f5a1 31d4 	subls.w	r1, r1, #108544	; 0x1a800
   18958:	f5a1 71a5 	subls.w	r1, r1, #330	; 0x14a
	ticker->remainder_current += ticker->remainder_periodic;
   1895c:	6269      	strhi	r1, [r5, #36]	; 0x24
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   1895e:	bf96      	itet	ls
   18960:	6269      	strls	r1, [r5, #36]	; 0x24
	return 0;
   18962:	2100      	movhi	r1, #0
		return 1;
   18964:	2101      	movls	r1, #1
			ticks_to_expire += ticker->ticks_periodic +
   18966:	4401      	add	r1, r0
			ticker->lazy_current++;
   18968:	f10e 0e01 	add.w	lr, lr, #1
			ticks_to_expire += ticker->ticks_periodic +
   1896c:	440b      	add	r3, r1
			ticker->lazy_current++;
   1896e:	f8a5 e01e 	strh.w	lr, [r5, #30]
   18972:	e79c      	b.n	188ae <ticker_job+0x1ee>
		ticker->req = ticker->ack;
   18974:	78aa      	ldrb	r2, [r5, #2]
   18976:	706a      	strb	r2, [r5, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
   18978:	7f21      	ldrb	r1, [r4, #28]
   1897a:	7872      	ldrb	r2, [r6, #1]
   1897c:	4291      	cmp	r1, r2
   1897e:	d1bd      	bne.n	188fc <ticker_job+0x23c>
			instance->ticker_id_slot_previous = TICKER_NULL;
   18980:	22ff      	movs	r2, #255	; 0xff
			if (user_op->op == TICKER_USER_OP_TYPE_STOP_ABS) {
   18982:	2b07      	cmp	r3, #7
			instance->ticker_id_slot_previous = TICKER_NULL;
   18984:	7722      	strb	r2, [r4, #28]
			if (user_op->op == TICKER_USER_OP_TYPE_STOP_ABS) {
   18986:	d10c      	bne.n	189a2 <ticker_job+0x2e2>
				ticks_at_stop =
   18988:	6870      	ldr	r0, [r6, #4]
			ticks_current = instance->ticks_current;
   1898a:	6963      	ldr	r3, [r4, #20]
			if (!((ticks_at_stop - ticks_current) &
   1898c:	1ac2      	subs	r2, r0, r3
   1898e:	0211      	lsls	r1, r2, #8
   18990:	d40a      	bmi.n	189a8 <ticker_job+0x2e8>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   18992:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
				ticks_used = ticks_elapsed +
   18996:	443b      	add	r3, r7
			if (instance->ticks_slot_previous > ticks_used) {
   18998:	69a2      	ldr	r2, [r4, #24]
   1899a:	429a      	cmp	r2, r3
				instance->ticks_slot_previous = ticks_used;
   1899c:	bf88      	it	hi
   1899e:	61a3      	strhi	r3, [r4, #24]
   189a0:	e7ac      	b.n	188fc <ticker_job+0x23c>
				ticks_at_stop = cntr_cnt_get();
   189a2:	f005 fce7 	bl	1e374 <cntr_cnt_get>
   189a6:	e7f0      	b.n	1898a <ticker_job+0x2ca>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   189a8:	1a1b      	subs	r3, r3, r0
   189aa:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
				if (ticks_elapsed > ticks_used) {
   189ae:	429f      	cmp	r7, r3
					ticks_used = ticks_elapsed -
   189b0:	bf8c      	ite	hi
   189b2:	1afb      	subhi	r3, r7, r3
					ticks_used = 0;
   189b4:	2300      	movls	r3, #0
   189b6:	e7ef      	b.n	18998 <ticker_job+0x2d8>
				instance->sched_cb(TICKER_CALL_ID_JOB,
   189b8:	2104      	movs	r1, #4
   189ba:	4623      	mov	r3, r4
   189bc:	6a65      	ldr	r5, [r4, #36]	; 0x24
   189be:	2201      	movs	r2, #1
   189c0:	4608      	mov	r0, r1
   189c2:	47a8      	blx	r5
				pending = 1U;
   189c4:	2301      	movs	r3, #1
				user->middle = prev;
   189c6:	f88a 8002 	strb.w	r8, [sl, #2]
				pending = 1U;
   189ca:	9303      	str	r3, [sp, #12]
				break;
   189cc:	e6a3      	b.n	18716 <ticker_job+0x56>
			if (instance->ticks_slot_previous > ticks_to_expire) {
   189ce:	69a2      	ldr	r2, [r4, #24]
   189d0:	4293      	cmp	r3, r2
		ticks_elapsed -= ticks_to_expire;
   189d2:	eba7 0703 	sub.w	r7, r7, r3
		ticks_expired += ticks_to_expire;
   189d6:	4499      	add	r9, r3
				instance->ticker_id_slot_previous = TICKER_NULL;
   189d8:	bf29      	itett	cs
   189da:	23ff      	movcs	r3, #255	; 0xff
				instance->ticks_slot_previous -=
   189dc:	1ad3      	subcc	r3, r2, r3
				instance->ticker_id_slot_previous = TICKER_NULL;
   189de:	7723      	strbcs	r3, [r4, #28]
				instance->ticks_slot_previous = 0U;
   189e0:	2300      	movcs	r3, #0
   189e2:	61a3      	str	r3, [r4, #24]
			    ticker->ticks_slot != 0U) {
   189e4:	6983      	ldr	r3, [r0, #24]
			if (!TICKER_RESCHEDULE_PENDING(ticker) &&
   189e6:	b10b      	cbz	r3, 189ec <ticker_job+0x32c>
				instance->ticker_id_slot_previous =
   189e8:	7725      	strb	r5, [r4, #28]
				instance->ticks_slot_previous =
   189ea:	61a3      	str	r3, [r4, #24]
		instance->ticker_id_head = ticker->next;
   189ec:	9b02      	ldr	r3, [sp, #8]
		ticker->ticks_to_expire = 0U;
   189ee:	2100      	movs	r1, #0
   189f0:	6081      	str	r1, [r0, #8]
		instance->ticker_id_head = ticker->next;
   189f2:	f813 3036 	ldrb.w	r3, [r3, r6, lsl #3]
   189f6:	7763      	strb	r3, [r4, #29]
		if ((ticker->ticks_periodic != 0U) ||
   189f8:	f8d0 e004 	ldr.w	lr, [r0, #4]
   189fc:	f1be 0f00 	cmp.w	lr, #0
   18a00:	d02d      	beq.n	18a5e <ticker_job+0x39e>
			while (count--) {
   18a02:	f8b0 c01c 	ldrh.w	ip, [r0, #28]
	if ((ticker->remainder_current < BIT(31)) &&
   18a06:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 18bb0 <ticker_job+0x4f0>
	ticker->remainder_current += ticker->remainder_periodic;
   18a0a:	e9d0 2308 	ldrd	r2, r3, [r0, #32]
   18a0e:	4413      	add	r3, r2
	if ((ticker->remainder_current < BIT(31)) &&
   18a10:	4a68      	ldr	r2, [pc, #416]	; (18bb4 <ticker_job+0x4f4>)
   18a12:	189a      	adds	r2, r3, r2
   18a14:	4552      	cmp	r2, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   18a16:	bf9f      	itttt	ls
   18a18:	f1a3 73e8 	subls.w	r3, r3, #30408704	; 0x1d00000
   18a1c:	f5a3 33d4 	subls.w	r3, r3, #108544	; 0x1a800
   18a20:	f5a3 73a5 	subls.w	r3, r3, #330	; 0x14a
   18a24:	6243      	strls	r3, [r0, #36]	; 0x24
		return 1;
   18a26:	bf92      	itee	ls
   18a28:	9b00      	ldrls	r3, [sp, #0]
	ticker->remainder_current += ticker->remainder_periodic;
   18a2a:	6243      	strhi	r3, [r0, #36]	; 0x24
	return 0;
   18a2c:	2300      	movhi	r3, #0
				ticks_to_expire += ticker_remainder_inc(ticker);
   18a2e:	4473      	add	r3, lr
			while (count--) {
   18a30:	f1bc 0c01 	subs.w	ip, ip, #1
				ticks_to_expire += ticker_remainder_inc(ticker);
   18a34:	4419      	add	r1, r3
			while (count--) {
   18a36:	d2e8      	bcs.n	18a0a <ticker_job+0x34a>
			ticks_to_expire_prep(ticker, instance->ticks_current,
   18a38:	9b04      	ldr	r3, [sp, #16]
			ticker->ticks_to_expire = ticks_to_expire;
   18a3a:	6081      	str	r1, [r0, #8]
			ticks_to_expire_prep(ticker, instance->ticks_current,
   18a3c:	eb03 0209 	add.w	r2, r3, r9
   18a40:	6961      	ldr	r1, [r4, #20]
   18a42:	f00f fbda 	bl	281fa <ticks_to_expire_prep>
			ticker->lazy_current = ticker->lazy_periodic;
   18a46:	8b83      	ldrh	r3, [r0, #28]
   18a48:	83c3      	strh	r3, [r0, #30]
			ticker->force = 0U;
   18a4a:	2300      	movs	r3, #0
   18a4c:	70c3      	strb	r3, [r0, #3]
			ticker->next = *insert_head;
   18a4e:	9b02      	ldr	r3, [sp, #8]
   18a50:	f803 b036 	strb.w	fp, [r3, r6, lsl #3]
			ticker->req++;
   18a54:	7843      	ldrb	r3, [r0, #1]
   18a56:	3301      	adds	r3, #1
   18a58:	7043      	strb	r3, [r0, #1]
			ticker->req = ticker->ack;
   18a5a:	46ab      	mov	fp, r5
   18a5c:	e66e      	b.n	1873c <ticker_job+0x7c>
   18a5e:	7883      	ldrb	r3, [r0, #2]
   18a60:	7043      	strb	r3, [r0, #1]
   18a62:	465d      	mov	r5, fp
   18a64:	e7f9      	b.n	18a5a <ticker_job+0x39a>
	users = &instance->users[0];
   18a66:	6863      	ldr	r3, [r4, #4]
   18a68:	9300      	str	r3, [sp, #0]
	count_user = instance->count_user;
   18a6a:	7a65      	ldrb	r5, [r4, #9]
		uop->status = TICKER_STATUS_SUCCESS;
   18a6c:	9b03      	ldr	r3, [sp, #12]
   18a6e:	9302      	str	r3, [sp, #8]
	while (count_user--) {
   18a70:	3d01      	subs	r5, #1
   18a72:	b2ed      	uxtb	r5, r5
   18a74:	2dff      	cmp	r5, #255	; 0xff
   18a76:	f43f ae83 	beq.w	18780 <ticker_job+0xc0>
		user = &users[count_user];
   18a7a:	9b00      	ldr	r3, [sp, #0]
   18a7c:	eb03 06c5 	add.w	r6, r3, r5, lsl #3
		user_op = &user->user_op[0];
   18a80:	6877      	ldr	r7, [r6, #4]
		while (user->first != user->last) {
   18a82:	7873      	ldrb	r3, [r6, #1]
   18a84:	78f2      	ldrb	r2, [r6, #3]
   18a86:	429a      	cmp	r2, r3
   18a88:	d0f2      	beq.n	18a70 <ticker_job+0x3b0>
			ticker_job_op_inquire(instance, &user_op[user->first]);
   18a8a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   18a8e:	011a      	lsls	r2, r3, #4
   18a90:	eb07 1303 	add.w	r3, r7, r3, lsl #4
	switch (uop->op) {
   18a94:	5cba      	ldrb	r2, [r7, r2]
   18a96:	2a01      	cmp	r2, #1
   18a98:	d023      	beq.n	18ae2 <ticker_job+0x422>
   18a9a:	2a02      	cmp	r2, #2
   18a9c:	d128      	bne.n	18af0 <ticker_job+0x430>
		ticker_by_next_slot_get(instance,
   18a9e:	e9d3 9001 	ldrd	r9, r0, [r3, #4]
	_ticker_id_head = *ticker_id_head;
   18aa2:	f899 a000 	ldrb.w	sl, [r9]
		ticker_by_next_slot_get(instance,
   18aa6:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	node = instance->nodes;
   18aaa:	f8d4 c000 	ldr.w	ip, [r4]
	if ((_ticker_id_head == TICKER_NULL) ||
   18aae:	6961      	ldr	r1, [r4, #20]
   18ab0:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   18ab4:	d002      	beq.n	18abc <ticker_job+0x3fc>
   18ab6:	6802      	ldr	r2, [r0, #0]
   18ab8:	4291      	cmp	r1, r2
   18aba:	d022      	beq.n	18b02 <ticker_job+0x442>
		_ticker_id_head = instance->ticker_id_head;
   18abc:	7f62      	ldrb	r2, [r4, #29]
		*ticks_current = instance->ticks_current;
   18abe:	6001      	str	r1, [r0, #0]
		_ticks_to_expire = 0U;
   18ac0:	2100      	movs	r1, #0
	while ((_ticker_id_head != TICKER_NULL) &&
   18ac2:	2aff      	cmp	r2, #255	; 0xff
   18ac4:	d009      	beq.n	18ada <ticker_job+0x41a>
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
   18ac6:	eb02 0b82 	add.w	fp, r2, r2, lsl #2
   18aca:	eb0c 0acb 	add.w	sl, ip, fp, lsl #3
   18ace:	f8da 0008 	ldr.w	r0, [sl, #8]
   18ad2:	4401      	add	r1, r0
	while ((_ticker_id_head != TICKER_NULL) &&
   18ad4:	f8da 0018 	ldr.w	r0, [sl, #24]
   18ad8:	b1d0      	cbz	r0, 18b10 <ticker_job+0x450>
	*ticker_id_head = _ticker_id_head;
   18ada:	f889 2000 	strb.w	r2, [r9]
	*ticks_to_expire = _ticks_to_expire;
   18ade:	f8ce 1000 	str.w	r1, [lr]
		uop->status = TICKER_STATUS_SUCCESS;
   18ae2:	9a02      	ldr	r2, [sp, #8]
   18ae4:	625a      	str	r2, [r3, #36]	; 0x24
		fp_op_func = uop->fp_op_func;
   18ae6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (fp_op_func) {
   18ae8:	b112      	cbz	r2, 18af0 <ticker_job+0x430>
		fp_op_func(uop->status, uop->op_context);
   18aea:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   18aec:	2000      	movs	r0, #0
   18aee:	4790      	blx	r2
			first = user->first + 1;
   18af0:	7873      	ldrb	r3, [r6, #1]
			if (first == user->count_user_op) {
   18af2:	7832      	ldrb	r2, [r6, #0]
			first = user->first + 1;
   18af4:	3301      	adds	r3, #1
   18af6:	b2db      	uxtb	r3, r3
				first = 0U;
   18af8:	429a      	cmp	r2, r3
   18afa:	bf08      	it	eq
   18afc:	2300      	moveq	r3, #0
			user->first = first;
   18afe:	7073      	strb	r3, [r6, #1]
   18b00:	e7bf      	b.n	18a82 <ticker_job+0x3c2>
		ticker = &node[_ticker_id_head];
   18b02:	eb0a 028a 	add.w	r2, sl, sl, lsl #2
	_ticks_to_expire = *ticks_to_expire;
   18b06:	f8de 1000 	ldr.w	r1, [lr]
		_ticker_id_head = ticker->next;
   18b0a:	f81c 2032 	ldrb.w	r2, [ip, r2, lsl #3]
   18b0e:	e7d8      	b.n	18ac2 <ticker_job+0x402>
		_ticker_id_head = ticker->next;
   18b10:	f81c 203b 	ldrb.w	r2, [ip, fp, lsl #3]
   18b14:	e7d5      	b.n	18ac2 <ticker_job+0x402>
	if (ticker_id_old_head == TICKER_NULL) {
   18b16:	9b01      	ldr	r3, [sp, #4]
   18b18:	2bff      	cmp	r3, #255	; 0xff
   18b1a:	d106      	bne.n	18b2a <ticker_job+0x46a>
		ticks_current = cntr_cnt_get();
   18b1c:	f005 fc2a 	bl	1e374 <cntr_cnt_get>
   18b20:	4605      	mov	r5, r0
		if (cntr_start() == 0) {
   18b22:	f005 fbf3 	bl	1e30c <cntr_start>
   18b26:	b900      	cbnz	r0, 18b2a <ticker_job+0x46a>
			instance->ticks_current = ticks_current;
   18b28:	6165      	str	r5, [r4, #20]
	ticker = &instance->nodes[instance->ticker_id_head];
   18b2a:	7f63      	ldrb	r3, [r4, #29]
	ticks_to_expire = ticker->ticks_to_expire;
   18b2c:	6822      	ldr	r2, [r4, #0]
		LL_ASSERT(i);
   18b2e:	f8df 8088 	ldr.w	r8, [pc, #136]	; 18bb8 <ticker_job+0x4f8>
   18b32:	f8df 9088 	ldr.w	r9, [pc, #136]	; 18bbc <ticker_job+0x4fc>
   18b36:	f8df a088 	ldr.w	sl, [pc, #136]	; 18bc0 <ticker_job+0x500>
	ticker = &instance->nodes[instance->ticker_id_head];
   18b3a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	ticks_to_expire = ticker->ticks_to_expire;
   18b3e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
	i = 10U;
   18b42:	260a      	movs	r6, #10
	ticks_to_expire = ticker->ticks_to_expire;
   18b44:	689f      	ldr	r7, [r3, #8]
		ctr = cntr_cnt_get();
   18b46:	f005 fc15 	bl	1e374 <cntr_cnt_get>
		cc = instance->ticks_current;
   18b4a:	6965      	ldr	r5, [r4, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   18b4c:	1b43      	subs	r3, r0, r5
   18b4e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
   18b52:	3303      	adds	r3, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
   18b54:	42bb      	cmp	r3, r7
   18b56:	bf2c      	ite	cs
   18b58:	18ed      	addcs	r5, r5, r3
   18b5a:	19ed      	addcc	r5, r5, r7
		cc &= HAL_TICKER_CNTR_MASK;
   18b5c:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
   18b60:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		ctr = cntr_cnt_get();
   18b62:	4683      	mov	fp, r0
		instance->trigger_set_cb(cc);
   18b64:	4628      	mov	r0, r5
   18b66:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
   18b68:	f005 fc04 	bl	1e374 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   18b6c:	eba0 030b 	sub.w	r3, r0, fp
   18b70:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   18b74:	eba5 050b 	sub.w	r5, r5, fp
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
   18b78:	3303      	adds	r3, #3
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   18b7a:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		  ticker_ticks_diff_get(cc, ctr));
   18b7e:	42ab      	cmp	r3, r5
		i--;
   18b80:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
		  ticker_ticks_diff_get(cc, ctr));
   18b84:	f67f ae0c 	bls.w	187a0 <ticker_job+0xe0>
		LL_ASSERT(i);
   18b88:	2e00      	cmp	r6, #0
   18b8a:	d1dc      	bne.n	18b46 <ticker_job+0x486>
   18b8c:	f640 0342 	movw	r3, #2114	; 0x842
   18b90:	4642      	mov	r2, r8
   18b92:	4649      	mov	r1, r9
   18b94:	4650      	mov	r0, sl
   18b96:	f00b f9a4 	bl	23ee2 <printk>
   18b9a:	4040      	eors	r0, r0
   18b9c:	f380 8811 	msr	BASEPRI, r0
   18ba0:	f04f 0003 	mov.w	r0, #3
   18ba4:	df02      	svc	2
   18ba6:	e7ce      	b.n	18b46 <ticker_job+0x486>
}
   18ba8:	b00b      	add	sp, #44	; 0x2c
   18baa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18bae:	bf00      	nop
   18bb0:	7f172b59 	.word	0x7f172b59
   18bb4:	ff172b5a 	.word	0xff172b5a
   18bb8:	00030166 	.word	0x00030166
   18bbc:	00030359 	.word	0x00030359
   18bc0:	0002a5e8 	.word	0x0002a5e8

00018bc4 <ticker_init>:
{
   18bc4:	b5f0      	push	{r4, r5, r6, r7, lr}
   18bc6:	9d05      	ldr	r5, [sp, #20]
   18bc8:	f89d 4018 	ldrb.w	r4, [sp, #24]
   18bcc:	9e07      	ldr	r6, [sp, #28]
   18bce:	4617      	mov	r7, r2
	if (instance_index >= TICKER_INSTANCE_MAX) {
   18bd0:	b108      	cbz	r0, 18bd6 <ticker_init+0x12>
		return TICKER_STATUS_FAILURE;
   18bd2:	2001      	movs	r0, #1
}
   18bd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	instance->count_node = count_node;
   18bd6:	4a12      	ldr	r2, [pc, #72]	; (18c20 <ticker_init+0x5c>)
   18bd8:	7211      	strb	r1, [r2, #8]
	instance->nodes = node;
   18bda:	6017      	str	r7, [r2, #0]
	instance->count_user = count_user;
   18bdc:	7253      	strb	r3, [r2, #9]
	instance->users = user;
   18bde:	6055      	str	r5, [r2, #4]
	while (count_user--) {
   18be0:	3b01      	subs	r3, #1
   18be2:	b2db      	uxtb	r3, r3
   18be4:	2bff      	cmp	r3, #255	; 0xff
   18be6:	d10f      	bne.n	18c08 <ticker_init+0x44>
	if (count_op) {
   18be8:	2c00      	cmp	r4, #0
   18bea:	d1f2      	bne.n	18bd2 <ticker_init+0xe>
	instance->caller_id_get_cb = caller_id_get_cb;
   18bec:	9b08      	ldr	r3, [sp, #32]
   18bee:	6213      	str	r3, [r2, #32]
	instance->sched_cb = sched_cb;
   18bf0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18bf2:	6253      	str	r3, [r2, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
   18bf4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18bf6:	6293      	str	r3, [r2, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
   18bf8:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->ticks_slot_previous = 0U;
   18bfc:	e9c2 4405 	strd	r4, r4, [r2, #20]
	instance->ticker_id_slot_previous = TICKER_NULL;
   18c00:	8393      	strh	r3, [r2, #28]
	instance->ticks_elapsed_first = 0U;
   18c02:	8154      	strh	r4, [r2, #10]
	return TICKER_STATUS_SUCCESS;
   18c04:	4620      	mov	r0, r4
   18c06:	e7e5      	b.n	18bd4 <ticker_init+0x10>
		users[count_user].user_op = user_op_;
   18c08:	eb05 01c3 	add.w	r1, r5, r3, lsl #3
   18c0c:	604e      	str	r6, [r1, #4]
		user_op_ += users[count_user].count_user_op;
   18c0e:	f815 0033 	ldrb.w	r0, [r5, r3, lsl #3]
   18c12:	eb00 0140 	add.w	r1, r0, r0, lsl #1
		count_op -= users[count_user].count_user_op;
   18c16:	1a20      	subs	r0, r4, r0
		user_op_ += users[count_user].count_user_op;
   18c18:	eb06 1601 	add.w	r6, r6, r1, lsl #4
		count_op -= users[count_user].count_user_op;
   18c1c:	b2c4      	uxtb	r4, r0
   18c1e:	e7df      	b.n	18be0 <ticker_init+0x1c>
   18c20:	20000e08 	.word	0x20000e08

00018c24 <ticker_is_initialized>:
	return !!(_instance[instance_index].count_node);
   18c24:	4b04      	ldr	r3, [pc, #16]	; (18c38 <ticker_is_initialized+0x14>)
   18c26:	222c      	movs	r2, #44	; 0x2c
   18c28:	fb02 3000 	mla	r0, r2, r0, r3
   18c2c:	7a00      	ldrb	r0, [r0, #8]
}
   18c2e:	3800      	subs	r0, #0
   18c30:	bf18      	it	ne
   18c32:	2001      	movne	r0, #1
   18c34:	4770      	bx	lr
   18c36:	bf00      	nop
   18c38:	20000e08 	.word	0x20000e08

00018c3c <ticker_trigger>:
	if (instance->sched_cb) {
   18c3c:	4b07      	ldr	r3, [pc, #28]	; (18c5c <ticker_trigger+0x20>)
   18c3e:	222c      	movs	r2, #44	; 0x2c
   18c40:	fb02 3100 	mla	r1, r2, r0, r3
{
   18c44:	b410      	push	{r4}
	if (instance->sched_cb) {
   18c46:	6a4c      	ldr	r4, [r1, #36]	; 0x24
   18c48:	b134      	cbz	r4, 18c58 <ticker_trigger+0x1c>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   18c4a:	460b      	mov	r3, r1
   18c4c:	46a4      	mov	ip, r4
   18c4e:	2201      	movs	r2, #1
}
   18c50:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   18c52:	2103      	movs	r1, #3
   18c54:	2002      	movs	r0, #2
   18c56:	4760      	bx	ip
}
   18c58:	bc10      	pop	{r4}
   18c5a:	4770      	bx	lr
   18c5c:	20000e08 	.word	0x20000e08

00018c60 <ticker_start>:
{
   18c60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   18c64:	4694      	mov	ip, r2
   18c66:	461a      	mov	r2, r3
	struct ticker_instance *instance = &_instance[instance_index];
   18c68:	4b21      	ldr	r3, [pc, #132]	; (18cf0 <ticker_start+0x90>)
{
   18c6a:	4605      	mov	r5, r0
   18c6c:	4608      	mov	r0, r1
	struct ticker_instance *instance = &_instance[instance_index];
   18c6e:	212c      	movs	r1, #44	; 0x2c
   18c70:	fb05 3801 	mla	r8, r5, r1, r3
	user = &instance->users[user_id];
   18c74:	f8d8 3004 	ldr.w	r3, [r8, #4]
   18c78:	eb03 07c0 	add.w	r7, r3, r0, lsl #3
	if (last >= user->count_user_op) {
   18c7c:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
	last = user->last + 1;
   18c80:	78fc      	ldrb	r4, [r7, #3]
   18c82:	1c66      	adds	r6, r4, #1
   18c84:	b2f6      	uxtb	r6, r6
		last = 0U;
   18c86:	42b3      	cmp	r3, r6
   18c88:	bf98      	it	ls
   18c8a:	2600      	movls	r6, #0
	if (last == user->first) {
   18c8c:	787b      	ldrb	r3, [r7, #1]
   18c8e:	42b3      	cmp	r3, r6
   18c90:	d02c      	beq.n	18cec <ticker_start+0x8c>
	user_op = &user->user_op[user->last];
   18c92:	687b      	ldr	r3, [r7, #4]
   18c94:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   18c98:	0121      	lsls	r1, r4, #4
	user_op->op = TICKER_USER_OP_TYPE_START;
   18c9a:	f04f 0904 	mov.w	r9, #4
	user_op = &user->user_op[user->last];
   18c9e:	eb03 1404 	add.w	r4, r3, r4, lsl #4
	user_op->op = TICKER_USER_OP_TYPE_START;
   18ca2:	f803 9001 	strb.w	r9, [r3, r1]
	user_op->params.start.ticks_first = ticks_first;
   18ca6:	9b08      	ldr	r3, [sp, #32]
   18ca8:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
   18caa:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18cac:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
   18cae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18cb0:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
   18cb2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   18cb4:	61a3      	str	r3, [r4, #24]
	user_op->params.start.lazy = lazy;
   18cb6:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
   18cba:	82a3      	strh	r3, [r4, #20]
	user_op->params.start.fp_timeout_func = fp_timeout_func;
   18cbc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18cbe:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
   18cc0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   18cc2:	6223      	str	r3, [r4, #32]
	user_op->status = TICKER_STATUS_BUSY;
   18cc4:	2302      	movs	r3, #2
   18cc6:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->fp_op_func = fp_op_func;
   18cc8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   18cca:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->op_context = op_context;
   18ccc:	9b10      	ldr	r3, [sp, #64]	; 0x40
	user_op->id = ticker_id;
   18cce:	f884 c001 	strb.w	ip, [r4, #1]
	user_op->params.start.ticks_at_start = ticks_anchor;
   18cd2:	6062      	str	r2, [r4, #4]
	user_op->op_context = op_context;
   18cd4:	62e3      	str	r3, [r4, #44]	; 0x2c
	user->last = last;
   18cd6:	70fe      	strb	r6, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   18cd8:	e9d8 3608 	ldrd	r3, r6, [r8, #32]
   18cdc:	4798      	blx	r3
   18cde:	4643      	mov	r3, r8
   18ce0:	2200      	movs	r2, #0
   18ce2:	4649      	mov	r1, r9
   18ce4:	47b0      	blx	r6
	return user_op->status;
   18ce6:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
   18ce8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
   18cec:	2001      	movs	r0, #1
   18cee:	e7fb      	b.n	18ce8 <ticker_start+0x88>
   18cf0:	20000e08 	.word	0x20000e08

00018cf4 <ticker_update>:
{
   18cf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18cf8:	4605      	mov	r5, r0
   18cfa:	4608      	mov	r0, r1
   18cfc:	4619      	mov	r1, r3
	struct ticker_instance *instance = &_instance[instance_index];
   18cfe:	4b1f      	ldr	r3, [pc, #124]	; (18d7c <ticker_update+0x88>)
   18d00:	242c      	movs	r4, #44	; 0x2c
   18d02:	fb05 3804 	mla	r8, r5, r4, r3
	user = &instance->users[user_id];
   18d06:	f8d8 3004 	ldr.w	r3, [r8, #4]
   18d0a:	eb03 07c0 	add.w	r7, r3, r0, lsl #3
	if (last >= user->count_user_op) {
   18d0e:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
	last = user->last + 1;
   18d12:	78fc      	ldrb	r4, [r7, #3]
   18d14:	1c66      	adds	r6, r4, #1
   18d16:	b2f6      	uxtb	r6, r6
		last = 0U;
   18d18:	42b3      	cmp	r3, r6
   18d1a:	bf98      	it	ls
   18d1c:	2600      	movls	r6, #0
	if (last == user->first) {
   18d1e:	787b      	ldrb	r3, [r7, #1]
   18d20:	42b3      	cmp	r3, r6
   18d22:	d029      	beq.n	18d78 <ticker_update+0x84>
	user_op = &user->user_op[user->last];
   18d24:	687b      	ldr	r3, [r7, #4]
   18d26:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   18d2a:	ea4f 1c04 	mov.w	ip, r4, lsl #4
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
   18d2e:	f04f 0e05 	mov.w	lr, #5
	user_op = &user->user_op[user->last];
   18d32:	eb03 1404 	add.w	r4, r3, r4, lsl #4
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
   18d36:	f803 e00c 	strb.w	lr, [r3, ip]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
   18d3a:	9b06      	ldr	r3, [sp, #24]
   18d3c:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
   18d3e:	9b07      	ldr	r3, [sp, #28]
   18d40:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
   18d42:	9b08      	ldr	r3, [sp, #32]
   18d44:	6123      	str	r3, [r4, #16]
	user_op->params.update.lazy = lazy;
   18d46:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   18d4a:	82a3      	strh	r3, [r4, #20]
	user_op->params.update.force = force;
   18d4c:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   18d50:	75a3      	strb	r3, [r4, #22]
	user_op->status = TICKER_STATUS_BUSY;
   18d52:	2302      	movs	r3, #2
   18d54:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->fp_op_func = fp_op_func;
   18d56:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18d58:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->op_context = op_context;
   18d5a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	user_op->id = ticker_id;
   18d5c:	7062      	strb	r2, [r4, #1]
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
   18d5e:	6061      	str	r1, [r4, #4]
	user_op->op_context = op_context;
   18d60:	62e3      	str	r3, [r4, #44]	; 0x2c
	user->last = last;
   18d62:	70fe      	strb	r6, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   18d64:	e9d8 3608 	ldrd	r3, r6, [r8, #32]
   18d68:	4798      	blx	r3
   18d6a:	4643      	mov	r3, r8
   18d6c:	2200      	movs	r2, #0
   18d6e:	2104      	movs	r1, #4
   18d70:	47b0      	blx	r6
	return user_op->status;
   18d72:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
   18d74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
   18d78:	2001      	movs	r0, #1
   18d7a:	e7fb      	b.n	18d74 <ticker_update+0x80>
   18d7c:	20000e08 	.word	0x20000e08

00018d80 <ticker_stop>:
{
   18d80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18d84:	4605      	mov	r5, r0
   18d86:	4608      	mov	r0, r1
   18d88:	4619      	mov	r1, r3
	struct ticker_instance *instance = &_instance[instance_index];
   18d8a:	4b18      	ldr	r3, [pc, #96]	; (18dec <ticker_stop+0x6c>)
   18d8c:	242c      	movs	r4, #44	; 0x2c
   18d8e:	fb05 3804 	mla	r8, r5, r4, r3
	user = &instance->users[user_id];
   18d92:	f8d8 3004 	ldr.w	r3, [r8, #4]
   18d96:	eb03 07c0 	add.w	r7, r3, r0, lsl #3
	if (last >= user->count_user_op) {
   18d9a:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
	last = user->last + 1;
   18d9e:	78fc      	ldrb	r4, [r7, #3]
   18da0:	1c66      	adds	r6, r4, #1
   18da2:	b2f6      	uxtb	r6, r6
		last = 0U;
   18da4:	42b3      	cmp	r3, r6
   18da6:	bf98      	it	ls
   18da8:	2600      	movls	r6, #0
	if (last == user->first) {
   18daa:	787b      	ldrb	r3, [r7, #1]
   18dac:	42b3      	cmp	r3, r6
   18dae:	d01b      	beq.n	18de8 <ticker_stop+0x68>
	user_op = &user->user_op[user->last];
   18db0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   18db4:	687b      	ldr	r3, [r7, #4]
   18db6:	ea4f 1c04 	mov.w	ip, r4, lsl #4
	user_op->op = TICKER_USER_OP_TYPE_STOP;
   18dba:	f04f 0e06 	mov.w	lr, #6
   18dbe:	f803 e00c 	strb.w	lr, [r3, ip]
	user_op = &user->user_op[user->last];
   18dc2:	eb03 1404 	add.w	r4, r3, r4, lsl #4
	user_op->status = TICKER_STATUS_BUSY;
   18dc6:	2302      	movs	r3, #2
	user_op->fp_op_func = fp_op_func;
   18dc8:	e9c4 3109 	strd	r3, r1, [r4, #36]	; 0x24
	user_op->op_context = op_context;
   18dcc:	9b06      	ldr	r3, [sp, #24]
	user_op->id = ticker_id;
   18dce:	7062      	strb	r2, [r4, #1]
	user_op->op_context = op_context;
   18dd0:	62e3      	str	r3, [r4, #44]	; 0x2c
	user->last = last;
   18dd2:	70fe      	strb	r6, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   18dd4:	e9d8 3608 	ldrd	r3, r6, [r8, #32]
   18dd8:	4798      	blx	r3
   18dda:	4643      	mov	r3, r8
   18ddc:	2200      	movs	r2, #0
   18dde:	2104      	movs	r1, #4
   18de0:	47b0      	blx	r6
	return user_op->status;
   18de2:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
   18de4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
   18de8:	2001      	movs	r0, #1
   18dea:	e7fb      	b.n	18de4 <ticker_stop+0x64>
   18dec:	20000e08 	.word	0x20000e08

00018df0 <ll_addr_get>:

static u8_t pub_addr[BDADDR_SIZE];
static u8_t rnd_addr[BDADDR_SIZE];

u8_t *ll_addr_get(u8_t addr_type, u8_t *bdaddr)
{
   18df0:	b508      	push	{r3, lr}
   18df2:	4603      	mov	r3, r0
	if (addr_type > 1) {
   18df4:	2b01      	cmp	r3, #1
{
   18df6:	4608      	mov	r0, r1
	if (addr_type > 1) {
   18df8:	d80e      	bhi.n	18e18 <ll_addr_get+0x28>
		return NULL;
	}

	if (addr_type) {
   18dfa:	b133      	cbz	r3, 18e0a <ll_addr_get+0x1a>
		if (bdaddr) {
   18dfc:	b119      	cbz	r1, 18e06 <ll_addr_get+0x16>
			memcpy(bdaddr, rnd_addr, BDADDR_SIZE);
   18dfe:	4907      	ldr	r1, [pc, #28]	; (18e1c <ll_addr_get+0x2c>)
   18e00:	2206      	movs	r2, #6
   18e02:	f00c ff51 	bl	25ca8 <memcpy>
		}

		return rnd_addr;
   18e06:	4805      	ldr	r0, [pc, #20]	; (18e1c <ll_addr_get+0x2c>)
   18e08:	e007      	b.n	18e1a <ll_addr_get+0x2a>
	}

	if (bdaddr) {
   18e0a:	b119      	cbz	r1, 18e14 <ll_addr_get+0x24>
		memcpy(bdaddr, pub_addr, BDADDR_SIZE);
   18e0c:	4904      	ldr	r1, [pc, #16]	; (18e20 <ll_addr_get+0x30>)
   18e0e:	2206      	movs	r2, #6
   18e10:	f00c ff4a 	bl	25ca8 <memcpy>
	}

	return pub_addr;
   18e14:	4802      	ldr	r0, [pc, #8]	; (18e20 <ll_addr_get+0x30>)
   18e16:	e000      	b.n	18e1a <ll_addr_get+0x2a>
		return NULL;
   18e18:	2000      	movs	r0, #0
}
   18e1a:	bd08      	pop	{r3, pc}
   18e1c:	200024d2 	.word	0x200024d2
   18e20:	200024cc 	.word	0x200024cc

00018e24 <ll_addr_set>:

u32_t ll_addr_set(u8_t addr_type, u8_t const *const bdaddr)
{
   18e24:	b570      	push	{r4, r5, r6, lr}
   18e26:	4606      	mov	r6, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
	    ull_adv_is_enabled(0)) {
   18e28:	2000      	movs	r0, #0
{
   18e2a:	460d      	mov	r5, r1
	    ull_adv_is_enabled(0)) {
   18e2c:	f00f fb23 	bl	28476 <ull_adv_is_enabled>
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
   18e30:	b110      	cbz	r0, 18e38 <ll_addr_set+0x14>
		return BT_HCI_ERR_CMD_DISALLOWED;
   18e32:	240c      	movs	r4, #12
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
	}

	return 0;
}
   18e34:	4620      	mov	r0, r4
   18e36:	bd70      	pop	{r4, r5, r6, pc}
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
   18e38:	f00f fb60 	bl	284fc <ull_scan_is_enabled>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
   18e3c:	f010 0406 	ands.w	r4, r0, #6
   18e40:	d1f7      	bne.n	18e32 <ll_addr_set+0xe>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
   18e42:	2206      	movs	r2, #6
   18e44:	4629      	mov	r1, r5
	if (addr_type) {
   18e46:	b11e      	cbz	r6, 18e50 <ll_addr_set+0x2c>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
   18e48:	4802      	ldr	r0, [pc, #8]	; (18e54 <ll_addr_set+0x30>)
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
   18e4a:	f00c ff2d 	bl	25ca8 <memcpy>
   18e4e:	e7f1      	b.n	18e34 <ll_addr_set+0x10>
   18e50:	4801      	ldr	r0, [pc, #4]	; (18e58 <ll_addr_set+0x34>)
   18e52:	e7fa      	b.n	18e4a <ll_addr_set+0x26>
   18e54:	200024d2 	.word	0x200024d2
   18e58:	200024cc 	.word	0x200024cc

00018e5c <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(struct device *unused)
{
   18e5c:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
   18e5e:	4802      	ldr	r0, [pc, #8]	; (18e68 <hci_driver_init+0xc>)
   18e60:	f7ee fd2e 	bl	78c0 <bt_hci_driver_register>

	return 0;
}
   18e64:	2000      	movs	r0, #0
   18e66:	bd08      	pop	{r3, pc}
   18e68:	0002a494 	.word	0x0002a494

00018e6c <hci_driver_send>:
	if (!buf->len) {
   18e6c:	8983      	ldrh	r3, [r0, #12]
{
   18e6e:	b537      	push	{r0, r1, r2, r4, r5, lr}
   18e70:	4605      	mov	r5, r0
	if (!buf->len) {
   18e72:	b973      	cbnz	r3, 18e92 <hci_driver_send+0x26>
   18e74:	4920      	ldr	r1, [pc, #128]	; (18ef8 <hci_driver_send+0x8c>)
   18e76:	4b21      	ldr	r3, [pc, #132]	; (18efc <hci_driver_send+0x90>)
		BT_ERR("Empty HCI packet");
   18e78:	4821      	ldr	r0, [pc, #132]	; (18f00 <hci_driver_send+0x94>)
   18e7a:	1ac9      	subs	r1, r1, r3
   18e7c:	08c9      	lsrs	r1, r1, #3
   18e7e:	0189      	lsls	r1, r1, #6
   18e80:	f041 0101 	orr.w	r1, r1, #1
   18e84:	f00b f89e 	bl	23fc4 <log_0>
		return -EINVAL;
   18e88:	f06f 0415 	mvn.w	r4, #21
}
   18e8c:	4620      	mov	r0, r4
   18e8e:	b003      	add	sp, #12
   18e90:	bd30      	pop	{r4, r5, pc}
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
   18e92:	7d01      	ldrb	r1, [r0, #20]
	switch (type) {
   18e94:	b181      	cbz	r1, 18eb8 <hci_driver_send+0x4c>
   18e96:	2902      	cmp	r1, #2
   18e98:	d122      	bne.n	18ee0 <hci_driver_send+0x74>
	err = hci_acl_handle(buf, &evt);
   18e9a:	a901      	add	r1, sp, #4
   18e9c:	f000 fc74 	bl	19788 <hci_acl_handle>
   18ea0:	4604      	mov	r4, r0
	if (evt) {
   18ea2:	9801      	ldr	r0, [sp, #4]
   18ea4:	b108      	cbz	r0, 18eaa <hci_driver_send+0x3e>
		bt_recv_prio(evt);
   18ea6:	f7ee fcb5 	bl	7814 <bt_recv_prio>
	if (!err) {
   18eaa:	2c00      	cmp	r4, #0
   18eac:	d1ee      	bne.n	18e8c <hci_driver_send+0x20>
		net_buf_unref(buf);
   18eae:	4628      	mov	r0, r5
   18eb0:	f006 f90a 	bl	1f0c8 <net_buf_unref>
   18eb4:	2400      	movs	r4, #0
   18eb6:	e7e9      	b.n	18e8c <hci_driver_send+0x20>
	struct node_rx_pdu *node_rx = NULL;
   18eb8:	9101      	str	r1, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
   18eba:	a901      	add	r1, sp, #4
   18ebc:	f000 fa00 	bl	192c0 <hci_cmd_handle>
	if (evt) {
   18ec0:	2800      	cmp	r0, #0
   18ec2:	d0f4      	beq.n	18eae <hci_driver_send+0x42>
		bt_recv_prio(evt);
   18ec4:	f7ee fca6 	bl	7814 <bt_recv_prio>
		if (node_rx) {
   18ec8:	9c01      	ldr	r4, [sp, #4]
   18eca:	2c00      	cmp	r4, #0
   18ecc:	d0ef      	beq.n	18eae <hci_driver_send+0x42>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   18ece:	4620      	mov	r0, r4
   18ed0:	f000 fe86 	bl	19be0 <hci_get_class>
   18ed4:	7160      	strb	r0, [r4, #5]
			k_fifo_put(&recv_fifo, node_rx);
   18ed6:	9901      	ldr	r1, [sp, #4]
   18ed8:	480a      	ldr	r0, [pc, #40]	; (18f04 <hci_driver_send+0x98>)
   18eda:	f010 f9ba 	bl	29252 <k_queue_append>
	if (!err) {
   18ede:	e7e6      	b.n	18eae <hci_driver_send+0x42>
   18ee0:	4b06      	ldr	r3, [pc, #24]	; (18efc <hci_driver_send+0x90>)
   18ee2:	4a05      	ldr	r2, [pc, #20]	; (18ef8 <hci_driver_send+0x8c>)
		BT_ERR("Unknown HCI type %u", type);
   18ee4:	4808      	ldr	r0, [pc, #32]	; (18f08 <hci_driver_send+0x9c>)
   18ee6:	1ad2      	subs	r2, r2, r3
   18ee8:	08d2      	lsrs	r2, r2, #3
   18eea:	0192      	lsls	r2, r2, #6
   18eec:	f042 0201 	orr.w	r2, r2, #1
   18ef0:	f00b f875 	bl	23fde <log_1>
   18ef4:	e7c8      	b.n	18e88 <hci_driver_send+0x1c>
   18ef6:	bf00      	nop
   18ef8:	00029878 	.word	0x00029878
   18efc:	00029830 	.word	0x00029830
   18f00:	000301ca 	.word	0x000301ca
   18f04:	2000765c 	.word	0x2000765c
   18f08:	000301db 	.word	0x000301db

00018f0c <recv_thread>:
{
   18f0c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_queue_get(queue, timeout);
   18f0e:	4d27      	ldr	r5, [pc, #156]	; (18fac <recv_thread+0xa0>)
		LL_ASSERT(0);
   18f10:	4e27      	ldr	r6, [pc, #156]	; (18fb0 <recv_thread+0xa4>)
   18f12:	4f28      	ldr	r7, [pc, #160]	; (18fb4 <recv_thread+0xa8>)
   18f14:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   18f18:	4628      	mov	r0, r5
   18f1a:	f008 f8a3 	bl	21064 <z_impl_k_queue_get>
		if (node_rx && !buf) {
   18f1e:	b1e8      	cbz	r0, 18f5c <recv_thread+0x50>
	u8_t class = node_rx->hdr.user_meta;
   18f20:	7943      	ldrb	r3, [r0, #5]
	buf = encode_node(node_rx, class);
   18f22:	9001      	str	r0, [sp, #4]
	switch (class) {
   18f24:	2b04      	cmp	r3, #4
   18f26:	d81c      	bhi.n	18f62 <recv_thread+0x56>
   18f28:	b1eb      	cbz	r3, 18f66 <recv_thread+0x5a>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
   18f2a:	2b02      	cmp	r3, #2
   18f2c:	d129      	bne.n	18f82 <recv_thread+0x76>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
   18f2e:	2200      	movs	r2, #0
   18f30:	2101      	movs	r1, #1
   18f32:	4610      	mov	r0, r2
   18f34:	f7ef fd68 	bl	8a08 <bt_buf_get_evt>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   18f38:	4604      	mov	r4, r0
		if (buf) {
   18f3a:	b118      	cbz	r0, 18f44 <recv_thread+0x38>
			hci_evt_encode(node_rx, buf);
   18f3c:	4601      	mov	r1, r0
   18f3e:	9801      	ldr	r0, [sp, #4]
   18f40:	f000 fcee 	bl	19920 <hci_evt_encode>
	node_rx->hdr.next = NULL;
   18f44:	9b01      	ldr	r3, [sp, #4]
   18f46:	2200      	movs	r2, #0
   18f48:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
   18f4a:	a801      	add	r0, sp, #4
   18f4c:	f001 fa2c 	bl	1a3a8 <ll_rx_mem_release>
		if (buf) {
   18f50:	b124      	cbz	r4, 18f5c <recv_thread+0x50>
			if (buf->len) {
   18f52:	89a3      	ldrh	r3, [r4, #12]
				bt_recv(buf);
   18f54:	4620      	mov	r0, r4
			if (buf->len) {
   18f56:	b32b      	cbz	r3, 18fa4 <recv_thread+0x98>
				bt_recv(buf);
   18f58:	f7ee fbb2 	bl	76c0 <bt_recv>
	z_impl_k_yield();
   18f5c:	f009 fa22 	bl	223a4 <z_impl_k_yield>
}
   18f60:	e7d8      	b.n	18f14 <recv_thread+0x8>
	switch (class) {
   18f62:	2b05      	cmp	r3, #5
   18f64:	d013      	beq.n	18f8e <recv_thread+0x82>
		LL_ASSERT(0);
   18f66:	4814      	ldr	r0, [pc, #80]	; (18fb8 <recv_thread+0xac>)
   18f68:	23c3      	movs	r3, #195	; 0xc3
   18f6a:	4632      	mov	r2, r6
   18f6c:	4639      	mov	r1, r7
   18f6e:	f00a ffb8 	bl	23ee2 <printk>
   18f72:	4040      	eors	r0, r0
   18f74:	f380 8811 	msr	BASEPRI, r0
   18f78:	f04f 0003 	mov.w	r0, #3
   18f7c:	df02      	svc	2
	struct net_buf *buf = NULL;
   18f7e:	2400      	movs	r4, #0
		break;
   18f80:	e7e0      	b.n	18f44 <recv_thread+0x38>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   18f82:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   18f86:	2001      	movs	r0, #1
   18f88:	f7ef fcea 	bl	8960 <bt_buf_get_rx>
   18f8c:	e7d4      	b.n	18f38 <recv_thread+0x2c>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
   18f8e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   18f92:	2003      	movs	r0, #3
   18f94:	f7ef fce4 	bl	8960 <bt_buf_get_rx>
   18f98:	4604      	mov	r4, r0
		hci_acl_encode(node_rx, buf);
   18f9a:	4601      	mov	r1, r0
   18f9c:	9801      	ldr	r0, [sp, #4]
   18f9e:	f000 fc81 	bl	198a4 <hci_acl_encode>
		break;
   18fa2:	e7cf      	b.n	18f44 <recv_thread+0x38>
				net_buf_unref(buf);
   18fa4:	f006 f890 	bl	1f0c8 <net_buf_unref>
   18fa8:	e7d8      	b.n	18f5c <recv_thread+0x50>
   18faa:	bf00      	nop
   18fac:	2000765c 	.word	0x2000765c
   18fb0:	000301ef 	.word	0x000301ef
   18fb4:	0002e3c9 	.word	0x0002e3c9
   18fb8:	0002a5e8 	.word	0x0002a5e8

00018fbc <prio_recv_thread>:
{
   18fbc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_sem_take(sem, timeout);
   18fbe:	4e17      	ldr	r6, [pc, #92]	; (1901c <prio_recv_thread+0x60>)
				k_fifo_put(&recv_fifo, node_rx);
   18fc0:	4f17      	ldr	r7, [pc, #92]	; (19020 <prio_recv_thread+0x64>)
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
   18fc2:	f10d 0102 	add.w	r1, sp, #2
   18fc6:	a801      	add	r0, sp, #4
   18fc8:	f001 f8ea 	bl	1a1a0 <ll_rx_get>
   18fcc:	4604      	mov	r4, r0
   18fce:	b968      	cbnz	r0, 18fec <prio_recv_thread+0x30>
		if (node_rx) {
   18fd0:	9b01      	ldr	r3, [sp, #4]
   18fd2:	b1eb      	cbz	r3, 19010 <prio_recv_thread+0x54>
			ll_rx_dequeue();
   18fd4:	f001 f93c 	bl	1a250 <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   18fd8:	9c01      	ldr	r4, [sp, #4]
   18fda:	4620      	mov	r0, r4
   18fdc:	f000 fe00 	bl	19be0 <hci_get_class>
				k_fifo_put(&recv_fifo, node_rx);
   18fe0:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   18fe2:	7160      	strb	r0, [r4, #5]
				k_fifo_put(&recv_fifo, node_rx);
   18fe4:	4638      	mov	r0, r7
   18fe6:	f010 f934 	bl	29252 <k_queue_append>
			continue;
   18fea:	e7ea      	b.n	18fc2 <prio_recv_thread+0x6>
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   18fec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18ff0:	2100      	movs	r1, #0
   18ff2:	2013      	movs	r0, #19
   18ff4:	f7ef fd08 	bl	8a08 <bt_buf_get_evt>
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   18ff8:	f8bd 1002 	ldrh.w	r1, [sp, #2]
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   18ffc:	4605      	mov	r5, r0
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   18ffe:	4622      	mov	r2, r4
   19000:	f00f f9b3 	bl	2836a <hci_num_cmplt_encode>
			bt_recv_prio(buf);
   19004:	4628      	mov	r0, r5
   19006:	f7ee fc05 	bl	7814 <bt_recv_prio>
	z_impl_k_yield();
   1900a:	f009 f9cb 	bl	223a4 <z_impl_k_yield>
}
   1900e:	e7d8      	b.n	18fc2 <prio_recv_thread+0x6>
	return z_impl_k_sem_take(sem, timeout);
   19010:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19014:	4630      	mov	r0, r6
   19016:	f009 fb8f 	bl	22738 <z_impl_k_sem_take>
		BT_DBG("sem taken");
   1901a:	e7d2      	b.n	18fc2 <prio_recv_thread+0x6>
   1901c:	200075e0 	.word	0x200075e0
   19020:	2000765c 	.word	0x2000765c

00019024 <hci_driver_open>:
{
   19024:	b510      	push	{r4, lr}
	err = ll_init(&sem_prio_recv);
   19026:	481e      	ldr	r0, [pc, #120]	; (190a0 <hci_driver_open+0x7c>)
{
   19028:	b086      	sub	sp, #24
	err = ll_init(&sem_prio_recv);
   1902a:	f000 ffcf 	bl	19fcc <ll_init>
	if (err) {
   1902e:	4604      	mov	r4, r0
   19030:	b168      	cbz	r0, 1904e <hci_driver_open+0x2a>
   19032:	4a1c      	ldr	r2, [pc, #112]	; (190a4 <hci_driver_open+0x80>)
   19034:	4b1c      	ldr	r3, [pc, #112]	; (190a8 <hci_driver_open+0x84>)
   19036:	1ad2      	subs	r2, r2, r3
   19038:	08d2      	lsrs	r2, r2, #3
		BT_ERR("LL initialization failed: %u", err);
   1903a:	0192      	lsls	r2, r2, #6
   1903c:	4601      	mov	r1, r0
   1903e:	f042 0201 	orr.w	r2, r2, #1
   19042:	481a      	ldr	r0, [pc, #104]	; (190ac <hci_driver_open+0x88>)
   19044:	f00a ffcb 	bl	23fde <log_1>
}
   19048:	4620      	mov	r0, r4
   1904a:	b006      	add	sp, #24
   1904c:	bd10      	pop	{r4, pc}
	hci_init(NULL);
   1904e:	f000 fddf 	bl	19c10 <hci_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   19052:	f06f 0309 	mvn.w	r3, #9
   19056:	e9cd 4302 	strd	r4, r3, [sp, #8]
   1905a:	e9cd 4404 	strd	r4, r4, [sp, #16]
   1905e:	e9cd 4400 	strd	r4, r4, [sp]
   19062:	4b13      	ldr	r3, [pc, #76]	; (190b0 <hci_driver_open+0x8c>)
   19064:	4913      	ldr	r1, [pc, #76]	; (190b4 <hci_driver_open+0x90>)
   19066:	4814      	ldr	r0, [pc, #80]	; (190b8 <hci_driver_open+0x94>)
   19068:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
   1906c:	f009 fc3a 	bl	228e4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   19070:	4912      	ldr	r1, [pc, #72]	; (190bc <hci_driver_open+0x98>)
   19072:	4811      	ldr	r0, [pc, #68]	; (190b8 <hci_driver_open+0x94>)
   19074:	f009 fbfc 	bl	22870 <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   19078:	f06f 0307 	mvn.w	r3, #7
   1907c:	e9cd 4302 	strd	r4, r3, [sp, #8]
   19080:	e9cd 4404 	strd	r4, r4, [sp, #16]
   19084:	e9cd 4400 	strd	r4, r4, [sp]
   19088:	4b0d      	ldr	r3, [pc, #52]	; (190c0 <hci_driver_open+0x9c>)
   1908a:	490e      	ldr	r1, [pc, #56]	; (190c4 <hci_driver_open+0xa0>)
   1908c:	480e      	ldr	r0, [pc, #56]	; (190c8 <hci_driver_open+0xa4>)
   1908e:	f44f 6200 	mov.w	r2, #2048	; 0x800
   19092:	f009 fc27 	bl	228e4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   19096:	490d      	ldr	r1, [pc, #52]	; (190cc <hci_driver_open+0xa8>)
   19098:	480b      	ldr	r0, [pc, #44]	; (190c8 <hci_driver_open+0xa4>)
   1909a:	f009 fbe9 	bl	22870 <z_impl_k_thread_name_set>
	return 0;
   1909e:	e7d3      	b.n	19048 <hci_driver_open+0x24>
   190a0:	200075e0 	.word	0x200075e0
   190a4:	00029878 	.word	0x00029878
   190a8:	00029830 	.word	0x00029830
   190ac:	0003022f 	.word	0x0003022f
   190b0:	00018fbd 	.word	0x00018fbd
   190b4:	20003240 	.word	0x20003240
   190b8:	20000e34 	.word	0x20000e34
   190bc:	0003024c 	.word	0x0003024c
   190c0:	00018f0d 	.word	0x00018f0d
   190c4:	20003420 	.word	0x20003420
   190c8:	20000ec8 	.word	0x20000ec8
   190cc:	00030256 	.word	0x00030256

000190d0 <cmd_status>:
	return net_buf_add(*buf, plen);
}

#if defined(CONFIG_BT_CONN)
static struct net_buf *cmd_status(u8_t status)
{
   190d0:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_cmd_status *cs;
	struct net_buf *buf;

	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   190d2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   190d6:	4605      	mov	r5, r0
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   190d8:	2100      	movs	r1, #0
   190da:	200f      	movs	r0, #15
   190dc:	f7ef fc94 	bl	8a08 <bt_buf_get_evt>
	hci_evt_create(buf, BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   190e0:	2204      	movs	r2, #4
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   190e2:	4604      	mov	r4, r0
	hci_evt_create(buf, BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   190e4:	210f      	movs	r1, #15
   190e6:	f00f f921 	bl	2832c <hci_evt_create>

	cs = net_buf_add(buf, sizeof(*cs));
   190ea:	2104      	movs	r1, #4
   190ec:	f104 0008 	add.w	r0, r4, #8
   190f0:	f006 f8f2 	bl	1f2d8 <net_buf_simple_add>
	cs->status = status;
	cs->ncmd = 1U;
   190f4:	2301      	movs	r3, #1
   190f6:	7043      	strb	r3, [r0, #1]
	cs->opcode = sys_cpu_to_le16(_opcode);
   190f8:	4b02      	ldr	r3, [pc, #8]	; (19104 <cmd_status+0x34>)
	cs->status = status;
   190fa:	7005      	strb	r5, [r0, #0]
	cs->opcode = sys_cpu_to_le16(_opcode);
   190fc:	881b      	ldrh	r3, [r3, #0]
   190fe:	8043      	strh	r3, [r0, #2]

	return buf;
}
   19100:	4620      	mov	r0, r4
   19102:	bd38      	pop	{r3, r4, r5, pc}
   19104:	20001f2c 	.word	0x20001f2c

00019108 <le_remote_feat_complete>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void le_remote_feat_complete(u8_t status, struct pdu_data *pdu_data,
				    u16_t handle, struct net_buf *buf)
{
   19108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1910a:	4604      	mov	r4, r0
   1910c:	4618      	mov	r0, r3
	struct bt_hci_evt_le_remote_feat_complete *sep;

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1910e:	4b13      	ldr	r3, [pc, #76]	; (1915c <le_remote_feat_complete+0x54>)
{
   19110:	460e      	mov	r6, r1
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   19112:	6859      	ldr	r1, [r3, #4]
   19114:	2500      	movs	r5, #0
{
   19116:	4617      	mov	r7, r2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   19118:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
   1911c:	462a      	mov	r2, r5
   1911e:	4313      	orrs	r3, r2
   19120:	d01a      	beq.n	19158 <le_remote_feat_complete+0x50>
	    !(le_event_mask & BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE)) {
   19122:	4b0f      	ldr	r3, [pc, #60]	; (19160 <le_remote_feat_complete+0x58>)
   19124:	6819      	ldr	r1, [r3, #0]
   19126:	462b      	mov	r3, r5
   19128:	f001 0208 	and.w	r2, r1, #8
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1912c:	4313      	orrs	r3, r2
   1912e:	d013      	beq.n	19158 <le_remote_feat_complete+0x50>
		return;
	}

	sep = meta_evt(buf, BT_HCI_EV_LE_REMOTE_FEAT_COMPLETE, sizeof(*sep));
   19130:	220b      	movs	r2, #11
   19132:	2104      	movs	r1, #4
   19134:	f00f f904 	bl	28340 <meta_evt>

	sep->status = status;
	sep->handle = sys_cpu_to_le16(handle);
	if (!status) {
		memcpy(&sep->features[0],
   19138:	2208      	movs	r2, #8
	sep->status = status;
   1913a:	7004      	strb	r4, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
   1913c:	f8a0 7001 	strh.w	r7, [r0, #1]
	if (!status) {
   19140:	3003      	adds	r0, #3
   19142:	b924      	cbnz	r4, 1914e <le_remote_feat_complete+0x46>
		memcpy(&sep->features[0],
   19144:	1d31      	adds	r1, r6, #4
		       &pdu_data->llctrl.feature_rsp.features[0],
		       sizeof(sep->features));
	} else {
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
	}
}
   19146:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		memcpy(&sep->features[0],
   1914a:	f00c bdad 	b.w	25ca8 <memcpy>
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
   1914e:	4629      	mov	r1, r5
}
   19150:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
   19154:	f00c bdd3 	b.w	25cfe <memset>
}
   19158:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1915a:	bf00      	nop
   1915c:	200069f0 	.word	0x200069f0
   19160:	200069f8 	.word	0x200069f8

00019164 <hci_cmd_complete>:
{
   19164:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
   19166:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   1916a:	4604      	mov	r4, r0
   1916c:	460d      	mov	r5, r1
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
   1916e:	200e      	movs	r0, #14
   19170:	2100      	movs	r1, #0
   19172:	f7ef fc49 	bl	8a08 <bt_buf_get_evt>
	hci_evt_create(*buf, BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   19176:	1cea      	adds	r2, r5, #3
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
   19178:	6020      	str	r0, [r4, #0]
	hci_evt_create(*buf, BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   1917a:	b2d2      	uxtb	r2, r2
   1917c:	210e      	movs	r1, #14
   1917e:	f00f f8d5 	bl	2832c <hci_evt_create>
	cc = net_buf_add(*buf, sizeof(*cc));
   19182:	6820      	ldr	r0, [r4, #0]
   19184:	2103      	movs	r1, #3
   19186:	3008      	adds	r0, #8
   19188:	f006 f8a6 	bl	1f2d8 <net_buf_simple_add>
	cc->ncmd = 1U;
   1918c:	2301      	movs	r3, #1
   1918e:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(_opcode);
   19190:	4b05      	ldr	r3, [pc, #20]	; (191a8 <hci_cmd_complete+0x44>)
   19192:	881b      	ldrh	r3, [r3, #0]
   19194:	f8a0 3001 	strh.w	r3, [r0, #1]
	return net_buf_add(*buf, plen);
   19198:	6820      	ldr	r0, [r4, #0]
   1919a:	4629      	mov	r1, r5
   1919c:	3008      	adds	r0, #8
}
   1919e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return net_buf_add(*buf, plen);
   191a2:	f006 b899 	b.w	1f2d8 <net_buf_simple_add>
   191a6:	bf00      	nop
   191a8:	20001f2c 	.word	0x20001f2c

000191ac <hci_vendor_cmd_handle_common>:
{
   191ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   191ae:	3801      	subs	r0, #1
   191b0:	b087      	sub	sp, #28
   191b2:	4614      	mov	r4, r2
   191b4:	2809      	cmp	r0, #9
   191b6:	d87e      	bhi.n	192b6 <hci_vendor_cmd_handle_common+0x10a>
   191b8:	e8df f000 	tbb	[pc, r0]
   191bc:	7d321b05 	.word	0x7d321b05
   191c0:	3e7d597d 	.word	0x3e7d597d
   191c4:	7164      	.short	0x7164
	rp = hci_cmd_complete(evt, sizeof(*rp));
   191c6:	210d      	movs	r1, #13
   191c8:	4610      	mov	r0, r2
   191ca:	f7ff ffcb 	bl	19164 <hci_cmd_complete>
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   191ce:	2302      	movs	r3, #2
	rp->status = 0x00;
   191d0:	2100      	movs	r1, #0
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   191d2:	7043      	strb	r3, [r0, #1]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
   191d4:	70c3      	strb	r3, [r0, #3]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
   191d6:	7183      	strb	r3, [r0, #6]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   191d8:	71c3      	strb	r3, [r0, #7]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
   191da:	2363      	movs	r3, #99	; 0x63
	rp->status = 0x00;
   191dc:	7001      	strb	r1, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   191de:	7081      	strb	r1, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
   191e0:	7101      	strb	r1, [r0, #4]
	rp->fw_variant = 0U;
   191e2:	7141      	strb	r1, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   191e4:	7201      	strb	r1, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
   191e6:	7243      	strb	r3, [r0, #9]
   191e8:	7281      	strb	r1, [r0, #10]
   191ea:	72c1      	strb	r1, [r0, #11]
   191ec:	7301      	strb	r1, [r0, #12]
	return 0;
   191ee:	460c      	mov	r4, r1
}
   191f0:	e013      	b.n	1921a <hci_vendor_cmd_handle_common+0x6e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   191f2:	2141      	movs	r1, #65	; 0x41
   191f4:	4610      	mov	r0, r2
   191f6:	f7ff ffb5 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   191fa:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   191fc:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   191fe:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   19200:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   19204:	4621      	mov	r1, r4
   19206:	f00c fd7a 	bl	25cfe <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
   1920a:	786b      	ldrb	r3, [r5, #1]
   1920c:	f063 0358 	orn	r3, r3, #88	; 0x58
   19210:	706b      	strb	r3, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
   19212:	78ab      	ldrb	r3, [r5, #2]
   19214:	f043 0303 	orr.w	r3, r3, #3
   19218:	70ab      	strb	r3, [r5, #2]
}
   1921a:	4620      	mov	r0, r4
   1921c:	b007      	add	sp, #28
   1921e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19220:	2109      	movs	r1, #9
   19222:	4610      	mov	r0, r2
   19224:	f7ff ff9e 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   19228:	2400      	movs	r4, #0
   1922a:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1922e:	2208      	movs	r2, #8
   19230:	4621      	mov	r1, r4
   19232:	f00c fd64 	bl	25cfe <memset>
}
   19236:	e7f0      	b.n	1921a <hci_vendor_cmd_handle_common+0x6e>
	const char build_info[] = HCI_VS_BUILD_INFO;
   19238:	4b20      	ldr	r3, [pc, #128]	; (192bc <hci_vendor_cmd_handle_common+0x110>)
   1923a:	aa01      	add	r2, sp, #4
   1923c:	f103 0710 	add.w	r7, r3, #16
   19240:	4616      	mov	r6, r2
   19242:	6818      	ldr	r0, [r3, #0]
   19244:	6859      	ldr	r1, [r3, #4]
   19246:	4615      	mov	r5, r2
   19248:	c503      	stmia	r5!, {r0, r1}
   1924a:	3308      	adds	r3, #8
   1924c:	42bb      	cmp	r3, r7
   1924e:	462a      	mov	r2, r5
   19250:	d1f7      	bne.n	19242 <hci_vendor_cmd_handle_common+0x96>
   19252:	881b      	ldrh	r3, [r3, #0]
   19254:	802b      	strh	r3, [r5, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
   19256:	2113      	movs	r1, #19
   19258:	4620      	mov	r0, r4
   1925a:	f7ff ff83 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   1925e:	2400      	movs	r4, #0
   19260:	f800 4b01 	strb.w	r4, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
   19264:	2212      	movs	r2, #18
   19266:	4631      	mov	r1, r6
   19268:	f00c fd1e 	bl	25ca8 <memcpy>
}
   1926c:	e7d5      	b.n	1921a <hci_vendor_cmd_handle_common+0x6e>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
   1926e:	6889      	ldr	r1, [r1, #8]
   19270:	2000      	movs	r0, #0
   19272:	f7ff fdd7 	bl	18e24 <ll_addr_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   19276:	2101      	movs	r1, #1
   19278:	4620      	mov	r0, r4
   1927a:	f7ff ff73 	bl	19164 <hci_cmd_complete>
	ccst->status = 0x00;
   1927e:	2100      	movs	r1, #0
   19280:	7001      	strb	r1, [r0, #0]
   19282:	e7b4      	b.n	191ee <hci_vendor_cmd_handle_common+0x42>
	rp = hci_cmd_complete(evt, sizeof(*rp) +
   19284:	2118      	movs	r1, #24
   19286:	4610      	mov	r0, r2
   19288:	f7ff ff6c 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   1928c:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp) +
   1928e:	4605      	mov	r5, r0
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
   19290:	2101      	movs	r1, #1
	rp->status = 0x00;
   19292:	f800 4b02 	strb.w	r4, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
   19296:	f00f fc95 	bl	28bc4 <hci_vendor_read_static_addr>
   1929a:	7068      	strb	r0, [r5, #1]
}
   1929c:	e7bd      	b.n	1921a <hci_vendor_cmd_handle_common+0x6e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1929e:	2121      	movs	r1, #33	; 0x21
   192a0:	4610      	mov	r0, r2
   192a2:	f7ff ff5f 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   192a6:	4601      	mov	r1, r0
   192a8:	2400      	movs	r4, #0
   192aa:	f801 4b11 	strb.w	r4, [r1], #17
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
   192ae:	3001      	adds	r0, #1
   192b0:	f00f fcde 	bl	28c70 <hci_vendor_read_key_hierarchy_roots>
}
   192b4:	e7b1      	b.n	1921a <hci_vendor_cmd_handle_common+0x6e>
	return 0;
   192b6:	f06f 0415 	mvn.w	r4, #21
   192ba:	e7ae      	b.n	1921a <hci_vendor_cmd_handle_common+0x6e>
   192bc:	0003027a 	.word	0x0003027a

000192c0 <hci_cmd_handle>:
{
   192c0:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (cmd->len < sizeof(*chdr)) {
   192c2:	8983      	ldrh	r3, [r0, #12]
{
   192c4:	b08b      	sub	sp, #44	; 0x2c
	struct net_buf *evt = NULL;
   192c6:	2500      	movs	r5, #0
	if (cmd->len < sizeof(*chdr)) {
   192c8:	2b02      	cmp	r3, #2
{
   192ca:	4604      	mov	r4, r0
	struct net_buf *evt = NULL;
   192cc:	9505      	str	r5, [sp, #20]
	if (cmd->len < sizeof(*chdr)) {
   192ce:	d80c      	bhi.n	192ea <hci_cmd_handle+0x2a>
   192d0:	49c8      	ldr	r1, [pc, #800]	; (195f4 <hci_cmd_handle+0x334>)
   192d2:	4bc9      	ldr	r3, [pc, #804]	; (195f8 <hci_cmd_handle+0x338>)
		BT_ERR("No HCI Command header");
   192d4:	48c9      	ldr	r0, [pc, #804]	; (195fc <hci_cmd_handle+0x33c>)
   192d6:	1ac9      	subs	r1, r1, r3
   192d8:	08c9      	lsrs	r1, r1, #3
   192da:	0189      	lsls	r1, r1, #6
   192dc:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Invalid HCI CMD packet length");
   192e0:	f00a fe70 	bl	23fc4 <log_0>
		return NULL;
   192e4:	4628      	mov	r0, r5
}
   192e6:	b00b      	add	sp, #44	; 0x2c
   192e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
   192ea:	2103      	movs	r1, #3
   192ec:	3008      	adds	r0, #8
   192ee:	f005 ffd1 	bl	1f294 <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
   192f2:	89a2      	ldrh	r2, [r4, #12]
   192f4:	7883      	ldrb	r3, [r0, #2]
   192f6:	429a      	cmp	r2, r3
   192f8:	d208      	bcs.n	1930c <hci_cmd_handle+0x4c>
   192fa:	49be      	ldr	r1, [pc, #760]	; (195f4 <hci_cmd_handle+0x334>)
   192fc:	4bbe      	ldr	r3, [pc, #760]	; (195f8 <hci_cmd_handle+0x338>)
		BT_ERR("Invalid HCI CMD packet length");
   192fe:	48c0      	ldr	r0, [pc, #768]	; (19600 <hci_cmd_handle+0x340>)
   19300:	1ac9      	subs	r1, r1, r3
   19302:	08c9      	lsrs	r1, r1, #3
   19304:	0189      	lsls	r1, r1, #6
   19306:	f041 0101 	orr.w	r1, r1, #1
   1930a:	e7e9      	b.n	192e0 <hci_cmd_handle+0x20>
	_opcode = sys_le16_to_cpu(chdr->opcode);
   1930c:	8802      	ldrh	r2, [r0, #0]
   1930e:	4bbd      	ldr	r3, [pc, #756]	; (19604 <hci_cmd_handle+0x344>)
	switch (BT_OGF(_opcode)) {
   19310:	f5b2 5f10 	cmp.w	r2, #9216	; 0x2400
	_opcode = sys_le16_to_cpu(chdr->opcode);
   19314:	801a      	strh	r2, [r3, #0]
	ocf = BT_OCF(_opcode);
   19316:	f3c2 0509 	ubfx	r5, r2, #0, #10
	switch (BT_OGF(_opcode)) {
   1931a:	ea4f 2392 	mov.w	r3, r2, lsr #10
   1931e:	d20d      	bcs.n	1933c <hci_cmd_handle+0x7c>
   19320:	b17b      	cbz	r3, 19342 <hci_cmd_handle+0x82>
   19322:	3b01      	subs	r3, #1
   19324:	2b07      	cmp	r3, #7
   19326:	d80c      	bhi.n	19342 <hci_cmd_handle+0x82>
   19328:	e8df f013 	tbh	[pc, r3, lsl #1]
   1932c:	000b0011 	.word	0x000b0011
   19330:	005d0024 	.word	0x005d0024
   19334:	000b000b 	.word	0x000b000b
   19338:	00e4000b 	.word	0x00e4000b
   1933c:	2b3f      	cmp	r3, #63	; 0x3f
   1933e:	f000 821a 	beq.w	19776 <hci_cmd_handle+0x4b6>
		ccst = hci_cmd_complete(&evt, sizeof(*ccst));
   19342:	2101      	movs	r1, #1
   19344:	a805      	add	r0, sp, #20
   19346:	f7ff ff0d 	bl	19164 <hci_cmd_complete>
		ccst->status = BT_HCI_ERR_UNKNOWN_CMD;
   1934a:	2301      	movs	r3, #1
   1934c:	e02f      	b.n	193ae <hci_cmd_handle+0xee>
	switch (ocf) {
   1934e:	2d06      	cmp	r5, #6
   19350:	d006      	beq.n	19360 <hci_cmd_handle+0xa0>
   19352:	2d1d      	cmp	r5, #29
   19354:	d1f5      	bne.n	19342 <hci_cmd_handle+0x82>
	handle = sys_le16_to_cpu(cmd->handle);
   19356:	68a3      	ldr	r3, [r4, #8]
	status = ll_version_ind_send(handle);
   19358:	8818      	ldrh	r0, [r3, #0]
   1935a:	f00f f9f0 	bl	2873e <ll_version_ind_send>
   1935e:	e004      	b.n	1936a <hci_cmd_handle+0xaa>
		disconnect(cmd, evt);
   19360:	68a3      	ldr	r3, [r4, #8]
	status = ll_terminate_ind_send(handle, cmd->reason);
   19362:	7899      	ldrb	r1, [r3, #2]
   19364:	8818      	ldrh	r0, [r3, #0]
   19366:	f00f f9c9 	bl	286fc <ll_terminate_ind_send>
	*evt = cmd_status(status);
   1936a:	f7ff feb1 	bl	190d0 <cmd_status>
   1936e:	9005      	str	r0, [sp, #20]
	return evt;
   19370:	9805      	ldr	r0, [sp, #20]
   19372:	e7b8      	b.n	192e6 <hci_cmd_handle+0x26>
	switch (ocf) {
   19374:	2d2d      	cmp	r5, #45	; 0x2d
   19376:	d023      	beq.n	193c0 <hci_cmd_handle+0x100>
   19378:	d812      	bhi.n	193a0 <hci_cmd_handle+0xe0>
   1937a:	2d01      	cmp	r5, #1
   1937c:	d019      	beq.n	193b2 <hci_cmd_handle+0xf2>
   1937e:	2d03      	cmp	r5, #3
   19380:	d1df      	bne.n	19342 <hci_cmd_handle+0x82>
	event_mask = DEFAULT_EVENT_MASK;
   19382:	4ba1      	ldr	r3, [pc, #644]	; (19608 <hci_cmd_handle+0x348>)
   19384:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   19388:	f641 71ff 	movw	r1, #8191	; 0x1fff
   1938c:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   19390:	4b9e      	ldr	r3, [pc, #632]	; (1960c <hci_cmd_handle+0x34c>)
   19392:	201f      	movs	r0, #31
   19394:	2100      	movs	r1, #0
   19396:	e9c3 0100 	strd	r0, r1, [r3]
		ll_reset();
   1939a:	f000 fe7d 	bl	1a098 <ll_reset>
   1939e:	e001      	b.n	193a4 <hci_cmd_handle+0xe4>
	switch (ocf) {
   193a0:	2d63      	cmp	r5, #99	; 0x63
   193a2:	d1ce      	bne.n	19342 <hci_cmd_handle+0x82>
		ccst = hci_cmd_complete(evt, sizeof(*ccst));
   193a4:	2101      	movs	r1, #1
   193a6:	a805      	add	r0, sp, #20
   193a8:	f7ff fedc 	bl	19164 <hci_cmd_complete>
		ccst->status = 0x00;
   193ac:	2300      	movs	r3, #0
		ccst->status = BT_HCI_ERR_UNKNOWN_CMD;
   193ae:	7003      	strb	r3, [r0, #0]
   193b0:	e7de      	b.n	19370 <hci_cmd_handle+0xb0>
	event_mask = sys_get_le64(cmd->events);
   193b2:	68a0      	ldr	r0, [r4, #8]
   193b4:	f00e ffb6 	bl	28324 <sys_get_le64>
   193b8:	4b93      	ldr	r3, [pc, #588]	; (19608 <hci_cmd_handle+0x348>)
	le_event_mask = sys_get_le64(cmd->events);
   193ba:	e9c3 0100 	strd	r0, r1, [r3]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   193be:	e7f1      	b.n	193a4 <hci_cmd_handle+0xe4>
		read_tx_power_level(cmd, evt);
   193c0:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   193c2:	2104      	movs	r1, #4
   193c4:	a805      	add	r0, sp, #20
	handle = sys_le16_to_cpu(cmd->handle);
   193c6:	881d      	ldrh	r5, [r3, #0]
	type = cmd->type;
   193c8:	789f      	ldrb	r7, [r3, #2]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   193ca:	f7ff fecb 	bl	19164 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   193ce:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   193d0:	4604      	mov	r4, r0
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
   193d2:	1cc3      	adds	r3, r0, #3
   193d4:	463a      	mov	r2, r7
   193d6:	4631      	mov	r1, r6
   193d8:	2002      	movs	r0, #2
   193da:	f00e ff90 	bl	282fe <ll_tx_pwr_lvl_get>
	rp->status = status;
   193de:	7020      	strb	r0, [r4, #0]
	rp->handle = sys_le16_to_cpu(handle);
   193e0:	f8a4 5001 	strh.w	r5, [r4, #1]
	if (err == -EINVAL) {
   193e4:	e7c4      	b.n	19370 <hci_cmd_handle+0xb0>
	switch (ocf) {
   193e6:	3d01      	subs	r5, #1
   193e8:	2d08      	cmp	r5, #8
   193ea:	d8aa      	bhi.n	19342 <hci_cmd_handle+0x82>
   193ec:	a301      	add	r3, pc, #4	; (adr r3, 193f4 <hci_cmd_handle+0x134>)
   193ee:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
   193f2:	bf00      	nop
   193f4:	00019419 	.word	0x00019419
   193f8:	00019443 	.word	0x00019443
   193fc:	000194c3 	.word	0x000194c3
   19400:	00019343 	.word	0x00019343
   19404:	00019343 	.word	0x00019343
   19408:	00019343 	.word	0x00019343
   1940c:	00019343 	.word	0x00019343
   19410:	00019343 	.word	0x00019343
   19414:	000194df 	.word	0x000194df
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19418:	2109      	movs	r1, #9
   1941a:	a805      	add	r0, sp, #20
   1941c:	f7ff fea2 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   19420:	2300      	movs	r3, #0
   19422:	7003      	strb	r3, [r0, #0]
	rp->hci_revision = sys_cpu_to_le16(0);
   19424:	7083      	strb	r3, [r0, #2]
   19426:	70c3      	strb	r3, [r0, #3]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   19428:	f06f 030e 	mvn.w	r3, #14
	rp->hci_version = LL_VERSION_NUMBER;
   1942c:	220a      	movs	r2, #10
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   1942e:	7143      	strb	r3, [r0, #5]
   19430:	2305      	movs	r3, #5
   19432:	7183      	strb	r3, [r0, #6]
	rp->hci_version = LL_VERSION_NUMBER;
   19434:	7042      	strb	r2, [r0, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
   19436:	7102      	strb	r2, [r0, #4]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
   19438:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	dst[0] = val;
   1943c:	71c3      	strb	r3, [r0, #7]
	dst[1] = val >> 8;
   1943e:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
   19440:	e796      	b.n	19370 <hci_cmd_handle+0xb0>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19442:	2141      	movs	r1, #65	; 0x41
   19444:	a805      	add	r0, sp, #20
   19446:	f7ff fe8d 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   1944a:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1944c:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   1944e:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   19450:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   19454:	f00c fc53 	bl	25cfe <memset>
	rp->commands[5] |= BIT(6) | BIT(7);
   19458:	79a3      	ldrb	r3, [r4, #6]
	rp->commands[25] |= BIT(0) | BIT(1) | BIT(2) | BIT(4);
   1945a:	7ea2      	ldrb	r2, [r4, #26]
	rp->commands[28] |= BIT(3);
   1945c:	7f61      	ldrb	r1, [r4, #29]
	rp->commands[5] |= BIT(6) | BIT(7);
   1945e:	f063 033f 	orn	r3, r3, #63	; 0x3f
   19462:	71a3      	strb	r3, [r4, #6]
	rp->commands[10] |= BIT(2);
   19464:	7ae3      	ldrb	r3, [r4, #11]
   19466:	f043 0304 	orr.w	r3, r3, #4
   1946a:	72e3      	strb	r3, [r4, #11]
	rp->commands[14] |= BIT(3) | BIT(5);
   1946c:	7be3      	ldrb	r3, [r4, #15]
   1946e:	f043 0328 	orr.w	r3, r3, #40	; 0x28
   19472:	73e3      	strb	r3, [r4, #15]
	rp->commands[15] |= BIT(1);
   19474:	7c23      	ldrb	r3, [r4, #16]
   19476:	f043 0302 	orr.w	r3, r3, #2
   1947a:	7423      	strb	r3, [r4, #16]
	rp->commands[22] |= BIT(2);
   1947c:	7de3      	ldrb	r3, [r4, #23]
   1947e:	f043 0304 	orr.w	r3, r3, #4
   19482:	75e3      	strb	r3, [r4, #23]
	rp->commands[27] |= BIT(6) | BIT(7);
   19484:	7f23      	ldrb	r3, [r4, #28]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   19486:	f062 0208 	orn	r2, r2, #8
	rp->commands[27] |= BIT(2) | BIT(4) | BIT(5);
   1948a:	f063 030b 	orn	r3, r3, #11
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   1948e:	76a2      	strb	r2, [r4, #26]
	rp->commands[27] |= BIT(2) | BIT(4) | BIT(5);
   19490:	7723      	strb	r3, [r4, #28]
	rp->commands[26] |= BIT(2) | BIT(3);
   19492:	7ee2      	ldrb	r2, [r4, #27]
	rp->commands[33] |= BIT(4) | BIT(5);
   19494:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
	rp->commands[26] |= BIT(2) | BIT(3);
   19498:	f042 020f 	orr.w	r2, r2, #15
	rp->commands[33] |= BIT(4) | BIT(5);
   1949c:	f043 0330 	orr.w	r3, r3, #48	; 0x30
	rp->commands[26] |= BIT(2) | BIT(3);
   194a0:	76e2      	strb	r2, [r4, #27]
	rp->commands[33] |= BIT(4) | BIT(5);
   194a2:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	rp->commands[0] |= BIT(5);
   194a6:	7862      	ldrb	r2, [r4, #1]
	rp->commands[38] |= BIT(7);
   194a8:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
	rp->commands[28] |= BIT(3);
   194ac:	f041 0108 	orr.w	r1, r1, #8
	rp->commands[0] |= BIT(5);
   194b0:	f042 0220 	orr.w	r2, r2, #32
	rp->commands[38] |= BIT(7);
   194b4:	f063 037f 	orn	r3, r3, #127	; 0x7f
	rp->commands[28] |= BIT(3);
   194b8:	7761      	strb	r1, [r4, #29]
	rp->commands[0] |= BIT(5);
   194ba:	7062      	strb	r2, [r4, #1]
	rp->commands[38] |= BIT(7);
   194bc:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
	if (err == -EINVAL) {
   194c0:	e756      	b.n	19370 <hci_cmd_handle+0xb0>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   194c2:	2109      	movs	r1, #9
   194c4:	a805      	add	r0, sp, #20
   194c6:	f7ff fe4d 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   194ca:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   194cc:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   194ce:	2208      	movs	r2, #8
	rp->status = 0x00;
   194d0:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   194d4:	f00c fc13 	bl	25cfe <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
   194d8:	2360      	movs	r3, #96	; 0x60
   194da:	7163      	strb	r3, [r4, #5]
	if (err == -EINVAL) {
   194dc:	e748      	b.n	19370 <hci_cmd_handle+0xb0>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   194de:	2107      	movs	r1, #7
   194e0:	a805      	add	r0, sp, #20
   194e2:	f7ff fe3f 	bl	19164 <hci_cmd_complete>
   194e6:	4601      	mov	r1, r0
	rp->status = 0x00;
   194e8:	2000      	movs	r0, #0
   194ea:	f801 0b01 	strb.w	r0, [r1], #1
	ll_addr_get(0, &rp->bdaddr.val[0]);
   194ee:	f7ff fc7f 	bl	18df0 <ll_addr_get>
	if (err == -EINVAL) {
   194f2:	e73d      	b.n	19370 <hci_cmd_handle+0xb0>
	switch (ocf) {
   194f4:	2d21      	cmp	r5, #33	; 0x21
   194f6:	d84b      	bhi.n	19590 <hci_cmd_handle+0x2d0>
   194f8:	2d00      	cmp	r5, #0
   194fa:	f43f af22 	beq.w	19342 <hci_cmd_handle+0x82>
   194fe:	3d01      	subs	r5, #1
   19500:	2d20      	cmp	r5, #32
   19502:	f63f af1e 	bhi.w	19342 <hci_cmd_handle+0x82>
   19506:	a301      	add	r3, pc, #4	; (adr r3, 1950c <hci_cmd_handle+0x24c>)
   19508:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
   1950c:	000195af 	.word	0x000195af
   19510:	000195b9 	.word	0x000195b9
   19514:	000195d1 	.word	0x000195d1
   19518:	00019343 	.word	0x00019343
   1951c:	00019611 	.word	0x00019611
   19520:	00019689 	.word	0x00019689
   19524:	000196a5 	.word	0x000196a5
   19528:	000196b5 	.word	0x000196b5
   1952c:	000196c1 	.word	0x000196c1
   19530:	000196cd 	.word	0x000196cd
   19534:	000196d7 	.word	0x000196d7
   19538:	000196ef 	.word	0x000196ef
   1953c:	00019343 	.word	0x00019343
   19540:	00019343 	.word	0x00019343
   19544:	00019343 	.word	0x00019343
   19548:	00019343 	.word	0x00019343
   1954c:	00019343 	.word	0x00019343
   19550:	00019343 	.word	0x00019343
   19554:	0001971d 	.word	0x0001971d
   19558:	00019343 	.word	0x00019343
   1955c:	000196f9 	.word	0x000196f9
   19560:	00019713 	.word	0x00019713
   19564:	00019627 	.word	0x00019627
   19568:	0001964d 	.word	0x0001964d
   1956c:	00019343 	.word	0x00019343
   19570:	00019343 	.word	0x00019343
   19574:	00019343 	.word	0x00019343
   19578:	00019663 	.word	0x00019663
   1957c:	00019343 	.word	0x00019343
   19580:	00019343 	.word	0x00019343
   19584:	00019343 	.word	0x00019343
   19588:	00019739 	.word	0x00019739
   1958c:	00019767 	.word	0x00019767
   19590:	2d4b      	cmp	r5, #75	; 0x4b
   19592:	f47f aed6 	bne.w	19342 <hci_cmd_handle+0x82>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19596:	2103      	movs	r1, #3
   19598:	a805      	add	r0, sp, #20
   1959a:	f7ff fde3 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   1959e:	4601      	mov	r1, r0
   195a0:	2300      	movs	r3, #0
   195a2:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
   195a6:	3001      	adds	r0, #1
   195a8:	f00e feb8 	bl	2831c <ll_tx_pwr_get>
	if (err == -EINVAL) {
   195ac:	e6e0      	b.n	19370 <hci_cmd_handle+0xb0>
	le_event_mask = sys_get_le64(cmd->events);
   195ae:	68a0      	ldr	r0, [r4, #8]
   195b0:	f00e feb8 	bl	28324 <sys_get_le64>
   195b4:	4b15      	ldr	r3, [pc, #84]	; (1960c <hci_cmd_handle+0x34c>)
   195b6:	e700      	b.n	193ba <hci_cmd_handle+0xfa>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   195b8:	2104      	movs	r1, #4
   195ba:	a805      	add	r0, sp, #20
   195bc:	f7ff fdd2 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   195c0:	2300      	movs	r3, #0
   195c2:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
   195c4:	221b      	movs	r2, #27
   195c6:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
   195c8:	2303      	movs	r3, #3
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
   195ca:	7042      	strb	r2, [r0, #1]
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
   195cc:	70c3      	strb	r3, [r0, #3]
	if (err == -EINVAL) {
   195ce:	e6cf      	b.n	19370 <hci_cmd_handle+0xb0>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   195d0:	2109      	movs	r1, #9
   195d2:	a805      	add	r0, sp, #20
   195d4:	f7ff fdc6 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   195d8:	2500      	movs	r5, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   195da:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   195dc:	2208      	movs	r2, #8
	rp->status = 0x00;
   195de:	f800 5b01 	strb.w	r5, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   195e2:	4629      	mov	r1, r5
   195e4:	f00c fb8b 	bl	25cfe <memset>
	dst[0] = val;
   195e8:	2306      	movs	r3, #6
   195ea:	7063      	strb	r3, [r4, #1]
	dst[1] = val >> 8;
   195ec:	70a5      	strb	r5, [r4, #2]
	dst[2] = val >> 16;
   195ee:	70e5      	strb	r5, [r4, #3]
	if (err == -EINVAL) {
   195f0:	e6be      	b.n	19370 <hci_cmd_handle+0xb0>
   195f2:	bf00      	nop
   195f4:	00029870 	.word	0x00029870
   195f8:	00029830 	.word	0x00029830
   195fc:	0003028c 	.word	0x0003028c
   19600:	000302a2 	.word	0x000302a2
   19604:	20001f2c 	.word	0x20001f2c
   19608:	200069f0 	.word	0x200069f0
   1960c:	200069f8 	.word	0x200069f8
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
   19610:	68a1      	ldr	r1, [r4, #8]
   19612:	2001      	movs	r0, #1
   19614:	f7ff fc06 	bl	18e24 <ll_addr_set>
	status = ll_scan_enable(cmd->enable);
   19618:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1961a:	2101      	movs	r1, #1
   1961c:	a805      	add	r0, sp, #20
   1961e:	f7ff fda1 	bl	19164 <hci_cmd_complete>
	ccst->status = status;
   19622:	7004      	strb	r4, [r0, #0]
	if (err == -EINVAL) {
   19624:	e6a4      	b.n	19370 <hci_cmd_handle+0xb0>
		le_encrypt(cmd, evt);
   19626:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
   19628:	aa06      	add	r2, sp, #24
   1962a:	2300      	movs	r3, #0
   1962c:	f100 0110 	add.w	r1, r0, #16
   19630:	f00f fa78 	bl	28b24 <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19634:	2111      	movs	r1, #17
   19636:	a805      	add	r0, sp, #20
   19638:	f7ff fd94 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   1963c:	2300      	movs	r3, #0
   1963e:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
   19642:	2210      	movs	r2, #16
   19644:	a906      	add	r1, sp, #24
   19646:	f00c fb2f 	bl	25ca8 <memcpy>
	if (err == -EINVAL) {
   1964a:	e691      	b.n	19370 <hci_cmd_handle+0xb0>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1964c:	2109      	movs	r1, #9
   1964e:	a805      	add	r0, sp, #20
   19650:	f7ff fd88 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   19654:	2300      	movs	r3, #0
   19656:	f800 3b01 	strb.w	r3, [r0], #1
	util_rand(rp->rand, count);
   1965a:	2108      	movs	r1, #8
   1965c:	f7fe fe74 	bl	18348 <util_rand>
	if (err == -EINVAL) {
   19660:	e686      	b.n	19370 <hci_cmd_handle+0xb0>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19662:	2109      	movs	r1, #9
   19664:	a805      	add	r0, sp, #20
   19666:	f7ff fd7d 	bl	19164 <hci_cmd_complete>
	dst[0] = val;
   1966a:	22bf      	movs	r2, #191	; 0xbf
   1966c:	7042      	strb	r2, [r0, #1]
	dst[1] = val >> 8;
   1966e:	22ff      	movs	r2, #255	; 0xff
   19670:	7082      	strb	r2, [r0, #2]
	dst[0] = val;
   19672:	2230      	movs	r2, #48	; 0x30
   19674:	70c2      	strb	r2, [r0, #3]
	dst[1] = val >> 8;
   19676:	22ec      	movs	r2, #236	; 0xec
   19678:	7102      	strb	r2, [r0, #4]
	dst[0] = val;
   1967a:	22c0      	movs	r2, #192	; 0xc0
	rp->status = 0x00;
   1967c:	2300      	movs	r3, #0
   1967e:	7142      	strb	r2, [r0, #5]
	dst[1] = val >> 8;
   19680:	2201      	movs	r2, #1
   19682:	7003      	strb	r3, [r0, #0]
   19684:	7182      	strb	r2, [r0, #6]
   19686:	e6d9      	b.n	1943c <hci_cmd_handle+0x17c>
		le_set_adv_param(cmd, evt);
   19688:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_params_set(min_interval, cmd->type,
   1968a:	7ba5      	ldrb	r5, [r4, #14]
   1968c:	79a3      	ldrb	r3, [r4, #6]
   1968e:	7962      	ldrb	r2, [r4, #5]
   19690:	7921      	ldrb	r1, [r4, #4]
   19692:	8820      	ldrh	r0, [r4, #0]
   19694:	9502      	str	r5, [sp, #8]
   19696:	7b65      	ldrb	r5, [r4, #13]
   19698:	9501      	str	r5, [sp, #4]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
   1969a:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
   1969c:	9400      	str	r4, [sp, #0]
   1969e:	f001 fc01 	bl	1aea4 <ll_adv_params_set>
   196a2:	e7b9      	b.n	19618 <hci_cmd_handle+0x358>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   196a4:	2102      	movs	r1, #2
   196a6:	a805      	add	r0, sp, #20
   196a8:	f7ff fd5c 	bl	19164 <hci_cmd_complete>
	rp->status = 0x00;
   196ac:	2300      	movs	r3, #0
   196ae:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
   196b0:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
   196b2:	e65d      	b.n	19370 <hci_cmd_handle+0xb0>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
   196b4:	68a1      	ldr	r1, [r4, #8]
   196b6:	f811 0b01 	ldrb.w	r0, [r1], #1
   196ba:	f001 fc5b 	bl	1af74 <ll_adv_data_set>
   196be:	e7ab      	b.n	19618 <hci_cmd_handle+0x358>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
   196c0:	68a1      	ldr	r1, [r4, #8]
   196c2:	f811 0b01 	ldrb.w	r0, [r1], #1
   196c6:	f001 fc93 	bl	1aff0 <ll_adv_scan_rsp_set>
   196ca:	e7a5      	b.n	19618 <hci_cmd_handle+0x358>
	status = ll_adv_enable(cmd->enable);
   196cc:	68a3      	ldr	r3, [r4, #8]
   196ce:	7818      	ldrb	r0, [r3, #0]
   196d0:	f7e6 fef6 	bl	4c0 <ll_adv_enable>
   196d4:	e7a0      	b.n	19618 <hci_cmd_handle+0x358>
		le_set_scan_param(cmd, evt);
   196d6:	68a4      	ldr	r4, [r4, #8]
	status = ll_scan_params_set(cmd->scan_type, interval, window,
   196d8:	7963      	ldrb	r3, [r4, #5]
   196da:	f8b4 2003 	ldrh.w	r2, [r4, #3]
   196de:	f8b4 1001 	ldrh.w	r1, [r4, #1]
   196e2:	7820      	ldrb	r0, [r4, #0]
   196e4:	79a4      	ldrb	r4, [r4, #6]
   196e6:	9400      	str	r4, [sp, #0]
   196e8:	f7e7 f922 	bl	930 <ll_scan_params_set>
   196ec:	e794      	b.n	19618 <hci_cmd_handle+0x358>
	status = ll_scan_enable(cmd->enable);
   196ee:	68a3      	ldr	r3, [r4, #8]
   196f0:	7818      	ldrb	r0, [r3, #0]
   196f2:	f00e fee2 	bl	284ba <ll_scan_enable>
   196f6:	e78f      	b.n	19618 <hci_cmd_handle+0x358>
	handle = sys_le16_to_cpu(cmd->handle);
   196f8:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   196fa:	2108      	movs	r1, #8
   196fc:	a805      	add	r0, sp, #20
	handle = sys_le16_to_cpu(cmd->handle);
   196fe:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19700:	f7ff fd30 	bl	19164 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   19704:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19706:	4604      	mov	r4, r0
	status = ll_chm_get(handle, rp->ch_map);
   19708:	1cc1      	adds	r1, r0, #3
   1970a:	4630      	mov	r0, r6
   1970c:	f00e ffdf 	bl	286ce <ll_chm_get>
   19710:	e665      	b.n	193de <hci_cmd_handle+0x11e>
	handle = sys_le16_to_cpu(cmd->handle);
   19712:	68a3      	ldr	r3, [r4, #8]
	status = ll_feature_req_send(handle);
   19714:	8818      	ldrh	r0, [r3, #0]
   19716:	f00f f801 	bl	2871c <ll_feature_req_send>
	*evt = cmd_status(status);
   1971a:	e626      	b.n	1936a <hci_cmd_handle+0xaa>
		le_conn_update(cmd, evt);
   1971c:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
   1971e:	8911      	ldrh	r1, [r2, #8]
   19720:	8853      	ldrh	r3, [r2, #2]
   19722:	8810      	ldrh	r0, [r2, #0]
   19724:	9102      	str	r1, [sp, #8]
   19726:	88d1      	ldrh	r1, [r2, #6]
   19728:	9101      	str	r1, [sp, #4]
   1972a:	8892      	ldrh	r2, [r2, #4]
   1972c:	9200      	str	r2, [sp, #0]
   1972e:	2200      	movs	r2, #0
   19730:	4611      	mov	r1, r2
   19732:	f00e ff51 	bl	285d8 <ll_conn_update>
	*evt = cmd_status(status);
   19736:	e618      	b.n	1936a <hci_cmd_handle+0xaa>
		le_conn_param_req_reply(cmd, evt);
   19738:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   1973a:	8911      	ldrh	r1, [r2, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   1973c:	8815      	ldrh	r5, [r2, #0]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   1973e:	8853      	ldrh	r3, [r2, #2]
   19740:	9102      	str	r1, [sp, #8]
   19742:	88d1      	ldrh	r1, [r2, #6]
   19744:	9101      	str	r1, [sp, #4]
   19746:	8892      	ldrh	r2, [r2, #4]
   19748:	9200      	str	r2, [sp, #0]
   1974a:	2200      	movs	r2, #0
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   1974c:	2102      	movs	r1, #2
   1974e:	4628      	mov	r0, r5
   19750:	f00e ff42 	bl	285d8 <ll_conn_update>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19754:	2103      	movs	r1, #3
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   19756:	4604      	mov	r4, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   19758:	a805      	add	r0, sp, #20
   1975a:	f7ff fd03 	bl	19164 <hci_cmd_complete>
	rp->status = status;
   1975e:	7004      	strb	r4, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
   19760:	f8a0 5001 	strh.w	r5, [r0, #1]
	if (err == -EINVAL) {
   19764:	e604      	b.n	19370 <hci_cmd_handle+0xb0>
		le_conn_param_req_neg_reply(cmd, evt);
   19766:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   19768:	881d      	ldrh	r5, [r3, #0]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   1976a:	789a      	ldrb	r2, [r3, #2]
   1976c:	2300      	movs	r3, #0
   1976e:	e9cd 3301 	strd	r3, r3, [sp, #4]
   19772:	9300      	str	r3, [sp, #0]
   19774:	e7ea      	b.n	1974c <hci_cmd_handle+0x48c>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(u16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
   19776:	aa05      	add	r2, sp, #20
   19778:	4621      	mov	r1, r4
   1977a:	4628      	mov	r0, r5
   1977c:	f7ff fd16 	bl	191ac <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
   19780:	3016      	adds	r0, #22
   19782:	f43f adde 	beq.w	19342 <hci_cmd_handle+0x82>
   19786:	e5f3      	b.n	19370 <hci_cmd_handle+0xb0>

00019788 <hci_acl_handle>:
{
   19788:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	*evt = NULL;
   1978c:	2300      	movs	r3, #0
   1978e:	600b      	str	r3, [r1, #0]
	if (buf->len < sizeof(*acl)) {
   19790:	8983      	ldrh	r3, [r0, #12]
   19792:	2b03      	cmp	r3, #3
{
   19794:	4605      	mov	r5, r0
   19796:	460e      	mov	r6, r1
	if (buf->len < sizeof(*acl)) {
   19798:	d80c      	bhi.n	197b4 <hci_acl_handle+0x2c>
   1979a:	493b      	ldr	r1, [pc, #236]	; (19888 <hci_acl_handle+0x100>)
   1979c:	4b3b      	ldr	r3, [pc, #236]	; (1988c <hci_acl_handle+0x104>)
		BT_ERR("No HCI ACL header");
   1979e:	483c      	ldr	r0, [pc, #240]	; (19890 <hci_acl_handle+0x108>)
   197a0:	1ac9      	subs	r1, r1, r3
   197a2:	08c9      	lsrs	r1, r1, #3
   197a4:	0189      	lsls	r1, r1, #6
   197a6:	f041 0101 	orr.w	r1, r1, #1
		BT_ERR("Invalid HCI ACL packet length");
   197aa:	f00a fc0b 	bl	23fc4 <log_0>
		return -EINVAL;
   197ae:	f06f 0015 	mvn.w	r0, #21
   197b2:	e03d      	b.n	19830 <hci_acl_handle+0xa8>
	acl = net_buf_pull_mem(buf, sizeof(*acl));
   197b4:	2104      	movs	r1, #4
   197b6:	3008      	adds	r0, #8
   197b8:	f005 fd6c 	bl	1f294 <net_buf_simple_pull_mem>
	if (buf->len < len) {
   197bc:	89ab      	ldrh	r3, [r5, #12]
	len = sys_le16_to_cpu(acl->len);
   197be:	f8b0 8002 	ldrh.w	r8, [r0, #2]
	handle = sys_le16_to_cpu(acl->handle);
   197c2:	f8b0 9000 	ldrh.w	r9, [r0]
	if (buf->len < len) {
   197c6:	4543      	cmp	r3, r8
   197c8:	d208      	bcs.n	197dc <hci_acl_handle+0x54>
   197ca:	492f      	ldr	r1, [pc, #188]	; (19888 <hci_acl_handle+0x100>)
   197cc:	4b2f      	ldr	r3, [pc, #188]	; (1988c <hci_acl_handle+0x104>)
		BT_ERR("Invalid HCI ACL packet length");
   197ce:	4831      	ldr	r0, [pc, #196]	; (19894 <hci_acl_handle+0x10c>)
   197d0:	1ac9      	subs	r1, r1, r3
   197d2:	08c9      	lsrs	r1, r1, #3
   197d4:	0189      	lsls	r1, r1, #6
   197d6:	f041 0101 	orr.w	r1, r1, #1
   197da:	e7e6      	b.n	197aa <hci_acl_handle+0x22>
	node_tx = ll_tx_mem_acquire();
   197dc:	f001 ff7a 	bl	1b6d4 <ll_tx_mem_acquire>
	flags = bt_acl_flags(handle);
   197e0:	ea4f 3719 	mov.w	r7, r9, lsr #12
	if (!node_tx) {
   197e4:	4604      	mov	r4, r0
   197e6:	bb28      	cbnz	r0, 19834 <hci_acl_handle+0xac>
   197e8:	4928      	ldr	r1, [pc, #160]	; (1988c <hci_acl_handle+0x104>)
   197ea:	4b27      	ldr	r3, [pc, #156]	; (19888 <hci_acl_handle+0x100>)
		BT_ERR("Tx Buffer Overflow");
   197ec:	482a      	ldr	r0, [pc, #168]	; (19898 <hci_acl_handle+0x110>)
   197ee:	1a5b      	subs	r3, r3, r1
   197f0:	08db      	lsrs	r3, r3, #3
   197f2:	019b      	lsls	r3, r3, #6
   197f4:	f043 0101 	orr.w	r1, r3, #1
   197f8:	f00a fbe4 	bl	23fc4 <log_0>
	if (!(event_mask & BT_EVT_MASK_DATA_BUFFER_OVERFLOW)) {
   197fc:	4b27      	ldr	r3, [pc, #156]	; (1989c <hci_acl_handle+0x114>)
   197fe:	6819      	ldr	r1, [r3, #0]
   19800:	4623      	mov	r3, r4
   19802:	f001 7200 	and.w	r2, r1, #33554432	; 0x2000000
   19806:	4313      	orrs	r3, r2
   19808:	d010      	beq.n	1982c <hci_acl_handle+0xa4>
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   1980a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1980e:	2001      	movs	r0, #1
   19810:	f7ef f8a6 	bl	8960 <bt_buf_get_rx>
	hci_evt_create(*buf, BT_HCI_EVT_DATA_BUF_OVERFLOW, sizeof(*ep));
   19814:	2201      	movs	r2, #1
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   19816:	6030      	str	r0, [r6, #0]
	hci_evt_create(*buf, BT_HCI_EVT_DATA_BUF_OVERFLOW, sizeof(*ep));
   19818:	211a      	movs	r1, #26
   1981a:	f00e fd87 	bl	2832c <hci_evt_create>
	ep = net_buf_add(*buf, sizeof(*ep));
   1981e:	6830      	ldr	r0, [r6, #0]
   19820:	2101      	movs	r1, #1
   19822:	3008      	adds	r0, #8
   19824:	f005 fd58 	bl	1f2d8 <net_buf_simple_add>
	ep->link_type = BT_OVERFLOW_LINK_ACL;
   19828:	2301      	movs	r3, #1
   1982a:	7003      	strb	r3, [r0, #0]
		return -ENOBUFS;
   1982c:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
   19830:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (bt_acl_flags_bc(flags) != BT_ACL_POINT_TO_POINT) {
   19834:	08bb      	lsrs	r3, r7, #2
   19836:	d1ba      	bne.n	197ae <hci_acl_handle+0x26>
	switch (bt_acl_flags_pb(flags)) {
   19838:	b12f      	cbz	r7, 19846 <hci_acl_handle+0xbe>
   1983a:	2f01      	cmp	r7, #1
   1983c:	d1b7      	bne.n	197ae <hci_acl_handle+0x26>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   1983e:	7903      	ldrb	r3, [r0, #4]
   19840:	f367 0301 	bfi	r3, r7, #0, #2
   19844:	e003      	b.n	1984e <hci_acl_handle+0xc6>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
   19846:	7903      	ldrb	r3, [r0, #4]
   19848:	2202      	movs	r2, #2
   1984a:	f362 0301 	bfi	r3, r2, #0, #2
	pdu_data->len = len;
   1984e:	f884 8005 	strb.w	r8, [r4, #5]
	memcpy(&pdu_data->lldata[0], buf->data, len);
   19852:	68a9      	ldr	r1, [r5, #8]
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   19854:	7123      	strb	r3, [r4, #4]
	memcpy(&pdu_data->lldata[0], buf->data, len);
   19856:	4642      	mov	r2, r8
   19858:	1de0      	adds	r0, r4, #7
   1985a:	f00c fa25 	bl	25ca8 <memcpy>
	if (ll_tx_mem_enqueue(handle, node_tx)) {
   1985e:	4621      	mov	r1, r4
   19860:	f3c9 000b 	ubfx	r0, r9, #0, #12
   19864:	f001 ff42 	bl	1b6ec <ll_tx_mem_enqueue>
   19868:	2800      	cmp	r0, #0
   1986a:	d0e1      	beq.n	19830 <hci_acl_handle+0xa8>
   1986c:	4b07      	ldr	r3, [pc, #28]	; (1988c <hci_acl_handle+0x104>)
   1986e:	4906      	ldr	r1, [pc, #24]	; (19888 <hci_acl_handle+0x100>)
		BT_ERR("Invalid Tx Enqueue");
   19870:	480b      	ldr	r0, [pc, #44]	; (198a0 <hci_acl_handle+0x118>)
   19872:	1ac9      	subs	r1, r1, r3
   19874:	08c9      	lsrs	r1, r1, #3
   19876:	0189      	lsls	r1, r1, #6
   19878:	f041 0101 	orr.w	r1, r1, #1
   1987c:	f00a fba2 	bl	23fc4 <log_0>
		ll_tx_mem_release(node_tx);
   19880:	4620      	mov	r0, r4
   19882:	f001 ff2d 	bl	1b6e0 <ll_tx_mem_release>
		return -EINVAL;
   19886:	e792      	b.n	197ae <hci_acl_handle+0x26>
   19888:	00029870 	.word	0x00029870
   1988c:	00029830 	.word	0x00029830
   19890:	000302c0 	.word	0x000302c0
   19894:	000302d2 	.word	0x000302d2
   19898:	000302f0 	.word	0x000302f0
   1989c:	200069f0 	.word	0x200069f0
   198a0:	00030303 	.word	0x00030303

000198a4 <hci_acl_encode>:
	u16_t handle;
	u8_t *data;

	handle = node_rx->hdr.handle;

	switch (pdu_data->ll_id) {
   198a4:	f890 3020 	ldrb.w	r3, [r0, #32]
   198a8:	f003 0303 	and.w	r3, r3, #3
   198ac:	3b01      	subs	r3, #1
   198ae:	2b01      	cmp	r3, #1
{
   198b0:	b570      	push	{r4, r5, r6, lr}
   198b2:	4604      	mov	r4, r0
	switch (pdu_data->ll_id) {
   198b4:	d81f      	bhi.n	198f6 <hci_acl_encode+0x52>
	case PDU_DATA_LLID_DATA_CONTINUE:
	case PDU_DATA_LLID_DATA_START:
		acl = (void *)net_buf_add(buf, sizeof(*acl));
   198b6:	f101 0508 	add.w	r5, r1, #8
	handle = node_rx->hdr.handle;
   198ba:	88c6      	ldrh	r6, [r0, #6]
		acl = (void *)net_buf_add(buf, sizeof(*acl));
   198bc:	2104      	movs	r1, #4
   198be:	4628      	mov	r0, r5
   198c0:	f005 fd0a 	bl	1f2d8 <net_buf_simple_add>
		if (pdu_data->ll_id == PDU_DATA_LLID_DATA_START) {
   198c4:	f894 3020 	ldrb.w	r3, [r4, #32]
   198c8:	f003 0303 	and.w	r3, r3, #3
   198cc:	2b02      	cmp	r3, #2
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_START);
   198ce:	bf0c      	ite	eq
   198d0:	f446 5600 	orreq.w	r6, r6, #8192	; 0x2000
		} else {
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_CONT);
   198d4:	f446 5680 	orrne.w	r6, r6, #4096	; 0x1000
		}
		acl->handle = sys_cpu_to_le16(handle_flags);
   198d8:	8006      	strh	r6, [r0, #0]
		acl->len = sys_cpu_to_le16(pdu_data->len);
   198da:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
   198de:	8041      	strh	r1, [r0, #2]
		data = (void *)net_buf_add(buf, pdu_data->len);
   198e0:	4628      	mov	r0, r5
   198e2:	f005 fcf9 	bl	1f2d8 <net_buf_simple_add>
		memcpy(data, pdu_data->lldata, pdu_data->len);
   198e6:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
   198ea:	f104 0123 	add.w	r1, r4, #35	; 0x23

	default:
		LL_ASSERT(0);
		break;
	}
}
   198ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		memcpy(data, pdu_data->lldata, pdu_data->len);
   198f2:	f00c b9d9 	b.w	25ca8 <memcpy>
		LL_ASSERT(0);
   198f6:	4a07      	ldr	r2, [pc, #28]	; (19914 <hci_acl_encode+0x70>)
   198f8:	4907      	ldr	r1, [pc, #28]	; (19918 <hci_acl_encode+0x74>)
   198fa:	4808      	ldr	r0, [pc, #32]	; (1991c <hci_acl_encode+0x78>)
   198fc:	f640 5349 	movw	r3, #3401	; 0xd49
   19900:	f00a faef 	bl	23ee2 <printk>
   19904:	4040      	eors	r0, r0
   19906:	f380 8811 	msr	BASEPRI, r0
   1990a:	f04f 0003 	mov.w	r0, #3
   1990e:	df02      	svc	2
}
   19910:	bd70      	pop	{r4, r5, r6, pc}
   19912:	bf00      	nop
   19914:	00030316 	.word	0x00030316
   19918:	0002e3c9 	.word	0x0002e3c9
   1991c:	0002a5e8 	.word	0x0002a5e8

00019920 <hci_evt_encode>:
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
   19920:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct pdu_data *pdu_data = PDU_DATA(node_rx);

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   19924:	7903      	ldrb	r3, [r0, #4]
   19926:	88c7      	ldrh	r7, [r0, #6]
   19928:	2b02      	cmp	r3, #2
{
   1992a:	b086      	sub	sp, #24
   1992c:	4604      	mov	r4, r0
   1992e:	460e      	mov	r6, r1
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   19930:	f000 80ef 	beq.w	19b12 <hci_evt_encode+0x1f2>
	switch (node_rx->hdr.type) {
   19934:	3b04      	subs	r3, #4
   19936:	2b06      	cmp	r3, #6
   19938:	f200 80dd 	bhi.w	19af6 <hci_evt_encode+0x1d6>
   1993c:	e8df f013 	tbh	[pc, r3, lsl #1]
   19940:	00db0007 	.word	0x00db0007
   19944:	00db00db 	.word	0x00db00db
   19948:	009b0056 	.word	0x009b0056
   1994c:	00b8      	.short	0x00b8
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   1994e:	4b9a      	ldr	r3, [pc, #616]	; (19bb8 <hci_evt_encode+0x298>)
		le_advertising_report(pdu_data, node_rx, buf);
   19950:	7f07      	ldrb	r7, [r0, #28]
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   19952:	889a      	ldrh	r2, [r3, #4]
   19954:	6818      	ldr	r0, [r3, #0]
   19956:	799b      	ldrb	r3, [r3, #6]
   19958:	f88d 3016 	strb.w	r3, [sp, #22]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1995c:	4b97      	ldr	r3, [pc, #604]	; (19bbc <hci_evt_encode+0x29c>)
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   1995e:	f8ad 2014 	strh.w	r2, [sp, #20]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   19962:	6859      	ldr	r1, [r3, #4]
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   19964:	9004      	str	r0, [sp, #16]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   19966:	2500      	movs	r5, #0
   19968:	462a      	mov	r2, r5
   1996a:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
   1996e:	4313      	orrs	r3, r2
   19970:	d039      	beq.n	199e6 <hci_evt_encode+0xc6>
	    !(le_event_mask & BT_EVT_MASK_LE_ADVERTISING_REPORT)) {
   19972:	4b93      	ldr	r3, [pc, #588]	; (19bc0 <hci_evt_encode+0x2a0>)
   19974:	6819      	ldr	r1, [r3, #0]
   19976:	462b      	mov	r3, r5
   19978:	f001 0202 	and.w	r2, r1, #2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1997c:	4313      	orrs	r3, r2
   1997e:	d032      	beq.n	199e6 <hci_evt_encode+0xc6>
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
   19980:	f894 3020 	ldrb.w	r3, [r4, #32]
   19984:	f003 030f 	and.w	r3, r3, #15
   19988:	2b01      	cmp	r3, #1
		data_len = (adv->len - BDADDR_SIZE);
   1998a:	bf1e      	ittt	ne
   1998c:	f894 5021 	ldrbne.w	r5, [r4, #33]	; 0x21
   19990:	3d06      	subne	r5, #6
   19992:	b2ed      	uxtbne	r5, r5
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
   19994:	f105 020b 	add.w	r2, r5, #11
   19998:	b2d2      	uxtb	r2, r2
   1999a:	2102      	movs	r1, #2
   1999c:	4630      	mov	r0, r6
   1999e:	f00e fccf 	bl	28340 <meta_evt>
	sep->num_reports = 1U;
   199a2:	2301      	movs	r3, #1
   199a4:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = c_adv_type[adv->type];
   199a6:	f894 3020 	ldrb.w	r3, [r4, #32]
   199aa:	aa06      	add	r2, sp, #24
   199ac:	f003 030f 	and.w	r3, r3, #15
   199b0:	4413      	add	r3, r2
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
   199b2:	4606      	mov	r6, r0
	adv_info->evt_type = c_adv_type[adv->type];
   199b4:	f813 3c08 	ldrb.w	r3, [r3, #-8]
   199b8:	7043      	strb	r3, [r0, #1]
		adv_info->addr.type = adv->tx_addr;
   199ba:	f894 3020 	ldrb.w	r3, [r4, #32]
   199be:	f3c3 1380 	ubfx	r3, r3, #6, #1
   199c2:	7083      	strb	r3, [r0, #2]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
   199c4:	2206      	movs	r2, #6
   199c6:	f104 0122 	add.w	r1, r4, #34	; 0x22
   199ca:	3003      	adds	r0, #3
   199cc:	f00c f96c 	bl	25ca8 <memcpy>
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
   199d0:	360a      	adds	r6, #10
	adv_info->length = data_len;
   199d2:	f806 5c01 	strb.w	r5, [r6, #-1]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
   199d6:	462a      	mov	r2, r5
   199d8:	f104 0128 	add.w	r1, r4, #40	; 0x28
   199dc:	4630      	mov	r0, r6
	rssi = -(node_rx->hdr.rx_ftr.rssi);
   199de:	427f      	negs	r7, r7
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
   199e0:	f00c f962 	bl	25ca8 <memcpy>
	*prssi = rssi;
   199e4:	5577      	strb	r7, [r6, r5]
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
   199e6:	b006      	add	sp, #24
   199e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   199ec:	4b73      	ldr	r3, [pc, #460]	; (19bbc <hci_evt_encode+0x29c>)
   199ee:	6858      	ldr	r0, [r3, #4]
   199f0:	2100      	movs	r1, #0
   199f2:	460a      	mov	r2, r1
   199f4:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   199f8:	4313      	orrs	r3, r2
   199fa:	d0f4      	beq.n	199e6 <hci_evt_encode+0xc6>
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
   199fc:	4b70      	ldr	r3, [pc, #448]	; (19bc0 <hci_evt_encode+0x2a0>)
   199fe:	6818      	ldr	r0, [r3, #0]
   19a00:	460b      	mov	r3, r1
   19a02:	f000 0201 	and.w	r2, r0, #1
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   19a06:	4313      	orrs	r3, r2
   19a08:	d0ed      	beq.n	199e6 <hci_evt_encode+0xc6>
	u8_t status = node_rx->status;
   19a0a:	f894 8020 	ldrb.w	r8, [r4, #32]
	if (!status) {
   19a0e:	f1b8 0f00 	cmp.w	r8, #0
   19a12:	d103      	bne.n	19a1c <hci_evt_encode+0xfc>
		conn_count++;
   19a14:	4a6b      	ldr	r2, [pc, #428]	; (19bc4 <hci_evt_encode+0x2a4>)
   19a16:	6813      	ldr	r3, [r2, #0]
   19a18:	3301      	adds	r3, #1
   19a1a:	6013      	str	r3, [r2, #0]
	lecc = meta_evt(buf, BT_HCI_EVT_LE_CONN_COMPLETE, sizeof(*lecc));
   19a1c:	2212      	movs	r2, #18
   19a1e:	2101      	movs	r1, #1
   19a20:	4630      	mov	r0, r6
   19a22:	f00e fc8d 	bl	28340 <meta_evt>
   19a26:	4605      	mov	r5, r0
	if (status) {
   19a28:	f1b8 0f00 	cmp.w	r8, #0
   19a2c:	d006      	beq.n	19a3c <hci_evt_encode+0x11c>
		(void)memset(lecc, 0x00, sizeof(*lecc));
   19a2e:	2212      	movs	r2, #18
   19a30:	2100      	movs	r1, #0
   19a32:	f00c f964 	bl	25cfe <memset>
		lecc->status = status;
   19a36:	f885 8000 	strb.w	r8, [r5]
		return;
   19a3a:	e7d4      	b.n	199e6 <hci_evt_encode+0xc6>
	lecc->status = 0x00;
   19a3c:	f880 8000 	strb.w	r8, [r0]
	lecc->handle = sys_cpu_to_le16(handle);
   19a40:	f8a0 7001 	strh.w	r7, [r0, #1]
	lecc->role = node_rx->role;
   19a44:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
   19a48:	70c3      	strb	r3, [r0, #3]
	lecc->peer_addr.type = node_rx->peer_addr_type;
   19a4a:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
   19a4e:	7103      	strb	r3, [r0, #4]
	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
   19a50:	2206      	movs	r2, #6
   19a52:	f104 0123 	add.w	r1, r4, #35	; 0x23
   19a56:	3005      	adds	r0, #5
   19a58:	f00c f926 	bl	25ca8 <memcpy>
	lecc->interval = sys_cpu_to_le16(node_rx->interval);
   19a5c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   19a5e:	f8a5 300b 	strh.w	r3, [r5, #11]
	lecc->latency = sys_cpu_to_le16(node_rx->latency);
   19a62:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   19a64:	f8a5 300d 	strh.w	r3, [r5, #13]
	lecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
   19a68:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
   19a6a:	f8a5 300f 	strh.w	r3, [r5, #15]
	lecc->clock_accuracy = node_rx->sca;
   19a6e:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   19a72:	746b      	strb	r3, [r5, #17]
   19a74:	e7b7      	b.n	199e6 <hci_evt_encode+0xc6>
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
   19a76:	4b51      	ldr	r3, [pc, #324]	; (19bbc <hci_evt_encode+0x29c>)
   19a78:	6819      	ldr	r1, [r3, #0]
   19a7a:	2500      	movs	r5, #0
   19a7c:	f001 0210 	and.w	r2, r1, #16
   19a80:	462b      	mov	r3, r5
   19a82:	4313      	orrs	r3, r2
   19a84:	d0af      	beq.n	199e6 <hci_evt_encode+0xc6>
	hci_evt_create(buf, BT_HCI_EVT_DISCONN_COMPLETE, sizeof(*ep));
   19a86:	2204      	movs	r2, #4
   19a88:	2105      	movs	r1, #5
   19a8a:	4630      	mov	r0, r6
   19a8c:	f00e fc4e 	bl	2832c <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
   19a90:	2104      	movs	r1, #4
   19a92:	f106 0008 	add.w	r0, r6, #8
   19a96:	f005 fc1f 	bl	1f2d8 <net_buf_simple_add>
	conn_count--;
   19a9a:	4a4a      	ldr	r2, [pc, #296]	; (19bc4 <hci_evt_encode+0x2a4>)
	ep->status = 0x00;
   19a9c:	7005      	strb	r5, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   19a9e:	f8a0 7001 	strh.w	r7, [r0, #1]
	ep->reason = *((u8_t *)pdu_data);
   19aa2:	f894 3020 	ldrb.w	r3, [r4, #32]
   19aa6:	70c3      	strb	r3, [r0, #3]
	conn_count--;
   19aa8:	6813      	ldr	r3, [r2, #0]
   19aaa:	3b01      	subs	r3, #1
   19aac:	6013      	str	r3, [r2, #0]
   19aae:	e79a      	b.n	199e6 <hci_evt_encode+0xc6>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   19ab0:	4b42      	ldr	r3, [pc, #264]	; (19bbc <hci_evt_encode+0x29c>)
   19ab2:	6858      	ldr	r0, [r3, #4]
   19ab4:	2100      	movs	r1, #0
   19ab6:	460a      	mov	r2, r1
   19ab8:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   19abc:	4313      	orrs	r3, r2
   19abe:	d092      	beq.n	199e6 <hci_evt_encode+0xc6>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_UPDATE_COMPLETE)) {
   19ac0:	4b3f      	ldr	r3, [pc, #252]	; (19bc0 <hci_evt_encode+0x2a0>)
   19ac2:	6818      	ldr	r0, [r3, #0]
   19ac4:	460b      	mov	r3, r1
   19ac6:	f000 0204 	and.w	r2, r0, #4
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   19aca:	4313      	orrs	r3, r2
   19acc:	d08b      	beq.n	199e6 <hci_evt_encode+0xc6>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE, sizeof(*sep));
   19ace:	2209      	movs	r2, #9
   19ad0:	2103      	movs	r1, #3
   19ad2:	4630      	mov	r0, r6
   19ad4:	f00e fc34 	bl	28340 <meta_evt>
	sep->status = cu->status;
   19ad8:	f894 3020 	ldrb.w	r3, [r4, #32]
   19adc:	7003      	strb	r3, [r0, #0]
	sep->interval = sys_cpu_to_le16(cu->interval);
   19ade:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   19ae0:	f8a0 3003 	strh.w	r3, [r0, #3]
	sep->latency = sys_cpu_to_le16(cu->latency);
   19ae4:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   19ae6:	f8a0 3005 	strh.w	r3, [r0, #5]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
   19aea:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
	sep->handle = sys_cpu_to_le16(handle);
   19aec:	f8a0 7001 	strh.w	r7, [r0, #1]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
   19af0:	f8a0 3007 	strh.w	r3, [r0, #7]
   19af4:	e777      	b.n	199e6 <hci_evt_encode+0xc6>
		LL_ASSERT(0);
   19af6:	f640 4354 	movw	r3, #3156	; 0xc54
		LL_ASSERT(0);
   19afa:	4a33      	ldr	r2, [pc, #204]	; (19bc8 <hci_evt_encode+0x2a8>)
   19afc:	4933      	ldr	r1, [pc, #204]	; (19bcc <hci_evt_encode+0x2ac>)
   19afe:	4834      	ldr	r0, [pc, #208]	; (19bd0 <hci_evt_encode+0x2b0>)
   19b00:	f00a f9ef 	bl	23ee2 <printk>
   19b04:	4040      	eors	r0, r0
   19b06:	f380 8811 	msr	BASEPRI, r0
   19b0a:	f04f 0003 	mov.w	r0, #3
   19b0e:	df02      	svc	2
}
   19b10:	e769      	b.n	199e6 <hci_evt_encode+0xc6>
	switch (pdu_data->llctrl.opcode) {
   19b12:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
   19b16:	2b09      	cmp	r3, #9
   19b18:	d00c      	beq.n	19b34 <hci_evt_encode+0x214>
   19b1a:	2b0f      	cmp	r3, #15
   19b1c:	d014      	beq.n	19b48 <hci_evt_encode+0x228>
   19b1e:	2b07      	cmp	r3, #7
   19b20:	d147      	bne.n	19bb2 <hci_evt_encode+0x292>
		le_unknown_rsp(pdu_data, handle, buf);
   19b22:	f890 1024 	ldrb.w	r1, [r0, #36]	; 0x24
	switch (pdu_data->llctrl.unknown_rsp.type) {
   19b26:	290e      	cmp	r1, #14
   19b28:	d136      	bne.n	19b98 <hci_evt_encode+0x278>
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   19b2a:	4633      	mov	r3, r6
   19b2c:	463a      	mov	r2, r7
   19b2e:	2100      	movs	r1, #0
   19b30:	201a      	movs	r0, #26
   19b32:	e004      	b.n	19b3e <hci_evt_encode+0x21e>
		le_remote_feat_complete(0x00, pdu_data, handle, buf);
   19b34:	460b      	mov	r3, r1
   19b36:	463a      	mov	r2, r7
   19b38:	f100 0120 	add.w	r1, r0, #32
   19b3c:	2000      	movs	r0, #0
}
   19b3e:	b006      	add	sp, #24
   19b40:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   19b44:	f7ff bae0 	b.w	19108 <le_remote_feat_complete>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   19b48:	4b1c      	ldr	r3, [pc, #112]	; (19bbc <hci_evt_encode+0x29c>)
   19b4a:	6858      	ldr	r0, [r3, #4]
   19b4c:	2100      	movs	r1, #0
   19b4e:	460a      	mov	r2, r1
   19b50:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   19b54:	4313      	orrs	r3, r2
   19b56:	d006      	beq.n	19b66 <hci_evt_encode+0x246>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_PARAM_REQ)) {
   19b58:	4b19      	ldr	r3, [pc, #100]	; (19bc0 <hci_evt_encode+0x2a0>)
   19b5a:	6818      	ldr	r0, [r3, #0]
   19b5c:	460b      	mov	r3, r1
   19b5e:	f000 0220 	and.w	r2, r0, #32
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   19b62:	4313      	orrs	r3, r2
   19b64:	d109      	bne.n	19b7a <hci_evt_encode+0x25a>
		ll_conn_update(handle, 2, BT_HCI_ERR_UNSUPP_REMOTE_FEATURE, 0,
   19b66:	2300      	movs	r3, #0
   19b68:	e9cd 3301 	strd	r3, r3, [sp, #4]
   19b6c:	9300      	str	r3, [sp, #0]
   19b6e:	221a      	movs	r2, #26
   19b70:	2102      	movs	r1, #2
   19b72:	4638      	mov	r0, r7
   19b74:	f00e fd30 	bl	285d8 <ll_conn_update>
		return;
   19b78:	e735      	b.n	199e6 <hci_evt_encode+0xc6>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_PARAM_REQ, sizeof(*sep));
   19b7a:	220a      	movs	r2, #10
   19b7c:	2106      	movs	r1, #6
   19b7e:	4630      	mov	r0, r6
   19b80:	f00e fbde 	bl	28340 <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
   19b84:	8007      	strh	r7, [r0, #0]
	sep->interval_min = pdu_data->llctrl.conn_param_req.interval_min;
   19b86:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   19b88:	8043      	strh	r3, [r0, #2]
	sep->interval_max = pdu_data->llctrl.conn_param_req.interval_max;
   19b8a:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   19b8c:	8083      	strh	r3, [r0, #4]
	sep->latency = pdu_data->llctrl.conn_param_req.latency;
   19b8e:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   19b90:	80c3      	strh	r3, [r0, #6]
	sep->timeout = pdu_data->llctrl.conn_param_req.timeout;
   19b92:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   19b94:	8103      	strh	r3, [r0, #8]
   19b96:	e726      	b.n	199e6 <hci_evt_encode+0xc6>
   19b98:	4b0e      	ldr	r3, [pc, #56]	; (19bd4 <hci_evt_encode+0x2b4>)
   19b9a:	4a0f      	ldr	r2, [pc, #60]	; (19bd8 <hci_evt_encode+0x2b8>)
		BT_WARN("type: 0x%02x",	pdu_data->llctrl.unknown_rsp.type);
   19b9c:	480f      	ldr	r0, [pc, #60]	; (19bdc <hci_evt_encode+0x2bc>)
   19b9e:	1ad2      	subs	r2, r2, r3
   19ba0:	08d2      	lsrs	r2, r2, #3
   19ba2:	0192      	lsls	r2, r2, #6
   19ba4:	f042 0202 	orr.w	r2, r2, #2
}
   19ba8:	b006      	add	sp, #24
   19baa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		BT_WARN("type: 0x%02x",	pdu_data->llctrl.unknown_rsp.type);
   19bae:	f00a ba16 	b.w	23fde <log_1>
		LL_ASSERT(0);
   19bb2:	f640 531d 	movw	r3, #3357	; 0xd1d
   19bb6:	e7a0      	b.n	19afa <hci_evt_encode+0x1da>
   19bb8:	00029aac 	.word	0x00029aac
   19bbc:	200069f0 	.word	0x200069f0
   19bc0:	200069f8 	.word	0x200069f8
   19bc4:	20000f5c 	.word	0x20000f5c
   19bc8:	00030316 	.word	0x00030316
   19bcc:	0002e3c9 	.word	0x0002e3c9
   19bd0:	0002a5e8 	.word	0x0002a5e8
   19bd4:	00029830 	.word	0x00029830
   19bd8:	00029870 	.word	0x00029870
   19bdc:	0002f8f2 	.word	0x0002f8f2

00019be0 <hci_get_class>:
{
#if defined(CONFIG_BT_CONN)
	struct pdu_data *pdu_data = PDU_DATA(node_rx);
#endif

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   19be0:	7903      	ldrb	r3, [r0, #4]
   19be2:	2b02      	cmp	r3, #2
   19be4:	d006      	beq.n	19bf4 <hci_get_class+0x14>

		switch (node_rx->hdr.type) {
   19be6:	3b04      	subs	r3, #4
   19be8:	b2db      	uxtb	r3, r3
   19bea:	2b06      	cmp	r3, #6
   19bec:	d80b      	bhi.n	19c06 <hci_get_class+0x26>
   19bee:	4a07      	ldr	r2, [pc, #28]	; (19c0c <hci_get_class+0x2c>)
   19bf0:	5cd0      	ldrb	r0, [r2, r3]
   19bf2:	4770      	bx	lr
		default:
			return HCI_CLASS_NONE;
		}

#if defined(CONFIG_BT_CONN)
	} else if (pdu_data->ll_id == PDU_DATA_LLID_CTRL) {
   19bf4:	f890 3020 	ldrb.w	r3, [r0, #32]
   19bf8:	f003 0303 	and.w	r3, r3, #3
   19bfc:	2b03      	cmp	r3, #3
		return HCI_CLASS_EVT_LLCP;
	} else {
		return HCI_CLASS_ACL_DATA;
   19bfe:	bf0c      	ite	eq
   19c00:	2004      	moveq	r0, #4
   19c02:	2005      	movne	r0, #5
   19c04:	4770      	bx	lr
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   19c06:	2000      	movs	r0, #0
#else
	} else {
		return HCI_CLASS_NONE;
	}
#endif
}
   19c08:	4770      	bx	lr
   19c0a:	bf00      	nop
   19c0c:	0003035b 	.word	0x0003035b

00019c10 <hci_init>:
	event_mask = DEFAULT_EVENT_MASK;
   19c10:	4b06      	ldr	r3, [pc, #24]	; (19c2c <hci_init+0x1c>)
   19c12:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   19c16:	f641 71ff 	movw	r1, #8191	; 0x1fff
   19c1a:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   19c1e:	4b04      	ldr	r3, [pc, #16]	; (19c30 <hci_init+0x20>)
   19c20:	201f      	movs	r0, #31
   19c22:	2100      	movs	r1, #0
   19c24:	e9c3 0100 	strd	r0, r1, [r3]
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
   19c28:	4770      	bx	lr
   19c2a:	bf00      	nop
   19c2c:	200069f0 	.word	0x200069f0
   19c30:	200069f8 	.word	0x200069f8

00019c34 <ll_rx_link_inc_quota>:
	rx_alloc(UINT8_MAX);
}

static inline void ll_rx_link_inc_quota(int8_t delta)
{
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   19c34:	2801      	cmp	r0, #1
{
   19c36:	b538      	push	{r3, r4, r5, lr}
   19c38:	4d0b      	ldr	r5, [pc, #44]	; (19c68 <ll_rx_link_inc_quota+0x34>)
   19c3a:	4604      	mov	r4, r0
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   19c3c:	d10f      	bne.n	19c5e <ll_rx_link_inc_quota+0x2a>
   19c3e:	782b      	ldrb	r3, [r5, #0]
   19c40:	2b05      	cmp	r3, #5
   19c42:	d90c      	bls.n	19c5e <ll_rx_link_inc_quota+0x2a>
   19c44:	4a09      	ldr	r2, [pc, #36]	; (19c6c <ll_rx_link_inc_quota+0x38>)
   19c46:	490a      	ldr	r1, [pc, #40]	; (19c70 <ll_rx_link_inc_quota+0x3c>)
   19c48:	480a      	ldr	r0, [pc, #40]	; (19c74 <ll_rx_link_inc_quota+0x40>)
   19c4a:	f240 335d 	movw	r3, #861	; 0x35d
   19c4e:	f00a f948 	bl	23ee2 <printk>
   19c52:	4040      	eors	r0, r0
   19c54:	f380 8811 	msr	BASEPRI, r0
   19c58:	f04f 0003 	mov.w	r0, #3
   19c5c:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
   19c5e:	7828      	ldrb	r0, [r5, #0]
   19c60:	4404      	add	r4, r0
   19c62:	702c      	strb	r4, [r5, #0]
}
   19c64:	bd38      	pop	{r3, r4, r5, pc}
   19c66:	bf00      	nop
   19c68:	20001058 	.word	0x20001058
   19c6c:	00030371 	.word	0x00030371
   19c70:	000303ac 	.word	0x000303ac
   19c74:	0002a5e8 	.word	0x0002a5e8

00019c78 <rx_alloc>:

	return done;
}

static inline void rx_alloc(u8_t max)
{
   19c78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u8_t idx;

#if defined(CONFIG_BT_CONN)
	while (mem_link_rx.quota_pdu &&
   19c7c:	4f34      	ldr	r7, [pc, #208]	; (19d50 <rx_alloc+0xd8>)
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   19c7e:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 19d5c <rx_alloc+0xe4>
{
   19c82:	4606      	mov	r6, r0
   19c84:	46b8      	mov	r8, r7
	while (mem_link_rx.quota_pdu &&
   19c86:	783b      	ldrb	r3, [r7, #0]
   19c88:	b1cb      	cbz	r3, 19cbe <rx_alloc+0x46>
 */
static inline bool mfifo_enqueue_idx_get(u8_t count, u8_t first, u8_t last,
					 u8_t *idx)
{
	/* Non-destructive: Advance write-index modulo 'count' */
	last = last + 1;
   19c8a:	f899 4003 	ldrb.w	r4, [r9, #3]
	if (last == count) {
   19c8e:	f899 2001 	ldrb.w	r2, [r9, #1]
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   19c92:	f899 3002 	ldrb.w	r3, [r9, #2]
	last = last + 1;
   19c96:	3401      	adds	r4, #1
   19c98:	b2e4      	uxtb	r4, r4
		last = 0U;
   19c9a:	42a2      	cmp	r2, r4
   19c9c:	bf08      	it	eq
   19c9e:	2400      	moveq	r4, #0
	 * We want to maintain the invariant of emptiness defined by
	 * first == last, but we just advanced a copy of the write-index before
	 * and may have wrapped. So if first == last the queue is full and we
	 * can not continue
	 */
	if (last == first) {
   19ca0:	42a3      	cmp	r3, r4
   19ca2:	d00c      	beq.n	19cbe <rx_alloc+0x46>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
   19ca4:	482b      	ldr	r0, [pc, #172]	; (19d54 <rx_alloc+0xdc>)
   19ca6:	f00e f9ed 	bl	28084 <mem_acquire>
		if (!link) {
   19caa:	4605      	mov	r5, r0
   19cac:	b138      	cbz	r0, 19cbe <rx_alloc+0x46>
			break;
		}

		rx = mem_acquire(&mem_pdu_rx.free);
   19cae:	482a      	ldr	r0, [pc, #168]	; (19d58 <rx_alloc+0xe0>)
   19cb0:	f00e f9e8 	bl	28084 <mem_acquire>
		if (!rx) {
   19cb4:	bb00      	cbnz	r0, 19cf8 <rx_alloc+0x80>
			mem_release(link, &mem_link_rx.free);
   19cb6:	4927      	ldr	r1, [pc, #156]	; (19d54 <rx_alloc+0xdc>)
   19cb8:	4628      	mov	r0, r5
   19cba:	f00e f9fc 	bl	280b6 <mem_release>

		ll_rx_link_inc_quota(-1);
	}
#endif /* CONFIG_BT_CONN */

	if (max > mem_link_rx.quota_pdu) {
   19cbe:	f898 0000 	ldrb.w	r0, [r8]

	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
   19cc2:	4f24      	ldr	r7, [pc, #144]	; (19d54 <rx_alloc+0xdc>)
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   19cc4:	f8df 8098 	ldr.w	r8, [pc, #152]	; 19d60 <rx_alloc+0xe8>
   19cc8:	4286      	cmp	r6, r0
   19cca:	bf28      	it	cs
   19ccc:	4606      	movcs	r6, r0
   19cce:	b18e      	cbz	r6, 19cf4 <rx_alloc+0x7c>
	last = last + 1;
   19cd0:	f898 4003 	ldrb.w	r4, [r8, #3]
	if (last == count) {
   19cd4:	f898 2001 	ldrb.w	r2, [r8, #1]
   19cd8:	f898 3002 	ldrb.w	r3, [r8, #2]
	last = last + 1;
   19cdc:	3401      	adds	r4, #1
   19cde:	b2e4      	uxtb	r4, r4
		last = 0U;
   19ce0:	42a2      	cmp	r2, r4
   19ce2:	bf08      	it	eq
   19ce4:	2400      	moveq	r4, #0
	if (last == first) {
   19ce6:	42a3      	cmp	r3, r4
   19ce8:	d004      	beq.n	19cf4 <rx_alloc+0x7c>
		link = mem_acquire(&mem_link_rx.free);
   19cea:	4638      	mov	r0, r7
   19cec:	f00e f9ca 	bl	28084 <mem_acquire>
		if (!link) {
   19cf0:	4605      	mov	r5, r0
   19cf2:	b990      	cbnz	r0, 19d1a <rx_alloc+0xa2>

		MFIFO_BY_IDX_ENQUEUE(pdu_rx_free, idx, rx);

		ll_rx_link_inc_quota(-1);
	}
}
   19cf4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		link->mem = NULL;
   19cf8:	2300      	movs	r3, #0
   19cfa:	606b      	str	r3, [r5, #4]
		rx->link = link;
   19cfc:	6005      	str	r5, [r0, #0]
 */
static inline void mfifo_by_idx_enqueue(u8_t *fifo, u8_t size, u8_t idx,
					void *mem, u8_t *last)
{
	/* API 2: fifo is array of void-ptrs */
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   19cfe:	f899 2003 	ldrb.w	r2, [r9, #3]
   19d02:	f899 3000 	ldrb.w	r3, [r9]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   19d06:	fb02 9303 	mla	r3, r2, r3, r9
   19d0a:	6058      	str	r0, [r3, #4]
		ll_rx_link_inc_quota(-1);
   19d0c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

	*last = idx; /* Commit: Update write index */
   19d10:	f889 4003 	strb.w	r4, [r9, #3]
   19d14:	f7ff ff8e 	bl	19c34 <ll_rx_link_inc_quota>
   19d18:	e7b5      	b.n	19c86 <rx_alloc+0xe>
		rx = mem_acquire(&mem_pdu_rx.free);
   19d1a:	480f      	ldr	r0, [pc, #60]	; (19d58 <rx_alloc+0xe0>)
   19d1c:	f00e f9b2 	bl	28084 <mem_acquire>
		if (!rx) {
   19d20:	b928      	cbnz	r0, 19d2e <rx_alloc+0xb6>
			mem_release(link, &mem_link_rx.free);
   19d22:	4628      	mov	r0, r5
   19d24:	490b      	ldr	r1, [pc, #44]	; (19d54 <rx_alloc+0xdc>)
}
   19d26:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			mem_release(link, &mem_link_rx.free);
   19d2a:	f00e b9c4 	b.w	280b6 <mem_release>
		rx->link = link;
   19d2e:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   19d30:	f898 2003 	ldrb.w	r2, [r8, #3]
   19d34:	f898 3000 	ldrb.w	r3, [r8]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   19d38:	fb02 8303 	mla	r3, r2, r3, r8
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   19d3c:	3e01      	subs	r6, #1
   19d3e:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
   19d40:	f888 4003 	strb.w	r4, [r8, #3]
		ll_rx_link_inc_quota(-1);
   19d44:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   19d48:	b2f6      	uxtb	r6, r6
		ll_rx_link_inc_quota(-1);
   19d4a:	f7ff ff73 	bl	19c34 <ll_rx_link_inc_quota>
   19d4e:	e7be      	b.n	19cce <rx_alloc+0x56>
   19d50:	20001058 	.word	0x20001058
   19d54:	2000105c 	.word	0x2000105c
   19d58:	200010a8 	.word	0x200010a8
   19d5c:	200070dc 	.word	0x200070dc
   19d60:	200070ec 	.word	0x200070ec

00019d64 <init_reset>:
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
   19d64:	4b3b      	ldr	r3, [pc, #236]	; (19e54 <init_reset+0xf0>)
{
   19d66:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
   19d6a:	1d18      	adds	r0, r3, #4
   19d6c:	2203      	movs	r2, #3
   19d6e:	2138      	movs	r1, #56	; 0x38
   19d70:	f00e f964 	bl	2803c <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
   19d74:	4b38      	ldr	r3, [pc, #224]	; (19e58 <init_reset+0xf4>)
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   19d76:	4f39      	ldr	r7, [pc, #228]	; (19e5c <init_reset+0xf8>)
		link = mem_acquire(&mem_link_done.free);
   19d78:	4e37      	ldr	r6, [pc, #220]	; (19e58 <init_reset+0xf4>)
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
   19d7a:	2203      	movs	r2, #3
   19d7c:	2108      	movs	r1, #8
   19d7e:	1d18      	adds	r0, r3, #4
   19d80:	f00e f95c 	bl	2803c <mem_init>
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   19d84:	46b8      	mov	r8, r7
	last = last + 1;
   19d86:	78fc      	ldrb	r4, [r7, #3]
	if (last == count) {
   19d88:	787a      	ldrb	r2, [r7, #1]
   19d8a:	78bb      	ldrb	r3, [r7, #2]
	last = last + 1;
   19d8c:	3401      	adds	r4, #1
   19d8e:	b2e4      	uxtb	r4, r4
		last = 0U;
   19d90:	42a2      	cmp	r2, r4
   19d92:	bf08      	it	eq
   19d94:	2400      	moveq	r4, #0
	if (last == first) {
   19d96:	429c      	cmp	r4, r3
   19d98:	d00d      	beq.n	19db6 <init_reset+0x52>
		link = mem_acquire(&mem_link_done.free);
   19d9a:	4630      	mov	r0, r6
   19d9c:	f00e f972 	bl	28084 <mem_acquire>
		if (!link) {
   19da0:	4605      	mov	r5, r0
   19da2:	b140      	cbz	r0, 19db6 <init_reset+0x52>
		rx = mem_acquire(&mem_done.free);
   19da4:	482b      	ldr	r0, [pc, #172]	; (19e54 <init_reset+0xf0>)
   19da6:	f00e f96d 	bl	28084 <mem_acquire>
		if (!rx) {
   19daa:	2800      	cmp	r0, #0
   19dac:	d146      	bne.n	19e3c <init_reset+0xd8>
			mem_release(link, &mem_link_done.free);
   19dae:	492a      	ldr	r1, [pc, #168]	; (19e58 <init_reset+0xf4>)
   19db0:	4628      	mov	r0, r5
   19db2:	f00e f980 	bl	280b6 <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
   19db6:	4b2a      	ldr	r3, [pc, #168]	; (19e60 <init_reset+0xfc>)
   19db8:	2207      	movs	r2, #7
   19dba:	1d18      	adds	r0, r3, #4
   19dbc:	2148      	movs	r1, #72	; 0x48
   19dbe:	f00e f93d 	bl	2803c <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
   19dc2:	4b28      	ldr	r3, [pc, #160]	; (19e64 <init_reset+0x100>)
   19dc4:	2209      	movs	r2, #9
   19dc6:	1d18      	adds	r0, r3, #4
   19dc8:	2108      	movs	r1, #8
   19dca:	f00e f937 	bl	2803c <mem_init>
	link = mem_acquire(&mem_link_rx.free);
   19dce:	4825      	ldr	r0, [pc, #148]	; (19e64 <init_reset+0x100>)
   19dd0:	f00e f958 	bl	28084 <mem_acquire>
	LL_ASSERT(link);
   19dd4:	4604      	mov	r4, r0
   19dd6:	b960      	cbnz	r0, 19df2 <init_reset+0x8e>
   19dd8:	4a23      	ldr	r2, [pc, #140]	; (19e68 <init_reset+0x104>)
   19dda:	4924      	ldr	r1, [pc, #144]	; (19e6c <init_reset+0x108>)
   19ddc:	4824      	ldr	r0, [pc, #144]	; (19e70 <init_reset+0x10c>)
   19dde:	f240 43af 	movw	r3, #1199	; 0x4af
   19de2:	f00a f87e 	bl	23ee2 <printk>
   19de6:	4040      	eors	r0, r0
   19de8:	f380 8811 	msr	BASEPRI, r0
   19dec:	f04f 0003 	mov.w	r0, #3
   19df0:	df02      	svc	2
	MEMQ_INIT(ull_rx, link);
   19df2:	4a20      	ldr	r2, [pc, #128]	; (19e74 <init_reset+0x110>)
   19df4:	4620      	mov	r0, r4
   19df6:	1f11      	subs	r1, r2, #4
   19df8:	f00e f994 	bl	28124 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
   19dfc:	4819      	ldr	r0, [pc, #100]	; (19e64 <init_reset+0x100>)
   19dfe:	f00e f941 	bl	28084 <mem_acquire>
	LL_ASSERT(link);
   19e02:	4604      	mov	r4, r0
   19e04:	b960      	cbnz	r0, 19e20 <init_reset+0xbc>
   19e06:	4a18      	ldr	r2, [pc, #96]	; (19e68 <init_reset+0x104>)
   19e08:	4918      	ldr	r1, [pc, #96]	; (19e6c <init_reset+0x108>)
   19e0a:	4819      	ldr	r0, [pc, #100]	; (19e70 <init_reset+0x10c>)
   19e0c:	f240 43b6 	movw	r3, #1206	; 0x4b6
   19e10:	f00a f867 	bl	23ee2 <printk>
   19e14:	4040      	eors	r0, r0
   19e16:	f380 8811 	msr	BASEPRI, r0
   19e1a:	f04f 0003 	mov.w	r0, #3
   19e1e:	df02      	svc	2
	MEMQ_INIT(ll_rx, link);
   19e20:	4a15      	ldr	r2, [pc, #84]	; (19e78 <init_reset+0x114>)
   19e22:	4620      	mov	r0, r4
   19e24:	1f11      	subs	r1, r2, #4
   19e26:	f00e f97d 	bl	28124 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
   19e2a:	4b14      	ldr	r3, [pc, #80]	; (19e7c <init_reset+0x118>)
   19e2c:	2206      	movs	r2, #6
	rx_alloc(UINT8_MAX);
   19e2e:	20ff      	movs	r0, #255	; 0xff
	mem_link_rx.quota_pdu = RX_CNT;
   19e30:	701a      	strb	r2, [r3, #0]
	rx_alloc(UINT8_MAX);
   19e32:	f7ff ff21 	bl	19c78 <rx_alloc>
}
   19e36:	2000      	movs	r0, #0
   19e38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx->link = link;
   19e3c:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   19e3e:	f898 2003 	ldrb.w	r2, [r8, #3]
   19e42:	f898 3000 	ldrb.w	r3, [r8]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   19e46:	fb02 8303 	mla	r3, r2, r3, r8
   19e4a:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
   19e4c:	f888 4003 	strb.w	r4, [r8, #3]
}
   19e50:	e799      	b.n	19d86 <init_reset+0x22>
   19e52:	bf00      	nop
   19e54:	20000f90 	.word	0x20000f90
   19e58:	2000103c 	.word	0x2000103c
   19e5c:	200070c8 	.word	0x200070c8
   19e60:	200010a8 	.word	0x200010a8
   19e64:	2000105c 	.word	0x2000105c
   19e68:	00030371 	.word	0x00030371
   19e6c:	0002fa18 	.word	0x0002fa18
   19e70:	0002a5e8 	.word	0x0002a5e8
   19e74:	200012b0 	.word	0x200012b0
   19e78:	200012a8 	.word	0x200012a8
   19e7c:	20001058 	.word	0x20001058

00019e80 <perform_lll_reset>:
{
   19e80:	b510      	push	{r4, lr}
   19e82:	4604      	mov	r4, r0
	err = lll_reset();
   19e84:	f00e fc80 	bl	28788 <lll_reset>
	LL_ASSERT(!err);
   19e88:	b160      	cbz	r0, 19ea4 <perform_lll_reset+0x24>
   19e8a:	4a21      	ldr	r2, [pc, #132]	; (19f10 <perform_lll_reset+0x90>)
   19e8c:	4921      	ldr	r1, [pc, #132]	; (19f14 <perform_lll_reset+0x94>)
   19e8e:	4822      	ldr	r0, [pc, #136]	; (19f18 <perform_lll_reset+0x98>)
   19e90:	f44f 6399 	mov.w	r3, #1224	; 0x4c8
   19e94:	f00a f825 	bl	23ee2 <printk>
   19e98:	4040      	eors	r0, r0
   19e9a:	f380 8811 	msr	BASEPRI, r0
   19e9e:	f04f 0003 	mov.w	r0, #3
   19ea2:	df02      	svc	2
	err = lll_adv_reset();
   19ea4:	f00e fd1a 	bl	288dc <lll_adv_reset>
	LL_ASSERT(!err);
   19ea8:	b160      	cbz	r0, 19ec4 <perform_lll_reset+0x44>
   19eaa:	4a19      	ldr	r2, [pc, #100]	; (19f10 <perform_lll_reset+0x90>)
   19eac:	4919      	ldr	r1, [pc, #100]	; (19f14 <perform_lll_reset+0x94>)
   19eae:	481a      	ldr	r0, [pc, #104]	; (19f18 <perform_lll_reset+0x98>)
   19eb0:	f240 43cd 	movw	r3, #1229	; 0x4cd
   19eb4:	f00a f815 	bl	23ee2 <printk>
   19eb8:	4040      	eors	r0, r0
   19eba:	f380 8811 	msr	BASEPRI, r0
   19ebe:	f04f 0003 	mov.w	r0, #3
   19ec2:	df02      	svc	2
	err = lll_scan_reset();
   19ec4:	f00e fd75 	bl	289b2 <lll_scan_reset>
	LL_ASSERT(!err);
   19ec8:	b160      	cbz	r0, 19ee4 <perform_lll_reset+0x64>
   19eca:	4a11      	ldr	r2, [pc, #68]	; (19f10 <perform_lll_reset+0x90>)
   19ecc:	4911      	ldr	r1, [pc, #68]	; (19f14 <perform_lll_reset+0x94>)
   19ece:	4812      	ldr	r0, [pc, #72]	; (19f18 <perform_lll_reset+0x98>)
   19ed0:	f240 43d3 	movw	r3, #1235	; 0x4d3
   19ed4:	f00a f805 	bl	23ee2 <printk>
   19ed8:	4040      	eors	r0, r0
   19eda:	f380 8811 	msr	BASEPRI, r0
   19ede:	f04f 0003 	mov.w	r0, #3
   19ee2:	df02      	svc	2
	err = lll_conn_reset();
   19ee4:	f00e fd8a 	bl	289fc <lll_conn_reset>
	LL_ASSERT(!err);
   19ee8:	b160      	cbz	r0, 19f04 <perform_lll_reset+0x84>
   19eea:	4a09      	ldr	r2, [pc, #36]	; (19f10 <perform_lll_reset+0x90>)
   19eec:	4909      	ldr	r1, [pc, #36]	; (19f14 <perform_lll_reset+0x94>)
   19eee:	480a      	ldr	r0, [pc, #40]	; (19f18 <perform_lll_reset+0x98>)
   19ef0:	f240 43d9 	movw	r3, #1241	; 0x4d9
   19ef4:	f009 fff5 	bl	23ee2 <printk>
   19ef8:	4040      	eors	r0, r0
   19efa:	f380 8811 	msr	BASEPRI, r0
   19efe:	f04f 0003 	mov.w	r0, #3
   19f02:	df02      	svc	2
	z_impl_k_sem_give(sem);
   19f04:	4620      	mov	r0, r4
}
   19f06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   19f0a:	f008 bbd1 	b.w	226b0 <z_impl_k_sem_give>
   19f0e:	bf00      	nop
   19f10:	00030371 	.word	0x00030371
   19f14:	000303e0 	.word	0x000303e0
   19f18:	0002a5e8 	.word	0x0002a5e8

00019f1c <tx_cmplt_get>:

#if defined(CONFIG_BT_CONN)
static u8_t tx_cmplt_get(u16_t *handle, u8_t *first, u8_t last)
{
   19f1c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   19f20:	460c      	mov	r4, r1
	struct lll_tx *tx;
	u8_t cmplt;

	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   19f22:	4e28      	ldr	r6, [pc, #160]	; (19fc4 <tx_cmplt_get+0xa8>)
					   u8_t first, u8_t last, u8_t *idx)
{
	void *p;
	u8_t i;

	if (*idx >= count) {
   19f24:	7823      	ldrb	r3, [r4, #0]
   19f26:	7871      	ldrb	r1, [r6, #1]
   19f28:	428b      	cmp	r3, r1
   19f2a:	bf28      	it	cs
   19f2c:	78b3      	ldrbcs	r3, [r6, #2]
{
   19f2e:	4680      	mov	r8, r0
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   19f30:	7830      	ldrb	r0, [r6, #0]
		*idx = first;
   19f32:	bf28      	it	cs
   19f34:	7023      	strbcs	r3, [r4, #0]
	}

	if (*idx == last) {
   19f36:	7823      	ldrb	r3, [r4, #0]
   19f38:	429a      	cmp	r2, r3
{
   19f3a:	4691      	mov	r9, r2
   19f3c:	d103      	bne.n	19f46 <tx_cmplt_get+0x2a>
				    mfifo_tx_ack.n, mfifo_tx_ack.f, last,
				    first);
	if (!tx) {
		return 0;
   19f3e:	2700      	movs	r7, #0
					    mfifo_tx_ack.n, mfifo_tx_ack.f,
					    last, first);
	} while (tx && tx->handle == *handle);

	return cmplt;
}
   19f40:	4638      	mov	r0, r7
   19f42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return NULL;
	}

	i = *idx + 1;
   19f46:	1c5a      	adds	r2, r3, #1
	if (i == count) {
		i = 0U;
	}

	p = (void *)(fifo + (*idx) * size);
   19f48:	4d1f      	ldr	r5, [pc, #124]	; (19fc8 <tx_cmplt_get+0xac>)
	i = *idx + 1;
   19f4a:	b2d2      	uxtb	r2, r2
		i = 0U;
   19f4c:	4291      	cmp	r1, r2
   19f4e:	bf08      	it	eq
   19f50:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
   19f52:	fb13 f300 	smulbb	r3, r3, r0

	*idx = i;
   19f56:	7022      	strb	r2, [r4, #0]
	if (!tx) {
   19f58:	18ea      	adds	r2, r5, r3
   19f5a:	d0f0      	beq.n	19f3e <tx_cmplt_get+0x22>
	*handle = tx->handle;
   19f5c:	5aeb      	ldrh	r3, [r5, r3]
   19f5e:	f8a8 3000 	strh.w	r3, [r8]
	cmplt = 0U;
   19f62:	2700      	movs	r7, #0
		node_tx = tx->node;
   19f64:	6850      	ldr	r0, [r2, #4]
		if (!node_tx || (node_tx == (void *)1) ||
   19f66:	2801      	cmp	r0, #1
   19f68:	f020 0103 	bic.w	r1, r0, #3
   19f6c:	d906      	bls.n	19f7c <tx_cmplt_get+0x60>
   19f6e:	b331      	cbz	r1, 19fbe <tx_cmplt_get+0xa2>
		     (p->ll_id == PDU_DATA_LLID_DATA_START ||
   19f70:	7903      	ldrb	r3, [r0, #4]
   19f72:	f003 0303 	and.w	r3, r3, #3
		    (((u32_t)node_tx & ~3) &&
   19f76:	3b01      	subs	r3, #1
   19f78:	2b01      	cmp	r3, #1
   19f7a:	d820      	bhi.n	19fbe <tx_cmplt_get+0xa2>
			cmplt++;
   19f7c:	3701      	adds	r7, #1
   19f7e:	b2ff      	uxtb	r7, r7
			tx->node = (void *)1;
   19f80:	2301      	movs	r3, #1
   19f82:	6053      	str	r3, [r2, #4]
		if (((u32_t)node_tx & ~3)) {
   19f84:	b109      	cbz	r1, 19f8a <tx_cmplt_get+0x6e>
			ll_tx_mem_release(node_tx);
   19f86:	f001 fbab 	bl	1b6e0 <ll_tx_mem_release>
	if (*idx >= count) {
   19f8a:	7823      	ldrb	r3, [r4, #0]
		tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   19f8c:	7872      	ldrb	r2, [r6, #1]
   19f8e:	7830      	ldrb	r0, [r6, #0]
   19f90:	4293      	cmp	r3, r2
   19f92:	bf24      	itt	cs
   19f94:	78b3      	ldrbcs	r3, [r6, #2]
		*idx = first;
   19f96:	7023      	strbcs	r3, [r4, #0]
	if (*idx == last) {
   19f98:	7823      	ldrb	r3, [r4, #0]
   19f9a:	4599      	cmp	r9, r3
   19f9c:	d0d0      	beq.n	19f40 <tx_cmplt_get+0x24>
	i = *idx + 1;
   19f9e:	1c59      	adds	r1, r3, #1
   19fa0:	b2c9      	uxtb	r1, r1
	p = (void *)(fifo + (*idx) * size);
   19fa2:	fb13 f300 	smulbb	r3, r3, r0
		i = 0U;
   19fa6:	428a      	cmp	r2, r1
   19fa8:	bf08      	it	eq
   19faa:	2100      	moveq	r1, #0
	} while (tx && tx->handle == *handle);
   19fac:	18ea      	adds	r2, r5, r3
	*idx = i;
   19fae:	7021      	strb	r1, [r4, #0]
   19fb0:	d0c6      	beq.n	19f40 <tx_cmplt_get+0x24>
   19fb2:	5ae9      	ldrh	r1, [r5, r3]
   19fb4:	f8b8 3000 	ldrh.w	r3, [r8]
   19fb8:	4299      	cmp	r1, r3
   19fba:	d0d3      	beq.n	19f64 <tx_cmplt_get+0x48>
   19fbc:	e7c0      	b.n	19f40 <tx_cmplt_get+0x24>
			tx->node = (void *)2;
   19fbe:	2302      	movs	r3, #2
   19fc0:	e7df      	b.n	19f82 <tx_cmplt_get+0x66>
   19fc2:	bf00      	nop
   19fc4:	20007228 	.word	0x20007228
   19fc8:	2000722c 	.word	0x2000722c

00019fcc <ll_init>:
{
   19fcc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	sem_recv = sem_rx;
   19fce:	4b27      	ldr	r3, [pc, #156]	; (1a06c <ll_init+0xa0>)
   19fd0:	6018      	str	r0, [r3, #0]
	cntr_init();
   19fd2:	f004 f98d 	bl	1e2f0 <cntr_init>
	mayfly_init();
   19fd6:	f7fe f857 	bl	18088 <mayfly_init>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
   19fda:	4a25      	ldr	r2, [pc, #148]	; (1a070 <ll_init+0xa4>)
   19fdc:	2103      	movs	r1, #3
   19fde:	7011      	strb	r1, [r2, #0]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_APP_OPS;
   19fe0:	7611      	strb	r1, [r2, #24]
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
   19fe2:	2002      	movs	r0, #2
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   19fe4:	4923      	ldr	r1, [pc, #140]	; (1a074 <ll_init+0xa8>)
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
   19fe6:	7410      	strb	r0, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
   19fe8:	2304      	movs	r3, #4
   19fea:	7213      	strb	r3, [r2, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   19fec:	9105      	str	r1, [sp, #20]
   19fee:	4922      	ldr	r1, [pc, #136]	; (1a078 <ll_init+0xac>)
   19ff0:	9104      	str	r1, [sp, #16]
   19ff2:	4922      	ldr	r1, [pc, #136]	; (1a07c <ll_init+0xb0>)
   19ff4:	9103      	str	r1, [sp, #12]
   19ff6:	4922      	ldr	r1, [pc, #136]	; (1a080 <ll_init+0xb4>)
   19ff8:	9102      	str	r1, [sp, #8]
   19ffa:	210c      	movs	r1, #12
   19ffc:	e9cd 2100 	strd	r2, r1, [sp]
   1a000:	2000      	movs	r0, #0
   1a002:	4a20      	ldr	r2, [pc, #128]	; (1a084 <ll_init+0xb8>)
   1a004:	2107      	movs	r1, #7
   1a006:	f7fe fddd 	bl	18bc4 <ticker_init>
	LL_ASSERT(!err);
   1a00a:	b160      	cbz	r0, 1a026 <ll_init+0x5a>
   1a00c:	4a1e      	ldr	r2, [pc, #120]	; (1a088 <ll_init+0xbc>)
   1a00e:	491f      	ldr	r1, [pc, #124]	; (1a08c <ll_init+0xc0>)
   1a010:	481f      	ldr	r0, [pc, #124]	; (1a090 <ll_init+0xc4>)
   1a012:	f44f 7388 	mov.w	r3, #272	; 0x110
   1a016:	f009 ff64 	bl	23ee2 <printk>
   1a01a:	4040      	eors	r0, r0
   1a01c:	f380 8811 	msr	BASEPRI, r0
   1a020:	f04f 0003 	mov.w	r0, #3
   1a024:	df02      	svc	2
	return z_impl_k_sem_init(sem, initial_count, limit);
   1a026:	2201      	movs	r2, #1
   1a028:	2100      	movs	r1, #0
   1a02a:	481a      	ldr	r0, [pc, #104]	; (1a094 <ll_init+0xc8>)
   1a02c:	f00f f954 	bl	292d8 <z_impl_k_sem_init>
	err = lll_init();
   1a030:	f002 fdee 	bl	1cc10 <lll_init>
	if (err) {
   1a034:	b9b0      	cbnz	r0, 1a064 <ll_init+0x98>
	err = init_reset();
   1a036:	f7ff fe95 	bl	19d64 <init_reset>
	if (err) {
   1a03a:	b998      	cbnz	r0, 1a064 <ll_init+0x98>
	err = lll_adv_init();
   1a03c:	f00e fc4c 	bl	288d8 <lll_adv_init>
	if (err) {
   1a040:	b980      	cbnz	r0, 1a064 <ll_init+0x98>
	err = ull_adv_init();
   1a042:	f00e fa11 	bl	28468 <ull_adv_init>
	if (err) {
   1a046:	b968      	cbnz	r0, 1a064 <ll_init+0x98>
	err = lll_scan_init();
   1a048:	f00e fcb1 	bl	289ae <lll_scan_init>
	if (err) {
   1a04c:	b950      	cbnz	r0, 1a064 <ll_init+0x98>
	err = ull_scan_init();
   1a04e:	f00e fa19 	bl	28484 <ull_scan_init>
	if (err) {
   1a052:	b938      	cbnz	r0, 1a064 <ll_init+0x98>
	err = lll_conn_init();
   1a054:	f00e fcd0 	bl	289f8 <lll_conn_init>
	if (err) {
   1a058:	b920      	cbnz	r0, 1a064 <ll_init+0x98>
}
   1a05a:	b007      	add	sp, #28
   1a05c:	f85d eb04 	ldr.w	lr, [sp], #4
	err = ull_conn_init();
   1a060:	f001 bba6 	b.w	1b7b0 <ull_conn_init>
}
   1a064:	b007      	add	sp, #28
   1a066:	f85d fb04 	ldr.w	pc, [sp], #4
   1a06a:	bf00      	nop
   1a06c:	200012b4 	.word	0x200012b4
   1a070:	20001628 	.word	0x20001628
   1a074:	00028bab 	.word	0x00028bab
   1a078:	0001eba5 	.word	0x0001eba5
   1a07c:	0001eb4d 	.word	0x0001eb4d
   1a080:	200013e8 	.word	0x200013e8
   1a084:	200012d0 	.word	0x200012d0
   1a088:	00030371 	.word	0x00030371
   1a08c:	000303e0 	.word	0x000303e0
   1a090:	0002a5e8 	.word	0x0002a5e8
   1a094:	200012b8 	.word	0x200012b8

0001a098 <ll_reset>:
{
   1a098:	b510      	push	{r4, lr}
   1a09a:	b086      	sub	sp, #24
	err = ull_adv_reset();
   1a09c:	f00e f9e6 	bl	2846c <ull_adv_reset>
	LL_ASSERT(!err);
   1a0a0:	b160      	cbz	r0, 1a0bc <ll_reset+0x24>
   1a0a2:	4a35      	ldr	r2, [pc, #212]	; (1a178 <ll_reset+0xe0>)
   1a0a4:	4935      	ldr	r1, [pc, #212]	; (1a17c <ll_reset+0xe4>)
   1a0a6:	4836      	ldr	r0, [pc, #216]	; (1a180 <ll_reset+0xe8>)
   1a0a8:	f44f 73af 	mov.w	r3, #350	; 0x15e
   1a0ac:	f009 ff19 	bl	23ee2 <printk>
   1a0b0:	4040      	eors	r0, r0
   1a0b2:	f380 8811 	msr	BASEPRI, r0
   1a0b6:	f04f 0003 	mov.w	r0, #3
   1a0ba:	df02      	svc	2
	err = ull_scan_reset();
   1a0bc:	f00e f9f8 	bl	284b0 <ull_scan_reset>
	LL_ASSERT(!err);
   1a0c0:	b160      	cbz	r0, 1a0dc <ll_reset+0x44>
   1a0c2:	4a2d      	ldr	r2, [pc, #180]	; (1a178 <ll_reset+0xe0>)
   1a0c4:	492d      	ldr	r1, [pc, #180]	; (1a17c <ll_reset+0xe4>)
   1a0c6:	482e      	ldr	r0, [pc, #184]	; (1a180 <ll_reset+0xe8>)
   1a0c8:	f44f 73b2 	mov.w	r3, #356	; 0x164
   1a0cc:	f009 ff09 	bl	23ee2 <printk>
   1a0d0:	4040      	eors	r0, r0
   1a0d2:	f380 8811 	msr	BASEPRI, r0
   1a0d6:	f04f 0003 	mov.w	r0, #3
   1a0da:	df02      	svc	2
	err = ull_conn_reset();
   1a0dc:	f001 fb76 	bl	1b7cc <ull_conn_reset>
	LL_ASSERT(!err);
   1a0e0:	b160      	cbz	r0, 1a0fc <ll_reset+0x64>
   1a0e2:	4a25      	ldr	r2, [pc, #148]	; (1a178 <ll_reset+0xe0>)
   1a0e4:	4925      	ldr	r1, [pc, #148]	; (1a17c <ll_reset+0xe4>)
   1a0e6:	4826      	ldr	r0, [pc, #152]	; (1a180 <ll_reset+0xe8>)
   1a0e8:	f44f 73bf 	mov.w	r3, #382	; 0x17e
   1a0ec:	f009 fef9 	bl	23ee2 <printk>
   1a0f0:	4040      	eors	r0, r0
   1a0f2:	f380 8811 	msr	BASEPRI, r0
   1a0f6:	f04f 0003 	mov.w	r0, #3
   1a0fa:	df02      	svc	2
	MFIFO_INIT(tx_ack);
   1a0fc:	4b21      	ldr	r3, [pc, #132]	; (1a184 <ll_reset+0xec>)
   1a0fe:	2400      	movs	r4, #0
   1a100:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(prep);
   1a102:	4b21      	ldr	r3, [pc, #132]	; (1a188 <ll_reset+0xf0>)
   1a104:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(done);
   1a106:	4b21      	ldr	r3, [pc, #132]	; (1a18c <ll_reset+0xf4>)
   1a108:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(pdu_rx_free);
   1a10a:	4b21      	ldr	r3, [pc, #132]	; (1a190 <ll_reset+0xf8>)
   1a10c:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(ll_pdu_rx_free);
   1a10e:	4b21      	ldr	r3, [pc, #132]	; (1a194 <ll_reset+0xfc>)
   1a110:	805c      	strh	r4, [r3, #2]
   1a112:	2201      	movs	r2, #1
   1a114:	4621      	mov	r1, r4
   1a116:	4668      	mov	r0, sp
   1a118:	f00f f8de 	bl	292d8 <z_impl_k_sem_init>
		mfy.param = &sem;
   1a11c:	4b1e      	ldr	r3, [pc, #120]	; (1a198 <ll_reset+0x100>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   1a11e:	4622      	mov	r2, r4
   1a120:	4621      	mov	r1, r4
   1a122:	2003      	movs	r0, #3
		mfy.param = &sem;
   1a124:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   1a128:	f7fe f800 	bl	1812c <mayfly_enqueue>
		LL_ASSERT(!retval);
   1a12c:	b160      	cbz	r0, 1a148 <ll_reset+0xb0>
   1a12e:	4a12      	ldr	r2, [pc, #72]	; (1a178 <ll_reset+0xe0>)
   1a130:	491a      	ldr	r1, [pc, #104]	; (1a19c <ll_reset+0x104>)
   1a132:	4813      	ldr	r0, [pc, #76]	; (1a180 <ll_reset+0xe8>)
   1a134:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
   1a138:	f009 fed3 	bl	23ee2 <printk>
   1a13c:	4040      	eors	r0, r0
   1a13e:	f380 8811 	msr	BASEPRI, r0
   1a142:	f04f 0003 	mov.w	r0, #3
   1a146:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   1a148:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1a14c:	4668      	mov	r0, sp
   1a14e:	f008 faf3 	bl	22738 <z_impl_k_sem_take>
	err = init_reset();
   1a152:	f7ff fe07 	bl	19d64 <init_reset>
	LL_ASSERT(!err);
   1a156:	b160      	cbz	r0, 1a172 <ll_reset+0xda>
   1a158:	4a07      	ldr	r2, [pc, #28]	; (1a178 <ll_reset+0xe0>)
   1a15a:	4908      	ldr	r1, [pc, #32]	; (1a17c <ll_reset+0xe4>)
   1a15c:	4808      	ldr	r0, [pc, #32]	; (1a180 <ll_reset+0xe8>)
   1a15e:	f44f 73de 	mov.w	r3, #444	; 0x1bc
   1a162:	f009 febe 	bl	23ee2 <printk>
   1a166:	4040      	eors	r0, r0
   1a168:	f380 8811 	msr	BASEPRI, r0
   1a16c:	f04f 0003 	mov.w	r0, #3
   1a170:	df02      	svc	2
}
   1a172:	b006      	add	sp, #24
   1a174:	bd10      	pop	{r4, pc}
   1a176:	bf00      	nop
   1a178:	00030371 	.word	0x00030371
   1a17c:	000303e0 	.word	0x000303e0
   1a180:	0002a5e8 	.word	0x0002a5e8
   1a184:	20007228 	.word	0x20007228
   1a188:	20007104 	.word	0x20007104
   1a18c:	200070c8 	.word	0x200070c8
   1a190:	200070ec 	.word	0x200070ec
   1a194:	200070dc 	.word	0x200070dc
   1a198:	2000724c 	.word	0x2000724c
   1a19c:	000303e5 	.word	0x000303e5

0001a1a0 <ll_rx_get>:
{
   1a1a0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
   1a1a4:	4f25      	ldr	r7, [pc, #148]	; (1a23c <ll_rx_get+0x9c>)
   1a1a6:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 1a24c <ll_rx_get+0xac>
{
   1a1aa:	4605      	mov	r5, r0
   1a1ac:	460c      	mov	r4, r1
   1a1ae:	46b9      	mov	r9, r7
	*node_rx = NULL;
   1a1b0:	2300      	movs	r3, #0
   1a1b2:	602b      	str	r3, [r5, #0]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
   1a1b4:	e9d7 0100 	ldrd	r0, r1, [r7]
   1a1b8:	aa01      	add	r2, sp, #4
   1a1ba:	f00d ffc8 	bl	2814e <memq_peek>
	if (link) {
   1a1be:	4606      	mov	r6, r0
   1a1c0:	b3a8      	cbz	r0, 1a22e <ll_rx_get+0x8e>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
   1a1c2:	9b01      	ldr	r3, [sp, #4]
   1a1c4:	491e      	ldr	r1, [pc, #120]	; (1a240 <ll_rx_get+0xa0>)
   1a1c6:	781a      	ldrb	r2, [r3, #0]
   1a1c8:	4620      	mov	r0, r4
   1a1ca:	f7ff fea7 	bl	19f1c <tx_cmplt_get>
		if (!cmplt) {
   1a1ce:	bb58      	cbnz	r0, 1a228 <ll_rx_get+0x88>
			f = mfifo_tx_ack.f;
   1a1d0:	f898 3002 	ldrb.w	r3, [r8, #2]
   1a1d4:	f88d 3001 	strb.w	r3, [sp, #1]
				cmplt_curr = tx_cmplt_get(&h, &f,
   1a1d8:	f898 2003 	ldrb.w	r2, [r8, #3]
   1a1dc:	4682      	mov	sl, r0
   1a1de:	f10d 0101 	add.w	r1, sp, #1
   1a1e2:	f10d 0002 	add.w	r0, sp, #2
   1a1e6:	f7ff fe99 	bl	19f1c <tx_cmplt_get>
			} while ((cmplt_prev != 0U) ||
   1a1ea:	ea4a 0200 	orr.w	r2, sl, r0
   1a1ee:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
   1a1f2:	d1f1      	bne.n	1a1d8 <ll_rx_get+0x38>
			if (rx->type == NODE_RX_TYPE_DC_PDU_RELEASE) {
   1a1f4:	9b01      	ldr	r3, [sp, #4]
   1a1f6:	7919      	ldrb	r1, [r3, #4]
   1a1f8:	2903      	cmp	r1, #3
   1a1fa:	d113      	bne.n	1a224 <ll_rx_get+0x84>
				(void)memq_dequeue(memq_ll_rx.tail,
   1a1fc:	4639      	mov	r1, r7
   1a1fe:	f8d9 0004 	ldr.w	r0, [r9, #4]
   1a202:	f00d ffac 	bl	2815e <memq_dequeue>
				mem_release(link, &mem_link_rx.free);
   1a206:	490f      	ldr	r1, [pc, #60]	; (1a244 <ll_rx_get+0xa4>)
   1a208:	4630      	mov	r0, r6
   1a20a:	f00d ff54 	bl	280b6 <mem_release>
				ll_rx_link_inc_quota(1);
   1a20e:	2001      	movs	r0, #1
   1a210:	f7ff fd10 	bl	19c34 <ll_rx_link_inc_quota>
				mem_release(rx, &mem_pdu_rx.free);
   1a214:	9801      	ldr	r0, [sp, #4]
   1a216:	490c      	ldr	r1, [pc, #48]	; (1a248 <ll_rx_get+0xa8>)
   1a218:	f00d ff4d 	bl	280b6 <mem_release>
				rx_alloc(1);
   1a21c:	2001      	movs	r0, #1
   1a21e:	f7ff fd2b 	bl	19c78 <rx_alloc>
				goto ll_rx_get_again;
   1a222:	e7c5      	b.n	1a1b0 <ll_rx_get+0x10>
			*node_rx = rx;
   1a224:	602b      	str	r3, [r5, #0]
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
   1a226:	4610      	mov	r0, r2
}
   1a228:	b002      	add	sp, #8
   1a22a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, mfifo_tx_ack.l);
   1a22e:	f898 2003 	ldrb.w	r2, [r8, #3]
   1a232:	4903      	ldr	r1, [pc, #12]	; (1a240 <ll_rx_get+0xa0>)
   1a234:	4620      	mov	r0, r4
   1a236:	f7ff fe71 	bl	19f1c <tx_cmplt_get>
   1a23a:	e7f5      	b.n	1a228 <ll_rx_get+0x88>
   1a23c:	200012a4 	.word	0x200012a4
   1a240:	2000722a 	.word	0x2000722a
   1a244:	2000105c 	.word	0x2000105c
   1a248:	200010a8 	.word	0x200010a8
   1a24c:	20007228 	.word	0x20007228

0001a250 <ll_rx_dequeue>:
{
   1a250:	b573      	push	{r0, r1, r4, r5, r6, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1a252:	494b      	ldr	r1, [pc, #300]	; (1a380 <ll_rx_dequeue+0x130>)
	struct node_rx_hdr *rx = NULL;
   1a254:	2300      	movs	r3, #0
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1a256:	6848      	ldr	r0, [r1, #4]
	struct node_rx_hdr *rx = NULL;
   1a258:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1a25a:	aa01      	add	r2, sp, #4
   1a25c:	f00d ff7f 	bl	2815e <memq_dequeue>
	LL_ASSERT(link);
   1a260:	4604      	mov	r4, r0
   1a262:	b960      	cbnz	r0, 1a27e <ll_rx_dequeue+0x2e>
   1a264:	4a47      	ldr	r2, [pc, #284]	; (1a384 <ll_rx_dequeue+0x134>)
   1a266:	4948      	ldr	r1, [pc, #288]	; (1a388 <ll_rx_dequeue+0x138>)
   1a268:	4848      	ldr	r0, [pc, #288]	; (1a38c <ll_rx_dequeue+0x13c>)
   1a26a:	f240 230e 	movw	r3, #526	; 0x20e
   1a26e:	f009 fe38 	bl	23ee2 <printk>
   1a272:	4040      	eors	r0, r0
   1a274:	f380 8811 	msr	BASEPRI, r0
   1a278:	f04f 0003 	mov.w	r0, #3
   1a27c:	df02      	svc	2
	mem_release(link, &mem_link_rx.free);
   1a27e:	4944      	ldr	r1, [pc, #272]	; (1a390 <ll_rx_dequeue+0x140>)
   1a280:	4620      	mov	r0, r4
   1a282:	f00d ff18 	bl	280b6 <mem_release>
	switch (rx->type) {
   1a286:	9b01      	ldr	r3, [sp, #4]
   1a288:	791a      	ldrb	r2, [r3, #4]
   1a28a:	2a0d      	cmp	r2, #13
   1a28c:	d875      	bhi.n	1a37a <ll_rx_dequeue+0x12a>
   1a28e:	e8df f002 	tbb	[pc, r2]
   1a292:	7464      	.short	0x7464
   1a294:	74647464 	.word	0x74647464
   1a298:	64077474 	.word	0x64077474
   1a29c:	64746464 	.word	0x64746464
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
   1a2a0:	f893 2020 	ldrb.w	r2, [r3, #32]
   1a2a4:	2a3c      	cmp	r2, #60	; 0x3c
   1a2a6:	d003      	beq.n	1a2b0 <ll_rx_dequeue+0x60>
   1a2a8:	f893 1021 	ldrb.w	r1, [r3, #33]	; 0x21
   1a2ac:	2900      	cmp	r1, #0
   1a2ae:	d04f      	beq.n	1a350 <ll_rx_dequeue+0x100>
			struct lll_adv *lll = ftr->param;
   1a2b0:	689e      	ldr	r6, [r3, #8]
			if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   1a2b2:	2a3c      	cmp	r2, #60	; 0x3c
			struct ll_adv_set *adv = (void *)HDR_LLL2EVT(lll);
   1a2b4:	6835      	ldr	r5, [r6, #0]
			if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   1a2b6:	d140      	bne.n	1a33a <ll_rx_dequeue+0xea>
				conn_lll = lll->conn;
   1a2b8:	68b4      	ldr	r4, [r6, #8]
				LL_ASSERT(conn_lll);
   1a2ba:	b964      	cbnz	r4, 1a2d6 <ll_rx_dequeue+0x86>
   1a2bc:	4a31      	ldr	r2, [pc, #196]	; (1a384 <ll_rx_dequeue+0x134>)
   1a2be:	4935      	ldr	r1, [pc, #212]	; (1a394 <ll_rx_dequeue+0x144>)
   1a2c0:	4832      	ldr	r0, [pc, #200]	; (1a38c <ll_rx_dequeue+0x13c>)
   1a2c2:	f240 2327 	movw	r3, #551	; 0x227
   1a2c6:	f009 fe0c 	bl	23ee2 <printk>
   1a2ca:	4040      	eors	r0, r0
   1a2cc:	f380 8811 	msr	BASEPRI, r0
   1a2d0:	f04f 0003 	mov.w	r0, #3
   1a2d4:	df02      	svc	2
				lll->conn = NULL;
   1a2d6:	2300      	movs	r3, #0
   1a2d8:	60b3      	str	r3, [r6, #8]
				LL_ASSERT(!conn_lll->link_tx_free);
   1a2da:	6d23      	ldr	r3, [r4, #80]	; 0x50
   1a2dc:	b163      	cbz	r3, 1a2f8 <ll_rx_dequeue+0xa8>
   1a2de:	4a29      	ldr	r2, [pc, #164]	; (1a384 <ll_rx_dequeue+0x134>)
   1a2e0:	492d      	ldr	r1, [pc, #180]	; (1a398 <ll_rx_dequeue+0x148>)
   1a2e2:	482a      	ldr	r0, [pc, #168]	; (1a38c <ll_rx_dequeue+0x13c>)
   1a2e4:	f240 232a 	movw	r3, #554	; 0x22a
   1a2e8:	f009 fdfb 	bl	23ee2 <printk>
   1a2ec:	4040      	eors	r0, r0
   1a2ee:	f380 8811 	msr	BASEPRI, r0
   1a2f2:	f04f 0003 	mov.w	r0, #3
   1a2f6:	df02      	svc	2
				link = memq_deinit(&conn_lll->memq_tx.head,
   1a2f8:	f104 0144 	add.w	r1, r4, #68	; 0x44
   1a2fc:	f104 0040 	add.w	r0, r4, #64	; 0x40
   1a300:	f00d ff13 	bl	2812a <memq_deinit>
				LL_ASSERT(link);
   1a304:	4606      	mov	r6, r0
   1a306:	b960      	cbnz	r0, 1a322 <ll_rx_dequeue+0xd2>
   1a308:	4a1e      	ldr	r2, [pc, #120]	; (1a384 <ll_rx_dequeue+0x134>)
   1a30a:	491f      	ldr	r1, [pc, #124]	; (1a388 <ll_rx_dequeue+0x138>)
   1a30c:	481f      	ldr	r0, [pc, #124]	; (1a38c <ll_rx_dequeue+0x13c>)
   1a30e:	f240 232d 	movw	r3, #557	; 0x22d
   1a312:	f009 fde6 	bl	23ee2 <printk>
   1a316:	4040      	eors	r0, r0
   1a318:	f380 8811 	msr	BASEPRI, r0
   1a31c:	f04f 0003 	mov.w	r0, #3
   1a320:	df02      	svc	2
				ll_conn_release(conn);
   1a322:	6820      	ldr	r0, [r4, #0]
				conn_lll->link_tx_free = link;
   1a324:	6526      	str	r6, [r4, #80]	; 0x50
				ll_conn_release(conn);
   1a326:	f001 f951 	bl	1b5cc <ll_conn_release>
			adv->is_enabled = 0U;
   1a32a:	f895 30cc 	ldrb.w	r3, [r5, #204]	; 0xcc
   1a32e:	f36f 0300 	bfc	r3, #0, #1
   1a332:	f885 30cc 	strb.w	r3, [r5, #204]	; 0xcc
}
   1a336:	b002      	add	sp, #8
   1a338:	bd70      	pop	{r4, r5, r6, pc}
				if (adv->node_rx_cc_free) {
   1a33a:	f8d5 00d4 	ldr.w	r0, [r5, #212]	; 0xd4
   1a33e:	2800      	cmp	r0, #0
   1a340:	d0f3      	beq.n	1a32a <ll_rx_dequeue+0xda>
					adv->node_rx_cc_free = NULL;
   1a342:	2300      	movs	r3, #0
					mem_release(rx_free, &mem_pdu_rx.free);
   1a344:	4915      	ldr	r1, [pc, #84]	; (1a39c <ll_rx_dequeue+0x14c>)
					adv->node_rx_cc_free = NULL;
   1a346:	f8c5 30d4 	str.w	r3, [r5, #212]	; 0xd4
					mem_release(rx_free, &mem_pdu_rx.free);
   1a34a:	f00d feb4 	bl	280b6 <mem_release>
   1a34e:	e7ec      	b.n	1a32a <ll_rx_dequeue+0xda>
			LL_ASSERT(0);
   1a350:	f240 2349 	movw	r3, #585	; 0x249
		LL_ASSERT(0);
   1a354:	4a0b      	ldr	r2, [pc, #44]	; (1a384 <ll_rx_dequeue+0x134>)
   1a356:	4912      	ldr	r1, [pc, #72]	; (1a3a0 <ll_rx_dequeue+0x150>)
   1a358:	e005      	b.n	1a366 <ll_rx_dequeue+0x116>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
   1a35a:	2a00      	cmp	r2, #0
   1a35c:	d1eb      	bne.n	1a336 <ll_rx_dequeue+0xe6>
   1a35e:	4a09      	ldr	r2, [pc, #36]	; (1a384 <ll_rx_dequeue+0x134>)
   1a360:	4910      	ldr	r1, [pc, #64]	; (1a3a4 <ll_rx_dequeue+0x154>)
   1a362:	f240 239a 	movw	r3, #666	; 0x29a
		LL_ASSERT(0);
   1a366:	4809      	ldr	r0, [pc, #36]	; (1a38c <ll_rx_dequeue+0x13c>)
   1a368:	f009 fdbb 	bl	23ee2 <printk>
   1a36c:	4040      	eors	r0, r0
   1a36e:	f380 8811 	msr	BASEPRI, r0
   1a372:	f04f 0003 	mov.w	r0, #3
   1a376:	df02      	svc	2
}
   1a378:	e7dd      	b.n	1a336 <ll_rx_dequeue+0xe6>
		LL_ASSERT(0);
   1a37a:	f240 239e 	movw	r3, #670	; 0x29e
   1a37e:	e7e9      	b.n	1a354 <ll_rx_dequeue+0x104>
   1a380:	200012a4 	.word	0x200012a4
   1a384:	00030371 	.word	0x00030371
   1a388:	0002fa18 	.word	0x0002fa18
   1a38c:	0002a5e8 	.word	0x0002a5e8
   1a390:	2000105c 	.word	0x2000105c
   1a394:	000303ed 	.word	0x000303ed
   1a398:	000303f6 	.word	0x000303f6
   1a39c:	200010a8 	.word	0x200010a8
   1a3a0:	0002e3c9 	.word	0x0002e3c9
   1a3a4:	0003040e 	.word	0x0003040e

0001a3a8 <ll_rx_mem_release>:
{
   1a3a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx = *node_rx;
   1a3ac:	6804      	ldr	r4, [r0, #0]
			LL_ASSERT(0);
   1a3ae:	4d40      	ldr	r5, [pc, #256]	; (1a4b0 <ll_rx_mem_release+0x108>)
   1a3b0:	f8df 9118 	ldr.w	r9, [pc, #280]	; 1a4cc <ll_rx_mem_release+0x124>
   1a3b4:	4e3f      	ldr	r6, [pc, #252]	; (1a4b4 <ll_rx_mem_release+0x10c>)
{
   1a3b6:	4607      	mov	r7, r0
	while (rx) {
   1a3b8:	b92c      	cbnz	r4, 1a3c6 <ll_rx_mem_release+0x1e>
	*node_rx = rx;
   1a3ba:	603c      	str	r4, [r7, #0]
	rx_alloc(UINT8_MAX);
   1a3bc:	20ff      	movs	r0, #255	; 0xff
}
   1a3be:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx_alloc(UINT8_MAX);
   1a3c2:	f7ff bc59 	b.w	19c78 <rx_alloc>
		rx = rx->next;
   1a3c6:	7923      	ldrb	r3, [r4, #4]
   1a3c8:	f8d4 a000 	ldr.w	sl, [r4]
		switch (rx_free->type) {
   1a3cc:	2b0d      	cmp	r3, #13
   1a3ce:	d861      	bhi.n	1a494 <ll_rx_mem_release+0xec>
   1a3d0:	e8df f003 	tbb	[pc, r3]
   1a3d4:	601f601f 	.word	0x601f601f
   1a3d8:	6060601f 	.word	0x6060601f
   1a3dc:	1f1f3207 	.word	0x1f1f3207
   1a3e0:	1f60      	.short	0x1f60
			} else if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   1a3e2:	f894 3020 	ldrb.w	r3, [r4, #32]
   1a3e6:	2b3c      	cmp	r3, #60	; 0x3c
   1a3e8:	d105      	bne.n	1a3f6 <ll_rx_mem_release+0x4e>
			mem_release(rx_free, &mem_pdu_rx.free);
   1a3ea:	4933      	ldr	r1, [pc, #204]	; (1a4b8 <ll_rx_mem_release+0x110>)
   1a3ec:	4620      	mov	r0, r4
   1a3ee:	f00d fe62 	bl	280b6 <mem_release>
{
   1a3f2:	4654      	mov	r4, sl
   1a3f4:	e7e0      	b.n	1a3b8 <ll_rx_mem_release+0x10>
				LL_ASSERT(!cc->status);
   1a3f6:	b163      	cbz	r3, 1a412 <ll_rx_mem_release+0x6a>
   1a3f8:	4930      	ldr	r1, [pc, #192]	; (1a4bc <ll_rx_mem_release+0x114>)
   1a3fa:	f240 23f6 	movw	r3, #758	; 0x2f6
   1a3fe:	462a      	mov	r2, r5
   1a400:	4630      	mov	r0, r6
   1a402:	f009 fd6e 	bl	23ee2 <printk>
   1a406:	4040      	eors	r0, r0
   1a408:	f380 8811 	msr	BASEPRI, r0
   1a40c:	f04f 0003 	mov.w	r0, #3
   1a410:	df02      	svc	2
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
   1a412:	7923      	ldrb	r3, [r4, #4]
   1a414:	b963      	cbnz	r3, 1a430 <ll_rx_mem_release+0x88>
   1a416:	492a      	ldr	r1, [pc, #168]	; (1a4c0 <ll_rx_mem_release+0x118>)
   1a418:	f240 3337 	movw	r3, #823	; 0x337
   1a41c:	462a      	mov	r2, r5
   1a41e:	4630      	mov	r0, r6
   1a420:	f009 fd5f 	bl	23ee2 <printk>
   1a424:	4040      	eors	r0, r0
   1a426:	f380 8811 	msr	BASEPRI, r0
   1a42a:	f04f 0003 	mov.w	r0, #3
   1a42e:	df02      	svc	2
			ll_rx_link_inc_quota(1);
   1a430:	2001      	movs	r0, #1
   1a432:	f7ff fbff 	bl	19c34 <ll_rx_link_inc_quota>
   1a436:	e7d8      	b.n	1a3ea <ll_rx_mem_release+0x42>
			conn = ll_conn_get(rx_free->handle);
   1a438:	88e0      	ldrh	r0, [r4, #6]
   1a43a:	f001 f943 	bl	1b6c4 <ll_conn_get>
			LL_ASSERT(!conn->lll.link_tx_free);
   1a43e:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
			conn = ll_conn_get(rx_free->handle);
   1a440:	4604      	mov	r4, r0
			LL_ASSERT(!conn->lll.link_tx_free);
   1a442:	b163      	cbz	r3, 1a45e <ll_rx_mem_release+0xb6>
   1a444:	491f      	ldr	r1, [pc, #124]	; (1a4c4 <ll_rx_mem_release+0x11c>)
   1a446:	f44f 7351 	mov.w	r3, #836	; 0x344
   1a44a:	462a      	mov	r2, r5
   1a44c:	4630      	mov	r0, r6
   1a44e:	f009 fd48 	bl	23ee2 <printk>
   1a452:	4040      	eors	r0, r0
   1a454:	f380 8811 	msr	BASEPRI, r0
   1a458:	f04f 0003 	mov.w	r0, #3
   1a45c:	df02      	svc	2
			link = memq_deinit(&conn->lll.memq_tx.head,
   1a45e:	f104 0160 	add.w	r1, r4, #96	; 0x60
   1a462:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   1a466:	f00d fe60 	bl	2812a <memq_deinit>
			LL_ASSERT(link);
   1a46a:	4680      	mov	r8, r0
   1a46c:	b960      	cbnz	r0, 1a488 <ll_rx_mem_release+0xe0>
   1a46e:	4916      	ldr	r1, [pc, #88]	; (1a4c8 <ll_rx_mem_release+0x120>)
   1a470:	f240 3347 	movw	r3, #839	; 0x347
   1a474:	462a      	mov	r2, r5
   1a476:	4630      	mov	r0, r6
   1a478:	f009 fd33 	bl	23ee2 <printk>
   1a47c:	4040      	eors	r0, r0
   1a47e:	f380 8811 	msr	BASEPRI, r0
   1a482:	f04f 0003 	mov.w	r0, #3
   1a486:	df02      	svc	2
			conn->lll.link_tx_free = link;
   1a488:	f8c4 806c 	str.w	r8, [r4, #108]	; 0x6c
			ll_conn_release(conn);
   1a48c:	4620      	mov	r0, r4
   1a48e:	f001 f89d 	bl	1b5cc <ll_conn_release>
		break;
   1a492:	e7ae      	b.n	1a3f2 <ll_rx_mem_release+0x4a>
			LL_ASSERT(0);
   1a494:	f240 3351 	movw	r3, #849	; 0x351
   1a498:	462a      	mov	r2, r5
   1a49a:	4649      	mov	r1, r9
   1a49c:	4630      	mov	r0, r6
   1a49e:	f009 fd20 	bl	23ee2 <printk>
   1a4a2:	4040      	eors	r0, r0
   1a4a4:	f380 8811 	msr	BASEPRI, r0
   1a4a8:	f04f 0003 	mov.w	r0, #3
   1a4ac:	df02      	svc	2
			break;
   1a4ae:	e7a0      	b.n	1a3f2 <ll_rx_mem_release+0x4a>
   1a4b0:	00030371 	.word	0x00030371
   1a4b4:	0002a5e8 	.word	0x0002a5e8
   1a4b8:	200010a8 	.word	0x200010a8
   1a4bc:	0003042c 	.word	0x0003042c
   1a4c0:	00030438 	.word	0x00030438
   1a4c4:	0003045b 	.word	0x0003045b
   1a4c8:	0002fa18 	.word	0x0002fa18
   1a4cc:	0002e3c9 	.word	0x0002e3c9

0001a4d0 <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
   1a4d0:	4801      	ldr	r0, [pc, #4]	; (1a4d8 <ll_rx_link_alloc+0x8>)
   1a4d2:	f00d bdd7 	b.w	28084 <mem_acquire>
   1a4d6:	bf00      	nop
   1a4d8:	2000105c 	.word	0x2000105c

0001a4dc <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
   1a4dc:	4901      	ldr	r1, [pc, #4]	; (1a4e4 <ll_rx_link_release+0x8>)
   1a4de:	f00d bdea 	b.w	280b6 <mem_release>
   1a4e2:	bf00      	nop
   1a4e4:	2000105c 	.word	0x2000105c

0001a4e8 <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
   1a4e8:	4801      	ldr	r0, [pc, #4]	; (1a4f0 <ll_rx_alloc+0x8>)
   1a4ea:	f00d bdcb 	b.w	28084 <mem_acquire>
   1a4ee:	bf00      	nop
   1a4f0:	200010a8 	.word	0x200010a8

0001a4f4 <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
   1a4f4:	4901      	ldr	r1, [pc, #4]	; (1a4fc <ll_rx_release+0x8>)
   1a4f6:	f00d bdde 	b.w	280b6 <mem_release>
   1a4fa:	bf00      	nop
   1a4fc:	200010a8 	.word	0x200010a8

0001a500 <ll_rx_put>:
	rx_hdr->ack_last = mfifo_tx_ack.l;
   1a500:	4b02      	ldr	r3, [pc, #8]	; (1a50c <ll_rx_put+0xc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   1a502:	4a03      	ldr	r2, [pc, #12]	; (1a510 <ll_rx_put+0x10>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
   1a504:	78db      	ldrb	r3, [r3, #3]
   1a506:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   1a508:	f00d be1a 	b.w	28140 <memq_enqueue>
   1a50c:	20007228 	.word	0x20007228
   1a510:	200012a8 	.word	0x200012a8

0001a514 <ll_rx_sched>:
	k_sem_give(sem_recv);
   1a514:	4b01      	ldr	r3, [pc, #4]	; (1a51c <ll_rx_sched+0x8>)
   1a516:	6818      	ldr	r0, [r3, #0]
	z_impl_k_sem_give(sem);
   1a518:	f008 b8ca 	b.w	226b0 <z_impl_k_sem_give>
   1a51c:	200012b4 	.word	0x200012b4

0001a520 <ll_pdu_rx_alloc_peek>:
{
   1a520:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
   1a522:	4a0a      	ldr	r2, [pc, #40]	; (1a54c <ll_pdu_rx_alloc_peek+0x2c>)
   1a524:	7891      	ldrb	r1, [r2, #2]
   1a526:	78d4      	ldrb	r4, [r2, #3]
   1a528:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   1a52a:	42a1      	cmp	r1, r4
		return count - first + last;
   1a52c:	bf8a      	itet	hi
   1a52e:	1a5b      	subhi	r3, r3, r1
		return last - first;
   1a530:	1a63      	subls	r3, r4, r1
		return count - first + last;
   1a532:	191b      	addhi	r3, r3, r4
   1a534:	b2db      	uxtb	r3, r3
   1a536:	4298      	cmp	r0, r3
   1a538:	d806      	bhi.n	1a548 <ll_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   1a53a:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
   1a53c:	7813      	ldrb	r3, [r2, #0]
   1a53e:	d003      	beq.n	1a548 <ll_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   1a540:	fb01 2203 	mla	r2, r1, r3, r2
   1a544:	6850      	ldr	r0, [r2, #4]
}
   1a546:	bd10      	pop	{r4, pc}
		return NULL;
   1a548:	2000      	movs	r0, #0
   1a54a:	e7fc      	b.n	1a546 <ll_pdu_rx_alloc_peek+0x26>
   1a54c:	200070dc 	.word	0x200070dc

0001a550 <ll_pdu_rx_alloc>:
{
   1a550:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   1a552:	4a09      	ldr	r2, [pc, #36]	; (1a578 <ll_pdu_rx_alloc+0x28>)
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(u8_t *fifo, u8_t size, u8_t count,
				  u8_t last, u8_t *first)
{
	u8_t _first = *first; /* Copy read-index */
   1a554:	7893      	ldrb	r3, [r2, #2]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
   1a556:	78d0      	ldrb	r0, [r2, #3]
   1a558:	7811      	ldrb	r1, [r2, #0]
   1a55a:	7854      	ldrb	r4, [r2, #1]
   1a55c:	4298      	cmp	r0, r3
   1a55e:	d009      	beq.n	1a574 <ll_pdu_rx_alloc+0x24>
	}

	/* Obtain address of head buffer.
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));
   1a560:	fb03 2101 	mla	r1, r3, r1, r2

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
   1a564:	3301      	adds	r3, #1
   1a566:	b2db      	uxtb	r3, r3
	if (_first == count) {
		_first = 0U;
   1a568:	429c      	cmp	r4, r3
   1a56a:	bf08      	it	eq
   1a56c:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   1a56e:	6848      	ldr	r0, [r1, #4]
	}

	*first = _first; /* Write back read-index */
   1a570:	7093      	strb	r3, [r2, #2]
}
   1a572:	bd10      	pop	{r4, pc}
		return NULL;
   1a574:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   1a576:	e7fc      	b.n	1a572 <ll_pdu_rx_alloc+0x22>
   1a578:	200070dc 	.word	0x200070dc

0001a57c <ll_tx_ack_put>:
{
   1a57c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	idx = MFIFO_ENQUEUE_GET(tx_ack, (void **)&tx);
   1a57e:	4a12      	ldr	r2, [pc, #72]	; (1a5c8 <ll_tx_ack_put+0x4c>)
   1a580:	78d4      	ldrb	r4, [r2, #3]
	if (last == count) {
   1a582:	7857      	ldrb	r7, [r2, #1]
   1a584:	7895      	ldrb	r5, [r2, #2]
   1a586:	7816      	ldrb	r6, [r2, #0]
	last = last + 1;
   1a588:	1c63      	adds	r3, r4, #1
   1a58a:	b2db      	uxtb	r3, r3
		last = 0U;
   1a58c:	429f      	cmp	r7, r3
   1a58e:	bf08      	it	eq
   1a590:	2300      	moveq	r3, #0
	if (last == first) {
   1a592:	429d      	cmp	r5, r3
   1a594:	d004      	beq.n	1a5a0 <ll_tx_ack_put+0x24>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1a596:	1d15      	adds	r5, r2, #4
   1a598:	fb14 f406 	smulbb	r4, r4, r6
	LL_ASSERT(tx);
   1a59c:	192e      	adds	r6, r5, r4
   1a59e:	d10f      	bne.n	1a5c0 <ll_tx_ack_put+0x44>
   1a5a0:	4a0a      	ldr	r2, [pc, #40]	; (1a5cc <ll_tx_ack_put+0x50>)
   1a5a2:	490b      	ldr	r1, [pc, #44]	; (1a5d0 <ll_tx_ack_put+0x54>)
   1a5a4:	480b      	ldr	r0, [pc, #44]	; (1a5d4 <ll_tx_ack_put+0x58>)
   1a5a6:	f240 33a7 	movw	r3, #935	; 0x3a7
   1a5aa:	f009 fc9a 	bl	23ee2 <printk>
   1a5ae:	4040      	eors	r0, r0
   1a5b0:	f380 8811 	msr	BASEPRI, r0
   1a5b4:	f04f 0003 	mov.w	r0, #3
   1a5b8:	df02      	svc	2
	tx->handle = handle;
   1a5ba:	2300      	movs	r3, #0
   1a5bc:	801b      	strh	r3, [r3, #0]
   1a5be:	deff      	udf	#255	; 0xff
   1a5c0:	5328      	strh	r0, [r5, r4]
	*last = idx; /* Commit: Update write index */
   1a5c2:	70d3      	strb	r3, [r2, #3]
	tx->node = node_tx;
   1a5c4:	6071      	str	r1, [r6, #4]
}
   1a5c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a5c8:	20007228 	.word	0x20007228
   1a5cc:	00030371 	.word	0x00030371
   1a5d0:	000306d8 	.word	0x000306d8
   1a5d4:	0002a5e8 	.word	0x0002a5e8

0001a5d8 <ll_radio_state_abort>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   1a5d8:	2200      	movs	r2, #0
{
   1a5da:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   1a5dc:	4611      	mov	r1, r2
   1a5de:	4b09      	ldr	r3, [pc, #36]	; (1a604 <ll_radio_state_abort+0x2c>)
   1a5e0:	2001      	movs	r0, #1
   1a5e2:	f7fd fda3 	bl	1812c <mayfly_enqueue>
	LL_ASSERT(!ret);
   1a5e6:	b160      	cbz	r0, 1a602 <ll_radio_state_abort+0x2a>
   1a5e8:	4a07      	ldr	r2, [pc, #28]	; (1a608 <ll_radio_state_abort+0x30>)
   1a5ea:	4908      	ldr	r1, [pc, #32]	; (1a60c <ll_radio_state_abort+0x34>)
   1a5ec:	4808      	ldr	r0, [pc, #32]	; (1a610 <ll_radio_state_abort+0x38>)
   1a5ee:	f240 33bf 	movw	r3, #959	; 0x3bf
   1a5f2:	f009 fc76 	bl	23ee2 <printk>
   1a5f6:	4040      	eors	r0, r0
   1a5f8:	f380 8811 	msr	BASEPRI, r0
   1a5fc:	f04f 0003 	mov.w	r0, #3
   1a600:	df02      	svc	2
}
   1a602:	bd08      	pop	{r3, pc}
   1a604:	2000725c 	.word	0x2000725c
   1a608:	00030371 	.word	0x00030371
   1a60c:	00030473 	.word	0x00030473
   1a610:	0002a5e8 	.word	0x0002a5e8

0001a614 <ull_ticker_status_give>:
	*((u32_t volatile *)param) = status;
   1a614:	6008      	str	r0, [r1, #0]
   1a616:	4801      	ldr	r0, [pc, #4]	; (1a61c <ull_ticker_status_give+0x8>)
   1a618:	f008 b84a 	b.w	226b0 <z_impl_k_sem_give>
   1a61c:	200012b8 	.word	0x200012b8

0001a620 <ull_ticker_status_take>:
{
   1a620:	b510      	push	{r4, lr}
   1a622:	460c      	mov	r4, r1
	return z_impl_k_sem_take(sem, timeout);
   1a624:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1a628:	4802      	ldr	r0, [pc, #8]	; (1a634 <ull_ticker_status_take+0x14>)
   1a62a:	f008 f885 	bl	22738 <z_impl_k_sem_take>
	return *ret_cb;
   1a62e:	6820      	ldr	r0, [r4, #0]
}
   1a630:	bd10      	pop	{r4, pc}
   1a632:	bf00      	nop
   1a634:	200012b8 	.word	0x200012b8

0001a638 <ull_disable_mark>:
	if (!*m) {
   1a638:	4b02      	ldr	r3, [pc, #8]	; (1a644 <ull_disable_mark+0xc>)
   1a63a:	681a      	ldr	r2, [r3, #0]
   1a63c:	b902      	cbnz	r2, 1a640 <ull_disable_mark+0x8>
		*m = param;
   1a63e:	6018      	str	r0, [r3, #0]
}
   1a640:	6818      	ldr	r0, [r3, #0]
   1a642:	4770      	bx	lr
   1a644:	20000f88 	.word	0x20000f88

0001a648 <ull_disable_unmark>:
	if (*m && *m == param) {
   1a648:	4a05      	ldr	r2, [pc, #20]	; (1a660 <ull_disable_unmark+0x18>)
{
   1a64a:	4603      	mov	r3, r0
	if (*m && *m == param) {
   1a64c:	6810      	ldr	r0, [r2, #0]
   1a64e:	b130      	cbz	r0, 1a65e <ull_disable_unmark+0x16>
   1a650:	4283      	cmp	r3, r0
   1a652:	f04f 0300 	mov.w	r3, #0
   1a656:	d101      	bne.n	1a65c <ull_disable_unmark+0x14>
		*m = NULL;
   1a658:	6013      	str	r3, [r2, #0]
		return param;
   1a65a:	4770      	bx	lr
	return NULL;
   1a65c:	4618      	mov	r0, r3
}
   1a65e:	4770      	bx	lr
   1a660:	20000f88 	.word	0x20000f88

0001a664 <ull_disable_mark_get>:
}
   1a664:	4b01      	ldr	r3, [pc, #4]	; (1a66c <ull_disable_mark_get+0x8>)
   1a666:	6818      	ldr	r0, [r3, #0]
   1a668:	4770      	bx	lr
   1a66a:	bf00      	nop
   1a66c:	20000f88 	.word	0x20000f88

0001a670 <ull_update_mark>:
	if (!*m) {
   1a670:	4b02      	ldr	r3, [pc, #8]	; (1a67c <ull_update_mark+0xc>)
   1a672:	681a      	ldr	r2, [r3, #0]
   1a674:	b902      	cbnz	r2, 1a678 <ull_update_mark+0x8>
		*m = param;
   1a676:	6018      	str	r0, [r3, #0]
}
   1a678:	6818      	ldr	r0, [r3, #0]
   1a67a:	4770      	bx	lr
   1a67c:	20000f8c 	.word	0x20000f8c

0001a680 <ull_update_unmark>:
	if (*m && *m == param) {
   1a680:	4a05      	ldr	r2, [pc, #20]	; (1a698 <ull_update_unmark+0x18>)
{
   1a682:	4603      	mov	r3, r0
	if (*m && *m == param) {
   1a684:	6810      	ldr	r0, [r2, #0]
   1a686:	b130      	cbz	r0, 1a696 <ull_update_unmark+0x16>
   1a688:	4283      	cmp	r3, r0
   1a68a:	f04f 0300 	mov.w	r3, #0
   1a68e:	d101      	bne.n	1a694 <ull_update_unmark+0x14>
		*m = NULL;
   1a690:	6013      	str	r3, [r2, #0]
		return param;
   1a692:	4770      	bx	lr
	return NULL;
   1a694:	4618      	mov	r0, r3
}
   1a696:	4770      	bx	lr
   1a698:	20000f8c 	.word	0x20000f8c

0001a69c <ull_update_mark_get>:
}
   1a69c:	4b01      	ldr	r3, [pc, #4]	; (1a6a4 <ull_update_mark_get+0x8>)
   1a69e:	6818      	ldr	r0, [r3, #0]
   1a6a0:	4770      	bx	lr
   1a6a2:	bf00      	nop
   1a6a4:	20000f8c 	.word	0x20000f8c

0001a6a8 <ull_disable>:
{
   1a6a8:	b530      	push	{r4, r5, lr}
	hdr = HDR_ULL(((struct lll_hdr *)lll)->parent);
   1a6aa:	6805      	ldr	r5, [r0, #0]
	if (!hdr) {
   1a6ac:	f115 0f10 	cmn.w	r5, #16
{
   1a6b0:	b087      	sub	sp, #28
   1a6b2:	4604      	mov	r4, r0
	if (!hdr) {
   1a6b4:	d102      	bne.n	1a6bc <ull_disable+0x14>
		return ULL_STATUS_SUCCESS;
   1a6b6:	2000      	movs	r0, #0
}
   1a6b8:	b007      	add	sp, #28
   1a6ba:	bd30      	pop	{r4, r5, pc}
	return z_impl_k_sem_init(sem, initial_count, limit);
   1a6bc:	2201      	movs	r2, #1
   1a6be:	2100      	movs	r1, #0
   1a6c0:	4668      	mov	r0, sp
   1a6c2:	f00e fe09 	bl	292d8 <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
   1a6c6:	4b11      	ldr	r3, [pc, #68]	; (1a70c <ull_disable+0x64>)
   1a6c8:	616b      	str	r3, [r5, #20]
	if (!hdr->ref) {
   1a6ca:	7c2b      	ldrb	r3, [r5, #16]
	hdr->disabled_param = &sem;
   1a6cc:	f8c5 d018 	str.w	sp, [r5, #24]
	if (!hdr->ref) {
   1a6d0:	2b00      	cmp	r3, #0
   1a6d2:	d0f0      	beq.n	1a6b6 <ull_disable+0xe>
	mfy.param = lll;
   1a6d4:	4b0e      	ldr	r3, [pc, #56]	; (1a710 <ull_disable+0x68>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   1a6d6:	2200      	movs	r2, #0
   1a6d8:	4611      	mov	r1, r2
   1a6da:	2003      	movs	r0, #3
	mfy.param = lll;
   1a6dc:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   1a6de:	f7fd fd25 	bl	1812c <mayfly_enqueue>
	LL_ASSERT(!ret);
   1a6e2:	b160      	cbz	r0, 1a6fe <ull_disable+0x56>
   1a6e4:	4a0b      	ldr	r2, [pc, #44]	; (1a714 <ull_disable+0x6c>)
   1a6e6:	490c      	ldr	r1, [pc, #48]	; (1a718 <ull_disable+0x70>)
   1a6e8:	480c      	ldr	r0, [pc, #48]	; (1a71c <ull_disable+0x74>)
   1a6ea:	f240 4312 	movw	r3, #1042	; 0x412
   1a6ee:	f009 fbf8 	bl	23ee2 <printk>
   1a6f2:	4040      	eors	r0, r0
   1a6f4:	f380 8811 	msr	BASEPRI, r0
   1a6f8:	f04f 0003 	mov.w	r0, #3
   1a6fc:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   1a6fe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1a702:	4668      	mov	r0, sp
   1a704:	f008 f818 	bl	22738 <z_impl_k_sem_take>
	return k_sem_take(&sem, K_FOREVER);
   1a708:	e7d6      	b.n	1a6b8 <ull_disable+0x10>
   1a70a:	bf00      	nop
   1a70c:	000283a1 	.word	0x000283a1
   1a710:	2000726c 	.word	0x2000726c
   1a714:	00030371 	.word	0x00030371
   1a718:	00030473 	.word	0x00030473
   1a71c:	0002a5e8 	.word	0x0002a5e8

0001a720 <ull_pdu_rx_alloc_peek>:
{
   1a720:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
   1a722:	4a0a      	ldr	r2, [pc, #40]	; (1a74c <ull_pdu_rx_alloc_peek+0x2c>)
   1a724:	7891      	ldrb	r1, [r2, #2]
   1a726:	78d4      	ldrb	r4, [r2, #3]
   1a728:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   1a72a:	42a1      	cmp	r1, r4
		return count - first + last;
   1a72c:	bf8a      	itet	hi
   1a72e:	1a5b      	subhi	r3, r3, r1
		return last - first;
   1a730:	1a63      	subls	r3, r4, r1
		return count - first + last;
   1a732:	191b      	addhi	r3, r3, r4
   1a734:	b2db      	uxtb	r3, r3
   1a736:	4298      	cmp	r0, r3
   1a738:	d806      	bhi.n	1a748 <ull_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   1a73a:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
   1a73c:	7813      	ldrb	r3, [r2, #0]
   1a73e:	d003      	beq.n	1a748 <ull_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   1a740:	fb01 2203 	mla	r2, r1, r3, r2
   1a744:	6850      	ldr	r0, [r2, #4]
}
   1a746:	bd10      	pop	{r4, pc}
		return NULL;
   1a748:	2000      	movs	r0, #0
   1a74a:	e7fc      	b.n	1a746 <ull_pdu_rx_alloc_peek+0x26>
   1a74c:	200070ec 	.word	0x200070ec

0001a750 <ull_pdu_rx_alloc>:
{
   1a750:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(pdu_rx_free);
   1a752:	4a09      	ldr	r2, [pc, #36]	; (1a778 <ull_pdu_rx_alloc+0x28>)
	u8_t _first = *first; /* Copy read-index */
   1a754:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   1a756:	78d0      	ldrb	r0, [r2, #3]
   1a758:	7811      	ldrb	r1, [r2, #0]
   1a75a:	7854      	ldrb	r4, [r2, #1]
   1a75c:	4298      	cmp	r0, r3
   1a75e:	d009      	beq.n	1a774 <ull_pdu_rx_alloc+0x24>
	mem = *((void **)(fifo + _first * size));
   1a760:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   1a764:	3301      	adds	r3, #1
   1a766:	b2db      	uxtb	r3, r3
		_first = 0U;
   1a768:	429c      	cmp	r4, r3
   1a76a:	bf08      	it	eq
   1a76c:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   1a76e:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   1a770:	7093      	strb	r3, [r2, #2]
}
   1a772:	bd10      	pop	{r4, pc}
		return NULL;
   1a774:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
   1a776:	e7fc      	b.n	1a772 <ull_pdu_rx_alloc+0x22>
   1a778:	200070ec 	.word	0x200070ec

0001a77c <ull_rx_put>:
{
   1a77c:	b538      	push	{r3, r4, r5, lr}
   1a77e:	460c      	mov	r4, r1
   1a780:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   1a782:	f001 ff99 	bl	1c6b8 <ull_conn_ack_last_idx_get>
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   1a786:	4621      	mov	r1, r4
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   1a788:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   1a78a:	4a03      	ldr	r2, [pc, #12]	; (1a798 <ull_rx_put+0x1c>)
   1a78c:	4628      	mov	r0, r5
}
   1a78e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   1a792:	f00d bcd5 	b.w	28140 <memq_enqueue>
   1a796:	bf00      	nop
   1a798:	200012b0 	.word	0x200012b0

0001a79c <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
   1a79c:	2201      	movs	r2, #1
   1a79e:	4b02      	ldr	r3, [pc, #8]	; (1a7a8 <ull_rx_sched+0xc>)
   1a7a0:	4611      	mov	r1, r2
   1a7a2:	2000      	movs	r0, #0
   1a7a4:	f7fd bcc2 	b.w	1812c <mayfly_enqueue>
   1a7a8:	2000727c 	.word	0x2000727c

0001a7ac <ull_prepare_enqueue>:
{
   1a7ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1a7b0:	4e17      	ldr	r6, [pc, #92]	; (1a810 <ull_prepare_enqueue+0x64>)
{
   1a7b2:	4699      	mov	r9, r3
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1a7b4:	78f3      	ldrb	r3, [r6, #3]
   1a7b6:	7834      	ldrb	r4, [r6, #0]
{
   1a7b8:	4680      	mov	r8, r0
	last = last + 1;
   1a7ba:	1c5d      	adds	r5, r3, #1
	if (last == count) {
   1a7bc:	7870      	ldrb	r0, [r6, #1]
   1a7be:	460f      	mov	r7, r1
	last = last + 1;
   1a7c0:	b2ed      	uxtb	r5, r5
   1a7c2:	4611      	mov	r1, r2
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1a7c4:	78b2      	ldrb	r2, [r6, #2]
		last = 0U;
   1a7c6:	42a8      	cmp	r0, r5
   1a7c8:	bf08      	it	eq
   1a7ca:	2500      	moveq	r5, #0
	if (last == first) {
   1a7cc:	42aa      	cmp	r2, r5
   1a7ce:	d01b      	beq.n	1a808 <ull_prepare_enqueue+0x5c>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1a7d0:	1d32      	adds	r2, r6, #4
   1a7d2:	fb03 2404 	mla	r4, r3, r4, r2
	if (!e) {
   1a7d6:	b1bc      	cbz	r4, 1a808 <ull_prepare_enqueue+0x5c>
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
   1a7d8:	2210      	movs	r2, #16
   1a7da:	4620      	mov	r0, r4
   1a7dc:	f00b fa64 	bl	25ca8 <memcpy>
	e->prio = prio;
   1a7e0:	9b08      	ldr	r3, [sp, #32]
	e->is_resume = is_resume;
   1a7e2:	f89d 2024 	ldrb.w	r2, [sp, #36]	; 0x24
	e->prio = prio;
   1a7e6:	61e3      	str	r3, [r4, #28]
	e->is_resume = is_resume;
   1a7e8:	f894 3020 	ldrb.w	r3, [r4, #32]
	e->abort_cb = abort_cb;
   1a7ec:	61a7      	str	r7, [r4, #24]
	e->is_resume = is_resume;
   1a7ee:	f023 0303 	bic.w	r3, r3, #3
   1a7f2:	f002 0201 	and.w	r2, r2, #1
	e->is_abort_cb = is_abort_cb;
   1a7f6:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->is_resume = is_resume;
   1a7fa:	4313      	orrs	r3, r2
   1a7fc:	f884 3020 	strb.w	r3, [r4, #32]
	*last = idx; /* Commit: Update write index */
   1a800:	70f5      	strb	r5, [r6, #3]
	return 0;
   1a802:	2000      	movs	r0, #0
}
   1a804:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -ENOBUFS;
   1a808:	f06f 0036 	mvn.w	r0, #54	; 0x36
   1a80c:	e7fa      	b.n	1a804 <ull_prepare_enqueue+0x58>
   1a80e:	bf00      	nop
   1a810:	20007104 	.word	0x20007104

0001a814 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
   1a814:	4b05      	ldr	r3, [pc, #20]	; (1a82c <ull_prepare_dequeue_get+0x18>)
   1a816:	789a      	ldrb	r2, [r3, #2]
	if (first == last) {
   1a818:	78d9      	ldrb	r1, [r3, #3]
   1a81a:	7818      	ldrb	r0, [r3, #0]
   1a81c:	4291      	cmp	r1, r2
	return (void *)(fifo + first * size);
   1a81e:	bf1a      	itte	ne
   1a820:	3304      	addne	r3, #4
   1a822:	fb02 3000 	mlane	r0, r2, r0, r3
		return NULL;
   1a826:	2000      	moveq	r0, #0
}
   1a828:	4770      	bx	lr
   1a82a:	bf00      	nop
   1a82c:	20007104 	.word	0x20007104

0001a830 <rx_demux>:
		}
}
#endif /* CONFIG_BT_CONN */

static void rx_demux(void *param)
{
   1a830:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
					     TICKER_USER_ID_LLL, 0, &mfy);
			LL_ASSERT(!ret);
		}

		MFIFO_DEQUEUE(prep);
   1a834:	4d8d      	ldr	r5, [pc, #564]	; (1aa6c <rx_demux+0x23c>)
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
   1a836:	4c8e      	ldr	r4, [pc, #568]	; (1aa70 <rx_demux+0x240>)
   1a838:	aa01      	add	r2, sp, #4
   1a83a:	e9d4 0100 	ldrd	r0, r1, [r4]
   1a83e:	f00d fc86 	bl	2814e <memq_peek>
		if (link) {
   1a842:	4606      	mov	r6, r0
   1a844:	2800      	cmp	r0, #0
   1a846:	f000 80ff 	beq.w	1aa48 <rx_demux+0x218>
			LL_ASSERT(rx);
   1a84a:	9b01      	ldr	r3, [sp, #4]
   1a84c:	b963      	cbnz	r3, 1a868 <rx_demux+0x38>
   1a84e:	4a89      	ldr	r2, [pc, #548]	; (1aa74 <rx_demux+0x244>)
   1a850:	4989      	ldr	r1, [pc, #548]	; (1aa78 <rx_demux+0x248>)
   1a852:	488a      	ldr	r0, [pc, #552]	; (1aa7c <rx_demux+0x24c>)
   1a854:	f240 53ca 	movw	r3, #1482	; 0x5ca
   1a858:	f009 fb43 	bl	23ee2 <printk>
   1a85c:	4040      	eors	r0, r0
   1a85e:	f380 8811 	msr	BASEPRI, r0
   1a862:	f04f 0003 	mov.w	r0, #3
   1a866:	df02      	svc	2
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
   1a868:	9b01      	ldr	r3, [sp, #4]
   1a86a:	aa02      	add	r2, sp, #8
   1a86c:	7818      	ldrb	r0, [r3, #0]
   1a86e:	f10d 0102 	add.w	r1, sp, #2
   1a872:	f001 ff3f 	bl	1c6f4 <ull_conn_ack_by_last_peek>
			if (link_tx) {
   1a876:	4602      	mov	r2, r0
   1a878:	9801      	ldr	r0, [sp, #4]
   1a87a:	b132      	cbz	r2, 1a88a <rx_demux+0x5a>
				rx_demux_conn_tx_ack(rx->ack_last, handle,
   1a87c:	9b02      	ldr	r3, [sp, #8]
   1a87e:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1a882:	7800      	ldrb	r0, [r0, #0]
				rx_demux_conn_tx_ack(ack_last, handle,
   1a884:	f00d fd8e 	bl	283a4 <rx_demux_conn_tx_ack>
	} while (link);
   1a888:	e7d5      	b.n	1a836 <rx_demux+0x6>
				nack = rx_demux_rx(link, rx);
   1a88a:	9003      	str	r0, [sp, #12]
	switch (rx->type) {
   1a88c:	7903      	ldrb	r3, [r0, #4]
   1a88e:	3b01      	subs	r3, #1
   1a890:	2b08      	cmp	r3, #8
   1a892:	f200 80cb 	bhi.w	1aa2c <rx_demux+0x1fc>
   1a896:	e8df f013 	tbh	[pc, r3, lsl #1]
   1a89a:	0009      	.short	0x0009
   1a89c:	00c900ad 	.word	0x00c900ad
   1a8a0:	00c900c2 	.word	0x00c900c2
   1a8a4:	00c900c9 	.word	0x00c900c9
   1a8a8:	00c200a3 	.word	0x00c200a3
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1a8ac:	6860      	ldr	r0, [r4, #4]
   1a8ae:	4970      	ldr	r1, [pc, #448]	; (1aa70 <rx_demux+0x240>)
   1a8b0:	2200      	movs	r2, #0
   1a8b2:	f00d fc54 	bl	2815e <memq_dequeue>
		rx_demux_event_done(link, rx);
   1a8b6:	9f03      	ldr	r7, [sp, #12]
	switch (done->extra.type) {
   1a8b8:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
	ull_hdr = done->param;
   1a8bc:	6a3c      	ldr	r4, [r7, #32]
	switch (done->extra.type) {
   1a8be:	b123      	cbz	r3, 1a8ca <rx_demux+0x9a>
   1a8c0:	2b01      	cmp	r3, #1
   1a8c2:	d16e      	bne.n	1a9a2 <rx_demux+0x172>
		ull_conn_done(done);
   1a8c4:	4638      	mov	r0, r7
   1a8c6:	f001 fde5 	bl	1c494 <ull_conn_done>
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   1a8ca:	4a6d      	ldr	r2, [pc, #436]	; (1aa80 <rx_demux+0x250>)
   1a8cc:	78d1      	ldrb	r1, [r2, #3]
	if (last == count) {
   1a8ce:	f892 c001 	ldrb.w	ip, [r2, #1]
   1a8d2:	7890      	ldrb	r0, [r2, #2]
	done->extra.type = 0U;
   1a8d4:	2300      	movs	r3, #0
   1a8d6:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	last = last + 1;
   1a8da:	1c4b      	adds	r3, r1, #1
   1a8dc:	b2db      	uxtb	r3, r3
		last = 0U;
   1a8de:	459c      	cmp	ip, r3
   1a8e0:	bf08      	it	eq
   1a8e2:	2300      	moveq	r3, #0
	if (last == first) {
   1a8e4:	4298      	cmp	r0, r3
   1a8e6:	d16a      	bne.n	1a9be <rx_demux+0x18e>
	LL_ASSERT(release == done);
   1a8e8:	4a62      	ldr	r2, [pc, #392]	; (1aa74 <rx_demux+0x244>)
   1a8ea:	4966      	ldr	r1, [pc, #408]	; (1aa84 <rx_demux+0x254>)
   1a8ec:	4863      	ldr	r0, [pc, #396]	; (1aa7c <rx_demux+0x24c>)
   1a8ee:	f240 638a 	movw	r3, #1674	; 0x68a
   1a8f2:	f009 faf6 	bl	23ee2 <printk>
   1a8f6:	4040      	eors	r0, r0
   1a8f8:	f380 8811 	msr	BASEPRI, r0
   1a8fc:	f04f 0003 	mov.w	r0, #3
   1a900:	df02      	svc	2
	next = ull_prepare_dequeue_get();
   1a902:	f7ff ff87 	bl	1a814 <ull_prepare_dequeue_get>
			mfy.param = next;
   1a906:	4f60      	ldr	r7, [pc, #384]	; (1aa88 <rx_demux+0x258>)
	while (next) {
   1a908:	b358      	cbz	r0, 1a962 <rx_demux+0x132>
		u8_t is_aborted = next->is_aborted;
   1a90a:	f890 3020 	ldrb.w	r3, [r0, #32]
		if (!is_aborted) {
   1a90e:	079a      	lsls	r2, r3, #30
		u8_t is_aborted = next->is_aborted;
   1a910:	f3c3 0640 	ubfx	r6, r3, #1, #1
		u8_t is_resume = next->is_resume;
   1a914:	f003 0801 	and.w	r8, r3, #1
		if (!is_aborted) {
   1a918:	d414      	bmi.n	1a944 <rx_demux+0x114>
			mfy.param = next;
   1a91a:	60b8      	str	r0, [r7, #8]
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1a91c:	4b5a      	ldr	r3, [pc, #360]	; (1aa88 <rx_demux+0x258>)
   1a91e:	4632      	mov	r2, r6
   1a920:	4631      	mov	r1, r6
   1a922:	2001      	movs	r0, #1
   1a924:	f7fd fc02 	bl	1812c <mayfly_enqueue>
			LL_ASSERT(!ret);
   1a928:	b160      	cbz	r0, 1a944 <rx_demux+0x114>
   1a92a:	4a52      	ldr	r2, [pc, #328]	; (1aa74 <rx_demux+0x244>)
   1a92c:	4957      	ldr	r1, [pc, #348]	; (1aa8c <rx_demux+0x25c>)
   1a92e:	4853      	ldr	r0, [pc, #332]	; (1aa7c <rx_demux+0x24c>)
   1a930:	f240 639b 	movw	r3, #1691	; 0x69b
   1a934:	f009 fad5 	bl	23ee2 <printk>
   1a938:	4040      	eors	r0, r0
   1a93a:	f380 8811 	msr	BASEPRI, r0
   1a93e:	f04f 0003 	mov.w	r0, #3
   1a942:	df02      	svc	2
	u8_t _first = *first; /* Copy read-index */
   1a944:	78ab      	ldrb	r3, [r5, #2]
	if (_first == last) {
   1a946:	78e9      	ldrb	r1, [r5, #3]
		MFIFO_DEQUEUE(prep);
   1a948:	786a      	ldrb	r2, [r5, #1]
   1a94a:	4299      	cmp	r1, r3
   1a94c:	d005      	beq.n	1a95a <rx_demux+0x12a>
	_first += 1U;
   1a94e:	3301      	adds	r3, #1
   1a950:	b2db      	uxtb	r3, r3
		_first = 0U;
   1a952:	429a      	cmp	r2, r3
   1a954:	bf08      	it	eq
   1a956:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1a958:	70ab      	strb	r3, [r5, #2]

		next = ull_prepare_dequeue_get();
   1a95a:	f7ff ff5b 	bl	1a814 <ull_prepare_dequeue_get>

		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
   1a95e:	2800      	cmp	r0, #0
   1a960:	d134      	bne.n	1a9cc <rx_demux+0x19c>
			break;
		}
	}

	/* ull instance will resume, dont decrement ref */
	if (!ull_hdr) {
   1a962:	2c00      	cmp	r4, #0
   1a964:	f43f af67 	beq.w	1a836 <rx_demux+0x6>
		return;
	}

	/* Decrement prepare reference */
	LL_ASSERT(ull_hdr->ref);
   1a968:	7823      	ldrb	r3, [r4, #0]
   1a96a:	b963      	cbnz	r3, 1a986 <rx_demux+0x156>
   1a96c:	4a41      	ldr	r2, [pc, #260]	; (1aa74 <rx_demux+0x244>)
   1a96e:	4948      	ldr	r1, [pc, #288]	; (1aa90 <rx_demux+0x260>)
   1a970:	4842      	ldr	r0, [pc, #264]	; (1aa7c <rx_demux+0x24c>)
   1a972:	f240 63ad 	movw	r3, #1709	; 0x6ad
   1a976:	f009 fab4 	bl	23ee2 <printk>
   1a97a:	4040      	eors	r0, r0
   1a97c:	f380 8811 	msr	BASEPRI, r0
   1a980:	f04f 0003 	mov.w	r0, #3
   1a984:	df02      	svc	2
	return hdr->ref--;
   1a986:	7823      	ldrb	r3, [r4, #0]
   1a988:	3b01      	subs	r3, #1
   1a98a:	b2db      	uxtb	r3, r3
   1a98c:	7023      	strb	r3, [r4, #0]
	ull_ref_dec(ull_hdr);

	/* If disable initiated, signal the semaphore */
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
   1a98e:	2b00      	cmp	r3, #0
   1a990:	f47f af51 	bne.w	1a836 <rx_demux+0x6>
   1a994:	6863      	ldr	r3, [r4, #4]
   1a996:	2b00      	cmp	r3, #0
   1a998:	f43f af4d 	beq.w	1a836 <rx_demux+0x6>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
   1a99c:	68a0      	ldr	r0, [r4, #8]
   1a99e:	4798      	blx	r3
			if (nack) {
   1a9a0:	e749      	b.n	1a836 <rx_demux+0x6>
		LL_ASSERT(0);
   1a9a2:	4a34      	ldr	r2, [pc, #208]	; (1aa74 <rx_demux+0x244>)
   1a9a4:	493b      	ldr	r1, [pc, #236]	; (1aa94 <rx_demux+0x264>)
   1a9a6:	4835      	ldr	r0, [pc, #212]	; (1aa7c <rx_demux+0x24c>)
   1a9a8:	f240 6383 	movw	r3, #1667	; 0x683
   1a9ac:	f009 fa99 	bl	23ee2 <printk>
   1a9b0:	4040      	eors	r0, r0
   1a9b2:	f380 8811 	msr	BASEPRI, r0
   1a9b6:	f04f 0003 	mov.w	r0, #3
   1a9ba:	df02      	svc	2
		break;
   1a9bc:	e785      	b.n	1a8ca <rx_demux+0x9a>
	done->hdr.link = link;
   1a9be:	603e      	str	r6, [r7, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1a9c0:	7810      	ldrb	r0, [r2, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1a9c2:	fb00 2101 	mla	r1, r0, r1, r2
   1a9c6:	604f      	str	r7, [r1, #4]
	*last = idx; /* Commit: Update write index */
   1a9c8:	70d3      	strb	r3, [r2, #3]
	LL_ASSERT(release == done);
   1a9ca:	e79a      	b.n	1a902 <rx_demux+0xd2>
		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
   1a9cc:	2e00      	cmp	r6, #0
   1a9ce:	d19b      	bne.n	1a908 <rx_demux+0xd8>
   1a9d0:	f1b8 0f00 	cmp.w	r8, #0
   1a9d4:	d0c5      	beq.n	1a962 <rx_demux+0x132>
   1a9d6:	f890 3020 	ldrb.w	r3, [r0, #32]
   1a9da:	07db      	lsls	r3, r3, #31
   1a9dc:	d4c1      	bmi.n	1a962 <rx_demux+0x132>
   1a9de:	e793      	b.n	1a908 <rx_demux+0xd8>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1a9e0:	4923      	ldr	r1, [pc, #140]	; (1aa70 <rx_demux+0x240>)
   1a9e2:	6860      	ldr	r0, [r4, #4]
   1a9e4:	2200      	movs	r2, #0
   1a9e6:	f00d fbba 	bl	2815e <memq_dequeue>
		ull_conn_setup(link, rx);
   1a9ea:	9903      	ldr	r1, [sp, #12]
   1a9ec:	4630      	mov	r0, r6
   1a9ee:	f000 ff63 	bl	1b8b8 <ull_conn_setup>
			if (nack) {
   1a9f2:	e720      	b.n	1a836 <rx_demux+0x6>
		nack = ull_conn_rx(link, (void *)&rx);
   1a9f4:	a903      	add	r1, sp, #12
   1a9f6:	4630      	mov	r0, r6
   1a9f8:	f000 ff80 	bl	1b8fc <ull_conn_rx>
		if (nack) {
   1a9fc:	4602      	mov	r2, r0
   1a9fe:	2800      	cmp	r0, #0
   1aa00:	d130      	bne.n	1aa64 <rx_demux+0x234>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1aa02:	491b      	ldr	r1, [pc, #108]	; (1aa70 <rx_demux+0x240>)
   1aa04:	6860      	ldr	r0, [r4, #4]
   1aa06:	f00d fbaa 	bl	2815e <memq_dequeue>
		if (rx) {
   1aa0a:	9903      	ldr	r1, [sp, #12]
   1aa0c:	2900      	cmp	r1, #0
   1aa0e:	f43f af12 	beq.w	1a836 <rx_demux+0x6>
		ll_rx_put(link, rx);
   1aa12:	4630      	mov	r0, r6
   1aa14:	f7ff fd74 	bl	1a500 <ll_rx_put>
		ll_rx_sched();
   1aa18:	f7ff fd7c 	bl	1a514 <ll_rx_sched>
			if (nack) {
   1aa1c:	e70b      	b.n	1a836 <rx_demux+0x6>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1aa1e:	4914      	ldr	r1, [pc, #80]	; (1aa70 <rx_demux+0x240>)
   1aa20:	6860      	ldr	r0, [r4, #4]
   1aa22:	2200      	movs	r2, #0
   1aa24:	f00d fb9b 	bl	2815e <memq_dequeue>
		ll_rx_put(link, rx);
   1aa28:	9903      	ldr	r1, [sp, #12]
   1aa2a:	e7f2      	b.n	1aa12 <rx_demux+0x1e2>
		LL_ASSERT(0);
   1aa2c:	4a11      	ldr	r2, [pc, #68]	; (1aa74 <rx_demux+0x244>)
   1aa2e:	4919      	ldr	r1, [pc, #100]	; (1aa94 <rx_demux+0x264>)
   1aa30:	4812      	ldr	r0, [pc, #72]	; (1aa7c <rx_demux+0x24c>)
   1aa32:	f240 635b 	movw	r3, #1627	; 0x65b
   1aa36:	f009 fa54 	bl	23ee2 <printk>
   1aa3a:	4040      	eors	r0, r0
   1aa3c:	f380 8811 	msr	BASEPRI, r0
   1aa40:	f04f 0003 	mov.w	r0, #3
   1aa44:	df02      	svc	2
			if (nack) {
   1aa46:	e6f6      	b.n	1a836 <rx_demux+0x6>
			link = ull_conn_ack_peek(&ack_last, &handle, &node_tx);
   1aa48:	aa03      	add	r2, sp, #12
   1aa4a:	a902      	add	r1, sp, #8
   1aa4c:	f10d 0002 	add.w	r0, sp, #2
   1aa50:	f001 fe38 	bl	1c6c4 <ull_conn_ack_peek>
			if (link) {
   1aa54:	4602      	mov	r2, r0
   1aa56:	b128      	cbz	r0, 1aa64 <rx_demux+0x234>
				rx_demux_conn_tx_ack(ack_last, handle,
   1aa58:	9b03      	ldr	r3, [sp, #12]
   1aa5a:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   1aa5e:	f89d 0002 	ldrb.w	r0, [sp, #2]
   1aa62:	e70f      	b.n	1a884 <rx_demux+0x54>
}
   1aa64:	b004      	add	sp, #16
   1aa66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1aa6a:	bf00      	nop
   1aa6c:	20007104 	.word	0x20007104
   1aa70:	200012ac 	.word	0x200012ac
   1aa74:	00030371 	.word	0x00030371
   1aa78:	00030a5f 	.word	0x00030a5f
   1aa7c:	0002a5e8 	.word	0x0002a5e8
   1aa80:	200070c8 	.word	0x200070c8
   1aa84:	00030478 	.word	0x00030478
   1aa88:	2000728c 	.word	0x2000728c
   1aa8c:	00030473 	.word	0x00030473
   1aa90:	00030488 	.word	0x00030488
   1aa94:	0002e3c9 	.word	0x0002e3c9

0001aa98 <ull_prepare_dequeue_iter>:
{
   1aa98:	b530      	push	{r4, r5, lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   1aa9a:	4a0c      	ldr	r2, [pc, #48]	; (1aacc <ull_prepare_dequeue_iter+0x34>)
{
   1aa9c:	4603      	mov	r3, r0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   1aa9e:	7854      	ldrb	r4, [r2, #1]
	if (*idx >= count) {
   1aaa0:	7819      	ldrb	r1, [r3, #0]
   1aaa2:	78d5      	ldrb	r5, [r2, #3]
   1aaa4:	7810      	ldrb	r0, [r2, #0]
   1aaa6:	42a1      	cmp	r1, r4
   1aaa8:	bf24      	itt	cs
   1aaaa:	7892      	ldrbcs	r2, [r2, #2]
		*idx = first;
   1aaac:	701a      	strbcs	r2, [r3, #0]
	if (*idx == last) {
   1aaae:	7819      	ldrb	r1, [r3, #0]
   1aab0:	428d      	cmp	r5, r1
   1aab2:	d009      	beq.n	1aac8 <ull_prepare_dequeue_iter+0x30>
	i = *idx + 1;
   1aab4:	1c4a      	adds	r2, r1, #1
   1aab6:	b2d2      	uxtb	r2, r2
		i = 0U;
   1aab8:	4294      	cmp	r4, r2
   1aaba:	bf08      	it	eq
   1aabc:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
   1aabe:	4c04      	ldr	r4, [pc, #16]	; (1aad0 <ull_prepare_dequeue_iter+0x38>)
	*idx = i;
   1aac0:	701a      	strb	r2, [r3, #0]
	p = (void *)(fifo + (*idx) * size);
   1aac2:	fb01 4000 	mla	r0, r1, r0, r4
}
   1aac6:	bd30      	pop	{r4, r5, pc}
		return NULL;
   1aac8:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   1aaca:	e7fc      	b.n	1aac6 <ull_prepare_dequeue_iter+0x2e>
   1aacc:	20007104 	.word	0x20007104
   1aad0:	20007108 	.word	0x20007108

0001aad4 <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
   1aad4:	4b06      	ldr	r3, [pc, #24]	; (1aaf0 <ull_event_done_extra_get+0x1c>)
   1aad6:	7899      	ldrb	r1, [r3, #2]
	if (first == last) {
   1aad8:	78d8      	ldrb	r0, [r3, #3]
   1aada:	781a      	ldrb	r2, [r3, #0]
   1aadc:	4288      	cmp	r0, r1
   1aade:	d005      	beq.n	1aaec <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
   1aae0:	fb01 3302 	mla	r3, r1, r2, r3
   1aae4:	6858      	ldr	r0, [r3, #4]
	if (!evdone) {
   1aae6:	b110      	cbz	r0, 1aaee <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
   1aae8:	3024      	adds	r0, #36	; 0x24
   1aaea:	4770      	bx	lr
		return NULL;
   1aaec:	2000      	movs	r0, #0
}
   1aaee:	4770      	bx	lr
   1aaf0:	200070c8 	.word	0x200070c8

0001aaf4 <ull_event_done>:
{
   1aaf4:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
   1aaf6:	4a10      	ldr	r2, [pc, #64]	; (1ab38 <ull_event_done+0x44>)
	u8_t _first = *first; /* Copy read-index */
   1aaf8:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   1aafa:	78d4      	ldrb	r4, [r2, #3]
   1aafc:	7855      	ldrb	r5, [r2, #1]
   1aafe:	429c      	cmp	r4, r3
{
   1ab00:	4601      	mov	r1, r0
	evdone = MFIFO_DEQUEUE(done);
   1ab02:	7810      	ldrb	r0, [r2, #0]
   1ab04:	d016      	beq.n	1ab34 <ull_event_done+0x40>
	mem = *((void **)(fifo + _first * size));
   1ab06:	fb03 2000 	mla	r0, r3, r0, r2
	_first += 1U;
   1ab0a:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
   1ab0c:	6844      	ldr	r4, [r0, #4]
	_first += 1U;
   1ab0e:	b2db      	uxtb	r3, r3
		_first = 0U;
   1ab10:	429d      	cmp	r5, r3
   1ab12:	bf08      	it	eq
   1ab14:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1ab16:	7093      	strb	r3, [r2, #2]
	if (!evdone) {
   1ab18:	b154      	cbz	r4, 1ab30 <ull_event_done+0x3c>
	evdone->hdr.link = NULL;
   1ab1a:	2300      	movs	r3, #0
	link = evdone->hdr.link;
   1ab1c:	6820      	ldr	r0, [r4, #0]
	evdone->hdr.link = NULL;
   1ab1e:	6023      	str	r3, [r4, #0]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
   1ab20:	2301      	movs	r3, #1
   1ab22:	7123      	strb	r3, [r4, #4]
	evdone->param = param;
   1ab24:	6221      	str	r1, [r4, #32]
	ull_rx_put(link, evdone);
   1ab26:	4621      	mov	r1, r4
   1ab28:	f7ff fe28 	bl	1a77c <ull_rx_put>
	ull_rx_sched();
   1ab2c:	f7ff fe36 	bl	1a79c <ull_rx_sched>
}
   1ab30:	4620      	mov	r0, r4
   1ab32:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   1ab34:	2400      	movs	r4, #0
   1ab36:	e7fb      	b.n	1ab30 <ull_event_done+0x3c>
   1ab38:	200070c8 	.word	0x200070c8

0001ab3c <disabled_cb>:
		LL_ASSERT(!ret);
	}
}

static void disabled_cb(void *param)
{
   1ab3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct ll_adv_set *adv;
	struct node_rx_pdu *rx;
	struct node_rx_cc *cc;
	memq_link_t *link;

	adv = ((struct lll_hdr *)param)->parent;
   1ab3e:	6805      	ldr	r5, [r0, #0]

	LL_ASSERT(adv->link_cc_free);
   1ab40:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
{
   1ab44:	4606      	mov	r6, r0
	LL_ASSERT(adv->link_cc_free);
   1ab46:	b963      	cbnz	r3, 1ab62 <disabled_cb+0x26>
   1ab48:	4a1e      	ldr	r2, [pc, #120]	; (1abc4 <disabled_cb+0x88>)
   1ab4a:	491f      	ldr	r1, [pc, #124]	; (1abc8 <disabled_cb+0x8c>)
   1ab4c:	481f      	ldr	r0, [pc, #124]	; (1abcc <disabled_cb+0x90>)
   1ab4e:	f240 43b5 	movw	r3, #1205	; 0x4b5
   1ab52:	f009 f9c6 	bl	23ee2 <printk>
   1ab56:	4040      	eors	r0, r0
   1ab58:	f380 8811 	msr	BASEPRI, r0
   1ab5c:	f04f 0003 	mov.w	r0, #3
   1ab60:	df02      	svc	2
	link = adv->link_cc_free;
	adv->link_cc_free = NULL;
   1ab62:	2300      	movs	r3, #0
	link = adv->link_cc_free;
   1ab64:	f8d5 70d0 	ldr.w	r7, [r5, #208]	; 0xd0
	adv->link_cc_free = NULL;
   1ab68:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0

	LL_ASSERT(adv->node_rx_cc_free);
   1ab6c:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
   1ab70:	b963      	cbnz	r3, 1ab8c <disabled_cb+0x50>
   1ab72:	4a14      	ldr	r2, [pc, #80]	; (1abc4 <disabled_cb+0x88>)
   1ab74:	4916      	ldr	r1, [pc, #88]	; (1abd0 <disabled_cb+0x94>)
   1ab76:	4815      	ldr	r0, [pc, #84]	; (1abcc <disabled_cb+0x90>)
   1ab78:	f240 43b9 	movw	r3, #1209	; 0x4b9
   1ab7c:	f009 f9b1 	bl	23ee2 <printk>
   1ab80:	4040      	eors	r0, r0
   1ab82:	f380 8811 	msr	BASEPRI, r0
   1ab86:	f04f 0003 	mov.w	r0, #3
   1ab8a:	df02      	svc	2
	rx = adv->node_rx_cc_free;
   1ab8c:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
	adv->node_rx_cc_free = NULL;
   1ab90:	2100      	movs	r1, #0

	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1ab92:	2308      	movs	r3, #8
	adv->node_rx_cc_free = NULL;
   1ab94:	f8c5 10d4 	str.w	r1, [r5, #212]	; 0xd4
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1ab98:	7123      	strb	r3, [r4, #4]
	rx->hdr.handle = 0xffff;
   1ab9a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1ab9e:	80e3      	strh	r3, [r4, #6]

	cc = (void *)rx->pdu;
	memset(cc, 0x00, sizeof(struct node_rx_cc));
   1aba0:	2212      	movs	r2, #18
   1aba2:	f104 0020 	add.w	r0, r4, #32
   1aba6:	f00b f8aa 	bl	25cfe <memset>
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
   1abaa:	233c      	movs	r3, #60	; 0x3c
   1abac:	f884 3020 	strb.w	r3, [r4, #32]

	ftr = &(rx->hdr.rx_ftr);
	ftr->param = param;
   1abb0:	60a6      	str	r6, [r4, #8]

	ll_rx_put(link, rx);
   1abb2:	4621      	mov	r1, r4
   1abb4:	4638      	mov	r0, r7
   1abb6:	f7ff fca3 	bl	1a500 <ll_rx_put>
	ll_rx_sched();
}
   1abba:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ll_rx_sched();
   1abbe:	f7ff bca9 	b.w	1a514 <ll_rx_sched>
   1abc2:	bf00      	nop
   1abc4:	000304b2 	.word	0x000304b2
   1abc8:	000304f1 	.word	0x000304f1
   1abcc:	0002a5e8 	.word	0x0002a5e8
   1abd0:	00030503 	.word	0x00030503

0001abd4 <ticker_cb>:
{
   1abd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1abd8:	461d      	mov	r5, r3
	lll = &adv->lll;
   1abda:	f103 081c 	add.w	r8, r3, #28
	return ++hdr->ref;
   1abde:	7c1b      	ldrb	r3, [r3, #16]
   1abe0:	3301      	adds	r3, #1
   1abe2:	b2db      	uxtb	r3, r3
{
   1abe4:	b08a      	sub	sp, #40	; 0x28
   1abe6:	4607      	mov	r7, r0
   1abe8:	460e      	mov	r6, r1
   1abea:	4614      	mov	r4, r2
   1abec:	742b      	strb	r3, [r5, #16]
		LL_ASSERT(ref);
   1abee:	b963      	cbnz	r3, 1ac0a <ticker_cb+0x36>
   1abf0:	4a2f      	ldr	r2, [pc, #188]	; (1acb0 <ticker_cb+0xdc>)
   1abf2:	4930      	ldr	r1, [pc, #192]	; (1acb4 <ticker_cb+0xe0>)
   1abf4:	4830      	ldr	r0, [pc, #192]	; (1acb8 <ticker_cb+0xe4>)
   1abf6:	f240 4331 	movw	r3, #1073	; 0x431
   1abfa:	f009 f972 	bl	23ee2 <printk>
   1abfe:	4040      	eors	r0, r0
   1ac00:	f380 8811 	msr	BASEPRI, r0
   1ac04:	f04f 0003 	mov.w	r0, #3
   1ac08:	df02      	svc	2
		p.ticks_at_expire = ticks_at_expire;
   1ac0a:	4a2c      	ldr	r2, [pc, #176]	; (1acbc <ticker_cb+0xe8>)
		mfy.param = &p;
   1ac0c:	4b2c      	ldr	r3, [pc, #176]	; (1acc0 <ticker_cb+0xec>)
		p.lazy = lazy;
   1ac0e:	8114      	strh	r4, [r2, #8]
		p.remainder = remainder;
   1ac10:	e9c2 7600 	strd	r7, r6, [r2]
		p.param = lll;
   1ac14:	f8c2 800c 	str.w	r8, [r2, #12]
		mfy.param = &p;
   1ac18:	609a      	str	r2, [r3, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1ac1a:	2200      	movs	r2, #0
   1ac1c:	4611      	mov	r1, r2
   1ac1e:	2001      	movs	r0, #1
   1ac20:	f7fd fa84 	bl	1812c <mayfly_enqueue>
		LL_ASSERT(!ret);
   1ac24:	b160      	cbz	r0, 1ac40 <ticker_cb+0x6c>
   1ac26:	4a22      	ldr	r2, [pc, #136]	; (1acb0 <ticker_cb+0xdc>)
   1ac28:	4926      	ldr	r1, [pc, #152]	; (1acc4 <ticker_cb+0xf0>)
   1ac2a:	4823      	ldr	r0, [pc, #140]	; (1acb8 <ticker_cb+0xe4>)
   1ac2c:	f240 433d 	movw	r3, #1085	; 0x43d
   1ac30:	f009 f957 	bl	23ee2 <printk>
   1ac34:	4040      	eors	r0, r0
   1ac36:	f380 8811 	msr	BASEPRI, r0
   1ac3a:	f04f 0003 	mov.w	r0, #3
   1ac3e:	df02      	svc	2
	if (!lll->is_hdcd)
   1ac40:	f895 4028 	ldrb.w	r4, [r5, #40]	; 0x28
   1ac44:	f014 0401 	ands.w	r4, r4, #1
   1ac48:	d12f      	bne.n	1acaa <ticker_cb+0xd6>
		lll_entropy_get(sizeof(random_delay), &random_delay);
   1ac4a:	a909      	add	r1, sp, #36	; 0x24
   1ac4c:	2004      	movs	r0, #4
   1ac4e:	f002 f811 	bl	1cc74 <lll_entropy_get>
		random_delay %= ULL_ADV_RANDOM_DELAY;
   1ac52:	9909      	ldr	r1, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1ac54:	9506      	str	r5, [sp, #24]
		random_delay %= ULL_ADV_RANDOM_DELAY;
   1ac56:	f240 1247 	movw	r2, #327	; 0x147
   1ac5a:	fbb1 f3f2 	udiv	r3, r1, r2
   1ac5e:	fb02 1313 	mls	r3, r2, r3, r1
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1ac62:	4a19      	ldr	r2, [pc, #100]	; (1acc8 <ticker_cb+0xf4>)
   1ac64:	21dc      	movs	r1, #220	; 0xdc
   1ac66:	1aaa      	subs	r2, r5, r2
   1ac68:	fbb2 f2f1 	udiv	r2, r2, r1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1ac6c:	4917      	ldr	r1, [pc, #92]	; (1accc <ticker_cb+0xf8>)
				    (TICKER_ID_ADV_BASE +
   1ac6e:	3202      	adds	r2, #2
		random_delay += 1;
   1ac70:	3301      	adds	r3, #1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1ac72:	e9cd 4104 	strd	r4, r1, [sp, #16]
   1ac76:	e9cd 4402 	strd	r4, r4, [sp, #8]
   1ac7a:	e9cd 4400 	strd	r4, r4, [sp]
   1ac7e:	b2d2      	uxtb	r2, r2
   1ac80:	2101      	movs	r1, #1
   1ac82:	4620      	mov	r0, r4
		random_delay += 1;
   1ac84:	9309      	str	r3, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1ac86:	f7fe f835 	bl	18cf4 <ticker_update>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1ac8a:	f030 0302 	bics.w	r3, r0, #2
   1ac8e:	d00c      	beq.n	1acaa <ticker_cb+0xd6>
   1ac90:	4a07      	ldr	r2, [pc, #28]	; (1acb0 <ticker_cb+0xdc>)
   1ac92:	490f      	ldr	r1, [pc, #60]	; (1acd0 <ticker_cb+0xfc>)
   1ac94:	4808      	ldr	r0, [pc, #32]	; (1acb8 <ticker_cb+0xe4>)
   1ac96:	f240 4353 	movw	r3, #1107	; 0x453
   1ac9a:	f009 f922 	bl	23ee2 <printk>
   1ac9e:	4040      	eors	r0, r0
   1aca0:	f380 8811 	msr	BASEPRI, r0
   1aca4:	f04f 0003 	mov.w	r0, #3
   1aca8:	df02      	svc	2
}
   1acaa:	b00a      	add	sp, #40	; 0x28
   1acac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1acb0:	000304b2 	.word	0x000304b2
   1acb4:	00030491 	.word	0x00030491
   1acb8:	0002a5e8 	.word	0x0002a5e8
   1acbc:	20001734 	.word	0x20001734
   1acc0:	2000729c 	.word	0x2000729c
   1acc4:	00030473 	.word	0x00030473
   1acc8:	20001658 	.word	0x20001658
   1accc:	0001adf5 	.word	0x0001adf5
   1acd0:	00030518 	.word	0x00030518

0001acd4 <conn_release>:

static void conn_release(struct ll_adv_set *adv)
{
   1acd4:	b570      	push	{r4, r5, r6, lr}
	struct lll_conn *lll = adv->lll.conn;
   1acd6:	6a45      	ldr	r5, [r0, #36]	; 0x24
	memq_link_t *link;

	LL_ASSERT(!lll->link_tx_free);
   1acd8:	6d2b      	ldr	r3, [r5, #80]	; 0x50
{
   1acda:	4604      	mov	r4, r0
	LL_ASSERT(!lll->link_tx_free);
   1acdc:	b163      	cbz	r3, 1acf8 <conn_release+0x24>
   1acde:	4a1a      	ldr	r2, [pc, #104]	; (1ad48 <conn_release+0x74>)
   1ace0:	491a      	ldr	r1, [pc, #104]	; (1ad4c <conn_release+0x78>)
   1ace2:	481b      	ldr	r0, [pc, #108]	; (1ad50 <conn_release+0x7c>)
   1ace4:	f44f 639a 	mov.w	r3, #1232	; 0x4d0
   1ace8:	f009 f8fb 	bl	23ee2 <printk>
   1acec:	4040      	eors	r0, r0
   1acee:	f380 8811 	msr	BASEPRI, r0
   1acf2:	f04f 0003 	mov.w	r0, #3
   1acf6:	df02      	svc	2
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
   1acf8:	f105 0144 	add.w	r1, r5, #68	; 0x44
   1acfc:	f105 0040 	add.w	r0, r5, #64	; 0x40
   1ad00:	f00d fa13 	bl	2812a <memq_deinit>
	LL_ASSERT(link);
   1ad04:	4606      	mov	r6, r0
   1ad06:	b960      	cbnz	r0, 1ad22 <conn_release+0x4e>
   1ad08:	4a0f      	ldr	r2, [pc, #60]	; (1ad48 <conn_release+0x74>)
   1ad0a:	4912      	ldr	r1, [pc, #72]	; (1ad54 <conn_release+0x80>)
   1ad0c:	4810      	ldr	r0, [pc, #64]	; (1ad50 <conn_release+0x7c>)
   1ad0e:	f240 43d2 	movw	r3, #1234	; 0x4d2
   1ad12:	f009 f8e6 	bl	23ee2 <printk>
   1ad16:	4040      	eors	r0, r0
   1ad18:	f380 8811 	msr	BASEPRI, r0
   1ad1c:	f04f 0003 	mov.w	r0, #3
   1ad20:	df02      	svc	2
	lll->link_tx_free = link;

	ll_conn_release(lll->hdr.parent);
   1ad22:	6828      	ldr	r0, [r5, #0]
	lll->link_tx_free = link;
   1ad24:	652e      	str	r6, [r5, #80]	; 0x50
	adv->lll.conn = NULL;
   1ad26:	2500      	movs	r5, #0
	ll_conn_release(lll->hdr.parent);
   1ad28:	f000 fc50 	bl	1b5cc <ll_conn_release>

	ll_rx_release(adv->node_rx_cc_free);
   1ad2c:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
	adv->lll.conn = NULL;
   1ad30:	6265      	str	r5, [r4, #36]	; 0x24
	ll_rx_release(adv->node_rx_cc_free);
   1ad32:	f7ff fbdf 	bl	1a4f4 <ll_rx_release>
	adv->node_rx_cc_free = NULL;
	ll_rx_link_release(adv->link_cc_free);
   1ad36:	f8d4 00d0 	ldr.w	r0, [r4, #208]	; 0xd0
	adv->node_rx_cc_free = NULL;
   1ad3a:	f8c4 50d4 	str.w	r5, [r4, #212]	; 0xd4
	ll_rx_link_release(adv->link_cc_free);
   1ad3e:	f7ff fbcd 	bl	1a4dc <ll_rx_link_release>
	adv->link_cc_free = NULL;
   1ad42:	f8c4 50d0 	str.w	r5, [r4, #208]	; 0xd0
}
   1ad46:	bd70      	pop	{r4, r5, r6, pc}
   1ad48:	000304b2 	.word	0x000304b2
   1ad4c:	00030531 	.word	0x00030531
   1ad50:	0002a5e8 	.word	0x0002a5e8
   1ad54:	0002fa18 	.word	0x0002fa18

0001ad58 <ticker_op_stop_cb>:
{
   1ad58:	b570      	push	{r4, r5, r6, lr}
   1ad5a:	460c      	mov	r4, r1
	if (status != TICKER_STATUS_SUCCESS) {
   1ad5c:	2800      	cmp	r0, #0
   1ad5e:	d12f      	bne.n	1adc0 <ticker_op_stop_cb+0x68>
	mfy.param = &adv->lll;
   1ad60:	4b1d      	ldr	r3, [pc, #116]	; (1add8 <ticker_op_stop_cb+0x80>)
   1ad62:	4d1e      	ldr	r5, [pc, #120]	; (1addc <ticker_op_stop_cb+0x84>)
   1ad64:	f101 021c 	add.w	r2, r1, #28
   1ad68:	609a      	str	r2, [r3, #8]
	if (hdr->ref) {
   1ad6a:	7c0a      	ldrb	r2, [r1, #16]
   1ad6c:	461e      	mov	r6, r3
   1ad6e:	b342      	cbz	r2, 1adc2 <ticker_op_stop_cb+0x6a>
		LL_ASSERT(!hdr->disabled_cb);
   1ad70:	694b      	ldr	r3, [r1, #20]
   1ad72:	b163      	cbz	r3, 1ad8e <ticker_op_stop_cb+0x36>
   1ad74:	4a1a      	ldr	r2, [pc, #104]	; (1ade0 <ticker_op_stop_cb+0x88>)
   1ad76:	491b      	ldr	r1, [pc, #108]	; (1ade4 <ticker_op_stop_cb+0x8c>)
   1ad78:	481b      	ldr	r0, [pc, #108]	; (1ade8 <ticker_op_stop_cb+0x90>)
   1ad7a:	f240 439b 	movw	r3, #1179	; 0x49b
   1ad7e:	f009 f8b0 	bl	23ee2 <printk>
   1ad82:	4040      	eors	r0, r0
   1ad84:	f380 8811 	msr	BASEPRI, r0
   1ad88:	f04f 0003 	mov.w	r0, #3
   1ad8c:	df02      	svc	2
		hdr->disabled_param = mfy.param;
   1ad8e:	68b3      	ldr	r3, [r6, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1ad90:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
   1ad92:	e9c4 5305 	strd	r5, r3, [r4, #20]
		mfy.fp = lll_disable;
   1ad96:	4b15      	ldr	r3, [pc, #84]	; (1adec <ticker_op_stop_cb+0x94>)
   1ad98:	60f3      	str	r3, [r6, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1ad9a:	4611      	mov	r1, r2
   1ad9c:	4b0e      	ldr	r3, [pc, #56]	; (1add8 <ticker_op_stop_cb+0x80>)
   1ad9e:	2002      	movs	r0, #2
   1ada0:	f7fd f9c4 	bl	1812c <mayfly_enqueue>
		LL_ASSERT(!ret);
   1ada4:	b160      	cbz	r0, 1adc0 <ticker_op_stop_cb+0x68>
   1ada6:	f240 43a2 	movw	r3, #1186	; 0x4a2
		LL_ASSERT(!ret);
   1adaa:	4a0d      	ldr	r2, [pc, #52]	; (1ade0 <ticker_op_stop_cb+0x88>)
   1adac:	4910      	ldr	r1, [pc, #64]	; (1adf0 <ticker_op_stop_cb+0x98>)
   1adae:	480e      	ldr	r0, [pc, #56]	; (1ade8 <ticker_op_stop_cb+0x90>)
   1adb0:	f009 f897 	bl	23ee2 <printk>
   1adb4:	4040      	eors	r0, r0
   1adb6:	f380 8811 	msr	BASEPRI, r0
   1adba:	f04f 0003 	mov.w	r0, #3
   1adbe:	df02      	svc	2
}
   1adc0:	bd70      	pop	{r4, r5, r6, pc}
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1adc2:	2101      	movs	r1, #1
   1adc4:	2002      	movs	r0, #2
		mfy.fp = disabled_cb;
   1adc6:	60dd      	str	r5, [r3, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1adc8:	f7fd f9b0 	bl	1812c <mayfly_enqueue>
		LL_ASSERT(!ret);
   1adcc:	2800      	cmp	r0, #0
   1adce:	d0f7      	beq.n	1adc0 <ticker_op_stop_cb+0x68>
   1add0:	f240 43a7 	movw	r3, #1191	; 0x4a7
   1add4:	e7e9      	b.n	1adaa <ticker_op_stop_cb+0x52>
   1add6:	bf00      	nop
   1add8:	200072ac 	.word	0x200072ac
   1addc:	0001ab3d 	.word	0x0001ab3d
   1ade0:	000304b2 	.word	0x000304b2
   1ade4:	00030544 	.word	0x00030544
   1ade8:	0002a5e8 	.word	0x0002a5e8
   1adec:	0001cce1 	.word	0x0001cce1
   1adf0:	00030473 	.word	0x00030473

0001adf4 <ticker_op_update_cb>:
{
   1adf4:	b510      	push	{r4, lr}
   1adf6:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   1adf8:	b180      	cbz	r0, 1ae1c <ticker_op_update_cb+0x28>
   1adfa:	f7ff fc33 	bl	1a664 <ull_disable_mark_get>
   1adfe:	4284      	cmp	r4, r0
   1ae00:	d00c      	beq.n	1ae1c <ticker_op_update_cb+0x28>
   1ae02:	4a07      	ldr	r2, [pc, #28]	; (1ae20 <ticker_op_update_cb+0x2c>)
   1ae04:	4907      	ldr	r1, [pc, #28]	; (1ae24 <ticker_op_update_cb+0x30>)
   1ae06:	4808      	ldr	r0, [pc, #32]	; (1ae28 <ticker_op_update_cb+0x34>)
   1ae08:	f240 435c 	movw	r3, #1116	; 0x45c
   1ae0c:	f009 f869 	bl	23ee2 <printk>
   1ae10:	4040      	eors	r0, r0
   1ae12:	f380 8811 	msr	BASEPRI, r0
   1ae16:	f04f 0003 	mov.w	r0, #3
   1ae1a:	df02      	svc	2
}
   1ae1c:	bd10      	pop	{r4, pc}
   1ae1e:	bf00      	nop
   1ae20:	000304b2 	.word	0x000304b2
   1ae24:	00030556 	.word	0x00030556
   1ae28:	0002a5e8 	.word	0x0002a5e8

0001ae2c <ticker_stop_cb>:
{
   1ae2c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1ae2e:	4c17      	ldr	r4, [pc, #92]	; (1ae8c <ticker_stop_cb+0x60>)
{
   1ae30:	461d      	mov	r5, r3
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1ae32:	1b1c      	subs	r4, r3, r4
   1ae34:	22dc      	movs	r2, #220	; 0xdc
   1ae36:	fbb4 f4f2 	udiv	r4, r4, r2
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
   1ae3a:	b2a3      	uxth	r3, r4
   1ae3c:	b163      	cbz	r3, 1ae58 <ticker_stop_cb+0x2c>
   1ae3e:	4a14      	ldr	r2, [pc, #80]	; (1ae90 <ticker_stop_cb+0x64>)
   1ae40:	4914      	ldr	r1, [pc, #80]	; (1ae94 <ticker_stop_cb+0x68>)
   1ae42:	4815      	ldr	r0, [pc, #84]	; (1ae98 <ticker_stop_cb+0x6c>)
   1ae44:	f44f 638f 	mov.w	r3, #1144	; 0x478
   1ae48:	f009 f84b 	bl	23ee2 <printk>
   1ae4c:	4040      	eors	r0, r0
   1ae4e:	f380 8811 	msr	BASEPRI, r0
   1ae52:	f04f 0003 	mov.w	r0, #3
   1ae56:	df02      	svc	2
			  TICKER_ID_ADV_BASE + handle,
   1ae58:	1ca2      	adds	r2, r4, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
   1ae5a:	4b10      	ldr	r3, [pc, #64]	; (1ae9c <ticker_stop_cb+0x70>)
   1ae5c:	9500      	str	r5, [sp, #0]
   1ae5e:	b2d2      	uxtb	r2, r2
   1ae60:	2101      	movs	r1, #1
   1ae62:	2000      	movs	r0, #0
   1ae64:	f7fd ff8c 	bl	18d80 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1ae68:	f030 0302 	bics.w	r3, r0, #2
   1ae6c:	d00c      	beq.n	1ae88 <ticker_stop_cb+0x5c>
   1ae6e:	4a08      	ldr	r2, [pc, #32]	; (1ae90 <ticker_stop_cb+0x64>)
   1ae70:	490b      	ldr	r1, [pc, #44]	; (1aea0 <ticker_stop_cb+0x74>)
   1ae72:	4809      	ldr	r0, [pc, #36]	; (1ae98 <ticker_stop_cb+0x6c>)
   1ae74:	f240 437d 	movw	r3, #1149	; 0x47d
   1ae78:	f009 f833 	bl	23ee2 <printk>
   1ae7c:	4040      	eors	r0, r0
   1ae7e:	f380 8811 	msr	BASEPRI, r0
   1ae82:	f04f 0003 	mov.w	r0, #3
   1ae86:	df02      	svc	2
}
   1ae88:	b003      	add	sp, #12
   1ae8a:	bd30      	pop	{r4, r5, pc}
   1ae8c:	20001658 	.word	0x20001658
   1ae90:	000304b2 	.word	0x000304b2
   1ae94:	00030585 	.word	0x00030585
   1ae98:	0002a5e8 	.word	0x0002a5e8
   1ae9c:	0001ad59 	.word	0x0001ad59
   1aea0:	00030518 	.word	0x00030518

0001aea4 <ll_adv_params_set>:
{
   1aea4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   1aea6:	4c31      	ldr	r4, [pc, #196]	; (1af6c <ll_adv_params_set+0xc8>)
{
   1aea8:	4607      	mov	r7, r0
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   1aeaa:	6820      	ldr	r0, [r4, #0]
   1aeac:	9000      	str	r0, [sp, #0]
   1aeae:	7920      	ldrb	r0, [r4, #4]
	if (!adv || adv->is_enabled) {
   1aeb0:	4c2f      	ldr	r4, [pc, #188]	; (1af70 <ll_adv_params_set+0xcc>)
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   1aeb2:	f88d 0004 	strb.w	r0, [sp, #4]
	if (!adv || adv->is_enabled) {
   1aeb6:	f894 60cc 	ldrb.w	r6, [r4, #204]	; 0xcc
   1aeba:	f016 0601 	ands.w	r6, r6, #1
   1aebe:	d153      	bne.n	1af68 <ll_adv_params_set+0xc4>
	adv->lll.chan_map = chan_map;
   1aec0:	f89d 0028 	ldrb.w	r0, [sp, #40]	; 0x28
   1aec4:	f000 0503 	and.w	r5, r0, #3
   1aec8:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
   1aecc:	f000 0007 	and.w	r0, r0, #7
   1aed0:	0040      	lsls	r0, r0, #1
   1aed2:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
   1aed6:	8d25      	ldrh	r5, [r4, #40]	; 0x28
   1aed8:	f425 7543 	bic.w	r5, r5, #780	; 0x30c
   1aedc:	f025 0502 	bic.w	r5, r5, #2
	pdu->type = pdu_adv_type[adv_type];
   1aee0:	f10d 0c08 	add.w	ip, sp, #8
		adv->interval = 0;
   1aee4:	2901      	cmp	r1, #1
	adv->lll.chan_map = chan_map;
   1aee6:	ea40 0005 	orr.w	r0, r0, r5
	pdu->type = pdu_adv_type[adv_type];
   1aeea:	4461      	add	r1, ip
		adv->interval = 0;
   1aeec:	bf08      	it	eq
   1aeee:	2700      	moveq	r7, #0
	adv->lll.chan_map = chan_map;
   1aef0:	8520      	strh	r0, [r4, #40]	; 0x28
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   1aef2:	f894 002b 	ldrb.w	r0, [r4, #43]	; 0x2b
   1aef6:	f8a4 70d8 	strh.w	r7, [r4, #216]	; 0xd8
   1aefa:	252c      	movs	r5, #44	; 0x2c
   1aefc:	2727      	movs	r7, #39	; 0x27
	pdu->type = pdu_adv_type[adv_type];
   1aefe:	f811 1c08 	ldrb.w	r1, [r1, #-8]
   1af02:	fb17 5000 	smlabb	r0, r7, r0, r5
   1af06:	0195      	lsls	r5, r2, #6
   1af08:	f001 010f 	and.w	r1, r1, #15
   1af0c:	f005 0240 	and.w	r2, r5, #64	; 0x40
   1af10:	430a      	orrs	r2, r1
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   1af12:	f002 010f 	and.w	r1, r2, #15
   1af16:	2901      	cmp	r1, #1
	pdu->type = pdu_adv_type[adv_type];
   1af18:	5422      	strb	r2, [r4, r0]
   1af1a:	eb04 0700 	add.w	r7, r4, r0
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   1af1e:	d11e      	bne.n	1af5e <ll_adv_params_set+0xba>
		pdu->rx_addr = direct_addr_type;
   1af20:	f363 12c7 	bfi	r2, r3, #7, #1
   1af24:	5422      	strb	r2, [r4, r0]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
   1af26:	9908      	ldr	r1, [sp, #32]
   1af28:	2206      	movs	r2, #6
   1af2a:	f107 0008 	add.w	r0, r7, #8
   1af2e:	f00a febb 	bl	25ca8 <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
   1af32:	230c      	movs	r3, #12
		pdu->len = BDADDR_SIZE;
   1af34:	707b      	strb	r3, [r7, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   1af36:	f894 107b 	ldrb.w	r1, [r4, #123]	; 0x7b
   1af3a:	227c      	movs	r2, #124	; 0x7c
   1af3c:	2327      	movs	r3, #39	; 0x27
   1af3e:	fb13 2301 	smlabb	r3, r3, r1, r2
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   1af42:	f005 0540 	and.w	r5, r5, #64	; 0x40
   1af46:	f045 0504 	orr.w	r5, r5, #4
   1af4a:	54e5      	strb	r5, [r4, r3]
   1af4c:	18e2      	adds	r2, r4, r3
	if (pdu->len == 0) {
   1af4e:	7853      	ldrb	r3, [r2, #1]
   1af50:	b913      	cbnz	r3, 1af58 <ll_adv_params_set+0xb4>
		pdu->len = BDADDR_SIZE;
   1af52:	2106      	movs	r1, #6
   1af54:	7051      	strb	r1, [r2, #1]
	return 0;
   1af56:	461e      	mov	r6, r3
}
   1af58:	4630      	mov	r0, r6
   1af5a:	b003      	add	sp, #12
   1af5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (pdu->len == 0) {
   1af5e:	787b      	ldrb	r3, [r7, #1]
   1af60:	2b00      	cmp	r3, #0
   1af62:	d1e8      	bne.n	1af36 <ll_adv_params_set+0x92>
		pdu->len = BDADDR_SIZE;
   1af64:	2306      	movs	r3, #6
   1af66:	e7e5      	b.n	1af34 <ll_adv_params_set+0x90>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1af68:	260c      	movs	r6, #12
   1af6a:	e7f5      	b.n	1af58 <ll_adv_params_set+0xb4>
   1af6c:	00029ab3 	.word	0x00029ab3
   1af70:	20001658 	.word	0x20001658

0001af74 <ll_adv_data_set>:
{
   1af74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   1af78:	4d1c      	ldr	r5, [pc, #112]	; (1afec <ll_adv_data_set+0x78>)
   1af7a:	f895 402b 	ldrb.w	r4, [r5, #43]	; 0x2b
   1af7e:	222c      	movs	r2, #44	; 0x2c
   1af80:	2327      	movs	r3, #39	; 0x27
   1af82:	fb13 2304 	smlabb	r3, r3, r4, r2
   1af86:	4688      	mov	r8, r1
   1af88:	18e9      	adds	r1, r5, r3
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
   1af8a:	5ceb      	ldrb	r3, [r5, r3]
   1af8c:	f003 020f 	and.w	r2, r3, #15
   1af90:	2a01      	cmp	r2, #1
{
   1af92:	4606      	mov	r6, r0
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
   1af94:	d026      	beq.n	1afe4 <ll_adv_data_set+0x70>
	if (pdu->first == pdu->last) {
   1af96:	f895 202a 	ldrb.w	r2, [r5, #42]	; 0x2a
   1af9a:	42a2      	cmp	r2, r4
   1af9c:	d104      	bne.n	1afa8 <ll_adv_data_set+0x34>
		last = pdu->last + 1;
   1af9e:	3401      	adds	r4, #1
   1afa0:	b2e4      	uxtb	r4, r4
			last = 0U;
   1afa2:	2c02      	cmp	r4, #2
   1afa4:	bf08      	it	eq
   1afa6:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   1afa8:	222c      	movs	r2, #44	; 0x2c
   1afaa:	2027      	movs	r0, #39	; 0x27
   1afac:	fb10 2004 	smlabb	r0, r0, r4, r2
	pdu->tx_addr = prev->tx_addr;
   1afb0:	f3c3 1c80 	ubfx	ip, r3, #6, #1
	pdu->type = prev->type;
   1afb4:	f3c3 0203 	ubfx	r2, r3, #0, #4
   1afb8:	ea42 128c 	orr.w	r2, r2, ip, lsl #6
   1afbc:	f003 0380 	and.w	r3, r3, #128	; 0x80
   1afc0:	4313      	orrs	r3, r2
   1afc2:	182f      	adds	r7, r5, r0
   1afc4:	542b      	strb	r3, [r5, r0]
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
   1afc6:	2206      	movs	r2, #6
   1afc8:	3102      	adds	r1, #2
   1afca:	1cb8      	adds	r0, r7, #2
   1afcc:	f00a fe6c 	bl	25ca8 <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
   1afd0:	4632      	mov	r2, r6
   1afd2:	4641      	mov	r1, r8
   1afd4:	f107 0008 	add.w	r0, r7, #8
	pdu->len = BDADDR_SIZE + len;
   1afd8:	3606      	adds	r6, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
   1afda:	f00a fe65 	bl	25ca8 <memcpy>
	pdu->len = BDADDR_SIZE + len;
   1afde:	707e      	strb	r6, [r7, #1]
	pdu->last = idx;
   1afe0:	f885 402b 	strb.w	r4, [r5, #43]	; 0x2b
}
   1afe4:	2000      	movs	r0, #0
   1afe6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1afea:	bf00      	nop
   1afec:	20001658 	.word	0x20001658

0001aff0 <ll_adv_scan_rsp_set>:
{
   1aff0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   1aff4:	4b19      	ldr	r3, [pc, #100]	; (1b05c <ll_adv_scan_rsp_set+0x6c>)
   1aff6:	f893 407b 	ldrb.w	r4, [r3, #123]	; 0x7b
   1affa:	227c      	movs	r2, #124	; 0x7c
   1affc:	4605      	mov	r5, r0
   1affe:	2027      	movs	r0, #39	; 0x27
   1b000:	fb10 2004 	smlabb	r0, r0, r4, r2
	if (pdu->first == pdu->last) {
   1b004:	f893 207a 	ldrb.w	r2, [r3, #122]	; 0x7a
   1b008:	42a2      	cmp	r2, r4
   1b00a:	4688      	mov	r8, r1
   1b00c:	461e      	mov	r6, r3
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   1b00e:	eb03 0100 	add.w	r1, r3, r0
	if (pdu->first == pdu->last) {
   1b012:	d104      	bne.n	1b01e <ll_adv_scan_rsp_set+0x2e>
		last = pdu->last + 1;
   1b014:	3401      	adds	r4, #1
   1b016:	b2e4      	uxtb	r4, r4
			last = 0U;
   1b018:	2c02      	cmp	r4, #2
   1b01a:	bf08      	it	eq
   1b01c:	2400      	moveq	r4, #0
	pdu->tx_addr = prev->tx_addr;
   1b01e:	5c1b      	ldrb	r3, [r3, r0]
	return (void *)pdu->pdu[last];
   1b020:	277c      	movs	r7, #124	; 0x7c
   1b022:	2227      	movs	r2, #39	; 0x27
   1b024:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1b028:	fb12 7204 	smlabb	r2, r2, r4, r7
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   1b02c:	019b      	lsls	r3, r3, #6
   1b02e:	18b7      	adds	r7, r6, r2
   1b030:	f043 0304 	orr.w	r3, r3, #4
   1b034:	54b3      	strb	r3, [r6, r2]
	pdu->len = BDADDR_SIZE + len;
   1b036:	1dab      	adds	r3, r5, #6
   1b038:	707b      	strb	r3, [r7, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
   1b03a:	2206      	movs	r2, #6
   1b03c:	3102      	adds	r1, #2
   1b03e:	1cb8      	adds	r0, r7, #2
   1b040:	f00a fe32 	bl	25ca8 <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
   1b044:	462a      	mov	r2, r5
   1b046:	4641      	mov	r1, r8
   1b048:	f107 0008 	add.w	r0, r7, #8
   1b04c:	f00a fe2c 	bl	25ca8 <memcpy>
	pdu->last = idx;
   1b050:	f886 407b 	strb.w	r4, [r6, #123]	; 0x7b
}
   1b054:	2000      	movs	r0, #0
   1b056:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1b05a:	bf00      	nop
   1b05c:	20001658 	.word	0x20001658

0001b060 <ull_adv_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1b060:	4b03      	ldr	r3, [pc, #12]	; (1b070 <ull_adv_handle_get+0x10>)
   1b062:	1ac0      	subs	r0, r0, r3
   1b064:	23dc      	movs	r3, #220	; 0xdc
   1b066:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1b06a:	b280      	uxth	r0, r0
   1b06c:	4770      	bx	lr
   1b06e:	bf00      	nop
   1b070:	20001658 	.word	0x20001658

0001b074 <ull_adv_lll_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1b074:	6800      	ldr	r0, [r0, #0]
   1b076:	4b03      	ldr	r3, [pc, #12]	; (1b084 <ull_adv_lll_handle_get+0x10>)
   1b078:	1ac0      	subs	r0, r0, r3
   1b07a:	23dc      	movs	r3, #220	; 0xdc
   1b07c:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1b080:	b280      	uxth	r0, r0
   1b082:	4770      	bx	lr
   1b084:	20001658 	.word	0x20001658

0001b088 <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_MAX) {
   1b088:	b938      	cbnz	r0, 1b09a <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
   1b08a:	4805      	ldr	r0, [pc, #20]	; (1b0a0 <ull_adv_is_enabled_get+0x18>)
   1b08c:	f890 30cc 	ldrb.w	r3, [r0, #204]	; 0xcc
	return &ll_adv[handle];
   1b090:	f013 0f01 	tst.w	r3, #1
   1b094:	bf08      	it	eq
   1b096:	2000      	moveq	r0, #0
   1b098:	4770      	bx	lr
		return NULL;
   1b09a:	2000      	movs	r0, #0
}
   1b09c:	4770      	bx	lr
   1b09e:	bf00      	nop
   1b0a0:	20001658 	.word	0x20001658

0001b0a4 <disable.constprop.0>:
#endif /* CONFIG_BT_PERIPHERAL */

static inline u8_t disable(u16_t handle)
   1b0a4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
{
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1b0a6:	2302      	movs	r3, #2
	struct ll_adv_set *adv;
	void *mark;
	u32_t ret;

	adv = ull_adv_is_enabled_get(handle);
   1b0a8:	2000      	movs	r0, #0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1b0aa:	9303      	str	r3, [sp, #12]
	adv = ull_adv_is_enabled_get(handle);
   1b0ac:	f7ff ffec 	bl	1b088 <ull_adv_is_enabled_get>
	if (!adv) {
   1b0b0:	4604      	mov	r4, r0
   1b0b2:	b910      	cbnz	r0, 1b0ba <disable.constprop.0+0x16>
		ret = ull_ticker_status_take(ret, &ret_cb);
		if (ret) {
			mark = ull_disable_mark(adv);
			LL_ASSERT(mark == adv);

			return BT_HCI_ERR_CMD_DISALLOWED;
   1b0b4:	200c      	movs	r0, #12
		ull_filter_adv_scan_state_cb(0);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return 0;
}
   1b0b6:	b004      	add	sp, #16
   1b0b8:	bd10      	pop	{r4, pc}
	mark = ull_disable_mark(adv);
   1b0ba:	f7ff fabd 	bl	1a638 <ull_disable_mark>
	LL_ASSERT(mark == adv);
   1b0be:	4284      	cmp	r4, r0
   1b0c0:	d00c      	beq.n	1b0dc <disable.constprop.0+0x38>
   1b0c2:	4a3b      	ldr	r2, [pc, #236]	; (1b1b0 <disable.constprop.0+0x10c>)
   1b0c4:	493b      	ldr	r1, [pc, #236]	; (1b1b4 <disable.constprop.0+0x110>)
   1b0c6:	483c      	ldr	r0, [pc, #240]	; (1b1b8 <disable.constprop.0+0x114>)
   1b0c8:	f240 43ec 	movw	r3, #1260	; 0x4ec
   1b0cc:	f008 ff09 	bl	23ee2 <printk>
   1b0d0:	4040      	eors	r0, r0
   1b0d2:	f380 8811 	msr	BASEPRI, r0
   1b0d6:	f04f 0003 	mov.w	r0, #3
   1b0da:	df02      	svc	2
	if (adv->lll.is_hdcd) {
   1b0dc:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   1b0e0:	07db      	lsls	r3, r3, #31
   1b0e2:	d520      	bpl.n	1b126 <disable.constprop.0+0x82>
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   1b0e4:	ab03      	add	r3, sp, #12
   1b0e6:	9300      	str	r3, [sp, #0]
   1b0e8:	2103      	movs	r1, #3
   1b0ea:	4b34      	ldr	r3, [pc, #208]	; (1b1bc <disable.constprop.0+0x118>)
   1b0ec:	2201      	movs	r2, #1
   1b0ee:	2000      	movs	r0, #0
   1b0f0:	f7fd fe46 	bl	18d80 <ticker_stop>
		ret = ull_ticker_status_take(ret, &ret_cb);
   1b0f4:	a903      	add	r1, sp, #12
   1b0f6:	f7ff fa93 	bl	1a620 <ull_ticker_status_take>
		if (ret) {
   1b0fa:	b190      	cbz	r0, 1b122 <disable.constprop.0+0x7e>
			mark = ull_disable_mark(adv);
   1b0fc:	4620      	mov	r0, r4
   1b0fe:	f7ff fa9b 	bl	1a638 <ull_disable_mark>
			LL_ASSERT(mark == adv);
   1b102:	4284      	cmp	r4, r0
   1b104:	d0d6      	beq.n	1b0b4 <disable.constprop.0+0x10>
   1b106:	f240 43f6 	movw	r3, #1270	; 0x4f6
   1b10a:	4a29      	ldr	r2, [pc, #164]	; (1b1b0 <disable.constprop.0+0x10c>)
   1b10c:	4929      	ldr	r1, [pc, #164]	; (1b1b4 <disable.constprop.0+0x110>)
   1b10e:	482a      	ldr	r0, [pc, #168]	; (1b1b8 <disable.constprop.0+0x114>)
   1b110:	f008 fee7 	bl	23ee2 <printk>
   1b114:	4040      	eors	r0, r0
   1b116:	f380 8811 	msr	BASEPRI, r0
   1b11a:	f04f 0003 	mov.w	r0, #3
   1b11e:	df02      	svc	2
   1b120:	e7c8      	b.n	1b0b4 <disable.constprop.0+0x10>
		ret_cb = TICKER_STATUS_BUSY;
   1b122:	2302      	movs	r3, #2
   1b124:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1b126:	ab03      	add	r3, sp, #12
   1b128:	9300      	str	r3, [sp, #0]
   1b12a:	2103      	movs	r1, #3
   1b12c:	4b23      	ldr	r3, [pc, #140]	; (1b1bc <disable.constprop.0+0x118>)
   1b12e:	2202      	movs	r2, #2
   1b130:	2000      	movs	r0, #0
   1b132:	f7fd fe25 	bl	18d80 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   1b136:	a903      	add	r1, sp, #12
   1b138:	f7ff fa72 	bl	1a620 <ull_ticker_status_take>
	if (ret) {
   1b13c:	b138      	cbz	r0, 1b14e <disable.constprop.0+0xaa>
		mark = ull_disable_mark(adv);
   1b13e:	4620      	mov	r0, r4
   1b140:	f7ff fa7a 	bl	1a638 <ull_disable_mark>
		LL_ASSERT(mark == adv);
   1b144:	4284      	cmp	r4, r0
   1b146:	d0b5      	beq.n	1b0b4 <disable.constprop.0+0x10>
   1b148:	f240 5305 	movw	r3, #1285	; 0x505
   1b14c:	e7dd      	b.n	1b10a <disable.constprop.0+0x66>
	ret = ull_disable(&adv->lll);
   1b14e:	f104 001c 	add.w	r0, r4, #28
   1b152:	f7ff faa9 	bl	1a6a8 <ull_disable>
	LL_ASSERT(!ret);
   1b156:	b160      	cbz	r0, 1b172 <disable.constprop.0+0xce>
   1b158:	4a15      	ldr	r2, [pc, #84]	; (1b1b0 <disable.constprop.0+0x10c>)
   1b15a:	4919      	ldr	r1, [pc, #100]	; (1b1c0 <disable.constprop.0+0x11c>)
   1b15c:	4816      	ldr	r0, [pc, #88]	; (1b1b8 <disable.constprop.0+0x114>)
   1b15e:	f240 530b 	movw	r3, #1291	; 0x50b
   1b162:	f008 febe 	bl	23ee2 <printk>
   1b166:	4040      	eors	r0, r0
   1b168:	f380 8811 	msr	BASEPRI, r0
   1b16c:	f04f 0003 	mov.w	r0, #3
   1b170:	df02      	svc	2
	mark = ull_disable_unmark(adv);
   1b172:	4620      	mov	r0, r4
   1b174:	f7ff fa68 	bl	1a648 <ull_disable_unmark>
	LL_ASSERT(mark == adv);
   1b178:	4284      	cmp	r4, r0
   1b17a:	d00c      	beq.n	1b196 <disable.constprop.0+0xf2>
   1b17c:	4a0c      	ldr	r2, [pc, #48]	; (1b1b0 <disable.constprop.0+0x10c>)
   1b17e:	490d      	ldr	r1, [pc, #52]	; (1b1b4 <disable.constprop.0+0x110>)
   1b180:	480d      	ldr	r0, [pc, #52]	; (1b1b8 <disable.constprop.0+0x114>)
   1b182:	f240 530e 	movw	r3, #1294	; 0x50e
   1b186:	f008 feac 	bl	23ee2 <printk>
   1b18a:	4040      	eors	r0, r0
   1b18c:	f380 8811 	msr	BASEPRI, r0
   1b190:	f04f 0003 	mov.w	r0, #3
   1b194:	df02      	svc	2
	if (adv->lll.conn) {
   1b196:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1b198:	b113      	cbz	r3, 1b1a0 <disable.constprop.0+0xfc>
		conn_release(adv);
   1b19a:	4620      	mov	r0, r4
   1b19c:	f7ff fd9a 	bl	1acd4 <conn_release>
	adv->is_enabled = 0U;
   1b1a0:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
   1b1a4:	f36f 0300 	bfc	r3, #0, #1
   1b1a8:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	return 0;
   1b1ac:	2000      	movs	r0, #0
   1b1ae:	e782      	b.n	1b0b6 <disable.constprop.0+0x12>
   1b1b0:	000304b2 	.word	0x000304b2
   1b1b4:	00030590 	.word	0x00030590
   1b1b8:	0002a5e8 	.word	0x0002a5e8
   1b1bc:	0001a615 	.word	0x0001a615
   1b1c0:	00030473 	.word	0x00030473

0001b1c4 <ticker_cb>:
	return 0;
}

static void ticker_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
		      void *param)
{
   1b1c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b1c6:	461c      	mov	r4, r3
   1b1c8:	7c1b      	ldrb	r3, [r3, #16]
   1b1ca:	3301      	adds	r3, #1
   1b1cc:	b2db      	uxtb	r3, r3
   1b1ce:	4607      	mov	r7, r0
   1b1d0:	460e      	mov	r6, r1
   1b1d2:	4615      	mov	r5, r2
   1b1d4:	7423      	strb	r3, [r4, #16]

	DEBUG_RADIO_PREPARE_O(1);

	/* Increment prepare reference count */
	ref = ull_ref_inc(&scan->ull);
	LL_ASSERT(ref);
   1b1d6:	b963      	cbnz	r3, 1b1f2 <ticker_cb+0x2e>
   1b1d8:	4a14      	ldr	r2, [pc, #80]	; (1b22c <ticker_cb+0x68>)
   1b1da:	4915      	ldr	r1, [pc, #84]	; (1b230 <ticker_cb+0x6c>)
   1b1dc:	4815      	ldr	r0, [pc, #84]	; (1b234 <ticker_cb+0x70>)
   1b1de:	f44f 73c4 	mov.w	r3, #392	; 0x188
   1b1e2:	f008 fe7e 	bl	23ee2 <printk>
   1b1e6:	4040      	eors	r0, r0
   1b1e8:	f380 8811 	msr	BASEPRI, r0
   1b1ec:	f04f 0003 	mov.w	r0, #3
   1b1f0:	df02      	svc	2

	/* Append timing parameters */
	p.ticks_at_expire = ticks_at_expire;
   1b1f2:	4a11      	ldr	r2, [pc, #68]	; (1b238 <ticker_cb+0x74>)
	p.remainder = remainder;
	p.lazy = lazy;
	p.param = &scan->lll;
	mfy.param = &p;
   1b1f4:	4b11      	ldr	r3, [pc, #68]	; (1b23c <ticker_cb+0x78>)
	p.lazy = lazy;
   1b1f6:	8115      	strh	r5, [r2, #8]
	p.param = &scan->lll;
   1b1f8:	341c      	adds	r4, #28
	p.remainder = remainder;
   1b1fa:	e9c2 7600 	strd	r7, r6, [r2]
	p.param = &scan->lll;
   1b1fe:	60d4      	str	r4, [r2, #12]
	mfy.param = &p;
   1b200:	609a      	str	r2, [r3, #8]

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1b202:	2200      	movs	r2, #0
   1b204:	4611      	mov	r1, r2
   1b206:	2001      	movs	r0, #1
   1b208:	f7fc ff90 	bl	1812c <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
   1b20c:	b160      	cbz	r0, 1b228 <ticker_cb+0x64>
   1b20e:	4a07      	ldr	r2, [pc, #28]	; (1b22c <ticker_cb+0x68>)
   1b210:	490b      	ldr	r1, [pc, #44]	; (1b240 <ticker_cb+0x7c>)
   1b212:	4808      	ldr	r0, [pc, #32]	; (1b234 <ticker_cb+0x70>)
   1b214:	f44f 73ca 	mov.w	r3, #404	; 0x194
   1b218:	f008 fe63 	bl	23ee2 <printk>
   1b21c:	4040      	eors	r0, r0
   1b21e:	f380 8811 	msr	BASEPRI, r0
   1b222:	f04f 0003 	mov.w	r0, #3
   1b226:	df02      	svc	2
		LL_ASSERT(!retval);
	}
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	DEBUG_RADIO_PREPARE_O(1);
}
   1b228:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1b22a:	bf00      	nop
   1b22c:	000305ac 	.word	0x000305ac
   1b230:	00030491 	.word	0x00030491
   1b234:	0002a5e8 	.word	0x0002a5e8
   1b238:	20001788 	.word	0x20001788
   1b23c:	200072bc 	.word	0x200072bc
   1b240:	00030473 	.word	0x00030473

0001b244 <ull_scan_disable>:
{
   1b244:	b530      	push	{r4, r5, lr}
   1b246:	b085      	sub	sp, #20
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1b248:	2302      	movs	r3, #2
{
   1b24a:	4605      	mov	r5, r0
	mark = ull_disable_mark(scan);
   1b24c:	4608      	mov	r0, r1
{
   1b24e:	460c      	mov	r4, r1
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1b250:	9303      	str	r3, [sp, #12]
	mark = ull_disable_mark(scan);
   1b252:	f7ff f9f1 	bl	1a638 <ull_disable_mark>
	LL_ASSERT(mark == scan);
   1b256:	4284      	cmp	r4, r0
   1b258:	d00c      	beq.n	1b274 <ull_scan_disable+0x30>
   1b25a:	4a2a      	ldr	r2, [pc, #168]	; (1b304 <ull_scan_disable+0xc0>)
   1b25c:	492a      	ldr	r1, [pc, #168]	; (1b308 <ull_scan_disable+0xc4>)
   1b25e:	482b      	ldr	r0, [pc, #172]	; (1b30c <ull_scan_disable+0xc8>)
   1b260:	f240 1313 	movw	r3, #275	; 0x113
   1b264:	f008 fe3d 	bl	23ee2 <printk>
   1b268:	4040      	eors	r0, r0
   1b26a:	f380 8811 	msr	BASEPRI, r0
   1b26e:	f04f 0003 	mov.w	r0, #3
   1b272:	df02      	svc	2
			  TICKER_ID_SCAN_BASE + handle,
   1b274:	1d2a      	adds	r2, r5, #4
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1b276:	ad03      	add	r5, sp, #12
   1b278:	2103      	movs	r1, #3
   1b27a:	4b25      	ldr	r3, [pc, #148]	; (1b310 <ull_scan_disable+0xcc>)
   1b27c:	9500      	str	r5, [sp, #0]
   1b27e:	b2d2      	uxtb	r2, r2
   1b280:	2000      	movs	r0, #0
   1b282:	f7fd fd7d 	bl	18d80 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   1b286:	4629      	mov	r1, r5
   1b288:	f7ff f9ca 	bl	1a620 <ull_ticker_status_take>
	if (ret) {
   1b28c:	b1a0      	cbz	r0, 1b2b8 <ull_scan_disable+0x74>
		mark = ull_disable_unmark(scan);
   1b28e:	4620      	mov	r0, r4
   1b290:	f7ff f9da 	bl	1a648 <ull_disable_unmark>
		LL_ASSERT(mark == scan);
   1b294:	4284      	cmp	r4, r0
   1b296:	d00c      	beq.n	1b2b2 <ull_scan_disable+0x6e>
   1b298:	4a1a      	ldr	r2, [pc, #104]	; (1b304 <ull_scan_disable+0xc0>)
   1b29a:	491b      	ldr	r1, [pc, #108]	; (1b308 <ull_scan_disable+0xc4>)
   1b29c:	481b      	ldr	r0, [pc, #108]	; (1b30c <ull_scan_disable+0xc8>)
   1b29e:	f44f 738e 	mov.w	r3, #284	; 0x11c
   1b2a2:	f008 fe1e 	bl	23ee2 <printk>
   1b2a6:	4040      	eors	r0, r0
   1b2a8:	f380 8811 	msr	BASEPRI, r0
   1b2ac:	f04f 0003 	mov.w	r0, #3
   1b2b0:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
   1b2b2:	200c      	movs	r0, #12
}
   1b2b4:	b005      	add	sp, #20
   1b2b6:	bd30      	pop	{r4, r5, pc}
	ret = ull_disable(&scan->lll);
   1b2b8:	f104 001c 	add.w	r0, r4, #28
   1b2bc:	f7ff f9f4 	bl	1a6a8 <ull_disable>
	LL_ASSERT(!ret);
   1b2c0:	b160      	cbz	r0, 1b2dc <ull_scan_disable+0x98>
   1b2c2:	4a10      	ldr	r2, [pc, #64]	; (1b304 <ull_scan_disable+0xc0>)
   1b2c4:	4913      	ldr	r1, [pc, #76]	; (1b314 <ull_scan_disable+0xd0>)
   1b2c6:	4811      	ldr	r0, [pc, #68]	; (1b30c <ull_scan_disable+0xc8>)
   1b2c8:	f44f 7391 	mov.w	r3, #290	; 0x122
   1b2cc:	f008 fe09 	bl	23ee2 <printk>
   1b2d0:	4040      	eors	r0, r0
   1b2d2:	f380 8811 	msr	BASEPRI, r0
   1b2d6:	f04f 0003 	mov.w	r0, #3
   1b2da:	df02      	svc	2
	mark = ull_disable_unmark(scan);
   1b2dc:	4620      	mov	r0, r4
   1b2de:	f7ff f9b3 	bl	1a648 <ull_disable_unmark>
	LL_ASSERT(mark == scan);
   1b2e2:	4284      	cmp	r4, r0
   1b2e4:	d00c      	beq.n	1b300 <ull_scan_disable+0xbc>
   1b2e6:	4a07      	ldr	r2, [pc, #28]	; (1b304 <ull_scan_disable+0xc0>)
   1b2e8:	4907      	ldr	r1, [pc, #28]	; (1b308 <ull_scan_disable+0xc4>)
   1b2ea:	4808      	ldr	r0, [pc, #32]	; (1b30c <ull_scan_disable+0xc8>)
   1b2ec:	f240 1325 	movw	r3, #293	; 0x125
   1b2f0:	f008 fdf7 	bl	23ee2 <printk>
   1b2f4:	4040      	eors	r0, r0
   1b2f6:	f380 8811 	msr	BASEPRI, r0
   1b2fa:	f04f 0003 	mov.w	r0, #3
   1b2fe:	df02      	svc	2
	return 0;
   1b300:	2000      	movs	r0, #0
   1b302:	e7d7      	b.n	1b2b4 <ull_scan_disable+0x70>
   1b304:	000305ac 	.word	0x000305ac
   1b308:	000305ec 	.word	0x000305ec
   1b30c:	0002a5e8 	.word	0x0002a5e8
   1b310:	0001a615 	.word	0x0001a615
   1b314:	00030473 	.word	0x00030473

0001b318 <ull_scan_lll_handle_get>:
	return ((u8_t *)scan - (u8_t *)ll_scan) / sizeof(*scan);
   1b318:	6800      	ldr	r0, [r0, #0]
   1b31a:	4b03      	ldr	r3, [pc, #12]	; (1b328 <ull_scan_lll_handle_get+0x10>)
   1b31c:	1ac0      	subs	r0, r0, r3
   1b31e:	233c      	movs	r3, #60	; 0x3c
   1b320:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1b324:	b280      	uxth	r0, r0
   1b326:	4770      	bx	lr
   1b328:	2000174c 	.word	0x2000174c

0001b32c <ull_scan_is_enabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
   1b32c:	b938      	cbnz	r0, 1b33e <ull_scan_is_enabled_get+0x12>
	if (!scan || !scan->is_enabled) {
   1b32e:	4805      	ldr	r0, [pc, #20]	; (1b344 <ull_scan_is_enabled_get+0x18>)
   1b330:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
	return &ll_scan[handle];
   1b334:	f013 0f01 	tst.w	r3, #1
   1b338:	bf08      	it	eq
   1b33a:	2000      	moveq	r0, #0
   1b33c:	4770      	bx	lr
		return NULL;
   1b33e:	2000      	movs	r0, #0
}
   1b340:	4770      	bx	lr
   1b342:	bf00      	nop
   1b344:	2000174c 	.word	0x2000174c

0001b348 <ull_scan_is_disabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
   1b348:	b938      	cbnz	r0, 1b35a <ull_scan_is_disabled_get+0x12>
	if (!scan || scan->is_enabled) {
   1b34a:	4805      	ldr	r0, [pc, #20]	; (1b360 <ull_scan_is_disabled_get+0x18>)
   1b34c:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
	return &ll_scan[handle];
   1b350:	f013 0f01 	tst.w	r3, #1
   1b354:	bf18      	it	ne
   1b356:	2000      	movne	r0, #0
   1b358:	4770      	bx	lr
		return NULL;
   1b35a:	2000      	movs	r0, #0
}
   1b35c:	4770      	bx	lr
   1b35e:	bf00      	nop
   1b360:	2000174c 	.word	0x2000174c

0001b364 <pdu_len_cmp>:
		break;
	}
}

static inline bool pdu_len_cmp(u8_t opcode, u8_t len)
{
   1b364:	b5f0      	push	{r4, r5, r6, r7, lr}
	const u8_t ctrl_len_lut[] = {
   1b366:	4b0d      	ldr	r3, [pc, #52]	; (1b39c <pdu_len_cmp+0x38>)
{
   1b368:	b089      	sub	sp, #36	; 0x24
   1b36a:	4602      	mov	r2, r0
   1b36c:	460e      	mov	r6, r1
	const u8_t ctrl_len_lut[] = {
   1b36e:	ac01      	add	r4, sp, #4
   1b370:	f103 0718 	add.w	r7, r3, #24
   1b374:	6818      	ldr	r0, [r3, #0]
   1b376:	6859      	ldr	r1, [r3, #4]
   1b378:	4625      	mov	r5, r4
   1b37a:	c503      	stmia	r5!, {r0, r1}
   1b37c:	3308      	adds	r3, #8
   1b37e:	42bb      	cmp	r3, r7
   1b380:	462c      	mov	r4, r5
   1b382:	d1f7      	bne.n	1b374 <pdu_len_cmp+0x10>
   1b384:	881b      	ldrh	r3, [r3, #0]
   1b386:	802b      	strh	r3, [r5, #0]
		 sizeof(struct pdu_data_llctrl_phy_upd_ind)),
		(offsetof(struct pdu_data_llctrl, min_used_chans_ind) +
		 sizeof(struct pdu_data_llctrl_min_used_chans_ind)),
	};

	return ctrl_len_lut[opcode] == len;
   1b388:	ab08      	add	r3, sp, #32
   1b38a:	441a      	add	r2, r3
   1b38c:	f812 0c1c 	ldrb.w	r0, [r2, #-28]
}
   1b390:	1b83      	subs	r3, r0, r6
   1b392:	4258      	negs	r0, r3
   1b394:	4158      	adcs	r0, r3
   1b396:	b009      	add	sp, #36	; 0x24
   1b398:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1b39a:	bf00      	nop
   1b39c:	0003060a 	.word	0x0003060a

0001b3a0 <ticker_update_latency_cancel_op_cb>:
{
   1b3a0:	b510      	push	{r4, lr}
   1b3a2:	460c      	mov	r4, r1
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
   1b3a4:	b160      	cbz	r0, 1b3c0 <ticker_update_latency_cancel_op_cb+0x20>
   1b3a6:	4a0a      	ldr	r2, [pc, #40]	; (1b3d0 <ticker_update_latency_cancel_op_cb+0x30>)
   1b3a8:	490a      	ldr	r1, [pc, #40]	; (1b3d4 <ticker_update_latency_cancel_op_cb+0x34>)
   1b3aa:	480b      	ldr	r0, [pc, #44]	; (1b3d8 <ticker_update_latency_cancel_op_cb+0x38>)
   1b3ac:	f240 635b 	movw	r3, #1627	; 0x65b
   1b3b0:	f008 fd97 	bl	23ee2 <printk>
   1b3b4:	4040      	eors	r0, r0
   1b3b6:	f380 8811 	msr	BASEPRI, r0
   1b3ba:	f04f 0003 	mov.w	r0, #3
   1b3be:	df02      	svc	2
	conn->slave.latency_cancel = 0U;
   1b3c0:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
   1b3c4:	f36f 0341 	bfc	r3, #1, #1
   1b3c8:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
   1b3cc:	bd10      	pop	{r4, pc}
   1b3ce:	bf00      	nop
   1b3d0:	00030625 	.word	0x00030625
   1b3d4:	00030665 	.word	0x00030665
   1b3d8:	0002a5e8 	.word	0x0002a5e8

0001b3dc <init_reset>:
{
   1b3dc:	b508      	push	{r3, lr}
	mem_init(conn_pool, sizeof(struct ll_conn),
   1b3de:	480d      	ldr	r0, [pc, #52]	; (1b414 <init_reset+0x38>)
   1b3e0:	4b0d      	ldr	r3, [pc, #52]	; (1b418 <init_reset+0x3c>)
   1b3e2:	2201      	movs	r2, #1
   1b3e4:	f44f 7196 	mov.w	r1, #300	; 0x12c
   1b3e8:	f00c fe28 	bl	2803c <mem_init>
	mem_init(mem_conn_tx.pool, CONN_TX_BUF_SIZE, CONFIG_BT_CTLR_TX_BUFFERS,
   1b3ec:	4b0b      	ldr	r3, [pc, #44]	; (1b41c <init_reset+0x40>)
   1b3ee:	2203      	movs	r2, #3
   1b3f0:	1d18      	adds	r0, r3, #4
   1b3f2:	2124      	movs	r1, #36	; 0x24
   1b3f4:	f00c fe22 	bl	2803c <mem_init>
	mem_init(mem_conn_tx_ctrl.pool, CONN_TX_CTRL_BUF_SIZE,
   1b3f8:	4b09      	ldr	r3, [pc, #36]	; (1b420 <init_reset+0x44>)
   1b3fa:	2204      	movs	r2, #4
   1b3fc:	1898      	adds	r0, r3, r2
   1b3fe:	2120      	movs	r1, #32
   1b400:	f00c fe1c 	bl	2803c <mem_init>
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
   1b404:	4b07      	ldr	r3, [pc, #28]	; (1b424 <init_reset+0x48>)
   1b406:	2207      	movs	r2, #7
   1b408:	1d18      	adds	r0, r3, #4
   1b40a:	2108      	movs	r1, #8
   1b40c:	f00c fe16 	bl	2803c <mem_init>
}
   1b410:	2000      	movs	r0, #0
   1b412:	bd08      	pop	{r3, pc}
   1b414:	2000179c 	.word	0x2000179c
   1b418:	20001798 	.word	0x20001798
   1b41c:	200018d4 	.word	0x200018d4
   1b420:	20001944 	.word	0x20001944
   1b424:	200019c8 	.word	0x200019c8

0001b428 <ticker_start_conn_op_cb>:
{
   1b428:	b510      	push	{r4, lr}
   1b42a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1b42c:	b160      	cbz	r0, 1b448 <ticker_start_conn_op_cb+0x20>
   1b42e:	4a10      	ldr	r2, [pc, #64]	; (1b470 <ticker_start_conn_op_cb+0x48>)
   1b430:	4910      	ldr	r1, [pc, #64]	; (1b474 <ticker_start_conn_op_cb+0x4c>)
   1b432:	4811      	ldr	r0, [pc, #68]	; (1b478 <ticker_start_conn_op_cb+0x50>)
   1b434:	f240 6377 	movw	r3, #1655	; 0x677
   1b438:	f008 fd53 	bl	23ee2 <printk>
   1b43c:	4040      	eors	r0, r0
   1b43e:	f380 8811 	msr	BASEPRI, r0
   1b442:	f04f 0003 	mov.w	r0, #3
   1b446:	df02      	svc	2
	void *p = ull_update_unmark(param);
   1b448:	4620      	mov	r0, r4
   1b44a:	f7ff f919 	bl	1a680 <ull_update_unmark>
	LL_ASSERT(p == param);
   1b44e:	4284      	cmp	r4, r0
   1b450:	d00c      	beq.n	1b46c <ticker_start_conn_op_cb+0x44>
   1b452:	4a07      	ldr	r2, [pc, #28]	; (1b470 <ticker_start_conn_op_cb+0x48>)
   1b454:	4909      	ldr	r1, [pc, #36]	; (1b47c <ticker_start_conn_op_cb+0x54>)
   1b456:	4808      	ldr	r0, [pc, #32]	; (1b478 <ticker_start_conn_op_cb+0x50>)
   1b458:	f240 637b 	movw	r3, #1659	; 0x67b
   1b45c:	f008 fd41 	bl	23ee2 <printk>
   1b460:	4040      	eors	r0, r0
   1b462:	f380 8811 	msr	BASEPRI, r0
   1b466:	f04f 0003 	mov.w	r0, #3
   1b46a:	df02      	svc	2
}
   1b46c:	bd10      	pop	{r4, pc}
   1b46e:	bf00      	nop
   1b470:	00030625 	.word	0x00030625
   1b474:	0003066c 	.word	0x0003066c
   1b478:	0002a5e8 	.word	0x0002a5e8
   1b47c:	00030678 	.word	0x00030678

0001b480 <ticker_stop_conn_op_cb>:
{
   1b480:	b510      	push	{r4, lr}
   1b482:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1b484:	b160      	cbz	r0, 1b4a0 <ticker_stop_conn_op_cb+0x20>
   1b486:	4a10      	ldr	r2, [pc, #64]	; (1b4c8 <ticker_stop_conn_op_cb+0x48>)
   1b488:	4910      	ldr	r1, [pc, #64]	; (1b4cc <ticker_stop_conn_op_cb+0x4c>)
   1b48a:	4811      	ldr	r0, [pc, #68]	; (1b4d0 <ticker_stop_conn_op_cb+0x50>)
   1b48c:	f240 636e 	movw	r3, #1646	; 0x66e
   1b490:	f008 fd27 	bl	23ee2 <printk>
   1b494:	4040      	eors	r0, r0
   1b496:	f380 8811 	msr	BASEPRI, r0
   1b49a:	f04f 0003 	mov.w	r0, #3
   1b49e:	df02      	svc	2
	void *p = ull_update_mark(param);
   1b4a0:	4620      	mov	r0, r4
   1b4a2:	f7ff f8e5 	bl	1a670 <ull_update_mark>
	LL_ASSERT(p == param);
   1b4a6:	4284      	cmp	r4, r0
   1b4a8:	d00c      	beq.n	1b4c4 <ticker_stop_conn_op_cb+0x44>
   1b4aa:	4a07      	ldr	r2, [pc, #28]	; (1b4c8 <ticker_stop_conn_op_cb+0x48>)
   1b4ac:	4909      	ldr	r1, [pc, #36]	; (1b4d4 <ticker_stop_conn_op_cb+0x54>)
   1b4ae:	4808      	ldr	r0, [pc, #32]	; (1b4d0 <ticker_stop_conn_op_cb+0x50>)
   1b4b0:	f240 6372 	movw	r3, #1650	; 0x672
   1b4b4:	f008 fd15 	bl	23ee2 <printk>
   1b4b8:	4040      	eors	r0, r0
   1b4ba:	f380 8811 	msr	BASEPRI, r0
   1b4be:	f04f 0003 	mov.w	r0, #3
   1b4c2:	df02      	svc	2
}
   1b4c4:	bd10      	pop	{r4, pc}
   1b4c6:	bf00      	nop
   1b4c8:	00030625 	.word	0x00030625
   1b4cc:	0003066c 	.word	0x0003066c
   1b4d0:	0002a5e8 	.word	0x0002a5e8
   1b4d4:	00030678 	.word	0x00030678

0001b4d8 <ticker_update_conn_op_cb>:
{
   1b4d8:	b510      	push	{r4, lr}
   1b4da:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   1b4dc:	b1a0      	cbz	r0, 1b508 <ticker_update_conn_op_cb+0x30>
   1b4de:	f7ff f8dd 	bl	1a69c <ull_update_mark_get>
   1b4e2:	4284      	cmp	r4, r0
   1b4e4:	d010      	beq.n	1b508 <ticker_update_conn_op_cb+0x30>
   1b4e6:	f7ff f8bd 	bl	1a664 <ull_disable_mark_get>
   1b4ea:	4284      	cmp	r4, r0
   1b4ec:	d00c      	beq.n	1b508 <ticker_update_conn_op_cb+0x30>
   1b4ee:	4a07      	ldr	r2, [pc, #28]	; (1b50c <ticker_update_conn_op_cb+0x34>)
   1b4f0:	4907      	ldr	r1, [pc, #28]	; (1b510 <ticker_update_conn_op_cb+0x38>)
   1b4f2:	4808      	ldr	r0, [pc, #32]	; (1b514 <ticker_update_conn_op_cb+0x3c>)
   1b4f4:	f240 6367 	movw	r3, #1639	; 0x667
   1b4f8:	f008 fcf3 	bl	23ee2 <printk>
   1b4fc:	4040      	eors	r0, r0
   1b4fe:	f380 8811 	msr	BASEPRI, r0
   1b502:	f04f 0003 	mov.w	r0, #3
   1b506:	df02      	svc	2
}
   1b508:	bd10      	pop	{r4, pc}
   1b50a:	bf00      	nop
   1b50c:	00030625 	.word	0x00030625
   1b510:	00030683 	.word	0x00030683
   1b514:	0002a5e8 	.word	0x0002a5e8

0001b518 <ticker_op_stop_cb>:
{
   1b518:	b510      	push	{r4, lr}
   1b51a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1b51c:	b160      	cbz	r0, 1b538 <ticker_op_stop_cb+0x20>
   1b51e:	4a11      	ldr	r2, [pc, #68]	; (1b564 <ticker_op_stop_cb+0x4c>)
   1b520:	4911      	ldr	r1, [pc, #68]	; (1b568 <ticker_op_stop_cb+0x50>)
   1b522:	4812      	ldr	r0, [pc, #72]	; (1b56c <ticker_op_stop_cb+0x54>)
   1b524:	f240 6384 	movw	r3, #1668	; 0x684
   1b528:	f008 fcdb 	bl	23ee2 <printk>
   1b52c:	4040      	eors	r0, r0
   1b52e:	f380 8811 	msr	BASEPRI, r0
   1b532:	f04f 0003 	mov.w	r0, #3
   1b536:	df02      	svc	2
	mfy.param = param;
   1b538:	4b0d      	ldr	r3, [pc, #52]	; (1b570 <ticker_op_stop_cb+0x58>)
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
   1b53a:	2200      	movs	r2, #0
   1b53c:	4611      	mov	r1, r2
   1b53e:	2002      	movs	r0, #2
	mfy.param = param;
   1b540:	609c      	str	r4, [r3, #8]
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
   1b542:	f7fc fdf3 	bl	1812c <mayfly_enqueue>
	LL_ASSERT(!retval);
   1b546:	b160      	cbz	r0, 1b562 <ticker_op_stop_cb+0x4a>
   1b548:	4a06      	ldr	r2, [pc, #24]	; (1b564 <ticker_op_stop_cb+0x4c>)
   1b54a:	490a      	ldr	r1, [pc, #40]	; (1b574 <ticker_op_stop_cb+0x5c>)
   1b54c:	4807      	ldr	r0, [pc, #28]	; (1b56c <ticker_op_stop_cb+0x54>)
   1b54e:	f240 638b 	movw	r3, #1675	; 0x68b
   1b552:	f008 fcc6 	bl	23ee2 <printk>
   1b556:	4040      	eors	r0, r0
   1b558:	f380 8811 	msr	BASEPRI, r0
   1b55c:	f04f 0003 	mov.w	r0, #3
   1b560:	df02      	svc	2
}
   1b562:	bd10      	pop	{r4, pc}
   1b564:	00030625 	.word	0x00030625
   1b568:	0003066c 	.word	0x0003066c
   1b56c:	0002a5e8 	.word	0x0002a5e8
   1b570:	20007334 	.word	0x20007334
   1b574:	000303e5 	.word	0x000303e5

0001b578 <reject_ext_ind_send.isra.0>:
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   1b578:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b57c:	4605      	mov	r5, r0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   1b57e:	480f      	ldr	r0, [pc, #60]	; (1b5bc <reject_ext_ind_send.isra.0+0x44>)
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   1b580:	460c      	mov	r4, r1
   1b582:	4617      	mov	r7, r2
   1b584:	461e      	mov	r6, r3
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   1b586:	f00c fd7d 	bl	28084 <mem_acquire>
	if (!tx) {
   1b58a:	4601      	mov	r1, r0
   1b58c:	b198      	cbz	r0, 1b5b6 <reject_ext_ind_send.isra.0+0x3e>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   1b58e:	7903      	ldrb	r3, [r0, #4]
	pdu_ctrl_tx->llctrl.reject_ext_ind.reject_opcode = reject_opcode;
   1b590:	7207      	strb	r7, [r0, #8]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   1b592:	f043 0303 	orr.w	r3, r3, #3
   1b596:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   1b598:	f04f 0803 	mov.w	r8, #3
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   1b59c:	2311      	movs	r3, #17
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   1b59e:	f880 8005 	strb.w	r8, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   1b5a2:	71c3      	strb	r3, [r0, #7]
	pdu_ctrl_tx->llctrl.reject_ext_ind.error_code = error_code;
   1b5a4:	7246      	strb	r6, [r0, #9]
	ctrl_tx_enqueue(conn, tx);
   1b5a6:	4628      	mov	r0, r5
   1b5a8:	f00c ffe9 	bl	2857e <ctrl_tx_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1b5ac:	f884 8000 	strb.w	r8, [r4]
	return 0;
   1b5b0:	2000      	movs	r0, #0
}
   1b5b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOBUFS;
   1b5b6:	f06f 0036 	mvn.w	r0, #54	; 0x36
   1b5ba:	e7fa      	b.n	1b5b2 <reject_ext_ind_send.isra.0+0x3a>
   1b5bc:	20001944 	.word	0x20001944

0001b5c0 <ll_conn_acquire>:
	return mem_acquire(&conn_free);
   1b5c0:	4801      	ldr	r0, [pc, #4]	; (1b5c8 <ll_conn_acquire+0x8>)
   1b5c2:	f00c bd5f 	b.w	28084 <mem_acquire>
   1b5c6:	bf00      	nop
   1b5c8:	20001798 	.word	0x20001798

0001b5cc <ll_conn_release>:
	mem_release(conn, &conn_free);
   1b5cc:	4901      	ldr	r1, [pc, #4]	; (1b5d4 <ll_conn_release+0x8>)
   1b5ce:	f00c bd72 	b.w	280b6 <mem_release>
   1b5d2:	bf00      	nop
   1b5d4:	20001798 	.word	0x20001798

0001b5d8 <ll_conn_handle_get>:
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
   1b5d8:	4902      	ldr	r1, [pc, #8]	; (1b5e4 <ll_conn_handle_get+0xc>)
   1b5da:	f44f 7296 	mov.w	r2, #300	; 0x12c
   1b5de:	f00c bd82 	b.w	280e6 <mem_index_get>
   1b5e2:	bf00      	nop
   1b5e4:	2000179c 	.word	0x2000179c

0001b5e8 <tx_lll_flush>:
{
   1b5e8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct ll_conn *conn = (void *)HDR_LLL2EVT(param);
   1b5ec:	6804      	ldr	r4, [r0, #0]
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   1b5ee:	4e30      	ldr	r6, [pc, #192]	; (1b6b0 <tx_lll_flush+0xc8>)
{
   1b5f0:	4605      	mov	r5, r0
	u16_t handle = ll_conn_handle_get(conn);
   1b5f2:	4620      	mov	r0, r4
   1b5f4:	f7ff fff0 	bl	1b5d8 <ll_conn_handle_get>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   1b5f8:	f105 0840 	add.w	r8, r5, #64	; 0x40
	lll_conn_flush(handle, lll);
   1b5fc:	4629      	mov	r1, r5
   1b5fe:	f00d fa77 	bl	28af0 <lll_conn_flush>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   1b602:	6c68      	ldr	r0, [r5, #68]	; 0x44
   1b604:	aa01      	add	r2, sp, #4
   1b606:	4641      	mov	r1, r8
   1b608:	f00c fda9 	bl	2815e <memq_dequeue>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1b60c:	1d37      	adds	r7, r6, #4
	while (link) {
   1b60e:	b9f0      	cbnz	r0, 1b64e <tx_lll_flush+0x66>
	LL_ASSERT(rx->hdr.link);
   1b610:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
	rx = (void *)&conn->llcp_terminate.node_rx;
   1b614:	f104 05c8 	add.w	r5, r4, #200	; 0xc8
	LL_ASSERT(rx->hdr.link);
   1b618:	b963      	cbnz	r3, 1b634 <tx_lll_flush+0x4c>
   1b61a:	4a26      	ldr	r2, [pc, #152]	; (1b6b4 <tx_lll_flush+0xcc>)
   1b61c:	4926      	ldr	r1, [pc, #152]	; (1b6b8 <tx_lll_flush+0xd0>)
   1b61e:	4827      	ldr	r0, [pc, #156]	; (1b6bc <tx_lll_flush+0xd4>)
   1b620:	f240 7312 	movw	r3, #1810	; 0x712
   1b624:	f008 fc5d 	bl	23ee2 <printk>
   1b628:	4040      	eors	r0, r0
   1b62a:	f380 8811 	msr	BASEPRI, r0
   1b62e:	f04f 0003 	mov.w	r0, #3
   1b632:	df02      	svc	2
	rx->hdr.link = NULL;
   1b634:	2300      	movs	r3, #0
	link = rx->hdr.link;
   1b636:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
	rx->hdr.link = NULL;
   1b63a:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
	ull_rx_put(link, rx);
   1b63e:	4629      	mov	r1, r5
   1b640:	f7ff f89c 	bl	1a77c <ull_rx_put>
	ull_rx_sched();
   1b644:	f7ff f8aa 	bl	1a79c <ull_rx_sched>
}
   1b648:	b002      	add	sp, #8
   1b64a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   1b64e:	78f3      	ldrb	r3, [r6, #3]
	if (last == count) {
   1b650:	f896 e001 	ldrb.w	lr, [r6, #1]
   1b654:	f896 c002 	ldrb.w	ip, [r6, #2]
   1b658:	7832      	ldrb	r2, [r6, #0]
	last = last + 1;
   1b65a:	1c59      	adds	r1, r3, #1
   1b65c:	b2c9      	uxtb	r1, r1
		last = 0U;
   1b65e:	458e      	cmp	lr, r1
   1b660:	bf08      	it	eq
   1b662:	2100      	moveq	r1, #0
	if (last == first) {
   1b664:	458c      	cmp	ip, r1
   1b666:	d003      	beq.n	1b670 <tx_lll_flush+0x88>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1b668:	fb13 f302 	smulbb	r3, r3, r2
		LL_ASSERT(lll_tx);
   1b66c:	18fa      	adds	r2, r7, r3
   1b66e:	d10f      	bne.n	1b690 <tx_lll_flush+0xa8>
   1b670:	4a10      	ldr	r2, [pc, #64]	; (1b6b4 <tx_lll_flush+0xcc>)
   1b672:	4913      	ldr	r1, [pc, #76]	; (1b6c0 <tx_lll_flush+0xd8>)
   1b674:	4811      	ldr	r0, [pc, #68]	; (1b6bc <tx_lll_flush+0xd4>)
   1b676:	f240 63fe 	movw	r3, #1790	; 0x6fe
   1b67a:	f008 fc32 	bl	23ee2 <printk>
   1b67e:	4040      	eors	r0, r0
   1b680:	f380 8811 	msr	BASEPRI, r0
   1b684:	f04f 0003 	mov.w	r0, #3
   1b688:	df02      	svc	2
		lll_tx->handle = 0xFFFF;
   1b68a:	2300      	movs	r3, #0
   1b68c:	801b      	strh	r3, [r3, #0]
   1b68e:	deff      	udf	#255	; 0xff
   1b690:	f64f 7cff 	movw	ip, #65535	; 0xffff
   1b694:	f827 c003 	strh.w	ip, [r7, r3]
		lll_tx->node = tx;
   1b698:	9b01      	ldr	r3, [sp, #4]
   1b69a:	6053      	str	r3, [r2, #4]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
   1b69c:	681a      	ldr	r2, [r3, #0]
   1b69e:	6002      	str	r2, [r0, #0]
		tx->next = link;
   1b6a0:	6018      	str	r0, [r3, #0]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   1b6a2:	aa01      	add	r2, sp, #4
	*last = idx; /* Commit: Update write index */
   1b6a4:	70f1      	strb	r1, [r6, #3]
   1b6a6:	6c68      	ldr	r0, [r5, #68]	; 0x44
   1b6a8:	4641      	mov	r1, r8
   1b6aa:	f00c fd58 	bl	2815e <memq_dequeue>
   1b6ae:	e7ae      	b.n	1b60e <tx_lll_flush+0x26>
   1b6b0:	200072cc 	.word	0x200072cc
   1b6b4:	00030625 	.word	0x00030625
   1b6b8:	00030773 	.word	0x00030773
   1b6bc:	0002a5e8 	.word	0x0002a5e8
   1b6c0:	000306d4 	.word	0x000306d4

0001b6c4 <ll_conn_get>:
{
   1b6c4:	4602      	mov	r2, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   1b6c6:	f44f 7196 	mov.w	r1, #300	; 0x12c
   1b6ca:	4801      	ldr	r0, [pc, #4]	; (1b6d0 <ll_conn_get+0xc>)
   1b6cc:	f00c bd08 	b.w	280e0 <mem_get>
   1b6d0:	2000179c 	.word	0x2000179c

0001b6d4 <ll_tx_mem_acquire>:
	return mem_acquire(&mem_conn_tx.free);
   1b6d4:	4801      	ldr	r0, [pc, #4]	; (1b6dc <ll_tx_mem_acquire+0x8>)
   1b6d6:	f00c bcd5 	b.w	28084 <mem_acquire>
   1b6da:	bf00      	nop
   1b6dc:	200018d4 	.word	0x200018d4

0001b6e0 <ll_tx_mem_release>:
	mem_release(tx, &mem_conn_tx.free);
   1b6e0:	4901      	ldr	r1, [pc, #4]	; (1b6e8 <ll_tx_mem_release+0x8>)
   1b6e2:	f00c bce8 	b.w	280b6 <mem_release>
   1b6e6:	bf00      	nop
   1b6e8:	200018d4 	.word	0x200018d4

0001b6ec <ll_tx_mem_enqueue>:
{
   1b6ec:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b6ee:	b089      	sub	sp, #36	; 0x24
   1b6f0:	4605      	mov	r5, r0
   1b6f2:	460e      	mov	r6, r1
	conn = ll_connected_get(handle);
   1b6f4:	f00c ff68 	bl	285c8 <ll_connected_get>
	if (!conn) {
   1b6f8:	2800      	cmp	r0, #0
   1b6fa:	d048      	beq.n	1b78e <ll_tx_mem_enqueue+0xa2>
	idx = MFIFO_ENQUEUE_GET(conn_tx, (void **) &lll_tx);
   1b6fc:	4a27      	ldr	r2, [pc, #156]	; (1b79c <ll_tx_mem_enqueue+0xb0>)
   1b6fe:	78d4      	ldrb	r4, [r2, #3]
	if (last == count) {
   1b700:	f892 c001 	ldrb.w	ip, [r2, #1]
   1b704:	7891      	ldrb	r1, [r2, #2]
   1b706:	7817      	ldrb	r7, [r2, #0]
	last = last + 1;
   1b708:	1c63      	adds	r3, r4, #1
   1b70a:	b2db      	uxtb	r3, r3
		last = 0U;
   1b70c:	459c      	cmp	ip, r3
   1b70e:	bf08      	it	eq
   1b710:	2300      	moveq	r3, #0
	if (last == first) {
   1b712:	4299      	cmp	r1, r3
   1b714:	d03e      	beq.n	1b794 <ll_tx_mem_enqueue+0xa8>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1b716:	1d11      	adds	r1, r2, #4
   1b718:	fb14 f407 	smulbb	r4, r4, r7
	if (!lll_tx) {
   1b71c:	190f      	adds	r7, r1, r4
   1b71e:	d039      	beq.n	1b794 <ll_tx_mem_enqueue+0xa8>
	lll_tx->handle = handle;
   1b720:	530d      	strh	r5, [r1, r4]
	*last = idx; /* Commit: Update write index */
   1b722:	70d3      	strb	r3, [r2, #3]
	if (conn->lll.role && conn->lll.latency_event &&
   1b724:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
	lll_tx->node = tx;
   1b728:	607e      	str	r6, [r7, #4]
	if (conn->lll.role && conn->lll.latency_event &&
   1b72a:	2b00      	cmp	r3, #0
   1b72c:	db02      	blt.n	1b734 <ll_tx_mem_enqueue+0x48>
	return 0;
   1b72e:	2000      	movs	r0, #0
}
   1b730:	b009      	add	sp, #36	; 0x24
   1b732:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (conn->lll.role && conn->lll.latency_event &&
   1b734:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   1b736:	2b00      	cmp	r3, #0
   1b738:	d0f9      	beq.n	1b72e <ll_tx_mem_enqueue+0x42>
	    !conn->slave.latency_cancel) {
   1b73a:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
	if (conn->lll.role && conn->lll.latency_event &&
   1b73e:	f013 0402 	ands.w	r4, r3, #2
   1b742:	d1f4      	bne.n	1b72e <ll_tx_mem_enqueue+0x42>
		conn->slave.latency_cancel = 1U;
   1b744:	f043 0302 	orr.w	r3, r3, #2
   1b748:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   1b74c:	4b14      	ldr	r3, [pc, #80]	; (1b7a0 <ll_tx_mem_enqueue+0xb4>)
   1b74e:	9006      	str	r0, [sp, #24]
   1b750:	e9cd 4304 	strd	r4, r3, [sp, #16]
				      (TICKER_ID_CONN_BASE + handle),
   1b754:	1d6a      	adds	r2, r5, #5
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   1b756:	2301      	movs	r3, #1
   1b758:	e9cd 4302 	strd	r4, r3, [sp, #8]
   1b75c:	e9cd 4400 	strd	r4, r4, [sp]
   1b760:	4623      	mov	r3, r4
   1b762:	b2d2      	uxtb	r2, r2
   1b764:	2103      	movs	r1, #3
   1b766:	4620      	mov	r0, r4
   1b768:	f7fd fac4 	bl	18cf4 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   1b76c:	f030 0302 	bics.w	r3, r0, #2
   1b770:	d0dd      	beq.n	1b72e <ll_tx_mem_enqueue+0x42>
   1b772:	4a0c      	ldr	r2, [pc, #48]	; (1b7a4 <ll_tx_mem_enqueue+0xb8>)
   1b774:	490c      	ldr	r1, [pc, #48]	; (1b7a8 <ll_tx_mem_enqueue+0xbc>)
   1b776:	480d      	ldr	r0, [pc, #52]	; (1b7ac <ll_tx_mem_enqueue+0xc0>)
   1b778:	f44f 7380 	mov.w	r3, #256	; 0x100
   1b77c:	f008 fbb1 	bl	23ee2 <printk>
   1b780:	4040      	eors	r0, r0
   1b782:	f380 8811 	msr	BASEPRI, r0
   1b786:	f04f 0003 	mov.w	r0, #3
   1b78a:	df02      	svc	2
   1b78c:	e7cf      	b.n	1b72e <ll_tx_mem_enqueue+0x42>
		return -EINVAL;
   1b78e:	f06f 0015 	mvn.w	r0, #21
   1b792:	e7cd      	b.n	1b730 <ll_tx_mem_enqueue+0x44>
		return -ENOBUFS;
   1b794:	f06f 0036 	mvn.w	r0, #54	; 0x36
   1b798:	e7ca      	b.n	1b730 <ll_tx_mem_enqueue+0x44>
   1b79a:	bf00      	nop
   1b79c:	20007310 	.word	0x20007310
   1b7a0:	0001b3a1 	.word	0x0001b3a1
   1b7a4:	00030625 	.word	0x00030625
   1b7a8:	000306db 	.word	0x000306db
   1b7ac:	0002a5e8 	.word	0x0002a5e8

0001b7b0 <ull_conn_init>:
{
   1b7b0:	b508      	push	{r3, lr}
   1b7b2:	4805      	ldr	r0, [pc, #20]	; (1b7c8 <ull_conn_init+0x18>)
   1b7b4:	f004 fe08 	bl	203c8 <z_impl_device_get_binding>
	if (!entropy) {
   1b7b8:	b118      	cbz	r0, 1b7c2 <ull_conn_init+0x12>
}
   1b7ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	err = init_reset();
   1b7be:	f7ff be0d 	b.w	1b3dc <init_reset>
}
   1b7c2:	f06f 0012 	mvn.w	r0, #18
   1b7c6:	bd08      	pop	{r3, pc}
   1b7c8:	00030045 	.word	0x00030045

0001b7cc <ull_conn_reset>:
{
   1b7cc:	b530      	push	{r4, r5, lr}
   1b7ce:	b085      	sub	sp, #20
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1b7d0:	2302      	movs	r3, #2
	conn = ll_conn_get(handle);
   1b7d2:	2000      	movs	r0, #0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1b7d4:	9303      	str	r3, [sp, #12]
	conn = ll_conn_get(handle);
   1b7d6:	f7ff ff75 	bl	1b6c4 <ll_conn_get>
   1b7da:	4604      	mov	r4, r0
	mark = ull_disable_mark(conn);
   1b7dc:	f7fe ff2c 	bl	1a638 <ull_disable_mark>
	LL_ASSERT(mark == conn);
   1b7e0:	4284      	cmp	r4, r0
   1b7e2:	d00c      	beq.n	1b7fe <ull_conn_reset+0x32>
   1b7e4:	4a2a      	ldr	r2, [pc, #168]	; (1b890 <ull_conn_reset+0xc4>)
   1b7e6:	492b      	ldr	r1, [pc, #172]	; (1b894 <ull_conn_reset+0xc8>)
   1b7e8:	482b      	ldr	r0, [pc, #172]	; (1b898 <ull_conn_reset+0xcc>)
   1b7ea:	f44f 63d3 	mov.w	r3, #1688	; 0x698
   1b7ee:	f008 fb78 	bl	23ee2 <printk>
   1b7f2:	4040      	eors	r0, r0
   1b7f4:	f380 8811 	msr	BASEPRI, r0
   1b7f8:	f04f 0003 	mov.w	r0, #3
   1b7fc:	df02      	svc	2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1b7fe:	ad03      	add	r5, sp, #12
   1b800:	2103      	movs	r1, #3
   1b802:	4b26      	ldr	r3, [pc, #152]	; (1b89c <ull_conn_reset+0xd0>)
   1b804:	9500      	str	r5, [sp, #0]
   1b806:	2205      	movs	r2, #5
   1b808:	2000      	movs	r0, #0
   1b80a:	f7fd fab9 	bl	18d80 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   1b80e:	4629      	mov	r1, r5
   1b810:	f7fe ff06 	bl	1a620 <ull_ticker_status_take>
	if (!ret) {
   1b814:	b988      	cbnz	r0, 1b83a <ull_conn_reset+0x6e>
		ret = ull_disable(&conn->lll);
   1b816:	f104 001c 	add.w	r0, r4, #28
   1b81a:	f7fe ff45 	bl	1a6a8 <ull_disable>
		LL_ASSERT(!ret);
   1b81e:	b160      	cbz	r0, 1b83a <ull_conn_reset+0x6e>
   1b820:	4a1b      	ldr	r2, [pc, #108]	; (1b890 <ull_conn_reset+0xc4>)
   1b822:	491f      	ldr	r1, [pc, #124]	; (1b8a0 <ull_conn_reset+0xd4>)
   1b824:	481c      	ldr	r0, [pc, #112]	; (1b898 <ull_conn_reset+0xcc>)
   1b826:	f240 63a1 	movw	r3, #1697	; 0x6a1
   1b82a:	f008 fb5a 	bl	23ee2 <printk>
   1b82e:	4040      	eors	r0, r0
   1b830:	f380 8811 	msr	BASEPRI, r0
   1b834:	f04f 0003 	mov.w	r0, #3
   1b838:	df02      	svc	2
	conn->lll.link_tx_free = NULL;
   1b83a:	2300      	movs	r3, #0
   1b83c:	66e3      	str	r3, [r4, #108]	; 0x6c
	mark = ull_disable_unmark(conn);
   1b83e:	4620      	mov	r0, r4
   1b840:	f7fe ff02 	bl	1a648 <ull_disable_unmark>
	LL_ASSERT(mark == conn);
   1b844:	4284      	cmp	r4, r0
   1b846:	d00c      	beq.n	1b862 <ull_conn_reset+0x96>
   1b848:	4a11      	ldr	r2, [pc, #68]	; (1b890 <ull_conn_reset+0xc4>)
   1b84a:	4912      	ldr	r1, [pc, #72]	; (1b894 <ull_conn_reset+0xc8>)
   1b84c:	4812      	ldr	r0, [pc, #72]	; (1b898 <ull_conn_reset+0xcc>)
   1b84e:	f240 63a7 	movw	r3, #1703	; 0x6a7
   1b852:	f008 fb46 	bl	23ee2 <printk>
   1b856:	4040      	eors	r0, r0
   1b858:	f380 8811 	msr	BASEPRI, r0
   1b85c:	f04f 0003 	mov.w	r0, #3
   1b860:	df02      	svc	2
	data_chan_map[0] = 0xFF;
   1b862:	4b10      	ldr	r3, [pc, #64]	; (1b8a4 <ull_conn_reset+0xd8>)
   1b864:	22ff      	movs	r2, #255	; 0xff
   1b866:	701a      	strb	r2, [r3, #0]
	data_chan_map[1] = 0xFF;
   1b868:	705a      	strb	r2, [r3, #1]
	data_chan_map[2] = 0xFF;
   1b86a:	709a      	strb	r2, [r3, #2]
	data_chan_map[3] = 0xFF;
   1b86c:	70da      	strb	r2, [r3, #3]
	data_chan_map[4] = 0x1F;
   1b86e:	221f      	movs	r2, #31
   1b870:	711a      	strb	r2, [r3, #4]
	data_chan_count = 37U;
   1b872:	4b0d      	ldr	r3, [pc, #52]	; (1b8a8 <ull_conn_reset+0xdc>)
   1b874:	2225      	movs	r2, #37	; 0x25
   1b876:	701a      	strb	r2, [r3, #0]
	MFIFO_INIT(conn_tx);
   1b878:	4a0c      	ldr	r2, [pc, #48]	; (1b8ac <ull_conn_reset+0xe0>)
   1b87a:	2300      	movs	r3, #0
   1b87c:	8053      	strh	r3, [r2, #2]
	MFIFO_INIT(conn_ack);
   1b87e:	4a0c      	ldr	r2, [pc, #48]	; (1b8b0 <ull_conn_reset+0xe4>)
   1b880:	8053      	strh	r3, [r2, #2]
	conn_upd_curr = NULL;
   1b882:	4a0c      	ldr	r2, [pc, #48]	; (1b8b4 <ull_conn_reset+0xe8>)
   1b884:	6013      	str	r3, [r2, #0]
	err = init_reset();
   1b886:	f7ff fda9 	bl	1b3dc <init_reset>
}
   1b88a:	b005      	add	sp, #20
   1b88c:	bd30      	pop	{r4, r5, pc}
   1b88e:	bf00      	nop
   1b890:	00030625 	.word	0x00030625
   1b894:	00030708 	.word	0x00030708
   1b898:	0002a5e8 	.word	0x0002a5e8
   1b89c:	0001a615 	.word	0x0001a615
   1b8a0:	00030473 	.word	0x00030473
   1b8a4:	20007495 	.word	0x20007495
   1b8a8:	20007494 	.word	0x20007494
   1b8ac:	20007310 	.word	0x20007310
   1b8b0:	200072cc 	.word	0x200072cc
   1b8b4:	200018c8 	.word	0x200018c8

0001b8b8 <ull_conn_setup>:
	lll = *((struct lll_conn **)((u8_t *)ftr->param +
   1b8b8:	688b      	ldr	r3, [r1, #8]
   1b8ba:	689b      	ldr	r3, [r3, #8]
{
   1b8bc:	b510      	push	{r4, lr}
	switch (lll->role) {
   1b8be:	f893 4021 	ldrb.w	r4, [r3, #33]	; 0x21
   1b8c2:	09e4      	lsrs	r4, r4, #7
{
   1b8c4:	460a      	mov	r2, r1
	switch (lll->role) {
   1b8c6:	d004      	beq.n	1b8d2 <ull_conn_setup+0x1a>
}
   1b8c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ull_slave_setup(link, rx, ftr, lll);
   1b8cc:	3208      	adds	r2, #8
   1b8ce:	f7e5 bd53 	b.w	1378 <ull_slave_setup>
		LL_ASSERT(0);
   1b8d2:	4a07      	ldr	r2, [pc, #28]	; (1b8f0 <ull_conn_setup+0x38>)
   1b8d4:	4907      	ldr	r1, [pc, #28]	; (1b8f4 <ull_conn_setup+0x3c>)
   1b8d6:	4808      	ldr	r0, [pc, #32]	; (1b8f8 <ull_conn_setup+0x40>)
   1b8d8:	f240 23cf 	movw	r3, #719	; 0x2cf
   1b8dc:	f008 fb01 	bl	23ee2 <printk>
   1b8e0:	4040      	eors	r0, r0
   1b8e2:	f380 8811 	msr	BASEPRI, r0
   1b8e6:	f04f 0003 	mov.w	r0, #3
   1b8ea:	df02      	svc	2
}
   1b8ec:	bd10      	pop	{r4, pc}
   1b8ee:	bf00      	nop
   1b8f0:	00030625 	.word	0x00030625
   1b8f4:	0002e3c9 	.word	0x0002e3c9
   1b8f8:	0002a5e8 	.word	0x0002a5e8

0001b8fc <ull_conn_rx>:
	conn = ll_connected_get((*rx)->hdr.handle);
   1b8fc:	680b      	ldr	r3, [r1, #0]
{
   1b8fe:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b902:	4607      	mov	r7, r0
	conn = ll_connected_get((*rx)->hdr.handle);
   1b904:	88d8      	ldrh	r0, [r3, #6]
{
   1b906:	460e      	mov	r6, r1
	conn = ll_connected_get((*rx)->hdr.handle);
   1b908:	f00c fe5e 	bl	285c8 <ll_connected_get>
	if (!conn) {
   1b90c:	6835      	ldr	r5, [r6, #0]
   1b90e:	4604      	mov	r4, r0
   1b910:	b910      	cbnz	r0, 1b918 <ull_conn_rx+0x1c>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1b912:	2303      	movs	r3, #3
   1b914:	712b      	strb	r3, [r5, #4]
	return 0;
   1b916:	e008      	b.n	1b92a <ull_conn_rx+0x2e>
	switch (pdu_rx->ll_id) {
   1b918:	f895 0020 	ldrb.w	r0, [r5, #32]
   1b91c:	f000 0003 	and.w	r0, r0, #3
   1b920:	2803      	cmp	r0, #3
   1b922:	d004      	beq.n	1b92e <ull_conn_rx+0x32>
   1b924:	2800      	cmp	r0, #0
   1b926:	f000 84b3 	beq.w	1c290 <ull_conn_rx+0x994>
   1b92a:	2000      	movs	r0, #0
   1b92c:	e0e6      	b.n	1bafc <ull_conn_rx+0x200>
			  struct pdu_data *pdu_rx, struct ll_conn *conn)
{
	int nack = 0;
	u8_t opcode;

	opcode = pdu_rx->llctrl.opcode;
   1b92e:	f895 8023 	ldrb.w	r8, [r5, #35]	; 0x23

		return 0;
	}
#endif /* CONFIG_BT_CTLR_LE_ENC */

	switch (opcode) {
   1b932:	f1b8 0f11 	cmp.w	r8, #17
   1b936:	f200 8495 	bhi.w	1c264 <ull_conn_rx+0x968>
   1b93a:	e8df f018 	tbh	[pc, r8, lsl #1]
   1b93e:	0012      	.short	0x0012
   1b940:	00be008a 	.word	0x00be008a
   1b944:	04930493 	.word	0x04930493
   1b948:	04930493 	.word	0x04930493
   1b94c:	00cb0407 	.word	0x00cb0407
   1b950:	0493011a 	.word	0x0493011a
   1b954:	014b0493 	.word	0x014b0493
   1b958:	04930493 	.word	0x04930493
   1b95c:	030e01a2 	.word	0x030e01a2
   1b960:	03a0      	.short	0x03a0
	case PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND:
	{
		u8_t err;

		if (!conn->lll.role ||
   1b962:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1b966:	2b00      	cmp	r3, #0
   1b968:	f280 847c 	bge.w	1c264 <ull_conn_rx+0x968>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND,
   1b96c:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1b970:	2000      	movs	r0, #0
   1b972:	f7ff fcf7 	bl	1b364 <pdu_len_cmp>
		if (!conn->lll.role ||
   1b976:	2800      	cmp	r0, #0
   1b978:	f000 8474 	beq.w	1c264 <ull_conn_rx+0x968>
	instant = sys_le16_to_cpu(pdu->llctrl.conn_update_ind.instant);
   1b97c:	f8b5 202d 	ldrh.w	r2, [r5, #45]	; 0x2d
	if (((instant - conn->lll.event_counter) & 0xFFFF) > 0x7FFF) {
   1b980:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1b982:	1ad3      	subs	r3, r2, r3
   1b984:	041b      	lsls	r3, r3, #16
   1b986:	d503      	bpl.n	1b990 <ull_conn_rx+0x94>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1b988:	2303      	movs	r3, #3
   1b98a:	712b      	strb	r3, [r5, #4]
		err = BT_HCI_ERR_INSTANT_PASSED;
   1b98c:	2328      	movs	r3, #40	; 0x28
   1b98e:	e00b      	b.n	1b9a8 <ull_conn_rx+0xac>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   1b990:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
   1b994:	f894 108d 	ldrb.w	r1, [r4, #141]	; 0x8d
   1b998:	1a5b      	subs	r3, r3, r1
   1b99a:	f003 0303 	and.w	r3, r3, #3
   1b99e:	2b02      	cmp	r3, #2
   1b9a0:	d105      	bne.n	1b9ae <ull_conn_rx+0xb2>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1b9a2:	2303      	movs	r3, #3
   1b9a4:	712b      	strb	r3, [r5, #4]
		err = BT_HCI_ERR_DIFF_TRANS_COLLISION;
   1b9a6:	232a      	movs	r3, #42	; 0x2a
			goto ull_conn_rx_unknown_rsp_send;
		}

		err = chan_map_upd_recv(conn, *rx, pdu_rx);
		if (err) {
			conn->llcp_terminate.reason_peer = err;
   1b9a8:	f884 30c7 	strb.w	r3, [r4, #199]	; 0xc7
   1b9ac:	e7bd      	b.n	1b92a <ull_conn_rx+0x2e>
	if (!conn_upd_curr) {
   1b9ae:	4bd0      	ldr	r3, [pc, #832]	; (1bcf0 <ull_conn_rx+0x3f4>)
   1b9b0:	6819      	ldr	r1, [r3, #0]
   1b9b2:	b901      	cbnz	r1, 1b9b6 <ull_conn_rx+0xba>
		conn_upd_curr = conn;
   1b9b4:	601c      	str	r4, [r3, #0]
	conn->llcp_cu.win_size = pdu->llctrl.conn_update_ind.win_size;
   1b9b6:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   1b9ba:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) * 1250;
   1b9be:	f8b5 1025 	ldrh.w	r1, [r5, #37]	; 0x25
   1b9c2:	f240 43e2 	movw	r3, #1250	; 0x4e2
   1b9c6:	434b      	muls	r3, r1
	conn->llcp_cu.win_offset_us =
   1b9c8:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.interval);
   1b9cc:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
   1b9d0:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   1b9d4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.interval =
   1b9d8:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.latency);
   1b9dc:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
   1b9e0:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   1b9e4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.latency =
   1b9e8:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   1b9ec:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
   1b9f0:	f895 102c 	ldrb.w	r1, [r5, #44]	; 0x2c
	conn->llcp.conn_upd.instant = instant;
   1b9f4:	f8a4 2090 	strh.w	r2, [r4, #144]	; 0x90
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   1b9f8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.timeout =
   1b9fc:	f8a4 30a8 	strh.w	r3, [r4, #168]	; 0xa8
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   1ba00:	f894 30a2 	ldrb.w	r3, [r4, #162]	; 0xa2
   1ba04:	f023 0307 	bic.w	r3, r3, #7
   1ba08:	f043 0304 	orr.w	r3, r3, #4
   1ba0c:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
	conn->llcp_cu.ack--;
   1ba10:	f894 30a1 	ldrb.w	r3, [r4, #161]	; 0xa1
   1ba14:	3b01      	subs	r3, #1
   1ba16:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
	link->mem = conn->llcp_rx;
   1ba1a:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
   1ba1e:	607b      	str	r3, [r7, #4]
	(*rx)->hdr.link = link;
   1ba20:	6833      	ldr	r3, [r6, #0]
   1ba22:	601f      	str	r7, [r3, #0]
	conn->llcp_rx = *rx;
   1ba24:	6833      	ldr	r3, [r6, #0]
   1ba26:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	*rx = NULL;
   1ba2a:	2300      	movs	r3, #0
   1ba2c:	6033      	str	r3, [r6, #0]
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   1ba2e:	f894 20ec 	ldrb.w	r2, [r4, #236]	; 0xec
   1ba32:	f894 30ed 	ldrb.w	r3, [r4, #237]	; 0xed
   1ba36:	4293      	cmp	r3, r2
   1ba38:	d007      	beq.n	1ba4a <ull_conn_rx+0x14e>
	    (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT)) {
   1ba3a:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   1ba3e:	f003 0307 	and.w	r3, r3, #7
   1ba42:	2b04      	cmp	r3, #4
   1ba44:	d101      	bne.n	1ba4a <ull_conn_rx+0x14e>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1ba46:	f884 20ed 	strb.w	r2, [r4, #237]	; 0xed
				break;
			}
		}

		/* Procedure complete */
		conn->procedure_expire = 0U;
   1ba4a:	2000      	movs	r0, #0
   1ba4c:	f8a4 007c 	strh.w	r0, [r4, #124]	; 0x7c
		break;
   1ba50:	e054      	b.n	1bafc <ull_conn_rx+0x200>
		if (!conn->lll.role ||
   1ba52:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1ba56:	2b00      	cmp	r3, #0
   1ba58:	f280 8404 	bge.w	1c264 <ull_conn_rx+0x968>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CHAN_MAP_IND,
   1ba5c:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1ba60:	2001      	movs	r0, #1
   1ba62:	f7ff fc7f 	bl	1b364 <pdu_len_cmp>
		if (!conn->lll.role ||
   1ba66:	2800      	cmp	r0, #0
   1ba68:	f000 83fc 	beq.w	1c264 <ull_conn_rx+0x968>
	instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
   1ba6c:	f8b5 6029 	ldrh.w	r6, [r5, #41]	; 0x29
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   1ba70:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1ba72:	1af3      	subs	r3, r6, r3
   1ba74:	041f      	lsls	r7, r3, #16
   1ba76:	d487      	bmi.n	1b988 <ull_conn_rx+0x8c>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   1ba78:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
   1ba7c:	f894 208d 	ldrb.w	r2, [r4, #141]	; 0x8d
   1ba80:	1a9b      	subs	r3, r3, r2
   1ba82:	f003 0303 	and.w	r3, r3, #3
   1ba86:	2b02      	cmp	r3, #2
   1ba88:	d08b      	beq.n	1b9a2 <ull_conn_rx+0xa6>
	memcpy(&conn->llcp.chan_map.chm[0], &pdu->llctrl.chan_map_ind.chm[0],
   1ba8a:	2205      	movs	r2, #5
   1ba8c:	f105 0124 	add.w	r1, r5, #36	; 0x24
   1ba90:	f104 0091 	add.w	r0, r4, #145	; 0x91
   1ba94:	f00a f908 	bl	25ca8 <memcpy>
	conn->llcp.chan_map.initiate = 0U;
   1ba98:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
	conn->llcp.chan_map.instant = instant;
   1ba9c:	f8a4 6096 	strh.w	r6, [r4, #150]	; 0x96
	conn->llcp.chan_map.initiate = 0U;
   1baa0:	f36f 0300 	bfc	r3, #0, #1
   1baa4:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
	conn->llcp_type = LLCP_CHAN_MAP;
   1baa8:	2302      	movs	r3, #2
   1baaa:	f884 308e 	strb.w	r3, [r4, #142]	; 0x8e
	conn->llcp_ack -= 2U;
   1baae:	f894 308d 	ldrb.w	r3, [r4, #141]	; 0x8d
   1bab2:	3b02      	subs	r3, #2
   1bab4:	f884 308d 	strb.w	r3, [r4, #141]	; 0x8d
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1bab8:	e72b      	b.n	1b912 <ull_conn_rx+0x16>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_TERMINATE_IND,
   1baba:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1babe:	2002      	movs	r0, #2
   1bac0:	f7ff fc50 	bl	1b364 <pdu_len_cmp>
   1bac4:	2800      	cmp	r0, #0
   1bac6:	f000 83cd 	beq.w	1c264 <ull_conn_rx+0x968>
		terminate_ind_recv(conn, *rx, pdu_rx);
   1baca:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
	conn->llcp_terminate.reason_peer = pdu->llctrl.terminate_ind.error_code;
   1bace:	f884 30c7 	strb.w	r3, [r4, #199]	; 0xc7
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1bad2:	e71e      	b.n	1b912 <ull_conn_rx+0x16>
		if (!conn->lll.role ||
   1bad4:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1bad8:	2b00      	cmp	r3, #0
   1bada:	f280 83c3 	bge.w	1c264 <ull_conn_rx+0x968>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_FEATURE_REQ,
   1bade:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1bae2:	2008      	movs	r0, #8
   1bae4:	f7ff fc3e 	bl	1b364 <pdu_len_cmp>
		if (!conn->lll.role ||
   1bae8:	2800      	cmp	r0, #0
   1baea:	f000 83bb 	beq.w	1c264 <ull_conn_rx+0x968>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   1baee:	4881      	ldr	r0, [pc, #516]	; (1bcf4 <ull_conn_rx+0x3f8>)
   1baf0:	f00c fac8 	bl	28084 <mem_acquire>
	if (!tx) {
   1baf4:	4606      	mov	r6, r0
   1baf6:	b920      	cbnz	r0, 1bb02 <ull_conn_rx+0x206>
		return -ENOBUFS;
   1baf8:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
   1bafc:	b001      	add	sp, #4
   1bafe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	       (features[1] << 8) | (features[2] << 16);
   1bb02:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   1bb06:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   1bb0a:	041b      	lsls	r3, r3, #16
   1bb0c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
   1bb10:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
	       (features[1] << 8) | (features[2] << 16);
   1bb14:	4313      	orrs	r3, r2
   1bb16:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
   1bb1a:	f443 037e 	orr.w	r3, r3, #16646144	; 0xfe0000
	conn->llcp_feature.features &= feat_get(&req->features[0]);
   1bb1e:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
	       (features[1] << 8) | (features[2] << 16);
   1bb22:	f443 5343 	orr.w	r3, r3, #12480	; 0x30c0
   1bb26:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features &= feat_get(&req->features[0]);
   1bb2a:	4013      	ands	r3, r2
   1bb2c:	f3c3 0310 	ubfx	r3, r3, #0, #17
   1bb30:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
	conn->common.fex_valid = 1U;
   1bb34:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
   1bb38:	f043 0301 	orr.w	r3, r3, #1
   1bb3c:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   1bb40:	7903      	ldrb	r3, [r0, #4]
   1bb42:	f043 0303 	orr.w	r3, r3, #3
   1bb46:	7103      	strb	r3, [r0, #4]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   1bb48:	2208      	movs	r2, #8
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
   1bb4a:	2309      	movs	r3, #9
   1bb4c:	7143      	strb	r3, [r0, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
   1bb4e:	71c3      	strb	r3, [r0, #7]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   1bb50:	2100      	movs	r1, #0
   1bb52:	4410      	add	r0, r2
   1bb54:	f00a f8d3 	bl	25cfe <memset>
	sys_put_le24(conn->llcp_feature.features,
   1bb58:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
	dst[0] = val;
   1bb5c:	7233      	strb	r3, [r6, #8]
	dst[1] = val >> 8;
   1bb5e:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
   1bb62:	0c1b      	lsrs	r3, r3, #16
	dst[1] = val >> 8;
   1bb64:	7272      	strb	r2, [r6, #9]
	dst[2] = val >> 16;
   1bb66:	72b3      	strb	r3, [r6, #10]
	ctrl_tx_sec_enqueue(conn, tx);
   1bb68:	4631      	mov	r1, r6
   1bb6a:	4620      	mov	r0, r4
   1bb6c:	f00c fd07 	bl	2857e <ctrl_tx_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1bb70:	e6cf      	b.n	1b912 <ull_conn_rx+0x16>
		if ((!IS_ENABLED(CONFIG_BT_CTLR_SLAVE_FEAT_REQ) &&
   1bb72:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1bb76:	2b00      	cmp	r3, #0
   1bb78:	f2c0 8374 	blt.w	1c264 <ull_conn_rx+0x968>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_FEATURE_RSP,
   1bb7c:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1bb80:	2009      	movs	r0, #9
   1bb82:	f7ff fbef 	bl	1b364 <pdu_len_cmp>
		     conn->lll.role) ||
   1bb86:	2800      	cmp	r0, #0
   1bb88:	f000 836c 	beq.w	1c264 <ull_conn_rx+0x968>
	       (features[1] << 8) | (features[2] << 16);
   1bb8c:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   1bb90:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   1bb94:	041b      	lsls	r3, r3, #16
   1bb96:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
   1bb9a:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
	       (features[1] << 8) | (features[2] << 16);
   1bb9e:	4313      	orrs	r3, r2
   1bba0:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
   1bba4:	f443 037e 	orr.w	r3, r3, #16646144	; 0xfe0000
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
   1bba8:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
	       (features[1] << 8) | (features[2] << 16);
   1bbac:	f443 5343 	orr.w	r3, r3, #12480	; 0x30c0
   1bbb0:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
   1bbb4:	4013      	ands	r3, r2
   1bbb6:	f3c3 0310 	ubfx	r3, r3, #0, #17
   1bbba:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
	conn->common.fex_valid = 1U;
   1bbbe:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
   1bbc2:	f043 0301 	orr.w	r3, r3, #1
   1bbc6:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
	conn->llcp_feature.ack = conn->llcp_feature.req;
   1bbca:	f894 30b4 	ldrb.w	r3, [r4, #180]	; 0xb4
   1bbce:	f884 30b5 	strb.w	r3, [r4, #181]	; 0xb5
	conn->procedure_expire = 0U;
   1bbd2:	e73a      	b.n	1ba4a <ull_conn_rx+0x14e>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_VERSION_IND,
   1bbd4:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1bbd8:	200c      	movs	r0, #12
   1bbda:	f7ff fbc3 	bl	1b364 <pdu_len_cmp>
   1bbde:	2800      	cmp	r0, #0
   1bbe0:	f000 8340 	beq.w	1c264 <ull_conn_rx+0x968>
	if (!conn->llcp_version.tx) {
   1bbe4:	f894 30be 	ldrb.w	r3, [r4, #190]	; 0xbe
   1bbe8:	07d8      	lsls	r0, r3, #31
   1bbea:	d43f      	bmi.n	1bc6c <ull_conn_rx+0x370>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   1bbec:	4841      	ldr	r0, [pc, #260]	; (1bcf4 <ull_conn_rx+0x3f8>)
   1bbee:	f00c fa49 	bl	28084 <mem_acquire>
		if (!tx) {
   1bbf2:	4601      	mov	r1, r0
   1bbf4:	2800      	cmp	r0, #0
   1bbf6:	f43f af7f 	beq.w	1baf8 <ull_conn_rx+0x1fc>
		conn->llcp_version.tx = 1U;
   1bbfa:	f894 30be 	ldrb.w	r3, [r4, #190]	; 0xbe
   1bbfe:	f043 0301 	orr.w	r3, r3, #1
   1bc02:	f884 30be 	strb.w	r3, [r4, #190]	; 0xbe
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   1bc06:	7903      	ldrb	r3, [r0, #4]
   1bc08:	f043 0303 	orr.w	r3, r3, #3
   1bc0c:	7103      	strb	r3, [r0, #4]
		pdu_tx->len =
   1bc0e:	2306      	movs	r3, #6
   1bc10:	7143      	strb	r3, [r0, #5]
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
   1bc12:	230c      	movs	r3, #12
   1bc14:	71c3      	strb	r3, [r0, #7]
		v->version_number = LL_VERSION_NUMBER;
   1bc16:	230a      	movs	r3, #10
   1bc18:	7203      	strb	r3, [r0, #8]
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
   1bc1a:	f06f 030e 	mvn.w	r3, #14
   1bc1e:	7243      	strb	r3, [r0, #9]
   1bc20:	2305      	movs	r3, #5
   1bc22:	7283      	strb	r3, [r0, #10]
		v->sub_version_number =
   1bc24:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1bc28:	72c3      	strb	r3, [r0, #11]
   1bc2a:	7303      	strb	r3, [r0, #12]
		ctrl_tx_sec_enqueue(conn, tx);
   1bc2c:	4620      	mov	r0, r4
   1bc2e:	f00c fca6 	bl	2857e <ctrl_tx_enqueue>
		rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1bc32:	2303      	movs	r3, #3
   1bc34:	712b      	strb	r3, [r5, #4]
	conn->llcp_version.version_number = v->version_number;
   1bc36:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   1bc3a:	f884 30bf 	strb.w	r3, [r4, #191]	; 0xbf
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
   1bc3e:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
   1bc42:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   1bc46:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1bc4a:	f8a4 30c0 	strh.w	r3, [r4, #192]	; 0xc0
		sys_le16_to_cpu(v->sub_version_number);
   1bc4e:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   1bc52:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
   1bc56:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_version.sub_version_number =
   1bc5a:	f8a4 30c2 	strh.w	r3, [r4, #194]	; 0xc2
	conn->llcp_version.rx = 1U;
   1bc5e:	f894 30be 	ldrb.w	r3, [r4, #190]	; 0xbe
   1bc62:	f043 0302 	orr.w	r3, r3, #2
   1bc66:	f884 30be 	strb.w	r3, [r4, #190]	; 0xbe
	return 0;
   1bc6a:	e65e      	b.n	1b92a <ull_conn_rx+0x2e>
	} else if (!conn->llcp_version.rx) {
   1bc6c:	f013 0302 	ands.w	r3, r3, #2
   1bc70:	f47f ae4f 	bne.w	1b912 <ull_conn_rx+0x16>
		conn->llcp_version.ack = conn->llcp_version.req;
   1bc74:	f894 20bc 	ldrb.w	r2, [r4, #188]	; 0xbc
   1bc78:	f884 20bd 	strb.w	r2, [r4, #189]	; 0xbd
		conn->procedure_expire = 0U;
   1bc7c:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
   1bc80:	e7d9      	b.n	1bc36 <ull_conn_rx+0x33a>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ,
   1bc82:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1bc86:	200f      	movs	r0, #15
   1bc88:	f7ff fb6c 	bl	1b364 <pdu_len_cmp>
   1bc8c:	2800      	cmp	r0, #0
   1bc8e:	f000 82e9 	beq.w	1c264 <ull_conn_rx+0x968>
		if (conn_upd_curr && (conn_upd_curr != conn)) {
   1bc92:	4b17      	ldr	r3, [pc, #92]	; (1bcf0 <ull_conn_rx+0x3f4>)
   1bc94:	6818      	ldr	r0, [r3, #0]
   1bc96:	b150      	cbz	r0, 1bcae <ull_conn_rx+0x3b2>
   1bc98:	4284      	cmp	r4, r0
   1bc9a:	d008      	beq.n	1bcae <ull_conn_rx+0x3b2>
			nack = reject_ext_ind_send(conn, *rx,
   1bc9c:	2320      	movs	r3, #32
				nack = reject_ext_ind_send(conn, *rx,
   1bc9e:	220f      	movs	r2, #15
				nack = reject_ext_ind_send(conn, *rx,
   1bca0:	1d29      	adds	r1, r5, #4
   1bca2:	4620      	mov	r0, r4
}
   1bca4:	b001      	add	sp, #4
   1bca6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
				nack = reject_ext_ind_send(conn, *rx,
   1bcaa:	f7ff bc65 	b.w	1b578 <reject_ext_ind_send.isra.0>
		if (!conn->lll.role) {
   1bcae:	f994 103d 	ldrsb.w	r1, [r4, #61]	; 0x3d
   1bcb2:	f894 20ed 	ldrb.w	r2, [r4, #237]	; 0xed
   1bcb6:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   1bcba:	2900      	cmp	r1, #0
   1bcbc:	f2c0 80b0 	blt.w	1be20 <ull_conn_rx+0x524>
			if ((conn->llcp_conn_param.req !=
   1bcc0:	429a      	cmp	r2, r3
   1bcc2:	d009      	beq.n	1bcd8 <ull_conn_rx+0x3dc>
			    ((conn->llcp_conn_param.state ==
   1bcc4:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
					conn->llcp_conn_param.ack) &&
   1bcc8:	f013 0307 	ands.w	r3, r3, #7
   1bccc:	d002      	beq.n	1bcd4 <ull_conn_rx+0x3d8>
			      LLCP_CPR_STATE_REQ) ||
   1bcce:	3b04      	subs	r3, #4
   1bcd0:	2b01      	cmp	r3, #1
   1bcd2:	d801      	bhi.n	1bcd8 <ull_conn_rx+0x3dc>
				nack = reject_ext_ind_send(conn, *rx,
   1bcd4:	2323      	movs	r3, #35	; 0x23
   1bcd6:	e7e2      	b.n	1bc9e <ull_conn_rx+0x3a2>
			} else if (((conn->llcp_req - conn->llcp_ack) &
   1bcd8:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
   1bcdc:	f894 108d 	ldrb.w	r1, [r4, #141]	; 0x8d
   1bce0:	1a5b      	subs	r3, r3, r1
   1bce2:	f003 0303 	and.w	r3, r3, #3
   1bce6:	2b02      	cmp	r3, #2
   1bce8:	d106      	bne.n	1bcf8 <ull_conn_rx+0x3fc>
				nack = reject_ext_ind_send(conn, *rx,
   1bcea:	232a      	movs	r3, #42	; 0x2a
   1bcec:	e7d7      	b.n	1bc9e <ull_conn_rx+0x3a2>
   1bcee:	bf00      	nop
   1bcf0:	200018c8 	.word	0x200018c8
   1bcf4:	20001944 	.word	0x20001944
				u16_t interval_min =
   1bcf8:	f8b5 9024 	ldrh.w	r9, [r5, #36]	; 0x24
				if ((interval_min < 6) ||
   1bcfc:	f1b9 0f05 	cmp.w	r9, #5
				u16_t interval_min =
   1bd00:	fa1f f389 	uxth.w	r3, r9
				if ((interval_min < 6) ||
   1bd04:	d922      	bls.n	1bd4c <ull_conn_rx+0x450>
				u16_t interval_max =
   1bd06:	f8b5 8026 	ldrh.w	r8, [r5, #38]	; 0x26
				if ((interval_min < 6) ||
   1bd0a:	f5b8 6f48 	cmp.w	r8, #3200	; 0xc80
				u16_t interval_max =
   1bd0e:	fa1f f188 	uxth.w	r1, r8
				if ((interval_min < 6) ||
   1bd12:	d81b      	bhi.n	1bd4c <ull_conn_rx+0x450>
				    (interval_max > 3200) ||
   1bd14:	428b      	cmp	r3, r1
   1bd16:	d819      	bhi.n	1bd4c <ull_conn_rx+0x450>
				u16_t latency =
   1bd18:	f8b5 e028 	ldrh.w	lr, [r5, #40]	; 0x28
				    (interval_min > interval_max) ||
   1bd1c:	f5be 7ffa 	cmp.w	lr, #500	; 0x1f4
				u16_t latency =
   1bd20:	fa1f fc8e 	uxth.w	ip, lr
				    (interval_min > interval_max) ||
   1bd24:	d212      	bcs.n	1bd4c <ull_conn_rx+0x450>
				u16_t timeout =
   1bd26:	8d6f      	ldrh	r7, [r5, #42]	; 0x2a
				    (latency > 499) ||
   1bd28:	f1a7 0a0a 	sub.w	sl, r7, #10
   1bd2c:	fa1f fa8a 	uxth.w	sl, sl
   1bd30:	f640 4b76 	movw	fp, #3190	; 0xc76
   1bd34:	45da      	cmp	sl, fp
				u16_t timeout =
   1bd36:	b2bb      	uxth	r3, r7
				    (latency > 499) ||
   1bd38:	d808      	bhi.n	1bd4c <ull_conn_rx+0x450>
				     ((latency + 1) * interval_max)) ||
   1bd3a:	fb0c 1a01 	mla	sl, ip, r1, r1
				    (timeout > 3200) ||
   1bd3e:	ebba 0f83 	cmp.w	sl, r3, lsl #2
   1bd42:	d203      	bcs.n	1bd4c <ull_conn_rx+0x450>
					cpr->preferred_periodicity;
   1bd44:	f895 a02c 	ldrb.w	sl, [r5, #44]	; 0x2c
				     ((latency + 1) * interval_max)) ||
   1bd48:	4551      	cmp	r1, sl
   1bd4a:	d201      	bcs.n	1bd50 <ull_conn_rx+0x454>
				nack = reject_ext_ind_send(conn, *rx,
   1bd4c:	231e      	movs	r3, #30
   1bd4e:	e7a6      	b.n	1bc9e <ull_conn_rx+0x3a2>
				conn->llcp_conn_param.interval_min =
   1bd50:	f8a4 90f0 	strh.w	r9, [r4, #240]	; 0xf0
				conn->llcp_conn_param.interval_max =
   1bd54:	f8a4 80f2 	strh.w	r8, [r4, #242]	; 0xf2
				conn->llcp_conn_param.latency =	latency;
   1bd58:	f8a4 e0f4 	strh.w	lr, [r4, #244]	; 0xf4
				conn->llcp_conn_param.timeout =	timeout;
   1bd5c:	f8a4 70f6 	strh.w	r7, [r4, #246]	; 0xf6
				conn->llcp_conn_param.preferred_periodicity =
   1bd60:	f884 a0f8 	strb.w	sl, [r4, #248]	; 0xf8
					sys_le16_to_cpu(cpr->reference_conn_event_count);
   1bd64:	f895 e02e 	ldrb.w	lr, [r5, #46]	; 0x2e
   1bd68:	f895 702d 	ldrb.w	r7, [r5, #45]	; 0x2d
   1bd6c:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
				conn->llcp_conn_param.reference_conn_event_count =
   1bd70:	f8a4 70fa 	strh.w	r7, [r4, #250]	; 0xfa
					sys_le16_to_cpu(cpr->offset0);
   1bd74:	f895 e030 	ldrb.w	lr, [r5, #48]	; 0x30
   1bd78:	f895 702f 	ldrb.w	r7, [r5, #47]	; 0x2f
   1bd7c:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
				conn->llcp_conn_param.offset0 =
   1bd80:	f8a4 70fc 	strh.w	r7, [r4, #252]	; 0xfc
					sys_le16_to_cpu(cpr->offset1);
   1bd84:	f895 e032 	ldrb.w	lr, [r5, #50]	; 0x32
   1bd88:	f895 7031 	ldrb.w	r7, [r5, #49]	; 0x31
   1bd8c:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
				conn->llcp_conn_param.offset1 =
   1bd90:	f8a4 70fe 	strh.w	r7, [r4, #254]	; 0xfe
					sys_le16_to_cpu(cpr->offset2);
   1bd94:	f895 e034 	ldrb.w	lr, [r5, #52]	; 0x34
   1bd98:	f895 7033 	ldrb.w	r7, [r5, #51]	; 0x33
   1bd9c:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
				conn->llcp_conn_param.offset2 =
   1bda0:	f8a4 7100 	strh.w	r7, [r4, #256]	; 0x100
					sys_le16_to_cpu(cpr->offset3);
   1bda4:	f895 e036 	ldrb.w	lr, [r5, #54]	; 0x36
   1bda8:	f895 7035 	ldrb.w	r7, [r5, #53]	; 0x35
   1bdac:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
				conn->llcp_conn_param.offset3 =
   1bdb0:	f8a4 7102 	strh.w	r7, [r4, #258]	; 0x102
					sys_le16_to_cpu(cpr->offset4);
   1bdb4:	f895 7037 	ldrb.w	r7, [r5, #55]	; 0x37
   1bdb8:	f895 e038 	ldrb.w	lr, [r5, #56]	; 0x38
   1bdbc:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
				conn->llcp_conn_param.offset4 =
   1bdc0:	f8a4 7104 	strh.w	r7, [r4, #260]	; 0x104
					sys_le16_to_cpu(cpr->offset5);
   1bdc4:	f895 7039 	ldrb.w	r7, [r5, #57]	; 0x39
   1bdc8:	f895 503a 	ldrb.w	r5, [r5, #58]	; 0x3a
   1bdcc:	ea47 2505 	orr.w	r5, r7, r5, lsl #8
				conn->llcp_conn_param.offset5 =
   1bdd0:	f8a4 5106 	strh.w	r5, [r4, #262]	; 0x106
				     lll->interval) ||
   1bdd4:	8de5      	ldrh	r5, [r4, #46]	; 0x2e
				if ((conn->llcp_conn_param.interval_max !=
   1bdd6:	42a9      	cmp	r1, r5
   1bdd8:	d112      	bne.n	1be00 <ull_conn_rx+0x504>
				     lll->interval) ||
   1bdda:	8e21      	ldrh	r1, [r4, #48]	; 0x30
   1bddc:	4561      	cmp	r1, ip
   1bdde:	d10f      	bne.n	1be00 <ull_conn_rx+0x504>
				    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   1bde0:	f240 41e2 	movw	r1, #1250	; 0x4e2
			    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   1bde4:	4369      	muls	r1, r5
   1bde6:	f242 7510 	movw	r5, #10000	; 0x2710
   1bdea:	fb05 1303 	mla	r3, r5, r3, r1
   1bdee:	3b01      	subs	r3, #1
   1bdf0:	fbb3 f3f1 	udiv	r3, r3, r1
			    (conn->llcp_conn_param.latency != lll->latency) ||
   1bdf4:	f8b4 1076 	ldrh.w	r1, [r4, #118]	; 0x76
   1bdf8:	b29b      	uxth	r3, r3
   1bdfa:	4299      	cmp	r1, r3
   1bdfc:	f000 8093 	beq.w	1bf26 <ull_conn_rx+0x62a>
				conn->llcp_conn_param.state =
   1be00:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
   1be04:	2103      	movs	r1, #3
   1be06:	f361 0302 	bfi	r3, r1, #0, #3
   1be0a:	f884 30ee 	strb.w	r3, [r4, #238]	; 0xee
			conn->llcp_conn_param.ack--;
   1be0e:	3a01      	subs	r2, #1
   1be10:	f884 20ed 	strb.w	r2, [r4, #237]	; 0xed
			if (!conn_upd_curr) {
   1be14:	2800      	cmp	r0, #0
   1be16:	f47f ad88 	bne.w	1b92a <ull_conn_rx+0x2e>
				conn_upd_curr = conn;
   1be1a:	4bc7      	ldr	r3, [pc, #796]	; (1c138 <ull_conn_rx+0x83c>)
   1be1c:	601c      	str	r4, [r3, #0]
   1be1e:	e66d      	b.n	1bafc <ull_conn_rx+0x200>
		} else if ((conn->llcp_conn_param.req ==
   1be20:	429a      	cmp	r2, r3
   1be22:	d004      	beq.n	1be2e <ull_conn_rx+0x532>
			    conn->llcp_conn_param.ack) ||
   1be24:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
   1be28:	0799      	lsls	r1, r3, #30
   1be2a:	f040 8088 	bne.w	1bf3e <ull_conn_rx+0x642>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   1be2e:	f8b5 9024 	ldrh.w	r9, [r5, #36]	; 0x24
			if ((interval_min < 6) ||
   1be32:	f1b9 0f05 	cmp.w	r9, #5
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   1be36:	fa1f f389 	uxth.w	r3, r9
			if ((interval_min < 6) ||
   1be3a:	d987      	bls.n	1bd4c <ull_conn_rx+0x450>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   1be3c:	f8b5 8026 	ldrh.w	r8, [r5, #38]	; 0x26
			if ((interval_min < 6) ||
   1be40:	f5b8 6f48 	cmp.w	r8, #3200	; 0xc80
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   1be44:	fa1f f188 	uxth.w	r1, r8
			if ((interval_min < 6) ||
   1be48:	d880      	bhi.n	1bd4c <ull_conn_rx+0x450>
			    (interval_max > 3200) ||
   1be4a:	428b      	cmp	r3, r1
   1be4c:	f63f af7e 	bhi.w	1bd4c <ull_conn_rx+0x450>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   1be50:	f8b5 e028 	ldrh.w	lr, [r5, #40]	; 0x28
			    (interval_min > interval_max) ||
   1be54:	f5be 7ffa 	cmp.w	lr, #500	; 0x1f4
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   1be58:	fa1f fc8e 	uxth.w	ip, lr
			    (interval_min > interval_max) ||
   1be5c:	f4bf af76 	bcs.w	1bd4c <ull_conn_rx+0x450>
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   1be60:	8d6f      	ldrh	r7, [r5, #42]	; 0x2a
			    (latency > 499) ||
   1be62:	f1a7 0a0a 	sub.w	sl, r7, #10
   1be66:	fa1f fa8a 	uxth.w	sl, sl
   1be6a:	f640 4b76 	movw	fp, #3190	; 0xc76
   1be6e:	45da      	cmp	sl, fp
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   1be70:	b2bb      	uxth	r3, r7
			    (latency > 499) ||
   1be72:	f63f af6b 	bhi.w	1bd4c <ull_conn_rx+0x450>
			     ((latency + 1) * interval_max)) ||
   1be76:	fb0c 1a01 	mla	sl, ip, r1, r1
			    (timeout < 10) || (timeout > 3200) ||
   1be7a:	ebba 0f83 	cmp.w	sl, r3, lsl #2
   1be7e:	f4bf af65 	bcs.w	1bd4c <ull_conn_rx+0x450>
				cpr->preferred_periodicity;
   1be82:	f895 a02c 	ldrb.w	sl, [r5, #44]	; 0x2c
			     ((latency + 1) * interval_max)) ||
   1be86:	4551      	cmp	r1, sl
   1be88:	f4ff af60 	bcc.w	1bd4c <ull_conn_rx+0x450>
			conn->llcp_conn_param.interval_min = interval_min;
   1be8c:	f8a4 90f0 	strh.w	r9, [r4, #240]	; 0xf0
			conn->llcp_conn_param.interval_max = interval_max;
   1be90:	f8a4 80f2 	strh.w	r8, [r4, #242]	; 0xf2
			conn->llcp_conn_param.latency =	latency;
   1be94:	f8a4 e0f4 	strh.w	lr, [r4, #244]	; 0xf4
			conn->llcp_conn_param.timeout =	timeout;
   1be98:	f8a4 70f6 	strh.w	r7, [r4, #246]	; 0xf6
			conn->llcp_conn_param.preferred_periodicity =
   1be9c:	f884 a0f8 	strb.w	sl, [r4, #248]	; 0xf8
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   1bea0:	f895 e02e 	ldrb.w	lr, [r5, #46]	; 0x2e
   1bea4:	f895 702d 	ldrb.w	r7, [r5, #45]	; 0x2d
   1bea8:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
   1beac:	f8a4 70fa 	strh.w	r7, [r4, #250]	; 0xfa
				sys_le16_to_cpu(cpr->offset0);
   1beb0:	f895 e030 	ldrb.w	lr, [r5, #48]	; 0x30
   1beb4:	f895 702f 	ldrb.w	r7, [r5, #47]	; 0x2f
   1beb8:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
			conn->llcp_conn_param.offset0 =
   1bebc:	f8a4 70fc 	strh.w	r7, [r4, #252]	; 0xfc
				sys_le16_to_cpu(cpr->offset1);
   1bec0:	f895 e032 	ldrb.w	lr, [r5, #50]	; 0x32
   1bec4:	f895 7031 	ldrb.w	r7, [r5, #49]	; 0x31
   1bec8:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
			conn->llcp_conn_param.offset1 =
   1becc:	f8a4 70fe 	strh.w	r7, [r4, #254]	; 0xfe
				sys_le16_to_cpu(cpr->offset2);
   1bed0:	f895 e034 	ldrb.w	lr, [r5, #52]	; 0x34
   1bed4:	f895 7033 	ldrb.w	r7, [r5, #51]	; 0x33
   1bed8:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
			conn->llcp_conn_param.offset2 =
   1bedc:	f8a4 7100 	strh.w	r7, [r4, #256]	; 0x100
				sys_le16_to_cpu(cpr->offset3);
   1bee0:	f895 e036 	ldrb.w	lr, [r5, #54]	; 0x36
   1bee4:	f895 7035 	ldrb.w	r7, [r5, #53]	; 0x35
   1bee8:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
			conn->llcp_conn_param.offset3 =
   1beec:	f8a4 7102 	strh.w	r7, [r4, #258]	; 0x102
				sys_le16_to_cpu(cpr->offset4);
   1bef0:	f895 7037 	ldrb.w	r7, [r5, #55]	; 0x37
   1bef4:	f895 e038 	ldrb.w	lr, [r5, #56]	; 0x38
   1bef8:	ea47 270e 	orr.w	r7, r7, lr, lsl #8
			conn->llcp_conn_param.offset4 =
   1befc:	f8a4 7104 	strh.w	r7, [r4, #260]	; 0x104
				sys_le16_to_cpu(cpr->offset5);
   1bf00:	f895 7039 	ldrb.w	r7, [r5, #57]	; 0x39
   1bf04:	f895 503a 	ldrb.w	r5, [r5, #58]	; 0x3a
   1bf08:	ea47 2505 	orr.w	r5, r7, r5, lsl #8
			conn->llcp_conn_param.offset5 =
   1bf0c:	f8a4 5106 	strh.w	r5, [r4, #262]	; 0x106
			     lll->interval) ||
   1bf10:	8de5      	ldrh	r5, [r4, #46]	; 0x2e
			if ((conn->llcp_conn_param.interval_max !=
   1bf12:	42a9      	cmp	r1, r5
   1bf14:	f47f af74 	bne.w	1be00 <ull_conn_rx+0x504>
			     lll->interval) ||
   1bf18:	8e25      	ldrh	r5, [r4, #48]	; 0x30
   1bf1a:	4565      	cmp	r5, ip
   1bf1c:	f47f af70 	bne.w	1be00 <ull_conn_rx+0x504>
			    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   1bf20:	f240 45e2 	movw	r5, #1250	; 0x4e2
   1bf24:	e75e      	b.n	1bde4 <ull_conn_rx+0x4e8>
				conn->llcp_conn_param.state =
   1bf26:	f8b4 30ee 	ldrh.w	r3, [r4, #238]	; 0xee
   1bf2a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   1bf2e:	f043 0301 	orr.w	r3, r3, #1
   1bf32:	f8a4 30ee 	strh.w	r3, [r4, #238]	; 0xee
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1bf36:	6833      	ldr	r3, [r6, #0]
   1bf38:	2103      	movs	r1, #3
   1bf3a:	7119      	strb	r1, [r3, #4]
   1bf3c:	e767      	b.n	1be0e <ull_conn_rx+0x512>
			LL_ASSERT(0);
   1bf3e:	4a7f      	ldr	r2, [pc, #508]	; (1c13c <ull_conn_rx+0x840>)
   1bf40:	497f      	ldr	r1, [pc, #508]	; (1c140 <ull_conn_rx+0x844>)
   1bf42:	4880      	ldr	r0, [pc, #512]	; (1c144 <ull_conn_rx+0x848>)
   1bf44:	f241 6352 	movw	r3, #5714	; 0x1652
   1bf48:	f007 ffcb 	bl	23ee2 <printk>
   1bf4c:	4040      	eors	r0, r0
   1bf4e:	f380 8811 	msr	BASEPRI, r0
   1bf52:	f04f 0003 	mov.w	r0, #3
   1bf56:	df02      	svc	2
   1bf58:	e4e7      	b.n	1b92a <ull_conn_rx+0x2e>
		if (conn->lll.role ||
   1bf5a:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1bf5e:	2b00      	cmp	r3, #0
   1bf60:	f2c0 8180 	blt.w	1c264 <ull_conn_rx+0x968>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP,
   1bf64:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1bf68:	2010      	movs	r0, #16
   1bf6a:	f7ff f9fb 	bl	1b364 <pdu_len_cmp>
		if (conn->lll.role ||
   1bf6e:	2800      	cmp	r0, #0
   1bf70:	f000 8178 	beq.w	1c264 <ull_conn_rx+0x968>
		if (!conn->lll.role &&
   1bf74:	f894 20ec 	ldrb.w	r2, [r4, #236]	; 0xec
   1bf78:	f894 30ed 	ldrb.w	r3, [r4, #237]	; 0xed
   1bf7c:	429a      	cmp	r2, r3
   1bf7e:	d07a      	beq.n	1c076 <ull_conn_rx+0x77a>
		    (conn->llcp_conn_param.state ==
   1bf80:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
		     conn->llcp_conn_param.ack) &&
   1bf84:	f003 0307 	and.w	r3, r3, #7
   1bf88:	2b04      	cmp	r3, #4
   1bf8a:	d174      	bne.n	1c076 <ull_conn_rx+0x77a>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   1bf8c:	8caf      	ldrh	r7, [r5, #36]	; 0x24
			if ((interval_min < 6) ||
   1bf8e:	2f05      	cmp	r7, #5
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   1bf90:	b2ba      	uxth	r2, r7
			if ((interval_min < 6) ||
   1bf92:	d921      	bls.n	1bfd8 <ull_conn_rx+0x6dc>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   1bf94:	8ce8      	ldrh	r0, [r5, #38]	; 0x26
			if ((interval_min < 6) ||
   1bf96:	f5b0 6f48 	cmp.w	r0, #3200	; 0xc80
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   1bf9a:	b283      	uxth	r3, r0
			if ((interval_min < 6) ||
   1bf9c:	d81c      	bhi.n	1bfd8 <ull_conn_rx+0x6dc>
			    (interval_max > 3200) ||
   1bf9e:	429a      	cmp	r2, r3
   1bfa0:	d81a      	bhi.n	1bfd8 <ull_conn_rx+0x6dc>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   1bfa2:	8d29      	ldrh	r1, [r5, #40]	; 0x28
			    (interval_min > interval_max) ||
   1bfa4:	f5b1 7ffa 	cmp.w	r1, #500	; 0x1f4
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   1bfa8:	fa1f fc81 	uxth.w	ip, r1
			    (interval_min > interval_max) ||
   1bfac:	d214      	bcs.n	1bfd8 <ull_conn_rx+0x6dc>
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   1bfae:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
			    (latency > 499) ||
   1bfb0:	f1a2 0e0a 	sub.w	lr, r2, #10
   1bfb4:	fa1f fe8e 	uxth.w	lr, lr
   1bfb8:	f640 4976 	movw	r9, #3190	; 0xc76
   1bfbc:	45ce      	cmp	lr, r9
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   1bfbe:	fa1f f882 	uxth.w	r8, r2
			    (latency > 499) ||
   1bfc2:	d809      	bhi.n	1bfd8 <ull_conn_rx+0x6dc>
			     ((latency + 1) * interval_max)) ||
   1bfc4:	fb0c 3c03 	mla	ip, ip, r3, r3
			    (timeout < 10) || (timeout > 3200) ||
   1bfc8:	ebbc 0f88 	cmp.w	ip, r8, lsl #2
   1bfcc:	d204      	bcs.n	1bfd8 <ull_conn_rx+0x6dc>
				cpr->preferred_periodicity;
   1bfce:	f895 c02c 	ldrb.w	ip, [r5, #44]	; 0x2c
			     ((latency + 1) * interval_max)) ||
   1bfd2:	4563      	cmp	r3, ip
   1bfd4:	46e6      	mov	lr, ip
   1bfd6:	d202      	bcs.n	1bfde <ull_conn_rx+0x6e2>
				nack = reject_ext_ind_send(conn, *rx,
   1bfd8:	231e      	movs	r3, #30
   1bfda:	2210      	movs	r2, #16
   1bfdc:	e660      	b.n	1bca0 <ull_conn_rx+0x3a4>
			conn->procedure_expire = 0U;
   1bfde:	2300      	movs	r3, #0
   1bfe0:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
			conn->llcp_conn_param.interval_min = interval_min;
   1bfe4:	f8a4 70f0 	strh.w	r7, [r4, #240]	; 0xf0
			conn->llcp_conn_param.interval_max = interval_max;
   1bfe8:	f8a4 00f2 	strh.w	r0, [r4, #242]	; 0xf2
			conn->llcp_conn_param.latency =	latency;
   1bfec:	f8a4 10f4 	strh.w	r1, [r4, #244]	; 0xf4
			conn->llcp_conn_param.timeout =	timeout;
   1bff0:	f8a4 20f6 	strh.w	r2, [r4, #246]	; 0xf6
			conn->llcp_conn_param.preferred_periodicity =
   1bff4:	f884 c0f8 	strb.w	ip, [r4, #248]	; 0xf8
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   1bff8:	f895 202e 	ldrb.w	r2, [r5, #46]	; 0x2e
   1bffc:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
   1c000:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
   1c004:	f8a4 30fa 	strh.w	r3, [r4, #250]	; 0xfa
				sys_le16_to_cpu(cpr->offset0);
   1c008:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
   1c00c:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   1c010:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset0 =
   1c014:	f8a4 30fc 	strh.w	r3, [r4, #252]	; 0xfc
				sys_le16_to_cpu(cpr->offset1);
   1c018:	f895 2032 	ldrb.w	r2, [r5, #50]	; 0x32
   1c01c:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
   1c020:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset1 =
   1c024:	f8a4 30fe 	strh.w	r3, [r4, #254]	; 0xfe
				sys_le16_to_cpu(cpr->offset2);
   1c028:	f895 2034 	ldrb.w	r2, [r5, #52]	; 0x34
   1c02c:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
   1c030:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset2 =
   1c034:	f8a4 3100 	strh.w	r3, [r4, #256]	; 0x100
				sys_le16_to_cpu(cpr->offset3);
   1c038:	f895 2036 	ldrb.w	r2, [r5, #54]	; 0x36
   1c03c:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
   1c040:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset3 =
   1c044:	f8a4 3102 	strh.w	r3, [r4, #258]	; 0x102
				sys_le16_to_cpu(cpr->offset4);
   1c048:	f895 2038 	ldrb.w	r2, [r5, #56]	; 0x38
   1c04c:	f895 3037 	ldrb.w	r3, [r5, #55]	; 0x37
   1c050:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset4 =
   1c054:	f8a4 3104 	strh.w	r3, [r4, #260]	; 0x104
				sys_le16_to_cpu(cpr->offset5);
   1c058:	f895 203a 	ldrb.w	r2, [r5, #58]	; 0x3a
   1c05c:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
   1c060:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset5 =
   1c064:	f8a4 3106 	strh.w	r3, [r4, #262]	; 0x106
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
   1c068:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
   1c06c:	2201      	movs	r2, #1
   1c06e:	f362 0302 	bfi	r3, r2, #0, #3
   1c072:	f884 30ee 	strb.w	r3, [r4, #238]	; 0xee
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1c076:	6833      	ldr	r3, [r6, #0]
   1c078:	2203      	movs	r2, #3
   1c07a:	711a      	strb	r2, [r3, #4]
		break;
   1c07c:	e455      	b.n	1b92a <ull_conn_rx+0x2e>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND,
   1c07e:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1c082:	2011      	movs	r0, #17
   1c084:	f7ff f96e 	bl	1b364 <pdu_len_cmp>
   1c088:	2800      	cmp	r0, #0
   1c08a:	f000 80eb 	beq.w	1c264 <ull_conn_rx+0x968>
	switch (rej_ext_ind->reject_opcode) {
   1c08e:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   1c092:	2b0f      	cmp	r3, #15
   1c094:	f47f ac3d 	bne.w	1b912 <ull_conn_rx+0x16>
		if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
   1c098:	f894 20ed 	ldrb.w	r2, [r4, #237]	; 0xed
   1c09c:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   1c0a0:	429a      	cmp	r2, r3
   1c0a2:	f43f ac36 	beq.w	1b912 <ull_conn_rx+0x16>
	if (!lll->role && (rej_ext_ind->error_code ==
   1c0a6:	f994 203d 	ldrsb.w	r2, [r4, #61]	; 0x3d
   1c0aa:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   1c0ae:	2a00      	cmp	r2, #0
   1c0b0:	f2c0 80f1 	blt.w	1c296 <ull_conn_rx+0x99a>
   1c0b4:	2b1a      	cmp	r3, #26
   1c0b6:	f040 80f4 	bne.w	1c2a2 <ull_conn_rx+0x9a6>
		LL_ASSERT(conn->llcp_cu.req == conn->llcp_cu.ack);
   1c0ba:	f894 20a0 	ldrb.w	r2, [r4, #160]	; 0xa0
   1c0be:	f894 30a1 	ldrb.w	r3, [r4, #161]	; 0xa1
   1c0c2:	429a      	cmp	r2, r3
   1c0c4:	d00c      	beq.n	1c0e0 <ull_conn_rx+0x7e4>
   1c0c6:	4a1d      	ldr	r2, [pc, #116]	; (1c13c <ull_conn_rx+0x840>)
   1c0c8:	491f      	ldr	r1, [pc, #124]	; (1c148 <ull_conn_rx+0x84c>)
   1c0ca:	481e      	ldr	r0, [pc, #120]	; (1c144 <ull_conn_rx+0x848>)
   1c0cc:	f241 0383 	movw	r3, #4227	; 0x1083
   1c0d0:	f007 ff07 	bl	23ee2 <printk>
   1c0d4:	4040      	eors	r0, r0
   1c0d6:	f380 8811 	msr	BASEPRI, r0
   1c0da:	f04f 0003 	mov.w	r0, #3
   1c0de:	df02      	svc	2
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   1c0e0:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
   1c0e4:	2205      	movs	r2, #5
   1c0e6:	f362 0302 	bfi	r3, r2, #0, #3
		conn->llcp_cu.win_size = 1U;
   1c0ea:	2201      	movs	r2, #1
   1c0ec:	f884 20b0 	strb.w	r2, [r4, #176]	; 0xb0
		conn->llcp_cu.win_offset_us = 0U;
   1c0f0:	2200      	movs	r2, #0
   1c0f2:	f8c4 20ac 	str.w	r2, [r4, #172]	; 0xac
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
   1c0f6:	f8b4 20f2 	ldrh.w	r2, [r4, #242]	; 0xf2
   1c0fa:	f8a4 20a4 	strh.w	r2, [r4, #164]	; 0xa4
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
   1c0fe:	f8b4 20f4 	ldrh.w	r2, [r4, #244]	; 0xf4
   1c102:	f8a4 20a6 	strh.w	r2, [r4, #166]	; 0xa6
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
   1c106:	f8b4 20f6 	ldrh.w	r2, [r4, #246]	; 0xf6
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   1c10a:	f884 30ee 	strb.w	r3, [r4, #238]	; 0xee
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
   1c10e:	f8a4 20a8 	strh.w	r2, [r4, #168]	; 0xa8
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   1c112:	f3c3 03c0 	ubfx	r3, r3, #3, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   1c116:	f894 20a2 	ldrb.w	r2, [r4, #162]	; 0xa2
   1c11a:	009b      	lsls	r3, r3, #2
   1c11c:	f043 0301 	orr.w	r3, r3, #1
   1c120:	f022 0207 	bic.w	r2, r2, #7
   1c124:	4313      	orrs	r3, r2
   1c126:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
		conn->llcp_cu.ack--;
   1c12a:	f894 30a1 	ldrb.w	r3, [r4, #161]	; 0xa1
   1c12e:	3b01      	subs	r3, #1
   1c130:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
	if (err) {
   1c134:	f7ff bbed 	b.w	1b912 <ull_conn_rx+0x16>
   1c138:	200018c8 	.word	0x200018c8
   1c13c:	00030625 	.word	0x00030625
   1c140:	0002e3c9 	.word	0x0002e3c9
   1c144:	0002a5e8 	.word	0x0002a5e8
   1c148:	00030715 	.word	0x00030715
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP,
   1c14c:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1c150:	2007      	movs	r0, #7
   1c152:	f7ff f907 	bl	1b364 <pdu_len_cmp>
   1c156:	2800      	cmp	r0, #0
   1c158:	f000 8084 	beq.w	1c264 <ull_conn_rx+0x968>
		} else if (conn->llcp_conn_param.ack !=
   1c15c:	f894 20ed 	ldrb.w	r2, [r4, #237]	; 0xed
   1c160:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   1c164:	429a      	cmp	r2, r3
   1c166:	f43f ac70 	beq.w	1ba4a <ull_conn_rx+0x14e>
			conn->llcp_conn_param.disabled = 1U;
   1c16a:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
   1c16e:	f043 0310 	orr.w	r3, r3, #16
   1c172:	f884 30ee 	strb.w	r3, [r4, #238]	; 0xee
			if (!conn->lll.role) {
   1c176:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   1c17a:	2b00      	cmp	r3, #0
   1c17c:	db40      	blt.n	1c200 <ull_conn_rx+0x904>
				LL_ASSERT(conn->llcp_cu.req ==
   1c17e:	f894 20a0 	ldrb.w	r2, [r4, #160]	; 0xa0
   1c182:	f894 30a1 	ldrb.w	r3, [r4, #161]	; 0xa1
   1c186:	429a      	cmp	r2, r3
   1c188:	d00c      	beq.n	1c1a4 <ull_conn_rx+0x8a8>
   1c18a:	4a63      	ldr	r2, [pc, #396]	; (1c318 <ull_conn_rx+0xa1c>)
   1c18c:	4963      	ldr	r1, [pc, #396]	; (1c31c <ull_conn_rx+0xa20>)
   1c18e:	4864      	ldr	r0, [pc, #400]	; (1c320 <ull_conn_rx+0xa24>)
   1c190:	f241 63d2 	movw	r3, #5842	; 0x16d2
   1c194:	f007 fea5 	bl	23ee2 <printk>
   1c198:	4040      	eors	r0, r0
   1c19a:	f380 8811 	msr	BASEPRI, r0
   1c19e:	f04f 0003 	mov.w	r0, #3
   1c1a2:	df02      	svc	2
				conn->llcp_conn_param.state =
   1c1a4:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
   1c1a8:	2205      	movs	r2, #5
   1c1aa:	f362 0302 	bfi	r3, r2, #0, #3
				conn->llcp_cu.win_size = 1U;
   1c1ae:	2201      	movs	r2, #1
   1c1b0:	f884 20b0 	strb.w	r2, [r4, #176]	; 0xb0
				conn->llcp_cu.interval =
   1c1b4:	f8b4 20f2 	ldrh.w	r2, [r4, #242]	; 0xf2
   1c1b8:	f8a4 20a4 	strh.w	r2, [r4, #164]	; 0xa4
				conn->llcp_cu.latency =
   1c1bc:	f8b4 20f4 	ldrh.w	r2, [r4, #244]	; 0xf4
   1c1c0:	f8a4 20a6 	strh.w	r2, [r4, #166]	; 0xa6
				conn->llcp_cu.timeout =
   1c1c4:	f8b4 20f6 	ldrh.w	r2, [r4, #246]	; 0xf6
				conn->llcp_conn_param.state =
   1c1c8:	f884 30ee 	strb.w	r3, [r4, #238]	; 0xee
				conn->llcp_cu.timeout =
   1c1cc:	f8a4 20a8 	strh.w	r2, [r4, #168]	; 0xa8
				conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   1c1d0:	f3c3 03c0 	ubfx	r3, r3, #3, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   1c1d4:	f894 20a2 	ldrb.w	r2, [r4, #162]	; 0xa2
   1c1d8:	009b      	lsls	r3, r3, #2
   1c1da:	f043 0301 	orr.w	r3, r3, #1
   1c1de:	f022 0207 	bic.w	r2, r2, #7
   1c1e2:	4313      	orrs	r3, r2
   1c1e4:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
				conn->llcp_cu.ack--;
   1c1e8:	f894 30a1 	ldrb.w	r3, [r4, #161]	; 0xa1
   1c1ec:	3b01      	subs	r3, #1
   1c1ee:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
				conn->llcp_cu.win_offset_us = 0U;
   1c1f2:	2000      	movs	r0, #0
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1c1f4:	6833      	ldr	r3, [r6, #0]
				conn->llcp_cu.win_offset_us = 0U;
   1c1f6:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1c1fa:	2203      	movs	r2, #3
   1c1fc:	711a      	strb	r2, [r3, #4]
				break;
   1c1fe:	e47d      	b.n	1bafc <ull_conn_rx+0x200>
			LL_ASSERT(conn_upd_curr == conn);
   1c200:	4f48      	ldr	r7, [pc, #288]	; (1c324 <ull_conn_rx+0xa28>)
   1c202:	683a      	ldr	r2, [r7, #0]
   1c204:	4294      	cmp	r4, r2
   1c206:	d00c      	beq.n	1c222 <ull_conn_rx+0x926>
   1c208:	4a43      	ldr	r2, [pc, #268]	; (1c318 <ull_conn_rx+0xa1c>)
   1c20a:	4947      	ldr	r1, [pc, #284]	; (1c328 <ull_conn_rx+0xa2c>)
   1c20c:	4844      	ldr	r0, [pc, #272]	; (1c320 <ull_conn_rx+0xa24>)
   1c20e:	f241 63ea 	movw	r3, #5866	; 0x16ea
   1c212:	f007 fe66 	bl	23ee2 <printk>
   1c216:	4040      	eors	r0, r0
   1c218:	f380 8811 	msr	BASEPRI, r0
   1c21c:	f04f 0003 	mov.w	r0, #3
   1c220:	df02      	svc	2
			conn_upd_curr = NULL;
   1c222:	2300      	movs	r3, #0
			if (!conn->llcp_conn_param.cmd) {
   1c224:	f894 00ee 	ldrb.w	r0, [r4, #238]	; 0xee
			conn_upd_curr = NULL;
   1c228:	603b      	str	r3, [r7, #0]
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1c22a:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   1c22e:	f884 30ed 	strb.w	r3, [r4, #237]	; 0xed
			if (!conn->llcp_conn_param.cmd) {
   1c232:	f010 0008 	ands.w	r0, r0, #8
   1c236:	6833      	ldr	r3, [r6, #0]
   1c238:	d0df      	beq.n	1c1fa <ull_conn_rx+0x8fe>
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   1c23a:	220a      	movs	r2, #10
   1c23c:	711a      	strb	r2, [r3, #4]
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   1c23e:	231a      	movs	r3, #26
   1c240:	f885 3020 	strb.w	r3, [r5, #32]
			cu->latency = lll->latency;
   1c244:	8e22      	ldrh	r2, [r4, #48]	; 0x30
			cu->interval = lll->interval;
   1c246:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
			cu->latency = lll->latency;
   1c248:	84aa      	strh	r2, [r5, #36]	; 0x24
			cu->timeout = conn->supervision_reload *
   1c24a:	f8b4 2076 	ldrh.w	r2, [r4, #118]	; 0x76
			cu->interval = lll->interval;
   1c24e:	846b      	strh	r3, [r5, #34]	; 0x22
			cu->timeout = conn->supervision_reload *
   1c250:	435a      	muls	r2, r3
				      lll->interval * 125U / 1000;
   1c252:	237d      	movs	r3, #125	; 0x7d
   1c254:	4353      	muls	r3, r2
   1c256:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1c25a:	fbb3 f3f2 	udiv	r3, r3, r2
			cu->timeout = conn->supervision_reload *
   1c25e:	84eb      	strh	r3, [r5, #38]	; 0x26
   1c260:	f7ff bbf3 	b.w	1ba4a <ull_conn_rx+0x14e>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   1c264:	4831      	ldr	r0, [pc, #196]	; (1c32c <ull_conn_rx+0xa30>)
   1c266:	f00b ff0d 	bl	28084 <mem_acquire>
	if (!tx) {
   1c26a:	4601      	mov	r1, r0
   1c26c:	2800      	cmp	r0, #0
   1c26e:	f43f ac43 	beq.w	1baf8 <ull_conn_rx+0x1fc>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   1c272:	7903      	ldrb	r3, [r0, #4]
	pdu->llctrl.unknown_rsp.type = type;
   1c274:	f880 8008 	strb.w	r8, [r0, #8]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   1c278:	f043 0303 	orr.w	r3, r3, #3
   1c27c:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
   1c27e:	2302      	movs	r3, #2
   1c280:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
   1c282:	2307      	movs	r3, #7
   1c284:	71c3      	strb	r3, [r0, #7]
	ctrl_tx_enqueue(conn, tx);
   1c286:	4620      	mov	r0, r4
   1c288:	f00c f979 	bl	2857e <ctrl_tx_enqueue>
   1c28c:	f7ff bb41 	b.w	1b912 <ull_conn_rx+0x16>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1c290:	2303      	movs	r3, #3
   1c292:	712b      	strb	r3, [r5, #4]
		break;
   1c294:	e432      	b.n	1bafc <ull_conn_rx+0x200>
	else if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   1c296:	2b23      	cmp	r3, #35	; 0x23
   1c298:	d003      	beq.n	1c2a2 <ull_conn_rx+0x9a6>
			conn->slave.ticks_to_offset =
   1c29a:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
   1c29e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
	if (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) {
   1c2a2:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
   1c2a6:	f003 0307 	and.w	r3, r3, #7
   1c2aa:	2b04      	cmp	r3, #4
   1c2ac:	d118      	bne.n	1c2e0 <ull_conn_rx+0x9e4>
		LL_ASSERT(conn_upd_curr == conn);
   1c2ae:	4e1d      	ldr	r6, [pc, #116]	; (1c324 <ull_conn_rx+0xa28>)
   1c2b0:	6832      	ldr	r2, [r6, #0]
   1c2b2:	4294      	cmp	r4, r2
   1c2b4:	d00c      	beq.n	1c2d0 <ull_conn_rx+0x9d4>
   1c2b6:	4a18      	ldr	r2, [pc, #96]	; (1c318 <ull_conn_rx+0xa1c>)
   1c2b8:	491b      	ldr	r1, [pc, #108]	; (1c328 <ull_conn_rx+0xa2c>)
   1c2ba:	4819      	ldr	r0, [pc, #100]	; (1c320 <ull_conn_rx+0xa24>)
   1c2bc:	f241 039e 	movw	r3, #4254	; 0x109e
   1c2c0:	f007 fe0f 	bl	23ee2 <printk>
   1c2c4:	4040      	eors	r0, r0
   1c2c6:	f380 8811 	msr	BASEPRI, r0
   1c2ca:	f04f 0003 	mov.w	r0, #3
   1c2ce:	df02      	svc	2
		conn_upd_curr = NULL;
   1c2d0:	2300      	movs	r3, #0
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1c2d2:	f894 20ec 	ldrb.w	r2, [r4, #236]	; 0xec
		conn_upd_curr = NULL;
   1c2d6:	6033      	str	r3, [r6, #0]
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1c2d8:	f884 20ed 	strb.w	r2, [r4, #237]	; 0xed
		conn->procedure_expire = 0U;
   1c2dc:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
	if (!conn->llcp_conn_param.cmd) {
   1c2e0:	f894 30ee 	ldrb.w	r3, [r4, #238]	; 0xee
   1c2e4:	071b      	lsls	r3, r3, #28
   1c2e6:	f57f ab14 	bpl.w	1b912 <ull_conn_rx+0x16>
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   1c2ea:	230a      	movs	r3, #10
   1c2ec:	712b      	strb	r3, [r5, #4]
	cu->status = rej_ext_ind->error_code;
   1c2ee:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   1c2f2:	f885 3020 	strb.w	r3, [r5, #32]
	cu->latency = lll->latency;
   1c2f6:	8e22      	ldrh	r2, [r4, #48]	; 0x30
	cu->interval = lll->interval;
   1c2f8:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
	cu->latency = lll->latency;
   1c2fa:	84aa      	strh	r2, [r5, #36]	; 0x24
	cu->timeout = conn->supervision_reload *
   1c2fc:	f8b4 2076 	ldrh.w	r2, [r4, #118]	; 0x76
	cu->interval = lll->interval;
   1c300:	846b      	strh	r3, [r5, #34]	; 0x22
	cu->timeout = conn->supervision_reload *
   1c302:	435a      	muls	r2, r3
		      lll->interval * 125U / 1000;
   1c304:	237d      	movs	r3, #125	; 0x7d
   1c306:	4353      	muls	r3, r2
   1c308:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1c30c:	fbb3 f3f2 	udiv	r3, r3, r2
	cu->timeout = conn->supervision_reload *
   1c310:	84eb      	strh	r3, [r5, #38]	; 0x26
	if (err) {
   1c312:	f7ff bb0a 	b.w	1b92a <ull_conn_rx+0x2e>
   1c316:	bf00      	nop
   1c318:	00030625 	.word	0x00030625
   1c31c:	00030715 	.word	0x00030715
   1c320:	0002a5e8 	.word	0x0002a5e8
   1c324:	200018c8 	.word	0x200018c8
   1c328:	0003073c 	.word	0x0003073c
   1c32c:	20001944 	.word	0x20001944

0001c330 <ull_conn_tx_demux>:
{
   1c330:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   1c334:	4e20      	ldr	r6, [pc, #128]	; (1c3b8 <ull_conn_tx_demux+0x88>)
{
   1c336:	4604      	mov	r4, r0
   1c338:	4637      	mov	r7, r6
	return (void *)(fifo + first * size);
   1c33a:	1d35      	adds	r5, r6, #4
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   1c33c:	78b3      	ldrb	r3, [r6, #2]
	if (first == last) {
   1c33e:	78f1      	ldrb	r1, [r6, #3]
   1c340:	7832      	ldrb	r2, [r6, #0]
   1c342:	4299      	cmp	r1, r3
   1c344:	d02d      	beq.n	1c3a2 <ull_conn_tx_demux+0x72>
	return (void *)(fifo + first * size);
   1c346:	fb13 f302 	smulbb	r3, r3, r2
		if (!lll_tx) {
   1c34a:	eb15 0803 	adds.w	r8, r5, r3
   1c34e:	d028      	beq.n	1c3a2 <ull_conn_tx_demux+0x72>
		conn = ll_connected_get(lll_tx->handle);
   1c350:	5ae8      	ldrh	r0, [r5, r3]
   1c352:	f00c f939 	bl	285c8 <ll_connected_get>
		if (conn) {
   1c356:	f8d8 1004 	ldr.w	r1, [r8, #4]
   1c35a:	b320      	cbz	r0, 1c3a6 <ull_conn_tx_demux+0x76>
			tx->next = NULL;
   1c35c:	2300      	movs	r3, #0
   1c35e:	600b      	str	r3, [r1, #0]
			if (!conn->tx_data) {
   1c360:	f8d0 3120 	ldr.w	r3, [r0, #288]	; 0x120
   1c364:	b943      	cbnz	r3, 1c378 <ull_conn_tx_demux+0x48>
				if (!conn->tx_head) {
   1c366:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
				conn->tx_data = tx;
   1c36a:	f8c0 1120 	str.w	r1, [r0, #288]	; 0x120
				if (!conn->tx_head) {
   1c36e:	b91b      	cbnz	r3, 1c378 <ull_conn_tx_demux+0x48>
					conn->tx_head = tx;
   1c370:	f8c0 1114 	str.w	r1, [r0, #276]	; 0x114
					conn->tx_data_last = NULL;
   1c374:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
			if (conn->tx_data_last) {
   1c378:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
   1c37c:	b103      	cbz	r3, 1c380 <ull_conn_tx_demux+0x50>
				conn->tx_data_last->next = tx;
   1c37e:	6019      	str	r1, [r3, #0]
			conn->tx_data_last = tx;
   1c380:	f8c0 1124 	str.w	r1, [r0, #292]	; 0x124
	u8_t _first = *first; /* Copy read-index */
   1c384:	78bb      	ldrb	r3, [r7, #2]
	if (_first == last) {
   1c386:	78f9      	ldrb	r1, [r7, #3]
		MFIFO_DEQUEUE(conn_tx);
   1c388:	787a      	ldrb	r2, [r7, #1]
   1c38a:	4299      	cmp	r1, r3
   1c38c:	d005      	beq.n	1c39a <ull_conn_tx_demux+0x6a>
	_first += 1U;
   1c38e:	3301      	adds	r3, #1
   1c390:	b2db      	uxtb	r3, r3
		_first = 0U;
   1c392:	429a      	cmp	r2, r3
   1c394:	bf08      	it	eq
   1c396:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1c398:	70bb      	strb	r3, [r7, #2]
	} while (--count);
   1c39a:	3c01      	subs	r4, #1
   1c39c:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   1c3a0:	d1cc      	bne.n	1c33c <ull_conn_tx_demux+0xc>
}
   1c3a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			p->ll_id = PDU_DATA_LLID_RESV;
   1c3a6:	790b      	ldrb	r3, [r1, #4]
   1c3a8:	f360 0301 	bfi	r3, r0, #0, #2
   1c3ac:	710b      	strb	r3, [r1, #4]
			ll_tx_ack_put(0xFFFF, tx);
   1c3ae:	f64f 70ff 	movw	r0, #65535	; 0xffff
   1c3b2:	f7fe f8e3 	bl	1a57c <ll_tx_ack_put>
   1c3b6:	e7e5      	b.n	1c384 <ull_conn_tx_demux+0x54>
   1c3b8:	20007310 	.word	0x20007310

0001c3bc <conn_cleanup>:
	rx->hdr.handle = conn->lll.handle;
   1c3bc:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
{
   1c3be:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	rx->hdr.handle = conn->lll.handle;
   1c3c2:	f8a0 30ce 	strh.w	r3, [r0, #206]	; 0xce
	*((u8_t *)rx->pdu) = reason;
   1c3c6:	f880 10e8 	strb.w	r1, [r0, #232]	; 0xe8
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   1c3ca:	2309      	movs	r3, #9
	rx = conn->llcp_rx;
   1c3cc:	f8d0 109c 	ldr.w	r1, [r0, #156]	; 0x9c
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   1c3d0:	f880 30cc 	strb.w	r3, [r0, #204]	; 0xcc
{
   1c3d4:	4604      	mov	r4, r0
	struct lll_conn *lll = &conn->lll;
   1c3d6:	f100 061c 	add.w	r6, r0, #28
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1c3da:	2503      	movs	r5, #3
	while (rx) {
   1c3dc:	bb49      	cbnz	r1, 1c432 <conn_cleanup+0x76>
		link = mem_acquire(&mem_link_tx.free);
   1c3de:	4f27      	ldr	r7, [pc, #156]	; (1c47c <conn_cleanup+0xc0>)
		LL_ASSERT(link);
   1c3e0:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 1c484 <conn_cleanup+0xc8>
   1c3e4:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 1c490 <conn_cleanup+0xd4>
	while (conn->tx_head) {
   1c3e8:	f8d4 0114 	ldr.w	r0, [r4, #276]	; 0x114
   1c3ec:	bb40      	cbnz	r0, 1c440 <conn_cleanup+0x84>
				    TICKER_ID_CONN_BASE + lll->handle,
   1c3ee:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   1c3f2:	4b23      	ldr	r3, [pc, #140]	; (1c480 <conn_cleanup+0xc4>)
   1c3f4:	9600      	str	r6, [sp, #0]
				    TICKER_ID_CONN_BASE + lll->handle,
   1c3f6:	3205      	adds	r2, #5
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   1c3f8:	b2d2      	uxtb	r2, r2
   1c3fa:	2101      	movs	r1, #1
   1c3fc:	f7fc fcc0 	bl	18d80 <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   1c400:	f030 0302 	bics.w	r3, r0, #2
   1c404:	d00c      	beq.n	1c420 <conn_cleanup+0x64>
   1c406:	4a1f      	ldr	r2, [pc, #124]	; (1c484 <conn_cleanup+0xc8>)
   1c408:	491f      	ldr	r1, [pc, #124]	; (1c488 <conn_cleanup+0xcc>)
   1c40a:	4820      	ldr	r0, [pc, #128]	; (1c48c <conn_cleanup+0xd0>)
   1c40c:	f240 63d3 	movw	r3, #1747	; 0x6d3
   1c410:	f007 fd67 	bl	23ee2 <printk>
   1c414:	4040      	eors	r0, r0
   1c416:	f380 8811 	msr	BASEPRI, r0
   1c41a:	f04f 0003 	mov.w	r0, #3
   1c41e:	df02      	svc	2
	lll->handle = 0xFFFF;
   1c420:	f64f 73ff 	movw	r3, #65535	; 0xffff
	ull_conn_tx_demux(UINT8_MAX);
   1c424:	20ff      	movs	r0, #255	; 0xff
	lll->handle = 0xFFFF;
   1c426:	85a3      	strh	r3, [r4, #44]	; 0x2c
}
   1c428:	b002      	add	sp, #8
   1c42a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	ull_conn_tx_demux(UINT8_MAX);
   1c42e:	f7ff bf7f 	b.w	1c330 <ull_conn_tx_demux>
		rx = hdr->link->mem;
   1c432:	6808      	ldr	r0, [r1, #0]
   1c434:	6847      	ldr	r7, [r0, #4]
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
   1c436:	710d      	strb	r5, [r1, #4]
		ll_rx_put(hdr->link, hdr);
   1c438:	f7fe f862 	bl	1a500 <ll_rx_put>
		rx = hdr->link->mem;
   1c43c:	4639      	mov	r1, r7
   1c43e:	e7cd      	b.n	1c3dc <conn_cleanup+0x20>
		tx = tx_ull_dequeue(conn, conn->tx_head);
   1c440:	4601      	mov	r1, r0
   1c442:	4620      	mov	r0, r4
   1c444:	f00c f868 	bl	28518 <tx_ull_dequeue>
   1c448:	4682      	mov	sl, r0
		link = mem_acquire(&mem_link_tx.free);
   1c44a:	4638      	mov	r0, r7
   1c44c:	f00b fe1a 	bl	28084 <mem_acquire>
		LL_ASSERT(link);
   1c450:	4605      	mov	r5, r0
   1c452:	b960      	cbnz	r0, 1c46e <conn_cleanup+0xb2>
   1c454:	480d      	ldr	r0, [pc, #52]	; (1c48c <conn_cleanup+0xd0>)
   1c456:	f240 63e6 	movw	r3, #1766	; 0x6e6
   1c45a:	4642      	mov	r2, r8
   1c45c:	4649      	mov	r1, r9
   1c45e:	f007 fd40 	bl	23ee2 <printk>
   1c462:	4040      	eors	r0, r0
   1c464:	f380 8811 	msr	BASEPRI, r0
   1c468:	f04f 0003 	mov.w	r0, #3
   1c46c:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   1c46e:	f104 0260 	add.w	r2, r4, #96	; 0x60
   1c472:	4651      	mov	r1, sl
   1c474:	4628      	mov	r0, r5
   1c476:	f00b fe63 	bl	28140 <memq_enqueue>
   1c47a:	e7b5      	b.n	1c3e8 <conn_cleanup+0x2c>
   1c47c:	200019c8 	.word	0x200019c8
   1c480:	0001b519 	.word	0x0001b519
   1c484:	00030625 	.word	0x00030625
   1c488:	000306db 	.word	0x000306db
   1c48c:	0002a5e8 	.word	0x0002a5e8
   1c490:	0002fa18 	.word	0x0002fa18

0001c494 <ull_conn_done>:
{
   1c494:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct lll_conn *lll = (void *)HDR_ULL2LLL(done->param);
   1c498:	6a05      	ldr	r5, [r0, #32]
	if (lll->handle == 0xFFFF) {
   1c49a:	8baa      	ldrh	r2, [r5, #28]
   1c49c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1c4a0:	429a      	cmp	r2, r3
{
   1c4a2:	b08b      	sub	sp, #44	; 0x2c
   1c4a4:	4681      	mov	r9, r0
	if (lll->handle == 0xFFFF) {
   1c4a6:	d007      	beq.n	1c4b8 <ull_conn_done+0x24>
	struct ll_conn *conn = (void *)HDR_LLL2EVT(lll);
   1c4a8:	68ec      	ldr	r4, [r5, #12]
	reason_peer = conn->llcp_terminate.reason_peer;
   1c4aa:	f894 60c7 	ldrb.w	r6, [r4, #199]	; 0xc7
	if (reason_peer && (
   1c4ae:	b136      	cbz	r6, 1c4be <ull_conn_done+0x2a>
		conn_cleanup(conn, reason_peer);
   1c4b0:	4631      	mov	r1, r6
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   1c4b2:	4620      	mov	r0, r4
   1c4b4:	f7ff ff82 	bl	1c3bc <conn_cleanup>
}
   1c4b8:	b00b      	add	sp, #44	; 0x2c
   1c4ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	latency_event = lll->latency_event;
   1c4be:	f8b5 8024 	ldrh.w	r8, [r5, #36]	; 0x24
	if (done->extra.trx_cnt) {
   1c4c2:	8d03      	ldrh	r3, [r0, #40]	; 0x28
	elapsed_event = latency_event + 1;
   1c4c4:	f108 0701 	add.w	r7, r8, #1
	ticks_drift_minus = 0U;
   1c4c8:	e9cd 6608 	strd	r6, r6, [sp, #32]
	elapsed_event = latency_event + 1;
   1c4cc:	b2bf      	uxth	r7, r7
	if (done->extra.trx_cnt) {
   1c4ce:	b17b      	cbz	r3, 1c4f0 <ull_conn_done+0x5c>
		} else if (lll->role) {
   1c4d0:	f995 302d 	ldrsb.w	r3, [r5, #45]	; 0x2d
   1c4d4:	2b00      	cmp	r3, #0
   1c4d6:	da08      	bge.n	1c4ea <ull_conn_done+0x56>
			ull_slave_done(done, &ticks_drift_plus,
   1c4d8:	aa08      	add	r2, sp, #32
   1c4da:	a909      	add	r1, sp, #36	; 0x24
   1c4dc:	f7e5 f8b8 	bl	1650 <ull_slave_done>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   1c4e0:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
   1c4e4:	b15b      	cbz	r3, 1c4fe <ull_conn_done+0x6a>
				lll->latency_event = 0;
   1c4e6:	2300      	movs	r3, #0
				lll->latency_event = lll->latency;
   1c4e8:	84ab      	strh	r3, [r5, #36]	; 0x24
		conn->connect_expire = 0U;
   1c4ea:	2300      	movs	r3, #0
   1c4ec:	f8a4 3074 	strh.w	r3, [r4, #116]	; 0x74
	if (done->extra.crc_valid) {
   1c4f0:	f899 302a 	ldrb.w	r3, [r9, #42]	; 0x2a
   1c4f4:	b183      	cbz	r3, 1c518 <ull_conn_done+0x84>
		conn->supervision_expire = 0U;
   1c4f6:	2300      	movs	r3, #0
			conn->supervision_expire = conn->supervision_reload;
   1c4f8:	f8a4 3078 	strh.w	r3, [r4, #120]	; 0x78
   1c4fc:	e015      	b.n	1c52a <ull_conn_done+0x96>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   1c4fe:	e9d5 0113 	ldrd	r0, r1, [r5, #76]	; 0x4c
   1c502:	4632      	mov	r2, r6
   1c504:	f00b fe23 	bl	2814e <memq_peek>
   1c508:	2800      	cmp	r0, #0
   1c50a:	d1ec      	bne.n	1c4e6 <ull_conn_done+0x52>
			} else if (lll->slave.latency_enabled) {
   1c50c:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   1c510:	07db      	lsls	r3, r3, #31
   1c512:	d5ea      	bpl.n	1c4ea <ull_conn_done+0x56>
				lll->latency_event = lll->latency;
   1c514:	8c2b      	ldrh	r3, [r5, #32]
   1c516:	e7e7      	b.n	1c4e8 <ull_conn_done+0x54>
	else if (conn->connect_expire) {
   1c518:	f8b4 3074 	ldrh.w	r3, [r4, #116]	; 0x74
   1c51c:	2b00      	cmp	r3, #0
   1c51e:	d075      	beq.n	1c60c <ull_conn_done+0x178>
		if (conn->connect_expire > elapsed_event) {
   1c520:	42bb      	cmp	r3, r7
   1c522:	d971      	bls.n	1c608 <ull_conn_done+0x174>
			conn->connect_expire -= elapsed_event;
   1c524:	1bdb      	subs	r3, r3, r7
   1c526:	f8a4 3074 	strh.w	r3, [r4, #116]	; 0x74
	if (conn->supervision_expire) {
   1c52a:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
   1c52e:	b1eb      	cbz	r3, 1c56c <ull_conn_done+0xd8>
		if (conn->supervision_expire > elapsed_event) {
   1c530:	42bb      	cmp	r3, r7
   1c532:	d972      	bls.n	1c61a <ull_conn_done+0x186>
			conn->supervision_expire -= elapsed_event;
   1c534:	1bdb      	subs	r3, r3, r7
   1c536:	b29b      	uxth	r3, r3
			lll->latency_event = 0;
   1c538:	2200      	movs	r2, #0
			if (conn->supervision_expire <= 6U) {
   1c53a:	2b06      	cmp	r3, #6
			conn->supervision_expire -= elapsed_event;
   1c53c:	f8a4 3078 	strh.w	r3, [r4, #120]	; 0x78
			lll->latency_event = 0;
   1c540:	84aa      	strh	r2, [r5, #36]	; 0x24
			if (conn->supervision_expire <= 6U) {
   1c542:	d96c      	bls.n	1c61e <ull_conn_done+0x18a>
			else if (lll->role) {
   1c544:	f995 302d 	ldrsb.w	r3, [r5, #45]	; 0x2d
   1c548:	4293      	cmp	r3, r2
   1c54a:	da0f      	bge.n	1c56c <ull_conn_done+0xd8>
				if (latency_event) {
   1c54c:	f1b8 0f00 	cmp.w	r8, #0
   1c550:	d165      	bne.n	1c61e <ull_conn_done+0x18a>
					force = conn->slave.force & 0x01;
   1c552:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
					conn->slave.force >>= 1;
   1c556:	085a      	lsrs	r2, r3, #1
					if (force) {
   1c558:	f013 0301 	ands.w	r3, r3, #1
						conn->slave.force |= BIT(31);
   1c55c:	bf17      	itett	ne
   1c55e:	f042 4200 	orrne.w	r2, r2, #2147483648	; 0x80000000
					conn->slave.force >>= 1;
   1c562:	f8c4 2084 	streq.w	r2, [r4, #132]	; 0x84
						conn->slave.force |= BIT(31);
   1c566:	f8c4 2084 	strne.w	r2, [r4, #132]	; 0x84
					force = conn->slave.force & 0x01;
   1c56a:	461e      	movne	r6, r3
	if (conn->procedure_expire != 0U) {
   1c56c:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
   1c570:	b123      	cbz	r3, 1c57c <ull_conn_done+0xe8>
		if (conn->procedure_expire > elapsed_event) {
   1c572:	42bb      	cmp	r3, r7
   1c574:	d955      	bls.n	1c622 <ull_conn_done+0x18e>
			conn->procedure_expire -= elapsed_event;
   1c576:	1bdf      	subs	r7, r3, r7
   1c578:	f8a4 707c 	strh.w	r7, [r4, #124]	; 0x7c
	if ((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   1c57c:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
   1c580:	f894 208d 	ldrb.w	r2, [r4, #141]	; 0x8d
   1c584:	1a9b      	subs	r3, r3, r2
   1c586:	f003 0303 	and.w	r3, r3, #3
   1c58a:	2b02      	cmp	r3, #2
   1c58c:	d106      	bne.n	1c59c <ull_conn_done+0x108>
	    ((conn->llcp_type == LLCP_CONN_UPD) ||
   1c58e:	f894 308e 	ldrb.w	r3, [r4, #142]	; 0x8e
	if ((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   1c592:	3b01      	subs	r3, #1
   1c594:	2b01      	cmp	r3, #1
		lll->latency_event = 0;
   1c596:	bf9c      	itt	ls
   1c598:	2300      	movls	r3, #0
   1c59a:	84ab      	strhls	r3, [r5, #36]	; 0x24
	if ((force) || (latency_event != lll->latency_event)) {
   1c59c:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   1c59e:	b90e      	cbnz	r6, 1c5a4 <ull_conn_done+0x110>
   1c5a0:	4588      	cmp	r8, r1
   1c5a2:	d040      	beq.n	1c626 <ull_conn_done+0x192>
		lazy = lll->latency_event + 1;
   1c5a4:	3101      	adds	r1, #1
   1c5a6:	b289      	uxth	r1, r1
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
   1c5a8:	e9dd 7308 	ldrd	r7, r3, [sp, #32]
   1c5ac:	ea53 0207 	orrs.w	r2, r3, r7
   1c5b0:	d103      	bne.n	1c5ba <ull_conn_done+0x126>
   1c5b2:	b911      	cbnz	r1, 1c5ba <ull_conn_done+0x126>
	    (lazy != 0U) || (force != 0U)) {
   1c5b4:	2e00      	cmp	r6, #0
   1c5b6:	f43f af7f 	beq.w	1c4b8 <ull_conn_done+0x24>
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   1c5ba:	7f2a      	ldrb	r2, [r5, #28]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1c5bc:	481b      	ldr	r0, [pc, #108]	; (1c62c <ull_conn_done+0x198>)
		struct ll_conn *conn = lll->hdr.parent;
   1c5be:	68ec      	ldr	r4, [r5, #12]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1c5c0:	9406      	str	r4, [sp, #24]
   1c5c2:	e9cd 6004 	strd	r6, r0, [sp, #16]
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   1c5c6:	3205      	adds	r2, #5
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1c5c8:	2000      	movs	r0, #0
   1c5ca:	9103      	str	r1, [sp, #12]
   1c5cc:	e9cd 0001 	strd	r0, r0, [sp, #4]
   1c5d0:	9700      	str	r7, [sp, #0]
   1c5d2:	b2d2      	uxtb	r2, r2
   1c5d4:	2101      	movs	r1, #1
   1c5d6:	f7fc fb8d 	bl	18cf4 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   1c5da:	f030 0302 	bics.w	r3, r0, #2
   1c5de:	f43f af6b 	beq.w	1c4b8 <ull_conn_done+0x24>
   1c5e2:	f7fe f83f 	bl	1a664 <ull_disable_mark_get>
   1c5e6:	4284      	cmp	r4, r0
   1c5e8:	f43f af66 	beq.w	1c4b8 <ull_conn_done+0x24>
   1c5ec:	4a10      	ldr	r2, [pc, #64]	; (1c630 <ull_conn_done+0x19c>)
   1c5ee:	4911      	ldr	r1, [pc, #68]	; (1c634 <ull_conn_done+0x1a0>)
   1c5f0:	4811      	ldr	r0, [pc, #68]	; (1c638 <ull_conn_done+0x1a4>)
   1c5f2:	f240 43ea 	movw	r3, #1258	; 0x4ea
   1c5f6:	f007 fc74 	bl	23ee2 <printk>
   1c5fa:	4040      	eors	r0, r0
   1c5fc:	f380 8811 	msr	BASEPRI, r0
   1c600:	f04f 0003 	mov.w	r0, #3
   1c604:	df02      	svc	2
   1c606:	e757      	b.n	1c4b8 <ull_conn_done+0x24>
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   1c608:	213e      	movs	r1, #62	; 0x3e
   1c60a:	e752      	b.n	1c4b2 <ull_conn_done+0x1e>
		if (!conn->supervision_expire) {
   1c60c:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
   1c610:	2b00      	cmp	r3, #0
   1c612:	d18a      	bne.n	1c52a <ull_conn_done+0x96>
			conn->supervision_expire = conn->supervision_reload;
   1c614:	f8b4 3076 	ldrh.w	r3, [r4, #118]	; 0x76
   1c618:	e76e      	b.n	1c4f8 <ull_conn_done+0x64>
			conn_cleanup(conn, BT_HCI_ERR_CONN_TIMEOUT);
   1c61a:	2108      	movs	r1, #8
   1c61c:	e749      	b.n	1c4b2 <ull_conn_done+0x1e>
				force = 1U;
   1c61e:	2601      	movs	r6, #1
   1c620:	e7a4      	b.n	1c56c <ull_conn_done+0xd8>
			conn_cleanup(conn, BT_HCI_ERR_LL_RESP_TIMEOUT);
   1c622:	2122      	movs	r1, #34	; 0x22
   1c624:	e745      	b.n	1c4b2 <ull_conn_done+0x1e>
	lazy = 0U;
   1c626:	4631      	mov	r1, r6
   1c628:	e7be      	b.n	1c5a8 <ull_conn_done+0x114>
   1c62a:	bf00      	nop
   1c62c:	0001b4d9 	.word	0x0001b4d9
   1c630:	00030625 	.word	0x00030625
   1c634:	00030780 	.word	0x00030780
   1c638:	0002a5e8 	.word	0x0002a5e8

0001c63c <ull_conn_tx_lll_enqueue>:
{
   1c63c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		link = mem_acquire(&mem_link_tx.free);
   1c640:	f8df 805c 	ldr.w	r8, [pc, #92]	; 1c6a0 <ull_conn_tx_lll_enqueue+0x64>
		LL_ASSERT(link);
   1c644:	f8df 905c 	ldr.w	r9, [pc, #92]	; 1c6a4 <ull_conn_tx_lll_enqueue+0x68>
   1c648:	f8df a05c 	ldr.w	sl, [pc, #92]	; 1c6a8 <ull_conn_tx_lll_enqueue+0x6c>
{
   1c64c:	4605      	mov	r5, r0
   1c64e:	460c      	mov	r4, r1
	while (conn->tx_head &&
   1c650:	f8d5 1114 	ldr.w	r1, [r5, #276]	; 0x114
   1c654:	b101      	cbz	r1, 1c658 <ull_conn_tx_lll_enqueue+0x1c>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   1c656:	b90c      	cbnz	r4, 1c65c <ull_conn_tx_lll_enqueue+0x20>
}
   1c658:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		tx = tx_ull_dequeue(conn, conn->tx_head);
   1c65c:	4628      	mov	r0, r5
   1c65e:	f00b ff5b 	bl	28518 <tx_ull_dequeue>
   1c662:	4607      	mov	r7, r0
		link = mem_acquire(&mem_link_tx.free);
   1c664:	4640      	mov	r0, r8
   1c666:	f00b fd0d 	bl	28084 <mem_acquire>
		LL_ASSERT(link);
   1c66a:	4606      	mov	r6, r0
   1c66c:	b960      	cbnz	r0, 1c688 <ull_conn_tx_lll_enqueue+0x4c>
   1c66e:	480b      	ldr	r0, [pc, #44]	; (1c69c <ull_conn_tx_lll_enqueue+0x60>)
   1c670:	f240 5366 	movw	r3, #1382	; 0x566
   1c674:	464a      	mov	r2, r9
   1c676:	4651      	mov	r1, sl
   1c678:	f007 fc33 	bl	23ee2 <printk>
   1c67c:	4040      	eors	r0, r0
   1c67e:	f380 8811 	msr	BASEPRI, r0
   1c682:	f04f 0003 	mov.w	r0, #3
   1c686:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   1c688:	f105 0260 	add.w	r2, r5, #96	; 0x60
   1c68c:	4639      	mov	r1, r7
   1c68e:	4630      	mov	r0, r6
   1c690:	3c01      	subs	r4, #1
   1c692:	f00b fd55 	bl	28140 <memq_enqueue>
   1c696:	b2e4      	uxtb	r4, r4
   1c698:	e7da      	b.n	1c650 <ull_conn_tx_lll_enqueue+0x14>
   1c69a:	bf00      	nop
   1c69c:	0002a5e8 	.word	0x0002a5e8
   1c6a0:	200019c8 	.word	0x200019c8
   1c6a4:	00030625 	.word	0x00030625
   1c6a8:	0002fa18 	.word	0x0002fa18

0001c6ac <ull_conn_link_tx_release>:
	mem_release(link, &mem_link_tx.free);
   1c6ac:	4901      	ldr	r1, [pc, #4]	; (1c6b4 <ull_conn_link_tx_release+0x8>)
   1c6ae:	f00b bd02 	b.w	280b6 <mem_release>
   1c6b2:	bf00      	nop
   1c6b4:	200019c8 	.word	0x200019c8

0001c6b8 <ull_conn_ack_last_idx_get>:
}
   1c6b8:	4b01      	ldr	r3, [pc, #4]	; (1c6c0 <ull_conn_ack_last_idx_get+0x8>)
   1c6ba:	78d8      	ldrb	r0, [r3, #3]
   1c6bc:	4770      	bx	lr
   1c6be:	bf00      	nop
   1c6c0:	200072cc 	.word	0x200072cc

0001c6c4 <ull_conn_ack_peek>:
{
   1c6c4:	b570      	push	{r4, r5, r6, lr}
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   1c6c6:	4b0a      	ldr	r3, [pc, #40]	; (1c6f0 <ull_conn_ack_peek+0x2c>)
   1c6c8:	789c      	ldrb	r4, [r3, #2]
   1c6ca:	78de      	ldrb	r6, [r3, #3]
	if (first == last) {
   1c6cc:	42b4      	cmp	r4, r6
{
   1c6ce:	4605      	mov	r5, r0
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   1c6d0:	7818      	ldrb	r0, [r3, #0]
   1c6d2:	d00b      	beq.n	1c6ec <ull_conn_ack_peek+0x28>
	return (void *)(fifo + first * size);
   1c6d4:	3304      	adds	r3, #4
   1c6d6:	fb14 f400 	smulbb	r4, r4, r0
	if (!lll_tx) {
   1c6da:	1918      	adds	r0, r3, r4
   1c6dc:	d005      	beq.n	1c6ea <ull_conn_ack_peek+0x26>
	*ack_last = mfifo_conn_ack.l;
   1c6de:	702e      	strb	r6, [r5, #0]
	*handle = lll_tx->handle;
   1c6e0:	5b1b      	ldrh	r3, [r3, r4]
   1c6e2:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   1c6e4:	6843      	ldr	r3, [r0, #4]
   1c6e6:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   1c6e8:	6818      	ldr	r0, [r3, #0]
}
   1c6ea:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
   1c6ec:	2000      	movs	r0, #0
   1c6ee:	e7fc      	b.n	1c6ea <ull_conn_ack_peek+0x26>
   1c6f0:	200072cc 	.word	0x200072cc

0001c6f4 <ull_conn_ack_by_last_peek>:
{
   1c6f4:	b530      	push	{r4, r5, lr}
	lll_tx = mfifo_dequeue_get(mfifo_conn_ack.m, mfifo_conn_ack.s,
   1c6f6:	4b09      	ldr	r3, [pc, #36]	; (1c71c <ull_conn_ack_by_last_peek+0x28>)
   1c6f8:	789c      	ldrb	r4, [r3, #2]
   1c6fa:	781d      	ldrb	r5, [r3, #0]
	if (first == last) {
   1c6fc:	4284      	cmp	r4, r0
   1c6fe:	d00a      	beq.n	1c716 <ull_conn_ack_by_last_peek+0x22>
	return (void *)(fifo + first * size);
   1c700:	3304      	adds	r3, #4
   1c702:	fb14 f405 	smulbb	r4, r4, r5
	if (!lll_tx) {
   1c706:	1918      	adds	r0, r3, r4
   1c708:	d004      	beq.n	1c714 <ull_conn_ack_by_last_peek+0x20>
	*handle = lll_tx->handle;
   1c70a:	5b1b      	ldrh	r3, [r3, r4]
   1c70c:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   1c70e:	6843      	ldr	r3, [r0, #4]
   1c710:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   1c712:	6818      	ldr	r0, [r3, #0]
}
   1c714:	bd30      	pop	{r4, r5, pc}
		return NULL;
   1c716:	2000      	movs	r0, #0
   1c718:	e7fc      	b.n	1c714 <ull_conn_ack_by_last_peek+0x20>
   1c71a:	bf00      	nop
   1c71c:	200072cc 	.word	0x200072cc

0001c720 <ull_conn_ack_dequeue>:
{
   1c720:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(conn_ack);
   1c722:	4a09      	ldr	r2, [pc, #36]	; (1c748 <ull_conn_ack_dequeue+0x28>)
	u8_t _first = *first; /* Copy read-index */
   1c724:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   1c726:	78d0      	ldrb	r0, [r2, #3]
   1c728:	7811      	ldrb	r1, [r2, #0]
   1c72a:	7854      	ldrb	r4, [r2, #1]
   1c72c:	4298      	cmp	r0, r3
   1c72e:	d009      	beq.n	1c744 <ull_conn_ack_dequeue+0x24>
	mem = *((void **)(fifo + _first * size));
   1c730:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   1c734:	3301      	adds	r3, #1
   1c736:	b2db      	uxtb	r3, r3
		_first = 0U;
   1c738:	429c      	cmp	r4, r3
   1c73a:	bf08      	it	eq
   1c73c:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   1c73e:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   1c740:	7093      	strb	r3, [r2, #2]
}
   1c742:	bd10      	pop	{r4, pc}
		return NULL;
   1c744:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(conn_ack);
   1c746:	e7fc      	b.n	1c742 <ull_conn_ack_dequeue+0x22>
   1c748:	200072cc 	.word	0x200072cc

0001c74c <ull_conn_lll_ack_enqueue>:
{
   1c74c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   1c74e:	4a12      	ldr	r2, [pc, #72]	; (1c798 <ull_conn_lll_ack_enqueue+0x4c>)
   1c750:	78d4      	ldrb	r4, [r2, #3]
	if (last == count) {
   1c752:	7857      	ldrb	r7, [r2, #1]
   1c754:	7895      	ldrb	r5, [r2, #2]
   1c756:	7816      	ldrb	r6, [r2, #0]
	last = last + 1;
   1c758:	1c63      	adds	r3, r4, #1
   1c75a:	b2db      	uxtb	r3, r3
		last = 0U;
   1c75c:	429f      	cmp	r7, r3
   1c75e:	bf08      	it	eq
   1c760:	2300      	moveq	r3, #0
	if (last == first) {
   1c762:	429d      	cmp	r5, r3
   1c764:	d004      	beq.n	1c770 <ull_conn_lll_ack_enqueue+0x24>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1c766:	1d15      	adds	r5, r2, #4
   1c768:	fb14 f406 	smulbb	r4, r4, r6
	LL_ASSERT(lll_tx);
   1c76c:	192e      	adds	r6, r5, r4
   1c76e:	d10f      	bne.n	1c790 <ull_conn_lll_ack_enqueue+0x44>
   1c770:	4a0a      	ldr	r2, [pc, #40]	; (1c79c <ull_conn_lll_ack_enqueue+0x50>)
   1c772:	490b      	ldr	r1, [pc, #44]	; (1c7a0 <ull_conn_lll_ack_enqueue+0x54>)
   1c774:	480b      	ldr	r0, [pc, #44]	; (1c7a4 <ull_conn_lll_ack_enqueue+0x58>)
   1c776:	f240 53a4 	movw	r3, #1444	; 0x5a4
   1c77a:	f007 fbb2 	bl	23ee2 <printk>
   1c77e:	4040      	eors	r0, r0
   1c780:	f380 8811 	msr	BASEPRI, r0
   1c784:	f04f 0003 	mov.w	r0, #3
   1c788:	df02      	svc	2
	lll_tx->handle = handle;
   1c78a:	2300      	movs	r3, #0
   1c78c:	801b      	strh	r3, [r3, #0]
   1c78e:	deff      	udf	#255	; 0xff
   1c790:	5328      	strh	r0, [r5, r4]
	*last = idx; /* Commit: Update write index */
   1c792:	70d3      	strb	r3, [r2, #3]
	lll_tx->node = tx;
   1c794:	6071      	str	r1, [r6, #4]
}
   1c796:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c798:	200072cc 	.word	0x200072cc
   1c79c:	00030625 	.word	0x00030625
   1c7a0:	000306d4 	.word	0x000306d4
   1c7a4:	0002a5e8 	.word	0x0002a5e8

0001c7a8 <ull_conn_tx_ack>:
{
   1c7a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	LL_ASSERT(pdu_tx->len);
   1c7aa:	7953      	ldrb	r3, [r2, #5]
{
   1c7ac:	4606      	mov	r6, r0
   1c7ae:	460f      	mov	r7, r1
   1c7b0:	4614      	mov	r4, r2
	LL_ASSERT(pdu_tx->len);
   1c7b2:	b963      	cbnz	r3, 1c7ce <ull_conn_tx_ack+0x26>
   1c7b4:	4a26      	ldr	r2, [pc, #152]	; (1c850 <ull_conn_tx_ack+0xa8>)
   1c7b6:	4927      	ldr	r1, [pc, #156]	; (1c854 <ull_conn_tx_ack+0xac>)
   1c7b8:	4827      	ldr	r0, [pc, #156]	; (1c858 <ull_conn_tx_ack+0xb0>)
   1c7ba:	f240 53b3 	movw	r3, #1459	; 0x5b3
   1c7be:	f007 fb90 	bl	23ee2 <printk>
   1c7c2:	4040      	eors	r0, r0
   1c7c4:	f380 8811 	msr	BASEPRI, r0
   1c7c8:	f04f 0003 	mov.w	r0, #3
   1c7cc:	df02      	svc	2
	if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   1c7ce:	7923      	ldrb	r3, [r4, #4]
   1c7d0:	f003 0203 	and.w	r2, r3, #3
   1c7d4:	2a03      	cmp	r2, #3
   1c7d6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1c7da:	d12c      	bne.n	1c836 <ull_conn_tx_ack+0x8e>
		if (handle != 0xFFFF) {
   1c7dc:	4296      	cmp	r6, r2
   1c7de:	d015      	beq.n	1c80c <ull_conn_tx_ack+0x64>
			conn = ll_conn_get(handle);
   1c7e0:	4630      	mov	r0, r6
   1c7e2:	f7fe ff6f 	bl	1b6c4 <ll_conn_get>
	switch (pdu_tx->llctrl.opcode) {
   1c7e6:	79e3      	ldrb	r3, [r4, #7]
   1c7e8:	2b02      	cmp	r3, #2
			conn = ll_conn_get(handle);
   1c7ea:	4605      	mov	r5, r0
	switch (pdu_tx->llctrl.opcode) {
   1c7ec:	d105      	bne.n	1c7fa <ull_conn_tx_ack+0x52>
		u8_t reason = (pdu_tx->llctrl.terminate_ind.error_code ==
   1c7ee:	7a21      	ldrb	r1, [r4, #8]
   1c7f0:	2913      	cmp	r1, #19
		conn_cleanup(conn, reason);
   1c7f2:	bf08      	it	eq
   1c7f4:	2116      	moveq	r1, #22
   1c7f6:	f7ff fde1 	bl	1c3bc <conn_cleanup>
		if (link->next == (void *)tx) {
   1c7fa:	683b      	ldr	r3, [r7, #0]
   1c7fc:	42a3      	cmp	r3, r4
   1c7fe:	d107      	bne.n	1c810 <ull_conn_tx_ack+0x68>
			mem_release(tx, &mem_conn_tx_ctrl.free);
   1c800:	4916      	ldr	r1, [pc, #88]	; (1c85c <ull_conn_tx_ack+0xb4>)
   1c802:	4620      	mov	r0, r4
   1c804:	f00b fc57 	bl	280b6 <mem_release>
}
   1c808:	4628      	mov	r0, r5
   1c80a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	struct ll_conn *conn = NULL;
   1c80c:	2500      	movs	r5, #0
   1c80e:	e7f4      	b.n	1c7fa <ull_conn_tx_ack+0x52>
			LL_ASSERT(!link->next);
   1c810:	b163      	cbz	r3, 1c82c <ull_conn_tx_ack+0x84>
   1c812:	4a0f      	ldr	r2, [pc, #60]	; (1c850 <ull_conn_tx_ack+0xa8>)
   1c814:	4912      	ldr	r1, [pc, #72]	; (1c860 <ull_conn_tx_ack+0xb8>)
   1c816:	4810      	ldr	r0, [pc, #64]	; (1c858 <ull_conn_tx_ack+0xb0>)
   1c818:	f240 53c6 	movw	r3, #1478	; 0x5c6
   1c81c:	f007 fb61 	bl	23ee2 <printk>
   1c820:	4040      	eors	r0, r0
   1c822:	f380 8811 	msr	BASEPRI, r0
   1c826:	f04f 0003 	mov.w	r0, #3
   1c82a:	df02      	svc	2
	ll_tx_ack_put(handle, tx);
   1c82c:	4621      	mov	r1, r4
   1c82e:	4630      	mov	r0, r6
   1c830:	f7fd fea4 	bl	1a57c <ll_tx_ack_put>
	return conn;
   1c834:	e7e8      	b.n	1c808 <ull_conn_tx_ack+0x60>
	} else if (handle != 0xFFFF) {
   1c836:	4296      	cmp	r6, r2
   1c838:	d004      	beq.n	1c844 <ull_conn_tx_ack+0x9c>
		conn = ll_conn_get(handle);
   1c83a:	4630      	mov	r0, r6
   1c83c:	f7fe ff42 	bl	1b6c4 <ll_conn_get>
   1c840:	4605      	mov	r5, r0
   1c842:	e7f3      	b.n	1c82c <ull_conn_tx_ack+0x84>
		pdu_tx->ll_id = PDU_DATA_LLID_RESV;
   1c844:	f36f 0301 	bfc	r3, #0, #2
   1c848:	7123      	strb	r3, [r4, #4]
	struct ll_conn *conn = NULL;
   1c84a:	2500      	movs	r5, #0
   1c84c:	e7ee      	b.n	1c82c <ull_conn_tx_ack+0x84>
   1c84e:	bf00      	nop
   1c850:	00030625 	.word	0x00030625
   1c854:	000307d9 	.word	0x000307d9
   1c858:	0002a5e8 	.word	0x0002a5e8
   1c85c:	20001944 	.word	0x20001944
   1c860:	000307e5 	.word	0x000307e5

0001c864 <ticker_op_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
		  param == ull_disable_mark_get());
}

static void ticker_op_cb(u32_t status, void *param)
{
   1c864:	b508      	push	{r3, lr}
	ARG_UNUSED(param);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1c866:	b160      	cbz	r0, 1c882 <ticker_op_cb+0x1e>
   1c868:	4a06      	ldr	r2, [pc, #24]	; (1c884 <ticker_op_cb+0x20>)
   1c86a:	4907      	ldr	r1, [pc, #28]	; (1c888 <ticker_op_cb+0x24>)
   1c86c:	4807      	ldr	r0, [pc, #28]	; (1c88c <ticker_op_cb+0x28>)
   1c86e:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
   1c872:	f007 fb36 	bl	23ee2 <printk>
   1c876:	4040      	eors	r0, r0
   1c878:	f380 8811 	msr	BASEPRI, r0
   1c87c:	f04f 0003 	mov.w	r0, #3
   1c880:	df02      	svc	2
}
   1c882:	bd08      	pop	{r3, pc}
   1c884:	00030802 	.word	0x00030802
   1c888:	0003066c 	.word	0x0003066c
   1c88c:	0002a5e8 	.word	0x0002a5e8

0001c890 <ticker_op_stop_adv_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   1c890:	2801      	cmp	r0, #1
{
   1c892:	b510      	push	{r4, lr}
   1c894:	460c      	mov	r4, r1
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   1c896:	d110      	bne.n	1c8ba <ticker_op_stop_adv_cb+0x2a>
   1c898:	f7fd fee4 	bl	1a664 <ull_disable_mark_get>
   1c89c:	4284      	cmp	r4, r0
   1c89e:	d00c      	beq.n	1c8ba <ticker_op_stop_adv_cb+0x2a>
   1c8a0:	4a06      	ldr	r2, [pc, #24]	; (1c8bc <ticker_op_stop_adv_cb+0x2c>)
   1c8a2:	4907      	ldr	r1, [pc, #28]	; (1c8c0 <ticker_op_stop_adv_cb+0x30>)
   1c8a4:	4807      	ldr	r0, [pc, #28]	; (1c8c4 <ticker_op_stop_adv_cb+0x34>)
   1c8a6:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
   1c8aa:	f007 fb1a 	bl	23ee2 <printk>
   1c8ae:	4040      	eors	r0, r0
   1c8b0:	f380 8811 	msr	BASEPRI, r0
   1c8b4:	f04f 0003 	mov.w	r0, #3
   1c8b8:	df02      	svc	2
}
   1c8ba:	bd10      	pop	{r4, pc}
   1c8bc:	00030802 	.word	0x00030802
   1c8c0:	00030843 	.word	0x00030843
   1c8c4:	0002a5e8 	.word	0x0002a5e8

0001c8c8 <ull_slave_ticker_cb>:
{
   1c8c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c8cc:	4606      	mov	r6, r0
   1c8ce:	4688      	mov	r8, r1
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   1c8d0:	4601      	mov	r1, r0
   1c8d2:	4618      	mov	r0, r3
{
   1c8d4:	4617      	mov	r7, r2
   1c8d6:	461c      	mov	r4, r3
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   1c8d8:	f7e4 f862 	bl	9a0 <ull_conn_llcp>
		if (ret) {
   1c8dc:	2800      	cmp	r0, #0
   1c8de:	d136      	bne.n	1c94e <ull_slave_ticker_cb+0x86>
   1c8e0:	7c23      	ldrb	r3, [r4, #16]
   1c8e2:	3301      	adds	r3, #1
   1c8e4:	b2db      	uxtb	r3, r3
   1c8e6:	7423      	strb	r3, [r4, #16]
	LL_ASSERT(ref);
   1c8e8:	b963      	cbnz	r3, 1c904 <ull_slave_ticker_cb+0x3c>
   1c8ea:	4a1a      	ldr	r2, [pc, #104]	; (1c954 <ull_slave_ticker_cb+0x8c>)
   1c8ec:	491a      	ldr	r1, [pc, #104]	; (1c958 <ull_slave_ticker_cb+0x90>)
   1c8ee:	481b      	ldr	r0, [pc, #108]	; (1c95c <ull_slave_ticker_cb+0x94>)
   1c8f0:	f44f 73b8 	mov.w	r3, #368	; 0x170
   1c8f4:	f007 faf5 	bl	23ee2 <printk>
   1c8f8:	4040      	eors	r0, r0
   1c8fa:	f380 8811 	msr	BASEPRI, r0
   1c8fe:	f04f 0003 	mov.w	r0, #3
   1c902:	df02      	svc	2
	p.ticks_at_expire = ticks_at_expire;
   1c904:	4d16      	ldr	r5, [pc, #88]	; (1c960 <ull_slave_ticker_cb+0x98>)
	p.param = &conn->lll;
   1c906:	f104 031c 	add.w	r3, r4, #28
   1c90a:	60eb      	str	r3, [r5, #12]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1c90c:	2200      	movs	r2, #0
	mfy.param = &p;
   1c90e:	4b15      	ldr	r3, [pc, #84]	; (1c964 <ull_slave_ticker_cb+0x9c>)
	p.lazy = lazy;
   1c910:	812f      	strh	r7, [r5, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1c912:	4611      	mov	r1, r2
   1c914:	2001      	movs	r0, #1
	p.remainder = remainder;
   1c916:	e9c5 6800 	strd	r6, r8, [r5]
	mfy.param = &p;
   1c91a:	609d      	str	r5, [r3, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1c91c:	f7fb fc06 	bl	1812c <mayfly_enqueue>
	LL_ASSERT(!err);
   1c920:	b160      	cbz	r0, 1c93c <ull_slave_ticker_cb+0x74>
   1c922:	4a0c      	ldr	r2, [pc, #48]	; (1c954 <ull_slave_ticker_cb+0x8c>)
   1c924:	4910      	ldr	r1, [pc, #64]	; (1c968 <ull_slave_ticker_cb+0xa0>)
   1c926:	480d      	ldr	r0, [pc, #52]	; (1c95c <ull_slave_ticker_cb+0x94>)
   1c928:	f44f 73be 	mov.w	r3, #380	; 0x17c
   1c92c:	f007 fad9 	bl	23ee2 <printk>
   1c930:	4040      	eors	r0, r0
   1c932:	f380 8811 	msr	BASEPRI, r0
   1c936:	f04f 0003 	mov.w	r0, #3
   1c93a:	df02      	svc	2
	ull_conn_tx_demux(UINT8_MAX);
   1c93c:	20ff      	movs	r0, #255	; 0xff
   1c93e:	f7ff fcf7 	bl	1c330 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   1c942:	4620      	mov	r0, r4
   1c944:	21ff      	movs	r1, #255	; 0xff
}
   1c946:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   1c94a:	f7ff be77 	b.w	1c63c <ull_conn_tx_lll_enqueue>
}
   1c94e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1c952:	bf00      	nop
   1c954:	00030802 	.word	0x00030802
   1c958:	00030491 	.word	0x00030491
   1c95c:	0002a5e8 	.word	0x0002a5e8
   1c960:	20001a0c 	.word	0x20001a0c
   1c964:	20007344 	.word	0x20007344
   1c968:	000303e0 	.word	0x000303e0

0001c96c <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(void *arg)
{
   1c96c:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
   1c96e:	4b08      	ldr	r3, [pc, #32]	; (1c990 <rtc0_nrf5_isr+0x24>)
   1c970:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   1c974:	b122      	cbz	r2, 1c980 <rtc0_nrf5_isr+0x14>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
   1c976:	2000      	movs	r0, #0
   1c978:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140

		ticker_trigger(0);
   1c97c:	f7fc f95e 	bl	18c3c <ticker_trigger>
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
   1c980:	2001      	movs	r0, #1
   1c982:	f7fb fc23 	bl	181cc <mayfly_run>
	(CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	mayfly_run(TICKER_USER_ID_ULL_LOW);
#endif

	DEBUG_TICKER_ISR(0);
}
   1c986:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
   1c98a:	2002      	movs	r0, #2
   1c98c:	f7fb bc1e 	b.w	181cc <mayfly_run>
   1c990:	4000b000 	.word	0x4000b000

0001c994 <ticker_start_op_cb>:
	/* NOTE: this callback is present only for addition of debug messages
	 * when needed, else can be dispensed with.
	 */
	ARG_UNUSED(param);

	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
   1c994:	2801      	cmp	r0, #1
{
   1c996:	b508      	push	{r3, lr}
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
   1c998:	d90c      	bls.n	1c9b4 <ticker_start_op_cb+0x20>
   1c99a:	4a07      	ldr	r2, [pc, #28]	; (1c9b8 <ticker_start_op_cb+0x24>)
   1c99c:	4907      	ldr	r1, [pc, #28]	; (1c9bc <ticker_start_op_cb+0x28>)
   1c99e:	4808      	ldr	r0, [pc, #32]	; (1c9c0 <ticker_start_op_cb+0x2c>)
   1c9a0:	f44f 73fc 	mov.w	r3, #504	; 0x1f8
   1c9a4:	f007 fa9d 	bl	23ee2 <printk>
   1c9a8:	4040      	eors	r0, r0
   1c9aa:	f380 8811 	msr	BASEPRI, r0
   1c9ae:	f04f 0003 	mov.w	r0, #3
   1c9b2:	df02      	svc	2
		  (status == TICKER_STATUS_FAILURE));
}
   1c9b4:	bd08      	pop	{r3, pc}
   1c9b6:	bf00      	nop
   1c9b8:	00030884 	.word	0x00030884
   1c9bc:	000308ca 	.word	0x000308ca
   1c9c0:	0002a5e8 	.word	0x0002a5e8

0001c9c4 <preempt_ticker_start>:

static void preempt_ticker_start(struct lll_prepare_param *prepare_param)
{
   1c9c4:	b530      	push	{r4, r5, lr}
	struct evt_hdr *evt;
	u32_t preempt_to;
	int ret;

	/* Calc the preempt timeout */
	evt = HDR_LLL2EVT(prepare_param->param);
   1c9c6:	68c3      	ldr	r3, [r0, #12]
   1c9c8:	6819      	ldr	r1, [r3, #0]
	preempt_to = MAX(evt->ticks_active_to_start,
			 evt->ticks_xtal_to_start) -
			 evt->ticks_preempt_to_start;

	/* Setup pre empt timeout */
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1c9ca:	4b16      	ldr	r3, [pc, #88]	; (1ca24 <preempt_ticker_start+0x60>)
   1c9cc:	2200      	movs	r2, #0
{
   1c9ce:	b08b      	sub	sp, #44	; 0x2c
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1c9d0:	e9cd 2306 	strd	r2, r3, [sp, #24]
   1c9d4:	4b14      	ldr	r3, [pc, #80]	; (1ca28 <preempt_ticker_start+0x64>)
   1c9d6:	9208      	str	r2, [sp, #32]
   1c9d8:	e9cd 2304 	strd	r2, r3, [sp, #16]
   1c9dc:	e9cd 2202 	strd	r2, r2, [sp, #8]
   1c9e0:	9201      	str	r2, [sp, #4]
	preempt_to = MAX(evt->ticks_active_to_start,
   1c9e2:	e9d1 5400 	ldrd	r5, r4, [r1]
   1c9e6:	688b      	ldr	r3, [r1, #8]
   1c9e8:	42a5      	cmp	r5, r4
   1c9ea:	bf2c      	ite	cs
   1c9ec:	ebc3 0305 	rsbcs	r3, r3, r5
   1c9f0:	ebc3 0304 	rsbcc	r3, r3, r4
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1c9f4:	9300      	str	r3, [sp, #0]
   1c9f6:	6803      	ldr	r3, [r0, #0]
   1c9f8:	4611      	mov	r1, r2
   1c9fa:	4610      	mov	r0, r2
   1c9fc:	f7fc f930 	bl	18c60 <ticker_start>
			   TICKER_NULL_REMAINDER,
			   TICKER_NULL_LAZY,
			   TICKER_NULL_SLOT,
			   preempt_ticker_cb, NULL,
			   ticker_start_op_cb, NULL);
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1ca00:	2802      	cmp	r0, #2
   1ca02:	d90c      	bls.n	1ca1e <preempt_ticker_start+0x5a>
   1ca04:	4a09      	ldr	r2, [pc, #36]	; (1ca2c <preempt_ticker_start+0x68>)
   1ca06:	490a      	ldr	r1, [pc, #40]	; (1ca30 <preempt_ticker_start+0x6c>)
   1ca08:	480a      	ldr	r0, [pc, #40]	; (1ca34 <preempt_ticker_start+0x70>)
   1ca0a:	f240 2316 	movw	r3, #534	; 0x216
   1ca0e:	f007 fa68 	bl	23ee2 <printk>
   1ca12:	4040      	eors	r0, r0
   1ca14:	f380 8811 	msr	BASEPRI, r0
   1ca18:	f04f 0003 	mov.w	r0, #3
   1ca1c:	df02      	svc	2
		  (ret == TICKER_STATUS_FAILURE) ||
		  (ret == TICKER_STATUS_BUSY));
}
   1ca1e:	b00b      	add	sp, #44	; 0x2c
   1ca20:	bd30      	pop	{r4, r5, pc}
   1ca22:	bf00      	nop
   1ca24:	0001c995 	.word	0x0001c995
   1ca28:	0001cbd5 	.word	0x0001cbd5
   1ca2c:	00030884 	.word	0x00030884
   1ca30:	000308e9 	.word	0x000308e9
   1ca34:	0002a5e8 	.word	0x0002a5e8

0001ca38 <preempt>:
			     0, &mfy);
	LL_ASSERT(!ret);
}

static void preempt(void *param)
{
   1ca38:	b5f0      	push	{r4, r5, r6, r7, lr}
	lll_prepare_cb_t resume_cb;
	u8_t idx = UINT8_MAX;
	int resume_prio;
	int ret;

	if (!event.curr.abort_cb || !event.curr.param) {
   1ca3a:	4d3c      	ldr	r5, [pc, #240]	; (1cb2c <preempt+0xf4>)
{
   1ca3c:	b08b      	sub	sp, #44	; 0x2c
	struct lll_event *next = ull_prepare_dequeue_get();
   1ca3e:	f7fd fee9 	bl	1a814 <ull_prepare_dequeue_get>
	u8_t idx = UINT8_MAX;
   1ca42:	23ff      	movs	r3, #255	; 0xff
   1ca44:	f88d 300e 	strb.w	r3, [sp, #14]
	if (!event.curr.abort_cb || !event.curr.param) {
   1ca48:	68ab      	ldr	r3, [r5, #8]
   1ca4a:	b35b      	cbz	r3, 1caa4 <preempt+0x6c>
   1ca4c:	682b      	ldr	r3, [r5, #0]
   1ca4e:	b34b      	cbz	r3, 1caa4 <preempt+0x6c>
	if (!next) {
		return;
	}

	while (next && (next->is_aborted || next->is_resume)) {
		next = ull_prepare_dequeue_iter(&idx);
   1ca50:	f10d 000e 	add.w	r0, sp, #14
   1ca54:	f7fe f820 	bl	1aa98 <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
   1ca58:	4604      	mov	r4, r0
   1ca5a:	b318      	cbz	r0, 1caa4 <preempt+0x6c>
   1ca5c:	f890 0020 	ldrb.w	r0, [r0, #32]
   1ca60:	f010 0703 	ands.w	r7, r0, #3
   1ca64:	d1f4      	bne.n	1ca50 <preempt+0x18>

	if (!next) {
		return;
	}

	ret = event.curr.is_abort_cb(next->prepare_param.param, next->prio,
   1ca66:	ab05      	add	r3, sp, #20
   1ca68:	9300      	str	r3, [sp, #0]
   1ca6a:	686e      	ldr	r6, [r5, #4]
   1ca6c:	682a      	ldr	r2, [r5, #0]
   1ca6e:	69e1      	ldr	r1, [r4, #28]
   1ca70:	68e0      	ldr	r0, [r4, #12]
   1ca72:	ab04      	add	r3, sp, #16
   1ca74:	47b0      	blx	r6
				     event.curr.param,
				     &resume_cb, &resume_prio);
	if (!ret) {
   1ca76:	4606      	mov	r6, r0
   1ca78:	b9b0      	cbnz	r0, 1caa8 <preempt+0x70>
		/* Let LLL know about the cancelled prepare */
		next->is_aborted = 1;
   1ca7a:	f894 3020 	ldrb.w	r3, [r4, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   1ca7e:	68e1      	ldr	r1, [r4, #12]
		next->is_aborted = 1;
   1ca80:	f043 0302 	orr.w	r3, r3, #2
   1ca84:	f884 3020 	strb.w	r3, [r4, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   1ca88:	4620      	mov	r0, r4
   1ca8a:	69a3      	ldr	r3, [r4, #24]
   1ca8c:	4798      	blx	r3
		LL_ASSERT(ret == -ECANCELED);
	}

preempt_next:
	do {
		next = ull_prepare_dequeue_iter(&idx);
   1ca8e:	f10d 000e 	add.w	r0, sp, #14
   1ca92:	f7fe f801 	bl	1aa98 <ull_prepare_dequeue_iter>
		if (!next) {
   1ca96:	b128      	cbz	r0, 1caa4 <preempt+0x6c>
			return;
		}
	} while (next->is_aborted || next->is_resume);
   1ca98:	f890 3020 	ldrb.w	r3, [r0, #32]
   1ca9c:	079b      	lsls	r3, r3, #30
   1ca9e:	d1f6      	bne.n	1ca8e <preempt+0x56>

	preempt_ticker_start(&next->prepare_param);
   1caa0:	f7ff ff90 	bl	1c9c4 <preempt_ticker_start>
}
   1caa4:	b00b      	add	sp, #44	; 0x2c
   1caa6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	event.curr.abort_cb(NULL, event.curr.param);
   1caa8:	68ab      	ldr	r3, [r5, #8]
   1caaa:	6829      	ldr	r1, [r5, #0]
   1caac:	4638      	mov	r0, r7
   1caae:	4798      	blx	r3
	if (ret == -EAGAIN) {
   1cab0:	f116 0f0b 	cmn.w	r6, #11
   1cab4:	d133      	bne.n	1cb1e <preempt+0xe6>
		u8_t iter_idx = UINT8_MAX;
   1cab6:	23ff      	movs	r3, #255	; 0xff
   1cab8:	f88d 300f 	strb.w	r3, [sp, #15]
			iter = ull_prepare_dequeue_iter(&iter_idx);
   1cabc:	f10d 000f 	add.w	r0, sp, #15
   1cac0:	f7fd ffea 	bl	1aa98 <ull_prepare_dequeue_iter>
		while (iter) {
   1cac4:	b9e0      	cbnz	r0, 1cb00 <preempt+0xc8>
	prepare_param.param = event.curr.param;
   1cac6:	682b      	ldr	r3, [r5, #0]
   1cac8:	9309      	str	r3, [sp, #36]	; 0x24
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   1caca:	2301      	movs	r3, #1
   1cacc:	9301      	str	r3, [sp, #4]
   1cace:	9b05      	ldr	r3, [sp, #20]
	event.curr.param = NULL;
   1cad0:	6028      	str	r0, [r5, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   1cad2:	9300      	str	r3, [sp, #0]
   1cad4:	e9d5 0101 	ldrd	r0, r1, [r5, #4]
   1cad8:	9b04      	ldr	r3, [sp, #16]
   1cada:	aa06      	add	r2, sp, #24
   1cadc:	f7fd fe66 	bl	1a7ac <ull_prepare_enqueue>
		LL_ASSERT(!ret);
   1cae0:	2800      	cmp	r0, #0
   1cae2:	d0d4      	beq.n	1ca8e <preempt+0x56>
   1cae4:	4a12      	ldr	r2, [pc, #72]	; (1cb30 <preempt+0xf8>)
   1cae6:	4913      	ldr	r1, [pc, #76]	; (1cb34 <preempt+0xfc>)
   1cae8:	f240 235e 	movw	r3, #606	; 0x25e
		LL_ASSERT(ret == -ECANCELED);
   1caec:	4812      	ldr	r0, [pc, #72]	; (1cb38 <preempt+0x100>)
   1caee:	f007 f9f8 	bl	23ee2 <printk>
   1caf2:	4040      	eors	r0, r0
   1caf4:	f380 8811 	msr	BASEPRI, r0
   1caf8:	f04f 0003 	mov.w	r0, #3
   1cafc:	df02      	svc	2
   1cafe:	e7c6      	b.n	1ca8e <preempt+0x56>
			if (!iter->is_aborted &&
   1cb00:	f890 3020 	ldrb.w	r3, [r0, #32]
   1cb04:	079a      	lsls	r2, r3, #30
   1cb06:	d4d9      	bmi.n	1cabc <preempt+0x84>
			    event.curr.param == iter->prepare_param.param) {
   1cb08:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
   1cb0a:	6829      	ldr	r1, [r5, #0]
   1cb0c:	4291      	cmp	r1, r2
   1cb0e:	d1d5      	bne.n	1cabc <preempt+0x84>
				iter->is_aborted = 1;
   1cb10:	f043 0302 	orr.w	r3, r3, #2
   1cb14:	f880 3020 	strb.w	r3, [r0, #32]
				iter->abort_cb(&iter->prepare_param,
   1cb18:	6983      	ldr	r3, [r0, #24]
   1cb1a:	4798      	blx	r3
   1cb1c:	e7ce      	b.n	1cabc <preempt+0x84>
		LL_ASSERT(ret == -ECANCELED);
   1cb1e:	3648      	adds	r6, #72	; 0x48
   1cb20:	d0b5      	beq.n	1ca8e <preempt+0x56>
   1cb22:	4a03      	ldr	r2, [pc, #12]	; (1cb30 <preempt+0xf8>)
   1cb24:	4905      	ldr	r1, [pc, #20]	; (1cb3c <preempt+0x104>)
   1cb26:	f44f 7318 	mov.w	r3, #608	; 0x260
   1cb2a:	e7df      	b.n	1caec <preempt+0xb4>
   1cb2c:	20001a20 	.word	0x20001a20
   1cb30:	00030884 	.word	0x00030884
   1cb34:	00030473 	.word	0x00030473
   1cb38:	0002a5e8 	.word	0x0002a5e8
   1cb3c:	00030910 	.word	0x00030910

0001cb40 <prepare>:
{
   1cb40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1cb44:	b085      	sub	sp, #20
   1cb46:	4698      	mov	r8, r3
   1cb48:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   1cb4a:	f89d 7034 	ldrb.w	r7, [sp, #52]	; 0x34
	u8_t idx = UINT8_MAX;
   1cb4e:	23ff      	movs	r3, #255	; 0xff
{
   1cb50:	4606      	mov	r6, r0
   1cb52:	4689      	mov	r9, r1
   1cb54:	4614      	mov	r4, r2
	u8_t idx = UINT8_MAX;
   1cb56:	f88d 300f 	strb.w	r3, [sp, #15]
		p = ull_prepare_dequeue_iter(&idx);
   1cb5a:	f10d 000f 	add.w	r0, sp, #15
   1cb5e:	f7fd ff9b 	bl	1aa98 <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
   1cb62:	b118      	cbz	r0, 1cb6c <prepare+0x2c>
   1cb64:	f890 3020 	ldrb.w	r3, [r0, #32]
   1cb68:	079b      	lsls	r3, r3, #30
   1cb6a:	d1f6      	bne.n	1cb5a <prepare+0x1a>
	if (event.curr.abort_cb || (p && is_resume)) {
   1cb6c:	4b15      	ldr	r3, [pc, #84]	; (1cbc4 <prepare+0x84>)
   1cb6e:	689a      	ldr	r2, [r3, #8]
   1cb70:	b90a      	cbnz	r2, 1cb76 <prepare+0x36>
   1cb72:	b1e8      	cbz	r0, 1cbb0 <prepare+0x70>
   1cb74:	b1e7      	cbz	r7, 1cbb0 <prepare+0x70>
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
   1cb76:	e9cd 8700 	strd	r8, r7, [sp]
   1cb7a:	4623      	mov	r3, r4
   1cb7c:	462a      	mov	r2, r5
   1cb7e:	4649      	mov	r1, r9
   1cb80:	4630      	mov	r0, r6
   1cb82:	f7fd fe13 	bl	1a7ac <ull_prepare_enqueue>
		LL_ASSERT(!ret);
   1cb86:	b160      	cbz	r0, 1cba2 <prepare+0x62>
   1cb88:	4a0f      	ldr	r2, [pc, #60]	; (1cbc8 <prepare+0x88>)
   1cb8a:	4910      	ldr	r1, [pc, #64]	; (1cbcc <prepare+0x8c>)
   1cb8c:	4810      	ldr	r0, [pc, #64]	; (1cbd0 <prepare+0x90>)
   1cb8e:	f44f 73d6 	mov.w	r3, #428	; 0x1ac
   1cb92:	f007 f9a6 	bl	23ee2 <printk>
   1cb96:	4040      	eors	r0, r0
   1cb98:	f380 8811 	msr	BASEPRI, r0
   1cb9c:	f04f 0003 	mov.w	r0, #3
   1cba0:	df02      	svc	2
		if (is_resume) {
   1cba2:	b917      	cbnz	r7, 1cbaa <prepare+0x6a>
		preempt_ticker_start(prepare_param);
   1cba4:	4628      	mov	r0, r5
   1cba6:	f7ff ff0d 	bl	1c9c4 <preempt_ticker_start>
		return -EINPROGRESS;
   1cbaa:	f06f 0043 	mvn.w	r0, #67	; 0x43
   1cbae:	e006      	b.n	1cbbe <prepare+0x7e>
	event.curr.param = prepare_param->param;
   1cbb0:	68ea      	ldr	r2, [r5, #12]
	event.curr.abort_cb = abort_cb;
   1cbb2:	f8c3 9008 	str.w	r9, [r3, #8]
	event.curr.is_abort_cb = is_abort_cb;
   1cbb6:	e9c3 2600 	strd	r2, r6, [r3]
	err = prepare_cb(prepare_param);
   1cbba:	4628      	mov	r0, r5
   1cbbc:	47a0      	blx	r4
}
   1cbbe:	b005      	add	sp, #20
   1cbc0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1cbc4:	20001a20 	.word	0x20001a20
   1cbc8:	00030884 	.word	0x00030884
   1cbcc:	00030473 	.word	0x00030473
   1cbd0:	0002a5e8 	.word	0x0002a5e8

0001cbd4 <preempt_ticker_cb>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1cbd4:	2200      	movs	r2, #0
{
   1cbd6:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1cbd8:	4611      	mov	r1, r2
   1cbda:	4b09      	ldr	r3, [pc, #36]	; (1cc00 <preempt_ticker_cb+0x2c>)
   1cbdc:	2001      	movs	r0, #1
   1cbde:	f7fb faa5 	bl	1812c <mayfly_enqueue>
	LL_ASSERT(!ret);
   1cbe2:	b160      	cbz	r0, 1cbfe <preempt_ticker_cb+0x2a>
   1cbe4:	4a07      	ldr	r2, [pc, #28]	; (1cc04 <preempt_ticker_cb+0x30>)
   1cbe6:	4908      	ldr	r1, [pc, #32]	; (1cc08 <preempt_ticker_cb+0x34>)
   1cbe8:	4808      	ldr	r0, [pc, #32]	; (1cc0c <preempt_ticker_cb+0x38>)
   1cbea:	f44f 7309 	mov.w	r3, #548	; 0x224
   1cbee:	f007 f978 	bl	23ee2 <printk>
   1cbf2:	4040      	eors	r0, r0
   1cbf4:	f380 8811 	msr	BASEPRI, r0
   1cbf8:	f04f 0003 	mov.w	r0, #3
   1cbfc:	df02      	svc	2
}
   1cbfe:	bd08      	pop	{r3, pc}
   1cc00:	20007354 	.word	0x20007354
   1cc04:	00030884 	.word	0x00030884
   1cc08:	00030473 	.word	0x00030473
   1cc0c:	0002a5e8 	.word	0x0002a5e8

0001cc10 <lll_init>:
{
   1cc10:	b510      	push	{r4, lr}
   1cc12:	4815      	ldr	r0, [pc, #84]	; (1cc68 <lll_init+0x58>)
   1cc14:	f003 fbd8 	bl	203c8 <z_impl_device_get_binding>
	dev_entropy = device_get_binding(CONFIG_ENTROPY_NAME);
   1cc18:	4b14      	ldr	r3, [pc, #80]	; (1cc6c <lll_init+0x5c>)
   1cc1a:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
   1cc1c:	b300      	cbz	r0, 1cc60 <lll_init+0x50>
	event.curr.abort_cb = NULL;
   1cc1e:	4b14      	ldr	r3, [pc, #80]	; (1cc70 <lll_init+0x60>)
   1cc20:	2200      	movs	r2, #0
   1cc22:	609a      	str	r2, [r3, #8]
	err = lll_clock_init();
   1cc24:	f000 f920 	bl	1ce68 <lll_clock_init>
	if (err) {
   1cc28:	4604      	mov	r4, r0
   1cc2a:	b9b8      	cbnz	r0, 1cc5c <lll_init+0x4c>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
   1cc2c:	4602      	mov	r2, r0
   1cc2e:	4601      	mov	r1, r0
   1cc30:	2001      	movs	r0, #1
   1cc32:	f7e7 fec3 	bl	49bc <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
   1cc36:	4622      	mov	r2, r4
   1cc38:	4621      	mov	r1, r4
   1cc3a:	200b      	movs	r0, #11
   1cc3c:	f7e7 febe 	bl	49bc <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
   1cc40:	4622      	mov	r2, r4
   1cc42:	4621      	mov	r1, r4
   1cc44:	2018      	movs	r0, #24
   1cc46:	f7e7 feb9 	bl	49bc <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
   1cc4a:	2001      	movs	r0, #1
   1cc4c:	f7e7 fe84 	bl	4958 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
   1cc50:	200b      	movs	r0, #11
   1cc52:	f7e7 fe81 	bl	4958 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
   1cc56:	2018      	movs	r0, #24
   1cc58:	f7e7 fe7e 	bl	4958 <arch_irq_enable>
}
   1cc5c:	4620      	mov	r0, r4
   1cc5e:	bd10      	pop	{r4, pc}
		return -ENODEV;
   1cc60:	f06f 0412 	mvn.w	r4, #18
   1cc64:	e7fa      	b.n	1cc5c <lll_init+0x4c>
   1cc66:	bf00      	nop
   1cc68:	00030045 	.word	0x00030045
   1cc6c:	20001a1c 	.word	0x20001a1c
   1cc70:	20001a20 	.word	0x20001a20

0001cc74 <lll_entropy_get>:
	return entropy_get_entropy_isr(dev_entropy, rand, len, 0);
   1cc74:	4b06      	ldr	r3, [pc, #24]	; (1cc90 <lll_entropy_get+0x1c>)
{
   1cc76:	4602      	mov	r2, r0
	return entropy_get_entropy_isr(dev_entropy, rand, len, 0);
   1cc78:	6818      	ldr	r0, [r3, #0]
					  u32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	if (unlikely(!api->get_entropy_isr)) {
   1cc7a:	6843      	ldr	r3, [r0, #4]
{
   1cc7c:	b510      	push	{r4, lr}
   1cc7e:	685c      	ldr	r4, [r3, #4]
   1cc80:	b11c      	cbz	r4, 1cc8a <lll_entropy_get+0x16>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
   1cc82:	2300      	movs	r3, #0
   1cc84:	47a0      	blx	r4
}
   1cc86:	b2c0      	uxtb	r0, r0
   1cc88:	bd10      	pop	{r4, pc}
		return -ENOTSUP;
   1cc8a:	f06f 0022 	mvn.w	r0, #34	; 0x22
   1cc8e:	e7fa      	b.n	1cc86 <lll_entropy_get+0x12>
   1cc90:	20001a1c 	.word	0x20001a1c

0001cc94 <lll_resume>:
{
   1cc94:	b507      	push	{r0, r1, r2, lr}
		      next->prio, &next->prepare_param, next->is_resume);
   1cc96:	f890 3020 	ldrb.w	r3, [r0, #32]
	ret = prepare(next->is_abort_cb, next->abort_cb, next->prepare_cb,
   1cc9a:	f003 0301 	and.w	r3, r3, #1
   1cc9e:	e9cd 0300 	strd	r0, r3, [sp]
   1cca2:	69c3      	ldr	r3, [r0, #28]
   1cca4:	6902      	ldr	r2, [r0, #16]
   1cca6:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
   1ccaa:	f7ff ff49 	bl	1cb40 <prepare>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
   1ccae:	b168      	cbz	r0, 1cccc <lll_resume+0x38>
   1ccb0:	3044      	adds	r0, #68	; 0x44
   1ccb2:	d00b      	beq.n	1cccc <lll_resume+0x38>
   1ccb4:	4a07      	ldr	r2, [pc, #28]	; (1ccd4 <lll_resume+0x40>)
   1ccb6:	4908      	ldr	r1, [pc, #32]	; (1ccd8 <lll_resume+0x44>)
   1ccb8:	4808      	ldr	r0, [pc, #32]	; (1ccdc <lll_resume+0x48>)
   1ccba:	23d2      	movs	r3, #210	; 0xd2
   1ccbc:	f007 f911 	bl	23ee2 <printk>
   1ccc0:	4040      	eors	r0, r0
   1ccc2:	f380 8811 	msr	BASEPRI, r0
   1ccc6:	f04f 0003 	mov.w	r0, #3
   1ccca:	df02      	svc	2
}
   1cccc:	b003      	add	sp, #12
   1ccce:	f85d fb04 	ldr.w	pc, [sp], #4
   1ccd2:	bf00      	nop
   1ccd4:	00030884 	.word	0x00030884
   1ccd8:	0003091b 	.word	0x0003091b
   1ccdc:	0002a5e8 	.word	0x0002a5e8

0001cce0 <lll_disable>:
{
   1cce0:	b513      	push	{r0, r1, r4, lr}
   1cce2:	4b1b      	ldr	r3, [pc, #108]	; (1cd50 <lll_disable+0x70>)
	if (!param || (param == event.curr.param)) {
   1cce4:	4604      	mov	r4, r0
   1cce6:	b110      	cbz	r0, 1ccee <lll_disable+0xe>
   1cce8:	681a      	ldr	r2, [r3, #0]
   1ccea:	4282      	cmp	r2, r0
   1ccec:	d105      	bne.n	1ccfa <lll_disable+0x1a>
		if (event.curr.abort_cb && event.curr.param) {
   1ccee:	689a      	ldr	r2, [r3, #8]
   1ccf0:	b16a      	cbz	r2, 1cd0e <lll_disable+0x2e>
   1ccf2:	6819      	ldr	r1, [r3, #0]
   1ccf4:	b159      	cbz	r1, 1cd0e <lll_disable+0x2e>
			event.curr.abort_cb(NULL, event.curr.param);
   1ccf6:	2000      	movs	r0, #0
   1ccf8:	4790      	blx	r2
		u8_t idx = UINT8_MAX;
   1ccfa:	23ff      	movs	r3, #255	; 0xff
   1ccfc:	f88d 3007 	strb.w	r3, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
   1cd00:	f10d 0007 	add.w	r0, sp, #7
   1cd04:	f7fd fec8 	bl	1aa98 <ull_prepare_dequeue_iter>
		while (next) {
   1cd08:	b980      	cbnz	r0, 1cd2c <lll_disable+0x4c>
}
   1cd0a:	b002      	add	sp, #8
   1cd0c:	bd10      	pop	{r4, pc}
			LL_ASSERT(!param);
   1cd0e:	2c00      	cmp	r4, #0
   1cd10:	d0f3      	beq.n	1ccfa <lll_disable+0x1a>
   1cd12:	4a10      	ldr	r2, [pc, #64]	; (1cd54 <lll_disable+0x74>)
   1cd14:	4910      	ldr	r1, [pc, #64]	; (1cd58 <lll_disable+0x78>)
   1cd16:	4811      	ldr	r0, [pc, #68]	; (1cd5c <lll_disable+0x7c>)
   1cd18:	23dc      	movs	r3, #220	; 0xdc
   1cd1a:	f007 f8e2 	bl	23ee2 <printk>
   1cd1e:	4040      	eors	r0, r0
   1cd20:	f380 8811 	msr	BASEPRI, r0
   1cd24:	f04f 0003 	mov.w	r0, #3
   1cd28:	df02      	svc	2
   1cd2a:	e7e6      	b.n	1ccfa <lll_disable+0x1a>
			if (!next->is_aborted &&
   1cd2c:	f890 3020 	ldrb.w	r3, [r0, #32]
   1cd30:	079b      	lsls	r3, r3, #30
   1cd32:	d4e5      	bmi.n	1cd00 <lll_disable+0x20>
   1cd34:	68c1      	ldr	r1, [r0, #12]
   1cd36:	b10c      	cbz	r4, 1cd3c <lll_disable+0x5c>
			    (!param || (param == next->prepare_param.param))) {
   1cd38:	428c      	cmp	r4, r1
   1cd3a:	d1e1      	bne.n	1cd00 <lll_disable+0x20>
				next->is_aborted = 1;
   1cd3c:	f890 3020 	ldrb.w	r3, [r0, #32]
   1cd40:	f043 0302 	orr.w	r3, r3, #2
   1cd44:	f880 3020 	strb.w	r3, [r0, #32]
				next->abort_cb(&next->prepare_param,
   1cd48:	6983      	ldr	r3, [r0, #24]
   1cd4a:	4798      	blx	r3
   1cd4c:	e7d8      	b.n	1cd00 <lll_disable+0x20>
   1cd4e:	bf00      	nop
   1cd50:	20001a20 	.word	0x20001a20
   1cd54:	00030884 	.word	0x00030884
   1cd58:	0003092e 	.word	0x0003092e
   1cd5c:	0002a5e8 	.word	0x0002a5e8

0001cd60 <lll_done>:
{
   1cd60:	b510      	push	{r4, lr}
   1cd62:	4604      	mov	r4, r0
	struct lll_event *next = ull_prepare_dequeue_get();
   1cd64:	f7fd fd56 	bl	1a814 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
   1cd68:	b17c      	cbz	r4, 1cd8a <lll_done+0x2a>
   1cd6a:	b960      	cbnz	r0, 1cd86 <lll_done+0x26>
   1cd6c:	4a1b      	ldr	r2, [pc, #108]	; (1cddc <lll_done+0x7c>)
   1cd6e:	491c      	ldr	r1, [pc, #112]	; (1cde0 <lll_done+0x80>)
   1cd70:	481c      	ldr	r0, [pc, #112]	; (1cde4 <lll_done+0x84>)
   1cd72:	f240 130b 	movw	r3, #267	; 0x10b
   1cd76:	f007 f8b4 	bl	23ee2 <printk>
   1cd7a:	4040      	eors	r0, r0
   1cd7c:	f380 8811 	msr	BASEPRI, r0
   1cd80:	f04f 0003 	mov.w	r0, #3
   1cd84:	df02      	svc	2
		ull = HDR_ULL(((struct lll_hdr *)param)->parent);
   1cd86:	6820      	ldr	r0, [r4, #0]
   1cd88:	e015      	b.n	1cdb6 <lll_done+0x56>
		LL_ASSERT(event.curr.abort_cb);
   1cd8a:	4c17      	ldr	r4, [pc, #92]	; (1cde8 <lll_done+0x88>)
   1cd8c:	68a3      	ldr	r3, [r4, #8]
   1cd8e:	b963      	cbnz	r3, 1cdaa <lll_done+0x4a>
   1cd90:	4a12      	ldr	r2, [pc, #72]	; (1cddc <lll_done+0x7c>)
   1cd92:	4916      	ldr	r1, [pc, #88]	; (1cdec <lll_done+0x8c>)
   1cd94:	4813      	ldr	r0, [pc, #76]	; (1cde4 <lll_done+0x84>)
   1cd96:	f44f 7388 	mov.w	r3, #272	; 0x110
   1cd9a:	f007 f8a2 	bl	23ee2 <printk>
   1cd9e:	4040      	eors	r0, r0
   1cda0:	f380 8811 	msr	BASEPRI, r0
   1cda4:	f04f 0003 	mov.w	r0, #3
   1cda8:	df02      	svc	2
		param = event.curr.param;
   1cdaa:	6820      	ldr	r0, [r4, #0]
		event.curr.abort_cb = NULL;
   1cdac:	2300      	movs	r3, #0
   1cdae:	60a3      	str	r3, [r4, #8]
		event.curr.param = NULL;
   1cdb0:	6023      	str	r3, [r4, #0]
		if (param) {
   1cdb2:	b108      	cbz	r0, 1cdb8 <lll_done+0x58>
			ull = HDR_ULL(((struct lll_hdr *)param)->parent);
   1cdb4:	6800      	ldr	r0, [r0, #0]
   1cdb6:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
   1cdb8:	f7fd fe9c 	bl	1aaf4 <ull_event_done>
	LL_ASSERT(evdone);
   1cdbc:	b960      	cbnz	r0, 1cdd8 <lll_done+0x78>
   1cdbe:	4a07      	ldr	r2, [pc, #28]	; (1cddc <lll_done+0x7c>)
   1cdc0:	490b      	ldr	r1, [pc, #44]	; (1cdf0 <lll_done+0x90>)
   1cdc2:	4808      	ldr	r0, [pc, #32]	; (1cde4 <lll_done+0x84>)
   1cdc4:	f44f 7394 	mov.w	r3, #296	; 0x128
   1cdc8:	f007 f88b 	bl	23ee2 <printk>
   1cdcc:	4040      	eors	r0, r0
   1cdce:	f380 8811 	msr	BASEPRI, r0
   1cdd2:	f04f 0003 	mov.w	r0, #3
   1cdd6:	df02      	svc	2
}
   1cdd8:	2000      	movs	r0, #0
   1cdda:	bd10      	pop	{r4, pc}
   1cddc:	00030884 	.word	0x00030884
   1cde0:	00030935 	.word	0x00030935
   1cde4:	0002a5e8 	.word	0x0002a5e8
   1cde8:	20001a20 	.word	0x20001a20
   1cdec:	00030944 	.word	0x00030944
   1cdf0:	00030958 	.word	0x00030958

0001cdf4 <lll_is_done>:
	return !event.curr.abort_cb;
   1cdf4:	4b02      	ldr	r3, [pc, #8]	; (1ce00 <lll_is_done+0xc>)
   1cdf6:	6898      	ldr	r0, [r3, #8]
}
   1cdf8:	fab0 f080 	clz	r0, r0
   1cdfc:	0940      	lsrs	r0, r0, #5
   1cdfe:	4770      	bx	lr
   1ce00:	20001a20 	.word	0x20001a20

0001ce04 <lll_chan_set>:
	switch (chan) {
   1ce04:	2826      	cmp	r0, #38	; 0x26
{
   1ce06:	b510      	push	{r4, lr}
   1ce08:	4604      	mov	r4, r0
	switch (chan) {
   1ce0a:	d00b      	beq.n	1ce24 <lll_chan_set+0x20>
   1ce0c:	2827      	cmp	r0, #39	; 0x27
   1ce0e:	d00b      	beq.n	1ce28 <lll_chan_set+0x24>
   1ce10:	2825      	cmp	r0, #37	; 0x25
   1ce12:	d10b      	bne.n	1ce2c <lll_chan_set+0x28>
		radio_freq_chan_set(2);
   1ce14:	2002      	movs	r0, #2
		radio_freq_chan_set(26);
   1ce16:	f001 fbc7 	bl	1e5a8 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
   1ce1a:	4620      	mov	r0, r4
}
   1ce1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
   1ce20:	f001 bbc8 	b.w	1e5b4 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
   1ce24:	201a      	movs	r0, #26
   1ce26:	e7f6      	b.n	1ce16 <lll_chan_set+0x12>
		radio_freq_chan_set(80);
   1ce28:	2050      	movs	r0, #80	; 0x50
   1ce2a:	e7f4      	b.n	1ce16 <lll_chan_set+0x12>
		if (chan < 11) {
   1ce2c:	280a      	cmp	r0, #10
   1ce2e:	d802      	bhi.n	1ce36 <lll_chan_set+0x32>
			radio_freq_chan_set(4 + (chan * 2U));
   1ce30:	3002      	adds	r0, #2
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   1ce32:	0040      	lsls	r0, r0, #1
   1ce34:	e7ef      	b.n	1ce16 <lll_chan_set+0x12>
		} else if (chan < 40) {
   1ce36:	2827      	cmp	r0, #39	; 0x27
   1ce38:	d801      	bhi.n	1ce3e <lll_chan_set+0x3a>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   1ce3a:	3003      	adds	r0, #3
   1ce3c:	e7f9      	b.n	1ce32 <lll_chan_set+0x2e>
			LL_ASSERT(0);
   1ce3e:	4a07      	ldr	r2, [pc, #28]	; (1ce5c <lll_chan_set+0x58>)
   1ce40:	4907      	ldr	r1, [pc, #28]	; (1ce60 <lll_chan_set+0x5c>)
   1ce42:	4808      	ldr	r0, [pc, #32]	; (1ce64 <lll_chan_set+0x60>)
   1ce44:	f44f 73b6 	mov.w	r3, #364	; 0x16c
   1ce48:	f007 f84b 	bl	23ee2 <printk>
   1ce4c:	4040      	eors	r0, r0
   1ce4e:	f380 8811 	msr	BASEPRI, r0
   1ce52:	f04f 0003 	mov.w	r0, #3
   1ce56:	df02      	svc	2
   1ce58:	e7df      	b.n	1ce1a <lll_chan_set+0x16>
   1ce5a:	bf00      	nop
   1ce5c:	00030884 	.word	0x00030884
   1ce60:	0002e3c9 	.word	0x0002e3c9
   1ce64:	0002a5e8 	.word	0x0002a5e8

0001ce68 <lll_clock_init>:
			void *user_data);

static struct device *dev;

int lll_clock_init(void)
{
   1ce68:	b510      	push	{r4, lr}
   1ce6a:	4807      	ldr	r0, [pc, #28]	; (1ce88 <lll_clock_init+0x20>)
   1ce6c:	f003 faac 	bl	203c8 <z_impl_device_get_binding>
	int err;

	dev = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
   1ce70:	4a06      	ldr	r2, [pc, #24]	; (1ce8c <lll_clock_init+0x24>)
   1ce72:	6010      	str	r0, [r2, #0]
	if (!dev) {
   1ce74:	b128      	cbz	r0, 1ce82 <lll_clock_init+0x1a>
   1ce76:	6843      	ldr	r3, [r0, #4]
	}

	err = clock_control_on(dev, CLOCK_CONTROL_NRF_SUBSYS_LF);

	return err;
}
   1ce78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1ce7c:	681b      	ldr	r3, [r3, #0]
   1ce7e:	2101      	movs	r1, #1
   1ce80:	4718      	bx	r3
   1ce82:	f06f 0012 	mvn.w	r0, #18
   1ce86:	bd10      	pop	{r4, pc}
   1ce88:	0002ae34 	.word	0x0002ae34
   1ce8c:	20001a34 	.word	0x20001a34

0001ce90 <lll_clock_wait>:

int lll_clock_wait(void)
{
   1ce90:	b530      	push	{r4, r5, lr}
	static bool done;

	if (done) {
   1ce92:	4b12      	ldr	r3, [pc, #72]	; (1cedc <lll_clock_wait+0x4c>)
   1ce94:	7819      	ldrb	r1, [r3, #0]
{
   1ce96:	b08b      	sub	sp, #44	; 0x2c
	if (done) {
   1ce98:	b9d1      	cbnz	r1, 1ced0 <lll_clock_wait+0x40>
		return 0;
	}
	done = true;
   1ce9a:	2501      	movs	r5, #1
   1ce9c:	701d      	strb	r5, [r3, #0]

	struct k_sem sem_clock_wait;
	struct clock_control_async_data async_data = {
   1ce9e:	ac04      	add	r4, sp, #16
   1cea0:	4b0f      	ldr	r3, [pc, #60]	; (1cee0 <lll_clock_wait+0x50>)
   1cea2:	9101      	str	r1, [sp, #4]
   1cea4:	9302      	str	r3, [sp, #8]
   1cea6:	9403      	str	r4, [sp, #12]
	return z_impl_k_sem_init(sem, initial_count, limit);
   1cea8:	462a      	mov	r2, r5
   1ceaa:	4620      	mov	r0, r4
   1ceac:	f00c fa14 	bl	292d8 <z_impl_k_sem_init>
	};
	int err;

	k_sem_init(&sem_clock_wait, 0, 1);

	err = clock_control_async_on(dev, CLOCK_CONTROL_NRF_SUBSYS_LF,
   1ceb0:	4b0c      	ldr	r3, [pc, #48]	; (1cee4 <lll_clock_wait+0x54>)
   1ceb2:	6818      	ldr	r0, [r3, #0]
					 struct clock_control_async_data *data)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	if (!api->async_on) {
   1ceb4:	6843      	ldr	r3, [r0, #4]
   1ceb6:	689b      	ldr	r3, [r3, #8]
   1ceb8:	b163      	cbz	r3, 1ced4 <lll_clock_wait+0x44>
		return -ENOTSUP;
	}

	return api->async_on(dev, sys, data);
   1ceba:	aa01      	add	r2, sp, #4
   1cebc:	4629      	mov	r1, r5
   1cebe:	4798      	blx	r3
				     &async_data);
	if (err) {
   1cec0:	b920      	cbnz	r0, 1cecc <lll_clock_wait+0x3c>
	return z_impl_k_sem_take(sem, timeout);
   1cec2:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   1cec6:	4620      	mov	r0, r4
   1cec8:	f005 fc36 	bl	22738 <z_impl_k_sem_take>
	}

	err = k_sem_take(&sem_clock_wait, K_MSEC(LFCLOCK_TIMEOUT_MS));

	return err;
}
   1cecc:	b00b      	add	sp, #44	; 0x2c
   1cece:	bd30      	pop	{r4, r5, pc}
		return 0;
   1ced0:	2000      	movs	r0, #0
   1ced2:	e7fb      	b.n	1cecc <lll_clock_wait+0x3c>
		return -ENOTSUP;
   1ced4:	f06f 0022 	mvn.w	r0, #34	; 0x22
   1ced8:	e7f8      	b.n	1cecc <lll_clock_wait+0x3c>
   1ceda:	bf00      	nop
   1cedc:	200024d8 	.word	0x200024d8
   1cee0:	000287e5 	.word	0x000287e5
   1cee4:	20001a34 	.word	0x20001a34

0001cee8 <lll_hfclock_on>:
int lll_hfclock_on(void)
{
	int err;

	/* turn on radio clock in non-blocking mode. */
	err = clock_control_on(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
   1cee8:	4b02      	ldr	r3, [pc, #8]	; (1cef4 <lll_hfclock_on+0xc>)
   1ceea:	6818      	ldr	r0, [r3, #0]
	return api->on(dev, sys);
   1ceec:	6843      	ldr	r3, [r0, #4]
   1ceee:	2100      	movs	r1, #0
   1cef0:	681b      	ldr	r3, [r3, #0]
   1cef2:	4718      	bx	r3
   1cef4:	20001a34 	.word	0x20001a34

0001cef8 <lll_hfclock_off>:
int lll_hfclock_off(void)
{
	int err;

	/* turn off radio clock in non-blocking mode. */
	err = clock_control_off(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
   1cef8:	4b02      	ldr	r3, [pc, #8]	; (1cf04 <lll_hfclock_off+0xc>)
   1cefa:	6818      	ldr	r0, [r3, #0]
	return api->off(dev, sys);
   1cefc:	6843      	ldr	r3, [r0, #4]
   1cefe:	2100      	movs	r1, #0
   1cf00:	685b      	ldr	r3, [r3, #4]
   1cf02:	4718      	bx	r3
   1cf04:	20001a34 	.word	0x20001a34

0001cf08 <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
   1cf08:	b508      	push	{r3, lr}
   1cf0a:	4601      	mov	r1, r0
	int err;

	radio_isr_set(isr_race, param);
   1cf0c:	4810      	ldr	r0, [pc, #64]	; (1cf50 <isr_cleanup+0x48>)
   1cf0e:	f001 faf1 	bl	1e4f4 <radio_isr_set>
	if (!radio_is_idle()) {
   1cf12:	f001 fbef 	bl	1e6f4 <radio_is_idle>
   1cf16:	b908      	cbnz	r0, 1cf1c <isr_cleanup+0x14>
		radio_disable();
   1cf18:	f001 fbba 	bl	1e690 <radio_disable>
	}

	radio_tmr_stop();
   1cf1c:	f001 fd32 	bl	1e984 <radio_tmr_stop>

	err = lll_hfclock_off();
   1cf20:	f7ff ffea 	bl	1cef8 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
   1cf24:	b170      	cbz	r0, 1cf44 <isr_cleanup+0x3c>
   1cf26:	3010      	adds	r0, #16
   1cf28:	d00c      	beq.n	1cf44 <isr_cleanup+0x3c>
   1cf2a:	4a0a      	ldr	r2, [pc, #40]	; (1cf54 <isr_cleanup+0x4c>)
   1cf2c:	490a      	ldr	r1, [pc, #40]	; (1cf58 <isr_cleanup+0x50>)
   1cf2e:	480b      	ldr	r0, [pc, #44]	; (1cf5c <isr_cleanup+0x54>)
   1cf30:	f240 2349 	movw	r3, #585	; 0x249
   1cf34:	f006 ffd5 	bl	23ee2 <printk>
   1cf38:	4040      	eors	r0, r0
   1cf3a:	f380 8811 	msr	BASEPRI, r0
   1cf3e:	f04f 0003 	mov.w	r0, #3
   1cf42:	df02      	svc	2

	lll_done(NULL);
}
   1cf44:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   1cf48:	2000      	movs	r0, #0
   1cf4a:	f7ff bf09 	b.w	1cd60 <lll_done>
   1cf4e:	bf00      	nop
   1cf50:	000287eb 	.word	0x000287eb
   1cf54:	0003097d 	.word	0x0003097d
   1cf58:	000309c7 	.word	0x000309c7
   1cf5c:	0002a5e8 	.word	0x0002a5e8

0001cf60 <isr_tx>:
{
   1cf60:	b538      	push	{r3, r4, r5, lr}
   1cf62:	4604      	mov	r4, r0
	radio_status_reset();
   1cf64:	f001 fba6 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   1cf68:	f001 fc54 	bl	1e814 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1cf6c:	2096      	movs	r0, #150	; 0x96
   1cf6e:	f001 fc61 	bl	1e834 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1cf72:	2300      	movs	r3, #0
   1cf74:	461a      	mov	r2, r3
   1cf76:	4619      	mov	r1, r3
   1cf78:	4618      	mov	r0, r3
   1cf7a:	f001 fbef 	bl	1e75c <radio_switch_complete_and_tx>
	radio_pkt_rx_set(radio_pkt_scratch_get());
   1cf7e:	f001 fbdd 	bl	1e73c <radio_pkt_scratch_get>
   1cf82:	f001 fb6d 	bl	1e660 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
   1cf86:	f001 fba1 	bl	1e6cc <radio_is_ready>
   1cf8a:	b160      	cbz	r0, 1cfa6 <isr_tx+0x46>
   1cf8c:	4a12      	ldr	r2, [pc, #72]	; (1cfd8 <isr_tx+0x78>)
   1cf8e:	4913      	ldr	r1, [pc, #76]	; (1cfdc <isr_tx+0x7c>)
   1cf90:	4813      	ldr	r0, [pc, #76]	; (1cfe0 <isr_tx+0x80>)
   1cf92:	f240 1357 	movw	r3, #343	; 0x157
   1cf96:	f006 ffa4 	bl	23ee2 <printk>
   1cf9a:	4040      	eors	r0, r0
   1cf9c:	f380 8811 	msr	BASEPRI, r0
   1cfa0:	f04f 0003 	mov.w	r0, #3
   1cfa4:	df02      	svc	2
	radio_isr_set(isr_rx, param);
   1cfa6:	4621      	mov	r1, r4
   1cfa8:	480e      	ldr	r0, [pc, #56]	; (1cfe4 <isr_tx+0x84>)
   1cfaa:	f001 faa3 	bl	1e4f4 <radio_isr_set>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1cfae:	f001 fd3b 	bl	1ea28 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   1cfb2:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1cfb4:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   1cfb6:	4608      	mov	r0, r1
   1cfb8:	f00b fdd9 	bl	28b6e <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   1cfbc:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   1cfbe:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   1cfc0:	4608      	mov	r0, r1
   1cfc2:	f00b fdd0 	bl	28b66 <radio_tx_chain_delay_get>
   1cfc6:	442c      	add	r4, r5
   1cfc8:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   1cfca:	1a20      	subs	r0, r4, r0
   1cfcc:	f001 fce6 	bl	1e99c <radio_tmr_hcto_configure>
}
   1cfd0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_tmr_end_capture();
   1cfd4:	f001 bd1a 	b.w	1ea0c <radio_tmr_end_capture>
   1cfd8:	0003097d 	.word	0x0003097d
   1cfdc:	000309da 	.word	0x000309da
   1cfe0:	0002a5e8 	.word	0x0002a5e8
   1cfe4:	0001d0ad 	.word	0x0001d0ad

0001cfe8 <is_abort_cb>:
	if (next != curr) {
   1cfe8:	4282      	cmp	r2, r0
{
   1cfea:	b508      	push	{r3, lr}
	if (next != curr) {
   1cfec:	d01c      	beq.n	1d028 <is_abort_cb+0x40>
		} else if (lll->is_hdcd) {
   1cfee:	7b12      	ldrb	r2, [r2, #12]
   1cff0:	07d2      	lsls	r2, r2, #31
   1cff2:	d526      	bpl.n	1d042 <is_abort_cb+0x5a>
			*resume_cb = resume_prepare_cb;
   1cff4:	4a14      	ldr	r2, [pc, #80]	; (1d048 <is_abort_cb+0x60>)
   1cff6:	601a      	str	r2, [r3, #0]
			*resume_prio = 0; /* TODO: */
   1cff8:	9b02      	ldr	r3, [sp, #8]
   1cffa:	2200      	movs	r2, #0
   1cffc:	601a      	str	r2, [r3, #0]
			err = lll_hfclock_on();
   1cffe:	f7ff ff73 	bl	1cee8 <lll_hfclock_on>
			LL_ASSERT(!err || err == -EINPROGRESS);
   1d002:	b170      	cbz	r0, 1d022 <is_abort_cb+0x3a>
   1d004:	3044      	adds	r0, #68	; 0x44
   1d006:	d00c      	beq.n	1d022 <is_abort_cb+0x3a>
   1d008:	4a10      	ldr	r2, [pc, #64]	; (1d04c <is_abort_cb+0x64>)
   1d00a:	4911      	ldr	r1, [pc, #68]	; (1d050 <is_abort_cb+0x68>)
   1d00c:	4811      	ldr	r0, [pc, #68]	; (1d054 <is_abort_cb+0x6c>)
   1d00e:	f240 1313 	movw	r3, #275	; 0x113
   1d012:	f006 ff66 	bl	23ee2 <printk>
   1d016:	4040      	eors	r0, r0
   1d018:	f380 8811 	msr	BASEPRI, r0
   1d01c:	f04f 0003 	mov.w	r0, #3
   1d020:	df02      	svc	2
   1d022:	f06f 000a 	mvn.w	r0, #10
   1d026:	e00b      	b.n	1d040 <is_abort_cb+0x58>
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
}

static inline struct pdu_adv *lll_adv_data_curr_get(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
   1d028:	7b93      	ldrb	r3, [r2, #14]
   1d02a:	2127      	movs	r1, #39	; 0x27
   1d02c:	fb01 2203 	mla	r2, r1, r3, r2
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   1d030:	7c13      	ldrb	r3, [r2, #16]
   1d032:	f003 030f 	and.w	r3, r3, #15
   1d036:	2b01      	cmp	r3, #1
		return 0;
   1d038:	bf14      	ite	ne
   1d03a:	f06f 0047 	mvnne.w	r0, #71	; 0x47
   1d03e:	2000      	moveq	r0, #0
}
   1d040:	bd08      	pop	{r3, pc}
			return -ECANCELED;
   1d042:	f06f 0047 	mvn.w	r0, #71	; 0x47
   1d046:	e7fb      	b.n	1d040 <is_abort_cb+0x58>
   1d048:	0002885d 	.word	0x0002885d
   1d04c:	0003097d 	.word	0x0003097d
   1d050:	000309ec 	.word	0x000309ec
   1d054:	0002a5e8 	.word	0x0002a5e8

0001d058 <abort_cb>:
{
   1d058:	b510      	push	{r4, lr}
   1d05a:	460c      	mov	r4, r1
	if (!prepare_param) {
   1d05c:	b930      	cbnz	r0, 1d06c <abort_cb+0x14>
		radio_isr_set(isr_abort, param);
   1d05e:	480f      	ldr	r0, [pc, #60]	; (1d09c <abort_cb+0x44>)
   1d060:	f001 fa48 	bl	1e4f4 <radio_isr_set>
}
   1d064:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   1d068:	f001 bb12 	b.w	1e690 <radio_disable>
	err = lll_hfclock_off();
   1d06c:	f7ff ff44 	bl	1cef8 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
   1d070:	b170      	cbz	r0, 1d090 <abort_cb+0x38>
   1d072:	3010      	adds	r0, #16
   1d074:	d00c      	beq.n	1d090 <abort_cb+0x38>
   1d076:	4a0a      	ldr	r2, [pc, #40]	; (1d0a0 <abort_cb+0x48>)
   1d078:	490a      	ldr	r1, [pc, #40]	; (1d0a4 <abort_cb+0x4c>)
   1d07a:	480b      	ldr	r0, [pc, #44]	; (1d0a8 <abort_cb+0x50>)
   1d07c:	f240 1339 	movw	r3, #313	; 0x139
   1d080:	f006 ff2f 	bl	23ee2 <printk>
   1d084:	4040      	eors	r0, r0
   1d086:	f380 8811 	msr	BASEPRI, r0
   1d08a:	f04f 0003 	mov.w	r0, #3
   1d08e:	df02      	svc	2
	lll_done(param);
   1d090:	4620      	mov	r0, r4
}
   1d092:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   1d096:	f7ff be63 	b.w	1cd60 <lll_done>
   1d09a:	bf00      	nop
   1d09c:	000287ef 	.word	0x000287ef
   1d0a0:	0003097d 	.word	0x0003097d
   1d0a4:	000309c7 	.word	0x000309c7
   1d0a8:	0002a5e8 	.word	0x0002a5e8

0001d0ac <isr_rx>:
{
   1d0ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d0b0:	4605      	mov	r5, r0
	trx_done = radio_is_done();
   1d0b2:	f001 fb15 	bl	1e6e0 <radio_is_done>
	if (trx_done) {
   1d0b6:	f010 06ff 	ands.w	r6, r0, #255	; 0xff
   1d0ba:	d06a      	beq.n	1d192 <isr_rx+0xe6>
		crc_ok = radio_crc_is_valid();
   1d0bc:	f001 fb30 	bl	1e720 <radio_crc_is_valid>
   1d0c0:	b2c7      	uxtb	r7, r0
		devmatch_ok = radio_filter_has_match();
   1d0c2:	f001 fb97 	bl	1e7f4 <radio_filter_has_match>
   1d0c6:	b2c4      	uxtb	r4, r0
		devmatch_id = radio_filter_match_get();
   1d0c8:	f001 fb9e 	bl	1e808 <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
   1d0cc:	f001 fcc4 	bl	1ea58 <radio_ar_has_match>
		irkmatch_id = radio_ar_match_get();
   1d0d0:	f001 fcb0 	bl	1ea34 <radio_ar_match_get>
		rssi_ready = radio_rssi_is_ready();
   1d0d4:	f001 fb72 	bl	1e7bc <radio_rssi_is_ready>
	radio_status_reset();
   1d0d8:	f001 faec 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   1d0dc:	f001 fb9a 	bl	1e814 <radio_tmr_status_reset>
	radio_filter_status_reset();
   1d0e0:	f001 fb80 	bl	1e7e4 <radio_filter_status_reset>
	radio_ar_status_reset();
   1d0e4:	f001 fcac 	bl	1ea40 <radio_ar_status_reset>
	radio_rssi_status_reset();
   1d0e8:	f001 fb60 	bl	1e7ac <radio_rssi_status_reset>
	if (!trx_done) {
   1d0ec:	2e00      	cmp	r6, #0
   1d0ee:	f000 80e0 	beq.w	1d2b2 <isr_rx+0x206>
	if (crc_ok) {
   1d0f2:	2f00      	cmp	r7, #0
   1d0f4:	f000 80dd 	beq.w	1d2b2 <isr_rx+0x206>
				    FILTER_IDX_NONE;
#else
	u8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	pdu_rx = (void *)radio_pkt_scratch_get();
   1d0f8:	f001 fb20 	bl	1e73c <radio_pkt_scratch_get>
   1d0fc:	7baa      	ldrb	r2, [r5, #14]
   1d0fe:	2310      	movs	r3, #16
   1d100:	2727      	movs	r7, #39	; 0x27
   1d102:	fb17 3702 	smlabb	r7, r7, r2, r3
	pdu_adv = lll_adv_data_curr_get(lll);

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   1d106:	7802      	ldrb	r2, [r0, #0]
   1d108:	f002 030f 	and.w	r3, r2, #15
   1d10c:	2b03      	cmp	r3, #3
	pdu_rx = (void *)radio_pkt_scratch_get();
   1d10e:	4606      	mov	r6, r0
   1d110:	eb05 0807 	add.w	r8, r5, r7
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   1d114:	d140      	bne.n	1d198 <isr_rx+0xec>
   1d116:	7843      	ldrb	r3, [r0, #1]
   1d118:	2b0c      	cmp	r3, #12
   1d11a:	f040 80ca 	bne.w	1d2b2 <isr_rx+0x206>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
   1d11e:	5deb      	ldrb	r3, [r5, r7]
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
   1d120:	f003 010f 	and.w	r1, r3, #15
   1d124:	2901      	cmp	r1, #1
   1d126:	f000 80c4 	beq.w	1d2b2 <isr_rx+0x206>
						rl_idx)) ||
		(((lll->filter_policy & 0x01) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
		isr_rx_sr_adva_check(adv, sr);
#else
	return (((lll->filter_policy & 0x01) == 0U) || devmatch_ok) &&
   1d12a:	7b69      	ldrb	r1, [r5, #13]
   1d12c:	07c9      	lsls	r1, r1, #31
   1d12e:	d502      	bpl.n	1d136 <isr_rx+0x8a>
   1d130:	2c00      	cmp	r4, #0
   1d132:	f000 80be 	beq.w	1d2b2 <isr_rx+0x206>
}

static inline bool isr_rx_sr_adva_check(struct pdu_adv *adv,
					struct pdu_adv *sr)
{
	return (adv->tx_addr == sr->rx_addr) &&
   1d136:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1d13a:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   1d13e:	f040 80b8 	bne.w	1d2b2 <isr_rx+0x206>
		!memcmp(adv->adv_ind.addr, sr->scan_req.adv_addr, BDADDR_SIZE);
   1d142:	2206      	movs	r2, #6
   1d144:	f106 0108 	add.w	r1, r6, #8
   1d148:	f108 0002 	add.w	r0, r8, #2
   1d14c:	f008 fd9c 	bl	25c88 <memcmp>
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
   1d150:	bb10      	cbnz	r0, 1d198 <isr_rx+0xec>
		radio_isr_set(isr_done, lll);
   1d152:	485c      	ldr	r0, [pc, #368]	; (1d2c4 <isr_rx+0x218>)
   1d154:	4629      	mov	r1, r5
   1d156:	f001 f9cd 	bl	1e4f4 <radio_isr_set>
		radio_switch_complete_and_disable();
   1d15a:	f001 fb09 	bl	1e770 <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
   1d15e:	f895 005e 	ldrb.w	r0, [r5, #94]	; 0x5e
   1d162:	2327      	movs	r3, #39	; 0x27
   1d164:	fb03 5000 	mla	r0, r3, r0, r5
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
   1d168:	3060      	adds	r0, #96	; 0x60
   1d16a:	f001 fa7f 	bl	1e66c <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
   1d16e:	f001 faad 	bl	1e6cc <radio_is_ready>
   1d172:	b160      	cbz	r0, 1d18e <isr_rx+0xe2>
   1d174:	4a54      	ldr	r2, [pc, #336]	; (1d2c8 <isr_rx+0x21c>)
   1d176:	4955      	ldr	r1, [pc, #340]	; (1d2cc <isr_rx+0x220>)
   1d178:	4855      	ldr	r0, [pc, #340]	; (1d2d0 <isr_rx+0x224>)
   1d17a:	f240 239b 	movw	r3, #667	; 0x29b
   1d17e:	f006 feb0 	bl	23ee2 <printk>
   1d182:	4040      	eors	r0, r0
   1d184:	f380 8811 	msr	BASEPRI, r0
   1d188:	f04f 0003 	mov.w	r0, #3
   1d18c:	df02      	svc	2
}
   1d18e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
   1d192:	4634      	mov	r4, r6
   1d194:	4637      	mov	r7, r6
   1d196:	e79f      	b.n	1d0d8 <isr_rx+0x2c>
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
   1d198:	7833      	ldrb	r3, [r6, #0]
   1d19a:	f003 030f 	and.w	r3, r3, #15
   1d19e:	2b05      	cmp	r3, #5
   1d1a0:	f040 8087 	bne.w	1d2b2 <isr_rx+0x206>
   1d1a4:	7873      	ldrb	r3, [r6, #1]
   1d1a6:	2b22      	cmp	r3, #34	; 0x22
   1d1a8:	f040 8083 	bne.w	1d2b2 <isr_rx+0x206>
static inline bool isr_rx_ci_check(struct lll_adv *lll, struct pdu_adv *adv,
				   struct pdu_adv *ci, u8_t devmatch_ok,
				   u8_t *rl_idx)
{
	/* LL 4.3.2: filter policy shall be ignored for directed adv */
	if (adv->type == PDU_ADV_TYPE_DIRECT_IND) {
   1d1ac:	5deb      	ldrb	r3, [r5, r7]
   1d1ae:	f003 030f 	and.w	r3, r3, #15
   1d1b2:	2b01      	cmp	r3, #1
   1d1b4:	d171      	bne.n	1d29a <isr_rx+0x1ee>
						      ci->connect_ind.init_addr,
						      rl_idx) &&
#else
		return (1) &&
#endif
		       isr_rx_ci_adva_check(adv, ci) &&
   1d1b6:	4631      	mov	r1, r6
   1d1b8:	4640      	mov	r0, r8
   1d1ba:	f00b fb2b 	bl	28814 <isr_rx_ci_adva_check>
   1d1be:	2800      	cmp	r0, #0
   1d1c0:	d077      	beq.n	1d2b2 <isr_rx+0x206>
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (rl_idx != FILTER_IDX_NONE) {
		return rl_idx == lll->rl_idx;
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */
	return (adv->rx_addr == ci->tx_addr) &&
   1d1c2:	7833      	ldrb	r3, [r6, #0]
   1d1c4:	5dea      	ldrb	r2, [r5, r7]
   1d1c6:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1d1ca:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   1d1ce:	d162      	bne.n	1d296 <isr_rx+0x1ea>
	       !memcmp(adv->direct_ind.tgt_addr, ci->connect_ind.init_addr,
   1d1d0:	2206      	movs	r2, #6
   1d1d2:	1cb1      	adds	r1, r6, #2
   1d1d4:	f108 0008 	add.w	r0, r8, #8
   1d1d8:	f008 fd56 	bl	25c88 <memcmp>
	return (adv->rx_addr == ci->tx_addr) &&
   1d1dc:	fab0 f380 	clz	r3, r0
   1d1e0:	095b      	lsrs	r3, r3, #5
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
   1d1e2:	2b00      	cmp	r3, #0
   1d1e4:	d065      	beq.n	1d2b2 <isr_rx+0x206>
				   &rl_idx) &&
   1d1e6:	68ab      	ldr	r3, [r5, #8]
   1d1e8:	2b00      	cmp	r3, #0
   1d1ea:	d062      	beq.n	1d2b2 <isr_rx+0x206>
			rx = ull_pdu_rx_alloc_peek(3);
   1d1ec:	2003      	movs	r0, #3
   1d1ee:	f7fd fa97 	bl	1a720 <ull_pdu_rx_alloc_peek>
		if (!rx) {
   1d1f2:	2800      	cmp	r0, #0
   1d1f4:	d05d      	beq.n	1d2b2 <isr_rx+0x206>
		radio_isr_set(isr_abort, lll);
   1d1f6:	4837      	ldr	r0, [pc, #220]	; (1d2d4 <isr_rx+0x228>)
   1d1f8:	4629      	mov	r1, r5
   1d1fa:	f001 f97b 	bl	1e4f4 <radio_isr_set>
		radio_disable();
   1d1fe:	f001 fa47 	bl	1e690 <radio_disable>
		LL_ASSERT(!radio_is_ready());
   1d202:	f001 fa63 	bl	1e6cc <radio_is_ready>
   1d206:	b160      	cbz	r0, 1d222 <isr_rx+0x176>
   1d208:	4a2f      	ldr	r2, [pc, #188]	; (1d2c8 <isr_rx+0x21c>)
   1d20a:	4930      	ldr	r1, [pc, #192]	; (1d2cc <isr_rx+0x220>)
   1d20c:	4830      	ldr	r0, [pc, #192]	; (1d2d0 <isr_rx+0x224>)
   1d20e:	f240 23d7 	movw	r3, #727	; 0x2d7
   1d212:	f006 fe66 	bl	23ee2 <printk>
   1d216:	4040      	eors	r0, r0
   1d218:	f380 8811 	msr	BASEPRI, r0
   1d21c:	f04f 0003 	mov.w	r0, #3
   1d220:	df02      	svc	2
}

static inline int lll_stop(void *lll)
{
	struct lll_hdr *hdr = lll;
	int ret = !!hdr->is_stop;
   1d222:	792b      	ldrb	r3, [r5, #4]

	hdr->is_stop = 1U;
   1d224:	f043 0201 	orr.w	r2, r3, #1
		LL_ASSERT(!ret);
   1d228:	07db      	lsls	r3, r3, #31
   1d22a:	712a      	strb	r2, [r5, #4]
   1d22c:	d50c      	bpl.n	1d248 <isr_rx+0x19c>
   1d22e:	4a26      	ldr	r2, [pc, #152]	; (1d2c8 <isr_rx+0x21c>)
   1d230:	4929      	ldr	r1, [pc, #164]	; (1d2d8 <isr_rx+0x22c>)
   1d232:	4827      	ldr	r0, [pc, #156]	; (1d2d0 <isr_rx+0x224>)
   1d234:	f240 23e5 	movw	r3, #741	; 0x2e5
   1d238:	f006 fe53 	bl	23ee2 <printk>
   1d23c:	4040      	eors	r0, r0
   1d23e:	f380 8811 	msr	BASEPRI, r0
   1d242:	f04f 0003 	mov.w	r0, #3
   1d246:	df02      	svc	2
		rx = ull_pdu_rx_alloc();
   1d248:	f7fd fa82 	bl	1a750 <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1d24c:	2308      	movs	r3, #8
		rx = ull_pdu_rx_alloc();
   1d24e:	4604      	mov	r4, r0
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1d250:	7103      	strb	r3, [r0, #4]
		rx->hdr.handle = 0xffff;
   1d252:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1d256:	80c3      	strh	r3, [r0, #6]
		memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
   1d258:	2224      	movs	r2, #36	; 0x24
   1d25a:	4631      	mov	r1, r6
   1d25c:	3020      	adds	r0, #32
   1d25e:	f008 fd23 	bl	25ca8 <memcpy>
		ftr->param = lll;
   1d262:	60a5      	str	r5, [r4, #8]
		ftr->ticks_anchor = radio_tmr_start_get();
   1d264:	f001 fb88 	bl	1e978 <radio_tmr_start_get>
   1d268:	6120      	str	r0, [r4, #16]
		ftr->us_radio_end = radio_tmr_end_get() -
   1d26a:	f001 fbd7 	bl	1ea1c <radio_tmr_end_get>
				    radio_tx_chain_delay_get(0, 0);
   1d26e:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
   1d270:	4605      	mov	r5, r0
				    radio_tx_chain_delay_get(0, 0);
   1d272:	4608      	mov	r0, r1
   1d274:	f00b fc77 	bl	28b66 <radio_tx_chain_delay_get>
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
   1d278:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
   1d27a:	1a2d      	subs	r5, r5, r0
   1d27c:	6165      	str	r5, [r4, #20]
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
   1d27e:	4608      	mov	r0, r1
   1d280:	f00b fc73 	bl	28b6a <radio_rx_ready_delay_get>
		ull_rx_put(rx->hdr.link, rx);
   1d284:	4621      	mov	r1, r4
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
   1d286:	61a0      	str	r0, [r4, #24]
		ull_rx_put(rx->hdr.link, rx);
   1d288:	6820      	ldr	r0, [r4, #0]
   1d28a:	f7fd fa77 	bl	1a77c <ull_rx_put>
}
   1d28e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		ull_rx_sched();
   1d292:	f7fd ba83 	b.w	1a79c <ull_rx_sched>
	return (adv->rx_addr == ci->tx_addr) &&
   1d296:	2300      	movs	r3, #0
   1d298:	e7a3      	b.n	1d1e2 <isr_rx+0x136>
	return (((lll->filter_policy & 0x02) == 0) ||
   1d29a:	7b6b      	ldrb	r3, [r5, #13]
		(devmatch_ok)) &&
   1d29c:	079a      	lsls	r2, r3, #30
   1d29e:	d500      	bpl.n	1d2a2 <isr_rx+0x1f6>
	return (((lll->filter_policy & 0x02) == 0) ||
   1d2a0:	b124      	cbz	r4, 1d2ac <isr_rx+0x200>
	       isr_rx_ci_adva_check(adv, ci);
   1d2a2:	4631      	mov	r1, r6
   1d2a4:	4640      	mov	r0, r8
   1d2a6:	f00b fab5 	bl	28814 <isr_rx_ci_adva_check>
   1d2aa:	4604      	mov	r4, r0
		(devmatch_ok)) &&
   1d2ac:	f004 0301 	and.w	r3, r4, #1
   1d2b0:	e797      	b.n	1d1e2 <isr_rx+0x136>
	radio_isr_set(isr_done, param);
   1d2b2:	4629      	mov	r1, r5
   1d2b4:	4803      	ldr	r0, [pc, #12]	; (1d2c4 <isr_rx+0x218>)
   1d2b6:	f001 f91d 	bl	1e4f4 <radio_isr_set>
}
   1d2ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	radio_disable();
   1d2be:	f001 b9e7 	b.w	1e690 <radio_disable>
   1d2c2:	bf00      	nop
   1d2c4:	00028885 	.word	0x00028885
   1d2c8:	0003097d 	.word	0x0003097d
   1d2cc:	000309da 	.word	0x000309da
   1d2d0:	0002a5e8 	.word	0x0002a5e8
   1d2d4:	000287ef 	.word	0x000287ef
   1d2d8:	00030473 	.word	0x00030473

0001d2dc <chan_prepare>:
{
   1d2dc:	b570      	push	{r4, r5, r6, lr}
	first = pdu->first;
   1d2de:	7b82      	ldrb	r2, [r0, #14]
	if (first != pdu->last) {
   1d2e0:	7bc3      	ldrb	r3, [r0, #15]
   1d2e2:	429a      	cmp	r2, r3
   1d2e4:	4604      	mov	r4, r0
   1d2e6:	d005      	beq.n	1d2f4 <chan_prepare+0x18>
		first += 1U;
   1d2e8:	1c53      	adds	r3, r2, #1
   1d2ea:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
   1d2ec:	2b02      	cmp	r3, #2
			first = 0U;
   1d2ee:	bf08      	it	eq
   1d2f0:	2300      	moveq	r3, #0
		pdu->first = first;
   1d2f2:	7383      	strb	r3, [r0, #14]
	return (void *)pdu->pdu[first];
   1d2f4:	2202      	movs	r2, #2
   1d2f6:	2527      	movs	r5, #39	; 0x27
   1d2f8:	fb15 2503 	smlabb	r5, r5, r3, r2
	first = pdu->first;
   1d2fc:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
	if (first != pdu->last) {
   1d300:	f894 205f 	ldrb.w	r2, [r4, #95]	; 0x5f
	return (void *)pdu->pdu[first];
   1d304:	f104 060e 	add.w	r6, r4, #14
	if (first != pdu->last) {
   1d308:	429a      	cmp	r2, r3
	return (void *)pdu->pdu[first];
   1d30a:	eb06 0005 	add.w	r0, r6, r5
	if (first != pdu->last) {
   1d30e:	d006      	beq.n	1d31e <chan_prepare+0x42>
		first += 1U;
   1d310:	3301      	adds	r3, #1
   1d312:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
   1d314:	2b02      	cmp	r3, #2
			first = 0U;
   1d316:	bf08      	it	eq
   1d318:	2300      	moveq	r3, #0
		pdu->first = first;
   1d31a:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
	radio_pkt_tx_set(pdu);
   1d31e:	f001 f9a5 	bl	1e66c <radio_pkt_tx_set>
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   1d322:	5d73      	ldrb	r3, [r6, r5]
   1d324:	f003 030f 	and.w	r3, r3, #15
   1d328:	2b02      	cmp	r3, #2
		radio_isr_set(isr_tx, lll);
   1d32a:	4621      	mov	r1, r4
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   1d32c:	d030      	beq.n	1d390 <chan_prepare+0xb4>
		radio_isr_set(isr_tx, lll);
   1d32e:	481b      	ldr	r0, [pc, #108]	; (1d39c <chan_prepare+0xc0>)
   1d330:	f001 f8e0 	bl	1e4f4 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
   1d334:	2096      	movs	r0, #150	; 0x96
   1d336:	f001 fa7d 	bl	1e834 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   1d33a:	2000      	movs	r0, #0
   1d33c:	f001 fa02 	bl	1e744 <radio_switch_complete_and_rx>
	chan = find_lsb_set(lll->chan_map_curr);
   1d340:	7b23      	ldrb	r3, [r4, #12]
   1d342:	f3c3 1302 	ubfx	r3, r3, #4, #3
   1d346:	2b00      	cmp	r3, #0
   1d348:	fa93 f0a3 	rbit	r0, r3
   1d34c:	fab0 f080 	clz	r0, r0
   1d350:	bf08      	it	eq
   1d352:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
	LL_ASSERT(chan);
   1d356:	1c45      	adds	r5, r0, #1
   1d358:	d10c      	bne.n	1d374 <chan_prepare+0x98>
   1d35a:	4a11      	ldr	r2, [pc, #68]	; (1d3a0 <chan_prepare+0xc4>)
   1d35c:	4911      	ldr	r1, [pc, #68]	; (1d3a4 <chan_prepare+0xc8>)
   1d35e:	4812      	ldr	r0, [pc, #72]	; (1d3a8 <chan_prepare+0xcc>)
   1d360:	f240 2379 	movw	r3, #633	; 0x279
   1d364:	f006 fdbd 	bl	23ee2 <printk>
   1d368:	4040      	eors	r0, r0
   1d36a:	f380 8811 	msr	BASEPRI, r0
   1d36e:	f04f 0003 	mov.w	r0, #3
   1d372:	df02      	svc	2
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
   1d374:	7b23      	ldrb	r3, [r4, #12]
   1d376:	f3c3 1202 	ubfx	r2, r3, #4, #3
   1d37a:	1e51      	subs	r1, r2, #1
   1d37c:	400a      	ands	r2, r1
   1d37e:	f362 1306 	bfi	r3, r2, #4, #3
   1d382:	7323      	strb	r3, [r4, #12]
	lll_chan_set(36 + chan);
   1d384:	f105 0024 	add.w	r0, r5, #36	; 0x24
}
   1d388:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	lll_chan_set(36 + chan);
   1d38c:	f7ff bd3a 	b.w	1ce04 <lll_chan_set>
		radio_isr_set(isr_done, lll);
   1d390:	4806      	ldr	r0, [pc, #24]	; (1d3ac <chan_prepare+0xd0>)
   1d392:	f001 f8af 	bl	1e4f4 <radio_isr_set>
		radio_switch_complete_and_disable();
   1d396:	f001 f9eb 	bl	1e770 <radio_switch_complete_and_disable>
   1d39a:	e7d1      	b.n	1d340 <chan_prepare+0x64>
   1d39c:	0001cf61 	.word	0x0001cf61
   1d3a0:	0003097d 	.word	0x0003097d
   1d3a4:	000304ad 	.word	0x000304ad
   1d3a8:	0002a5e8 	.word	0x0002a5e8
   1d3ac:	00028885 	.word	0x00028885

0001d3b0 <prepare_cb>:
{
   1d3b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct lll_adv *lll = prepare_param->param;
   1d3b2:	68c4      	ldr	r4, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
   1d3b4:	4b36      	ldr	r3, [pc, #216]	; (1d490 <prepare_cb+0xe0>)

static inline int lll_is_stop(void *lll)
{
	struct lll_hdr *hdr = lll;

	return !!hdr->is_stop;
   1d3b6:	7925      	ldrb	r5, [r4, #4]
   1d3b8:	9301      	str	r3, [sp, #4]
	if (lll_is_stop(lll)) {
   1d3ba:	f015 0501 	ands.w	r5, r5, #1
{
   1d3be:	4606      	mov	r6, r0
	if (lll_is_stop(lll)) {
   1d3c0:	d016      	beq.n	1d3f0 <prepare_cb+0x40>
		err = lll_hfclock_off();
   1d3c2:	f7ff fd99 	bl	1cef8 <lll_hfclock_off>
		LL_ASSERT(!err || err == -EBUSY);
   1d3c6:	b168      	cbz	r0, 1d3e4 <prepare_cb+0x34>
   1d3c8:	3010      	adds	r0, #16
   1d3ca:	d00b      	beq.n	1d3e4 <prepare_cb+0x34>
   1d3cc:	4a31      	ldr	r2, [pc, #196]	; (1d494 <prepare_cb+0xe4>)
   1d3ce:	4932      	ldr	r1, [pc, #200]	; (1d498 <prepare_cb+0xe8>)
   1d3d0:	4832      	ldr	r0, [pc, #200]	; (1d49c <prepare_cb+0xec>)
   1d3d2:	238b      	movs	r3, #139	; 0x8b
   1d3d4:	f006 fd85 	bl	23ee2 <printk>
   1d3d8:	4040      	eors	r0, r0
   1d3da:	f380 8811 	msr	BASEPRI, r0
   1d3de:	f04f 0003 	mov.w	r0, #3
   1d3e2:	df02      	svc	2
		lll_done(NULL);
   1d3e4:	2000      	movs	r0, #0
   1d3e6:	f7ff fcbb 	bl	1cd60 <lll_done>
}
   1d3ea:	2000      	movs	r0, #0
   1d3ec:	b003      	add	sp, #12
   1d3ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
	radio_reset();
   1d3f0:	f001 f8a0 	bl	1e534 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   1d3f4:	4628      	mov	r0, r5
   1d3f6:	f001 f8d1 	bl	1e59c <radio_tx_power_set>
	radio_phy_set(0, 0);
   1d3fa:	4629      	mov	r1, r5
   1d3fc:	4628      	mov	r0, r5
   1d3fe:	f001 f8bd 	bl	1e57c <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
   1d402:	462a      	mov	r2, r5
   1d404:	2125      	movs	r1, #37	; 0x25
   1d406:	2008      	movs	r0, #8
   1d408:	f001 f8fe 	bl	1e608 <radio_pkt_configure>
	radio_aa_set((u8_t *)&aa);
   1d40c:	a801      	add	r0, sp, #4
   1d40e:	f001 f8e3 	bl	1e5d8 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   1d412:	4923      	ldr	r1, [pc, #140]	; (1d4a0 <prepare_cb+0xf0>)
   1d414:	f240 605b 	movw	r0, #1627	; 0x65b
   1d418:	f001 f976 	bl	1e708 <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
   1d41c:	7b23      	ldrb	r3, [r4, #12]
   1d41e:	f3c3 0242 	ubfx	r2, r3, #1, #3
   1d422:	f362 1306 	bfi	r3, r2, #4, #3
   1d426:	7323      	strb	r3, [r4, #12]
	chan_prepare(lll);
   1d428:	4620      	mov	r0, r4
   1d42a:	f7ff ff57 	bl	1d2dc <chan_prepare>
	evt = HDR_LLL2EVT(lll);
   1d42e:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   1d430:	6835      	ldr	r5, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   1d432:	4638      	mov	r0, r7
   1d434:	f00b f9b5 	bl	287a2 <lll_evt_offset_get>
   1d438:	4405      	add	r5, r0
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
   1d43a:	6872      	ldr	r2, [r6, #4]
   1d43c:	f105 0109 	add.w	r1, r5, #9
   1d440:	2001      	movs	r0, #1
   1d442:	f001 fa03 	bl	1e84c <radio_tmr_start>
	radio_tmr_end_capture();
   1d446:	f001 fae1 	bl	1ea0c <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
   1d44a:	4620      	mov	r0, r4
   1d44c:	f7fd fe12 	bl	1b074 <ull_adv_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_ADV_BASE +
   1d450:	1c81      	adds	r1, r0, #2
   1d452:	462a      	mov	r2, r5
   1d454:	b2c9      	uxtb	r1, r1
   1d456:	4638      	mov	r0, r7
   1d458:	f00b f9b1 	bl	287be <lll_preempt_calc>
   1d45c:	b130      	cbz	r0, 1d46c <prepare_cb+0xbc>
		radio_isr_set(isr_abort, lll);
   1d45e:	4811      	ldr	r0, [pc, #68]	; (1d4a4 <prepare_cb+0xf4>)
   1d460:	4621      	mov	r1, r4
   1d462:	f001 f847 	bl	1e4f4 <radio_isr_set>
		radio_disable();
   1d466:	f001 f913 	bl	1e690 <radio_disable>
   1d46a:	e7be      	b.n	1d3ea <prepare_cb+0x3a>
		ret = lll_prepare_done(lll);
   1d46c:	4620      	mov	r0, r4
   1d46e:	f00b f996 	bl	2879e <lll_prepare_done>
		LL_ASSERT(!ret);
   1d472:	2800      	cmp	r0, #0
   1d474:	d0b9      	beq.n	1d3ea <prepare_cb+0x3a>
   1d476:	4a07      	ldr	r2, [pc, #28]	; (1d494 <prepare_cb+0xe4>)
   1d478:	490b      	ldr	r1, [pc, #44]	; (1d4a8 <prepare_cb+0xf8>)
   1d47a:	4808      	ldr	r0, [pc, #32]	; (1d49c <prepare_cb+0xec>)
   1d47c:	23e9      	movs	r3, #233	; 0xe9
   1d47e:	f006 fd30 	bl	23ee2 <printk>
   1d482:	4040      	eors	r0, r0
   1d484:	f380 8811 	msr	BASEPRI, r0
   1d488:	f04f 0003 	mov.w	r0, #3
   1d48c:	df02      	svc	2
   1d48e:	e7ac      	b.n	1d3ea <prepare_cb+0x3a>
   1d490:	8e89bed6 	.word	0x8e89bed6
   1d494:	0003097d 	.word	0x0003097d
   1d498:	000309c7 	.word	0x000309c7
   1d49c:	0002a5e8 	.word	0x0002a5e8
   1d4a0:	00555555 	.word	0x00555555
   1d4a4:	000287ef 	.word	0x000287ef
   1d4a8:	00030473 	.word	0x00030473

0001d4ac <lll_adv_prepare>:
{
   1d4ac:	b513      	push	{r0, r1, r4, lr}
   1d4ae:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   1d4b0:	f7ff fd1a 	bl	1cee8 <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1d4b4:	b168      	cbz	r0, 1d4d2 <lll_adv_prepare+0x26>
   1d4b6:	3044      	adds	r0, #68	; 0x44
   1d4b8:	d00b      	beq.n	1d4d2 <lll_adv_prepare+0x26>
   1d4ba:	4a12      	ldr	r2, [pc, #72]	; (1d504 <lll_adv_prepare+0x58>)
   1d4bc:	4912      	ldr	r1, [pc, #72]	; (1d508 <lll_adv_prepare+0x5c>)
   1d4be:	4813      	ldr	r0, [pc, #76]	; (1d50c <lll_adv_prepare+0x60>)
   1d4c0:	236e      	movs	r3, #110	; 0x6e
   1d4c2:	f006 fd0e 	bl	23ee2 <printk>
   1d4c6:	4040      	eors	r0, r0
   1d4c8:	f380 8811 	msr	BASEPRI, r0
   1d4cc:	f04f 0003 	mov.w	r0, #3
   1d4d0:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
   1d4d2:	4a0f      	ldr	r2, [pc, #60]	; (1d510 <lll_adv_prepare+0x64>)
   1d4d4:	490f      	ldr	r1, [pc, #60]	; (1d514 <lll_adv_prepare+0x68>)
   1d4d6:	4810      	ldr	r0, [pc, #64]	; (1d518 <lll_adv_prepare+0x6c>)
   1d4d8:	9400      	str	r4, [sp, #0]
   1d4da:	2300      	movs	r3, #0
   1d4dc:	f00b f956 	bl	2878c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1d4e0:	b168      	cbz	r0, 1d4fe <lll_adv_prepare+0x52>
   1d4e2:	3044      	adds	r0, #68	; 0x44
   1d4e4:	d00b      	beq.n	1d4fe <lll_adv_prepare+0x52>
   1d4e6:	4a07      	ldr	r2, [pc, #28]	; (1d504 <lll_adv_prepare+0x58>)
   1d4e8:	4907      	ldr	r1, [pc, #28]	; (1d508 <lll_adv_prepare+0x5c>)
   1d4ea:	4808      	ldr	r0, [pc, #32]	; (1d50c <lll_adv_prepare+0x60>)
   1d4ec:	2371      	movs	r3, #113	; 0x71
   1d4ee:	f006 fcf8 	bl	23ee2 <printk>
   1d4f2:	4040      	eors	r0, r0
   1d4f4:	f380 8811 	msr	BASEPRI, r0
   1d4f8:	f04f 0003 	mov.w	r0, #3
   1d4fc:	df02      	svc	2
}
   1d4fe:	b002      	add	sp, #8
   1d500:	bd10      	pop	{r4, pc}
   1d502:	bf00      	nop
   1d504:	0003097d 	.word	0x0003097d
   1d508:	000309ec 	.word	0x000309ec
   1d50c:	0002a5e8 	.word	0x0002a5e8
   1d510:	0001d3b1 	.word	0x0001d3b1
   1d514:	0001d059 	.word	0x0001d059
   1d518:	0001cfe9 	.word	0x0001cfe9

0001d51c <ticker_stop_cb>:
	lll_done(param);
}

static void ticker_stop_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
			   void *param)
{
   1d51c:	b508      	push	{r3, lr}
	radio_isr_set(isr_cleanup, param);
   1d51e:	4619      	mov	r1, r3
   1d520:	4803      	ldr	r0, [pc, #12]	; (1d530 <ticker_stop_cb+0x14>)
   1d522:	f000 ffe7 	bl	1e4f4 <radio_isr_set>
	radio_disable();
}
   1d526:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_disable();
   1d52a:	f001 b8b1 	b.w	1e690 <radio_disable>
   1d52e:	bf00      	nop
   1d530:	0001d901 	.word	0x0001d901

0001d534 <prepare_cb>:
{
   1d534:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_scan *lll = prepare_param->param;
   1d536:	68c4      	ldr	r4, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
   1d538:	4b59      	ldr	r3, [pc, #356]	; (1d6a0 <prepare_cb+0x16c>)
   1d53a:	7925      	ldrb	r5, [r4, #4]
{
   1d53c:	b08d      	sub	sp, #52	; 0x34
	if (lll_is_stop(lll)) {
   1d53e:	f015 0501 	ands.w	r5, r5, #1
{
   1d542:	4606      	mov	r6, r0
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
   1d544:	930b      	str	r3, [sp, #44]	; 0x2c
	if (lll_is_stop(lll)) {
   1d546:	d016      	beq.n	1d576 <prepare_cb+0x42>
		err = lll_hfclock_off();
   1d548:	f7ff fcd6 	bl	1cef8 <lll_hfclock_off>
		LL_ASSERT(!err || err == -EBUSY);
   1d54c:	b168      	cbz	r0, 1d56a <prepare_cb+0x36>
   1d54e:	3010      	adds	r0, #16
   1d550:	d00b      	beq.n	1d56a <prepare_cb+0x36>
   1d552:	4a54      	ldr	r2, [pc, #336]	; (1d6a4 <prepare_cb+0x170>)
   1d554:	4954      	ldr	r1, [pc, #336]	; (1d6a8 <prepare_cb+0x174>)
   1d556:	4855      	ldr	r0, [pc, #340]	; (1d6ac <prepare_cb+0x178>)
   1d558:	238b      	movs	r3, #139	; 0x8b
   1d55a:	f006 fcc2 	bl	23ee2 <printk>
   1d55e:	4040      	eors	r0, r0
   1d560:	f380 8811 	msr	BASEPRI, r0
   1d564:	f04f 0003 	mov.w	r0, #3
   1d568:	df02      	svc	2
		lll_done(NULL);
   1d56a:	2000      	movs	r0, #0
   1d56c:	f7ff fbf8 	bl	1cd60 <lll_done>
}
   1d570:	2000      	movs	r0, #0
   1d572:	b00d      	add	sp, #52	; 0x34
   1d574:	bdf0      	pop	{r4, r5, r6, r7, pc}
	radio_reset();
   1d576:	f000 ffdd 	bl	1e534 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   1d57a:	4628      	mov	r0, r5
   1d57c:	f001 f80e 	bl	1e59c <radio_tx_power_set>
	radio_phy_set(0, 0);
   1d580:	4629      	mov	r1, r5
   1d582:	4628      	mov	r0, r5
   1d584:	f000 fffa 	bl	1e57c <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
   1d588:	462a      	mov	r2, r5
   1d58a:	2125      	movs	r1, #37	; 0x25
   1d58c:	2008      	movs	r0, #8
   1d58e:	f001 f83b 	bl	1e608 <radio_pkt_configure>
	node_rx = ull_pdu_rx_alloc_peek(1);
   1d592:	2001      	movs	r0, #1
   1d594:	f7fd f8c4 	bl	1a720 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1d598:	4605      	mov	r5, r0
   1d59a:	b958      	cbnz	r0, 1d5b4 <prepare_cb+0x80>
   1d59c:	4a41      	ldr	r2, [pc, #260]	; (1d6a4 <prepare_cb+0x170>)
   1d59e:	4944      	ldr	r1, [pc, #272]	; (1d6b0 <prepare_cb+0x17c>)
   1d5a0:	4842      	ldr	r0, [pc, #264]	; (1d6ac <prepare_cb+0x178>)
   1d5a2:	23a4      	movs	r3, #164	; 0xa4
   1d5a4:	f006 fc9d 	bl	23ee2 <printk>
   1d5a8:	4040      	eors	r0, r0
   1d5aa:	f380 8811 	msr	BASEPRI, r0
   1d5ae:	f04f 0003 	mov.w	r0, #3
   1d5b2:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
   1d5b4:	f105 0020 	add.w	r0, r5, #32
   1d5b8:	f001 f852 	bl	1e660 <radio_pkt_rx_set>
	radio_aa_set((u8_t *)&aa);
   1d5bc:	a80b      	add	r0, sp, #44	; 0x2c
   1d5be:	f001 f80b 	bl	1e5d8 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   1d5c2:	493c      	ldr	r1, [pc, #240]	; (1d6b4 <prepare_cb+0x180>)
   1d5c4:	f240 605b 	movw	r0, #1627	; 0x65b
   1d5c8:	f001 f89e 	bl	1e708 <radio_crc_configure>
	lll_chan_set(37 + lll->chan);
   1d5cc:	7a20      	ldrb	r0, [r4, #8]
   1d5ce:	f3c0 0041 	ubfx	r0, r0, #1, #2
   1d5d2:	3025      	adds	r0, #37	; 0x25
   1d5d4:	f7ff fc16 	bl	1ce04 <lll_chan_set>
	radio_isr_set(isr_rx, lll);
   1d5d8:	4621      	mov	r1, r4
   1d5da:	4837      	ldr	r0, [pc, #220]	; (1d6b8 <prepare_cb+0x184>)
   1d5dc:	f000 ff8a 	bl	1e4f4 <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1d5e0:	2096      	movs	r0, #150	; 0x96
   1d5e2:	f001 f927 	bl	1e834 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1d5e6:	2300      	movs	r3, #0
   1d5e8:	461a      	mov	r2, r3
   1d5ea:	4619      	mov	r1, r3
   1d5ec:	4618      	mov	r0, r3
   1d5ee:	f001 f8b5 	bl	1e75c <radio_switch_complete_and_tx>
	evt = HDR_LLL2EVT(lll);
   1d5f2:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   1d5f4:	6835      	ldr	r5, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   1d5f6:	4638      	mov	r0, r7
   1d5f8:	f00b f8d3 	bl	287a2 <lll_evt_offset_get>
   1d5fc:	4405      	add	r5, r0
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   1d5fe:	6872      	ldr	r2, [r6, #4]
   1d600:	f105 0109 	add.w	r1, r5, #9
   1d604:	2000      	movs	r0, #0
   1d606:	f001 f921 	bl	1e84c <radio_tmr_start>
	radio_tmr_end_capture();
   1d60a:	f001 f9ff 	bl	1ea0c <radio_tmr_end_capture>
	radio_rssi_measure();
   1d60e:	f001 f8bd 	bl	1e78c <radio_rssi_measure>
				   ull_scan_lll_handle_get(lll)),
   1d612:	4620      	mov	r0, r4
   1d614:	f7fd fe80 	bl	1b318 <ull_scan_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_SCAN_BASE +
   1d618:	1d01      	adds	r1, r0, #4
   1d61a:	b2c9      	uxtb	r1, r1
   1d61c:	462a      	mov	r2, r5
   1d61e:	4638      	mov	r0, r7
   1d620:	f00b f8cd 	bl	287be <lll_preempt_calc>
   1d624:	4601      	mov	r1, r0
   1d626:	b130      	cbz	r0, 1d636 <prepare_cb+0x102>
		radio_isr_set(isr_abort, lll);
   1d628:	4824      	ldr	r0, [pc, #144]	; (1d6bc <prepare_cb+0x188>)
   1d62a:	4621      	mov	r1, r4
   1d62c:	f000 ff62 	bl	1e4f4 <radio_isr_set>
		radio_disable();
   1d630:	f001 f82e 	bl	1e690 <radio_disable>
   1d634:	e79c      	b.n	1d570 <prepare_cb+0x3c>
		if (lll->ticks_window) {
   1d636:	69a3      	ldr	r3, [r4, #24]
   1d638:	b1f3      	cbz	r3, 1d678 <prepare_cb+0x144>
			ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1d63a:	22fe      	movs	r2, #254	; 0xfe
   1d63c:	9208      	str	r2, [sp, #32]
   1d63e:	4a20      	ldr	r2, [pc, #128]	; (1d6c0 <prepare_cb+0x18c>)
   1d640:	e9cd 4206 	strd	r4, r2, [sp, #24]
   1d644:	4a1f      	ldr	r2, [pc, #124]	; (1d6c4 <prepare_cb+0x190>)
   1d646:	e9cd 3000 	strd	r3, r0, [sp]
   1d64a:	e9cd 0204 	strd	r0, r2, [sp, #16]
   1d64e:	462b      	mov	r3, r5
   1d650:	e9cd 0002 	strd	r0, r0, [sp, #8]
   1d654:	2203      	movs	r2, #3
   1d656:	f7fb fb03 	bl	18c60 <ticker_start>
			LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1d65a:	f030 0302 	bics.w	r3, r0, #2
   1d65e:	d00b      	beq.n	1d678 <prepare_cb+0x144>
   1d660:	4a10      	ldr	r2, [pc, #64]	; (1d6a4 <prepare_cb+0x170>)
   1d662:	4919      	ldr	r1, [pc, #100]	; (1d6c8 <prepare_cb+0x194>)
   1d664:	4811      	ldr	r0, [pc, #68]	; (1d6ac <prepare_cb+0x178>)
   1d666:	23ff      	movs	r3, #255	; 0xff
   1d668:	f006 fc3b 	bl	23ee2 <printk>
   1d66c:	4040      	eors	r0, r0
   1d66e:	f380 8811 	msr	BASEPRI, r0
   1d672:	f04f 0003 	mov.w	r0, #3
   1d676:	df02      	svc	2
		ret = lll_prepare_done(lll);
   1d678:	4620      	mov	r0, r4
   1d67a:	f00b f890 	bl	2879e <lll_prepare_done>
		LL_ASSERT(!ret);
   1d67e:	2800      	cmp	r0, #0
   1d680:	f43f af76 	beq.w	1d570 <prepare_cb+0x3c>
   1d684:	4a07      	ldr	r2, [pc, #28]	; (1d6a4 <prepare_cb+0x170>)
   1d686:	4911      	ldr	r1, [pc, #68]	; (1d6cc <prepare_cb+0x198>)
   1d688:	4808      	ldr	r0, [pc, #32]	; (1d6ac <prepare_cb+0x178>)
   1d68a:	f44f 7382 	mov.w	r3, #260	; 0x104
   1d68e:	f006 fc28 	bl	23ee2 <printk>
   1d692:	4040      	eors	r0, r0
   1d694:	f380 8811 	msr	BASEPRI, r0
   1d698:	f04f 0003 	mov.w	r0, #3
   1d69c:	df02      	svc	2
   1d69e:	e767      	b.n	1d570 <prepare_cb+0x3c>
   1d6a0:	8e89bed6 	.word	0x8e89bed6
   1d6a4:	00030a0f 	.word	0x00030a0f
   1d6a8:	000309c7 	.word	0x000309c7
   1d6ac:	0002a5e8 	.word	0x0002a5e8
   1d6b0:	00030a5a 	.word	0x00030a5a
   1d6b4:	00555555 	.word	0x00555555
   1d6b8:	0001d981 	.word	0x0001d981
   1d6bc:	00028939 	.word	0x00028939
   1d6c0:	0001d7f9 	.word	0x0001d7f9
   1d6c4:	0001d51d 	.word	0x0001d51d
   1d6c8:	00030518 	.word	0x00030518
   1d6cc:	00030473 	.word	0x00030473

0001d6d0 <isr_common_done>:

	radio_isr_set(isr_rx, param);
}

static void isr_common_done(void *param)
{
   1d6d0:	b538      	push	{r3, r4, r5, lr}
   1d6d2:	4605      	mov	r5, r0
	struct node_rx_pdu *node_rx;

	/* TODO: MOVE to a common interface, isr_lll_radio_status? */
	/* Clear radio status and events */
	radio_status_reset();
   1d6d4:	f000 ffee 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   1d6d8:	f001 f89c 	bl	1e814 <radio_tmr_status_reset>
	radio_filter_status_reset();
   1d6dc:	f001 f882 	bl	1e7e4 <radio_filter_status_reset>
	radio_ar_status_reset();
   1d6e0:	f001 f9ae 	bl	1ea40 <radio_ar_status_reset>
	radio_rssi_status_reset();
   1d6e4:	f001 f862 	bl	1e7ac <radio_rssi_status_reset>
		radio_gpio_pa_lna_disable();
	}
	/* TODO: MOVE ^^ */

	/* setup tIFS switching */
	radio_tmr_tifs_set(EVENT_IFS_US);
   1d6e8:	2096      	movs	r0, #150	; 0x96
   1d6ea:	f001 f8a3 	bl	1e834 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1d6ee:	2300      	movs	r3, #0
   1d6f0:	4618      	mov	r0, r3
   1d6f2:	461a      	mov	r2, r3
   1d6f4:	4619      	mov	r1, r3
   1d6f6:	f001 f831 	bl	1e75c <radio_switch_complete_and_tx>

	node_rx = ull_pdu_rx_alloc_peek(1);
   1d6fa:	2001      	movs	r0, #1
   1d6fc:	f7fd f810 	bl	1a720 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1d700:	4604      	mov	r4, r0
   1d702:	b960      	cbnz	r0, 1d71e <isr_common_done+0x4e>
   1d704:	4a0c      	ldr	r2, [pc, #48]	; (1d738 <isr_common_done+0x68>)
   1d706:	490d      	ldr	r1, [pc, #52]	; (1d73c <isr_common_done+0x6c>)
   1d708:	480d      	ldr	r0, [pc, #52]	; (1d740 <isr_common_done+0x70>)
   1d70a:	f44f 73fe 	mov.w	r3, #508	; 0x1fc
   1d70e:	f006 fbe8 	bl	23ee2 <printk>
   1d712:	4040      	eors	r0, r0
   1d714:	f380 8811 	msr	BASEPRI, r0
   1d718:	f04f 0003 	mov.w	r0, #3
   1d71c:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
   1d71e:	f104 0020 	add.w	r0, r4, #32
   1d722:	f000 ff9d 	bl	1e660 <radio_pkt_rx_set>

		radio_ar_configure(count, irks);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	radio_rssi_measure();
   1d726:	f001 f831 	bl	1e78c <radio_rssi_measure>

	radio_isr_set(isr_rx, param);
   1d72a:	4629      	mov	r1, r5
   1d72c:	4805      	ldr	r0, [pc, #20]	; (1d744 <isr_common_done+0x74>)
}
   1d72e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(isr_rx, param);
   1d732:	f000 bedf 	b.w	1e4f4 <radio_isr_set>
   1d736:	bf00      	nop
   1d738:	00030a0f 	.word	0x00030a0f
   1d73c:	00030a5a 	.word	0x00030a5a
   1d740:	0002a5e8 	.word	0x0002a5e8
   1d744:	0001d981 	.word	0x0001d981

0001d748 <isr_tx>:
{
   1d748:	b570      	push	{r4, r5, r6, lr}
   1d74a:	4605      	mov	r5, r0
	radio_status_reset();
   1d74c:	f000 ffb2 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   1d750:	f001 f860 	bl	1e814 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1d754:	2096      	movs	r0, #150	; 0x96
   1d756:	f001 f86d 	bl	1e834 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1d75a:	2300      	movs	r3, #0
   1d75c:	4618      	mov	r0, r3
   1d75e:	461a      	mov	r2, r3
   1d760:	4619      	mov	r1, r3
   1d762:	f000 fffb 	bl	1e75c <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
   1d766:	2001      	movs	r0, #1
   1d768:	f7fc ffda 	bl	1a720 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1d76c:	4604      	mov	r4, r0
   1d76e:	b960      	cbnz	r0, 1d78a <isr_tx+0x42>
   1d770:	4a1c      	ldr	r2, [pc, #112]	; (1d7e4 <isr_tx+0x9c>)
   1d772:	491d      	ldr	r1, [pc, #116]	; (1d7e8 <isr_tx+0xa0>)
   1d774:	481d      	ldr	r0, [pc, #116]	; (1d7ec <isr_tx+0xa4>)
   1d776:	f240 13c3 	movw	r3, #451	; 0x1c3
   1d77a:	f006 fbb2 	bl	23ee2 <printk>
   1d77e:	4040      	eors	r0, r0
   1d780:	f380 8811 	msr	BASEPRI, r0
   1d784:	f04f 0003 	mov.w	r0, #3
   1d788:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
   1d78a:	f104 0020 	add.w	r0, r4, #32
   1d78e:	f000 ff67 	bl	1e660 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
   1d792:	f000 ff9b 	bl	1e6cc <radio_is_ready>
   1d796:	b160      	cbz	r0, 1d7b2 <isr_tx+0x6a>
   1d798:	4a12      	ldr	r2, [pc, #72]	; (1d7e4 <isr_tx+0x9c>)
   1d79a:	4915      	ldr	r1, [pc, #84]	; (1d7f0 <isr_tx+0xa8>)
   1d79c:	4813      	ldr	r0, [pc, #76]	; (1d7ec <isr_tx+0xa4>)
   1d79e:	f240 13c7 	movw	r3, #455	; 0x1c7
   1d7a2:	f006 fb9e 	bl	23ee2 <printk>
   1d7a6:	4040      	eors	r0, r0
   1d7a8:	f380 8811 	msr	BASEPRI, r0
   1d7ac:	f04f 0003 	mov.w	r0, #3
   1d7b0:	df02      	svc	2
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1d7b2:	f001 f939 	bl	1ea28 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   1d7b6:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1d7b8:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   1d7ba:	4608      	mov	r0, r1
   1d7bc:	f00b f9d7 	bl	28b6e <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   1d7c0:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   1d7c2:	4606      	mov	r6, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   1d7c4:	4608      	mov	r0, r1
   1d7c6:	f00b f9ce 	bl	28b66 <radio_tx_chain_delay_get>
   1d7ca:	4434      	add	r4, r6
   1d7cc:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   1d7ce:	1a20      	subs	r0, r4, r0
   1d7d0:	f001 f8e4 	bl	1e99c <radio_tmr_hcto_configure>
	radio_rssi_measure();
   1d7d4:	f000 ffda 	bl	1e78c <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
   1d7d8:	4629      	mov	r1, r5
   1d7da:	4806      	ldr	r0, [pc, #24]	; (1d7f4 <isr_tx+0xac>)
}
   1d7dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	radio_isr_set(isr_rx, param);
   1d7e0:	f000 be88 	b.w	1e4f4 <radio_isr_set>
   1d7e4:	00030a0f 	.word	0x00030a0f
   1d7e8:	00030a5a 	.word	0x00030a5a
   1d7ec:	0002a5e8 	.word	0x0002a5e8
   1d7f0:	000309da 	.word	0x000309da
   1d7f4:	0001d981 	.word	0x0001d981

0001d7f8 <ticker_op_start_cb>:
{
   1d7f8:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1d7fa:	b160      	cbz	r0, 1d816 <ticker_op_start_cb+0x1e>
   1d7fc:	4a06      	ldr	r2, [pc, #24]	; (1d818 <ticker_op_start_cb+0x20>)
   1d7fe:	4907      	ldr	r1, [pc, #28]	; (1d81c <ticker_op_start_cb+0x24>)
   1d800:	4807      	ldr	r0, [pc, #28]	; (1d820 <ticker_op_start_cb+0x28>)
   1d802:	f44f 73b0 	mov.w	r3, #352	; 0x160
   1d806:	f006 fb6c 	bl	23ee2 <printk>
   1d80a:	4040      	eors	r0, r0
   1d80c:	f380 8811 	msr	BASEPRI, r0
   1d810:	f04f 0003 	mov.w	r0, #3
   1d814:	df02      	svc	2
}
   1d816:	bd08      	pop	{r3, pc}
   1d818:	00030a0f 	.word	0x00030a0f
   1d81c:	0003066c 	.word	0x0003066c
   1d820:	0002a5e8 	.word	0x0002a5e8

0001d824 <abort_cb>:
{
   1d824:	b510      	push	{r4, lr}
   1d826:	460c      	mov	r4, r1
	if (!prepare_param) {
   1d828:	b930      	cbnz	r0, 1d838 <abort_cb+0x14>
			radio_isr_set(isr_abort, param);
   1d82a:	480f      	ldr	r0, [pc, #60]	; (1d868 <abort_cb+0x44>)
   1d82c:	f000 fe62 	bl	1e4f4 <radio_isr_set>
}
   1d830:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			radio_disable();
   1d834:	f000 bf2c 	b.w	1e690 <radio_disable>
	err = lll_hfclock_off();
   1d838:	f7ff fb5e 	bl	1cef8 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
   1d83c:	b170      	cbz	r0, 1d85c <abort_cb+0x38>
   1d83e:	3010      	adds	r0, #16
   1d840:	d00c      	beq.n	1d85c <abort_cb+0x38>
   1d842:	4a0a      	ldr	r2, [pc, #40]	; (1d86c <abort_cb+0x48>)
   1d844:	490a      	ldr	r1, [pc, #40]	; (1d870 <abort_cb+0x4c>)
   1d846:	480b      	ldr	r0, [pc, #44]	; (1d874 <abort_cb+0x50>)
   1d848:	f44f 73a8 	mov.w	r3, #336	; 0x150
   1d84c:	f006 fb49 	bl	23ee2 <printk>
   1d850:	4040      	eors	r0, r0
   1d852:	f380 8811 	msr	BASEPRI, r0
   1d856:	f04f 0003 	mov.w	r0, #3
   1d85a:	df02      	svc	2
	lll_done(param);
   1d85c:	4620      	mov	r0, r4
}
   1d85e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   1d862:	f7ff ba7d 	b.w	1cd60 <lll_done>
   1d866:	bf00      	nop
   1d868:	00028939 	.word	0x00028939
   1d86c:	00030a0f 	.word	0x00030a0f
   1d870:	000309c7 	.word	0x000309c7
   1d874:	0002a5e8 	.word	0x0002a5e8

0001d878 <is_abort_cb>:
	if (next != curr) {
   1d878:	4282      	cmp	r2, r0
{
   1d87a:	b510      	push	{r4, lr}
   1d87c:	4614      	mov	r4, r2
	if (next != curr) {
   1d87e:	d019      	beq.n	1d8b4 <is_abort_cb+0x3c>
		*resume_cb = resume_prepare_cb;
   1d880:	4a1a      	ldr	r2, [pc, #104]	; (1d8ec <is_abort_cb+0x74>)
   1d882:	601a      	str	r2, [r3, #0]
		*resume_prio = 0; /* TODO: */
   1d884:	9b02      	ldr	r3, [sp, #8]
   1d886:	2200      	movs	r2, #0
   1d888:	601a      	str	r2, [r3, #0]
		err = lll_hfclock_on();
   1d88a:	f7ff fb2d 	bl	1cee8 <lll_hfclock_on>
		LL_ASSERT(!err || err == -EINPROGRESS);
   1d88e:	b170      	cbz	r0, 1d8ae <is_abort_cb+0x36>
   1d890:	3044      	adds	r0, #68	; 0x44
   1d892:	d00c      	beq.n	1d8ae <is_abort_cb+0x36>
   1d894:	4a16      	ldr	r2, [pc, #88]	; (1d8f0 <is_abort_cb+0x78>)
   1d896:	4917      	ldr	r1, [pc, #92]	; (1d8f4 <is_abort_cb+0x7c>)
   1d898:	4817      	ldr	r0, [pc, #92]	; (1d8f8 <is_abort_cb+0x80>)
   1d89a:	f44f 7393 	mov.w	r3, #294	; 0x126
   1d89e:	f006 fb20 	bl	23ee2 <printk>
   1d8a2:	4040      	eors	r0, r0
   1d8a4:	f380 8811 	msr	BASEPRI, r0
   1d8a8:	f04f 0003 	mov.w	r0, #3
   1d8ac:	df02      	svc	2
   1d8ae:	f06f 000a 	mvn.w	r0, #10
   1d8b2:	e019      	b.n	1d8e8 <is_abort_cb+0x70>
	radio_isr_set(isr_window, lll);
   1d8b4:	4611      	mov	r1, r2
   1d8b6:	4811      	ldr	r0, [pc, #68]	; (1d8fc <is_abort_cb+0x84>)
   1d8b8:	f000 fe1c 	bl	1e4f4 <radio_isr_set>
	radio_disable();
   1d8bc:	f000 fee8 	bl	1e690 <radio_disable>
	if (++lll->chan == 3U) {
   1d8c0:	7a23      	ldrb	r3, [r4, #8]
   1d8c2:	f3c3 0241 	ubfx	r2, r3, #1, #2
   1d8c6:	3201      	adds	r2, #1
   1d8c8:	f002 0203 	and.w	r2, r2, #3
   1d8cc:	2a03      	cmp	r2, #3
   1d8ce:	bf14      	ite	ne
   1d8d0:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
   1d8d4:	f36f 0342 	bfceq	r3, #1, #2
   1d8d8:	7223      	strb	r3, [r4, #8]
	lll_chan_set(37 + lll->chan);
   1d8da:	7a20      	ldrb	r0, [r4, #8]
   1d8dc:	f3c0 0041 	ubfx	r0, r0, #1, #2
   1d8e0:	3025      	adds	r0, #37	; 0x25
   1d8e2:	f7ff fa8f 	bl	1ce04 <lll_chan_set>
	return 0;
   1d8e6:	2000      	movs	r0, #0
}
   1d8e8:	bd10      	pop	{r4, pc}
   1d8ea:	bf00      	nop
   1d8ec:	000288f7 	.word	0x000288f7
   1d8f0:	00030a0f 	.word	0x00030a0f
   1d8f4:	000309ec 	.word	0x000309ec
   1d8f8:	0002a5e8 	.word	0x0002a5e8
   1d8fc:	0002891f 	.word	0x0002891f

0001d900 <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
   1d900:	b538      	push	{r3, r4, r5, lr}
   1d902:	4604      	mov	r4, r0
	struct lll_scan *lll = param;
	struct node_rx_hdr *node_rx;
	int err;

	if (lll_is_done(param)) {
   1d904:	f7ff fa76 	bl	1cdf4 <lll_is_done>
   1d908:	4605      	mov	r5, r0
   1d90a:	bb80      	cbnz	r0, 1d96e <isr_cleanup+0x6e>
		return;
	}

	radio_filter_disable();
   1d90c:	f000 ff60 	bl	1e7d0 <radio_filter_disable>

	if (++lll->chan == 3U) {
   1d910:	7a23      	ldrb	r3, [r4, #8]
	}
#else /* !CONFIG_BT_CTLR_SCAN_INDICATION */
	ARG_UNUSED(node_rx);
#endif /* !CONFIG_BT_CTLR_SCAN_INDICATION */

	radio_isr_set(isr_race, param);
   1d912:	4817      	ldr	r0, [pc, #92]	; (1d970 <isr_cleanup+0x70>)
	if (++lll->chan == 3U) {
   1d914:	f3c3 0241 	ubfx	r2, r3, #1, #2
   1d918:	3201      	adds	r2, #1
   1d91a:	f002 0203 	and.w	r2, r2, #3
   1d91e:	2a03      	cmp	r2, #3
   1d920:	bf14      	ite	ne
   1d922:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
   1d926:	f365 0342 	bfieq	r3, r5, #1, #2
   1d92a:	7223      	strb	r3, [r4, #8]
	radio_isr_set(isr_race, param);
   1d92c:	4621      	mov	r1, r4
   1d92e:	f000 fde1 	bl	1e4f4 <radio_isr_set>
	if (!radio_is_idle()) {
   1d932:	f000 fedf 	bl	1e6f4 <radio_is_idle>
   1d936:	b908      	cbnz	r0, 1d93c <isr_cleanup+0x3c>
		radio_disable();
   1d938:	f000 feaa 	bl	1e690 <radio_disable>
	}

	radio_tmr_stop();
   1d93c:	f001 f822 	bl	1e984 <radio_tmr_stop>

	err = lll_hfclock_off();
   1d940:	f7ff fada 	bl	1cef8 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
   1d944:	b170      	cbz	r0, 1d964 <isr_cleanup+0x64>
   1d946:	3010      	adds	r0, #16
   1d948:	d00c      	beq.n	1d964 <isr_cleanup+0x64>
   1d94a:	4a0a      	ldr	r2, [pc, #40]	; (1d974 <isr_cleanup+0x74>)
   1d94c:	490a      	ldr	r1, [pc, #40]	; (1d978 <isr_cleanup+0x78>)
   1d94e:	480b      	ldr	r0, [pc, #44]	; (1d97c <isr_cleanup+0x7c>)
   1d950:	f240 2387 	movw	r3, #647	; 0x287
   1d954:	f006 fac5 	bl	23ee2 <printk>
   1d958:	4040      	eors	r0, r0
   1d95a:	f380 8811 	msr	BASEPRI, r0
   1d95e:	f04f 0003 	mov.w	r0, #3
   1d962:	df02      	svc	2

	lll_done(NULL);
}
   1d964:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(NULL);
   1d968:	2000      	movs	r0, #0
   1d96a:	f7ff b9f9 	b.w	1cd60 <lll_done>
}
   1d96e:	bd38      	pop	{r3, r4, r5, pc}
   1d970:	000288e1 	.word	0x000288e1
   1d974:	00030a0f 	.word	0x00030a0f
   1d978:	000309c7 	.word	0x000309c7
   1d97c:	0002a5e8 	.word	0x0002a5e8

0001d980 <isr_rx>:
{
   1d980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d984:	4605      	mov	r5, r0
	trx_done = radio_is_done();
   1d986:	f000 feab 	bl	1e6e0 <radio_is_done>
	if (trx_done) {
   1d98a:	f010 04ff 	ands.w	r4, r0, #255	; 0xff
   1d98e:	f000 8096 	beq.w	1dabe <isr_rx+0x13e>
		crc_ok = radio_crc_is_valid();
   1d992:	f000 fec5 	bl	1e720 <radio_crc_is_valid>
   1d996:	fa5f f880 	uxtb.w	r8, r0
		devmatch_ok = radio_filter_has_match();
   1d99a:	f000 ff2b 	bl	1e7f4 <radio_filter_has_match>
   1d99e:	b2c7      	uxtb	r7, r0
		devmatch_id = radio_filter_match_get();
   1d9a0:	f000 ff32 	bl	1e808 <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
   1d9a4:	f001 f858 	bl	1ea58 <radio_ar_has_match>
		irkmatch_id = radio_ar_match_get();
   1d9a8:	f001 f844 	bl	1ea34 <radio_ar_match_get>
		rssi_ready = radio_rssi_is_ready();
   1d9ac:	f000 ff06 	bl	1e7bc <radio_rssi_is_ready>
   1d9b0:	b2c6      	uxtb	r6, r0
	radio_status_reset();
   1d9b2:	f000 fe7f 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   1d9b6:	f000 ff2d 	bl	1e814 <radio_tmr_status_reset>
	radio_filter_status_reset();
   1d9ba:	f000 ff13 	bl	1e7e4 <radio_filter_status_reset>
	radio_ar_status_reset();
   1d9be:	f001 f83f 	bl	1ea40 <radio_ar_status_reset>
	radio_rssi_status_reset();
   1d9c2:	f000 fef3 	bl	1e7ac <radio_rssi_status_reset>
	if (!trx_done) {
   1d9c6:	2c00      	cmp	r4, #0
   1d9c8:	f000 8095 	beq.w	1daf6 <isr_rx+0x176>
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
   1d9cc:	f1b8 0f00 	cmp.w	r8, #0
   1d9d0:	f000 8091 	beq.w	1daf6 <isr_rx+0x176>
		 (!devmatch_ok || ull_filter_lll_rl_idx_allowed(irkmatch_ok,
								rl_idx))) ||
		(((lll->filter_policy & 0x01) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(rl_idx)));
#else
	return ((lll->filter_policy & 0x01) == 0U) ||
   1d9d4:	7a2b      	ldrb	r3, [r5, #8]
   1d9d6:	0719      	lsls	r1, r3, #28
   1d9d8:	d502      	bpl.n	1d9e0 <isr_rx+0x60>
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
   1d9da:	2f00      	cmp	r7, #0
   1d9dc:	f000 808b 	beq.w	1daf6 <isr_rx+0x176>
{
	struct node_rx_pdu *node_rx;
	struct pdu_adv *pdu_adv_rx;
	bool dir_report = false;

	node_rx = ull_pdu_rx_alloc_peek(1);
   1d9e0:	2001      	movs	r0, #1
   1d9e2:	f7fc fe9d 	bl	1a720 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1d9e6:	4604      	mov	r4, r0
   1d9e8:	b960      	cbnz	r0, 1da04 <isr_rx+0x84>
   1d9ea:	4a67      	ldr	r2, [pc, #412]	; (1db88 <isr_rx+0x208>)
   1d9ec:	4967      	ldr	r1, [pc, #412]	; (1db8c <isr_rx+0x20c>)
   1d9ee:	4868      	ldr	r0, [pc, #416]	; (1db90 <isr_rx+0x210>)
   1d9f0:	f240 23aa 	movw	r3, #682	; 0x2aa
   1d9f4:	f006 fa75 	bl	23ee2 <printk>
   1d9f8:	4040      	eors	r0, r0
   1d9fa:	f380 8811 	msr	BASEPRI, r0
   1d9fe:	f04f 0003 	mov.w	r0, #3
   1da02:	df02      	svc	2

		return 0;
#endif /* CONFIG_BT_CENTRAL */

	/* Active scanner */
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   1da04:	f894 3020 	ldrb.w	r3, [r4, #32]
   1da08:	f013 020f 	ands.w	r2, r3, #15
   1da0c:	d002      	beq.n	1da14 <isr_rx+0x94>
   1da0e:	2a06      	cmp	r2, #6
   1da10:	f040 80b7 	bne.w	1db82 <isr_rx+0x202>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
   1da14:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
   1da18:	2925      	cmp	r1, #37	; 0x25
   1da1a:	d854      	bhi.n	1dac6 <isr_rx+0x146>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind)) &&
		   lll->type &&
   1da1c:	f995 1008 	ldrsb.w	r1, [r5, #8]
   1da20:	2900      	cmp	r1, #0
   1da22:	da50      	bge.n	1dac6 <isr_rx+0x146>
		bt_addr_t *lrpa;
#endif /* CONFIG_BT_CTLR_PRIVACY */
		u32_t err;

		/* setup tIFS switching */
		radio_tmr_tifs_set(EVENT_IFS_US);
   1da24:	2096      	movs	r0, #150	; 0x96
   1da26:	f000 ff05 	bl	1e834 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   1da2a:	2000      	movs	r0, #0
   1da2c:	f000 fe8a 	bl	1e744 <radio_switch_complete_and_rx>

		/* save the adv packet */
		err = isr_rx_scan_report(lll, rssi_ready,
   1da30:	4630      	mov	r0, r6
   1da32:	f00a ff9c 	bl	2896e <isr_rx_scan_report.isra.0>
					 irkmatch_ok ? rl_idx : FILTER_IDX_NONE,
					 false);
		if (err) {
   1da36:	2800      	cmp	r0, #0
   1da38:	d15d      	bne.n	1daf6 <isr_rx+0x176>
			return err;
		}

		/* prepare the scan request packet */
		pdu_tx = (void *)radio_pkt_scratch_get();
   1da3a:	f000 fe7f 	bl	1e73c <radio_pkt_scratch_get>
			       BDADDR_SIZE);
		} else {
#else
		if (1) {
#endif /* CONFIG_BT_CTLR_PRIVACY */
			pdu_tx->tx_addr = lll->init_addr_type;
   1da3e:	7a2b      	ldrb	r3, [r5, #8]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
   1da40:	f894 2020 	ldrb.w	r2, [r4, #32]
			pdu_tx->tx_addr = lll->init_addr_type;
   1da44:	f3c3 1380 	ubfx	r3, r3, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
   1da48:	019b      	lsls	r3, r3, #6
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
   1da4a:	f3c2 1280 	ubfx	r2, r2, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
   1da4e:	f043 0303 	orr.w	r3, r3, #3
   1da52:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   1da56:	7802      	ldrb	r2, [r0, #0]
   1da58:	f002 0230 	and.w	r2, r2, #48	; 0x30
   1da5c:	4313      	orrs	r3, r2
   1da5e:	7003      	strb	r3, [r0, #0]
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
   1da60:	230c      	movs	r3, #12
   1da62:	7043      	strb	r3, [r0, #1]
		pdu_tx = (void *)radio_pkt_scratch_get();
   1da64:	4606      	mov	r6, r0
			memcpy(&pdu_tx->scan_req.scan_addr[0],
   1da66:	2206      	movs	r2, #6
   1da68:	f105 0109 	add.w	r1, r5, #9
   1da6c:	3002      	adds	r0, #2
   1da6e:	f008 f91b 	bl	25ca8 <memcpy>
			       &lll->init_addr[0], BDADDR_SIZE);
		}
		memcpy(&pdu_tx->scan_req.adv_addr[0],
   1da72:	2206      	movs	r2, #6
   1da74:	f104 0122 	add.w	r1, r4, #34	; 0x22
   1da78:	f106 0008 	add.w	r0, r6, #8
   1da7c:	f008 f914 	bl	25ca8 <memcpy>
		       &pdu_adv_rx->adv_ind.addr[0], BDADDR_SIZE);

		radio_pkt_tx_set(pdu_tx);
   1da80:	4630      	mov	r0, r6
   1da82:	f000 fdf3 	bl	1e66c <radio_pkt_tx_set>

		/* assert if radio packet ptr is not set and radio started tx */
		LL_ASSERT(!radio_is_ready());
   1da86:	f000 fe21 	bl	1e6cc <radio_is_ready>
   1da8a:	b160      	cbz	r0, 1daa6 <isr_rx+0x126>
   1da8c:	4a3e      	ldr	r2, [pc, #248]	; (1db88 <isr_rx+0x208>)
   1da8e:	4941      	ldr	r1, [pc, #260]	; (1db94 <isr_rx+0x214>)
   1da90:	483f      	ldr	r0, [pc, #252]	; (1db90 <isr_rx+0x210>)
   1da92:	f44f 7369 	mov.w	r3, #932	; 0x3a4
   1da96:	f006 fa24 	bl	23ee2 <printk>
   1da9a:	4040      	eors	r0, r0
   1da9c:	f380 8811 	msr	BASEPRI, r0
   1daa0:	f04f 0003 	mov.w	r0, #3
   1daa4:	df02      	svc	2
			lll_prof_cputime_capture();

		}

		/* capture end of Tx-ed PDU, used to calculate HCTO. */
		radio_tmr_end_capture();
   1daa6:	f000 ffb1 	bl	1ea0c <radio_tmr_end_capture>
					 radio_rx_chain_delay_get(0, 0) -
					 CONFIG_BT_CTLR_GPIO_PA_OFFSET);
#endif /* CONFIG_BT_CTLR_GPIO_PA_PIN */

		/* switch scanner state to active */
		lll->state = 1U;
   1daaa:	7a2b      	ldrb	r3, [r5, #8]
		radio_isr_set(isr_tx, lll);
   1daac:	483a      	ldr	r0, [pc, #232]	; (1db98 <isr_rx+0x218>)
		lll->state = 1U;
   1daae:	f043 0301 	orr.w	r3, r3, #1
   1dab2:	722b      	strb	r3, [r5, #8]
		radio_isr_set(isr_tx, lll);
   1dab4:	4629      	mov	r1, r5
}
   1dab6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		radio_isr_set(isr_tx, lll);
   1daba:	f000 bd1b 	b.w	1e4f4 <radio_isr_set>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
   1dabe:	4626      	mov	r6, r4
   1dac0:	4627      	mov	r7, r4
   1dac2:	46a0      	mov	r8, r4
   1dac4:	e775      	b.n	1d9b2 <isr_rx+0x32>

		return 0;
	}
	/* Passive scanner or scan responses */
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   1dac6:	f013 0f0d 	tst.w	r3, #13
   1daca:	d001      	beq.n	1dad0 <isr_rx+0x150>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_NONCONN_IND) ||
   1dacc:	2a06      	cmp	r2, #6
   1dace:	d10a      	bne.n	1dae6 <isr_rx+0x166>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
   1dad0:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
   1dad4:	2925      	cmp	r1, #37	; 0x25
   1dad6:	d806      	bhi.n	1dae6 <isr_rx+0x166>
		   (lll->phy)) ||
#endif /* CONFIG_BT_CTLR_ADV_EXT */
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
		   (lll->state != 0U) &&
		   isr_scan_rsp_adva_matches(pdu_adv_rx))) &&
   1dad8:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
   1dadc:	b15b      	cbz	r3, 1daf6 <isr_rx+0x176>
		   1) {
#endif /* !CONFIG_BT_CENTRAL */
		u32_t err;

		/* save the scan response packet */
		err = isr_rx_scan_report(lll, rssi_ready,
   1dade:	4630      	mov	r0, r6
   1dae0:	f00a ff45 	bl	2896e <isr_rx_scan_report.isra.0>
					 irkmatch_ok ? rl_idx :
						       FILTER_IDX_NONE,
					 dir_report);
		if (err) {
   1dae4:	e007      	b.n	1daf6 <isr_rx+0x176>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
   1dae6:	2a01      	cmp	r2, #1
   1dae8:	d00d      	beq.n	1db06 <isr_rx+0x186>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
   1daea:	f894 3020 	ldrb.w	r3, [r4, #32]
					&dir_report))) ||
   1daee:	f003 030f 	and.w	r3, r3, #15
   1daf2:	2b04      	cmp	r3, #4
   1daf4:	d02b      	beq.n	1db4e <isr_rx+0x1ce>
	radio_isr_set(isr_done, lll);
   1daf6:	4629      	mov	r1, r5
   1daf8:	4828      	ldr	r0, [pc, #160]	; (1db9c <isr_rx+0x21c>)
   1dafa:	f000 fcfb 	bl	1e4f4 <radio_isr_set>
}
   1dafe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	radio_disable();
   1db02:	f000 bdc5 	b.w	1e690 <radio_disable>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_DIRECT_IND) &&
   1db06:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
   1db0a:	2a0c      	cmp	r2, #12
   1db0c:	d1f3      	bne.n	1daf6 <isr_rx+0x176>
		 */
		return false;
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return (((lll->init_addr_type == pdu->rx_addr) &&
   1db0e:	7a2a      	ldrb	r2, [r5, #8]
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
			BDADDR_SIZE))) ||
   1db10:	f3c2 1280 	ubfx	r2, r2, #6, #1
   1db14:	ebb2 1fd3 	cmp.w	r2, r3, lsr #7
   1db18:	d00f      	beq.n	1db3a <isr_rx+0x1ba>

static inline bool isr_scan_tgta_rpa_check(struct lll_scan *lll,
					   struct pdu_adv *pdu,
					   bool *dir_report)
{
	if (((lll->filter_policy & 0x02) != 0U) &&
   1db1a:	7a2b      	ldrb	r3, [r5, #8]
   1db1c:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   1db20:	079a      	lsls	r2, r3, #30
   1db22:	d5e2      	bpl.n	1daea <isr_rx+0x16a>
   1db24:	f994 3020 	ldrsb.w	r3, [r4, #32]
   1db28:	2b00      	cmp	r3, #0
   1db2a:	dade      	bge.n	1daea <isr_rx+0x16a>
		   (pdu_adv_rx->len == sizeof(struct pdu_adv_direct_ind)) &&
   1db2c:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   1db30:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1db34:	2b40      	cmp	r3, #64	; 0x40
   1db36:	d0cf      	beq.n	1dad8 <isr_rx+0x158>
   1db38:	e7d7      	b.n	1daea <isr_rx+0x16a>
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
   1db3a:	2206      	movs	r2, #6
   1db3c:	f104 0128 	add.w	r1, r4, #40	; 0x28
   1db40:	f105 0009 	add.w	r0, r5, #9
   1db44:	f008 f8a0 	bl	25c88 <memcmp>
	return (((lll->init_addr_type == pdu->rx_addr) &&
   1db48:	2800      	cmp	r0, #0
   1db4a:	d0c5      	beq.n	1dad8 <isr_rx+0x158>
   1db4c:	e7e5      	b.n	1db1a <isr_rx+0x19a>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
   1db4e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
   1db52:	2b25      	cmp	r3, #37	; 0x25
   1db54:	d8cf      	bhi.n	1daf6 <isr_rx+0x176>
		   (lll->state != 0U) &&
   1db56:	7a2b      	ldrb	r3, [r5, #8]
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
   1db58:	07db      	lsls	r3, r3, #31
   1db5a:	d5cc      	bpl.n	1daf6 <isr_rx+0x176>
	return false;
}

static inline bool isr_scan_rsp_adva_matches(struct pdu_adv *srsp)
{
	struct pdu_adv *sreq = (void *)radio_pkt_scratch_get();
   1db5c:	f000 fdee 	bl	1e73c <radio_pkt_scratch_get>

	return ((sreq->rx_addr == srsp->tx_addr) &&
   1db60:	f894 3020 	ldrb.w	r3, [r4, #32]
   1db64:	7802      	ldrb	r2, [r0, #0]
   1db66:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1db6a:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   1db6e:	d1c2      	bne.n	1daf6 <isr_rx+0x176>
		(memcmp(&sreq->scan_req.adv_addr[0],
   1db70:	2206      	movs	r2, #6
   1db72:	f104 0122 	add.w	r1, r4, #34	; 0x22
   1db76:	3008      	adds	r0, #8
   1db78:	f008 f886 	bl	25c88 <memcmp>
		   (lll->state != 0U) &&
   1db7c:	2800      	cmp	r0, #0
   1db7e:	d0ab      	beq.n	1dad8 <isr_rx+0x158>
   1db80:	e7b9      	b.n	1daf6 <isr_rx+0x176>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   1db82:	2a02      	cmp	r2, #2
   1db84:	e7a3      	b.n	1dace <isr_rx+0x14e>
   1db86:	bf00      	nop
   1db88:	00030a0f 	.word	0x00030a0f
   1db8c:	00030a5a 	.word	0x00030a5a
   1db90:	0002a5e8 	.word	0x0002a5e8
   1db94:	000309da 	.word	0x000309da
   1db98:	0001d749 	.word	0x0001d749
   1db9c:	000288e5 	.word	0x000288e5

0001dba0 <lll_scan_prepare>:
{
   1dba0:	b513      	push	{r0, r1, r4, lr}
   1dba2:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   1dba4:	f7ff f9a0 	bl	1cee8 <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1dba8:	b168      	cbz	r0, 1dbc6 <lll_scan_prepare+0x26>
   1dbaa:	3044      	adds	r0, #68	; 0x44
   1dbac:	d00b      	beq.n	1dbc6 <lll_scan_prepare+0x26>
   1dbae:	4a12      	ldr	r2, [pc, #72]	; (1dbf8 <lll_scan_prepare+0x58>)
   1dbb0:	4912      	ldr	r1, [pc, #72]	; (1dbfc <lll_scan_prepare+0x5c>)
   1dbb2:	4813      	ldr	r0, [pc, #76]	; (1dc00 <lll_scan_prepare+0x60>)
   1dbb4:	236d      	movs	r3, #109	; 0x6d
   1dbb6:	f006 f994 	bl	23ee2 <printk>
   1dbba:	4040      	eors	r0, r0
   1dbbc:	f380 8811 	msr	BASEPRI, r0
   1dbc0:	f04f 0003 	mov.w	r0, #3
   1dbc4:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
   1dbc6:	4a0f      	ldr	r2, [pc, #60]	; (1dc04 <lll_scan_prepare+0x64>)
   1dbc8:	490f      	ldr	r1, [pc, #60]	; (1dc08 <lll_scan_prepare+0x68>)
   1dbca:	4810      	ldr	r0, [pc, #64]	; (1dc0c <lll_scan_prepare+0x6c>)
   1dbcc:	9400      	str	r4, [sp, #0]
   1dbce:	2300      	movs	r3, #0
   1dbd0:	f00a fddc 	bl	2878c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1dbd4:	b168      	cbz	r0, 1dbf2 <lll_scan_prepare+0x52>
   1dbd6:	3044      	adds	r0, #68	; 0x44
   1dbd8:	d00b      	beq.n	1dbf2 <lll_scan_prepare+0x52>
   1dbda:	4a07      	ldr	r2, [pc, #28]	; (1dbf8 <lll_scan_prepare+0x58>)
   1dbdc:	4907      	ldr	r1, [pc, #28]	; (1dbfc <lll_scan_prepare+0x5c>)
   1dbde:	4808      	ldr	r0, [pc, #32]	; (1dc00 <lll_scan_prepare+0x60>)
   1dbe0:	2370      	movs	r3, #112	; 0x70
   1dbe2:	f006 f97e 	bl	23ee2 <printk>
   1dbe6:	4040      	eors	r0, r0
   1dbe8:	f380 8811 	msr	BASEPRI, r0
   1dbec:	f04f 0003 	mov.w	r0, #3
   1dbf0:	df02      	svc	2
}
   1dbf2:	b002      	add	sp, #8
   1dbf4:	bd10      	pop	{r4, pc}
   1dbf6:	bf00      	nop
   1dbf8:	00030a0f 	.word	0x00030a0f
   1dbfc:	000309ec 	.word	0x000309ec
   1dc00:	0002a5e8 	.word	0x0002a5e8
   1dc04:	0001d535 	.word	0x0001d535
   1dc08:	0001d825 	.word	0x0001d825
   1dc0c:	0001d879 	.word	0x0001d879

0001dc10 <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
   1dc10:	b508      	push	{r3, lr}
   1dc12:	4601      	mov	r1, r0
	int err;

	radio_isr_set(isr_race, param);
   1dc14:	4810      	ldr	r0, [pc, #64]	; (1dc58 <isr_cleanup+0x48>)
   1dc16:	f000 fc6d 	bl	1e4f4 <radio_isr_set>
	if (!radio_is_idle()) {
   1dc1a:	f000 fd6b 	bl	1e6f4 <radio_is_idle>
   1dc1e:	b908      	cbnz	r0, 1dc24 <isr_cleanup+0x14>
		radio_disable();
   1dc20:	f000 fd36 	bl	1e690 <radio_disable>
	}

	radio_tmr_stop();
   1dc24:	f000 feae 	bl	1e984 <radio_tmr_stop>

	err = lll_hfclock_off();
   1dc28:	f7ff f966 	bl	1cef8 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
   1dc2c:	b170      	cbz	r0, 1dc4c <isr_cleanup+0x3c>
   1dc2e:	3010      	adds	r0, #16
   1dc30:	d00c      	beq.n	1dc4c <isr_cleanup+0x3c>
   1dc32:	4a0a      	ldr	r2, [pc, #40]	; (1dc5c <isr_cleanup+0x4c>)
   1dc34:	490a      	ldr	r1, [pc, #40]	; (1dc60 <isr_cleanup+0x50>)
   1dc36:	480b      	ldr	r0, [pc, #44]	; (1dc64 <isr_cleanup+0x54>)
   1dc38:	f240 2383 	movw	r3, #643	; 0x283
   1dc3c:	f006 f951 	bl	23ee2 <printk>
   1dc40:	4040      	eors	r0, r0
   1dc42:	f380 8811 	msr	BASEPRI, r0
   1dc46:	f04f 0003 	mov.w	r0, #3
   1dc4a:	df02      	svc	2

	lll_done(NULL);
}
   1dc4c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   1dc50:	2000      	movs	r0, #0
   1dc52:	f7ff b885 	b.w	1cd60 <lll_done>
   1dc56:	bf00      	nop
   1dc58:	000289b7 	.word	0x000289b7
   1dc5c:	00030a73 	.word	0x00030a73
   1dc60:	000309c7 	.word	0x000309c7
   1dc64:	0002a5e8 	.word	0x0002a5e8

0001dc68 <isr_done>:
{
   1dc68:	b570      	push	{r4, r5, r6, lr}
   1dc6a:	4605      	mov	r5, r0
	radio_status_reset();
   1dc6c:	f000 fd22 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   1dc70:	f000 fdd0 	bl	1e814 <radio_tmr_status_reset>
	radio_filter_status_reset();
   1dc74:	f000 fdb6 	bl	1e7e4 <radio_filter_status_reset>
	radio_ar_status_reset();
   1dc78:	f000 fee2 	bl	1ea40 <radio_ar_status_reset>
	radio_rssi_status_reset();
   1dc7c:	f000 fd96 	bl	1e7ac <radio_rssi_status_reset>
	e = ull_event_done_extra_get();
   1dc80:	f7fc ff28 	bl	1aad4 <ull_event_done_extra_get>
	LL_ASSERT(e);
   1dc84:	4604      	mov	r4, r0
   1dc86:	b960      	cbnz	r0, 1dca2 <isr_done+0x3a>
   1dc88:	4a16      	ldr	r2, [pc, #88]	; (1dce4 <isr_done+0x7c>)
   1dc8a:	4917      	ldr	r1, [pc, #92]	; (1dce8 <isr_done+0x80>)
   1dc8c:	4817      	ldr	r0, [pc, #92]	; (1dcec <isr_done+0x84>)
   1dc8e:	f240 234e 	movw	r3, #590	; 0x24e
   1dc92:	f006 f926 	bl	23ee2 <printk>
   1dc96:	4040      	eors	r0, r0
   1dc98:	f380 8811 	msr	BASEPRI, r0
   1dc9c:	f04f 0003 	mov.w	r0, #3
   1dca0:	df02      	svc	2
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   1dca2:	2301      	movs	r3, #1
   1dca4:	7023      	strb	r3, [r4, #0]
	e->trx_cnt = trx_cnt;
   1dca6:	4b12      	ldr	r3, [pc, #72]	; (1dcf0 <isr_done+0x88>)
	e->crc_valid = crc_valid;
   1dca8:	4a12      	ldr	r2, [pc, #72]	; (1dcf4 <isr_done+0x8c>)
	e->trx_cnt = trx_cnt;
   1dcaa:	881b      	ldrh	r3, [r3, #0]
	e->crc_valid = crc_valid;
   1dcac:	7812      	ldrb	r2, [r2, #0]
	e->trx_cnt = trx_cnt;
   1dcae:	80a3      	strh	r3, [r4, #4]
	e->crc_valid = crc_valid;
   1dcb0:	71a2      	strb	r2, [r4, #6]
	if (trx_cnt) {
   1dcb2:	b18b      	cbz	r3, 1dcd8 <isr_done+0x70>
		if (lll->role) {
   1dcb4:	f995 3021 	ldrsb.w	r3, [r5, #33]	; 0x21
   1dcb8:	2b00      	cmp	r3, #0
   1dcba:	da0d      	bge.n	1dcd8 <isr_done+0x70>
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   1dcbc:	f000 fe9a 	bl	1e9f4 <radio_tmr_aa_restore>
   1dcc0:	4606      	mov	r6, r0
   1dcc2:	f000 fe9d 	bl	1ea00 <radio_tmr_ready_get>
			e->slave.window_widening_event_us =
   1dcc6:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   1dcc8:	60e3      	str	r3, [r4, #12]
			e->slave.preamble_to_addr_us = preamble_to_addr_us;
   1dcca:	2328      	movs	r3, #40	; 0x28
   1dccc:	6123      	str	r3, [r4, #16]
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   1dcce:	1a36      	subs	r6, r6, r0
			lll->slave.window_widening_event_us = 0;
   1dcd0:	2300      	movs	r3, #0
			e->slave.start_to_address_actual_us =
   1dcd2:	60a6      	str	r6, [r4, #8]
			lll->slave.window_widening_event_us = 0;
   1dcd4:	636b      	str	r3, [r5, #52]	; 0x34
			lll->slave.window_size_event_us = 0;
   1dcd6:	63eb      	str	r3, [r5, #60]	; 0x3c
	isr_cleanup(param);
   1dcd8:	4628      	mov	r0, r5
}
   1dcda:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	isr_cleanup(param);
   1dcde:	f7ff bf97 	b.w	1dc10 <isr_cleanup>
   1dce2:	bf00      	nop
   1dce4:	00030a73 	.word	0x00030a73
   1dce8:	0002fe24 	.word	0x0002fe24
   1dcec:	0002a5e8 	.word	0x0002a5e8
   1dcf0:	20001f2e 	.word	0x20001f2e
   1dcf4:	200024da 	.word	0x200024da

0001dcf8 <lll_conn_ppm_get>:
}
   1dcf8:	4b01      	ldr	r3, [pc, #4]	; (1dd00 <lll_conn_ppm_get+0x8>)
   1dcfa:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   1dcfe:	4770      	bx	lr
   1dd00:	0002a558 	.word	0x0002a558

0001dd04 <lll_conn_prepare_reset>:
	trx_cnt = 0U;
   1dd04:	4a03      	ldr	r2, [pc, #12]	; (1dd14 <lll_conn_prepare_reset+0x10>)
   1dd06:	2300      	movs	r3, #0
   1dd08:	8013      	strh	r3, [r2, #0]
	crc_expire = 0U;
   1dd0a:	4a03      	ldr	r2, [pc, #12]	; (1dd18 <lll_conn_prepare_reset+0x14>)
   1dd0c:	7013      	strb	r3, [r2, #0]
	crc_valid = 0U;
   1dd0e:	4a03      	ldr	r2, [pc, #12]	; (1dd1c <lll_conn_prepare_reset+0x18>)
   1dd10:	7013      	strb	r3, [r2, #0]
}
   1dd12:	4770      	bx	lr
   1dd14:	20001f2e 	.word	0x20001f2e
   1dd18:	200024d9 	.word	0x200024d9
   1dd1c:	200024da 	.word	0x200024da

0001dd20 <lll_conn_abort_cb>:
{
   1dd20:	b510      	push	{r4, lr}
   1dd22:	460c      	mov	r4, r1
	if (!prepare_param) {
   1dd24:	b930      	cbnz	r0, 1dd34 <lll_conn_abort_cb+0x14>
		radio_isr_set(isr_done, param);
   1dd26:	480e      	ldr	r0, [pc, #56]	; (1dd60 <lll_conn_abort_cb+0x40>)
   1dd28:	f000 fbe4 	bl	1e4f4 <radio_isr_set>
}
   1dd2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   1dd30:	f000 bcae 	b.w	1e690 <radio_disable>
	err = lll_hfclock_off();
   1dd34:	f7ff f8e0 	bl	1cef8 <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
   1dd38:	b168      	cbz	r0, 1dd56 <lll_conn_abort_cb+0x36>
   1dd3a:	3010      	adds	r0, #16
   1dd3c:	d00b      	beq.n	1dd56 <lll_conn_abort_cb+0x36>
   1dd3e:	4a09      	ldr	r2, [pc, #36]	; (1dd64 <lll_conn_abort_cb+0x44>)
   1dd40:	4909      	ldr	r1, [pc, #36]	; (1dd68 <lll_conn_abort_cb+0x48>)
   1dd42:	480a      	ldr	r0, [pc, #40]	; (1dd6c <lll_conn_abort_cb+0x4c>)
   1dd44:	2382      	movs	r3, #130	; 0x82
   1dd46:	f006 f8cc 	bl	23ee2 <printk>
   1dd4a:	4040      	eors	r0, r0
   1dd4c:	f380 8811 	msr	BASEPRI, r0
   1dd50:	f04f 0003 	mov.w	r0, #3
   1dd54:	df02      	svc	2
	lll_done(param);
   1dd56:	4620      	mov	r0, r4
}
   1dd58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   1dd5c:	f7ff b800 	b.w	1cd60 <lll_done>
   1dd60:	0001dc69 	.word	0x0001dc69
   1dd64:	00030a73 	.word	0x00030a73
   1dd68:	000309c7 	.word	0x000309c7
   1dd6c:	0002a5e8 	.word	0x0002a5e8

0001dd70 <lll_conn_rx_pkt_set>:
{
   1dd70:	b510      	push	{r4, lr}
	node_rx = ull_pdu_rx_alloc_peek(1);
   1dd72:	2001      	movs	r0, #1
   1dd74:	f7fc fcd4 	bl	1a720 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1dd78:	4604      	mov	r4, r0
   1dd7a:	b960      	cbnz	r0, 1dd96 <lll_conn_rx_pkt_set+0x26>
   1dd7c:	4a0d      	ldr	r2, [pc, #52]	; (1ddb4 <lll_conn_rx_pkt_set+0x44>)
   1dd7e:	490e      	ldr	r1, [pc, #56]	; (1ddb8 <lll_conn_rx_pkt_set+0x48>)
   1dd80:	480e      	ldr	r0, [pc, #56]	; (1ddbc <lll_conn_rx_pkt_set+0x4c>)
   1dd82:	f240 13bf 	movw	r3, #447	; 0x1bf
   1dd86:	f006 f8ac 	bl	23ee2 <printk>
   1dd8a:	4040      	eors	r0, r0
   1dd8c:	f380 8811 	msr	BASEPRI, r0
   1dd90:	f04f 0003 	mov.w	r0, #3
   1dd94:	df02      	svc	2
	radio_phy_set(phy, 0);
   1dd96:	2100      	movs	r1, #0
   1dd98:	4608      	mov	r0, r1
   1dd9a:	f000 fbef 	bl	1e57c <radio_phy_set>
		radio_pkt_configure(8, max_rx_octets, (phy << 1) | 0x01);
   1dd9e:	2008      	movs	r0, #8
   1dda0:	2201      	movs	r2, #1
   1dda2:	211b      	movs	r1, #27
   1dda4:	f000 fc30 	bl	1e608 <radio_pkt_configure>
		radio_pkt_rx_set(node_rx->pdu);
   1dda8:	f104 0020 	add.w	r0, r4, #32
}
   1ddac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_pkt_rx_set(node_rx->pdu);
   1ddb0:	f000 bc56 	b.w	1e660 <radio_pkt_rx_set>
   1ddb4:	00030a73 	.word	0x00030a73
   1ddb8:	00030a5a 	.word	0x00030a5a
   1ddbc:	0002a5e8 	.word	0x0002a5e8

0001ddc0 <lll_conn_isr_tx>:
{
   1ddc0:	b570      	push	{r4, r5, r6, lr}
   1ddc2:	4605      	mov	r5, r0
	radio_status_reset();
   1ddc4:	f000 fc76 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   1ddc8:	f000 fd24 	bl	1e814 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1ddcc:	2096      	movs	r0, #150	; 0x96
   1ddce:	f000 fd31 	bl	1e834 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1ddd2:	2300      	movs	r3, #0
   1ddd4:	4618      	mov	r0, r3
   1ddd6:	461a      	mov	r2, r3
   1ddd8:	4619      	mov	r1, r3
   1ddda:	f000 fcbf 	bl	1e75c <radio_switch_complete_and_tx>
	lll_conn_rx_pkt_set(lll);
   1ddde:	4628      	mov	r0, r5
   1dde0:	f7ff ffc6 	bl	1dd70 <lll_conn_rx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   1dde4:	f000 fc72 	bl	1e6cc <radio_is_ready>
   1dde8:	b160      	cbz	r0, 1de04 <lll_conn_isr_tx+0x44>
   1ddea:	4a12      	ldr	r2, [pc, #72]	; (1de34 <lll_conn_isr_tx+0x74>)
   1ddec:	4912      	ldr	r1, [pc, #72]	; (1de38 <lll_conn_isr_tx+0x78>)
   1ddee:	4813      	ldr	r0, [pc, #76]	; (1de3c <lll_conn_isr_tx+0x7c>)
   1ddf0:	f44f 73bd 	mov.w	r3, #378	; 0x17a
   1ddf4:	f006 f875 	bl	23ee2 <printk>
   1ddf8:	4040      	eors	r0, r0
   1ddfa:	f380 8811 	msr	BASEPRI, r0
   1ddfe:	f04f 0003 	mov.w	r0, #3
   1de02:	df02      	svc	2
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 +
   1de04:	f000 fe10 	bl	1ea28 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   1de08:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 +
   1de0a:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   1de0c:	4608      	mov	r0, r1
   1de0e:	f00a feae 	bl	28b6e <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   1de12:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   1de14:	4606      	mov	r6, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   1de16:	4608      	mov	r0, r1
   1de18:	f00a fea5 	bl	28b66 <radio_tx_chain_delay_get>
   1de1c:	4434      	add	r4, r6
   1de1e:	34cb      	adds	r4, #203	; 0xcb
	radio_tmr_hcto_configure(hcto);
   1de20:	1a20      	subs	r0, r4, r0
   1de22:	f000 fdbb 	bl	1e99c <radio_tmr_hcto_configure>
	radio_isr_set(lll_conn_isr_rx, param);
   1de26:	4629      	mov	r1, r5
   1de28:	4805      	ldr	r0, [pc, #20]	; (1de40 <lll_conn_isr_tx+0x80>)
}
   1de2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	radio_isr_set(lll_conn_isr_rx, param);
   1de2e:	f000 bb61 	b.w	1e4f4 <radio_isr_set>
   1de32:	bf00      	nop
   1de34:	00030a73 	.word	0x00030a73
   1de38:	000309da 	.word	0x000309da
   1de3c:	0002a5e8 	.word	0x0002a5e8
   1de40:	0001de45 	.word	0x0001de45

0001de44 <lll_conn_isr_rx>:
{
   1de44:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1de48:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   1de4a:	f000 fc49 	bl	1e6e0 <radio_is_done>
	if (trx_done) {
   1de4e:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
   1de52:	d014      	beq.n	1de7e <lll_conn_isr_rx+0x3a>
		crc_ok = radio_crc_is_valid();
   1de54:	f000 fc64 	bl	1e720 <radio_crc_is_valid>
   1de58:	b2c7      	uxtb	r7, r0
		rssi_ready = radio_rssi_is_ready();
   1de5a:	f000 fcaf 	bl	1e7bc <radio_rssi_is_ready>
	radio_status_reset();
   1de5e:	f000 fc29 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   1de62:	f000 fcd7 	bl	1e814 <radio_tmr_status_reset>
	radio_rssi_status_reset();
   1de66:	f000 fca1 	bl	1e7ac <radio_rssi_status_reset>
	if (!trx_done) {
   1de6a:	b955      	cbnz	r5, 1de82 <lll_conn_isr_rx+0x3e>
		radio_isr_set(isr_done, param);
   1de6c:	4894      	ldr	r0, [pc, #592]	; (1e0c0 <lll_conn_isr_rx+0x27c>)
   1de6e:	4621      	mov	r1, r4
   1de70:	f000 fb40 	bl	1e4f4 <radio_isr_set>
		radio_disable();
   1de74:	f000 fc0c 	bl	1e690 <radio_disable>
}
   1de78:	b002      	add	sp, #8
   1de7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		crc_ok = rssi_ready = 0U;
   1de7e:	462f      	mov	r7, r5
   1de80:	e7ed      	b.n	1de5e <lll_conn_isr_rx+0x1a>
	trx_cnt++;
   1de82:	4a90      	ldr	r2, [pc, #576]	; (1e0c4 <lll_conn_isr_rx+0x280>)
   1de84:	8813      	ldrh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   1de86:	2001      	movs	r0, #1
	trx_cnt++;
   1de88:	3301      	adds	r3, #1
   1de8a:	8013      	strh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   1de8c:	f7fc fc48 	bl	1a720 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1de90:	4606      	mov	r6, r0
   1de92:	b958      	cbnz	r0, 1deac <lll_conn_isr_rx+0x68>
   1de94:	4a8c      	ldr	r2, [pc, #560]	; (1e0c8 <lll_conn_isr_rx+0x284>)
   1de96:	498d      	ldr	r1, [pc, #564]	; (1e0cc <lll_conn_isr_rx+0x288>)
   1de98:	488d      	ldr	r0, [pc, #564]	; (1e0d0 <lll_conn_isr_rx+0x28c>)
   1de9a:	23b8      	movs	r3, #184	; 0xb8
   1de9c:	f006 f821 	bl	23ee2 <printk>
   1dea0:	4040      	eors	r0, r0
   1dea2:	f380 8811 	msr	BASEPRI, r0
   1dea6:	f04f 0003 	mov.w	r0, #3
   1deaa:	df02      	svc	2
	if (crc_ok) {
   1deac:	f8df 9234 	ldr.w	r9, [pc, #564]	; 1e0e4 <lll_conn_isr_rx+0x2a0>
   1deb0:	2f00      	cmp	r7, #0
   1deb2:	f000 80e6 	beq.w	1e082 <lll_conn_isr_rx+0x23e>

static int isr_rx_pdu(struct lll_conn *lll, struct pdu_data *pdu_data_rx,
		      struct node_tx **tx_release, u8_t *is_rx_enqueue)
{
	/* Ack for tx-ed data */
	if (pdu_data_rx->nesn != lll->sn) {
   1deb6:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
   1deba:	f896 1020 	ldrb.w	r1, [r6, #32]
   1debe:	f003 0201 	and.w	r2, r3, #1
   1dec2:	f3c1 0180 	ubfx	r1, r1, #2, #1
   1dec6:	4291      	cmp	r1, r2
   1dec8:	f000 80a5 	beq.w	1e016 <lll_conn_isr_rx+0x1d2>
		struct node_tx *tx;
		memq_link_t *link;

		/* Increment serial number */
		lll->sn++;
   1decc:	f082 0201 	eor.w	r2, r2, #1
   1ded0:	f362 0300 	bfi	r3, r2, #0, #1
   1ded4:	f884 3056 	strb.w	r3, [r4, #86]	; 0x56

#if defined(CONFIG_BT_PERIPHERAL)
		/* First ack (and redundantly any other ack) enable use of
		 * slave latency.
		 */
		if (lll->role) {
   1ded8:	f994 3021 	ldrsb.w	r3, [r4, #33]	; 0x21
   1dedc:	2b00      	cmp	r3, #0
			lll->slave.latency_enabled = 1;
   1dede:	bfbe      	ittt	lt
   1dee0:	f894 3024 	ldrblt.w	r3, [r4, #36]	; 0x24
   1dee4:	f043 0301 	orrlt.w	r3, r3, #1
   1dee8:	f884 3024 	strblt.w	r3, [r4, #36]	; 0x24
		}
#endif /* CONFIG_BT_PERIPHERAL */

		if (!lll->empty) {
   1deec:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
   1def0:	f013 0504 	ands.w	r5, r3, #4
   1def4:	f040 808b 	bne.w	1e00e <lll_conn_isr_rx+0x1ca>
			link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail,
   1def8:	e9d4 0110 	ldrd	r0, r1, [r4, #64]	; 0x40
   1defc:	aa01      	add	r2, sp, #4
   1defe:	f00a f926 	bl	2814e <memq_peek>
		} else {
			lll->empty = 0;
			link = NULL;
		}

		if (link) {
   1df02:	4680      	mov	r8, r0
   1df04:	2800      	cmp	r0, #0
   1df06:	f040 8089 	bne.w	1e01c <lll_conn_isr_rx+0x1d8>
			}
		}
	}

	/* process received data */
	if ((pdu_data_rx->sn == lll->nesn) &&
   1df0a:	f896 2020 	ldrb.w	r2, [r6, #32]
   1df0e:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
   1df12:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   1df16:	f3c3 0340 	ubfx	r3, r3, #1, #1
   1df1a:	429a      	cmp	r2, r3
   1df1c:	f000 809d 	beq.w	1e05a <lll_conn_isr_rx+0x216>
	u8_t is_rx_enqueue = 0U;
   1df20:	f04f 0a00 	mov.w	sl, #0
		crc_valid = 1U;
   1df24:	4b6b      	ldr	r3, [pc, #428]	; (1e0d4 <lll_conn_isr_rx+0x290>)
		crc_expire = 0U;
   1df26:	2500      	movs	r5, #0
		crc_valid = 1U;
   1df28:	2201      	movs	r2, #1
		crc_expire = 0U;
   1df2a:	f889 5000 	strb.w	r5, [r9]
		crc_valid = 1U;
   1df2e:	701a      	strb	r2, [r3, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   1df30:	a901      	add	r1, sp, #4
   1df32:	4620      	mov	r0, r4
   1df34:	f00a fd8a 	bl	28a4c <lll_conn_pdu_tx_prep>
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
   1df38:	2d00      	cmp	r5, #0
   1df3a:	f040 80b5 	bne.w	1e0a8 <lll_conn_isr_rx+0x264>
   1df3e:	b147      	cbz	r7, 1df52 <lll_conn_isr_rx+0x10e>
   1df40:	f896 3020 	ldrb.w	r3, [r6, #32]
   1df44:	06db      	lsls	r3, r3, #27
   1df46:	d404      	bmi.n	1df52 <lll_conn_isr_rx+0x10e>
				     (pdu_data_tx->len == 0));
   1df48:	9b01      	ldr	r3, [sp, #4]
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
   1df4a:	785b      	ldrb	r3, [r3, #1]
   1df4c:	2b00      	cmp	r3, #0
   1df4e:	f000 80ab 	beq.w	1e0a8 <lll_conn_isr_rx+0x264>
		radio_tmr_tifs_set(EVENT_IFS_US);
   1df52:	2096      	movs	r0, #150	; 0x96
   1df54:	f000 fc6e 	bl	1e834 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   1df58:	2000      	movs	r0, #0
   1df5a:	f000 fbf3 	bl	1e744 <radio_switch_complete_and_rx>
		radio_isr_set(lll_conn_isr_tx, param);
   1df5e:	485e      	ldr	r0, [pc, #376]	; (1e0d8 <lll_conn_isr_rx+0x294>)
   1df60:	4621      	mov	r1, r4
   1df62:	f000 fac7 	bl	1e4f4 <radio_isr_set>
		radio_tmr_end_capture();
   1df66:	f000 fd51 	bl	1ea0c <radio_tmr_end_capture>
	pdu_data_tx->sn = lll->sn;
   1df6a:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
   1df6e:	9901      	ldr	r1, [sp, #4]
   1df70:	f3c3 0200 	ubfx	r2, r3, #0, #1
	pdu_data_tx->nesn = lll->nesn;
   1df74:	f3c3 0340 	ubfx	r3, r3, #1, #1
   1df78:	009b      	lsls	r3, r3, #2
   1df7a:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
   1df7e:	780a      	ldrb	r2, [r1, #0]
   1df80:	f022 020c 	bic.w	r2, r2, #12
   1df84:	4313      	orrs	r3, r2
   1df86:	700b      	strb	r3, [r1, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
   1df88:	4620      	mov	r0, r4
   1df8a:	f00a fd4f 	bl	28a2c <lll_conn_tx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   1df8e:	f000 fb9d 	bl	1e6cc <radio_is_ready>
   1df92:	b160      	cbz	r0, 1dfae <lll_conn_isr_rx+0x16a>
   1df94:	4a4c      	ldr	r2, [pc, #304]	; (1e0c8 <lll_conn_isr_rx+0x284>)
   1df96:	4951      	ldr	r1, [pc, #324]	; (1e0dc <lll_conn_isr_rx+0x298>)
   1df98:	484d      	ldr	r0, [pc, #308]	; (1e0d0 <lll_conn_isr_rx+0x28c>)
   1df9a:	f44f 7391 	mov.w	r3, #290	; 0x122
   1df9e:	f005 ffa0 	bl	23ee2 <printk>
   1dfa2:	4040      	eors	r0, r0
   1dfa4:	f380 8811 	msr	BASEPRI, r0
   1dfa8:	f04f 0003 	mov.w	r0, #3
   1dfac:	df02      	svc	2
	if (!radio_tmr_aa_restore()) {
   1dfae:	f000 fd21 	bl	1e9f4 <radio_tmr_aa_restore>
   1dfb2:	b918      	cbnz	r0, 1dfbc <lll_conn_isr_rx+0x178>
		radio_tmr_aa_save(radio_tmr_aa_get());
   1dfb4:	f000 fd12 	bl	1e9dc <radio_tmr_aa_get>
   1dfb8:	f000 fd16 	bl	1e9e8 <radio_tmr_aa_save>
	if (tx_release) {
   1dfbc:	f1b8 0f00 	cmp.w	r8, #0
   1dfc0:	d079      	beq.n	1e0b6 <lll_conn_isr_rx+0x272>
		LL_ASSERT(lll->handle != 0xFFFF);
   1dfc2:	8a22      	ldrh	r2, [r4, #16]
   1dfc4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1dfc8:	429a      	cmp	r2, r3
   1dfca:	d10c      	bne.n	1dfe6 <lll_conn_isr_rx+0x1a2>
   1dfcc:	4a3e      	ldr	r2, [pc, #248]	; (1e0c8 <lll_conn_isr_rx+0x284>)
   1dfce:	4944      	ldr	r1, [pc, #272]	; (1e0e0 <lll_conn_isr_rx+0x29c>)
   1dfd0:	483f      	ldr	r0, [pc, #252]	; (1e0d0 <lll_conn_isr_rx+0x28c>)
   1dfd2:	f240 132f 	movw	r3, #303	; 0x12f
   1dfd6:	f005 ff84 	bl	23ee2 <printk>
   1dfda:	4040      	eors	r0, r0
   1dfdc:	f380 8811 	msr	BASEPRI, r0
   1dfe0:	f04f 0003 	mov.w	r0, #3
   1dfe4:	df02      	svc	2
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
   1dfe6:	8a20      	ldrh	r0, [r4, #16]
   1dfe8:	4641      	mov	r1, r8
   1dfea:	f7fe fbaf 	bl	1c74c <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
   1dfee:	f1ba 0f00 	cmp.w	sl, #0
   1dff2:	d009      	beq.n	1e008 <lll_conn_isr_rx+0x1c4>
		ull_pdu_rx_alloc();
   1dff4:	f7fc fbac 	bl	1a750 <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   1dff8:	2302      	movs	r3, #2
   1dffa:	7133      	strb	r3, [r6, #4]
		node_rx->hdr.handle = lll->handle;
   1dffc:	8a23      	ldrh	r3, [r4, #16]
		ull_rx_put(node_rx->hdr.link, node_rx);
   1dffe:	6830      	ldr	r0, [r6, #0]
		node_rx->hdr.handle = lll->handle;
   1e000:	80f3      	strh	r3, [r6, #6]
		ull_rx_put(node_rx->hdr.link, node_rx);
   1e002:	4631      	mov	r1, r6
   1e004:	f7fc fbba 	bl	1a77c <ull_rx_put>
		ull_rx_sched();
   1e008:	f7fc fbc8 	bl	1a79c <ull_rx_sched>
	ARG_UNUSED(rssi_ready);
   1e00c:	e734      	b.n	1de78 <lll_conn_isr_rx+0x34>
			lll->empty = 0;
   1e00e:	f36f 0382 	bfc	r3, #2, #1
   1e012:	f884 3056 	strb.w	r3, [r4, #86]	; 0x56
	struct node_tx *tx_release = NULL;
   1e016:	f04f 0800 	mov.w	r8, #0
   1e01a:	e776      	b.n	1df0a <lll_conn_isr_rx+0xc6>
					       lll->packet_tx_head_offset);
   1e01c:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
			pdu_data_tx_len = pdu_data_tx->len;
   1e020:	9a01      	ldr	r2, [sp, #4]
   1e022:	441a      	add	r2, r3
			offset = lll->packet_tx_head_offset + pdu_data_tx_len;
   1e024:	7952      	ldrb	r2, [r2, #5]
   1e026:	4413      	add	r3, r2
			if (offset < lll->packet_tx_head_len) {
   1e028:	f894 2054 	ldrb.w	r2, [r4, #84]	; 0x54
			offset = lll->packet_tx_head_offset + pdu_data_tx_len;
   1e02c:	b2db      	uxtb	r3, r3
			if (offset < lll->packet_tx_head_len) {
   1e02e:	4293      	cmp	r3, r2
   1e030:	d202      	bcs.n	1e038 <lll_conn_isr_rx+0x1f4>
				lll->packet_tx_head_offset = offset;
   1e032:	f884 3055 	strb.w	r3, [r4, #85]	; 0x55
   1e036:	e7ee      	b.n	1e016 <lll_conn_isr_rx+0x1d2>
			} else if (offset == lll->packet_tx_head_len) {
   1e038:	d1ed      	bne.n	1e016 <lll_conn_isr_rx+0x1d2>
				memq_dequeue(lll->memq_tx.tail,
   1e03a:	462a      	mov	r2, r5
   1e03c:	6c60      	ldr	r0, [r4, #68]	; 0x44
				lll->packet_tx_head_len = 0;
   1e03e:	f8a4 5054 	strh.w	r5, [r4, #84]	; 0x54
				memq_dequeue(lll->memq_tx.tail,
   1e042:	f104 0140 	add.w	r1, r4, #64	; 0x40
   1e046:	f00a f88a 	bl	2815e <memq_dequeue>
				link->next = tx->next; /* Indicates ctrl or data
   1e04a:	9b01      	ldr	r3, [sp, #4]
   1e04c:	681a      	ldr	r2, [r3, #0]
   1e04e:	f8c8 2000 	str.w	r2, [r8]
				tx->next = link;
   1e052:	f8c3 8000 	str.w	r8, [r3]
   1e056:	4698      	mov	r8, r3
   1e058:	e757      	b.n	1df0a <lll_conn_isr_rx+0xc6>
	    /* check so that we will NEVER use the rx buffer reserved for empty
	     * packet and internal control enqueue
	     */
	    (ull_pdu_rx_alloc_peek(3) != 0)) {
   1e05a:	2003      	movs	r0, #3
   1e05c:	f7fc fb60 	bl	1a720 <ull_pdu_rx_alloc_peek>
	if ((pdu_data_rx->sn == lll->nesn) &&
   1e060:	2800      	cmp	r0, #0
   1e062:	f43f af5d 	beq.w	1df20 <lll_conn_isr_rx+0xdc>
		/* Increment next expected serial number */
		lll->nesn++;
   1e066:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
   1e06a:	f083 0302 	eor.w	r3, r3, #2
   1e06e:	f884 3056 	strb.w	r3, [r4, #86]	; 0x56

		if (pdu_data_rx->len != 0) {
   1e072:	f896 a021 	ldrb.w	sl, [r6, #33]	; 0x21
	u8_t is_rx_enqueue = 0U;
   1e076:	f1ba 0a00 	subs.w	sl, sl, #0
   1e07a:	bf18      	it	ne
   1e07c:	f04f 0a01 	movne.w	sl, #1
   1e080:	e750      	b.n	1df24 <lll_conn_isr_rx+0xe0>
		if (crc_expire == 0U) {
   1e082:	f899 3000 	ldrb.w	r3, [r9]
   1e086:	b913      	cbnz	r3, 1e08e <lll_conn_isr_rx+0x24a>
			crc_expire = 2U;
   1e088:	2302      	movs	r3, #2
   1e08a:	f889 3000 	strb.w	r3, [r9]
		crc_expire--;
   1e08e:	f899 5000 	ldrb.w	r5, [r9]
   1e092:	3d01      	subs	r5, #1
   1e094:	b2ed      	uxtb	r5, r5
   1e096:	f889 5000 	strb.w	r5, [r9]
	u8_t is_rx_enqueue = 0U;
   1e09a:	f04f 0a00 	mov.w	sl, #0
		is_crc_backoff = (crc_expire == 0U);
   1e09e:	fab5 f585 	clz	r5, r5
   1e0a2:	096d      	lsrs	r5, r5, #5
	struct node_tx *tx_release = NULL;
   1e0a4:	46d0      	mov	r8, sl
   1e0a6:	e743      	b.n	1df30 <lll_conn_isr_rx+0xec>
		radio_isr_set(isr_done, param);
   1e0a8:	4805      	ldr	r0, [pc, #20]	; (1e0c0 <lll_conn_isr_rx+0x27c>)
   1e0aa:	4621      	mov	r1, r4
   1e0ac:	f000 fa22 	bl	1e4f4 <radio_isr_set>
			radio_switch_complete_and_disable();
   1e0b0:	f000 fb5e 	bl	1e770 <radio_switch_complete_and_disable>
   1e0b4:	e759      	b.n	1df6a <lll_conn_isr_rx+0x126>
	if (is_rx_enqueue) {
   1e0b6:	f1ba 0f00 	cmp.w	sl, #0
   1e0ba:	f43f aedd 	beq.w	1de78 <lll_conn_isr_rx+0x34>
   1e0be:	e799      	b.n	1dff4 <lll_conn_isr_rx+0x1b0>
   1e0c0:	0001dc69 	.word	0x0001dc69
   1e0c4:	20001f2e 	.word	0x20001f2e
   1e0c8:	00030a73 	.word	0x00030a73
   1e0cc:	00030a5a 	.word	0x00030a5a
   1e0d0:	0002a5e8 	.word	0x0002a5e8
   1e0d4:	200024da 	.word	0x200024da
   1e0d8:	0001ddc1 	.word	0x0001ddc1
   1e0dc:	000309da 	.word	0x000309da
   1e0e0:	00030abe 	.word	0x00030abe
   1e0e4:	200024d9 	.word	0x200024d9

0001e0e8 <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *prepare_param)
{
   1e0e8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct lll_conn *lll = prepare_param->param;
   1e0ec:	68c4      	ldr	r4, [r0, #12]

	DEBUG_RADIO_START_S(1);

	/* TODO: Do the below in ULL ?  */

	lazy = prepare_param->lazy;
   1e0ee:	8903      	ldrh	r3, [r0, #8]

	/* Calc window widening */
	if (lll->role) {
   1e0f0:	f994 2021 	ldrsb.w	r2, [r4, #33]	; 0x21
   1e0f4:	2a00      	cmp	r2, #0
{
   1e0f6:	4606      	mov	r6, r0
	if (lll->role) {
   1e0f8:	da09      	bge.n	1e10e <prepare_cb+0x26>
		lll->slave.window_widening_prepare_us +=
		    lll->slave.window_widening_periodic_us * (lazy + 1);
   1e0fa:	6aa2      	ldr	r2, [r4, #40]	; 0x28
		lll->slave.window_widening_prepare_us +=
   1e0fc:	6b21      	ldr	r1, [r4, #48]	; 0x30
		    lll->slave.window_widening_periodic_us * (lazy + 1);
   1e0fe:	fb03 2202 	mla	r2, r3, r2, r2
		lll->slave.window_widening_prepare_us +=
   1e102:	440a      	add	r2, r1
		if (lll->slave.window_widening_prepare_us >
		    lll->slave.window_widening_max_us) {
   1e104:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			lll->slave.window_widening_prepare_us =
   1e106:	4291      	cmp	r1, r2
   1e108:	bf94      	ite	ls
   1e10a:	6321      	strls	r1, [r4, #48]	; 0x30
   1e10c:	6322      	strhi	r2, [r4, #48]	; 0x30
				lll->slave.window_widening_max_us;
		}
	}

	/* save the latency for use in event */
	lll->latency_prepare += lazy;
   1e10e:	8ae2      	ldrh	r2, [r4, #22]
   1e110:	4413      	add	r3, r2

	/* calc current event counter value */
	event_counter = lll->event_counter + lll->latency_prepare;
   1e112:	8b62      	ldrh	r2, [r4, #26]
	lll->latency_prepare += lazy;
   1e114:	b29b      	uxth	r3, r3
   1e116:	82e3      	strh	r3, [r4, #22]
	event_counter = lll->event_counter + lll->latency_prepare;
   1e118:	4413      	add	r3, r2

	/* store the next event counter value */
	lll->event_counter = event_counter + 1;
   1e11a:	3301      	adds	r3, #1
   1e11c:	8363      	strh	r3, [r4, #26]

	/* TODO: Do the above in ULL ?  */

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
   1e11e:	f7ff fdf1 	bl	1dd04 <lll_conn_prepare_reset>

	/* TODO: can we do something in ULL? */
	lll->latency_event = lll->latency_prepare;
	lll->latency_prepare = 0;

	if (lll->data_chan_sel) {
   1e122:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	lll->latency_event = lll->latency_prepare;
   1e126:	8ae2      	ldrh	r2, [r4, #22]
   1e128:	8322      	strh	r2, [r4, #24]
	lll->latency_prepare = 0;
   1e12a:	2700      	movs	r7, #0
	if (lll->data_chan_sel) {
   1e12c:	0659      	lsls	r1, r3, #25
	lll->latency_prepare = 0;
   1e12e:	82e7      	strh	r7, [r4, #22]
	if (lll->data_chan_sel) {
   1e130:	d57a      	bpl.n	1e228 <prepare_cb+0x140>
					       lll->data_chan_id,
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
#else /* !CONFIG_BT_CTLR_CHAN_SEL_2 */
		data_chan_use = 0;
		LL_ASSERT(0);
   1e132:	4a4d      	ldr	r2, [pc, #308]	; (1e268 <prepare_cb+0x180>)
   1e134:	494d      	ldr	r1, [pc, #308]	; (1e26c <prepare_cb+0x184>)
   1e136:	484e      	ldr	r0, [pc, #312]	; (1e270 <prepare_cb+0x188>)
   1e138:	2389      	movs	r3, #137	; 0x89
   1e13a:	f005 fed2 	bl	23ee2 <printk>
   1e13e:	4040      	eors	r0, r0
   1e140:	f380 8811 	msr	BASEPRI, r0
   1e144:	f04f 0003 	mov.w	r0, #3
   1e148:	df02      	svc	2
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* current window widening */
	lll->slave.window_widening_event_us +=
   1e14a:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
   1e14e:	4413      	add	r3, r2
		lll->slave.window_widening_prepare_us;
	lll->slave.window_widening_prepare_us = 0;
	if (lll->slave.window_widening_event_us >
	    lll->slave.window_widening_max_us) {
   1e150:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
		lll->slave.window_widening_event_us =
   1e152:	429a      	cmp	r2, r3
   1e154:	bf94      	ite	ls
   1e156:	6362      	strls	r2, [r4, #52]	; 0x34
   1e158:	6363      	strhi	r3, [r4, #52]	; 0x34
			lll->slave.window_widening_max_us;
	}

	/* current window size */
	lll->slave.window_size_event_us +=
   1e15a:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
   1e15e:	2500      	movs	r5, #0
	lll->slave.window_size_event_us +=
   1e160:	4413      	add	r3, r2
		lll->slave.window_size_prepare_us;
	lll->slave.window_size_prepare_us = 0;
   1e162:	e9c4 530e 	strd	r5, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
   1e166:	6325      	str	r5, [r4, #48]	; 0x30

	/* Start setting up Radio h/w */
	radio_reset();
   1e168:	f000 f9e4 	bl	1e534 <radio_reset>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   1e16c:	4628      	mov	r0, r5
   1e16e:	f000 fa15 	bl	1e59c <radio_tx_power_set>
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	lll_conn_rx_pkt_set(lll);
   1e172:	4620      	mov	r0, r4
   1e174:	f7ff fdfc 	bl	1dd70 <lll_conn_rx_pkt_set>

	radio_aa_set(lll->access_addr);
   1e178:	f104 0008 	add.w	r0, r4, #8
   1e17c:	f000 fa2c 	bl	1e5d8 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
			    (((u32_t)lll->crc_init[2] << 16) |
			     ((u32_t)lll->crc_init[1] << 8) |
   1e180:	7b63      	ldrb	r3, [r4, #13]
			    (((u32_t)lll->crc_init[2] << 16) |
   1e182:	7ba1      	ldrb	r1, [r4, #14]
			     ((u32_t)lll->crc_init[1] << 8) |
   1e184:	021b      	lsls	r3, r3, #8
			    (((u32_t)lll->crc_init[2] << 16) |
   1e186:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
			     ((u32_t)lll->crc_init[0])));
   1e18a:	7b21      	ldrb	r1, [r4, #12]
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   1e18c:	f240 605b 	movw	r0, #1627	; 0x65b
   1e190:	4319      	orrs	r1, r3
   1e192:	f000 fab9 	bl	1e708 <radio_crc_configure>

	lll_chan_set(data_chan_use);
   1e196:	4638      	mov	r0, r7
   1e198:	f7fe fe34 	bl	1ce04 <lll_chan_set>

	radio_isr_set(lll_conn_isr_rx, lll);
   1e19c:	4621      	mov	r1, r4
   1e19e:	4835      	ldr	r0, [pc, #212]	; (1e274 <prepare_cb+0x18c>)
   1e1a0:	f000 f9a8 	bl	1e4f4 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
   1e1a4:	2096      	movs	r0, #150	; 0x96
   1e1a6:	f000 fb45 	bl	1e834 <radio_tmr_tifs_set>

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
				     lll->phy_flags);
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1e1aa:	462b      	mov	r3, r5
   1e1ac:	462a      	mov	r2, r5
   1e1ae:	4629      	mov	r1, r5
   1e1b0:	4628      	mov	r0, r5
   1e1b2:	f000 fad3 	bl	1e75c <radio_switch_complete_and_tx>
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = prepare_param->ticks_at_expire;
	evt = HDR_LLL2EVT(lll);
   1e1b6:	f8d4 9000 	ldr.w	r9, [r4]
	ticks_at_event = prepare_param->ticks_at_expire;
   1e1ba:	6837      	ldr	r7, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   1e1bc:	4648      	mov	r0, r9
   1e1be:	f00a faf0 	bl	287a2 <lll_evt_offset_get>
   1e1c2:	eb07 0800 	add.w	r8, r7, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = prepare_param->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   1e1c6:	6872      	ldr	r2, [r6, #4]
   1e1c8:	f108 0109 	add.w	r1, r8, #9
   1e1cc:	4628      	mov	r0, r5
   1e1ce:	f000 fb3d 	bl	1e84c <radio_tmr_start>
   1e1d2:	4607      	mov	r7, r0

	radio_tmr_aa_capture();
   1e1d4:	f000 fbee 	bl	1e9b4 <radio_tmr_aa_capture>
	radio_tmr_aa_save(0);
   1e1d8:	4628      	mov	r0, r5
   1e1da:	f000 fc05 	bl	1e9e8 <radio_tmr_aa_save>

	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   1e1de:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	       (lll->slave.window_widening_event_us << 1) +
   1e1e0:	6b60      	ldr	r0, [r4, #52]	; 0x34
   1e1e2:	f103 0678 	add.w	r6, r3, #120	; 0x78
   1e1e6:	eb06 0640 	add.w	r6, r6, r0, lsl #1
#if defined(CONFIG_BT_CTLR_PHY)
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
	hcto += addr_us_get(lll->phy_rx);
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
#else /* !CONFIG_BT_CTLR_PHY */
	hcto += radio_rx_ready_delay_get(0, 0);
   1e1ea:	4629      	mov	r1, r5
   1e1ec:	4628      	mov	r0, r5
   1e1ee:	f00a fcbc 	bl	28b6a <radio_rx_ready_delay_get>
#define RANGE_DISTANCE 1000 /* meters */
#define RANGE_DELAY_US (2 * RANGE_DISTANCE * 4 / 1000)

static inline u32_t addr_us_get(u8_t phy)
{
	switch (phy) {
   1e1f2:	443e      	add	r6, r7
	hcto += addr_us_get(0);
	hcto += radio_rx_chain_delay_get(0, 0);
   1e1f4:	4629      	mov	r1, r5
   1e1f6:	4406      	add	r6, r0
   1e1f8:	4628      	mov	r0, r5
   1e1fa:	f00a fcb8 	bl	28b6e <radio_rx_chain_delay_get>
#endif /* !CONFIG_BT_CTLR_PHY */

	radio_tmr_hcto_configure(hcto);
   1e1fe:	4430      	add	r0, r6
   1e200:	f000 fbcc 	bl	1e99c <radio_tmr_hcto_configure>
#endif /* CONFIG_BT_CTLR_CONN_RSSI */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(evt, (TICKER_ID_CONN_BASE + lll->handle),
   1e204:	7c21      	ldrb	r1, [r4, #16]
   1e206:	3105      	adds	r1, #5
   1e208:	4642      	mov	r2, r8
   1e20a:	b2c9      	uxtb	r1, r1
   1e20c:	4648      	mov	r0, r9
   1e20e:	f00a fad6 	bl	287be <lll_preempt_calc>
   1e212:	b1b0      	cbz	r0, 1e242 <prepare_cb+0x15a>
			     ticks_at_event)) {
		radio_isr_set(lll_conn_isr_abort, lll);
   1e214:	4818      	ldr	r0, [pc, #96]	; (1e278 <prepare_cb+0x190>)
   1e216:	4621      	mov	r1, r4
   1e218:	f000 f96c 	bl	1e4f4 <radio_isr_set>
		radio_disable();
   1e21c:	f000 fa38 	bl	1e690 <radio_disable>
	}

	DEBUG_RADIO_START_S(1);

	return 0;
}
   1e220:	2000      	movs	r0, #0
   1e222:	b003      	add	sp, #12
   1e224:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   1e228:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1e22c:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
   1e230:	9300      	str	r3, [sp, #0]
   1e232:	f104 0023 	add.w	r0, r4, #35	; 0x23
   1e236:	f104 031c 	add.w	r3, r4, #28
   1e23a:	f00a f8e1 	bl	28400 <lll_chan_sel_1>
   1e23e:	4607      	mov	r7, r0
   1e240:	e783      	b.n	1e14a <prepare_cb+0x62>
		ret = lll_prepare_done(lll);
   1e242:	4620      	mov	r0, r4
   1e244:	f00a faab 	bl	2879e <lll_prepare_done>
		LL_ASSERT(!ret);
   1e248:	2800      	cmp	r0, #0
   1e24a:	d0e9      	beq.n	1e220 <prepare_cb+0x138>
   1e24c:	4a06      	ldr	r2, [pc, #24]	; (1e268 <prepare_cb+0x180>)
   1e24e:	490b      	ldr	r1, [pc, #44]	; (1e27c <prepare_cb+0x194>)
   1e250:	4807      	ldr	r0, [pc, #28]	; (1e270 <prepare_cb+0x188>)
   1e252:	f44f 7380 	mov.w	r3, #256	; 0x100
   1e256:	f005 fe44 	bl	23ee2 <printk>
   1e25a:	4040      	eors	r0, r0
   1e25c:	f380 8811 	msr	BASEPRI, r0
   1e260:	f04f 0003 	mov.w	r0, #3
   1e264:	df02      	svc	2
   1e266:	e7db      	b.n	1e220 <prepare_cb+0x138>
   1e268:	00030ae5 	.word	0x00030ae5
   1e26c:	0002e3c9 	.word	0x0002e3c9
   1e270:	0002a5e8 	.word	0x0002a5e8
   1e274:	0001de45 	.word	0x0001de45
   1e278:	00028a0b 	.word	0x00028a0b
   1e27c:	00030473 	.word	0x00030473

0001e280 <lll_slave_prepare>:
{
   1e280:	b513      	push	{r0, r1, r4, lr}
   1e282:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   1e284:	f7fe fe30 	bl	1cee8 <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1e288:	b168      	cbz	r0, 1e2a6 <lll_slave_prepare+0x26>
   1e28a:	3044      	adds	r0, #68	; 0x44
   1e28c:	d00b      	beq.n	1e2a6 <lll_slave_prepare+0x26>
   1e28e:	4a12      	ldr	r2, [pc, #72]	; (1e2d8 <lll_slave_prepare+0x58>)
   1e290:	4912      	ldr	r1, [pc, #72]	; (1e2dc <lll_slave_prepare+0x5c>)
   1e292:	4813      	ldr	r0, [pc, #76]	; (1e2e0 <lll_slave_prepare+0x60>)
   1e294:	2346      	movs	r3, #70	; 0x46
   1e296:	f005 fe24 	bl	23ee2 <printk>
   1e29a:	4040      	eors	r0, r0
   1e29c:	f380 8811 	msr	BASEPRI, r0
   1e2a0:	f04f 0003 	mov.w	r0, #3
   1e2a4:	df02      	svc	2
	err = lll_prepare(lll_conn_is_abort_cb, lll_conn_abort_cb, prepare_cb,
   1e2a6:	4a0f      	ldr	r2, [pc, #60]	; (1e2e4 <lll_slave_prepare+0x64>)
   1e2a8:	490f      	ldr	r1, [pc, #60]	; (1e2e8 <lll_slave_prepare+0x68>)
   1e2aa:	4810      	ldr	r0, [pc, #64]	; (1e2ec <lll_slave_prepare+0x6c>)
   1e2ac:	9400      	str	r4, [sp, #0]
   1e2ae:	2300      	movs	r3, #0
   1e2b0:	f00a fa6c 	bl	2878c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1e2b4:	b168      	cbz	r0, 1e2d2 <lll_slave_prepare+0x52>
   1e2b6:	3044      	adds	r0, #68	; 0x44
   1e2b8:	d00b      	beq.n	1e2d2 <lll_slave_prepare+0x52>
   1e2ba:	4a07      	ldr	r2, [pc, #28]	; (1e2d8 <lll_slave_prepare+0x58>)
   1e2bc:	4907      	ldr	r1, [pc, #28]	; (1e2dc <lll_slave_prepare+0x5c>)
   1e2be:	4808      	ldr	r0, [pc, #32]	; (1e2e0 <lll_slave_prepare+0x60>)
   1e2c0:	234a      	movs	r3, #74	; 0x4a
   1e2c2:	f005 fe0e 	bl	23ee2 <printk>
   1e2c6:	4040      	eors	r0, r0
   1e2c8:	f380 8811 	msr	BASEPRI, r0
   1e2cc:	f04f 0003 	mov.w	r0, #3
   1e2d0:	df02      	svc	2
}
   1e2d2:	b002      	add	sp, #8
   1e2d4:	bd10      	pop	{r4, pc}
   1e2d6:	bf00      	nop
   1e2d8:	00030ae5 	.word	0x00030ae5
   1e2dc:	000309ec 	.word	0x000309ec
   1e2e0:	0002a5e8 	.word	0x0002a5e8
   1e2e4:	0001e0e9 	.word	0x0001e0e9
   1e2e8:	0001dd21 	.word	0x0001dd21
   1e2ec:	00028a05 	.word	0x00028a05

0001e2f0 <cntr_init>:

static u8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
   1e2f0:	4b05      	ldr	r3, [pc, #20]	; (1e308 <cntr_init+0x18>)
   1e2f2:	2200      	movs	r2, #0
   1e2f4:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   1e2f8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1e2fc:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
   1e300:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
   1e304:	4770      	bx	lr
   1e306:	bf00      	nop
   1e308:	4000b000 	.word	0x4000b000

0001e30c <cntr_start>:

u32_t cntr_start(void)
{
	if (_refcount++) {
   1e30c:	4a04      	ldr	r2, [pc, #16]	; (1e320 <cntr_start+0x14>)
   1e30e:	7813      	ldrb	r3, [r2, #0]
   1e310:	1c59      	adds	r1, r3, #1
   1e312:	7011      	strb	r1, [r2, #0]
   1e314:	2001      	movs	r0, #1
   1e316:	b913      	cbnz	r3, 1e31e <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   1e318:	4a02      	ldr	r2, [pc, #8]	; (1e324 <cntr_start+0x18>)
   1e31a:	6010      	str	r0, [r2, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
   1e31c:	4618      	mov	r0, r3
}
   1e31e:	4770      	bx	lr
   1e320:	200024db 	.word	0x200024db
   1e324:	4000b000 	.word	0x4000b000

0001e328 <cntr_stop>:

u32_t cntr_stop(void)
{
   1e328:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
   1e32a:	4c0d      	ldr	r4, [pc, #52]	; (1e360 <cntr_stop+0x38>)
   1e32c:	7823      	ldrb	r3, [r4, #0]
   1e32e:	b95b      	cbnz	r3, 1e348 <cntr_stop+0x20>
   1e330:	4a0c      	ldr	r2, [pc, #48]	; (1e364 <cntr_stop+0x3c>)
   1e332:	490d      	ldr	r1, [pc, #52]	; (1e368 <cntr_stop+0x40>)
   1e334:	480d      	ldr	r0, [pc, #52]	; (1e36c <cntr_stop+0x44>)
   1e336:	232e      	movs	r3, #46	; 0x2e
   1e338:	f005 fdd3 	bl	23ee2 <printk>
   1e33c:	4040      	eors	r0, r0
   1e33e:	f380 8811 	msr	BASEPRI, r0
   1e342:	f04f 0003 	mov.w	r0, #3
   1e346:	df02      	svc	2

	if (--_refcount) {
   1e348:	7820      	ldrb	r0, [r4, #0]
   1e34a:	3801      	subs	r0, #1
   1e34c:	b2c0      	uxtb	r0, r0
   1e34e:	7020      	strb	r0, [r4, #0]
   1e350:	2301      	movs	r3, #1
   1e352:	b910      	cbnz	r0, 1e35a <cntr_stop+0x32>
   1e354:	4a06      	ldr	r2, [pc, #24]	; (1e370 <cntr_stop+0x48>)
   1e356:	6013      	str	r3, [r2, #0]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
   1e358:	bd10      	pop	{r4, pc}
		return 1;
   1e35a:	4618      	mov	r0, r3
   1e35c:	e7fc      	b.n	1e358 <cntr_stop+0x30>
   1e35e:	bf00      	nop
   1e360:	200024db 	.word	0x200024db
   1e364:	00030b43 	.word	0x00030b43
   1e368:	00030b8f 	.word	0x00030b8f
   1e36c:	0002a5e8 	.word	0x0002a5e8
   1e370:	4000b004 	.word	0x4000b004

0001e374 <cntr_cnt_get>:
     return p_reg->COUNTER;
   1e374:	4b01      	ldr	r3, [pc, #4]	; (1e37c <cntr_cnt_get+0x8>)
   1e376:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

u32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
   1e37a:	4770      	bx	lr
   1e37c:	4000b000 	.word	0x4000b000

0001e380 <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
   1e380:	4b02      	ldr	r3, [pc, #8]	; (1e38c <cntr_cmp_set+0xc>)
   1e382:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   1e386:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(u8_t cmp, u32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
   1e38a:	4770      	bx	lr
   1e38c:	4000b000 	.word	0x4000b000

0001e390 <do_ecb>:
	u8_t clear_text[16];
	u8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
   1e390:	b5f0      	push	{r4, r5, r6, r7, lr}
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
   1e392:	4b13      	ldr	r3, [pc, #76]	; (1e3e0 <do_ecb+0x50>)

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1e394:	4c13      	ldr	r4, [pc, #76]	; (1e3e4 <do_ecb+0x54>)
   1e396:	2501      	movs	r5, #1
   1e398:	462e      	mov	r6, r5
		NRF_ECB->EVENTS_ENDECB = 0;
   1e39a:	2700      	movs	r7, #0
   1e39c:	46a6      	mov	lr, r4
   1e39e:	461a      	mov	r2, r3
   1e3a0:	6026      	str	r6, [r4, #0]
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
   1e3a2:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
   1e3a6:	f8c3 7100 	str.w	r7, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
   1e3aa:	f8c3 7104 	str.w	r7, [r3, #260]	; 0x104
   1e3ae:	601e      	str	r6, [r3, #0]
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   1e3b0:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
   1e3b4:	b931      	cbnz	r1, 1e3c4 <do_ecb+0x34>
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   1e3b6:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   1e3ba:	b919      	cbnz	r1, 1e3c4 <do_ecb+0x34>
		       (NRF_ECB->ECBDATAPTR != 0)) {
   1e3bc:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   1e3c0:	2900      	cmp	r1, #0
   1e3c2:	d1f5      	bne.n	1e3b0 <do_ecb+0x20>
   1e3c4:	f8ce 5000 	str.w	r5, [lr]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
   1e3c8:	f8d2 1104 	ldr.w	r1, [r2, #260]	; 0x104
   1e3cc:	2900      	cmp	r1, #0
   1e3ce:	d1e7      	bne.n	1e3a0 <do_ecb+0x10>
   1e3d0:	f8d2 c504 	ldr.w	ip, [r2, #1284]	; 0x504
   1e3d4:	f1bc 0f00 	cmp.w	ip, #0
   1e3d8:	d0e2      	beq.n	1e3a0 <do_ecb+0x10>

	NRF_ECB->ECBDATAPTR = 0;
   1e3da:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
}
   1e3de:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e3e0:	4000e000 	.word	0x4000e000
   1e3e4:	4000e004 	.word	0x4000e004

0001e3e8 <hal_radio_enable_on_tick_ppi_config_and_enable>:
static inline void hal_radio_enable_on_tick_ppi_config_and_enable(u8_t trx)
{
	/* No need to configure anything for the pre-programmed channels.
	 * Just enable and disable them accordingly.
	 */
	nrf_ppi_channels_disable(
   1e3e8:	2800      	cmp	r0, #0
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
   1e3ea:	4b08      	ldr	r3, [pc, #32]	; (1e40c <hal_radio_enable_on_tick_ppi_config_and_enable+0x24>)
   1e3ec:	bf14      	ite	ne
   1e3ee:	f44f 1200 	movne.w	r2, #2097152	; 0x200000
   1e3f2:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
   1e3f6:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI));
	nrf_ppi_channels_enable(
   1e3fa:	bf14      	ite	ne
   1e3fc:	f44f 1280 	movne.w	r2, #1048576	; 0x100000
   1e400:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
    p_reg->CHENSET = mask;
   1e404:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI));
}
   1e408:	4770      	bx	lr
   1e40a:	bf00      	nop
   1e40c:	4001f000 	.word	0x4001f000

0001e410 <sw_switch.isra.0>:
}

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
static u8_t sw_tifs_toggle;

static void sw_switch(u8_t dir, u8_t phy_curr, u8_t flags_curr, u8_t phy_next,
   1e410:	b5f0      	push	{r4, r5, r6, r7, lr}
		      u8_t flags_next)
{
	u8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   1e412:	4e2b      	ldr	r6, [pc, #172]	; (1e4c0 <sw_switch.isra.0+0xb0>)
NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                      nrf_ppi_channel_t channel,
                                                      uint32_t          eep,
                                                      uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
   1e414:	4f2b      	ldr	r7, [pc, #172]	; (1e4c4 <sw_switch.isra.0+0xb4>)
   1e416:	7835      	ldrb	r5, [r6, #0]
   1e418:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 1e4d0 <sw_switch.isra.0+0xc0>
   1e41c:	f8c7 c560 	str.w	ip, [r7, #1376]	; 0x560
	 */
	nrf_ppi_channel_endpoint_setup(
		NRF_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_EVT,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   1e420:	00ec      	lsls	r4, r5, #3
   1e422:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   1e426:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
   1e42a:	f8c7 4564 	str.w	r4, [r7, #1380]	; 0x564
   1e42e:	f105 040b 	add.w	r4, r5, #11
   1e432:	b2e4      	uxtb	r4, r4
   1e434:	00e4      	lsls	r4, r4, #3
	 * (TX/RX).
	 */
	nrf_ppi_event_endpoint_setup(
		NRF_PPI,
		radio_enable_ppi,
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   1e436:	f5a7 37af 	sub.w	r7, r7, #89600	; 0x15e00
   1e43a:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   1e43e:	3fc0      	subs	r7, #192	; 0xc0
   1e440:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
   1e444:	eb07 0785 	add.w	r7, r7, r5, lsl #2
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   1e448:	462b      	mov	r3, r5

NRF_STATIC_INLINE void nrf_ppi_event_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                    nrf_ppi_channel_t channel,
                                                    uint32_t          eep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
   1e44a:	f8c4 7510 	str.w	r7, [r4, #1296]	; 0x510
	u8_t cc = SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle);
	u32_t delay;

	hal_radio_sw_switch_setup(cc, ppi, sw_tifs_toggle);

	if (dir) {
   1e44e:	b390      	cbz	r0, 1e4b6 <sw_switch.isra.0+0xa6>
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_2M_NS;
   1e450:	f649 70c4 	movw	r0, #40900	; 0x9fc4
   1e454:	f649 4740 	movw	r7, #40000	; 0x9c40
   1e458:	2a02      	cmp	r2, #2
   1e45a:	bf14      	ite	ne
   1e45c:	4602      	movne	r2, r0
   1e45e:	463a      	moveq	r2, r7
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_2M_NS;
   1e460:	f242 40b8 	movw	r0, #9400	; 0x24b8
   1e464:	f241 3788 	movw	r7, #5000	; 0x1388
   1e468:	2902      	cmp	r1, #2
   1e46a:	bf14      	ite	ne
   1e46c:	4601      	movne	r1, r0
   1e46e:	4639      	moveq	r1, r7
		/* TX */

		/* Calculate delay with respect to current (RX) and next
		 * (TX) PHY. If RX PHY is LE Coded, assume S8 coding scheme.
		 */
		delay = HAL_RADIO_NS2US_ROUND(
   1e470:	f502 72fa 	add.w	r2, r2, #500	; 0x1f4
   1e474:	440a      	add	r2, r1
   1e476:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1e47a:	fbb2 f2f1 	udiv	r2, r2, r1

NRF_STATIC_INLINE void nrf_ppi_task_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                   nrf_ppi_channel_t channel,
                                                   uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].TEP = tep;
   1e47e:	4912      	ldr	r1, [pc, #72]	; (1e4c8 <sw_switch.isra.0+0xb8>)
   1e480:	f8c4 1514 	str.w	r1, [r4, #1300]	; 0x514
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay <
   1e484:	009b      	lsls	r3, r3, #2
   1e486:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1e48a:	f503 4310 	add.w	r3, r3, #36864	; 0x9000
		SW_SWITCH_TIMER->CC[cc]) {
   1e48e:	f8d3 1540 	ldr.w	r1, [r3, #1344]	; 0x540
	if (delay <
   1e492:	4291      	cmp	r1, r2
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
				 SW_SWITCH_TIMER->CC[cc] - delay);
   1e494:	bf8a      	itet	hi
   1e496:	f8d3 1540 	ldrhi.w	r1, [r3, #1344]	; 0x540

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
   1e49a:	2201      	movls	r2, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
   1e49c:	1a8a      	subhi	r2, r1, r2
   1e49e:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->CHENSET = mask;
   1e4a2:	4b08      	ldr	r3, [pc, #32]	; (1e4c4 <sw_switch.isra.0+0xb4>)
   1e4a4:	f44f 6290 	mov.w	r2, #1152	; 0x480
   1e4a8:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	 * always need to capture the PDU END time-stamp.
	 */
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
   1e4ac:	1c6b      	adds	r3, r5, #1
	sw_tifs_toggle &= 1;
   1e4ae:	f003 0301 	and.w	r3, r3, #1
   1e4b2:	7033      	strb	r3, [r6, #0]
}
   1e4b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    p_reg->CH[(uint32_t) channel].TEP = tep;
   1e4b6:	4a05      	ldr	r2, [pc, #20]	; (1e4cc <sw_switch.isra.0+0xbc>)
   1e4b8:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
		delay = HAL_RADIO_NS2US_CEIL(
   1e4bc:	2228      	movs	r2, #40	; 0x28
{
	nrf_ppi_task_endpoint_setup(
		NRF_PPI,
		ppi,
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_TASK_RX);
}
   1e4be:	e7e1      	b.n	1e484 <sw_switch.isra.0+0x74>
   1e4c0:	200024dc 	.word	0x200024dc
   1e4c4:	4001f000 	.word	0x4001f000
   1e4c8:	40001000 	.word	0x40001000
   1e4cc:	40001004 	.word	0x40001004
   1e4d0:	4000110c 	.word	0x4000110c

0001e4d4 <isr_radio>:
	return (NRF_RADIO->EVENTS_DISABLED != 0);
   1e4d4:	4b04      	ldr	r3, [pc, #16]	; (1e4e8 <isr_radio+0x14>)
   1e4d6:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
   1e4da:	b123      	cbz	r3, 1e4e6 <isr_radio+0x12>
		isr_cb(isr_cb_param);
   1e4dc:	4b03      	ldr	r3, [pc, #12]	; (1e4ec <isr_radio+0x18>)
   1e4de:	4a04      	ldr	r2, [pc, #16]	; (1e4f0 <isr_radio+0x1c>)
   1e4e0:	681b      	ldr	r3, [r3, #0]
   1e4e2:	6810      	ldr	r0, [r2, #0]
   1e4e4:	4718      	bx	r3
}
   1e4e6:	4770      	bx	lr
   1e4e8:	40001000 	.word	0x40001000
   1e4ec:	20001b40 	.word	0x20001b40
   1e4f0:	20001b44 	.word	0x20001b44

0001e4f4 <radio_isr_set>:
{
   1e4f4:	b538      	push	{r3, r4, r5, lr}
   1e4f6:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
   1e4f8:	2001      	movs	r0, #1
{
   1e4fa:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
   1e4fc:	f7e6 fa3c 	bl	4978 <arch_irq_disable>
	isr_cb_param = param;
   1e500:	4b08      	ldr	r3, [pc, #32]	; (1e524 <radio_isr_set+0x30>)
   1e502:	601d      	str	r5, [r3, #0]
	isr_cb = cb;
   1e504:	4b08      	ldr	r3, [pc, #32]	; (1e528 <radio_isr_set+0x34>)
   1e506:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   1e508:	4b08      	ldr	r3, [pc, #32]	; (1e52c <radio_isr_set+0x38>)
   1e50a:	2210      	movs	r2, #16
   1e50c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1e510:	4b07      	ldr	r3, [pc, #28]	; (1e530 <radio_isr_set+0x3c>)
   1e512:	2202      	movs	r2, #2
   1e514:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
   1e518:	2001      	movs	r0, #1
}
   1e51a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
   1e51e:	f7e6 ba1b 	b.w	4958 <arch_irq_enable>
   1e522:	bf00      	nop
   1e524:	20001b44 	.word	0x20001b44
   1e528:	20001b40 	.word	0x20001b40
   1e52c:	40001000 	.word	0x40001000
   1e530:	e000e100 	.word	0xe000e100

0001e534 <radio_reset>:
{
   1e534:	b508      	push	{r3, lr}
	irq_disable(RADIO_IRQn);
   1e536:	2001      	movs	r0, #1
   1e538:	f7e6 fa1e 	bl	4978 <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (uint32_t) radio_power;
   1e53c:	4b0c      	ldr	r3, [pc, #48]	; (1e570 <radio_reset+0x3c>)
   1e53e:	2200      	movs	r2, #0
   1e540:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
   1e544:	2201      	movs	r2, #1
   1e546:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
   1e54a:	4a0a      	ldr	r2, [pc, #40]	; (1e574 <radio_reset+0x40>)
   1e54c:	6813      	ldr	r3, [r2, #0]
					 0xfffffffe) | 0x01000000;
   1e54e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   1e552:	f023 0301 	bic.w	r3, r3, #1
   1e556:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
   1e55a:	6013      	str	r3, [r2, #0]
static inline void hal_radio_sw_switch_ppi_group_setup(void)
{
	/* Include the appropriate PPI channels in the two PPI Groups. */
#if !defined(CONFIG_BT_CTLR_PHY_CODED) || \
	!defined(CONFIG_HAS_HW_NRF_RADIO_BLE_CODED)
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
   1e55c:	4b06      	ldr	r3, [pc, #24]	; (1e578 <radio_reset+0x44>)
   1e55e:	f44f 6210 	mov.w	r2, #2304	; 0x900
   1e562:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_0_INCLUDE |
			HAL_SW_SWITCH_RADIO_ENABLE_PPI_0_INCLUDE;
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
   1e566:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   1e56a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
   1e56e:	bd08      	pop	{r3, pc}
   1e570:	40001000 	.word	0x40001000
   1e574:	40001774 	.word	0x40001774
   1e578:	4001f000 	.word	0x4001f000

0001e57c <radio_phy_set>:
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
   1e57c:	4b06      	ldr	r3, [pc, #24]	; (1e598 <radio_phy_set+0x1c>)
	switch (phy) {
   1e57e:	2802      	cmp	r0, #2
		mode = RADIO_MODE_MODE_Ble_2Mbit;
   1e580:	bf14      	ite	ne
   1e582:	2203      	movne	r2, #3
   1e584:	2204      	moveq	r2, #4
   1e586:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
   1e58a:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
   1e58e:	f042 0201 	orr.w	r2, r2, #1
   1e592:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
   1e596:	4770      	bx	lr
   1e598:	40001000 	.word	0x40001000

0001e59c <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (u32_t)power;
   1e59c:	4b01      	ldr	r3, [pc, #4]	; (1e5a4 <radio_tx_power_set+0x8>)
   1e59e:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
   1e5a2:	4770      	bx	lr
   1e5a4:	40001000 	.word	0x40001000

0001e5a8 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
   1e5a8:	4b01      	ldr	r3, [pc, #4]	; (1e5b0 <radio_freq_chan_set+0x8>)
   1e5aa:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
   1e5ae:	4770      	bx	lr
   1e5b0:	40001000 	.word	0x40001000

0001e5b4 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
   1e5b4:	4b07      	ldr	r3, [pc, #28]	; (1e5d4 <radio_whiten_iv_set+0x20>)
   1e5b6:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
   1e5ba:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   1e5be:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
   1e5c2:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
   1e5c6:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   1e5ca:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
   1e5ce:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
   1e5d2:	4770      	bx	lr
   1e5d4:	40001000 	.word	0x40001000

0001e5d8 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
   1e5d8:	4a0a      	ldr	r2, [pc, #40]	; (1e604 <radio_aa_set+0x2c>)
   1e5da:	2300      	movs	r3, #0
   1e5dc:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
   1e5e0:	2301      	movs	r3, #1
   1e5e2:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
   1e5e6:	78c3      	ldrb	r3, [r0, #3]
   1e5e8:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
   1e5ec:	7843      	ldrb	r3, [r0, #1]
   1e5ee:	7881      	ldrb	r1, [r0, #2]
   1e5f0:	041b      	lsls	r3, r3, #16
   1e5f2:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   1e5f6:	7801      	ldrb	r1, [r0, #0]
   1e5f8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   1e5fc:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
   1e600:	4770      	bx	lr
   1e602:	bf00      	nop
   1e604:	40001000 	.word	0x40001000

0001e608 <radio_pkt_configure>:
	switch (phy) {
   1e608:	f3c2 0342 	ubfx	r3, r2, #1, #3
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
   1e60c:	2b02      	cmp	r3, #2
{
   1e60e:	b510      	push	{r4, lr}
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
   1e610:	bf14      	ite	ne
   1e612:	2400      	movne	r4, #0
   1e614:	f04f 7480 	moveq.w	r4, #16777216	; 0x1000000
	if (dc) {
   1e618:	07d3      	lsls	r3, r2, #31
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   1e61a:	f1c0 0308 	rsb	r3, r0, #8
		extra |= (RADIO_PCNF0_S1INCL_Include <<
   1e61e:	bf48      	it	mi
   1e620:	f444 1480 	orrmi.w	r4, r4, #1048576	; 0x100000
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   1e624:	041b      	lsls	r3, r3, #16
			   ((((u32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) &
   1e626:	f000 000f 	and.w	r0, r0, #15
			    RADIO_PCNF0_S1LEN_Msk) |
   1e62a:	4320      	orrs	r0, r4
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   1e62c:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
   1e630:	4a09      	ldr	r2, [pc, #36]	; (1e658 <radio_pkt_configure+0x50>)
			    RADIO_PCNF0_S1LEN_Msk) |
   1e632:	4303      	orrs	r3, r0
   1e634:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
   1e638:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
   1e63c:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
   1e640:	4b06      	ldr	r3, [pc, #24]	; (1e65c <radio_pkt_configure+0x54>)
   1e642:	4003      	ands	r3, r0
   1e644:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((((u32_t)max_len) << RADIO_PCNF1_MAXLEN_Pos) &
   1e648:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
   1e64c:	4319      	orrs	r1, r3
   1e64e:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
   1e652:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
   1e656:	bd10      	pop	{r4, pc}
   1e658:	40001000 	.word	0x40001000
   1e65c:	fef80000 	.word	0xfef80000

0001e660 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (u32_t)rx_packet;
   1e660:	4b01      	ldr	r3, [pc, #4]	; (1e668 <radio_pkt_rx_set+0x8>)
   1e662:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
   1e666:	4770      	bx	lr
   1e668:	40001000 	.word	0x40001000

0001e66c <radio_pkt_tx_set>:
   1e66c:	4b01      	ldr	r3, [pc, #4]	; (1e674 <radio_pkt_tx_set+0x8>)
   1e66e:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
   1e672:	4770      	bx	lr
   1e674:	40001000 	.word	0x40001000

0001e678 <radio_rx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1e678:	4b01      	ldr	r3, [pc, #4]	; (1e680 <radio_rx_enable+0x8>)
   1e67a:	2201      	movs	r2, #1
   1e67c:	601a      	str	r2, [r3, #0]
}
   1e67e:	4770      	bx	lr
   1e680:	40001004 	.word	0x40001004

0001e684 <radio_tx_enable>:
   1e684:	4b01      	ldr	r3, [pc, #4]	; (1e68c <radio_tx_enable+0x8>)
   1e686:	2201      	movs	r2, #1
   1e688:	601a      	str	r2, [r3, #0]
}
   1e68a:	4770      	bx	lr
   1e68c:	40001000 	.word	0x40001000

0001e690 <radio_disable>:
    p_reg->CHENCLR = mask;
   1e690:	4a07      	ldr	r2, [pc, #28]	; (1e6b0 <radio_disable+0x20>)
   1e692:	f44f 6390 	mov.w	r3, #1152	; 0x480
   1e696:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
   1e69a:	2301      	movs	r3, #1
   1e69c:	6053      	str	r3, [r2, #4]
   1e69e:	60d3      	str	r3, [r2, #12]
	NRF_RADIO->SHORTS = 0;
   1e6a0:	f5a2 32f0 	sub.w	r2, r2, #122880	; 0x1e000
   1e6a4:	2100      	movs	r1, #0
   1e6a6:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
   1e6aa:	6113      	str	r3, [r2, #16]
}
   1e6ac:	4770      	bx	lr
   1e6ae:	bf00      	nop
   1e6b0:	4001f000 	.word	0x4001f000

0001e6b4 <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
   1e6b4:	4b04      	ldr	r3, [pc, #16]	; (1e6c8 <radio_status_reset+0x14>)
   1e6b6:	2200      	movs	r2, #0
   1e6b8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
   1e6bc:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
   1e6c0:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
   1e6c4:	4770      	bx	lr
   1e6c6:	bf00      	nop
   1e6c8:	40001000 	.word	0x40001000

0001e6cc <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
   1e6cc:	4b03      	ldr	r3, [pc, #12]	; (1e6dc <radio_is_ready+0x10>)
   1e6ce:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
   1e6d2:	3800      	subs	r0, #0
   1e6d4:	bf18      	it	ne
   1e6d6:	2001      	movne	r0, #1
   1e6d8:	4770      	bx	lr
   1e6da:	bf00      	nop
   1e6dc:	40001000 	.word	0x40001000

0001e6e0 <radio_is_done>:
	return (NRF_RADIO->EVENTS_END != 0);
   1e6e0:	4b03      	ldr	r3, [pc, #12]	; (1e6f0 <radio_is_done+0x10>)
   1e6e2:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
   1e6e6:	3800      	subs	r0, #0
   1e6e8:	bf18      	it	ne
   1e6ea:	2001      	movne	r0, #1
   1e6ec:	4770      	bx	lr
   1e6ee:	bf00      	nop
   1e6f0:	40001000 	.word	0x40001000

0001e6f4 <radio_is_idle>:
	return (NRF_RADIO->STATE == 0);
   1e6f4:	4b03      	ldr	r3, [pc, #12]	; (1e704 <radio_is_idle+0x10>)
   1e6f6:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
   1e6fa:	fab0 f080 	clz	r0, r0
   1e6fe:	0940      	lsrs	r0, r0, #5
   1e700:	4770      	bx	lr
   1e702:	bf00      	nop
   1e704:	40001000 	.word	0x40001000

0001e708 <radio_crc_configure>:
	NRF_RADIO->CRCCNF =
   1e708:	4b04      	ldr	r3, [pc, #16]	; (1e71c <radio_crc_configure+0x14>)
   1e70a:	f240 1203 	movw	r2, #259	; 0x103
   1e70e:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	NRF_RADIO->CRCPOLY = polynomial;
   1e712:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
   1e716:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
   1e71a:	4770      	bx	lr
   1e71c:	40001000 	.word	0x40001000

0001e720 <radio_crc_is_valid>:
	return (NRF_RADIO->CRCSTATUS != 0);
   1e720:	4b03      	ldr	r3, [pc, #12]	; (1e730 <radio_crc_is_valid+0x10>)
   1e722:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   1e726:	3800      	subs	r0, #0
   1e728:	bf18      	it	ne
   1e72a:	2001      	movne	r0, #1
   1e72c:	4770      	bx	lr
   1e72e:	bf00      	nop
   1e730:	40001000 	.word	0x40001000

0001e734 <radio_pkt_empty_get>:
}
   1e734:	4800      	ldr	r0, [pc, #0]	; (1e738 <radio_pkt_empty_get+0x4>)
   1e736:	4770      	bx	lr
   1e738:	20001a38 	.word	0x20001a38

0001e73c <radio_pkt_scratch_get>:
}
   1e73c:	4800      	ldr	r0, [pc, #0]	; (1e740 <radio_pkt_scratch_get+0x4>)
   1e73e:	4770      	bx	lr
   1e740:	20001a3c 	.word	0x20001a3c

0001e744 <radio_switch_complete_and_rx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   1e744:	4b04      	ldr	r3, [pc, #16]	; (1e758 <radio_switch_complete_and_rx+0x14>)
   1e746:	2103      	movs	r1, #3
   1e748:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(0, 0, 0, phy_rx, 0);
   1e74c:	2100      	movs	r1, #0
{
   1e74e:	4602      	mov	r2, r0
	sw_switch(0, 0, 0, phy_rx, 0);
   1e750:	4608      	mov	r0, r1
   1e752:	f7ff be5d 	b.w	1e410 <sw_switch.isra.0>
   1e756:	bf00      	nop
   1e758:	40001000 	.word	0x40001000

0001e75c <radio_switch_complete_and_tx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   1e75c:	4b03      	ldr	r3, [pc, #12]	; (1e76c <radio_switch_complete_and_tx+0x10>)
{
   1e75e:	4601      	mov	r1, r0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   1e760:	2003      	movs	r0, #3
   1e762:	f8c3 0200 	str.w	r0, [r3, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
   1e766:	2001      	movs	r0, #1
   1e768:	f7ff be52 	b.w	1e410 <sw_switch.isra.0>
   1e76c:	40001000 	.word	0x40001000

0001e770 <radio_switch_complete_and_disable>:
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}

void radio_switch_complete_and_disable(void)
{
	NRF_RADIO->SHORTS =
   1e770:	4b05      	ldr	r3, [pc, #20]	; (1e788 <radio_switch_complete_and_disable+0x18>)
   1e772:	2203      	movs	r2, #3
   1e774:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    p_reg->CHENCLR = mask;
   1e778:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
   1e77c:	f44f 6290 	mov.w	r2, #1152	; 0x480
   1e780:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	    (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   1e784:	4770      	bx	lr
   1e786:	bf00      	nop
   1e788:	40001000 	.word	0x40001000

0001e78c <radio_rssi_measure>:

void radio_rssi_measure(void)
{
	NRF_RADIO->SHORTS |=
   1e78c:	4a03      	ldr	r2, [pc, #12]	; (1e79c <radio_rssi_measure+0x10>)
   1e78e:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
   1e792:	f443 7388 	orr.w	r3, r3, #272	; 0x110
   1e796:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	    (RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
	     RADIO_SHORTS_DISABLED_RSSISTOP_Msk);
}
   1e79a:	4770      	bx	lr
   1e79c:	40001000 	.word	0x40001000

0001e7a0 <radio_rssi_get>:

u32_t radio_rssi_get(void)
{
	return NRF_RADIO->RSSISAMPLE;
   1e7a0:	4b01      	ldr	r3, [pc, #4]	; (1e7a8 <radio_rssi_get+0x8>)
   1e7a2:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}
   1e7a6:	4770      	bx	lr
   1e7a8:	40001000 	.word	0x40001000

0001e7ac <radio_rssi_status_reset>:

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
   1e7ac:	4b02      	ldr	r3, [pc, #8]	; (1e7b8 <radio_rssi_status_reset+0xc>)
   1e7ae:	2200      	movs	r2, #0
   1e7b0:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
   1e7b4:	4770      	bx	lr
   1e7b6:	bf00      	nop
   1e7b8:	40001000 	.word	0x40001000

0001e7bc <radio_rssi_is_ready>:

u32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
   1e7bc:	4b03      	ldr	r3, [pc, #12]	; (1e7cc <radio_rssi_is_ready+0x10>)
   1e7be:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
   1e7c2:	3800      	subs	r0, #0
   1e7c4:	bf18      	it	ne
   1e7c6:	2001      	movne	r0, #1
   1e7c8:	4770      	bx	lr
   1e7ca:	bf00      	nop
   1e7cc:	40001000 	.word	0x40001000

0001e7d0 <radio_filter_disable>:
	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
}

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
   1e7d0:	4a03      	ldr	r2, [pc, #12]	; (1e7e0 <radio_filter_disable+0x10>)
   1e7d2:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
   1e7d6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   1e7da:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
   1e7de:	4770      	bx	lr
   1e7e0:	40001000 	.word	0x40001000

0001e7e4 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
   1e7e4:	4b02      	ldr	r3, [pc, #8]	; (1e7f0 <radio_filter_status_reset+0xc>)
   1e7e6:	2200      	movs	r2, #0
   1e7e8:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
   1e7ec:	4770      	bx	lr
   1e7ee:	bf00      	nop
   1e7f0:	40001000 	.word	0x40001000

0001e7f4 <radio_filter_has_match>:

u32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
   1e7f4:	4b03      	ldr	r3, [pc, #12]	; (1e804 <radio_filter_has_match+0x10>)
   1e7f6:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   1e7fa:	3800      	subs	r0, #0
   1e7fc:	bf18      	it	ne
   1e7fe:	2001      	movne	r0, #1
   1e800:	4770      	bx	lr
   1e802:	bf00      	nop
   1e804:	40001000 	.word	0x40001000

0001e808 <radio_filter_match_get>:

u32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
   1e808:	4b01      	ldr	r3, [pc, #4]	; (1e810 <radio_filter_match_get+0x8>)
   1e80a:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
   1e80e:	4770      	bx	lr
   1e810:	40001000 	.word	0x40001000

0001e814 <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   1e814:	4b05      	ldr	r3, [pc, #20]	; (1e82c <radio_tmr_status_reset+0x18>)
   1e816:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   1e81a:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
   1e81e:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
   1e822:	4a03      	ldr	r2, [pc, #12]	; (1e830 <radio_tmr_status_reset+0x1c>)
   1e824:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			BIT(HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI) |
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
   1e828:	4770      	bx	lr
   1e82a:	bf00      	nop
   1e82c:	4000b000 	.word	0x4000b000
   1e830:	0e700060 	.word	0x0e700060

0001e834 <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(u32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
   1e834:	4b03      	ldr	r3, [pc, #12]	; (1e844 <radio_tmr_tifs_set+0x10>)
   1e836:	4a04      	ldr	r2, [pc, #16]	; (1e848 <radio_tmr_tifs_set+0x14>)
   1e838:	781b      	ldrb	r3, [r3, #0]
   1e83a:	f503 73a8 	add.w	r3, r3, #336	; 0x150
   1e83e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   1e842:	4770      	bx	lr
   1e844:	200024dc 	.word	0x200024dc
   1e848:	40009000 	.word	0x40009000

0001e84c <radio_tmr_start>:

u32_t radio_tmr_start(u8_t trx, u32_t ticks_start, u32_t remainder)
{
   1e84c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
   1e84e:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
   1e852:	4c2f      	ldr	r4, [pc, #188]	; (1e910 <radio_tmr_start+0xc4>)
   1e854:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
   1e858:	42a3      	cmp	r3, r4
		ticks_start--;
		remainder += 30517578UL;
   1e85a:	bf88      	it	hi
   1e85c:	f102 72e8 	addhi.w	r2, r2, #30408704	; 0x1d00000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1e860:	4b2c      	ldr	r3, [pc, #176]	; (1e914 <radio_tmr_start+0xc8>)
	}
	remainder /= 1000000UL;
   1e862:	4c2d      	ldr	r4, [pc, #180]	; (1e918 <radio_tmr_start+0xcc>)
		remainder += 30517578UL;
   1e864:	bf84      	itt	hi
   1e866:	f502 32d4 	addhi.w	r2, r2, #108544	; 0x1a800
   1e86a:	f502 72a5 	addhi.w	r2, r2, #330	; 0x14a
   1e86e:	f04f 0501 	mov.w	r5, #1

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
   1e872:	f04f 0600 	mov.w	r6, #0
	remainder /= 1000000UL;
   1e876:	fbb2 f4f4 	udiv	r4, r2, r4
	EVENT_TIMER->PRESCALER = 4;
   1e87a:	f04f 0704 	mov.w	r7, #4
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   1e87e:	f04f 0202 	mov.w	r2, #2
   1e882:	601d      	str	r5, [r3, #0]
	EVENT_TIMER->MODE = 0;
   1e884:	f8c3 64f8 	str.w	r6, [r3, #1272]	; 0x4f8
	EVENT_TIMER->PRESCALER = 4;
   1e888:	f8c3 7504 	str.w	r7, [r3, #1284]	; 0x504
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   1e88c:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
    p_reg->CC[ch] = cc_val;
   1e890:	4a22      	ldr	r2, [pc, #136]	; (1e91c <radio_tmr_start+0xd0>)
    p_reg->CC[cc_channel] = cc_value;
   1e892:	f8c3 4534 	str.w	r4, [r3, #1332]	; 0x534
		ticks_start--;
   1e896:	bf88      	it	hi
   1e898:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
   1e89c:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
   1e8a0:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   1e8a4:	f8c2 1344 	str.w	r1, [r2, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
   1e8a8:	491d      	ldr	r1, [pc, #116]	; (1e920 <radio_tmr_start+0xd4>)
   1e8aa:	f502 72a4 	add.w	r2, r2, #328	; 0x148
	EVENT_TIMER->MODE = 0;
   1e8ae:	3b0c      	subs	r3, #12
   1e8b0:	f8c1 2538 	str.w	r2, [r1, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
   1e8b4:	f8c1 353c 	str.w	r3, [r1, #1340]	; 0x53c
    p_reg->CHENSET = mask;
   1e8b8:	2320      	movs	r3, #32
   1e8ba:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
   1e8be:	f7ff fd93 	bl	1e3e8 <hal_radio_enable_on_tick_ppi_config_and_enable>
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
   1e8c2:	4b18      	ldr	r3, [pc, #96]	; (1e924 <radio_tmr_start+0xd8>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1e8c4:	4a18      	ldr	r2, [pc, #96]	; (1e928 <radio_tmr_start+0xdc>)
   1e8c6:	6015      	str	r5, [r2, #0]
   1e8c8:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
   1e8cc:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
   1e8d0:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
   1e8d4:	601d      	str	r5, [r3, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
   1e8d6:	f5a3 43fd 	sub.w	r3, r3, #32384	; 0x7e80
   1e8da:	3b74      	subs	r3, #116	; 0x74
   1e8dc:	f8c1 3548 	str.w	r3, [r1, #1352]	; 0x548
   1e8e0:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
   1e8e4:	3334      	adds	r3, #52	; 0x34
    p_reg->CH[(uint32_t) channel].TEP = tep;
   1e8e6:	f8c1 254c 	str.w	r2, [r1, #1356]	; 0x54c
    p_reg->CH[(uint32_t) channel].EEP = eep;
   1e8ea:	f8c1 3550 	str.w	r3, [r1, #1360]	; 0x550
    p_reg->CH[(uint32_t) channel].TEP = tep;
   1e8ee:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
   1e8f2:	33c4      	adds	r3, #196	; 0xc4
   1e8f4:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
    p_reg->CH[(uint32_t) channel].EEP = eep;
   1e8f8:	f5a3 33af 	sub.w	r3, r3, #89600	; 0x15e00
   1e8fc:	3bc0      	subs	r3, #192	; 0xc0
   1e8fe:	f8c1 3558 	str.w	r3, [r1, #1368]	; 0x558
    p_reg->CH[(uint32_t) channel].TEP = tep;
   1e902:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
   1e906:	33c8      	adds	r3, #200	; 0xc8
   1e908:	f8c1 355c 	str.w	r3, [r1, #1372]	; 0x55c
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
   1e90c:	4620      	mov	r0, r4
   1e90e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e910:	7ff0bdbf 	.word	0x7ff0bdbf
   1e914:	4000800c 	.word	0x4000800c
   1e918:	000f4240 	.word	0x000f4240
   1e91c:	4000b000 	.word	0x4000b000
   1e920:	4001f000 	.word	0x4001f000
   1e924:	40009000 	.word	0x40009000
   1e928:	4000900c 	.word	0x4000900c

0001e92c <radio_tmr_start_tick>:
   1e92c:	4b0e      	ldr	r3, [pc, #56]	; (1e968 <radio_tmr_start_tick+0x3c>)
    p_reg->CC[cc_channel] = cc_value;
   1e92e:	4a0f      	ldr	r2, [pc, #60]	; (1e96c <radio_tmr_start_tick+0x40>)

u32_t radio_tmr_start_tick(u8_t trx, u32_t tick)
{
   1e930:	b510      	push	{r4, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1e932:	2401      	movs	r4, #1
   1e934:	601c      	str	r4, [r3, #0]
   1e936:	609c      	str	r4, [r3, #8]
    p_reg->CC[ch] = cc_val;
   1e938:	4b0d      	ldr	r3, [pc, #52]	; (1e970 <radio_tmr_start_tick+0x44>)
    p_reg->CC[cc_channel] = cc_value;
   1e93a:	f8c2 4540 	str.w	r4, [r2, #1344]	; 0x540
   1e93e:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
    p_reg->EVTENSET = mask;
   1e942:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   1e946:	f8c3 1344 	str.w	r1, [r3, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
   1e94a:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
   1e94e:	4909      	ldr	r1, [pc, #36]	; (1e974 <radio_tmr_start_tick+0x48>)
   1e950:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
   1e954:	f8c3 253c 	str.w	r2, [r3, #1340]	; 0x53c
    p_reg->CHENSET = mask;
   1e958:	2220      	movs	r2, #32
   1e95a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
   1e95e:	f7ff fd43 	bl	1e3e8 <hal_radio_enable_on_tick_ppi_config_and_enable>
	last_pdu_end_us = 0U;
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder_us;
}
   1e962:	4620      	mov	r0, r4
   1e964:	bd10      	pop	{r4, pc}
   1e966:	bf00      	nop
   1e968:	40008004 	.word	0x40008004
   1e96c:	40008000 	.word	0x40008000
   1e970:	4000b000 	.word	0x4000b000
   1e974:	4000b148 	.word	0x4000b148

0001e978 <radio_tmr_start_get>:
    return p_reg->CC[ch];
   1e978:	4b01      	ldr	r3, [pc, #4]	; (1e980 <radio_tmr_start_get+0x8>)
   1e97a:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}

u32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
   1e97e:	4770      	bx	lr
   1e980:	4000b000 	.word	0x4000b000

0001e984 <radio_tmr_stop>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1e984:	4a04      	ldr	r2, [pc, #16]	; (1e998 <radio_tmr_stop+0x14>)
   1e986:	2301      	movs	r3, #1
   1e988:	6013      	str	r3, [r2, #0]
   1e98a:	60d3      	str	r3, [r2, #12]
   1e98c:	320c      	adds	r2, #12
   1e98e:	f602 72f4 	addw	r2, r2, #4084	; 0xff4
   1e992:	6013      	str	r3, [r2, #0]
   1e994:	60d3      	str	r3, [r2, #12]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   1e996:	4770      	bx	lr
   1e998:	40008004 	.word	0x40008004

0001e99c <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
   1e99c:	4b04      	ldr	r3, [pc, #16]	; (1e9b0 <radio_tmr_hcto_configure+0x14>)
   1e99e:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
   1e9a2:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
   1e9a6:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
   1e9aa:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
   1e9ae:	4770      	bx	lr
   1e9b0:	40008000 	.word	0x40008000

0001e9b4 <radio_tmr_aa_capture>:
    p_reg->CH[(uint32_t) channel].EEP = eep;
   1e9b4:	4b06      	ldr	r3, [pc, #24]	; (1e9d0 <radio_tmr_aa_capture+0x1c>)
   1e9b6:	4a07      	ldr	r2, [pc, #28]	; (1e9d4 <radio_tmr_aa_capture+0x20>)
   1e9b8:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].TEP = tep;
   1e9bc:	f502 42de 	add.w	r2, r2, #28416	; 0x6f00
   1e9c0:	3240      	adds	r2, #64	; 0x40
   1e9c2:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
   1e9c6:	4a04      	ldr	r2, [pc, #16]	; (1e9d8 <radio_tmr_aa_capture+0x24>)
   1e9c8:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_ready_time_capture_ppi_config();
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_READY_TIME_CAPTURE_PPI) |
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI));
}
   1e9cc:	4770      	bx	lr
   1e9ce:	bf00      	nop
   1e9d0:	4001f000 	.word	0x4001f000
   1e9d4:	40001100 	.word	0x40001100
   1e9d8:	04000040 	.word	0x04000040

0001e9dc <radio_tmr_aa_get>:

u32_t radio_tmr_aa_get(void)
{
	return EVENT_TIMER->CC[1];
   1e9dc:	4b01      	ldr	r3, [pc, #4]	; (1e9e4 <radio_tmr_aa_get+0x8>)
   1e9de:	f8d3 0544 	ldr.w	r0, [r3, #1348]	; 0x544
}
   1e9e2:	4770      	bx	lr
   1e9e4:	40008000 	.word	0x40008000

0001e9e8 <radio_tmr_aa_save>:

static u32_t radio_tmr_aa;

void radio_tmr_aa_save(u32_t aa)
{
	radio_tmr_aa = aa;
   1e9e8:	4b01      	ldr	r3, [pc, #4]	; (1e9f0 <radio_tmr_aa_save+0x8>)
   1e9ea:	6018      	str	r0, [r3, #0]
}
   1e9ec:	4770      	bx	lr
   1e9ee:	bf00      	nop
   1e9f0:	20001b48 	.word	0x20001b48

0001e9f4 <radio_tmr_aa_restore>:

u32_t radio_tmr_aa_restore(void)
{
	/* NOTE: we dont need to restore for now, but return the saved value. */
	return radio_tmr_aa;
}
   1e9f4:	4b01      	ldr	r3, [pc, #4]	; (1e9fc <radio_tmr_aa_restore+0x8>)
   1e9f6:	6818      	ldr	r0, [r3, #0]
   1e9f8:	4770      	bx	lr
   1e9fa:	bf00      	nop
   1e9fc:	20001b48 	.word	0x20001b48

0001ea00 <radio_tmr_ready_get>:

u32_t radio_tmr_ready_get(void)
{
	return EVENT_TIMER->CC[0];
   1ea00:	4b01      	ldr	r3, [pc, #4]	; (1ea08 <radio_tmr_ready_get+0x8>)
   1ea02:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
}
   1ea06:	4770      	bx	lr
   1ea08:	40008000 	.word	0x40008000

0001ea0c <radio_tmr_end_capture>:
   1ea0c:	4b02      	ldr	r3, [pc, #8]	; (1ea18 <radio_tmr_end_capture+0xc>)
   1ea0e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
   1ea12:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504

void radio_tmr_end_capture(void)
{
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
}
   1ea16:	4770      	bx	lr
   1ea18:	4001f000 	.word	0x4001f000

0001ea1c <radio_tmr_end_get>:
u32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
   1ea1c:	4b01      	ldr	r3, [pc, #4]	; (1ea24 <radio_tmr_end_get+0x8>)
   1ea1e:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
   1ea22:	4770      	bx	lr
   1ea24:	40008000 	.word	0x40008000

0001ea28 <radio_tmr_tifs_base_get>:
   1ea28:	4b01      	ldr	r3, [pc, #4]	; (1ea30 <radio_tmr_tifs_base_get+0x8>)
   1ea2a:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
   1ea2e:	4770      	bx	lr
   1ea30:	40008000 	.word	0x40008000

0001ea34 <radio_ar_match_get>:
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}

u32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
   1ea34:	4b01      	ldr	r3, [pc, #4]	; (1ea3c <radio_ar_match_get+0x8>)
   1ea36:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   1ea3a:	4770      	bx	lr
   1ea3c:	4000f000 	.word	0x4000f000

0001ea40 <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
   1ea40:	4a04      	ldr	r2, [pc, #16]	; (1ea54 <radio_ar_status_reset+0x14>)
   1ea42:	2300      	movs	r3, #0
   1ea44:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
   1ea48:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
   1ea4c:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
}
   1ea50:	4770      	bx	lr
   1ea52:	bf00      	nop
   1ea54:	40001000 	.word	0x40001000

0001ea58 <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
   1ea58:	4b08      	ldr	r3, [pc, #32]	; (1ea7c <radio_ar_has_match+0x24>)
   1ea5a:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

u32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
   1ea5e:	b160      	cbz	r0, 1ea7a <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
   1ea60:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
   1ea64:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
   1ea68:	b138      	cbz	r0, 1ea7a <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
   1ea6a:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
   1ea6e:	b120      	cbz	r0, 1ea7a <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
   1ea70:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
   1ea74:	fab0 f080 	clz	r0, r0
   1ea78:	0940      	lsrs	r0, r0, #5
}
   1ea7a:	4770      	bx	lr
   1ea7c:	40001000 	.word	0x40001000

0001ea80 <mayfly_enable_cb>:

void mayfly_enable_cb(u8_t caller_id, u8_t callee_id, u8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   1ea80:	2902      	cmp	r1, #2
{
   1ea82:	b510      	push	{r4, lr}
   1ea84:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   1ea86:	d00b      	beq.n	1eaa0 <mayfly_enable_cb+0x20>
   1ea88:	4a0a      	ldr	r2, [pc, #40]	; (1eab4 <mayfly_enable_cb+0x34>)
   1ea8a:	490b      	ldr	r1, [pc, #44]	; (1eab8 <mayfly_enable_cb+0x38>)
   1ea8c:	480b      	ldr	r0, [pc, #44]	; (1eabc <mayfly_enable_cb+0x3c>)
   1ea8e:	2325      	movs	r3, #37	; 0x25
   1ea90:	f005 fa27 	bl	23ee2 <printk>
   1ea94:	4040      	eors	r0, r0
   1ea96:	f380 8811 	msr	BASEPRI, r0
   1ea9a:	f04f 0003 	mov.w	r0, #3
   1ea9e:	df02      	svc	2

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
   1eaa0:	200b      	movs	r0, #11
	if (enable) {
   1eaa2:	b11c      	cbz	r4, 1eaac <mayfly_enable_cb+0x2c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
   1eaa4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
   1eaa8:	f7e5 bf56 	b.w	4958 <arch_irq_enable>
}
   1eaac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
   1eab0:	f7e5 bf62 	b.w	4978 <arch_irq_disable>
   1eab4:	00030bba 	.word	0x00030bba
   1eab8:	00030c08 	.word	0x00030c08
   1eabc:	0002a5e8 	.word	0x0002a5e8

0001eac0 <mayfly_is_enabled>:

u32_t mayfly_is_enabled(u8_t caller_id, u8_t callee_id)
{
   1eac0:	b508      	push	{r3, lr}
	(void)caller_id;

	switch (callee_id) {
   1eac2:	b181      	cbz	r1, 1eae6 <mayfly_is_enabled+0x26>
   1eac4:	3901      	subs	r1, #1
   1eac6:	2901      	cmp	r1, #1
   1eac8:	d912      	bls.n	1eaf0 <mayfly_is_enabled+0x30>

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
   1eaca:	4a0a      	ldr	r2, [pc, #40]	; (1eaf4 <mayfly_is_enabled+0x34>)
   1eacc:	490a      	ldr	r1, [pc, #40]	; (1eaf8 <mayfly_is_enabled+0x38>)
   1eace:	480b      	ldr	r0, [pc, #44]	; (1eafc <mayfly_is_enabled+0x3c>)
   1ead0:	233f      	movs	r3, #63	; 0x3f
   1ead2:	f005 fa06 	bl	23ee2 <printk>
   1ead6:	4040      	eors	r0, r0
   1ead8:	f380 8811 	msr	BASEPRI, r0
   1eadc:	f04f 0003 	mov.w	r0, #3
   1eae0:	df02      	svc	2
		break;
	}

	return 0;
}
   1eae2:	2000      	movs	r0, #0
   1eae4:	bd08      	pop	{r3, pc}
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
   1eae6:	2018      	movs	r0, #24
}
   1eae8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
   1eaec:	f7e5 bf58 	b.w	49a0 <arch_irq_is_enabled>
   1eaf0:	200b      	movs	r0, #11
   1eaf2:	e7f9      	b.n	1eae8 <mayfly_is_enabled+0x28>
   1eaf4:	00030bba 	.word	0x00030bba
   1eaf8:	0002e3c9 	.word	0x0002e3c9
   1eafc:	0002a5e8 	.word	0x0002a5e8

0001eb00 <mayfly_pend>:

void mayfly_pend(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   1eb00:	2901      	cmp	r1, #1
{
   1eb02:	b508      	push	{r3, lr}
	switch (callee_id) {
   1eb04:	d008      	beq.n	1eb18 <mayfly_pend+0x18>
   1eb06:	2902      	cmp	r1, #2
   1eb08:	d006      	beq.n	1eb18 <mayfly_pend+0x18>
   1eb0a:	b949      	cbnz	r1, 1eb20 <mayfly_pend+0x20>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1eb0c:	4b0b      	ldr	r3, [pc, #44]	; (1eb3c <mayfly_pend+0x3c>)
   1eb0e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1eb12:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

	default:
		LL_ASSERT(0);
		break;
	}
}
   1eb16:	bd08      	pop	{r3, pc}
   1eb18:	4b08      	ldr	r3, [pc, #32]	; (1eb3c <mayfly_pend+0x3c>)
   1eb1a:	f44f 6200 	mov.w	r2, #2048	; 0x800
   1eb1e:	e7f8      	b.n	1eb12 <mayfly_pend+0x12>
		LL_ASSERT(0);
   1eb20:	4a07      	ldr	r2, [pc, #28]	; (1eb40 <mayfly_pend+0x40>)
   1eb22:	4908      	ldr	r1, [pc, #32]	; (1eb44 <mayfly_pend+0x44>)
   1eb24:	4808      	ldr	r0, [pc, #32]	; (1eb48 <mayfly_pend+0x48>)
   1eb26:	237b      	movs	r3, #123	; 0x7b
   1eb28:	f005 f9db 	bl	23ee2 <printk>
   1eb2c:	4040      	eors	r0, r0
   1eb2e:	f380 8811 	msr	BASEPRI, r0
   1eb32:	f04f 0003 	mov.w	r0, #3
   1eb36:	df02      	svc	2
}
   1eb38:	e7ed      	b.n	1eb16 <mayfly_pend+0x16>
   1eb3a:	bf00      	nop
   1eb3c:	e000e100 	.word	0xe000e100
   1eb40:	00030bba 	.word	0x00030bba
   1eb44:	0002e3c9 	.word	0x0002e3c9
   1eb48:	0002a5e8 	.word	0x0002a5e8

0001eb4c <hal_ticker_instance0_caller_id_get>:

u8_t hal_ticker_instance0_caller_id_get(u8_t user_id)
{
	u8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
   1eb4c:	2803      	cmp	r0, #3
{
   1eb4e:	b510      	push	{r4, lr}
   1eb50:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
   1eb52:	d90b      	bls.n	1eb6c <hal_ticker_instance0_caller_id_get+0x20>
   1eb54:	4a0e      	ldr	r2, [pc, #56]	; (1eb90 <hal_ticker_instance0_caller_id_get+0x44>)
   1eb56:	490f      	ldr	r1, [pc, #60]	; (1eb94 <hal_ticker_instance0_caller_id_get+0x48>)
   1eb58:	480f      	ldr	r0, [pc, #60]	; (1eb98 <hal_ticker_instance0_caller_id_get+0x4c>)
   1eb5a:	2338      	movs	r3, #56	; 0x38
   1eb5c:	f005 f9c1 	bl	23ee2 <printk>
   1eb60:	4040      	eors	r0, r0
   1eb62:	f380 8811 	msr	BASEPRI, r0
   1eb66:	f04f 0003 	mov.w	r0, #3
   1eb6a:	df02      	svc	2

	caller_id = caller_id_lut[user_id];
   1eb6c:	4b0b      	ldr	r3, [pc, #44]	; (1eb9c <hal_ticker_instance0_caller_id_get+0x50>)
   1eb6e:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
   1eb70:	b95c      	cbnz	r4, 1eb8a <hal_ticker_instance0_caller_id_get+0x3e>
   1eb72:	4a07      	ldr	r2, [pc, #28]	; (1eb90 <hal_ticker_instance0_caller_id_get+0x44>)
   1eb74:	490a      	ldr	r1, [pc, #40]	; (1eba0 <hal_ticker_instance0_caller_id_get+0x54>)
   1eb76:	4808      	ldr	r0, [pc, #32]	; (1eb98 <hal_ticker_instance0_caller_id_get+0x4c>)
   1eb78:	233b      	movs	r3, #59	; 0x3b
   1eb7a:	f005 f9b2 	bl	23ee2 <printk>
   1eb7e:	4040      	eors	r0, r0
   1eb80:	f380 8811 	msr	BASEPRI, r0
   1eb84:	f04f 0003 	mov.w	r0, #3
   1eb88:	df02      	svc	2

	return caller_id;
}
   1eb8a:	4620      	mov	r0, r4
   1eb8c:	bd10      	pop	{r4, pc}
   1eb8e:	bf00      	nop
   1eb90:	00030c2a 	.word	0x00030c2a
   1eb94:	00030c78 	.word	0x00030c78
   1eb98:	0002a5e8 	.word	0x0002a5e8
   1eb9c:	00030cba 	.word	0x00030cba
   1eba0:	00030c98 	.word	0x00030c98

0001eba4 <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
   1eba4:	3801      	subs	r0, #1
{
   1eba6:	b510      	push	{r4, lr}
   1eba8:	461c      	mov	r4, r3
   1ebaa:	2804      	cmp	r0, #4
   1ebac:	d845      	bhi.n	1ec3a <hal_ticker_instance0_sched+0x96>
   1ebae:	e8df f000 	tbb	[pc, r0]
   1ebb2:	1a03      	.short	0x1a03
   1ebb4:	2c23      	.short	0x2c23
   1ebb6:	3b          	.byte	0x3b
   1ebb7:	00          	.byte	0x00
#if defined(CONFIG_BT_LL_SW_SPLIT)
	case TICKER_CALL_ID_ISR:
		switch (callee_id) {
   1ebb8:	2904      	cmp	r1, #4
   1ebba:	d107      	bne.n	1ebcc <hal_ticker_instance0_sched+0x28>
		{
			static memq_link_t link;
			static struct mayfly m = {0, 0, &link, NULL,
						  ticker_job};

			m.param = instance;
   1ebbc:	4b20      	ldr	r3, [pc, #128]	; (1ec40 <hal_ticker_instance0_sched+0x9c>)

			/* TODO: scheduler lock, if preemptive threads used */
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   1ebbe:	2102      	movs	r1, #2
			m.param = instance;
   1ebc0:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   1ebc2:	2000      	movs	r0, #0

	default:
		LL_ASSERT(0);
		break;
	}
}
   1ebc4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   1ebc8:	f7f9 bab0 	b.w	1812c <mayfly_enqueue>
			LL_ASSERT(0);
   1ebcc:	235c      	movs	r3, #92	; 0x5c
		LL_ASSERT(0);
   1ebce:	4a1d      	ldr	r2, [pc, #116]	; (1ec44 <hal_ticker_instance0_sched+0xa0>)
   1ebd0:	491d      	ldr	r1, [pc, #116]	; (1ec48 <hal_ticker_instance0_sched+0xa4>)
   1ebd2:	481e      	ldr	r0, [pc, #120]	; (1ec4c <hal_ticker_instance0_sched+0xa8>)
   1ebd4:	f005 f985 	bl	23ee2 <printk>
   1ebd8:	4040      	eors	r0, r0
   1ebda:	f380 8811 	msr	BASEPRI, r0
   1ebde:	f04f 0003 	mov.w	r0, #3
   1ebe2:	df02      	svc	2
}
   1ebe4:	bd10      	pop	{r4, pc}
		switch (callee_id) {
   1ebe6:	2903      	cmp	r1, #3
   1ebe8:	d104      	bne.n	1ebf4 <hal_ticker_instance0_sched+0x50>
			m.param = instance;
   1ebea:	4b19      	ldr	r3, [pc, #100]	; (1ec50 <hal_ticker_instance0_sched+0xac>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
   1ebec:	2101      	movs	r1, #1
			m.param = instance;
   1ebee:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   1ebf0:	4608      	mov	r0, r1
   1ebf2:	e7e7      	b.n	1ebc4 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   1ebf4:	2374      	movs	r3, #116	; 0x74
   1ebf6:	e7ea      	b.n	1ebce <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
   1ebf8:	2904      	cmp	r1, #4
   1ebfa:	d104      	bne.n	1ec06 <hal_ticker_instance0_sched+0x62>
			m.param = instance;
   1ebfc:	4b15      	ldr	r3, [pc, #84]	; (1ec54 <hal_ticker_instance0_sched+0xb0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   1ebfe:	2102      	movs	r1, #2
			m.param = instance;
   1ec00:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   1ec02:	2001      	movs	r0, #1
   1ec04:	e7de      	b.n	1ebc4 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   1ec06:	238b      	movs	r3, #139	; 0x8b
   1ec08:	e7e1      	b.n	1ebce <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
   1ec0a:	2903      	cmp	r1, #3
   1ec0c:	d003      	beq.n	1ec16 <hal_ticker_instance0_sched+0x72>
   1ec0e:	2904      	cmp	r1, #4
   1ec10:	d006      	beq.n	1ec20 <hal_ticker_instance0_sched+0x7c>
			LL_ASSERT(0);
   1ec12:	23b1      	movs	r3, #177	; 0xb1
   1ec14:	e7db      	b.n	1ebce <hal_ticker_instance0_sched+0x2a>
			m.param = instance;
   1ec16:	4b10      	ldr	r3, [pc, #64]	; (1ec58 <hal_ticker_instance0_sched+0xb4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   1ec18:	2101      	movs	r1, #1
			m.param = instance;
   1ec1a:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   1ec1c:	2002      	movs	r0, #2
   1ec1e:	e7d1      	b.n	1ebc4 <hal_ticker_instance0_sched+0x20>
			m.param = instance;
   1ec20:	4b0e      	ldr	r3, [pc, #56]	; (1ec5c <hal_ticker_instance0_sched+0xb8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   1ec22:	2102      	movs	r1, #2
			m.param = instance;
   1ec24:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   1ec26:	e7e3      	b.n	1ebf0 <hal_ticker_instance0_sched+0x4c>
		switch (callee_id) {
   1ec28:	2904      	cmp	r1, #4
   1ec2a:	d104      	bne.n	1ec36 <hal_ticker_instance0_sched+0x92>
			m.param = instance;
   1ec2c:	4b0c      	ldr	r3, [pc, #48]	; (1ec60 <hal_ticker_instance0_sched+0xbc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   1ec2e:	2102      	movs	r1, #2
			m.param = instance;
   1ec30:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   1ec32:	2003      	movs	r0, #3
   1ec34:	e7c6      	b.n	1ebc4 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   1ec36:	23c9      	movs	r3, #201	; 0xc9
   1ec38:	e7c9      	b.n	1ebce <hal_ticker_instance0_sched+0x2a>
		LL_ASSERT(0);
   1ec3a:	23cf      	movs	r3, #207	; 0xcf
   1ec3c:	e7c7      	b.n	1ebce <hal_ticker_instance0_sched+0x2a>
   1ec3e:	bf00      	nop
   1ec40:	20007364 	.word	0x20007364
   1ec44:	00030c2a 	.word	0x00030c2a
   1ec48:	0002e3c9 	.word	0x0002e3c9
   1ec4c:	0002a5e8 	.word	0x0002a5e8
   1ec50:	20007374 	.word	0x20007374
   1ec54:	20007384 	.word	0x20007384
   1ec58:	20007394 	.word	0x20007394
   1ec5c:	200073a4 	.word	0x200073a4
   1ec60:	200073b4 	.word	0x200073b4

0001ec64 <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
   1ec64:	4b02      	ldr	r3, [pc, #8]	; (1ec70 <net_buf_pool_get+0xc>)
   1ec66:	2224      	movs	r2, #36	; 0x24
   1ec68:	fb02 3000 	mla	r0, r2, r0, r3
   1ec6c:	4770      	bx	lr
   1ec6e:	bf00      	nop
   1ec70:	20007670 	.word	0x20007670

0001ec74 <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   1ec74:	7983      	ldrb	r3, [r0, #6]

	return buf - pool->__bufs;
   1ec76:	4a05      	ldr	r2, [pc, #20]	; (1ec8c <net_buf_id+0x18>)
   1ec78:	2124      	movs	r1, #36	; 0x24
   1ec7a:	fb01 2303 	mla	r3, r1, r3, r2
   1ec7e:	6a1b      	ldr	r3, [r3, #32]
   1ec80:	1ac0      	subs	r0, r0, r3
}
   1ec82:	4b03      	ldr	r3, [pc, #12]	; (1ec90 <net_buf_id+0x1c>)
	return buf - pool->__bufs;
   1ec84:	10c0      	asrs	r0, r0, #3
}
   1ec86:	4358      	muls	r0, r3
   1ec88:	4770      	bx	lr
   1ec8a:	bf00      	nop
   1ec8c:	20007670 	.word	0x20007670
   1ec90:	aaaaaaab 	.word	0xaaaaaaab

0001ec94 <fixed_data_alloc>:
	.ref   = generic_data_ref,
	.unref = mem_pool_data_unref,
};

static u8_t *fixed_data_alloc(struct net_buf *buf, size_t *size, s32_t timeout)
{
   1ec94:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1ec96:	4a0a      	ldr	r2, [pc, #40]	; (1ecc0 <fixed_data_alloc+0x2c>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   1ec98:	7983      	ldrb	r3, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1ec9a:	2424      	movs	r4, #36	; 0x24
   1ec9c:	fb04 2303 	mla	r3, r4, r3, r2

	*size = MIN(fixed->data_size, *size);
   1eca0:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1eca2:	69db      	ldr	r3, [r3, #28]
   1eca4:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
   1eca6:	6823      	ldr	r3, [r4, #0]
   1eca8:	429a      	cmp	r2, r3
   1ecaa:	bf94      	ite	ls
   1ecac:	600a      	strls	r2, [r1, #0]
   1ecae:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   1ecb0:	f7ff ffe0 	bl	1ec74 <net_buf_id>
   1ecb4:	e9d4 2300 	ldrd	r2, r3, [r4]
}
   1ecb8:	fb02 3000 	mla	r0, r2, r0, r3
   1ecbc:	bd10      	pop	{r4, pc}
   1ecbe:	bf00      	nop
   1ecc0:	20007670 	.word	0x20007670

0001ecc4 <net_buf_reset>:
{
   1ecc4:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(buf->flags == 0U);
   1ecc6:	7943      	ldrb	r3, [r0, #5]
{
   1ecc8:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(buf->flags == 0U);
   1ecca:	b14b      	cbz	r3, 1ece0 <net_buf_reset+0x1c>
   1eccc:	490d      	ldr	r1, [pc, #52]	; (1ed04 <net_buf_reset+0x40>)
   1ecce:	480e      	ldr	r0, [pc, #56]	; (1ed08 <net_buf_reset+0x44>)
   1ecd0:	4a0e      	ldr	r2, [pc, #56]	; (1ed0c <net_buf_reset+0x48>)
   1ecd2:	234f      	movs	r3, #79	; 0x4f
   1ecd4:	f005 f905 	bl	23ee2 <printk>
   1ecd8:	480c      	ldr	r0, [pc, #48]	; (1ed0c <net_buf_reset+0x48>)
   1ecda:	214f      	movs	r1, #79	; 0x4f
   1ecdc:	f005 f944 	bl	23f68 <assert_post_action>
	__ASSERT_NO_MSG(buf->frags == NULL);
   1ece0:	6823      	ldr	r3, [r4, #0]
   1ece2:	b14b      	cbz	r3, 1ecf8 <net_buf_reset+0x34>
   1ece4:	490a      	ldr	r1, [pc, #40]	; (1ed10 <net_buf_reset+0x4c>)
   1ece6:	4808      	ldr	r0, [pc, #32]	; (1ed08 <net_buf_reset+0x44>)
   1ece8:	4a08      	ldr	r2, [pc, #32]	; (1ed0c <net_buf_reset+0x48>)
   1ecea:	2350      	movs	r3, #80	; 0x50
   1ecec:	f005 f8f9 	bl	23ee2 <printk>
   1ecf0:	4806      	ldr	r0, [pc, #24]	; (1ed0c <net_buf_reset+0x48>)
   1ecf2:	2150      	movs	r1, #80	; 0x50
   1ecf4:	f005 f938 	bl	23f68 <assert_post_action>
	buf->len  = 0U;
   1ecf8:	2300      	movs	r3, #0
   1ecfa:	81a3      	strh	r3, [r4, #12]
	buf->data = buf->__buf;
   1ecfc:	6923      	ldr	r3, [r4, #16]
   1ecfe:	60a3      	str	r3, [r4, #8]
}
   1ed00:	bd10      	pop	{r4, pc}
   1ed02:	bf00      	nop
   1ed04:	00030ce2 	.word	0x00030ce2
   1ed08:	0002a5e8 	.word	0x0002a5e8
   1ed0c:	00030cbe 	.word	0x00030cbe
   1ed10:	00030cf3 	.word	0x00030cf3

0001ed14 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  s32_t timeout)
#endif
{
   1ed14:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1ed18:	4605      	mov	r5, r0
   1ed1a:	9101      	str	r1, [sp, #4]
   1ed1c:	4616      	mov	r6, r2
	u32_t alloc_start = k_uptime_get_32();
   1ed1e:	f009 ffdf 	bl	28ce0 <k_uptime_get_32>
   1ed22:	4680      	mov	r8, r0
	struct net_buf *buf;
	unsigned int key;

	__ASSERT_NO_MSG(pool);
   1ed24:	b94d      	cbnz	r5, 1ed3a <net_buf_alloc_len+0x26>
   1ed26:	4945      	ldr	r1, [pc, #276]	; (1ee3c <net_buf_alloc_len+0x128>)
   1ed28:	4845      	ldr	r0, [pc, #276]	; (1ee40 <net_buf_alloc_len+0x12c>)
   1ed2a:	4a46      	ldr	r2, [pc, #280]	; (1ee44 <net_buf_alloc_len+0x130>)
   1ed2c:	23ef      	movs	r3, #239	; 0xef
   1ed2e:	f005 f8d8 	bl	23ee2 <printk>
   1ed32:	4844      	ldr	r0, [pc, #272]	; (1ee44 <net_buf_alloc_len+0x130>)
   1ed34:	21ef      	movs	r1, #239	; 0xef
   1ed36:	f005 f917 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   1ed3a:	f04f 0320 	mov.w	r3, #32
   1ed3e:	f3ef 8711 	mrs	r7, BASEPRI
   1ed42:	f383 8811 	msr	BASEPRI, r3
   1ed46:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   1ed4a:	8aeb      	ldrh	r3, [r5, #22]
   1ed4c:	2b00      	cmp	r3, #0
   1ed4e:	d048      	beq.n	1ede2 <net_buf_alloc_len+0xce>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   1ed50:	8aaa      	ldrh	r2, [r5, #20]
   1ed52:	429a      	cmp	r2, r3
   1ed54:	d931      	bls.n	1edba <net_buf_alloc_len+0xa6>
	return z_impl_k_queue_get(queue, timeout);
   1ed56:	2100      	movs	r1, #0
   1ed58:	4628      	mov	r0, r5
   1ed5a:	f002 f983 	bl	21064 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   1ed5e:	4604      	mov	r4, r0
   1ed60:	b358      	cbz	r0, 1edba <net_buf_alloc_len+0xa6>
	__asm__ volatile(
   1ed62:	f387 8811 	msr	BASEPRI, r7
   1ed66:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   1ed6a:	9f01      	ldr	r7, [sp, #4]
   1ed6c:	2f00      	cmp	r7, #0
   1ed6e:	d063      	beq.n	1ee38 <net_buf_alloc_len+0x124>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
   1ed70:	1c73      	adds	r3, r6, #1
   1ed72:	2b01      	cmp	r3, #1
   1ed74:	d907      	bls.n	1ed86 <net_buf_alloc_len+0x72>
			u32_t diff = k_uptime_get_32() - alloc_start;
   1ed76:	f009 ffb3 	bl	28ce0 <k_uptime_get_32>
   1ed7a:	eba0 0008 	sub.w	r0, r0, r8

			timeout -= MIN(timeout, diff);
   1ed7e:	42b0      	cmp	r0, r6
   1ed80:	bf94      	ite	ls
   1ed82:	1a36      	subls	r6, r6, r0
   1ed84:	1bb6      	subhi	r6, r6, r6
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   1ed86:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
   1ed88:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 1ee48 <net_buf_alloc_len+0x134>
   1ed8c:	2224      	movs	r2, #36	; 0x24
   1ed8e:	fb02 8303 	mla	r3, r2, r3, r8
   1ed92:	a901      	add	r1, sp, #4
   1ed94:	69db      	ldr	r3, [r3, #28]
   1ed96:	681b      	ldr	r3, [r3, #0]
   1ed98:	4632      	mov	r2, r6
   1ed9a:	681b      	ldr	r3, [r3, #0]
   1ed9c:	4620      	mov	r0, r4
   1ed9e:	4798      	blx	r3
   1eda0:	4605      	mov	r5, r0
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   1eda2:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
   1eda4:	bb60      	cbnz	r0, 1ee00 <net_buf_alloc_len+0xec>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
   1eda6:	79a0      	ldrb	r0, [r4, #6]
   1eda8:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   1edac:	4621      	mov	r1, r4
   1edae:	eb08 0080 	add.w	r0, r8, r0, lsl #2
   1edb2:	f00a fa53 	bl	2925c <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
   1edb6:	462c      	mov	r4, r5
}
   1edb8:	e01e      	b.n	1edf8 <net_buf_alloc_len+0xe4>
		uninit_count = pool->uninit_count--;
   1edba:	8ae8      	ldrh	r0, [r5, #22]
   1edbc:	1e43      	subs	r3, r0, #1
   1edbe:	82eb      	strh	r3, [r5, #22]
   1edc0:	f387 8811 	msr	BASEPRI, r7
   1edc4:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
   1edc8:	8aac      	ldrh	r4, [r5, #20]
   1edca:	1a24      	subs	r4, r4, r0
   1edcc:	6a28      	ldr	r0, [r5, #32]
   1edce:	2318      	movs	r3, #24
   1edd0:	fb03 0404 	mla	r4, r3, r4, r0
	return pool - _net_buf_pool_list;
   1edd4:	4b1c      	ldr	r3, [pc, #112]	; (1ee48 <net_buf_alloc_len+0x134>)
   1edd6:	1aed      	subs	r5, r5, r3
   1edd8:	4b1c      	ldr	r3, [pc, #112]	; (1ee4c <net_buf_alloc_len+0x138>)
   1edda:	10ad      	asrs	r5, r5, #2
   1eddc:	435d      	muls	r5, r3
	buf->pool_id = pool_id(pool);
   1edde:	71a5      	strb	r5, [r4, #6]
		goto success;
   1ede0:	e7c3      	b.n	1ed6a <net_buf_alloc_len+0x56>
   1ede2:	f387 8811 	msr	BASEPRI, r7
   1ede6:	f3bf 8f6f 	isb	sy
   1edea:	4631      	mov	r1, r6
   1edec:	4628      	mov	r0, r5
   1edee:	f002 f939 	bl	21064 <z_impl_k_queue_get>
	if (!buf) {
   1edf2:	4604      	mov	r4, r0
   1edf4:	2800      	cmp	r0, #0
   1edf6:	d1b8      	bne.n	1ed6a <net_buf_alloc_len+0x56>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	pool->avail_count--;
	__ASSERT_NO_MSG(pool->avail_count >= 0);
#endif
	return buf;
}
   1edf8:	4620      	mov	r0, r4
   1edfa:	b002      	add	sp, #8
   1edfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		NET_BUF_ASSERT(req_size <= size);
   1ee00:	9b01      	ldr	r3, [sp, #4]
   1ee02:	429f      	cmp	r7, r3
   1ee04:	d90e      	bls.n	1ee24 <net_buf_alloc_len+0x110>
   1ee06:	4912      	ldr	r1, [pc, #72]	; (1ee50 <net_buf_alloc_len+0x13c>)
   1ee08:	4a0e      	ldr	r2, [pc, #56]	; (1ee44 <net_buf_alloc_len+0x130>)
   1ee0a:	480d      	ldr	r0, [pc, #52]	; (1ee40 <net_buf_alloc_len+0x12c>)
   1ee0c:	f240 134b 	movw	r3, #331	; 0x14b
   1ee10:	f005 f867 	bl	23ee2 <printk>
   1ee14:	480f      	ldr	r0, [pc, #60]	; (1ee54 <net_buf_alloc_len+0x140>)
   1ee16:	f005 f864 	bl	23ee2 <printk>
   1ee1a:	480a      	ldr	r0, [pc, #40]	; (1ee44 <net_buf_alloc_len+0x130>)
   1ee1c:	f240 114b 	movw	r1, #331	; 0x14b
   1ee20:	f005 f8a2 	bl	23f68 <assert_post_action>
	buf->frags = NULL;
   1ee24:	2300      	movs	r3, #0
   1ee26:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
   1ee28:	2301      	movs	r3, #1
   1ee2a:	80a3      	strh	r3, [r4, #4]
	buf->size  = size;
   1ee2c:	9b01      	ldr	r3, [sp, #4]
   1ee2e:	81e3      	strh	r3, [r4, #14]
	net_buf_reset(buf);
   1ee30:	4620      	mov	r0, r4
   1ee32:	f7ff ff47 	bl	1ecc4 <net_buf_reset>
	return buf;
   1ee36:	e7df      	b.n	1edf8 <net_buf_alloc_len+0xe4>
		buf->__buf = NULL;
   1ee38:	6127      	str	r7, [r4, #16]
   1ee3a:	e7f3      	b.n	1ee24 <net_buf_alloc_len+0x110>
   1ee3c:	00030d0d 	.word	0x00030d0d
   1ee40:	0002a5e8 	.word	0x0002a5e8
   1ee44:	00030cbe 	.word	0x00030cbe
   1ee48:	20007670 	.word	0x20007670
   1ee4c:	38e38e39 	.word	0x38e38e39
   1ee50:	00030d12 	.word	0x00030d12
   1ee54:	00030d23 	.word	0x00030d23

0001ee58 <net_buf_get>:
struct net_buf *net_buf_get_debug(struct k_fifo *fifo, s32_t timeout,
				  const char *func, int line)
#else
struct net_buf *net_buf_get(struct k_fifo *fifo, s32_t timeout)
#endif
{
   1ee58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1ee5c:	4606      	mov	r6, r0
   1ee5e:	f002 f901 	bl	21064 <z_impl_k_queue_get>
	struct net_buf *buf, *frag;

	NET_BUF_DBG("%s():%d: fifo %p timeout %d", func, line, fifo, timeout);

	buf = k_fifo_get(fifo, timeout);
	if (!buf) {
   1ee62:	4605      	mov	r5, r0
   1ee64:	b150      	cbz	r0, 1ee7c <net_buf_get+0x24>
	NET_BUF_DBG("%s():%d: buf %p fifo %p", func, line, buf, fifo);

	/* Get any fragments belonging to this buffer */
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
		__ASSERT_NO_MSG(frag->frags);
   1ee66:	4f13      	ldr	r7, [pc, #76]	; (1eeb4 <net_buf_get+0x5c>)
   1ee68:	f8df 804c 	ldr.w	r8, [pc, #76]	; 1eeb8 <net_buf_get+0x60>
   1ee6c:	f8df 904c 	ldr.w	r9, [pc, #76]	; 1eebc <net_buf_get+0x64>
   1ee70:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1ee72:	7963      	ldrb	r3, [r4, #5]
   1ee74:	f013 0301 	ands.w	r3, r3, #1
   1ee78:	d103      	bne.n	1ee82 <net_buf_get+0x2a>
		/* The fragments flag is only for FIFO-internal usage */
		frag->flags &= ~NET_BUF_FRAGS;
	}

	/* Mark the end of the fragment list */
	frag->frags = NULL;
   1ee7a:	6023      	str	r3, [r4, #0]

	return buf;
}
   1ee7c:	4628      	mov	r0, r5
   1ee7e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1ee82:	2100      	movs	r1, #0
   1ee84:	4630      	mov	r0, r6
   1ee86:	f002 f8ed 	bl	21064 <z_impl_k_queue_get>
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   1ee8a:	6020      	str	r0, [r4, #0]
		__ASSERT_NO_MSG(frag->frags);
   1ee8c:	b958      	cbnz	r0, 1eea6 <net_buf_get+0x4e>
   1ee8e:	4641      	mov	r1, r8
   1ee90:	4648      	mov	r0, r9
   1ee92:	f240 13a1 	movw	r3, #417	; 0x1a1
   1ee96:	463a      	mov	r2, r7
   1ee98:	f005 f823 	bl	23ee2 <printk>
   1ee9c:	f240 11a1 	movw	r1, #417	; 0x1a1
   1eea0:	4638      	mov	r0, r7
   1eea2:	f005 f861 	bl	23f68 <assert_post_action>
		frag->flags &= ~NET_BUF_FRAGS;
   1eea6:	7963      	ldrb	r3, [r4, #5]
   1eea8:	f023 0301 	bic.w	r3, r3, #1
   1eeac:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1eeae:	6824      	ldr	r4, [r4, #0]
   1eeb0:	e7df      	b.n	1ee72 <net_buf_get+0x1a>
   1eeb2:	bf00      	nop
   1eeb4:	00030cbe 	.word	0x00030cbe
   1eeb8:	00030d26 	.word	0x00030d26
   1eebc:	0002a5e8 	.word	0x0002a5e8

0001eec0 <net_buf_simple_reserve>:
	buf->size  = size;
	buf->len   = size;
}

void net_buf_simple_reserve(struct net_buf_simple *buf, size_t reserve)
{
   1eec0:	b538      	push	{r3, r4, r5, lr}
   1eec2:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(buf);
   1eec4:	4604      	mov	r4, r0
   1eec6:	b958      	cbnz	r0, 1eee0 <net_buf_simple_reserve+0x20>
   1eec8:	490e      	ldr	r1, [pc, #56]	; (1ef04 <net_buf_simple_reserve+0x44>)
   1eeca:	480f      	ldr	r0, [pc, #60]	; (1ef08 <net_buf_simple_reserve+0x48>)
   1eecc:	4a0f      	ldr	r2, [pc, #60]	; (1ef0c <net_buf_simple_reserve+0x4c>)
   1eece:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
   1eed2:	f005 f806 	bl	23ee2 <printk>
   1eed6:	480d      	ldr	r0, [pc, #52]	; (1ef0c <net_buf_simple_reserve+0x4c>)
   1eed8:	f44f 71dc 	mov.w	r1, #440	; 0x1b8
   1eedc:	f005 f844 	bl	23f68 <assert_post_action>
	__ASSERT_NO_MSG(buf->len == 0U);
   1eee0:	88a3      	ldrh	r3, [r4, #4]
   1eee2:	b15b      	cbz	r3, 1eefc <net_buf_simple_reserve+0x3c>
   1eee4:	490a      	ldr	r1, [pc, #40]	; (1ef10 <net_buf_simple_reserve+0x50>)
   1eee6:	4808      	ldr	r0, [pc, #32]	; (1ef08 <net_buf_simple_reserve+0x48>)
   1eee8:	4a08      	ldr	r2, [pc, #32]	; (1ef0c <net_buf_simple_reserve+0x4c>)
   1eeea:	f240 13b9 	movw	r3, #441	; 0x1b9
   1eeee:	f004 fff8 	bl	23ee2 <printk>
   1eef2:	4806      	ldr	r0, [pc, #24]	; (1ef0c <net_buf_simple_reserve+0x4c>)
   1eef4:	f240 11b9 	movw	r1, #441	; 0x1b9
   1eef8:	f005 f836 	bl	23f68 <assert_post_action>
	NET_BUF_DBG("buf %p reserve %zu", buf, reserve);

	buf->data = buf->__buf + reserve;
   1eefc:	68a3      	ldr	r3, [r4, #8]
   1eefe:	442b      	add	r3, r5
   1ef00:	6023      	str	r3, [r4, #0]
}
   1ef02:	bd38      	pop	{r3, r4, r5, pc}
   1ef04:	00030dcd 	.word	0x00030dcd
   1ef08:	0002a5e8 	.word	0x0002a5e8
   1ef0c:	00030cbe 	.word	0x00030cbe
   1ef10:	00030d32 	.word	0x00030d32

0001ef14 <net_buf_slist_put>:

void net_buf_slist_put(sys_slist_t *list, struct net_buf *buf)
{
   1ef14:	b538      	push	{r3, r4, r5, lr}
   1ef16:	460d      	mov	r5, r1
	struct net_buf *tail;
	unsigned int key;

	__ASSERT_NO_MSG(list);
   1ef18:	4604      	mov	r4, r0
   1ef1a:	b958      	cbnz	r0, 1ef34 <net_buf_slist_put+0x20>
   1ef1c:	491a      	ldr	r1, [pc, #104]	; (1ef88 <net_buf_slist_put+0x74>)
   1ef1e:	481b      	ldr	r0, [pc, #108]	; (1ef8c <net_buf_slist_put+0x78>)
   1ef20:	4a1b      	ldr	r2, [pc, #108]	; (1ef90 <net_buf_slist_put+0x7c>)
   1ef22:	f44f 73e2 	mov.w	r3, #452	; 0x1c4
   1ef26:	f004 ffdc 	bl	23ee2 <printk>
   1ef2a:	4819      	ldr	r0, [pc, #100]	; (1ef90 <net_buf_slist_put+0x7c>)
   1ef2c:	f44f 71e2 	mov.w	r1, #452	; 0x1c4
   1ef30:	f005 f81a 	bl	23f68 <assert_post_action>
	__ASSERT_NO_MSG(buf);
   1ef34:	b95d      	cbnz	r5, 1ef4e <net_buf_slist_put+0x3a>
   1ef36:	4917      	ldr	r1, [pc, #92]	; (1ef94 <net_buf_slist_put+0x80>)
   1ef38:	4814      	ldr	r0, [pc, #80]	; (1ef8c <net_buf_slist_put+0x78>)
   1ef3a:	4a15      	ldr	r2, [pc, #84]	; (1ef90 <net_buf_slist_put+0x7c>)
   1ef3c:	f240 13c5 	movw	r3, #453	; 0x1c5
   1ef40:	f004 ffcf 	bl	23ee2 <printk>
   1ef44:	4812      	ldr	r0, [pc, #72]	; (1ef90 <net_buf_slist_put+0x7c>)
   1ef46:	f240 11c5 	movw	r1, #453	; 0x1c5
   1ef4a:	f005 f80d 	bl	23f68 <assert_post_action>
{
   1ef4e:	462b      	mov	r3, r5

	for (tail = buf; tail->frags; tail = tail->frags) {
   1ef50:	6819      	ldr	r1, [r3, #0]
   1ef52:	b981      	cbnz	r1, 1ef76 <net_buf_slist_put+0x62>
	__asm__ volatile(
   1ef54:	f04f 0220 	mov.w	r2, #32
   1ef58:	f3ef 8111 	mrs	r1, BASEPRI
   1ef5c:	f382 8811 	msr	BASEPRI, r2
   1ef60:	f3bf 8f6f 	isb	sy
Z_GENLIST_APPEND_LIST(slist, snode)
   1ef64:	6862      	ldr	r2, [r4, #4]
   1ef66:	b962      	cbnz	r2, 1ef82 <net_buf_slist_put+0x6e>
	list->head = node;
   1ef68:	6025      	str	r5, [r4, #0]
	list->tail = node;
   1ef6a:	6063      	str	r3, [r4, #4]
	__asm__ volatile(
   1ef6c:	f381 8811 	msr	BASEPRI, r1
   1ef70:	f3bf 8f6f 	isb	sy
	}

	key = irq_lock();
	sys_slist_append_list(list, &buf->node, &tail->node);
	irq_unlock(key);
}
   1ef74:	bd38      	pop	{r3, r4, r5, pc}
		tail->flags |= NET_BUF_FRAGS;
   1ef76:	795a      	ldrb	r2, [r3, #5]
   1ef78:	f042 0201 	orr.w	r2, r2, #1
   1ef7c:	715a      	strb	r2, [r3, #5]
   1ef7e:	460b      	mov	r3, r1
   1ef80:	e7e6      	b.n	1ef50 <net_buf_slist_put+0x3c>
	parent->next = child;
   1ef82:	6015      	str	r5, [r2, #0]
}
   1ef84:	e7f1      	b.n	1ef6a <net_buf_slist_put+0x56>
   1ef86:	bf00      	nop
   1ef88:	0002ede5 	.word	0x0002ede5
   1ef8c:	0002a5e8 	.word	0x0002a5e8
   1ef90:	00030cbe 	.word	0x00030cbe
   1ef94:	00030dcd 	.word	0x00030dcd

0001ef98 <net_buf_slist_get>:

struct net_buf *net_buf_slist_get(sys_slist_t *list)
{
   1ef98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct net_buf *buf, *frag;
	unsigned int key;

	__ASSERT_NO_MSG(list);
   1ef9c:	4604      	mov	r4, r0
   1ef9e:	b958      	cbnz	r0, 1efb8 <net_buf_slist_get+0x20>
   1efa0:	492b      	ldr	r1, [pc, #172]	; (1f050 <net_buf_slist_get+0xb8>)
   1efa2:	482c      	ldr	r0, [pc, #176]	; (1f054 <net_buf_slist_get+0xbc>)
   1efa4:	4a2c      	ldr	r2, [pc, #176]	; (1f058 <net_buf_slist_get+0xc0>)
   1efa6:	f240 13d5 	movw	r3, #469	; 0x1d5
   1efaa:	f004 ff9a 	bl	23ee2 <printk>
   1efae:	482a      	ldr	r0, [pc, #168]	; (1f058 <net_buf_slist_get+0xc0>)
   1efb0:	f240 11d5 	movw	r1, #469	; 0x1d5
   1efb4:	f004 ffd8 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   1efb8:	f04f 0320 	mov.w	r3, #32
   1efbc:	f3ef 8211 	mrs	r2, BASEPRI
   1efc0:	f383 8811 	msr	BASEPRI, r3
   1efc4:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   1efc8:	6826      	ldr	r6, [r4, #0]
Z_GENLIST_GET(slist, snode)
   1efca:	b12e      	cbz	r6, 1efd8 <net_buf_slist_get+0x40>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1efcc:	6861      	ldr	r1, [r4, #4]
   1efce:	6833      	ldr	r3, [r6, #0]
	list->head = node;
   1efd0:	6023      	str	r3, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1efd2:	428e      	cmp	r6, r1
	list->tail = node;
   1efd4:	bf08      	it	eq
   1efd6:	6063      	streq	r3, [r4, #4]
	__asm__ volatile(
   1efd8:	f382 8811 	msr	BASEPRI, r2
   1efdc:	f3bf 8f6f 	isb	sy

	key = irq_lock();
	buf = (void *)sys_slist_get(list);
	irq_unlock(key);

	if (!buf) {
   1efe0:	b156      	cbz	r6, 1eff8 <net_buf_slist_get+0x60>
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
		key = irq_lock();
		frag->frags = (void *)sys_slist_get(list);
		irq_unlock(key);

		__ASSERT_NO_MSG(frag->frags);
   1efe2:	f8df 9074 	ldr.w	r9, [pc, #116]	; 1f058 <net_buf_slist_get+0xc0>
   1efe6:	4f1d      	ldr	r7, [pc, #116]	; (1f05c <net_buf_slist_get+0xc4>)
   1efe8:	f8df 8068 	ldr.w	r8, [pc, #104]	; 1f054 <net_buf_slist_get+0xbc>
   1efec:	4635      	mov	r5, r6
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1efee:	796b      	ldrb	r3, [r5, #5]
   1eff0:	f013 0301 	ands.w	r3, r3, #1
   1eff4:	d103      	bne.n	1effe <net_buf_slist_get+0x66>
		/* The fragments flag is only for list-internal usage */
		frag->flags &= ~NET_BUF_FRAGS;
	}

	/* Mark the end of the fragment list */
	frag->frags = NULL;
   1eff6:	602b      	str	r3, [r5, #0]

	return buf;
}
   1eff8:	4630      	mov	r0, r6
   1effa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__asm__ volatile(
   1effe:	f04f 0320 	mov.w	r3, #32
   1f002:	f3ef 8011 	mrs	r0, BASEPRI
   1f006:	f383 8811 	msr	BASEPRI, r3
   1f00a:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   1f00e:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_GET(slist, snode)
   1f010:	b12b      	cbz	r3, 1f01e <net_buf_slist_get+0x86>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1f012:	6861      	ldr	r1, [r4, #4]
   1f014:	681a      	ldr	r2, [r3, #0]
	list->head = node;
   1f016:	6022      	str	r2, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1f018:	428b      	cmp	r3, r1
	list->tail = node;
   1f01a:	bf08      	it	eq
   1f01c:	6062      	streq	r2, [r4, #4]
		frag->frags = (void *)sys_slist_get(list);
   1f01e:	602b      	str	r3, [r5, #0]
	__asm__ volatile(
   1f020:	f380 8811 	msr	BASEPRI, r0
   1f024:	f3bf 8f6f 	isb	sy
		__ASSERT_NO_MSG(frag->frags);
   1f028:	682b      	ldr	r3, [r5, #0]
   1f02a:	b95b      	cbnz	r3, 1f044 <net_buf_slist_get+0xac>
   1f02c:	4639      	mov	r1, r7
   1f02e:	4640      	mov	r0, r8
   1f030:	f240 13e5 	movw	r3, #485	; 0x1e5
   1f034:	464a      	mov	r2, r9
   1f036:	f004 ff54 	bl	23ee2 <printk>
   1f03a:	f240 11e5 	movw	r1, #485	; 0x1e5
   1f03e:	4648      	mov	r0, r9
   1f040:	f004 ff92 	bl	23f68 <assert_post_action>
		frag->flags &= ~NET_BUF_FRAGS;
   1f044:	796b      	ldrb	r3, [r5, #5]
   1f046:	f023 0301 	bic.w	r3, r3, #1
   1f04a:	716b      	strb	r3, [r5, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1f04c:	682d      	ldr	r5, [r5, #0]
   1f04e:	e7ce      	b.n	1efee <net_buf_slist_get+0x56>
   1f050:	0002ede5 	.word	0x0002ede5
   1f054:	0002a5e8 	.word	0x0002a5e8
   1f058:	00030cbe 	.word	0x00030cbe
   1f05c:	00030d26 	.word	0x00030d26

0001f060 <net_buf_put>:

void net_buf_put(struct k_fifo *fifo, struct net_buf *buf)
{
   1f060:	b538      	push	{r3, r4, r5, lr}
   1f062:	460c      	mov	r4, r1
	struct net_buf *tail;

	__ASSERT_NO_MSG(fifo);
   1f064:	4605      	mov	r5, r0
   1f066:	b958      	cbnz	r0, 1f080 <net_buf_put+0x20>
   1f068:	4913      	ldr	r1, [pc, #76]	; (1f0b8 <net_buf_put+0x58>)
   1f06a:	4814      	ldr	r0, [pc, #80]	; (1f0bc <net_buf_put+0x5c>)
   1f06c:	4a14      	ldr	r2, [pc, #80]	; (1f0c0 <net_buf_put+0x60>)
   1f06e:	f240 13f5 	movw	r3, #501	; 0x1f5
   1f072:	f004 ff36 	bl	23ee2 <printk>
   1f076:	4812      	ldr	r0, [pc, #72]	; (1f0c0 <net_buf_put+0x60>)
   1f078:	f240 11f5 	movw	r1, #501	; 0x1f5
   1f07c:	f004 ff74 	bl	23f68 <assert_post_action>
	__ASSERT_NO_MSG(buf);
   1f080:	b95c      	cbnz	r4, 1f09a <net_buf_put+0x3a>
   1f082:	4910      	ldr	r1, [pc, #64]	; (1f0c4 <net_buf_put+0x64>)
   1f084:	480d      	ldr	r0, [pc, #52]	; (1f0bc <net_buf_put+0x5c>)
   1f086:	4a0e      	ldr	r2, [pc, #56]	; (1f0c0 <net_buf_put+0x60>)
   1f088:	f44f 73fb 	mov.w	r3, #502	; 0x1f6
   1f08c:	f004 ff29 	bl	23ee2 <printk>
   1f090:	480b      	ldr	r0, [pc, #44]	; (1f0c0 <net_buf_put+0x60>)
   1f092:	f44f 71fb 	mov.w	r1, #502	; 0x1f6
   1f096:	f004 ff67 	bl	23f68 <assert_post_action>
{
   1f09a:	4622      	mov	r2, r4

	for (tail = buf; tail->frags; tail = tail->frags) {
   1f09c:	6811      	ldr	r1, [r2, #0]
   1f09e:	b929      	cbnz	r1, 1f0ac <net_buf_put+0x4c>
		tail->flags |= NET_BUF_FRAGS;
	}

	k_fifo_put_list(fifo, buf, tail);
   1f0a0:	4621      	mov	r1, r4
   1f0a2:	4628      	mov	r0, r5
}
   1f0a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	k_fifo_put_list(fifo, buf, tail);
   1f0a8:	f001 bf92 	b.w	20fd0 <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
   1f0ac:	7953      	ldrb	r3, [r2, #5]
   1f0ae:	f043 0301 	orr.w	r3, r3, #1
   1f0b2:	7153      	strb	r3, [r2, #5]
   1f0b4:	460a      	mov	r2, r1
   1f0b6:	e7f1      	b.n	1f09c <net_buf_put+0x3c>
   1f0b8:	00030d41 	.word	0x00030d41
   1f0bc:	0002a5e8 	.word	0x0002a5e8
   1f0c0:	00030cbe 	.word	0x00030cbe
   1f0c4:	00030dcd 	.word	0x00030dcd

0001f0c8 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   1f0c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(buf);
   1f0cc:	4605      	mov	r5, r0
   1f0ce:	b328      	cbz	r0, 1f11c <net_buf_unref+0x54>
   1f0d0:	4e1d      	ldr	r6, [pc, #116]	; (1f148 <net_buf_unref+0x80>)
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
   1f0d2:	2700      	movs	r7, #0
	pool->alloc->cb->unref(buf, data);
   1f0d4:	f04f 0824 	mov.w	r8, #36	; 0x24
		struct net_buf *frags = buf->frags;
   1f0d8:	462c      	mov	r4, r5
   1f0da:	682d      	ldr	r5, [r5, #0]
		if (--buf->ref > 0) {
   1f0dc:	7923      	ldrb	r3, [r4, #4]
   1f0de:	3b01      	subs	r3, #1
   1f0e0:	b2db      	uxtb	r3, r3
   1f0e2:	7123      	strb	r3, [r4, #4]
   1f0e4:	b9c3      	cbnz	r3, 1f118 <net_buf_unref+0x50>
		if (buf->__buf) {
   1f0e6:	6921      	ldr	r1, [r4, #16]
   1f0e8:	b159      	cbz	r1, 1f102 <net_buf_unref+0x3a>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   1f0ea:	7963      	ldrb	r3, [r4, #5]
   1f0ec:	079b      	lsls	r3, r3, #30
   1f0ee:	d407      	bmi.n	1f100 <net_buf_unref+0x38>
	pool->alloc->cb->unref(buf, data);
   1f0f0:	79a3      	ldrb	r3, [r4, #6]
   1f0f2:	fb08 6303 	mla	r3, r8, r3, r6
   1f0f6:	4620      	mov	r0, r4
   1f0f8:	69db      	ldr	r3, [r3, #28]
   1f0fa:	681b      	ldr	r3, [r3, #0]
   1f0fc:	689b      	ldr	r3, [r3, #8]
   1f0fe:	4798      	blx	r3
			buf->__buf = NULL;
   1f100:	6127      	str	r7, [r4, #16]
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
   1f102:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
   1f104:	60a7      	str	r7, [r4, #8]
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		pool->avail_count++;
		__ASSERT_NO_MSG(pool->avail_count <= pool->buf_count);
#endif

		if (pool->destroy) {
   1f106:	fb08 6300 	mla	r3, r8, r0, r6
		buf->frags = NULL;
   1f10a:	6027      	str	r7, [r4, #0]
		if (pool->destroy) {
   1f10c:	699b      	ldr	r3, [r3, #24]
   1f10e:	b19b      	cbz	r3, 1f138 <net_buf_unref+0x70>
			pool->destroy(buf);
   1f110:	4620      	mov	r0, r4
   1f112:	4798      	blx	r3
	while (buf) {
   1f114:	2d00      	cmp	r5, #0
   1f116:	d1df      	bne.n	1f0d8 <net_buf_unref+0x10>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
   1f118:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(buf);
   1f11c:	490b      	ldr	r1, [pc, #44]	; (1f14c <net_buf_unref+0x84>)
   1f11e:	480c      	ldr	r0, [pc, #48]	; (1f150 <net_buf_unref+0x88>)
   1f120:	4a0c      	ldr	r2, [pc, #48]	; (1f154 <net_buf_unref+0x8c>)
   1f122:	f240 2305 	movw	r3, #517	; 0x205
   1f126:	f004 fedc 	bl	23ee2 <printk>
}
   1f12a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(buf);
   1f12e:	4809      	ldr	r0, [pc, #36]	; (1f154 <net_buf_unref+0x8c>)
   1f130:	f240 2105 	movw	r1, #517	; 0x205
   1f134:	f004 bf18 	b.w	23f68 <assert_post_action>
	k_lifo_put(&pool->free, buf);
   1f138:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   1f13c:	4621      	mov	r1, r4
   1f13e:	eb06 0080 	add.w	r0, r6, r0, lsl #2
   1f142:	f00a f88b 	bl	2925c <k_queue_prepend>
}
   1f146:	e7e5      	b.n	1f114 <net_buf_unref+0x4c>
   1f148:	20007670 	.word	0x20007670
   1f14c:	00030dcd 	.word	0x00030dcd
   1f150:	0002a5e8 	.word	0x0002a5e8
   1f154:	00030cbe 	.word	0x00030cbe

0001f158 <net_buf_ref>:

struct net_buf *net_buf_ref(struct net_buf *buf)
{
   1f158:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(buf);
   1f15a:	4604      	mov	r4, r0
   1f15c:	b958      	cbnz	r0, 1f176 <net_buf_ref+0x1e>
   1f15e:	4908      	ldr	r1, [pc, #32]	; (1f180 <net_buf_ref+0x28>)
   1f160:	4808      	ldr	r0, [pc, #32]	; (1f184 <net_buf_ref+0x2c>)
   1f162:	4a09      	ldr	r2, [pc, #36]	; (1f188 <net_buf_ref+0x30>)
   1f164:	f44f 730d 	mov.w	r3, #564	; 0x234
   1f168:	f004 febb 	bl	23ee2 <printk>
   1f16c:	4806      	ldr	r0, [pc, #24]	; (1f188 <net_buf_ref+0x30>)
   1f16e:	f44f 710d 	mov.w	r1, #564	; 0x234
   1f172:	f004 fef9 	bl	23f68 <assert_post_action>

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   1f176:	7923      	ldrb	r3, [r4, #4]
   1f178:	3301      	adds	r3, #1
   1f17a:	7123      	strb	r3, [r4, #4]
	return buf;
}
   1f17c:	4620      	mov	r0, r4
   1f17e:	bd10      	pop	{r4, pc}
   1f180:	00030dcd 	.word	0x00030dcd
   1f184:	0002a5e8 	.word	0x0002a5e8
   1f188:	00030cbe 	.word	0x00030cbe

0001f18c <net_buf_frag_del>:
				       struct net_buf *frag,
				       const char *func, int line)
#else
struct net_buf *net_buf_frag_del(struct net_buf *parent, struct net_buf *frag)
#endif
{
   1f18c:	b538      	push	{r3, r4, r5, lr}
   1f18e:	4605      	mov	r5, r0
	struct net_buf *next_frag;

	__ASSERT_NO_MSG(frag);
   1f190:	460c      	mov	r4, r1
   1f192:	b959      	cbnz	r1, 1f1ac <net_buf_frag_del+0x20>
   1f194:	4919      	ldr	r1, [pc, #100]	; (1f1fc <net_buf_frag_del+0x70>)
   1f196:	481a      	ldr	r0, [pc, #104]	; (1f200 <net_buf_frag_del+0x74>)
   1f198:	4a1a      	ldr	r2, [pc, #104]	; (1f204 <net_buf_frag_del+0x78>)
   1f19a:	f44f 7326 	mov.w	r3, #664	; 0x298
   1f19e:	f004 fea0 	bl	23ee2 <printk>
   1f1a2:	4818      	ldr	r0, [pc, #96]	; (1f204 <net_buf_frag_del+0x78>)
   1f1a4:	f44f 7126 	mov.w	r1, #664	; 0x298
   1f1a8:	f004 fede 	bl	23f68 <assert_post_action>

	if (parent) {
   1f1ac:	b1f5      	cbz	r5, 1f1ec <net_buf_frag_del+0x60>
		__ASSERT_NO_MSG(parent->frags);
   1f1ae:	682b      	ldr	r3, [r5, #0]
   1f1b0:	b95b      	cbnz	r3, 1f1ca <net_buf_frag_del+0x3e>
   1f1b2:	4915      	ldr	r1, [pc, #84]	; (1f208 <net_buf_frag_del+0x7c>)
   1f1b4:	4812      	ldr	r0, [pc, #72]	; (1f200 <net_buf_frag_del+0x74>)
   1f1b6:	4a13      	ldr	r2, [pc, #76]	; (1f204 <net_buf_frag_del+0x78>)
   1f1b8:	f240 239b 	movw	r3, #667	; 0x29b
   1f1bc:	f004 fe91 	bl	23ee2 <printk>
   1f1c0:	4810      	ldr	r0, [pc, #64]	; (1f204 <net_buf_frag_del+0x78>)
   1f1c2:	f240 219b 	movw	r1, #667	; 0x29b
   1f1c6:	f004 fecf 	bl	23f68 <assert_post_action>
		__ASSERT_NO_MSG(parent->frags == frag);
   1f1ca:	682b      	ldr	r3, [r5, #0]
   1f1cc:	42a3      	cmp	r3, r4
   1f1ce:	d00b      	beq.n	1f1e8 <net_buf_frag_del+0x5c>
   1f1d0:	490e      	ldr	r1, [pc, #56]	; (1f20c <net_buf_frag_del+0x80>)
   1f1d2:	480b      	ldr	r0, [pc, #44]	; (1f200 <net_buf_frag_del+0x74>)
   1f1d4:	4a0b      	ldr	r2, [pc, #44]	; (1f204 <net_buf_frag_del+0x78>)
   1f1d6:	f44f 7327 	mov.w	r3, #668	; 0x29c
   1f1da:	f004 fe82 	bl	23ee2 <printk>
   1f1de:	4809      	ldr	r0, [pc, #36]	; (1f204 <net_buf_frag_del+0x78>)
   1f1e0:	f44f 7127 	mov.w	r1, #668	; 0x29c
   1f1e4:	f004 fec0 	bl	23f68 <assert_post_action>
		parent->frags = frag->frags;
   1f1e8:	6823      	ldr	r3, [r4, #0]
   1f1ea:	602b      	str	r3, [r5, #0]
	}

	next_frag = frag->frags;
   1f1ec:	6825      	ldr	r5, [r4, #0]

	frag->frags = NULL;
   1f1ee:	2300      	movs	r3, #0

#if defined(CONFIG_NET_BUF_LOG)
	net_buf_unref_debug(frag, func, line);
#else
	net_buf_unref(frag);
   1f1f0:	4620      	mov	r0, r4
	frag->frags = NULL;
   1f1f2:	6023      	str	r3, [r4, #0]
	net_buf_unref(frag);
   1f1f4:	f7ff ff68 	bl	1f0c8 <net_buf_unref>
#endif

	return next_frag;
}
   1f1f8:	4628      	mov	r0, r5
   1f1fa:	bd38      	pop	{r3, r4, r5, pc}
   1f1fc:	00030d6c 	.word	0x00030d6c
   1f200:	0002a5e8 	.word	0x0002a5e8
   1f204:	00030cbe 	.word	0x00030cbe
   1f208:	00030d4d 	.word	0x00030d4d
   1f20c:	00030d5b 	.word	0x00030d5b

0001f210 <net_buf_simple_push>:

	sys_put_be64(val, net_buf_simple_add(buf, sizeof(val)));
}

void *net_buf_simple_push(struct net_buf_simple *buf, size_t len)
{
   1f210:	b538      	push	{r3, r4, r5, lr}
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   1f212:	6882      	ldr	r2, [r0, #8]
   1f214:	6803      	ldr	r3, [r0, #0]
   1f216:	1a9b      	subs	r3, r3, r2
	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);
   1f218:	4299      	cmp	r1, r3
{
   1f21a:	4604      	mov	r4, r0
   1f21c:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);
   1f21e:	d90b      	bls.n	1f238 <net_buf_simple_push+0x28>
   1f220:	4909      	ldr	r1, [pc, #36]	; (1f248 <net_buf_simple_push+0x38>)
   1f222:	480a      	ldr	r0, [pc, #40]	; (1f24c <net_buf_simple_push+0x3c>)
   1f224:	4a0a      	ldr	r2, [pc, #40]	; (1f250 <net_buf_simple_push+0x40>)
   1f226:	f240 3371 	movw	r3, #881	; 0x371
   1f22a:	f004 fe5a 	bl	23ee2 <printk>
   1f22e:	4808      	ldr	r0, [pc, #32]	; (1f250 <net_buf_simple_push+0x40>)
   1f230:	f240 3171 	movw	r1, #881	; 0x371
   1f234:	f004 fe98 	bl	23f68 <assert_post_action>
	buf->data -= len;
   1f238:	6820      	ldr	r0, [r4, #0]
	buf->len += len;
   1f23a:	88a1      	ldrh	r1, [r4, #4]
	buf->data -= len;
   1f23c:	1b40      	subs	r0, r0, r5
	buf->len += len;
   1f23e:	440d      	add	r5, r1
	buf->data -= len;
   1f240:	6020      	str	r0, [r4, #0]
	buf->len += len;
   1f242:	80a5      	strh	r5, [r4, #4]
}
   1f244:	bd38      	pop	{r3, r4, r5, pc}
   1f246:	bf00      	nop
   1f248:	00030d71 	.word	0x00030d71
   1f24c:	0002a5e8 	.word	0x0002a5e8
   1f250:	00030cbe 	.word	0x00030cbe

0001f254 <net_buf_simple_pull>:
{
   1f254:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(buf->len >= len);
   1f256:	8883      	ldrh	r3, [r0, #4]
   1f258:	428b      	cmp	r3, r1
{
   1f25a:	4604      	mov	r4, r0
   1f25c:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(buf->len >= len);
   1f25e:	d20b      	bcs.n	1f278 <net_buf_simple_pull+0x24>
   1f260:	4909      	ldr	r1, [pc, #36]	; (1f288 <net_buf_simple_pull+0x34>)
   1f262:	480a      	ldr	r0, [pc, #40]	; (1f28c <net_buf_simple_pull+0x38>)
   1f264:	4a0a      	ldr	r2, [pc, #40]	; (1f290 <net_buf_simple_pull+0x3c>)
   1f266:	f240 33c9 	movw	r3, #969	; 0x3c9
   1f26a:	f004 fe3a 	bl	23ee2 <printk>
   1f26e:	4808      	ldr	r0, [pc, #32]	; (1f290 <net_buf_simple_pull+0x3c>)
   1f270:	f240 31c9 	movw	r1, #969	; 0x3c9
   1f274:	f004 fe78 	bl	23f68 <assert_post_action>
	buf->len -= len;
   1f278:	88a3      	ldrh	r3, [r4, #4]
	return buf->data += len;
   1f27a:	6820      	ldr	r0, [r4, #0]
	buf->len -= len;
   1f27c:	1b5b      	subs	r3, r3, r5
	return buf->data += len;
   1f27e:	4428      	add	r0, r5
	buf->len -= len;
   1f280:	80a3      	strh	r3, [r4, #4]
	return buf->data += len;
   1f282:	6020      	str	r0, [r4, #0]
}
   1f284:	bd38      	pop	{r3, r4, r5, pc}
   1f286:	bf00      	nop
   1f288:	00030d95 	.word	0x00030d95
   1f28c:	0002a5e8 	.word	0x0002a5e8
   1f290:	00030cbe 	.word	0x00030cbe

0001f294 <net_buf_simple_pull_mem>:
	__ASSERT_NO_MSG(buf->len >= len);
   1f294:	8883      	ldrh	r3, [r0, #4]
   1f296:	428b      	cmp	r3, r1
{
   1f298:	b570      	push	{r4, r5, r6, lr}
	void *data = buf->data;
   1f29a:	6806      	ldr	r6, [r0, #0]
{
   1f29c:	4604      	mov	r4, r0
   1f29e:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(buf->len >= len);
   1f2a0:	d20b      	bcs.n	1f2ba <net_buf_simple_pull_mem+0x26>
   1f2a2:	490a      	ldr	r1, [pc, #40]	; (1f2cc <net_buf_simple_pull_mem+0x38>)
   1f2a4:	480a      	ldr	r0, [pc, #40]	; (1f2d0 <net_buf_simple_pull_mem+0x3c>)
   1f2a6:	4a0b      	ldr	r2, [pc, #44]	; (1f2d4 <net_buf_simple_pull_mem+0x40>)
   1f2a8:	f240 33d5 	movw	r3, #981	; 0x3d5
   1f2ac:	f004 fe19 	bl	23ee2 <printk>
   1f2b0:	4808      	ldr	r0, [pc, #32]	; (1f2d4 <net_buf_simple_pull_mem+0x40>)
   1f2b2:	f240 31d5 	movw	r1, #981	; 0x3d5
   1f2b6:	f004 fe57 	bl	23f68 <assert_post_action>
	buf->len -= len;
   1f2ba:	88a3      	ldrh	r3, [r4, #4]
	buf->data += len;
   1f2bc:	6821      	ldr	r1, [r4, #0]
	buf->len -= len;
   1f2be:	1b5b      	subs	r3, r3, r5
	buf->data += len;
   1f2c0:	4429      	add	r1, r5
	buf->len -= len;
   1f2c2:	80a3      	strh	r3, [r4, #4]
	buf->data += len;
   1f2c4:	6021      	str	r1, [r4, #0]
}
   1f2c6:	4630      	mov	r0, r6
   1f2c8:	bd70      	pop	{r4, r5, r6, pc}
   1f2ca:	bf00      	nop
   1f2cc:	00030d95 	.word	0x00030d95
   1f2d0:	0002a5e8 	.word	0x0002a5e8
   1f2d4:	00030cbe 	.word	0x00030cbe

0001f2d8 <net_buf_simple_add>:
{
   1f2d8:	b570      	push	{r4, r5, r6, lr}
	return buf->data + buf->len;
   1f2da:	6803      	ldr	r3, [r0, #0]
   1f2dc:	8886      	ldrh	r6, [r0, #4]
   1f2de:	4604      	mov	r4, r0
   1f2e0:	460d      	mov	r5, r1
   1f2e2:	441e      	add	r6, r3
	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);
   1f2e4:	f009 fd5f 	bl	28da6 <net_buf_simple_tailroom>
   1f2e8:	4288      	cmp	r0, r1
   1f2ea:	d20b      	bcs.n	1f304 <net_buf_simple_add+0x2c>
   1f2ec:	4908      	ldr	r1, [pc, #32]	; (1f310 <net_buf_simple_add+0x38>)
   1f2ee:	4809      	ldr	r0, [pc, #36]	; (1f314 <net_buf_simple_add+0x3c>)
   1f2f0:	4a09      	ldr	r2, [pc, #36]	; (1f318 <net_buf_simple_add+0x40>)
   1f2f2:	f240 330d 	movw	r3, #781	; 0x30d
   1f2f6:	f004 fdf4 	bl	23ee2 <printk>
   1f2fa:	4807      	ldr	r0, [pc, #28]	; (1f318 <net_buf_simple_add+0x40>)
   1f2fc:	f240 310d 	movw	r1, #781	; 0x30d
   1f300:	f004 fe32 	bl	23f68 <assert_post_action>
	buf->len += len;
   1f304:	88a1      	ldrh	r1, [r4, #4]
   1f306:	440d      	add	r5, r1
   1f308:	80a5      	strh	r5, [r4, #4]
}
   1f30a:	4630      	mov	r0, r6
   1f30c:	bd70      	pop	{r4, r5, r6, pc}
   1f30e:	bf00      	nop
   1f310:	00030da5 	.word	0x00030da5
   1f314:	0002a5e8 	.word	0x0002a5e8
   1f318:	00030cbe 	.word	0x00030cbe

0001f31c <nrf_gpio_pin_port_decode>:
 *
 * @return Pointer to port register set.
 */
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
{
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1f31c:	6803      	ldr	r3, [r0, #0]
   1f31e:	2b2f      	cmp	r3, #47	; 0x2f
{
   1f320:	b510      	push	{r4, lr}
   1f322:	4604      	mov	r4, r0
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1f324:	d90b      	bls.n	1f33e <nrf_gpio_pin_port_decode+0x22>
   1f326:	490b      	ldr	r1, [pc, #44]	; (1f354 <nrf_gpio_pin_port_decode+0x38>)
   1f328:	480b      	ldr	r0, [pc, #44]	; (1f358 <nrf_gpio_pin_port_decode+0x3c>)
   1f32a:	4a0c      	ldr	r2, [pc, #48]	; (1f35c <nrf_gpio_pin_port_decode+0x40>)
   1f32c:	f240 13ff 	movw	r3, #511	; 0x1ff
   1f330:	f004 fdd7 	bl	23ee2 <printk>
   1f334:	4809      	ldr	r0, [pc, #36]	; (1f35c <nrf_gpio_pin_port_decode+0x40>)
   1f336:	f240 11ff 	movw	r1, #511	; 0x1ff
   1f33a:	f004 fe15 	bl	23f68 <assert_post_action>
#if (GPIO_COUNT == 1)
    return NRF_P0;
#else
    if (*p_pin < P0_PIN_NUM)
   1f33e:	6823      	ldr	r3, [r4, #0]
   1f340:	2b1f      	cmp	r3, #31
    {
        return NRF_P0;
    }
    else
    {
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   1f342:	bf83      	ittte	hi
   1f344:	f003 031f 	andhi.w	r3, r3, #31
        return NRF_P1;
   1f348:	4805      	ldrhi	r0, [pc, #20]	; (1f360 <nrf_gpio_pin_port_decode+0x44>)
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   1f34a:	6023      	strhi	r3, [r4, #0]
        return NRF_P0;
   1f34c:	f04f 40a0 	movls.w	r0, #1342177280	; 0x50000000
    }
#endif
}
   1f350:	bd10      	pop	{r4, pc}
   1f352:	bf00      	nop
   1f354:	00030e04 	.word	0x00030e04
   1f358:	0002a5e8 	.word	0x0002a5e8
   1f35c:	00030dd1 	.word	0x00030dd1
   1f360:	50000300 	.word	0x50000300

0001f364 <gpio_nrfx_manage_callback>:
}

static int gpio_nrfx_manage_callback(struct device *port,
				     struct gpio_callback *callback,
				     bool set)
{
   1f364:	b570      	push	{r4, r5, r6, lr}
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1f366:	6885      	ldr	r5, [r0, #8]
{
   1f368:	4616      	mov	r6, r2
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
   1f36a:	460c      	mov	r4, r1
   1f36c:	b961      	cbnz	r1, 1f388 <gpio_nrfx_manage_callback+0x24>
   1f36e:	4922      	ldr	r1, [pc, #136]	; (1f3f8 <gpio_nrfx_manage_callback+0x94>)
   1f370:	4a22      	ldr	r2, [pc, #136]	; (1f3fc <gpio_nrfx_manage_callback+0x98>)
   1f372:	4823      	ldr	r0, [pc, #140]	; (1f400 <gpio_nrfx_manage_callback+0x9c>)
   1f374:	231e      	movs	r3, #30
   1f376:	f004 fdb4 	bl	23ee2 <printk>
   1f37a:	4822      	ldr	r0, [pc, #136]	; (1f404 <gpio_nrfx_manage_callback+0xa0>)
   1f37c:	f004 fdb1 	bl	23ee2 <printk>
   1f380:	481e      	ldr	r0, [pc, #120]	; (1f3fc <gpio_nrfx_manage_callback+0x98>)
   1f382:	211e      	movs	r1, #30
   1f384:	f004 fdf0 	bl	23f68 <assert_post_action>
	__ASSERT(callback->handler, "No callback handler!");
   1f388:	6863      	ldr	r3, [r4, #4]
   1f38a:	b963      	cbnz	r3, 1f3a6 <gpio_nrfx_manage_callback+0x42>
   1f38c:	491e      	ldr	r1, [pc, #120]	; (1f408 <gpio_nrfx_manage_callback+0xa4>)
   1f38e:	4a1b      	ldr	r2, [pc, #108]	; (1f3fc <gpio_nrfx_manage_callback+0x98>)
   1f390:	481b      	ldr	r0, [pc, #108]	; (1f400 <gpio_nrfx_manage_callback+0x9c>)
   1f392:	231f      	movs	r3, #31
   1f394:	f004 fda5 	bl	23ee2 <printk>
   1f398:	481c      	ldr	r0, [pc, #112]	; (1f40c <gpio_nrfx_manage_callback+0xa8>)
   1f39a:	f004 fda2 	bl	23ee2 <printk>
   1f39e:	4817      	ldr	r0, [pc, #92]	; (1f3fc <gpio_nrfx_manage_callback+0x98>)
   1f3a0:	211f      	movs	r1, #31
   1f3a2:	f004 fde1 	bl	23f68 <assert_post_action>
Z_GENLIST_IS_EMPTY(slist)
   1f3a6:	686b      	ldr	r3, [r5, #4]

	if (!sys_slist_is_empty(callbacks)) {
   1f3a8:	b15b      	cbz	r3, 1f3c2 <gpio_nrfx_manage_callback+0x5e>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1f3aa:	2200      	movs	r2, #0
   1f3ac:	429c      	cmp	r4, r3
   1f3ae:	d113      	bne.n	1f3d8 <gpio_nrfx_manage_callback+0x74>
Z_GENLIST_REMOVE(slist, snode)
   1f3b0:	6823      	ldr	r3, [r4, #0]
   1f3b2:	b95a      	cbnz	r2, 1f3cc <gpio_nrfx_manage_callback+0x68>
   1f3b4:	68aa      	ldr	r2, [r5, #8]
	list->head = node;
   1f3b6:	606b      	str	r3, [r5, #4]
Z_GENLIST_REMOVE(slist, snode)
   1f3b8:	4294      	cmp	r4, r2
   1f3ba:	d100      	bne.n	1f3be <gpio_nrfx_manage_callback+0x5a>
	list->tail = node;
   1f3bc:	60ab      	str	r3, [r5, #8]
	parent->next = child;
   1f3be:	2300      	movs	r3, #0
   1f3c0:	6023      	str	r3, [r4, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   1f3c2:	b976      	cbnz	r6, 1f3e2 <gpio_nrfx_manage_callback+0x7e>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   1f3c4:	2000      	movs	r0, #0
				     callback, set);
}
   1f3c6:	bd70      	pop	{r4, r5, r6, pc}
   1f3c8:	460b      	mov	r3, r1
   1f3ca:	e7ef      	b.n	1f3ac <gpio_nrfx_manage_callback+0x48>
   1f3cc:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   1f3ce:	68ab      	ldr	r3, [r5, #8]
   1f3d0:	429c      	cmp	r4, r3
	list->tail = node;
   1f3d2:	bf08      	it	eq
   1f3d4:	60aa      	streq	r2, [r5, #8]
}
   1f3d6:	e7f2      	b.n	1f3be <gpio_nrfx_manage_callback+0x5a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1f3d8:	6819      	ldr	r1, [r3, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1f3da:	461a      	mov	r2, r3
   1f3dc:	2900      	cmp	r1, #0
   1f3de:	d1f3      	bne.n	1f3c8 <gpio_nrfx_manage_callback+0x64>
			if (!set) {
   1f3e0:	b13e      	cbz	r6, 1f3f2 <gpio_nrfx_manage_callback+0x8e>
Z_GENLIST_PREPEND(slist, snode)
   1f3e2:	686b      	ldr	r3, [r5, #4]
	parent->next = child;
   1f3e4:	6023      	str	r3, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   1f3e6:	68a8      	ldr	r0, [r5, #8]
	list->head = node;
   1f3e8:	606c      	str	r4, [r5, #4]
Z_GENLIST_PREPEND(slist, snode)
   1f3ea:	2800      	cmp	r0, #0
   1f3ec:	d1ea      	bne.n	1f3c4 <gpio_nrfx_manage_callback+0x60>
	list->tail = node;
   1f3ee:	60ac      	str	r4, [r5, #8]
}
   1f3f0:	e7e9      	b.n	1f3c6 <gpio_nrfx_manage_callback+0x62>
				return -EINVAL;
   1f3f2:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1f3f6:	e7e6      	b.n	1f3c6 <gpio_nrfx_manage_callback+0x62>
   1f3f8:	00030e44 	.word	0x00030e44
   1f3fc:	00030e17 	.word	0x00030e17
   1f400:	0002a5e8 	.word	0x0002a5e8
   1f404:	00030e4d 	.word	0x00030e4d
   1f408:	00030e5c 	.word	0x00030e5c
   1f40c:	00030e6e 	.word	0x00030e6e

0001f410 <fire_callbacks>:

	return out;
}

static inline void fire_callbacks(struct device *port, u32_t pins)
{
   1f410:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct gpio_nrfx_data *data = get_port_data(port);
   1f414:	f8d0 8008 	ldr.w	r8, [r0, #8]
	/* Instead of calling the common gpio_fire_callbacks() function,
	 * iterate the list of callbacks locally, to be able to perform
	 * additional masking of the pins and to call handlers only for
	 * the currently enabled callbacks.
	 */
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1f418:	f8d8 4004 	ldr.w	r4, [r8, #4]
{
   1f41c:	4606      	mov	r6, r0
   1f41e:	460f      	mov	r7, r1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1f420:	b36c      	cbz	r4, 1f47e <fire_callbacks+0x6e>
	return node->next;
   1f422:	6825      	ldr	r5, [r4, #0]
		/* Check currently enabled callbacks (data->int_en) in each
		 * iteration, as some callbacks may get disabled also in any
		 * of the handlers called here.
		 */
		if ((cb->pin_mask & pins) & data->int_en) {
			__ASSERT(cb->handler, "No callback handler!");
   1f424:	f8df 9060 	ldr.w	r9, [pc, #96]	; 1f488 <fire_callbacks+0x78>
   1f428:	f8df a060 	ldr.w	sl, [pc, #96]	; 1f48c <fire_callbacks+0x7c>
   1f42c:	f8df b060 	ldr.w	fp, [pc, #96]	; 1f490 <fire_callbacks+0x80>
   1f430:	2d00      	cmp	r5, #0
   1f432:	bf38      	it	cc
   1f434:	2500      	movcc	r5, #0
		if ((cb->pin_mask & pins) & data->int_en) {
   1f436:	f8d8 3010 	ldr.w	r3, [r8, #16]
   1f43a:	68a2      	ldr	r2, [r4, #8]
   1f43c:	403b      	ands	r3, r7
   1f43e:	4213      	tst	r3, r2
   1f440:	d015      	beq.n	1f46e <fire_callbacks+0x5e>
			__ASSERT(cb->handler, "No callback handler!");
   1f442:	6863      	ldr	r3, [r4, #4]
   1f444:	b973      	cbnz	r3, 1f464 <fire_callbacks+0x54>
   1f446:	4651      	mov	r1, sl
   1f448:	f240 13a7 	movw	r3, #423	; 0x1a7
   1f44c:	464a      	mov	r2, r9
   1f44e:	4658      	mov	r0, fp
   1f450:	f004 fd47 	bl	23ee2 <printk>
   1f454:	480b      	ldr	r0, [pc, #44]	; (1f484 <fire_callbacks+0x74>)
   1f456:	f004 fd44 	bl	23ee2 <printk>
   1f45a:	f240 11a7 	movw	r1, #423	; 0x1a7
   1f45e:	4648      	mov	r0, r9
   1f460:	f004 fd82 	bl	23f68 <assert_post_action>
			cb->handler(port, cb, pins);
   1f464:	6863      	ldr	r3, [r4, #4]
   1f466:	463a      	mov	r2, r7
   1f468:	4621      	mov	r1, r4
   1f46a:	4630      	mov	r0, r6
   1f46c:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1f46e:	b135      	cbz	r5, 1f47e <fire_callbacks+0x6e>
   1f470:	682b      	ldr	r3, [r5, #0]
   1f472:	2b00      	cmp	r3, #0
   1f474:	bf38      	it	cc
   1f476:	2300      	movcc	r3, #0
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1f478:	462c      	mov	r4, r5
   1f47a:	461d      	mov	r5, r3
   1f47c:	e7db      	b.n	1f436 <fire_callbacks+0x26>
		}
	}
}
   1f47e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1f482:	bf00      	nop
   1f484:	00030e6e 	.word	0x00030e6e
   1f488:	00030e85 	.word	0x00030e85
   1f48c:	00030eb1 	.word	0x00030eb1
   1f490:	0002a5e8 	.word	0x0002a5e8

0001f494 <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
   1f494:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
   1f496:	4b09      	ldr	r3, [pc, #36]	; (1f4bc <gpio_nrfx_init+0x28>)
   1f498:	781a      	ldrb	r2, [r3, #0]
   1f49a:	b96a      	cbnz	r2, 1f4b8 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
   1f49c:	2101      	movs	r1, #1
   1f49e:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   1f4a0:	2006      	movs	r0, #6
   1f4a2:	2105      	movs	r1, #5
   1f4a4:	f7e5 fa8a 	bl	49bc <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
   1f4a8:	2006      	movs	r0, #6
   1f4aa:	f7e5 fa55 	bl	4958 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   1f4ae:	4b04      	ldr	r3, [pc, #16]	; (1f4c0 <gpio_nrfx_init+0x2c>)
   1f4b0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1f4b4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
   1f4b8:	2000      	movs	r0, #0
   1f4ba:	bd08      	pop	{r3, pc}
   1f4bc:	200024dd 	.word	0x200024dd
   1f4c0:	40006000 	.word	0x40006000

0001f4c4 <gpio_nrfx_config>:
	return port->config->config_info;
   1f4c4:	6803      	ldr	r3, [r0, #0]
{
   1f4c6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return port->config->config_info;
   1f4c8:	6898      	ldr	r0, [r3, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   1f4ca:	4b2e      	ldr	r3, [pc, #184]	; (1f584 <gpio_nrfx_config+0xc0>)
   1f4cc:	4c2e      	ldr	r4, [pc, #184]	; (1f588 <gpio_nrfx_config+0xc4>)
   1f4ce:	4013      	ands	r3, r2
   1f4d0:	42a3      	cmp	r3, r4
   1f4d2:	d045      	beq.n	1f560 <gpio_nrfx_config+0x9c>
   1f4d4:	d80e      	bhi.n	1f4f4 <gpio_nrfx_config+0x30>
   1f4d6:	2b06      	cmp	r3, #6
   1f4d8:	d044      	beq.n	1f564 <gpio_nrfx_config+0xa0>
   1f4da:	d806      	bhi.n	1f4ea <gpio_nrfx_config+0x26>
   1f4dc:	2b00      	cmp	r3, #0
   1f4de:	d041      	beq.n	1f564 <gpio_nrfx_config+0xa0>
   1f4e0:	2b02      	cmp	r3, #2
   1f4e2:	d041      	beq.n	1f568 <gpio_nrfx_config+0xa4>
   1f4e4:	f06f 0015 	mvn.w	r0, #21
   1f4e8:	e038      	b.n	1f55c <gpio_nrfx_config+0x98>
   1f4ea:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   1f4ee:	d1f9      	bne.n	1f4e4 <gpio_nrfx_config+0x20>
		drive = NRF_GPIO_PIN_H0S1;
   1f4f0:	2401      	movs	r4, #1
   1f4f2:	e009      	b.n	1f508 <gpio_nrfx_config+0x44>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   1f4f4:	4c25      	ldr	r4, [pc, #148]	; (1f58c <gpio_nrfx_config+0xc8>)
   1f4f6:	42a3      	cmp	r3, r4
   1f4f8:	d038      	beq.n	1f56c <gpio_nrfx_config+0xa8>
   1f4fa:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
   1f4fe:	d037      	beq.n	1f570 <gpio_nrfx_config+0xac>
   1f500:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   1f504:	d1ee      	bne.n	1f4e4 <gpio_nrfx_config+0x20>
		drive = NRF_GPIO_PIN_S0H1;
   1f506:	2402      	movs	r4, #2
	if ((flags & GPIO_PULL_UP) != 0) {
   1f508:	06d5      	lsls	r5, r2, #27
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
   1f50a:	f482 7380 	eor.w	r3, r2, #256	; 0x100
		pull = NRF_GPIO_PIN_NOPULL;
   1f50e:	bf54      	ite	pl
   1f510:	f3c2 1640 	ubfxpl	r6, r2, #5, #1
		pull = NRF_GPIO_PIN_PULLUP;
   1f514:	2603      	movmi	r6, #3
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
   1f516:	f3c3 2700 	ubfx	r7, r3, #8, #1
	if ((flags & GPIO_OUTPUT) != 0) {
   1f51a:	0593      	lsls	r3, r2, #22
	dir = ((flags & GPIO_OUTPUT) != 0)
   1f51c:	f3c2 2540 	ubfx	r5, r2, #9, #1
	if ((flags & GPIO_OUTPUT) != 0) {
   1f520:	d507      	bpl.n	1f532 <gpio_nrfx_config+0x6e>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
   1f522:	0513      	lsls	r3, r2, #20
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1f524:	f8d0 c004 	ldr.w	ip, [r0, #4]
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
   1f528:	d524      	bpl.n	1f574 <gpio_nrfx_config+0xb0>
			nrf_gpio_port_out_set(reg, BIT(pin));
   1f52a:	2301      	movs	r3, #1
   1f52c:	408b      	lsls	r3, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
   1f52e:	f8cc 3508 	str.w	r3, [ip, #1288]	; 0x508
	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
   1f532:	7a03      	ldrb	r3, [r0, #8]
   1f534:	f001 011f 	and.w	r1, r1, #31
   1f538:	ea41 1143 	orr.w	r1, r1, r3, lsl #5
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1f53c:	a801      	add	r0, sp, #4
   1f53e:	9101      	str	r1, [sp, #4]
   1f540:	f7ff feec 	bl	1f31c <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1f544:	9a01      	ldr	r2, [sp, #4]
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   1f546:	ea45 0347 	orr.w	r3, r5, r7, lsl #1
   1f54a:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1f54e:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   1f552:	ea43 0386 	orr.w	r3, r3, r6, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1f556:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
	return 0;
   1f55a:	2000      	movs	r0, #0
}
   1f55c:	b003      	add	sp, #12
   1f55e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		drive = NRF_GPIO_PIN_H0D1;
   1f560:	2407      	movs	r4, #7
   1f562:	e7d1      	b.n	1f508 <gpio_nrfx_config+0x44>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   1f564:	461c      	mov	r4, r3
   1f566:	e7cf      	b.n	1f508 <gpio_nrfx_config+0x44>
		drive = NRF_GPIO_PIN_D0S1;
   1f568:	2404      	movs	r4, #4
   1f56a:	e7cd      	b.n	1f508 <gpio_nrfx_config+0x44>
		drive = NRF_GPIO_PIN_D0H1;
   1f56c:	2405      	movs	r4, #5
   1f56e:	e7cb      	b.n	1f508 <gpio_nrfx_config+0x44>
		drive = NRF_GPIO_PIN_H0H1;
   1f570:	2403      	movs	r4, #3
   1f572:	e7c9      	b.n	1f508 <gpio_nrfx_config+0x44>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
   1f574:	0553      	lsls	r3, r2, #21
			nrf_gpio_port_out_clear(reg, BIT(pin));
   1f576:	bf42      	ittt	mi
   1f578:	2301      	movmi	r3, #1
   1f57a:	408b      	lslmi	r3, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   1f57c:	f8cc 350c 	strmi.w	r3, [ip, #1292]	; 0x50c
}
   1f580:	e7d7      	b.n	1f532 <gpio_nrfx_config+0x6e>
   1f582:	bf00      	nop
   1f584:	00f00006 	.word	0x00f00006
   1f588:	00100006 	.word	0x00100006
   1f58c:	00400002 	.word	0x00400002

0001f590 <gpiote_pin_int_cfg>:
{
   1f590:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return port->config->config_info;
   1f592:	6803      	ldr	r3, [r0, #0]
	struct gpio_nrfx_data *data = get_port_data(port);
   1f594:	6887      	ldr	r7, [r0, #8]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1f596:	689b      	ldr	r3, [r3, #8]
   1f598:	f001 051f 	and.w	r5, r1, #31
{
   1f59c:	460e      	mov	r6, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
   1f59e:	494a      	ldr	r1, [pc, #296]	; (1f6c8 <gpiote_pin_int_cfg+0x138>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1f5a0:	7a18      	ldrb	r0, [r3, #8]
   1f5a2:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
   1f5a6:	ea45 1540 	orr.w	r5, r5, r0, lsl #5
   1f5aa:	b2d2      	uxtb	r2, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1f5ac:	2300      	movs	r3, #0
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1f5ae:	f503 70a2 	add.w	r0, r3, #324	; 0x144
   1f5b2:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
   1f5b6:	f3c0 2005 	ubfx	r0, r0, #8, #6
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
   1f5ba:	4285      	cmp	r5, r0
   1f5bc:	d16e      	bne.n	1f69c <gpiote_pin_int_cfg+0x10c>
		    && (intenset & BIT(i))) {
   1f5be:	fa22 f003 	lsr.w	r0, r2, r3
   1f5c2:	07c0      	lsls	r0, r0, #31
   1f5c4:	d56a      	bpl.n	1f69c <gpiote_pin_int_cfg+0x10c>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
   1f5c6:	009a      	lsls	r2, r3, #2
   1f5c8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   1f5cc:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
   1f5d0:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   1f5d4:	f020 0001 	bic.w	r0, r0, #1
   1f5d8:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
   1f5dc:	2201      	movs	r2, #1
   1f5de:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
   1f5e2:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   1f5e6:	4628      	mov	r0, r5
   1f5e8:	2100      	movs	r1, #0
   1f5ea:	f009 fc4f 	bl	28e8c <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
   1f5ee:	68fb      	ldr	r3, [r7, #12]
   1f5f0:	40f3      	lsrs	r3, r6
   1f5f2:	f013 0001 	ands.w	r0, r3, #1
   1f5f6:	d04f      	beq.n	1f698 <gpiote_pin_int_cfg+0x108>
   1f5f8:	693b      	ldr	r3, [r7, #16]
   1f5fa:	40f3      	lsrs	r3, r6
   1f5fc:	f013 0001 	ands.w	r0, r3, #1
   1f600:	d04a      	beq.n	1f698 <gpiote_pin_int_cfg+0x108>
		if (data->trig_edge & BIT(pin)) {
   1f602:	69bb      	ldr	r3, [r7, #24]
   1f604:	40f3      	lsrs	r3, r6
   1f606:	f013 0401 	ands.w	r4, r3, #1
   1f60a:	d051      	beq.n	1f6b0 <gpiote_pin_int_cfg+0x120>
			if (data->double_edge & BIT(pin)) {
   1f60c:	69fb      	ldr	r3, [r7, #28]
   1f60e:	40f3      	lsrs	r3, r6
   1f610:	07db      	lsls	r3, r3, #31
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
   1f612:	bf58      	it	pl
   1f614:	6979      	ldrpl	r1, [r7, #20]
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
   1f616:	4f2c      	ldr	r7, [pc, #176]	; (1f6c8 <gpiote_pin_int_cfg+0x138>)
   1f618:	bf5f      	itttt	pl
   1f61a:	fa21 f606 	lsrpl.w	r6, r1, r6
   1f61e:	f006 0601 	andpl.w	r6, r6, #1
   1f622:	f1c6 0602 	rsbpl	r6, r6, #2
   1f626:	b2f6      	uxtbpl	r6, r6
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
   1f628:	bf48      	it	mi
   1f62a:	2603      	movmi	r6, #3
   1f62c:	2400      	movs	r4, #0
   1f62e:	f504 73a2 	add.w	r3, r4, #324	; 0x144
   1f632:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
   1f636:	f010 0003 	ands.w	r0, r0, #3
   1f63a:	d133      	bne.n	1f6a4 <gpiote_pin_int_cfg+0x114>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   1f63c:	00a2      	lsls	r2, r4, #2
   1f63e:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   1f642:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1f646:	022d      	lsls	r5, r5, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   1f648:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
   1f64c:	f421 314f 	bic.w	r1, r1, #211968	; 0x33c00
   1f650:	f421 7140 	bic.w	r1, r1, #768	; 0x300
   1f654:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1f658:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
   1f65c:	f405 557c 	and.w	r5, r5, #16128	; 0x3f00
   1f660:	ea45 4606 	orr.w	r6, r5, r6, lsl #16
   1f664:	430e      	orrs	r6, r1
			nrf_gpiote_event_t evt =
   1f666:	f104 0140 	add.w	r1, r4, #64	; 0x40
   1f66a:	0089      	lsls	r1, r1, #2
    return ((uint32_t)p_reg + event);
   1f66c:	b289      	uxth	r1, r1
   1f66e:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   1f672:	f501 41c0 	add.w	r1, r1, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1f676:	f8c2 6510 	str.w	r6, [r2, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1f67a:	6008      	str	r0, [r1, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   1f67c:	6809      	ldr	r1, [r1, #0]
   1f67e:	9101      	str	r1, [sp, #4]
    (void)dummy;
   1f680:	9901      	ldr	r1, [sp, #4]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   1f682:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
   1f686:	f041 0101 	orr.w	r1, r1, #1
   1f68a:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
   1f68e:	2201      	movs	r2, #1
   1f690:	fa02 f404 	lsl.w	r4, r2, r4
    p_reg->INTENSET = mask;
   1f694:	f8c7 4304 	str.w	r4, [r7, #772]	; 0x304
}
   1f698:	b003      	add	sp, #12
   1f69a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1f69c:	3301      	adds	r3, #1
   1f69e:	2b08      	cmp	r3, #8
   1f6a0:	d185      	bne.n	1f5ae <gpiote_pin_int_cfg+0x1e>
   1f6a2:	e7a0      	b.n	1f5e6 <gpiote_pin_int_cfg+0x56>
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
   1f6a4:	3401      	adds	r4, #1
   1f6a6:	2c08      	cmp	r4, #8
   1f6a8:	d1c1      	bne.n	1f62e <gpiote_pin_int_cfg+0x9e>
	return -ENODEV;
   1f6aa:	f06f 0012 	mvn.w	r0, #18
   1f6ae:	e7f3      	b.n	1f698 <gpiote_pin_int_cfg+0x108>
	if ((BIT(pin) & data->int_active_level) != 0U) {
   1f6b0:	6979      	ldr	r1, [r7, #20]
   1f6b2:	40f1      	lsrs	r1, r6
   1f6b4:	f001 0101 	and.w	r1, r1, #1
   1f6b8:	f1c1 0103 	rsb	r1, r1, #3
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   1f6bc:	4628      	mov	r0, r5
   1f6be:	b2c9      	uxtb	r1, r1
   1f6c0:	f009 fbe4 	bl	28e8c <nrf_gpio_cfg_sense_set>
	int res = 0;
   1f6c4:	4620      	mov	r0, r4
   1f6c6:	e7e7      	b.n	1f698 <gpiote_pin_int_cfg+0x108>
   1f6c8:	40006000 	.word	0x40006000

0001f6cc <gpiote_event_handler>:
{
   1f6cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t fired_triggers[GPIO_COUNT] = {0};
   1f6ce:	2600      	movs	r6, #0
{
   1f6d0:	b085      	sub	sp, #20
	u32_t fired_triggers[GPIO_COUNT] = {0};
   1f6d2:	e9cd 6602 	strd	r6, r6, [sp, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1f6d6:	4d28      	ldr	r5, [pc, #160]	; (1f778 <gpiote_event_handler+0xac>)
   1f6d8:	682c      	ldr	r4, [r5, #0]
	if (port_event) {
   1f6da:	b15c      	cbz	r4, 1f6f4 <gpiote_event_handler+0x28>
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p0));
   1f6dc:	4827      	ldr	r0, [pc, #156]	; (1f77c <gpiote_event_handler+0xb0>)
   1f6de:	f009 fbe8 	bl	28eb2 <check_level_trigger_pins>
		fired_triggers[0] =
   1f6e2:	9002      	str	r0, [sp, #8]
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p1));
   1f6e4:	4826      	ldr	r0, [pc, #152]	; (1f780 <gpiote_event_handler+0xb4>)
   1f6e6:	f009 fbe4 	bl	28eb2 <check_level_trigger_pins>
		fired_triggers[1] =
   1f6ea:	9003      	str	r0, [sp, #12]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1f6ec:	602e      	str	r6, [r5, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   1f6ee:	682b      	ldr	r3, [r5, #0]
   1f6f0:	9300      	str	r3, [sp, #0]
    (void)dummy;
   1f6f2:	9b00      	ldr	r3, [sp, #0]
    return p_reg->INTENSET & mask;
   1f6f4:	4d23      	ldr	r5, [pc, #140]	; (1f784 <gpiote_event_handler+0xb8>)
{
   1f6f6:	2200      	movs	r2, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
   1f6f8:	2601      	movs	r6, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1f6fa:	4694      	mov	ip, r2
    return p_reg->INTENSET & mask;
   1f6fc:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
   1f700:	fa06 f102 	lsl.w	r1, r6, r2
   1f704:	4219      	tst	r1, r3
   1f706:	d01d      	beq.n	1f744 <gpiote_event_handler+0x78>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1f708:	0091      	lsls	r1, r2, #2
   1f70a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   1f70e:	f501 41c2 	add.w	r1, r1, #24832	; 0x6100
   1f712:	680b      	ldr	r3, [r1, #0]
   1f714:	b1b3      	cbz	r3, 1f744 <gpiote_event_handler+0x78>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1f716:	f502 73a2 	add.w	r3, r2, #324	; 0x144
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
   1f71a:	af04      	add	r7, sp, #16
   1f71c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1f720:	f8c1 c000 	str.w	ip, [r1]
   1f724:	f3c3 3040 	ubfx	r0, r3, #13, #1
   1f728:	eb07 0080 	add.w	r0, r7, r0, lsl #2
   1f72c:	f3c3 2304 	ubfx	r3, r3, #8, #5
   1f730:	f850 7c08 	ldr.w	r7, [r0, #-8]
   1f734:	fa06 f303 	lsl.w	r3, r6, r3
   1f738:	433b      	orrs	r3, r7
   1f73a:	f840 3c08 	str.w	r3, [r0, #-8]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   1f73e:	680b      	ldr	r3, [r1, #0]
   1f740:	9301      	str	r3, [sp, #4]
    (void)dummy;
   1f742:	9b01      	ldr	r3, [sp, #4]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1f744:	3201      	adds	r2, #1
   1f746:	2a08      	cmp	r2, #8
   1f748:	d1d8      	bne.n	1f6fc <gpiote_event_handler+0x30>
	if (fired_triggers[0]) {
   1f74a:	9902      	ldr	r1, [sp, #8]
   1f74c:	b111      	cbz	r1, 1f754 <gpiote_event_handler+0x88>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p0), fired_triggers[0]);
   1f74e:	480b      	ldr	r0, [pc, #44]	; (1f77c <gpiote_event_handler+0xb0>)
   1f750:	f7ff fe5e 	bl	1f410 <fire_callbacks>
	if (fired_triggers[1]) {
   1f754:	9903      	ldr	r1, [sp, #12]
   1f756:	b111      	cbz	r1, 1f75e <gpiote_event_handler+0x92>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p1), fired_triggers[1]);
   1f758:	4809      	ldr	r0, [pc, #36]	; (1f780 <gpiote_event_handler+0xb4>)
   1f75a:	f7ff fe59 	bl	1f410 <fire_callbacks>
	if (port_event) {
   1f75e:	b144      	cbz	r4, 1f772 <gpiote_event_handler+0xa6>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p0));
   1f760:	4806      	ldr	r0, [pc, #24]	; (1f77c <gpiote_event_handler+0xb0>)
   1f762:	f009 fc32 	bl	28fca <cfg_level_pins>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
   1f766:	4806      	ldr	r0, [pc, #24]	; (1f780 <gpiote_event_handler+0xb4>)
}
   1f768:	b005      	add	sp, #20
   1f76a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
   1f76e:	f009 bc2c 	b.w	28fca <cfg_level_pins>
}
   1f772:	b005      	add	sp, #20
   1f774:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f776:	bf00      	nop
   1f778:	4000617c 	.word	0x4000617c
   1f77c:	20007520 	.word	0x20007520
   1f780:	2000752c 	.word	0x2000752c
   1f784:	40006000 	.word	0x40006000

0001f788 <flash_nrf_pages_layout>:
	*layout = &dev_layout;
   1f788:	4b02      	ldr	r3, [pc, #8]	; (1f794 <flash_nrf_pages_layout+0xc>)
   1f78a:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
   1f78c:	2301      	movs	r3, #1
   1f78e:	6013      	str	r3, [r2, #0]
}
   1f790:	4770      	bx	lr
   1f792:	bf00      	nop
   1f794:	20001bbc 	.word	0x20001bbc

0001f798 <_ticker_stop>:
{
   1f798:	b513      	push	{r0, r1, r4, lr}
	int ret = ticker_stop(inst_idx, u_id, tic_id, NULL, NULL);
   1f79a:	2300      	movs	r3, #0
   1f79c:	9300      	str	r3, [sp, #0]
   1f79e:	f7f9 faef 	bl	18d80 <ticker_stop>
	if (ret != TICKER_STATUS_SUCCESS &&
   1f7a2:	f030 0302 	bics.w	r3, r0, #2
	int ret = ticker_stop(inst_idx, u_id, tic_id, NULL, NULL);
   1f7a6:	4604      	mov	r4, r0
	if (ret != TICKER_STATUS_SUCCESS &&
   1f7a8:	d00e      	beq.n	1f7c8 <_ticker_stop+0x30>
		__ASSERT(0, "Failed to stop ticker.\n");
   1f7aa:	4909      	ldr	r1, [pc, #36]	; (1f7d0 <_ticker_stop+0x38>)
   1f7ac:	4a09      	ldr	r2, [pc, #36]	; (1f7d4 <_ticker_stop+0x3c>)
   1f7ae:	480a      	ldr	r0, [pc, #40]	; (1f7d8 <_ticker_stop+0x40>)
   1f7b0:	f240 131d 	movw	r3, #285	; 0x11d
   1f7b4:	f004 fb95 	bl	23ee2 <printk>
   1f7b8:	4808      	ldr	r0, [pc, #32]	; (1f7dc <_ticker_stop+0x44>)
   1f7ba:	f004 fb92 	bl	23ee2 <printk>
   1f7be:	4805      	ldr	r0, [pc, #20]	; (1f7d4 <_ticker_stop+0x3c>)
   1f7c0:	f240 111d 	movw	r1, #285	; 0x11d
   1f7c4:	f004 fbd0 	bl	23f68 <assert_post_action>
}
   1f7c8:	4620      	mov	r0, r4
   1f7ca:	b002      	add	sp, #8
   1f7cc:	bd10      	pop	{r4, pc}
   1f7ce:	bf00      	nop
   1f7d0:	0002e3c9 	.word	0x0002e3c9
   1f7d4:	00030ec4 	.word	0x00030ec4
   1f7d8:	0002a5e8 	.word	0x0002a5e8
   1f7dc:	00030ef5 	.word	0x00030ef5

0001f7e0 <time_slot_callback_helper>:
{
   1f7e0:	b570      	push	{r4, r5, r6, lr}
   1f7e2:	b08c      	sub	sp, #48	; 0x30
   1f7e4:	461d      	mov	r5, r3
   1f7e6:	4606      	mov	r6, r0
	ll_radio_state_abort();
   1f7e8:	f7fa fef6 	bl	1a5d8 <ll_radio_state_abort>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   1f7ec:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
   1f7f0:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
   1f7f4:	f008 fdfd 	bl	283f2 <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index, /* Radio instance ticker */
   1f7f8:	4b12      	ldr	r3, [pc, #72]	; (1f844 <time_slot_callback_helper+0x64>)
   1f7fa:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   1f7fe:	9506      	str	r5, [sp, #24]
   1f800:	2400      	movs	r4, #0
   1f802:	e9cd 4304 	strd	r4, r3, [sp, #16]
   1f806:	2310      	movs	r3, #16
   1f808:	9300      	str	r3, [sp, #0]
   1f80a:	e9cd 4407 	strd	r4, r4, [sp, #28]
   1f80e:	4633      	mov	r3, r6
   1f810:	e9cd 4402 	strd	r4, r4, [sp, #8]
   1f814:	9401      	str	r4, [sp, #4]
   1f816:	4622      	mov	r2, r4
   1f818:	4621      	mov	r1, r4
   1f81a:	f7f9 fa21 	bl	18c60 <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
   1f81e:	f030 0302 	bics.w	r3, r0, #2
   1f822:	d00c      	beq.n	1f83e <time_slot_callback_helper+0x5e>
		((struct flash_op_desc *)context)->result = -ECANCELED;
   1f824:	f06f 0347 	mvn.w	r3, #71	; 0x47
		_ticker_stop(instance_index, 0, ticker_id);
   1f828:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   1f82c:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
		((struct flash_op_desc *)context)->result = -ECANCELED;
   1f830:	60ab      	str	r3, [r5, #8]
		_ticker_stop(instance_index, 0, ticker_id);
   1f832:	4621      	mov	r1, r4
   1f834:	f7ff ffb0 	bl	1f798 <_ticker_stop>
	z_impl_k_sem_give(sem);
   1f838:	4803      	ldr	r0, [pc, #12]	; (1f848 <time_slot_callback_helper+0x68>)
   1f83a:	f002 ff39 	bl	226b0 <z_impl_k_sem_give>
}
   1f83e:	b00c      	add	sp, #48	; 0x30
   1f840:	bd70      	pop	{r4, r5, r6, pc}
   1f842:	bf00      	nop
   1f844:	0001f84d 	.word	0x0001f84d
   1f848:	20001bdc 	.word	0x20001bdc

0001f84c <time_slot_callback_work>:
{
   1f84c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1f84e:	461c      	mov	r4, r3
	__ASSERT(ll_radio_state_is_idle(),
   1f850:	f008 fdd4 	bl	283fc <ll_radio_state_is_idle>
   1f854:	b970      	cbnz	r0, 1f874 <time_slot_callback_work+0x28>
   1f856:	4913      	ldr	r1, [pc, #76]	; (1f8a4 <time_slot_callback_work+0x58>)
   1f858:	4a13      	ldr	r2, [pc, #76]	; (1f8a8 <time_slot_callback_work+0x5c>)
   1f85a:	4814      	ldr	r0, [pc, #80]	; (1f8ac <time_slot_callback_work+0x60>)
   1f85c:	f44f 7395 	mov.w	r3, #298	; 0x12a
   1f860:	f004 fb3f 	bl	23ee2 <printk>
   1f864:	4812      	ldr	r0, [pc, #72]	; (1f8b0 <time_slot_callback_work+0x64>)
   1f866:	f004 fb3c 	bl	23ee2 <printk>
   1f86a:	480f      	ldr	r0, [pc, #60]	; (1f8a8 <time_slot_callback_work+0x5c>)
   1f86c:	f44f 7195 	mov.w	r1, #298	; 0x12a
   1f870:	f004 fb7a 	bl	23f68 <assert_post_action>
	if (op_desc->handler(op_desc->context) == FLASH_OP_DONE) {
   1f874:	e9d4 3000 	ldrd	r3, r0, [r4]
   1f878:	4798      	blx	r3
   1f87a:	4605      	mov	r5, r0
   1f87c:	b980      	cbnz	r0, 1f8a0 <time_slot_callback_work+0x54>
		ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   1f87e:	f10d 0107 	add.w	r1, sp, #7
   1f882:	f10d 0006 	add.w	r0, sp, #6
   1f886:	f008 fdb4 	bl	283f2 <ll_timeslice_ticker_id_get>
		_ticker_stop(instance_index, 0, ticker_id);
   1f88a:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1f88e:	f89d 0006 	ldrb.w	r0, [sp, #6]
   1f892:	4629      	mov	r1, r5
   1f894:	f7ff ff80 	bl	1f798 <_ticker_stop>
		((struct flash_op_desc *)context)->result = 0;
   1f898:	60a5      	str	r5, [r4, #8]
   1f89a:	4806      	ldr	r0, [pc, #24]	; (1f8b4 <time_slot_callback_work+0x68>)
   1f89c:	f002 ff08 	bl	226b0 <z_impl_k_sem_give>
}
   1f8a0:	b003      	add	sp, #12
   1f8a2:	bd30      	pop	{r4, r5, pc}
   1f8a4:	00030f0f 	.word	0x00030f0f
   1f8a8:	00030ec4 	.word	0x00030ec4
   1f8ac:	0002a5e8 	.word	0x0002a5e8
   1f8b0:	00030f28 	.word	0x00030f28
   1f8b4:	20001bdc 	.word	0x20001bdc

0001f8b8 <nrf_flash_init>:
{
   1f8b8:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   1f8ba:	2201      	movs	r2, #1
   1f8bc:	4611      	mov	r1, r2
   1f8be:	4808      	ldr	r0, [pc, #32]	; (1f8e0 <nrf_flash_init+0x28>)
   1f8c0:	f009 fd0a 	bl	292d8 <z_impl_k_sem_init>
   1f8c4:	2201      	movs	r2, #1
   1f8c6:	2100      	movs	r1, #0
   1f8c8:	4806      	ldr	r0, [pc, #24]	; (1f8e4 <nrf_flash_init+0x2c>)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   1f8ca:	4c07      	ldr	r4, [pc, #28]	; (1f8e8 <nrf_flash_init+0x30>)
   1f8cc:	f009 fd04 	bl	292d8 <z_impl_k_sem_init>
   1f8d0:	f009 fc60 	bl	29194 <nrfx_nvmc_flash_page_count_get>
   1f8d4:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   1f8d6:	f009 fc59 	bl	2918c <nrfx_nvmc_flash_page_size_get>
   1f8da:	6060      	str	r0, [r4, #4]
}
   1f8dc:	2000      	movs	r0, #0
   1f8de:	bd10      	pop	{r4, pc}
   1f8e0:	20001bc4 	.word	0x20001bc4
   1f8e4:	20001bdc 	.word	0x20001bdc
   1f8e8:	20001bbc 	.word	0x20001bbc

0001f8ec <flash_nrf_erase>:
{
   1f8ec:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f8ee:	b08b      	sub	sp, #44	; 0x2c
   1f8f0:	460e      	mov	r6, r1
   1f8f2:	4615      	mov	r5, r2
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   1f8f4:	f009 fc4a 	bl	2918c <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
   1f8f8:	4629      	mov	r1, r5
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   1f8fa:	4607      	mov	r7, r0
	if (is_regular_addr_valid(addr, size)) {
   1f8fc:	4630      	mov	r0, r6
   1f8fe:	f009 fb9a 	bl	29036 <is_regular_addr_valid>
   1f902:	2800      	cmp	r0, #0
   1f904:	d03a      	beq.n	1f97c <flash_nrf_erase+0x90>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
   1f906:	fbb6 f3f7 	udiv	r3, r6, r7
   1f90a:	fb07 6313 	mls	r3, r7, r3, r6
   1f90e:	bbab      	cbnz	r3, 1f97c <flash_nrf_erase+0x90>
   1f910:	fbb5 f4f7 	udiv	r4, r5, r7
   1f914:	fb07 5414 	mls	r4, r7, r4, r5
   1f918:	bb84      	cbnz	r4, 1f97c <flash_nrf_erase+0x90>
		if (!n_pages) {
   1f91a:	42af      	cmp	r7, r5
   1f91c:	d822      	bhi.n	1f964 <flash_nrf_erase+0x78>
	return z_impl_k_sem_take(sem, timeout);
   1f91e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1f922:	4818      	ldr	r0, [pc, #96]	; (1f984 <flash_nrf_erase+0x98>)
   1f924:	f002 ff08 	bl	22738 <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
   1f928:	4620      	mov	r0, r4
   1f92a:	f7f9 f97b 	bl	18c24 <ticker_is_initialized>
   1f92e:	ab04      	add	r3, sp, #16
   1f930:	4601      	mov	r1, r0
   1f932:	b1d0      	cbz	r0, 1f96a <flash_nrf_erase+0x7e>
	struct flash_context context = {
   1f934:	2210      	movs	r2, #16
   1f936:	4621      	mov	r1, r4
   1f938:	4618      	mov	r0, r3
   1f93a:	f006 f9e0 	bl	25cfe <memset>
   1f93e:	2201      	movs	r2, #1
   1f940:	f88d 201c 	strb.w	r2, [sp, #28]
   1f944:	4a10      	ldr	r2, [pc, #64]	; (1f988 <flash_nrf_erase+0x9c>)
	struct flash_op_desc flash_op_desc = {
   1f946:	9403      	str	r4, [sp, #12]
	struct flash_context context = {
   1f948:	e9cd 2208 	strd	r2, r2, [sp, #32]
	struct flash_op_desc flash_op_desc = {
   1f94c:	4a0f      	ldr	r2, [pc, #60]	; (1f98c <flash_nrf_erase+0xa0>)
   1f94e:	e9cd 2001 	strd	r2, r0, [sp, #4]
	return work_in_time_slice(&flash_op_desc);
   1f952:	a801      	add	r0, sp, #4
	struct flash_context context = {
   1f954:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return work_in_time_slice(&flash_op_desc);
   1f958:	f7e1 fefa 	bl	1750 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		.enable_time_limit = 0 /* disable time limit */
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	};

	return	erase_op(&context);
   1f95c:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   1f95e:	4809      	ldr	r0, [pc, #36]	; (1f984 <flash_nrf_erase+0x98>)
   1f960:	f002 fea6 	bl	226b0 <z_impl_k_sem_give>
}
   1f964:	4620      	mov	r0, r4
   1f966:	b00b      	add	sp, #44	; 0x2c
   1f968:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct flash_context context = {
   1f96a:	2218      	movs	r2, #24
   1f96c:	4618      	mov	r0, r3
   1f96e:	f006 f9c6 	bl	25cfe <memset>
   1f972:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return	erase_op(&context);
   1f976:	f7e1 fea3 	bl	16c0 <erase_op>
   1f97a:	e7ef      	b.n	1f95c <flash_nrf_erase+0x70>
		return -EINVAL;
   1f97c:	f06f 0415 	mvn.w	r4, #21
   1f980:	e7f0      	b.n	1f964 <flash_nrf_erase+0x78>
   1f982:	bf00      	nop
   1f984:	20001bc4 	.word	0x20001bc4
   1f988:	00015e64 	.word	0x00015e64
   1f98c:	000016c1 	.word	0x000016c1

0001f990 <flash_nrf_write>:
{
   1f990:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f992:	460d      	mov	r5, r1
   1f994:	b08b      	sub	sp, #44	; 0x2c
	if (is_regular_addr_valid(addr, len)) {
   1f996:	4619      	mov	r1, r3
   1f998:	4628      	mov	r0, r5
{
   1f99a:	4617      	mov	r7, r2
   1f99c:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   1f99e:	f009 fb4a 	bl	29036 <is_regular_addr_valid>
   1f9a2:	b388      	cbz	r0, 1fa08 <flash_nrf_write+0x78>
	if (!is_aligned_32(addr) || (len % sizeof(u32_t))) {
   1f9a4:	ea45 0604 	orr.w	r6, r5, r4
   1f9a8:	f016 0603 	ands.w	r6, r6, #3
   1f9ac:	d12c      	bne.n	1fa08 <flash_nrf_write+0x78>
	if (!len) {
   1f9ae:	b1fc      	cbz	r4, 1f9f0 <flash_nrf_write+0x60>
	return z_impl_k_sem_take(sem, timeout);
   1f9b0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1f9b4:	4816      	ldr	r0, [pc, #88]	; (1fa10 <flash_nrf_write+0x80>)
   1f9b6:	f002 febf 	bl	22738 <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
   1f9ba:	4630      	mov	r0, r6
   1f9bc:	f7f9 f932 	bl	18c24 <ticker_is_initialized>
   1f9c0:	4603      	mov	r3, r0
   1f9c2:	a804      	add	r0, sp, #16
   1f9c4:	b1bb      	cbz	r3, 1f9f6 <flash_nrf_write+0x66>
	struct flash_context context = {
   1f9c6:	2301      	movs	r3, #1
   1f9c8:	f88d 301c 	strb.w	r3, [sp, #28]
   1f9cc:	f641 534c 	movw	r3, #7500	; 0x1d4c
   1f9d0:	e9cd 3308 	strd	r3, r3, [sp, #32]
	struct flash_op_desc flash_op_desc = {
   1f9d4:	4b0f      	ldr	r3, [pc, #60]	; (1fa14 <flash_nrf_write+0x84>)
	struct flash_context context = {
   1f9d6:	9406      	str	r4, [sp, #24]
	struct flash_op_desc flash_op_desc = {
   1f9d8:	e9cd 3001 	strd	r3, r0, [sp, #4]
	return  work_in_time_slice(&flash_op_desc);
   1f9dc:	a801      	add	r0, sp, #4
	struct flash_context context = {
   1f9de:	e9cd 7504 	strd	r7, r5, [sp, #16]
	struct flash_op_desc flash_op_desc = {
   1f9e2:	9603      	str	r6, [sp, #12]
	return  work_in_time_slice(&flash_op_desc);
   1f9e4:	f7e1 feb4 	bl	1750 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		.enable_time_limit = 0 /* disable time limit */
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	};

	return write_op(&context);
   1f9e8:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   1f9ea:	4809      	ldr	r0, [pc, #36]	; (1fa10 <flash_nrf_write+0x80>)
   1f9ec:	f002 fe60 	bl	226b0 <z_impl_k_sem_give>
}
   1f9f0:	4620      	mov	r0, r4
   1f9f2:	b00b      	add	sp, #44	; 0x2c
   1f9f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct flash_context context = {
   1f9f6:	e9cd 3307 	strd	r3, r3, [sp, #28]
   1f9fa:	e9cd 7504 	strd	r7, r5, [sp, #16]
   1f9fe:	9309      	str	r3, [sp, #36]	; 0x24
   1fa00:	9406      	str	r4, [sp, #24]
	return write_op(&context);
   1fa02:	f7e1 ff1d 	bl	1840 <write_op>
   1fa06:	e7ef      	b.n	1f9e8 <flash_nrf_write+0x58>
		return -EINVAL;
   1fa08:	f06f 0415 	mvn.w	r4, #21
   1fa0c:	e7f0      	b.n	1f9f0 <flash_nrf_write+0x60>
   1fa0e:	bf00      	nop
   1fa10:	20001bc4 	.word	0x20001bc4
   1fa14:	00001841 	.word	0x00001841

0001fa18 <uart_nrfx_err_check>:
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_uart_errorsrc_get_and_clear(NRF_UART_Type * p_reg)
{
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   1fa18:	4b02      	ldr	r3, [pc, #8]	; (1fa24 <uart_nrfx_err_check+0xc>)
   1fa1a:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   1fa1e:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
/** Console I/O function */
static int uart_nrfx_err_check(struct device *dev)
{
	/* register bitfields maps to the defines in uart.h */
	return nrf_uart_errorsrc_get_and_clear(uart0_addr);
}
   1fa22:	4770      	bx	lr
   1fa24:	40002000 	.word	0x40002000

0001fa28 <nrf_gpio_pin_port_decode>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1fa28:	6803      	ldr	r3, [r0, #0]
   1fa2a:	2b2f      	cmp	r3, #47	; 0x2f
{
   1fa2c:	b510      	push	{r4, lr}
   1fa2e:	4604      	mov	r4, r0
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1fa30:	d90b      	bls.n	1fa4a <nrf_gpio_pin_port_decode+0x22>
   1fa32:	490b      	ldr	r1, [pc, #44]	; (1fa60 <nrf_gpio_pin_port_decode+0x38>)
   1fa34:	480b      	ldr	r0, [pc, #44]	; (1fa64 <nrf_gpio_pin_port_decode+0x3c>)
   1fa36:	4a0c      	ldr	r2, [pc, #48]	; (1fa68 <nrf_gpio_pin_port_decode+0x40>)
   1fa38:	f240 13ff 	movw	r3, #511	; 0x1ff
   1fa3c:	f004 fa51 	bl	23ee2 <printk>
   1fa40:	4809      	ldr	r0, [pc, #36]	; (1fa68 <nrf_gpio_pin_port_decode+0x40>)
   1fa42:	f240 11ff 	movw	r1, #511	; 0x1ff
   1fa46:	f004 fa8f 	bl	23f68 <assert_post_action>
    if (*p_pin < P0_PIN_NUM)
   1fa4a:	6823      	ldr	r3, [r4, #0]
   1fa4c:	2b1f      	cmp	r3, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   1fa4e:	bf83      	ittte	hi
   1fa50:	f003 031f 	andhi.w	r3, r3, #31
        return NRF_P1;
   1fa54:	4805      	ldrhi	r0, [pc, #20]	; (1fa6c <nrf_gpio_pin_port_decode+0x44>)
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   1fa56:	6023      	strhi	r3, [r4, #0]
        return NRF_P0;
   1fa58:	f04f 40a0 	movls.w	r0, #1342177280	; 0x50000000
}
   1fa5c:	bd10      	pop	{r4, pc}
   1fa5e:	bf00      	nop
   1fa60:	00030e04 	.word	0x00030e04
   1fa64:	0002a5e8 	.word	0x0002a5e8
   1fa68:	00030dd1 	.word	0x00030dd1
   1fa6c:	50000300 	.word	0x50000300

0001fa70 <uart_nrfx_configure>:

static int uart_nrfx_configure(struct device *dev,
			       const struct uart_config *cfg)
{
   1fa70:	b570      	push	{r4, r5, r6, lr}
	nrf_uart_config_t uart_cfg;

#if defined(UART_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   1fa72:	794b      	ldrb	r3, [r1, #5]
   1fa74:	2b01      	cmp	r3, #1
   1fa76:	d028      	beq.n	1faca <uart_nrfx_configure+0x5a>
   1fa78:	2b03      	cmp	r3, #3
   1fa7a:	d123      	bne.n	1fac4 <uart_nrfx_configure+0x54>
	case UART_CFG_STOP_BITS_1:
		uart_cfg.stop = NRF_UART_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uart_cfg.stop = NRF_UART_STOP_TWO;
   1fa7c:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   1fa7e:	798b      	ldrb	r3, [r1, #6]
   1fa80:	2b03      	cmp	r3, #3
   1fa82:	d11f      	bne.n	1fac4 <uart_nrfx_configure+0x54>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   1fa84:	79cc      	ldrb	r4, [r1, #7]
   1fa86:	b12c      	cbz	r4, 1fa94 <uart_nrfx_configure+0x24>
   1fa88:	2c01      	cmp	r4, #1
   1fa8a:	d11b      	bne.n	1fac4 <uart_nrfx_configure+0x54>
	return dev->config->config_info;
   1fa8c:	6803      	ldr	r3, [r0, #0]
	case UART_CFG_FLOW_CTRL_NONE:
		uart_cfg.hwfc = NRF_UART_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
   1fa8e:	689b      	ldr	r3, [r3, #8]
   1fa90:	781b      	ldrb	r3, [r3, #0]
   1fa92:	b1bb      	cbz	r3, 1fac4 <uart_nrfx_configure+0x54>
	}

#if defined(UART_CONFIG_PARITYTYPE_Msk)
	uart_cfg.paritytype = NRF_UART_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   1fa94:	790a      	ldrb	r2, [r1, #4]
   1fa96:	b112      	cbz	r2, 1fa9e <uart_nrfx_configure+0x2e>
   1fa98:	2a02      	cmp	r2, #2
   1fa9a:	d113      	bne.n	1fac4 <uart_nrfx_configure+0x54>
	case UART_CFG_PARITY_NONE:
		uart_cfg.parity = NRF_UART_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uart_cfg.parity = NRF_UART_PARITY_INCLUDED;
   1fa9c:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   1fa9e:	680b      	ldr	r3, [r1, #0]
	switch (baudrate) {
   1faa0:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
   1faa4:	d062      	beq.n	1fb6c <uart_nrfx_configure+0xfc>
   1faa6:	d82d      	bhi.n	1fb04 <uart_nrfx_configure+0x94>
   1faa8:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   1faac:	d060      	beq.n	1fb70 <uart_nrfx_configure+0x100>
   1faae:	d816      	bhi.n	1fade <uart_nrfx_configure+0x6e>
   1fab0:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   1fab4:	d05e      	beq.n	1fb74 <uart_nrfx_configure+0x104>
   1fab6:	d80a      	bhi.n	1face <uart_nrfx_configure+0x5e>
   1fab8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   1fabc:	d05d      	beq.n	1fb7a <uart_nrfx_configure+0x10a>
   1fabe:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   1fac2:	d05d      	beq.n	1fb80 <uart_nrfx_configure+0x110>
   1fac4:	f06f 0022 	mvn.w	r0, #34	; 0x22
   1fac8:	e04f      	b.n	1fb6a <uart_nrfx_configure+0xfa>
	switch (cfg->stop_bits) {
   1faca:	2600      	movs	r6, #0
   1facc:	e7d7      	b.n	1fa7e <uart_nrfx_configure+0xe>
	switch (baudrate) {
   1face:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   1fad2:	d058      	beq.n	1fb86 <uart_nrfx_configure+0x116>
   1fad4:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   1fad8:	d1f4      	bne.n	1fac4 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_4800;
   1fada:	4b35      	ldr	r3, [pc, #212]	; (1fbb0 <uart_nrfx_configure+0x140>)
   1fadc:	e039      	b.n	1fb52 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
   1fade:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   1fae2:	d053      	beq.n	1fb8c <uart_nrfx_configure+0x11c>
   1fae4:	d807      	bhi.n	1faf6 <uart_nrfx_configure+0x86>
   1fae6:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   1faea:	d051      	beq.n	1fb90 <uart_nrfx_configure+0x120>
   1faec:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   1faf0:	d1e8      	bne.n	1fac4 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_19200;
   1faf2:	4b30      	ldr	r3, [pc, #192]	; (1fbb4 <uart_nrfx_configure+0x144>)
   1faf4:	e02d      	b.n	1fb52 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
   1faf6:	f647 2512 	movw	r5, #31250	; 0x7a12
   1fafa:	42ab      	cmp	r3, r5
   1fafc:	d1e2      	bne.n	1fac4 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_31250;
   1fafe:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   1fb02:	e026      	b.n	1fb52 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
   1fb04:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   1fb08:	d045      	beq.n	1fb96 <uart_nrfx_configure+0x126>
   1fb0a:	d811      	bhi.n	1fb30 <uart_nrfx_configure+0xc0>
   1fb0c:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   1fb10:	d043      	beq.n	1fb9a <uart_nrfx_configure+0x12a>
   1fb12:	d808      	bhi.n	1fb26 <uart_nrfx_configure+0xb6>
   1fb14:	f64d 25c0 	movw	r5, #56000	; 0xdac0
   1fb18:	42ab      	cmp	r3, r5
   1fb1a:	d040      	beq.n	1fb9e <uart_nrfx_configure+0x12e>
   1fb1c:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   1fb20:	d1d0      	bne.n	1fac4 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_57600;
   1fb22:	4b25      	ldr	r3, [pc, #148]	; (1fbb8 <uart_nrfx_configure+0x148>)
   1fb24:	e015      	b.n	1fb52 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
   1fb26:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   1fb2a:	d1cb      	bne.n	1fac4 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_115200;
   1fb2c:	4b23      	ldr	r3, [pc, #140]	; (1fbbc <uart_nrfx_configure+0x14c>)
   1fb2e:	e010      	b.n	1fb52 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
   1fb30:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   1fb34:	d036      	beq.n	1fba4 <uart_nrfx_configure+0x134>
   1fb36:	d807      	bhi.n	1fb48 <uart_nrfx_configure+0xd8>
   1fb38:	4d21      	ldr	r5, [pc, #132]	; (1fbc0 <uart_nrfx_configure+0x150>)
   1fb3a:	42ab      	cmp	r3, r5
   1fb3c:	d034      	beq.n	1fba8 <uart_nrfx_configure+0x138>
   1fb3e:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   1fb42:	d1bf      	bne.n	1fac4 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_460800;
   1fb44:	4b1f      	ldr	r3, [pc, #124]	; (1fbc4 <uart_nrfx_configure+0x154>)
   1fb46:	e004      	b.n	1fb52 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
   1fb48:	4d1f      	ldr	r5, [pc, #124]	; (1fbc8 <uart_nrfx_configure+0x158>)
   1fb4a:	42ab      	cmp	r3, r5
   1fb4c:	d1ba      	bne.n	1fac4 <uart_nrfx_configure+0x54>
		nrf_baudrate = NRF_UART_BAUDRATE_1000000;
   1fb4e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uart_baudrate_set(NRF_UART_Type * p_reg, nrf_uart_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   1fb52:	4d1e      	ldr	r5, [pc, #120]	; (1fbcc <uart_nrfx_configure+0x15c>)
                    | (uint32_t)p_cfg->hwfc;
   1fb54:	4334      	orrs	r4, r6
   1fb56:	4322      	orrs	r2, r4
    p_reg->BAUDRATE = baudrate;
   1fb58:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   1fb5c:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
		return -ENOTSUP;
	}

	nrf_uart_configure(uart0_addr, &uart_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   1fb60:	6883      	ldr	r3, [r0, #8]
   1fb62:	c903      	ldmia	r1, {r0, r1}
   1fb64:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   1fb68:	2000      	movs	r0, #0
}
   1fb6a:	bd70      	pop	{r4, r5, r6, pc}
		nrf_baudrate = NRF_UART_BAUDRATE_38400;
   1fb6c:	4b18      	ldr	r3, [pc, #96]	; (1fbd0 <uart_nrfx_configure+0x160>)
   1fb6e:	e7f0      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_9600;
   1fb70:	4b18      	ldr	r3, [pc, #96]	; (1fbd4 <uart_nrfx_configure+0x164>)
   1fb72:	e7ee      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_1200;
   1fb74:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   1fb78:	e7eb      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = 0x00014000;
   1fb7a:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   1fb7e:	e7e8      	b.n	1fb52 <uart_nrfx_configure+0xe2>
	switch (baudrate) {
   1fb80:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   1fb84:	e7e5      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_2400;
   1fb86:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   1fb8a:	e7e2      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_28800;
   1fb8c:	4b12      	ldr	r3, [pc, #72]	; (1fbd8 <uart_nrfx_configure+0x168>)
   1fb8e:	e7e0      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_14400;
   1fb90:	f44f 136c 	mov.w	r3, #3866624	; 0x3b0000
   1fb94:	e7dd      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_230400;
   1fb96:	4b11      	ldr	r3, [pc, #68]	; (1fbdc <uart_nrfx_configure+0x16c>)
   1fb98:	e7db      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_76800;
   1fb9a:	4b11      	ldr	r3, [pc, #68]	; (1fbe0 <uart_nrfx_configure+0x170>)
   1fb9c:	e7d9      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_56000;
   1fb9e:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   1fba2:	e7d6      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_921600;
   1fba4:	4b0f      	ldr	r3, [pc, #60]	; (1fbe4 <uart_nrfx_configure+0x174>)
   1fba6:	e7d4      	b.n	1fb52 <uart_nrfx_configure+0xe2>
		nrf_baudrate = NRF_UART_BAUDRATE_250000;
   1fba8:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   1fbac:	e7d1      	b.n	1fb52 <uart_nrfx_configure+0xe2>
   1fbae:	bf00      	nop
   1fbb0:	0013b000 	.word	0x0013b000
   1fbb4:	004ea000 	.word	0x004ea000
   1fbb8:	00ebf000 	.word	0x00ebf000
   1fbbc:	01d7e000 	.word	0x01d7e000
   1fbc0:	0003d090 	.word	0x0003d090
   1fbc4:	075f7000 	.word	0x075f7000
   1fbc8:	000f4240 	.word	0x000f4240
   1fbcc:	40002000 	.word	0x40002000
   1fbd0:	009d5000 	.word	0x009d5000
   1fbd4:	00275000 	.word	0x00275000
   1fbd8:	0075f000 	.word	0x0075f000
   1fbdc:	03afb000 	.word	0x03afb000
   1fbe0:	013a9000 	.word	0x013a9000
   1fbe4:	0ebed000 	.word	0x0ebed000

0001fbe8 <uart_nrfx_poll_in>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1fbe8:	4b08      	ldr	r3, [pc, #32]	; (1fc0c <uart_nrfx_poll_in+0x24>)
   1fbea:	681a      	ldr	r2, [r3, #0]
{
   1fbec:	b082      	sub	sp, #8
	if (!nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY)) {
   1fbee:	b152      	cbz	r2, 1fc06 <uart_nrfx_poll_in+0x1e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1fbf0:	2000      	movs	r0, #0
   1fbf2:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   1fbf4:	681b      	ldr	r3, [r3, #0]
   1fbf6:	9301      	str	r3, [sp, #4]
    (void)dummy;
   1fbf8:	9b01      	ldr	r3, [sp, #4]
    return p_reg->RXD;
   1fbfa:	4b05      	ldr	r3, [pc, #20]	; (1fc10 <uart_nrfx_poll_in+0x28>)
   1fbfc:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
   1fc00:	700b      	strb	r3, [r1, #0]
}
   1fc02:	b002      	add	sp, #8
   1fc04:	4770      	bx	lr
		return -1;
   1fc06:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1fc0a:	e7fa      	b.n	1fc02 <uart_nrfx_poll_in+0x1a>
   1fc0c:	40002108 	.word	0x40002108
   1fc10:	40002000 	.word	0x40002000

0001fc14 <uart_nrfx_poll_out>:
{
   1fc14:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1fc16:	460e      	mov	r6, r1
	if (!k_is_in_isr()) {
   1fc18:	f009 fb6e 	bl	292f8 <k_is_in_isr>
   1fc1c:	4d1a      	ldr	r5, [pc, #104]	; (1fc88 <uart_nrfx_poll_out+0x74>)
   1fc1e:	b9b8      	cbnz	r0, 1fc50 <uart_nrfx_poll_out+0x3c>
   1fc20:	2464      	movs	r4, #100	; 0x64
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1fc22:	2701      	movs	r7, #1
   1fc24:	f3bf 8f5b 	dmb	ish
   1fc28:	e855 3f00 	ldrex	r3, [r5]
   1fc2c:	2b00      	cmp	r3, #0
   1fc2e:	d103      	bne.n	1fc38 <uart_nrfx_poll_out+0x24>
   1fc30:	e845 7200 	strex	r2, r7, [r5]
   1fc34:	2a00      	cmp	r2, #0
   1fc36:	d1f7      	bne.n	1fc28 <uart_nrfx_poll_out+0x14>
   1fc38:	f3bf 8f5b 	dmb	ish
		while (atomic_cas((atomic_t *) lock,
   1fc3c:	d00a      	beq.n	1fc54 <uart_nrfx_poll_out+0x40>
	return z_impl_k_sleep(timeout);
   1fc3e:	2001      	movs	r0, #1
   1fc40:	3c01      	subs	r4, #1
   1fc42:	f002 fcf3 	bl	2262c <z_impl_k_sleep>
			if (--safety_cnt == 0) {
   1fc46:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   1fc4a:	d1eb      	bne.n	1fc24 <uart_nrfx_poll_out+0x10>
}
   1fc4c:	b003      	add	sp, #12
   1fc4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*lock = 1;
   1fc50:	2301      	movs	r3, #1
   1fc52:	602b      	str	r3, [r5, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1fc54:	4c0d      	ldr	r4, [pc, #52]	; (1fc8c <uart_nrfx_poll_out+0x78>)
   1fc56:	2200      	movs	r2, #0
   1fc58:	6022      	str	r2, [r4, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   1fc5a:	6822      	ldr	r2, [r4, #0]
   1fc5c:	9201      	str	r2, [sp, #4]
    (void)dummy;
   1fc5e:	9a01      	ldr	r2, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fc60:	4a0b      	ldr	r2, [pc, #44]	; (1fc90 <uart_nrfx_poll_out+0x7c>)
   1fc62:	2101      	movs	r1, #1
   1fc64:	6011      	str	r1, [r2, #0]
    p_reg->TXD = txd;
   1fc66:	f8c2 6514 	str.w	r6, [r2, #1300]	; 0x514
   1fc6a:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1fc6e:	6823      	ldr	r3, [r4, #0]
	NRFX_WAIT_FOR(event_txdrdy_check(), 1000, 1, res);
   1fc70:	b923      	cbnz	r3, 1fc7c <uart_nrfx_poll_out+0x68>
   1fc72:	2001      	movs	r0, #1
   1fc74:	f009 fa80 	bl	29178 <nrfx_busy_wait>
   1fc78:	3e01      	subs	r6, #1
   1fc7a:	d1f8      	bne.n	1fc6e <uart_nrfx_poll_out+0x5a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fc7c:	4b05      	ldr	r3, [pc, #20]	; (1fc94 <uart_nrfx_poll_out+0x80>)
   1fc7e:	2201      	movs	r2, #1
   1fc80:	601a      	str	r2, [r3, #0]
	*lock = 0;
   1fc82:	2300      	movs	r3, #0
   1fc84:	602b      	str	r3, [r5, #0]
   1fc86:	e7e1      	b.n	1fc4c <uart_nrfx_poll_out+0x38>
   1fc88:	20001bf4 	.word	0x20001bf4
   1fc8c:	4000211c 	.word	0x4000211c
   1fc90:	40002008 	.word	0x40002008
   1fc94:	4000200c 	.word	0x4000200c

0001fc98 <uart_nrfx_init>:
 * @param dev UART device struct
 *
 * @return 0 on success
 */
static int uart_nrfx_init(struct device *dev)
{
   1fc98:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1fc9c:	2706      	movs	r7, #6
   1fc9e:	4605      	mov	r5, r0
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1fca0:	a801      	add	r0, sp, #4
   1fca2:	9701      	str	r7, [sp, #4]
   1fca4:	f7ff fec0 	bl	1fa28 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1fca8:	9b01      	ldr	r3, [sp, #4]
    p_reg->PSEL.RXD = pselrxd;
   1fcaa:	4c2b      	ldr	r4, [pc, #172]	; (1fd58 <uart_nrfx_init+0xc0>)
   1fcac:	2601      	movs	r6, #1
   1fcae:	fa06 f303 	lsl.w	r3, r6, r3
    p_reg->OUTSET = set_mask;
   1fcb2:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1fcb6:	a801      	add	r0, sp, #4
   1fcb8:	9701      	str	r7, [sp, #4]
   1fcba:	f7ff feb5 	bl	1fa28 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1fcbe:	9b01      	ldr	r3, [sp, #4]
   1fcc0:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   1fcc4:	f04f 0903 	mov.w	r9, #3
   1fcc8:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
    nrf_gpio_cfg(
   1fccc:	f04f 0a08 	mov.w	sl, #8
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1fcd0:	a801      	add	r0, sp, #4
   1fcd2:	f8cd a004 	str.w	sl, [sp, #4]
   1fcd6:	f7ff fea7 	bl	1fa28 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1fcda:	9b01      	ldr	r3, [sp, #4]
   1fcdc:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   1fce0:	f04f 0800 	mov.w	r8, #0
   1fce4:	f840 8023 	str.w	r8, [r0, r3, lsl #2]
   1fce8:	f8c4 a514 	str.w	sl, [r4, #1300]	; 0x514
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1fcec:	a801      	add	r0, sp, #4
    p_reg->PSEL.TXD = pseltxd;
   1fcee:	f8c4 750c 	str.w	r7, [r4, #1292]	; 0x50c
        nrf_gpio_pin_set(pin_number);
   1fcf2:	2705      	movs	r7, #5
   1fcf4:	9701      	str	r7, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1fcf6:	f7ff fe97 	bl	1fa28 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1fcfa:	9b01      	ldr	r3, [sp, #4]
   1fcfc:	fa06 f303 	lsl.w	r3, r6, r3
    p_reg->OUTSET = set_mask;
   1fd00:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1fd04:	a801      	add	r0, sp, #4
   1fd06:	9701      	str	r7, [sp, #4]
   1fd08:	f7ff fe8e 	bl	1fa28 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1fd0c:	9b01      	ldr	r3, [sp, #4]
   1fd0e:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   1fd12:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
    nrf_gpio_cfg(
   1fd16:	f04f 0907 	mov.w	r9, #7
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1fd1a:	a801      	add	r0, sp, #4
   1fd1c:	f8cd 9004 	str.w	r9, [sp, #4]
   1fd20:	f7ff fe82 	bl	1fa28 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1fd24:	9b01      	ldr	r3, [sp, #4]

	nrf_uart_hwfc_pins_set(uart0_addr, RTS_PIN, CTS_PIN);
#endif

	/* Set initial configuration */
	err = uart_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   1fd26:	68a9      	ldr	r1, [r5, #8]
   1fd28:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   1fd2c:	f840 8023 	str.w	r8, [r0, r3, lsl #2]
    p_reg->PSEL.RTS = pselrts;
   1fd30:	f8c4 7508 	str.w	r7, [r4, #1288]	; 0x508
   1fd34:	4628      	mov	r0, r5
    p_reg->PSEL.CTS = pselcts;
   1fd36:	f8c4 9510 	str.w	r9, [r4, #1296]	; 0x510
   1fd3a:	f7ff fe99 	bl	1fa70 <uart_nrfx_configure>
	if (err) {
   1fd3e:	b940      	cbnz	r0, 1fd52 <uart_nrfx_init+0xba>
    p_reg->ENABLE = UART_ENABLE_ENABLE_Enabled;
   1fd40:	2304      	movs	r3, #4
   1fd42:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1fd46:	4b05      	ldr	r3, [pc, #20]	; (1fd5c <uart_nrfx_init+0xc4>)
   1fd48:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   1fd4a:	681b      	ldr	r3, [r3, #0]
   1fd4c:	9301      	str	r3, [sp, #4]
    (void)dummy;
   1fd4e:	9b01      	ldr	r3, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fd50:	6026      	str	r6, [r4, #0]
#if	HW_FLOW_CONTROL
	k_delayed_work_init(&uart0_cb.tx_timeout_work, tx_timeout);
#endif
#endif
	return 0;
}
   1fd52:	b002      	add	sp, #8
   1fd54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1fd58:	40002000 	.word	0x40002000
   1fd5c:	40002108 	.word	0x40002108

0001fd60 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static u16_t rng_pool_get(struct rng_pool *rngp, u8_t *buf, u16_t len)
{
   1fd60:	b5f0      	push	{r4, r5, r6, r7, lr}
   1fd62:	4603      	mov	r3, r0
	u32_t last  = rngp->last;
   1fd64:	7884      	ldrb	r4, [r0, #2]
	u32_t mask  = rngp->mask;
   1fd66:	78c7      	ldrb	r7, [r0, #3]
	__asm__ volatile(
   1fd68:	f04f 0520 	mov.w	r5, #32
   1fd6c:	f3ef 8011 	mrs	r0, BASEPRI
   1fd70:	f385 8811 	msr	BASEPRI, r5
   1fd74:	f3bf 8f6f 	isb	sy
	u32_t first, available;
	u32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
   1fd78:	781e      	ldrb	r6, [r3, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
   1fd7a:	f893 e001 	ldrb.w	lr, [r3, #1]

	available = (last - first) & mask;
   1fd7e:	1ba4      	subs	r4, r4, r6
   1fd80:	403c      	ands	r4, r7
	if (available < len) {
   1fd82:	42a2      	cmp	r2, r4
		len = available;
   1fd84:	bf88      	it	hi
   1fd86:	b2a2      	uxthhi	r2, r4

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
   1fd88:	eb06 0c02 	add.w	ip, r6, r2
   1fd8c:	ea07 0c0c 	and.w	ip, r7, ip
	first = rngp->first_alloc;
   1fd90:	4635      	mov	r5, r6
	rngp->first_alloc = (first + len) & mask;
   1fd92:	f883 c000 	strb.w	ip, [r3]
	__asm__ volatile(
   1fd96:	f380 8811 	msr	BASEPRI, r0
   1fd9a:	f3bf 8f6f 	isb	sy
   1fd9e:	440a      	add	r2, r1
	u8_t *dst   = buf;
   1fda0:	4608      	mov	r0, r1
	irq_unlock(key);

	while (likely(len--)) {
   1fda2:	4282      	cmp	r2, r0
   1fda4:	d119      	bne.n	1fdda <rng_pool_get+0x7a>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
   1fda6:	4576      	cmp	r6, lr
   1fda8:	d10d      	bne.n	1fdc6 <rng_pool_get+0x66>
	__asm__ volatile(
   1fdaa:	f04f 0520 	mov.w	r5, #32
   1fdae:	f3ef 8211 	mrs	r2, BASEPRI
   1fdb2:	f385 8811 	msr	BASEPRI, r5
   1fdb6:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
   1fdba:	781d      	ldrb	r5, [r3, #0]
   1fdbc:	705d      	strb	r5, [r3, #1]
	__asm__ volatile(
   1fdbe:	f382 8811 	msr	BASEPRI, r2
   1fdc2:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
   1fdc6:	1a41      	subs	r1, r0, r1
	available = available - len;
	if (available <= rngp->threshold) {
   1fdc8:	791b      	ldrb	r3, [r3, #4]
	len = dst - buf;
   1fdca:	b288      	uxth	r0, r1
	available = available - len;
   1fdcc:	1a21      	subs	r1, r4, r0
	if (available <= rngp->threshold) {
   1fdce:	428b      	cmp	r3, r1
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)rng_task);
}

NRF_STATIC_INLINE void nrf_rng_task_trigger(NRF_RNG_Type * p_reg, nrf_rng_task_t rng_task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   1fdd0:	bf22      	ittt	cs
   1fdd2:	4b06      	ldrcs	r3, [pc, #24]	; (1fdec <rng_pool_get+0x8c>)
   1fdd4:	2201      	movcs	r2, #1
   1fdd6:	601a      	strcs	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
   1fdd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
   1fdda:	eb03 0c05 	add.w	ip, r3, r5
		first = (first + 1) & mask;
   1fdde:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
   1fde0:	f89c c005 	ldrb.w	ip, [ip, #5]
   1fde4:	f800 cb01 	strb.w	ip, [r0], #1
		first = (first + 1) & mask;
   1fde8:	403d      	ands	r5, r7
   1fdea:	e7da      	b.n	1fda2 <rng_pool_get+0x42>
   1fdec:	4000d000 	.word	0x4000d000

0001fdf0 <entropy_nrf5_get_entropy>:
		k_sem_give(&entropy_nrf5_data.sem_sync);
	}
}

static int entropy_nrf5_get_entropy(struct device *device, u8_t *buf, u16_t len)
{
   1fdf0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(device));
   1fdf4:	4b18      	ldr	r3, [pc, #96]	; (1fe58 <entropy_nrf5_get_entropy+0x68>)
{
   1fdf6:	4614      	mov	r4, r2
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(device));
   1fdf8:	6882      	ldr	r2, [r0, #8]
   1fdfa:	429a      	cmp	r2, r3
{
   1fdfc:	4689      	mov	r9, r1
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(device));
   1fdfe:	d009      	beq.n	1fe14 <entropy_nrf5_get_entropy+0x24>
   1fe00:	4916      	ldr	r1, [pc, #88]	; (1fe5c <entropy_nrf5_get_entropy+0x6c>)
   1fe02:	4817      	ldr	r0, [pc, #92]	; (1fe60 <entropy_nrf5_get_entropy+0x70>)
   1fe04:	4a17      	ldr	r2, [pc, #92]	; (1fe64 <entropy_nrf5_get_entropy+0x74>)
   1fe06:	23e4      	movs	r3, #228	; 0xe4
   1fe08:	f004 f86b 	bl	23ee2 <printk>
   1fe0c:	4815      	ldr	r0, [pc, #84]	; (1fe64 <entropy_nrf5_get_entropy+0x74>)
   1fe0e:	21e4      	movs	r1, #228	; 0xe4
   1fe10:	f004 f8aa 	bl	23f68 <assert_post_action>
	return z_impl_k_sem_take(sem, timeout);
   1fe14:	4e10      	ldr	r6, [pc, #64]	; (1fe58 <entropy_nrf5_get_entropy+0x68>)

	while (len) {
		u16_t bytes;

		k_sem_take(&entropy_nrf5_data.sem_lock, K_FOREVER);
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   1fe16:	f106 0745 	add.w	r7, r6, #69	; 0x45
   1fe1a:	f106 0818 	add.w	r8, r6, #24
	while (len) {
   1fe1e:	b914      	cbnz	r4, 1fe26 <entropy_nrf5_get_entropy+0x36>
		len -= bytes;
		buf += bytes;
	}

	return 0;
}
   1fe20:	4620      	mov	r0, r4
   1fe22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1fe26:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1fe2a:	4630      	mov	r0, r6
   1fe2c:	f002 fc84 	bl	22738 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   1fe30:	4622      	mov	r2, r4
   1fe32:	4649      	mov	r1, r9
   1fe34:	4638      	mov	r0, r7
   1fe36:	f7ff ff93 	bl	1fd60 <rng_pool_get>
   1fe3a:	4605      	mov	r5, r0
	z_impl_k_sem_give(sem);
   1fe3c:	4630      	mov	r0, r6
   1fe3e:	f002 fc37 	bl	226b0 <z_impl_k_sem_give>
		if (bytes == 0U) {
   1fe42:	b92d      	cbnz	r5, 1fe50 <entropy_nrf5_get_entropy+0x60>
	return z_impl_k_sem_take(sem, timeout);
   1fe44:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1fe48:	4640      	mov	r0, r8
   1fe4a:	f002 fc75 	bl	22738 <z_impl_k_sem_take>
			continue;
   1fe4e:	e7e6      	b.n	1fe1e <entropy_nrf5_get_entropy+0x2e>
		len -= bytes;
   1fe50:	1b64      	subs	r4, r4, r5
   1fe52:	b2a4      	uxth	r4, r4
		buf += bytes;
   1fe54:	44a9      	add	r9, r5
   1fe56:	e7e2      	b.n	1fe1e <entropy_nrf5_get_entropy+0x2e>
   1fe58:	20001bf8 	.word	0x20001bf8
   1fe5c:	00030f82 	.word	0x00030f82
   1fe60:	0002a5e8 	.word	0x0002a5e8
   1fe64:	00030f50 	.word	0x00030f50

0001fe68 <random_byte_get>:
{
   1fe68:	b082      	sub	sp, #8
	__asm__ volatile(
   1fe6a:	f04f 0320 	mov.w	r3, #32
   1fe6e:	f3ef 8211 	mrs	r2, BASEPRI
   1fe72:	f383 8811 	msr	BASEPRI, r3
   1fe76:	f3bf 8f6f 	isb	sy
#endif
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   1fe7a:	4b0a      	ldr	r3, [pc, #40]	; (1fea4 <random_byte_get+0x3c>)
   1fe7c:	6819      	ldr	r1, [r3, #0]
	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
   1fe7e:	b171      	cbz	r1, 1fe9e <random_byte_get+0x36>
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
   1fe80:	4909      	ldr	r1, [pc, #36]	; (1fea8 <random_byte_get+0x40>)
   1fe82:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   1fe86:	2100      	movs	r1, #0
   1fe88:	6019      	str	r1, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   1fe8a:	681b      	ldr	r3, [r3, #0]
   1fe8c:	9301      	str	r3, [sp, #4]
    (void)dummy;
   1fe8e:	9b01      	ldr	r3, [sp, #4]
		retval = nrf_rng_random_value_get(NRF_RNG);
   1fe90:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
   1fe92:	f382 8811 	msr	BASEPRI, r2
   1fe96:	f3bf 8f6f 	isb	sy
}
   1fe9a:	b002      	add	sp, #8
   1fe9c:	4770      	bx	lr
	int retval = -EAGAIN;
   1fe9e:	f06f 000a 	mvn.w	r0, #10
   1fea2:	e7f6      	b.n	1fe92 <random_byte_get+0x2a>
   1fea4:	4000d100 	.word	0x4000d100
   1fea8:	4000d000 	.word	0x4000d000

0001feac <entropy_nrf5_get_entropy_isr>:

static int entropy_nrf5_get_entropy_isr(struct device *dev, u8_t *buf, u16_t len,
					u32_t flags)
{
   1feac:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1feb0:	4614      	mov	r4, r2
   1feb2:	461d      	mov	r5, r3
	u16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));
   1feb4:	6882      	ldr	r2, [r0, #8]
   1feb6:	4b2b      	ldr	r3, [pc, #172]	; (1ff64 <entropy_nrf5_get_entropy_isr+0xb8>)
   1feb8:	429a      	cmp	r2, r3
{
   1feba:	460e      	mov	r6, r1
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));
   1febc:	d00b      	beq.n	1fed6 <entropy_nrf5_get_entropy_isr+0x2a>
   1febe:	492a      	ldr	r1, [pc, #168]	; (1ff68 <entropy_nrf5_get_entropy_isr+0xbc>)
   1fec0:	482a      	ldr	r0, [pc, #168]	; (1ff6c <entropy_nrf5_get_entropy_isr+0xc0>)
   1fec2:	4a2b      	ldr	r2, [pc, #172]	; (1ff70 <entropy_nrf5_get_entropy_isr+0xc4>)
   1fec4:	f240 1301 	movw	r3, #257	; 0x101
   1fec8:	f004 f80b 	bl	23ee2 <printk>
   1fecc:	4828      	ldr	r0, [pc, #160]	; (1ff70 <entropy_nrf5_get_entropy_isr+0xc4>)
   1fece:	f240 1101 	movw	r1, #257	; 0x101
   1fed2:	f004 f849 	bl	23f68 <assert_post_action>

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   1fed6:	43eb      	mvns	r3, r5
   1fed8:	f013 0501 	ands.w	r5, r3, #1
   1fedc:	d007      	beq.n	1feee <entropy_nrf5_get_entropy_isr+0x42>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
   1fede:	4825      	ldr	r0, [pc, #148]	; (1ff74 <entropy_nrf5_get_entropy_isr+0xc8>)
   1fee0:	4622      	mov	r2, r4
   1fee2:	4631      	mov	r1, r6
   1fee4:	f7ff ff3c 	bl	1fd60 <rng_pool_get>
			irq_enable(RNG_IRQn);
		}
	}

	return cnt;
}
   1fee8:	b002      	add	sp, #8
   1feea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   1feee:	2c00      	cmp	r4, #0
   1fef0:	d032      	beq.n	1ff58 <entropy_nrf5_get_entropy_isr+0xac>
	__asm__ volatile(
   1fef2:	f04f 0320 	mov.w	r3, #32
   1fef6:	f3ef 8711 	mrs	r7, BASEPRI
   1fefa:	f383 8811 	msr	BASEPRI, r3
   1fefe:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(RNG_IRQn);
   1ff02:	200d      	movs	r0, #13
   1ff04:	f7e4 fd4c 	bl	49a0 <arch_irq_is_enabled>
   1ff08:	4680      	mov	r8, r0
		irq_disable(RNG_IRQn);
   1ff0a:	200d      	movs	r0, #13
   1ff0c:	f7e4 fd34 	bl	4978 <arch_irq_disable>
	__asm__ volatile(
   1ff10:	f387 8811 	msr	BASEPRI, r7
   1ff14:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   1ff18:	4f17      	ldr	r7, [pc, #92]	; (1ff78 <entropy_nrf5_get_entropy_isr+0xcc>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1ff1a:	f8df 9064 	ldr.w	r9, [pc, #100]	; 1ff80 <entropy_nrf5_get_entropy_isr+0xd4>
   1ff1e:	603d      	str	r5, [r7, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   1ff20:	683a      	ldr	r2, [r7, #0]
   1ff22:	9201      	str	r2, [sp, #4]
    (void)dummy;
   1ff24:	9a01      	ldr	r2, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   1ff26:	4a15      	ldr	r2, [pc, #84]	; (1ff7c <entropy_nrf5_get_entropy_isr+0xd0>)
   1ff28:	2101      	movs	r1, #1
   1ff2a:	6011      	str	r1, [r2, #0]
}
   1ff2c:	4625      	mov	r5, r4
   1ff2e:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   1ff32:	683b      	ldr	r3, [r7, #0]
			while (!nrf_rng_event_check(NRF_RNG,
   1ff34:	b193      	cbz	r3, 1ff5c <entropy_nrf5_get_entropy_isr+0xb0>
			byte = random_byte_get();
   1ff36:	f7ff ff97 	bl	1fe68 <random_byte_get>
			if (byte < 0) {
   1ff3a:	2800      	cmp	r0, #0
   1ff3c:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
   1ff40:	dbf7      	blt.n	1ff32 <entropy_nrf5_get_entropy_isr+0x86>
   1ff42:	3d01      	subs	r5, #1
   1ff44:	b2ad      	uxth	r5, r5
			buf[--len] = byte;
   1ff46:	5570      	strb	r0, [r6, r5]
		} while (len);
   1ff48:	2d00      	cmp	r5, #0
   1ff4a:	d1f2      	bne.n	1ff32 <entropy_nrf5_get_entropy_isr+0x86>
		if (irq_enabled) {
   1ff4c:	f1b8 0f00 	cmp.w	r8, #0
   1ff50:	d002      	beq.n	1ff58 <entropy_nrf5_get_entropy_isr+0xac>
			irq_enable(RNG_IRQn);
   1ff52:	200d      	movs	r0, #13
   1ff54:	f7e4 fd00 	bl	4958 <arch_irq_enable>
	return cnt;
   1ff58:	4620      	mov	r0, r4
   1ff5a:	e7c5      	b.n	1fee8 <entropy_nrf5_get_entropy_isr+0x3c>
				__WFE();
   1ff5c:	bf20      	wfe
				__SEV();
   1ff5e:	bf40      	sev
				__WFE();
   1ff60:	bf20      	wfe
   1ff62:	e7e6      	b.n	1ff32 <entropy_nrf5_get_entropy_isr+0x86>
   1ff64:	20001bf8 	.word	0x20001bf8
   1ff68:	00030fd0 	.word	0x00030fd0
   1ff6c:	0002a5e8 	.word	0x0002a5e8
   1ff70:	00030f50 	.word	0x00030f50
   1ff74:	20001c28 	.word	0x20001c28
   1ff78:	4000d100 	.word	0x4000d100
   1ff7c:	4000d000 	.word	0x4000d000
   1ff80:	e000e100 	.word	0xe000e100

0001ff84 <entropy_nrf5_init>:
		    entropy_nrf5_init, &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(struct device *device)
{
   1ff84:	b537      	push	{r0, r1, r2, r4, r5, lr}
	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(device));
   1ff86:	6883      	ldr	r3, [r0, #8]
   1ff88:	4c21      	ldr	r4, [pc, #132]	; (20010 <entropy_nrf5_init+0x8c>)
   1ff8a:	42a3      	cmp	r3, r4
   1ff8c:	d00b      	beq.n	1ffa6 <entropy_nrf5_init+0x22>
   1ff8e:	4921      	ldr	r1, [pc, #132]	; (20014 <entropy_nrf5_init+0x90>)
   1ff90:	4821      	ldr	r0, [pc, #132]	; (20018 <entropy_nrf5_init+0x94>)
   1ff92:	4a22      	ldr	r2, [pc, #136]	; (2001c <entropy_nrf5_init+0x98>)
   1ff94:	f240 133f 	movw	r3, #319	; 0x13f
   1ff98:	f003 ffa3 	bl	23ee2 <printk>
   1ff9c:	481f      	ldr	r0, [pc, #124]	; (2001c <entropy_nrf5_init+0x98>)
   1ff9e:	f240 113f 	movw	r1, #319	; 0x13f
   1ffa2:	f003 ffe1 	bl	23f68 <assert_post_action>
	return z_impl_k_sem_init(sem, initial_count, limit);
   1ffa6:	2201      	movs	r2, #1
   1ffa8:	4611      	mov	r1, r2
   1ffaa:	4819      	ldr	r0, [pc, #100]	; (20010 <entropy_nrf5_init+0x8c>)
   1ffac:	f009 f994 	bl	292d8 <z_impl_k_sem_init>
   1ffb0:	2201      	movs	r2, #1
   1ffb2:	2100      	movs	r1, #0
   1ffb4:	481a      	ldr	r0, [pc, #104]	; (20020 <entropy_nrf5_init+0x9c>)
   1ffb6:	f009 f98f 	bl	292d8 <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
   1ffba:	f240 4307 	movw	r3, #1031	; 0x407
   1ffbe:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
   1ffc2:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   1ffc6:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
   1ffc8:	230c      	movs	r3, #12
   1ffca:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
   1ffce:	2500      	movs	r5, #0
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
   1ffd0:	4b14      	ldr	r3, [pc, #80]	; (20024 <entropy_nrf5_init+0xa0>)
   1ffd2:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
   1ffd6:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
   1ffda:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   1ffde:	f042 0201 	orr.w	r2, r2, #1
   1ffe2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   1ffe6:	4a10      	ldr	r2, [pc, #64]	; (20028 <entropy_nrf5_init+0xa4>)
   1ffe8:	6015      	str	r5, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   1ffea:	6812      	ldr	r2, [r2, #0]
   1ffec:	9201      	str	r2, [sp, #4]
    (void)dummy;
   1ffee:	9a01      	ldr	r2, [sp, #4]
    p_reg->INTENSET = mask;
   1fff0:	2201      	movs	r2, #1
   1fff2:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(RNG_IRQn, CONFIG_ENTROPY_NRF5_PRI, isr,
   1fff6:	2105      	movs	r1, #5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   1fff8:	601a      	str	r2, [r3, #0]
   1fffa:	200d      	movs	r0, #13
   1fffc:	462a      	mov	r2, r5
   1fffe:	f7e4 fcdd 	bl	49bc <z_arm_irq_priority_set>
		    &entropy_nrf5_data, 0);
	irq_enable(RNG_IRQn);
   20002:	200d      	movs	r0, #13
   20004:	f7e4 fca8 	bl	4958 <arch_irq_enable>

	return 0;
}
   20008:	4628      	mov	r0, r5
   2000a:	b003      	add	sp, #12
   2000c:	bd30      	pop	{r4, r5, pc}
   2000e:	bf00      	nop
   20010:	20001bf8 	.word	0x20001bf8
   20014:	00030f82 	.word	0x00030f82
   20018:	0002a5e8 	.word	0x0002a5e8
   2001c:	00030f50 	.word	0x00030f50
   20020:	20001c10 	.word	0x20001c10
   20024:	4000d000 	.word	0x4000d000
   20028:	4000d100 	.word	0x4000d100

0002002c <isr>:
{
   2002c:	b510      	push	{r4, lr}
	byte = random_byte_get();
   2002e:	f7ff ff1b 	bl	1fe68 <random_byte_get>
	if (byte < 0) {
   20032:	2800      	cmp	r0, #0
   20034:	db20      	blt.n	20078 <isr+0x4c>
	u8_t last  = rngp->last;
   20036:	4b17      	ldr	r3, [pc, #92]	; (20094 <isr+0x68>)
   20038:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
   2003c:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	u8_t mask  = rngp->mask;
   20040:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
   20044:	1a51      	subs	r1, r2, r1
   20046:	ea34 0101 	bics.w	r1, r4, r1
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
   2004a:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
   2004c:	d10d      	bne.n	2006a <isr+0x3e>
	u8_t last  = rngp->last;
   2004e:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
   20052:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	u8_t mask  = rngp->mask;
   20056:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
   2005a:	1a51      	subs	r1, r2, r1
   2005c:	ea34 0101 	bics.w	r1, r4, r1
   20060:	d10b      	bne.n	2007a <isr+0x4e>
   20062:	4b0d      	ldr	r3, [pc, #52]	; (20098 <isr+0x6c>)
   20064:	2201      	movs	r2, #1
   20066:	601a      	str	r2, [r3, #0]
}
   20068:	e00e      	b.n	20088 <isr+0x5c>
	rngp->buffer[last] = byte;
   2006a:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   2006c:	3201      	adds	r2, #1
   2006e:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   20070:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
   20074:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
   20078:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
   2007a:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   2007c:	3201      	adds	r2, #1
   2007e:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   20080:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
   20084:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
   20088:	4804      	ldr	r0, [pc, #16]	; (2009c <isr+0x70>)
}
   2008a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2008e:	f002 bb0f 	b.w	226b0 <z_impl_k_sem_give>
   20092:	bf00      	nop
   20094:	20001bf8 	.word	0x20001bf8
   20098:	4000d004 	.word	0x4000d004
   2009c:	20001c10 	.word	0x20001c10

000200a0 <nrf52_errata_136>:
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   200a0:	4b0a      	ldr	r3, [pc, #40]	; (200cc <nrf52_errata_136+0x2c>)
   200a2:	681b      	ldr	r3, [r3, #0]
   200a4:	1c5a      	adds	r2, r3, #1
            {
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   200a6:	bf05      	ittet	eq
   200a8:	4b09      	ldreq	r3, [pc, #36]	; (200d0 <nrf52_errata_136+0x30>)
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   200aa:	4a0a      	ldreq	r2, [pc, #40]	; (200d4 <nrf52_errata_136+0x34>)
            }
            else
            {
                var1 = *(uint32_t *)0x10000130ul;
                var2 = *(uint32_t *)0x10000134ul;
   200ac:	4a0a      	ldrne	r2, [pc, #40]	; (200d8 <nrf52_errata_136+0x38>)
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   200ae:	6810      	ldreq	r0, [r2, #0]
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   200b0:	bf0a      	itet	eq
   200b2:	781b      	ldrbeq	r3, [r3, #0]
                var2 = *(uint32_t *)0x10000134ul;
   200b4:	6810      	ldrne	r0, [r2, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   200b6:	f3c0 1003 	ubfxeq	r0, r0, #4, #4
                        return true;
                }
            }
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
   200ba:	2b08      	cmp	r3, #8
   200bc:	d104      	bne.n	200c8 <nrf52_errata_136+0x28>
            {
                switch(var2)
   200be:	2803      	cmp	r0, #3
   200c0:	bf8c      	ite	hi
   200c2:	2000      	movhi	r0, #0
   200c4:	2001      	movls	r0, #1
   200c6:	4770      	bx	lr
                    case 0x00ul:
                        return true;
                }
            }
        #endif
        return false;
   200c8:	2000      	movs	r0, #0
    #endif
}
   200ca:	4770      	bx	lr
   200cc:	10000130 	.word	0x10000130
   200d0:	f0000fe0 	.word	0xf0000fe0
   200d4:	f0000fe8 	.word	0xf0000fe8
   200d8:	10000134 	.word	0x10000134

000200dc <nrf52_errata_103>:
{
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   200dc:	4b06      	ldr	r3, [pc, #24]	; (200f8 <nrf52_errata_103+0x1c>)
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
   200de:	681b      	ldr	r3, [r3, #0]
   200e0:	2b08      	cmp	r3, #8
   200e2:	d106      	bne.n	200f2 <nrf52_errata_103+0x16>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   200e4:	4b05      	ldr	r3, [pc, #20]	; (200fc <nrf52_errata_103+0x20>)
   200e6:	681b      	ldr	r3, [r3, #0]
            {
                switch(var2)
   200e8:	2b03      	cmp	r3, #3
   200ea:	d802      	bhi.n	200f2 <nrf52_errata_103+0x16>
   200ec:	4a04      	ldr	r2, [pc, #16]	; (20100 <nrf52_errata_103+0x24>)
   200ee:	5cd0      	ldrb	r0, [r2, r3]
   200f0:	4770      	bx	lr
                    case 0x03ul:
                        return false;
                }
            }
        #endif
        return false;
   200f2:	2000      	movs	r0, #0
    #endif
}
   200f4:	4770      	bx	lr
   200f6:	bf00      	nop
   200f8:	10000130 	.word	0x10000130
   200fc:	10000134 	.word	0x10000134
   20100:	0003101b 	.word	0x0003101b

00020104 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
   20104:	b508      	push	{r3, lr}
        NRF_P1->PIN_CNF[9]  = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif
    
    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_36()){
   20106:	f7ff ffcb 	bl	200a0 <nrf52_errata_136>
   2010a:	b140      	cbz	r0, 2011e <SystemInit+0x1a>
        NRF_CLOCK->EVENTS_DONE = 0;
   2010c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   20110:	2200      	movs	r2, #0
   20112:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
   20116:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
   2011a:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }
    
    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_66()){
   2011e:	f7ff ffbf 	bl	200a0 <nrf52_errata_136>
   20122:	2800      	cmp	r0, #0
   20124:	d046      	beq.n	201b4 <SystemInit+0xb0>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   20126:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2012a:	4b58      	ldr	r3, [pc, #352]	; (2028c <SystemInit+0x188>)
   2012c:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
   20130:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   20134:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
   20138:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   2013c:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
   20140:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   20144:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
   20148:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   2014c:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
   20150:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   20154:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   20158:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   2015c:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
   20160:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   20164:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
   20168:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   2016c:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
   20170:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   20174:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
   20178:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   2017c:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
   20180:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   20184:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
   20188:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   2018c:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
   20190:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   20194:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
   20198:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   2019c:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
   201a0:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   201a4:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
   201a8:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   201ac:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
   201b0:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    }
    
    /* Workaround for Errata 98 "NFCT: Not able to communicate with the peer" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_98()){
   201b4:	f7ff ff92 	bl	200dc <nrf52_errata_103>
   201b8:	b110      	cbz	r0, 201c0 <SystemInit+0xbc>
        *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
   201ba:	4b35      	ldr	r3, [pc, #212]	; (20290 <SystemInit+0x18c>)
   201bc:	4a35      	ldr	r2, [pc, #212]	; (20294 <SystemInit+0x190>)
   201be:	601a      	str	r2, [r3, #0]
    }
    
    /* Workaround for Errata 103 "CCM: Wrong reset value of CCM MAXPACKETSIZE" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_103()){
   201c0:	f7ff ff8c 	bl	200dc <nrf52_errata_103>
   201c4:	b118      	cbz	r0, 201ce <SystemInit+0xca>
        NRF_CCM->MAXPACKETSIZE = 0xFBul;
   201c6:	4b34      	ldr	r3, [pc, #208]	; (20298 <SystemInit+0x194>)
   201c8:	22fb      	movs	r2, #251	; 0xfb
   201ca:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    }
    
    /* Workaround for Errata 115 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_115()){
   201ce:	f7ff ff85 	bl	200dc <nrf52_errata_103>
   201d2:	b148      	cbz	r0, 201e8 <SystemInit+0xe4>
        *(volatile uint32_t *)0x40000EE4ul = (*(volatile uint32_t *)0x40000EE4ul & 0xFFFFFFF0ul) | (*(uint32_t *)0x10000258ul & 0x0000000Ful);
   201d4:	4931      	ldr	r1, [pc, #196]	; (2029c <SystemInit+0x198>)
   201d6:	4b32      	ldr	r3, [pc, #200]	; (202a0 <SystemInit+0x19c>)
   201d8:	680a      	ldr	r2, [r1, #0]
   201da:	681b      	ldr	r3, [r3, #0]
   201dc:	f022 020f 	bic.w	r2, r2, #15
   201e0:	f003 030f 	and.w	r3, r3, #15
   201e4:	4313      	orrs	r3, r2
   201e6:	600b      	str	r3, [r1, #0]
    }
    
    /* Workaround for Errata 120 "QSPI: Data read or written is corrupted" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_120()){
   201e8:	f7ff ff78 	bl	200dc <nrf52_errata_103>
   201ec:	b118      	cbz	r0, 201f6 <SystemInit+0xf2>
        *(volatile uint32_t *)0x40029640ul = 0x200ul;
   201ee:	4b2d      	ldr	r3, [pc, #180]	; (202a4 <SystemInit+0x1a0>)
   201f0:	f44f 7200 	mov.w	r2, #512	; 0x200
   201f4:	601a      	str	r2, [r3, #0]
    }
    
    /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf52_errata_136()){
   201f6:	f7ff ff53 	bl	200a0 <nrf52_errata_136>
   201fa:	b148      	cbz	r0, 20210 <SystemInit+0x10c>
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
   201fc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   20200:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   20204:	07d2      	lsls	r2, r2, #31
            NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
   20206:	bf44      	itt	mi
   20208:	f06f 0201 	mvnmi.w	r2, #1
   2020c:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   20210:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   20214:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   20218:	2a00      	cmp	r2, #0
   2021a:	db03      	blt.n	20224 <SystemInit+0x120>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
   2021c:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   20220:	2b00      	cmp	r3, #0
   20222:	da2f      	bge.n	20284 <SystemInit+0x180>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
   20224:	4b20      	ldr	r3, [pc, #128]	; (202a8 <SystemInit+0x1a4>)
   20226:	2201      	movs	r2, #1
   20228:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   2022c:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   20230:	2a00      	cmp	r2, #0
   20232:	d0fb      	beq.n	2022c <SystemInit+0x128>
            NRF_UICR->PSELRESET[0] = 18;
   20234:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
   20238:	2112      	movs	r1, #18
   2023a:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   2023e:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   20242:	2a00      	cmp	r2, #0
   20244:	d0fb      	beq.n	2023e <SystemInit+0x13a>
            NRF_UICR->PSELRESET[1] = 18;
   20246:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   2024a:	2212      	movs	r2, #18
   2024c:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   20250:	4b15      	ldr	r3, [pc, #84]	; (202a8 <SystemInit+0x1a4>)
   20252:	461a      	mov	r2, r3
   20254:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
   20258:	2900      	cmp	r1, #0
   2025a:	d0fb      	beq.n	20254 <SystemInit+0x150>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
   2025c:	2100      	movs	r1, #0
   2025e:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   20262:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
   20266:	2b00      	cmp	r3, #0
   20268:	d0fb      	beq.n	20262 <SystemInit+0x15e>
   2026a:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   2026e:	490f      	ldr	r1, [pc, #60]	; (202ac <SystemInit+0x1a8>)
   20270:	4b0f      	ldr	r3, [pc, #60]	; (202b0 <SystemInit+0x1ac>)
   20272:	68ca      	ldr	r2, [r1, #12]
   20274:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   20278:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   2027a:	60cb      	str	r3, [r1, #12]
   2027c:	f3bf 8f4f 	dsb	sy
    __NOP();
   20280:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   20282:	e7fd      	b.n	20280 <SystemInit+0x17c>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   20284:	4b0b      	ldr	r3, [pc, #44]	; (202b4 <SystemInit+0x1b0>)
   20286:	4a0c      	ldr	r2, [pc, #48]	; (202b8 <SystemInit+0x1b4>)
   20288:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
   2028a:	bd08      	pop	{r3, pc}
   2028c:	4000c000 	.word	0x4000c000
   20290:	4000568c 	.word	0x4000568c
   20294:	00038148 	.word	0x00038148
   20298:	4000f000 	.word	0x4000f000
   2029c:	40000ee4 	.word	0x40000ee4
   202a0:	10000258 	.word	0x10000258
   202a4:	40029640 	.word	0x40029640
   202a8:	4001e000 	.word	0x4001e000
   202ac:	e000ed00 	.word	0xe000ed00
   202b0:	05fa0004 	.word	0x05fa0004
   202b4:	200073cc 	.word	0x200073cc
   202b8:	03d09000 	.word	0x03d09000

000202bc <nrfx_nvmc_page_erase>:
        nvmc_word_write(addr + (NVMC_BYTES_IN_WORD * i), ((uint32_t const *)src)[i]);
    }
}

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
   202bc:	b510      	push	{r4, lr}
   202be:	4604      	mov	r4, r0
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   202c0:	f008 ff5c 	bl	2917c <flash_total_size_get>
   202c4:	42a0      	cmp	r0, r4
   202c6:	d809      	bhi.n	202dc <nrfx_nvmc_page_erase+0x20>
   202c8:	4911      	ldr	r1, [pc, #68]	; (20310 <nrfx_nvmc_page_erase+0x54>)
   202ca:	4812      	ldr	r0, [pc, #72]	; (20314 <nrfx_nvmc_page_erase+0x58>)
   202cc:	4a12      	ldr	r2, [pc, #72]	; (20318 <nrfx_nvmc_page_erase+0x5c>)
   202ce:	23dd      	movs	r3, #221	; 0xdd
   202d0:	f003 fe07 	bl	23ee2 <printk>
   202d4:	4810      	ldr	r0, [pc, #64]	; (20318 <nrfx_nvmc_page_erase+0x5c>)
   202d6:	21dd      	movs	r1, #221	; 0xdd
   202d8:	f003 fe46 	bl	23f68 <assert_post_action>
NRF_STATIC_INLINE uint32_t nrf_ficr_codepagesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)
    return p_reg->INFO.CODEPAGESIZE;
#else
    return p_reg->CODEPAGESIZE;
   202dc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   202e0:	691a      	ldr	r2, [r3, #16]
    return !(addr % flash_page_size_get());
   202e2:	fbb4 f3f2 	udiv	r3, r4, r2
   202e6:	fb02 4313 	mls	r3, r2, r3, r4

    if (!is_page_aligned_check(addr))
   202ea:	b973      	cbnz	r3, 2030a <nrfx_nvmc_page_erase+0x4e>
#endif

NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
                                         nrf_nvmc_mode_t mode)
{
    p_reg->CONFIG = (uint32_t)mode;
   202ec:	4b0b      	ldr	r3, [pc, #44]	; (2031c <nrfx_nvmc_page_erase+0x60>)
   202ee:	2202      	movs	r2, #2
   202f0:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    else
    {
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
   202f4:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   202f8:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   202fc:	07d2      	lsls	r2, r2, #31
   202fe:	d5fb      	bpl.n	202f8 <nrfx_nvmc_page_erase+0x3c>
    p_reg->CONFIG = (uint32_t)mode;
   20300:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
   20302:	4807      	ldr	r0, [pc, #28]	; (20320 <nrfx_nvmc_page_erase+0x64>)
   20304:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   20308:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_ADDR;
   2030a:	4806      	ldr	r0, [pc, #24]	; (20324 <nrfx_nvmc_page_erase+0x68>)
   2030c:	e7fc      	b.n	20308 <nrfx_nvmc_page_erase+0x4c>
   2030e:	bf00      	nop
   20310:	0003107b 	.word	0x0003107b
   20314:	0002a5e8 	.word	0x0002a5e8
   20318:	0003101f 	.word	0x0003101f
   2031c:	4001e000 	.word	0x4001e000
   20320:	0bad0000 	.word	0x0bad0000
   20324:	0bad000a 	.word	0x0bad000a

00020328 <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, &value, 1));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
   20328:	b538      	push	{r3, r4, r5, lr}
   2032a:	4604      	mov	r4, r0
   2032c:	460d      	mov	r5, r1
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   2032e:	f008 ff25 	bl	2917c <flash_total_size_get>
   20332:	42a0      	cmp	r0, r4
   20334:	d80b      	bhi.n	2034e <nrfx_nvmc_word_write+0x26>
   20336:	4914      	ldr	r1, [pc, #80]	; (20388 <nrfx_nvmc_word_write+0x60>)
   20338:	4814      	ldr	r0, [pc, #80]	; (2038c <nrfx_nvmc_word_write+0x64>)
   2033a:	4a15      	ldr	r2, [pc, #84]	; (20390 <nrfx_nvmc_word_write+0x68>)
   2033c:	f240 134d 	movw	r3, #333	; 0x14d
   20340:	f003 fdcf 	bl	23ee2 <printk>
   20344:	4812      	ldr	r0, [pc, #72]	; (20390 <nrfx_nvmc_word_write+0x68>)
   20346:	f240 114d 	movw	r1, #333	; 0x14d
   2034a:	f003 fe0d 	bl	23f68 <assert_post_action>
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));
   2034e:	07a1      	lsls	r1, r4, #30
   20350:	d00b      	beq.n	2036a <nrfx_nvmc_word_write+0x42>
   20352:	4910      	ldr	r1, [pc, #64]	; (20394 <nrfx_nvmc_word_write+0x6c>)
   20354:	480d      	ldr	r0, [pc, #52]	; (2038c <nrfx_nvmc_word_write+0x64>)
   20356:	4a0e      	ldr	r2, [pc, #56]	; (20390 <nrfx_nvmc_word_write+0x68>)
   20358:	f44f 73a7 	mov.w	r3, #334	; 0x14e
   2035c:	f003 fdc1 	bl	23ee2 <printk>
   20360:	480b      	ldr	r0, [pc, #44]	; (20390 <nrfx_nvmc_word_write+0x68>)
   20362:	f44f 71a7 	mov.w	r1, #334	; 0x14e
   20366:	f003 fdff 	bl	23f68 <assert_post_action>
   2036a:	4b0b      	ldr	r3, [pc, #44]	; (20398 <nrfx_nvmc_word_write+0x70>)
   2036c:	2201      	movs	r2, #1
   2036e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   20372:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   20376:	07d2      	lsls	r2, r2, #31
   20378:	d5fb      	bpl.n	20372 <nrfx_nvmc_word_write+0x4a>
    *(volatile uint32_t *)addr = value;
   2037a:	6025      	str	r5, [r4, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   2037c:	f3bf 8f5f 	dmb	sy
    p_reg->CONFIG = (uint32_t)mode;
   20380:	2200      	movs	r2, #0
   20382:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    nvmc_write_mode_set();

    nvmc_word_write(addr, value);

    nvmc_readonly_mode_set();
}
   20386:	bd38      	pop	{r3, r4, r5, pc}
   20388:	0003107b 	.word	0x0003107b
   2038c:	0002a5e8 	.word	0x0002a5e8
   20390:	0003101f 	.word	0x0003101f
   20394:	0003109f 	.word	0x0003109f
   20398:	4001e000 	.word	0x4001e000

0002039c <z_sys_device_do_config_level>:
#endif
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
   2039c:	4b09      	ldr	r3, [pc, #36]	; (203c4 <z_sys_device_do_config_level+0x28>)
{
   2039e:	b570      	push	{r4, r5, r6, lr}
	for (info = config_levels[level]; info < config_levels[level+1];
   203a0:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   203a4:	3001      	adds	r0, #1
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
   203a6:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
   203a8:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   203ac:	42a5      	cmp	r5, r4
   203ae:	d800      	bhi.n	203b2 <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
   203b0:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
   203b2:	6823      	ldr	r3, [r4, #0]
   203b4:	4620      	mov	r0, r4
   203b6:	685b      	ldr	r3, [r3, #4]
   203b8:	4798      	blx	r3
		if (retval != 0) {
   203ba:	b100      	cbz	r0, 203be <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
   203bc:	6066      	str	r6, [r4, #4]
								info++) {
   203be:	340c      	adds	r4, #12
   203c0:	e7f4      	b.n	203ac <z_sys_device_do_config_level+0x10>
   203c2:	bf00      	nop
   203c4:	0002a52c 	.word	0x0002a52c

000203c8 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   203c8:	4b10      	ldr	r3, [pc, #64]	; (2040c <z_impl_device_get_binding+0x44>)
{
   203ca:	b570      	push	{r4, r5, r6, lr}
	for (info = __device_init_start; info != __device_init_end; info++) {
   203cc:	4c10      	ldr	r4, [pc, #64]	; (20410 <z_impl_device_get_binding+0x48>)
{
   203ce:	4605      	mov	r5, r0
   203d0:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
   203d2:	429c      	cmp	r4, r3
   203d4:	d104      	bne.n	203e0 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   203d6:	4c0e      	ldr	r4, [pc, #56]	; (20410 <z_impl_device_get_binding+0x48>)
   203d8:	42b4      	cmp	r4, r6
   203da:	d109      	bne.n	203f0 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
   203dc:	2400      	movs	r4, #0
   203de:	e012      	b.n	20406 <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
   203e0:	6862      	ldr	r2, [r4, #4]
   203e2:	b11a      	cbz	r2, 203ec <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
   203e4:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
   203e6:	6812      	ldr	r2, [r2, #0]
   203e8:	42aa      	cmp	r2, r5
   203ea:	d00c      	beq.n	20406 <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   203ec:	340c      	adds	r4, #12
   203ee:	e7f0      	b.n	203d2 <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
   203f0:	6863      	ldr	r3, [r4, #4]
   203f2:	b90b      	cbnz	r3, 203f8 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
   203f4:	340c      	adds	r4, #12
   203f6:	e7ef      	b.n	203d8 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
   203f8:	6823      	ldr	r3, [r4, #0]
   203fa:	4628      	mov	r0, r5
   203fc:	6819      	ldr	r1, [r3, #0]
   203fe:	f005 fc28 	bl	25c52 <strcmp>
   20402:	2800      	cmp	r0, #0
   20404:	d1f6      	bne.n	203f4 <z_impl_device_get_binding+0x2c>
}
   20406:	4620      	mov	r0, r4
   20408:	bd70      	pop	{r4, r5, r6, pc}
   2040a:	bf00      	nop
   2040c:	2000755c 	.word	0x2000755c
   20410:	2000749c 	.word	0x2000749c

00020414 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   20414:	4b01      	ldr	r3, [pc, #4]	; (2041c <z_impl_z_errno+0x8>)
   20416:	6898      	ldr	r0, [r3, #8]
}
   20418:	307c      	adds	r0, #124	; 0x7c
   2041a:	4770      	bx	lr
   2041c:	20001d80 	.word	0x20001d80

00020420 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   20420:	b510      	push	{r4, lr}
   20422:	4604      	mov	r4, r0
	z_impl_log_panic();
   20424:	f7e2 fa76 	bl	2914 <z_impl_log_panic>
   20428:	4b06      	ldr	r3, [pc, #24]	; (20444 <k_sys_fatal_error_handler+0x24>)
   2042a:	4907      	ldr	r1, [pc, #28]	; (20448 <k_sys_fatal_error_handler+0x28>)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
   2042c:	4807      	ldr	r0, [pc, #28]	; (2044c <k_sys_fatal_error_handler+0x2c>)
   2042e:	1ac9      	subs	r1, r1, r3
   20430:	08c9      	lsrs	r1, r1, #3
   20432:	0189      	lsls	r1, r1, #6
   20434:	f041 0101 	orr.w	r1, r1, #1
   20438:	f003 fdc4 	bl	23fc4 <log_0>
	arch_system_halt(reason);
   2043c:	4620      	mov	r0, r4
   2043e:	f008 fead 	bl	2919c <arch_system_halt>
   20442:	bf00      	nop
   20444:	00029830 	.word	0x00029830
   20448:	000299c8 	.word	0x000299c8
   2044c:	000310c8 	.word	0x000310c8

00020450 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   20450:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   20454:	4605      	mov	r5, r0
   20456:	460e      	mov	r6, r1
	__asm__ volatile(
   20458:	f04f 0320 	mov.w	r3, #32
   2045c:	f3ef 8811 	mrs	r8, BASEPRI
   20460:	f383 8811 	msr	BASEPRI, r3
   20464:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   20468:	f002 f91c 	bl	226a4 <z_impl_k_current_get>
   2046c:	4c28      	ldr	r4, [pc, #160]	; (20510 <z_fatal_error+0xc0>)
   2046e:	4b29      	ldr	r3, [pc, #164]	; (20514 <z_fatal_error+0xc4>)
   20470:	1ae4      	subs	r4, r4, r3
   20472:	2d04      	cmp	r5, #4
   20474:	ea4f 04d4 	mov.w	r4, r4, lsr #3
   20478:	bf96      	itet	ls
   2047a:	4a27      	ldrls	r2, [pc, #156]	; (20518 <z_fatal_error+0xc8>)
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   2047c:	4a27      	ldrhi	r2, [pc, #156]	; (2051c <z_fatal_error+0xcc>)
   2047e:	f852 2025 	ldrls.w	r2, [r2, r5, lsl #2]
   20482:	01a4      	lsls	r4, r4, #6
   20484:	f044 0301 	orr.w	r3, r4, #1
   20488:	4607      	mov	r7, r0
   2048a:	f8ad 3000 	strh.w	r3, [sp]
   2048e:	4824      	ldr	r0, [pc, #144]	; (20520 <z_fatal_error+0xd0>)
   20490:	2300      	movs	r3, #0
   20492:	4629      	mov	r1, r5
   20494:	f003 fdd0 	bl	24038 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   20498:	b146      	cbz	r6, 204ac <z_fatal_error+0x5c>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   2049a:	69f3      	ldr	r3, [r6, #28]
   2049c:	f3c3 0308 	ubfx	r3, r3, #0, #9
   204a0:	b123      	cbz	r3, 204ac <z_fatal_error+0x5c>
		LOG_ERR("Fault during interrupt handling\n");
   204a2:	4820      	ldr	r0, [pc, #128]	; (20524 <z_fatal_error+0xd4>)
   204a4:	f044 0101 	orr.w	r1, r4, #1
   204a8:	f003 fd8c 	bl	23fc4 <log_0>
	const char *thread_name = k_thread_name_get(thread);
   204ac:	4638      	mov	r0, r7
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   204ae:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = k_thread_name_get(thread);
   204b2:	f008 ff29 	bl	29308 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   204b6:	b1e0      	cbz	r0, 204f2 <z_fatal_error+0xa2>
   204b8:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
   204ba:	4b1b      	ldr	r3, [pc, #108]	; (20528 <z_fatal_error+0xd8>)
   204bc:	2a00      	cmp	r2, #0
   204be:	bf08      	it	eq
   204c0:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
   204c2:	f7e2 f88d 	bl	25e0 <log_strdup>
   204c6:	4639      	mov	r1, r7
   204c8:	4602      	mov	r2, r0
   204ca:	4623      	mov	r3, r4
   204cc:	4817      	ldr	r0, [pc, #92]	; (2052c <z_fatal_error+0xdc>)
   204ce:	f003 fd9a 	bl	24006 <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   204d2:	4631      	mov	r1, r6
   204d4:	4628      	mov	r0, r5
   204d6:	f7ff ffa3 	bl	20420 <k_sys_fatal_error_handler>
		}
#endif /* CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	} else {
		/* Test mode */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   204da:	b166      	cbz	r6, 204f6 <z_fatal_error+0xa6>
   204dc:	69f3      	ldr	r3, [r6, #28]
   204de:	f3c3 0308 	ubfx	r3, r3, #0, #9
   204e2:	b143      	cbz	r3, 204f6 <z_fatal_error+0xa6>
	__asm__ volatile(
   204e4:	f388 8811 	msr	BASEPRI, r8
   204e8:	f3bf 8f6f 	isb	sy
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
   204ec:	b002      	add	sp, #8
   204ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread_name = "unknown";
   204f2:	480d      	ldr	r0, [pc, #52]	; (20528 <z_fatal_error+0xd8>)
   204f4:	e7e5      	b.n	204c2 <z_fatal_error+0x72>
			if (reason == K_ERR_SPURIOUS_IRQ) {
   204f6:	2d01      	cmp	r5, #1
   204f8:	d0f4      	beq.n	204e4 <z_fatal_error+0x94>
   204fa:	f388 8811 	msr	BASEPRI, r8
   204fe:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   20502:	4638      	mov	r0, r7
}
   20504:	b002      	add	sp, #8
   20506:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2050a:	f7e4 be33 	b.w	5174 <z_impl_k_thread_abort>
   2050e:	bf00      	nop
   20510:	000299c8 	.word	0x000299c8
   20514:	00029830 	.word	0x00029830
   20518:	0002a544 	.word	0x0002a544
   2051c:	000310d7 	.word	0x000310d7
   20520:	000310e5 	.word	0x000310e5
   20524:	0003110d 	.word	0x0003110d
   20528:	0002bc72 	.word	0x0002bc72
   2052c:	0003112e 	.word	0x0003112e

00020530 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   20530:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   20532:	4d0b      	ldr	r5, [pc, #44]	; (20560 <idle+0x30>)
	__asm__ volatile(
   20534:	f04f 0220 	mov.w	r2, #32
   20538:	f3ef 8311 	mrs	r3, BASEPRI
   2053c:	f382 8811 	msr	BASEPRI, r2
   20540:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   20544:	f002 fd82 	bl	2304c <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   20548:	2101      	movs	r1, #1
   2054a:	2802      	cmp	r0, #2
	s32_t ticks = z_get_next_timeout_expiry();
   2054c:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   2054e:	bfd8      	it	le
   20550:	4608      	movle	r0, r1
   20552:	f002 fdc3 	bl	230dc <z_set_timeout_expiry>
	_kernel.idle = ticks;
   20556:	622c      	str	r4, [r5, #32]
	arch_cpu_idle();
   20558:	f7e4 fb02 	bl	4b60 <arch_cpu_idle>
}
   2055c:	e7ea      	b.n	20534 <idle+0x4>
   2055e:	bf00      	nop
   20560:	20001d80 	.word	0x20001d80

00020564 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   20564:	4802      	ldr	r0, [pc, #8]	; (20570 <z_bss_zero+0xc>)
   20566:	4a03      	ldr	r2, [pc, #12]	; (20574 <z_bss_zero+0x10>)
   20568:	2100      	movs	r1, #0
   2056a:	1a12      	subs	r2, r2, r0
   2056c:	f005 bbc7 	b.w	25cfe <memset>
   20570:	20000000 	.word	0x20000000
   20574:	200024e0 	.word	0x200024e0

00020578 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   20578:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
   2057a:	4806      	ldr	r0, [pc, #24]	; (20594 <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
   2057c:	4a06      	ldr	r2, [pc, #24]	; (20598 <z_data_copy+0x20>)
   2057e:	4907      	ldr	r1, [pc, #28]	; (2059c <z_data_copy+0x24>)
   20580:	1a12      	subs	r2, r2, r0
   20582:	f005 fb91 	bl	25ca8 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   20586:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
   2058a:	4a05      	ldr	r2, [pc, #20]	; (205a0 <z_data_copy+0x28>)
   2058c:	4905      	ldr	r1, [pc, #20]	; (205a4 <z_data_copy+0x2c>)
   2058e:	4806      	ldr	r0, [pc, #24]	; (205a8 <z_data_copy+0x30>)
   20590:	f005 bb8a 	b.w	25ca8 <memcpy>
   20594:	20006810 	.word	0x20006810
   20598:	200077b4 	.word	0x200077b4
   2059c:	0003179e 	.word	0x0003179e
   205a0:	00000000 	.word	0x00000000
   205a4:	0003179c 	.word	0x0003179c
   205a8:	20000000 	.word	0x20000000

000205ac <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
   205ac:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
   205ae:	4b0c      	ldr	r3, [pc, #48]	; (205e0 <bg_thread_main+0x34>)
   205b0:	2201      	movs	r2, #1

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   205b2:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   205b4:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   205b6:	f7ff fef1 	bl	2039c <z_sys_device_do_config_level>
#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
			STRINGIFY(BUILD_VERSION), BOOT_DELAY_BANNER);
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
   205ba:	4a0a      	ldr	r2, [pc, #40]	; (205e4 <bg_thread_main+0x38>)
   205bc:	490a      	ldr	r1, [pc, #40]	; (205e8 <bg_thread_main+0x3c>)
   205be:	480b      	ldr	r0, [pc, #44]	; (205ec <bg_thread_main+0x40>)
   205c0:	f003 fc8f 	bl	23ee2 <printk>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   205c4:	2003      	movs	r0, #3
   205c6:	f7ff fee9 	bl	2039c <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
   205ca:	f002 f9f5 	bl	229b8 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   205ce:	f7e1 fb85 	bl	1cdc <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   205d2:	4a07      	ldr	r2, [pc, #28]	; (205f0 <bg_thread_main+0x44>)
   205d4:	7b13      	ldrb	r3, [r2, #12]
   205d6:	f023 0301 	bic.w	r3, r3, #1
   205da:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   205dc:	bd08      	pop	{r3, pc}
   205de:	bf00      	nop
   205e0:	200024de 	.word	0x200024de
   205e4:	0002d7aa 	.word	0x0002d7aa
   205e8:	00030285 	.word	0x00030285
   205ec:	00031190 	.word	0x00031190
   205f0:	20001ce0 	.word	0x20001ce0

000205f4 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   205f4:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
   205f8:	b0ad      	sub	sp, #180	; 0xb4
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   205fa:	f7e1 ff1f 	bl	243c <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(z_interrupt_stacks[0])) +
   205fe:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 206fc <z_cstart+0x108>
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   20602:	f38a 8808 	msr	MSP, sl
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
   20606:	4d35      	ldr	r5, [pc, #212]	; (206dc <z_cstart+0xe8>)
	_kernel.ready_q.cache = &z_main_thread;
   20608:	4e35      	ldr	r6, [pc, #212]	; (206e0 <z_cstart+0xec>)
   2060a:	696b      	ldr	r3, [r5, #20]
	z_setup_new_thread(&z_main_thread, z_main_stack,
   2060c:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 20700 <z_cstart+0x10c>
   20610:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 20704 <z_cstart+0x110>
	z_setup_new_thread(thread, stack,
   20614:	4f33      	ldr	r7, [pc, #204]	; (206e4 <z_cstart+0xf0>)
   20616:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2061a:	2400      	movs	r4, #0
   2061c:	616b      	str	r3, [r5, #20]
   2061e:	23e0      	movs	r3, #224	; 0xe0
   20620:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   20624:	77ec      	strb	r4, [r5, #31]
   20626:	762c      	strb	r4, [r5, #24]
   20628:	766c      	strb	r4, [r5, #25]
   2062a:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   2062c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   2062e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   20632:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   20634:	f7e4 fd8a 	bl	514c <z_arm_fault_init>
	z_arm_cpu_idle_init();
   20638:	f7e4 fa8c 	bl	4b54 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   2063c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   20640:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   20642:	62eb      	str	r3, [r5, #44]	; 0x2c

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
   20644:	ab07      	add	r3, sp, #28
   20646:	2294      	movs	r2, #148	; 0x94
   20648:	4621      	mov	r1, r4
   2064a:	4618      	mov	r0, r3
   2064c:	f005 fb57 	bl	25cfe <memset>
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current_cpu->current = &dummy_thread;
   20650:	4d25      	ldr	r5, [pc, #148]	; (206e8 <z_cstart+0xf4>)
	struct k_thread dummy_thread = {
   20652:	f04f 0801 	mov.w	r8, #1
	_current_cpu->current = &dummy_thread;
   20656:	60a8      	str	r0, [r5, #8]
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   20658:	4620      	mov	r0, r4
	struct k_thread dummy_thread = {
   2065a:	f88d 8029 	strb.w	r8, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   2065e:	f7ff fe9d 	bl	2039c <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   20662:	4640      	mov	r0, r8
   20664:	f7ff fe9a 	bl	2039c <z_sys_device_do_config_level>
	z_sched_init();
   20668:	f001 fe90 	bl	2238c <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   2066c:	4b1f      	ldr	r3, [pc, #124]	; (206ec <z_cstart+0xf8>)
	_kernel.ready_q.cache = &z_main_thread;
   2066e:	626e      	str	r6, [r5, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   20670:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
   20674:	4649      	mov	r1, r9
   20676:	e9cd 8304 	strd	r8, r3, [sp, #16]
   2067a:	4630      	mov	r0, r6
   2067c:	465b      	mov	r3, fp
   2067e:	e9cd 4402 	strd	r4, r4, [sp, #8]
   20682:	e9cd 4400 	strd	r4, r4, [sp]
   20686:	f002 f903 	bl	22890 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   2068a:	7b73      	ldrb	r3, [r6, #13]
	z_ready_thread(&z_main_thread);
   2068c:	4630      	mov	r0, r6
   2068e:	f023 0304 	bic.w	r3, r3, #4
   20692:	7373      	strb	r3, [r6, #13]
   20694:	f001 f8fc 	bl	21890 <z_ready_thread>
	z_setup_new_thread(thread, stack,
   20698:	4b15      	ldr	r3, [pc, #84]	; (206f0 <z_cstart+0xfc>)
   2069a:	4916      	ldr	r1, [pc, #88]	; (206f4 <z_cstart+0x100>)
   2069c:	e9cd 8304 	strd	r8, r3, [sp, #16]
   206a0:	230f      	movs	r3, #15
   206a2:	e9cd 4302 	strd	r4, r3, [sp, #8]
   206a6:	f44f 72a0 	mov.w	r2, #320	; 0x140
   206aa:	4b13      	ldr	r3, [pc, #76]	; (206f8 <z_cstart+0x104>)
   206ac:	4638      	mov	r0, r7
   206ae:	e9cd 4400 	strd	r4, r4, [sp]
   206b2:	f002 f8ed 	bl	22890 <z_setup_new_thread>
   206b6:	7b7b      	ldrb	r3, [r7, #13]
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   206b8:	60ef      	str	r7, [r5, #12]
   206ba:	f023 0304 	bic.w	r3, r3, #4
   206be:	737b      	strb	r3, [r7, #13]
	list->head = (sys_dnode_t *)list;
   206c0:	f105 0318 	add.w	r3, r5, #24
	list->tail = (sys_dnode_t *)list;
   206c4:	e9c5 3306 	strd	r3, r3, [r5, #24]
		_kernel.cpus[i].id = i;
   206c8:	752c      	strb	r4, [r5, #20]
		_kernel.cpus[i].irq_stack =
   206ca:	f8c5 a004 	str.w	sl, [r5, #4]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   206ce:	465b      	mov	r3, fp
   206d0:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
   206d4:	4649      	mov	r1, r9
   206d6:	4630      	mov	r0, r6
   206d8:	f7e4 fa1c 	bl	4b14 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   206dc:	e000ed00 	.word	0xe000ed00
   206e0:	20001ce0 	.word	0x20001ce0
   206e4:	20001c4c 	.word	0x20001c4c
   206e8:	20001d80 	.word	0x20001d80
   206ec:	0002cd2a 	.word	0x0002cd2a
   206f0:	000311b9 	.word	0x000311b9
   206f4:	20003e20 	.word	0x20003e20
   206f8:	00020531 	.word	0x00020531
   206fc:	200043a0 	.word	0x200043a0
   20700:	000205ad 	.word	0x000205ad
   20704:	20003c40 	.word	0x20003c40

00020708 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
   20708:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   2070c:	4d16      	ldr	r5, [pc, #88]	; (20768 <init_mem_slab_module+0x60>)
   2070e:	4c17      	ldr	r4, [pc, #92]	; (2076c <init_mem_slab_module+0x64>)
   20710:	4e17      	ldr	r6, [pc, #92]	; (20770 <init_mem_slab_module+0x68>)
   20712:	46a8      	mov	r8, r5
   20714:	42ac      	cmp	r4, r5
   20716:	d90c      	bls.n	20732 <init_mem_slab_module+0x2a>
   20718:	4916      	ldr	r1, [pc, #88]	; (20774 <init_mem_slab_module+0x6c>)
   2071a:	4817      	ldr	r0, [pc, #92]	; (20778 <init_mem_slab_module+0x70>)
   2071c:	2342      	movs	r3, #66	; 0x42
   2071e:	4632      	mov	r2, r6
   20720:	f003 fbdf 	bl	23ee2 <printk>
   20724:	4815      	ldr	r0, [pc, #84]	; (2077c <init_mem_slab_module+0x74>)
   20726:	f003 fbdc 	bl	23ee2 <printk>
   2072a:	2142      	movs	r1, #66	; 0x42
   2072c:	4630      	mov	r0, r6
   2072e:	f003 fc1b 	bl	23f68 <assert_post_action>
   20732:	4544      	cmp	r4, r8
   20734:	d302      	bcc.n	2073c <init_mem_slab_module+0x34>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
   20736:	2000      	movs	r0, #0
	return rc;
}
   20738:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   2073c:	e9d4 2103 	ldrd	r2, r1, [r4, #12]
   20740:	ea41 0302 	orr.w	r3, r1, r2
   20744:	f013 0303 	ands.w	r3, r3, #3
   20748:	d10b      	bne.n	20762 <init_mem_slab_module+0x5a>
	for (j = 0U; j < slab->num_blocks; j++) {
   2074a:	68a0      	ldr	r0, [r4, #8]
	slab->free_list = NULL;
   2074c:	6163      	str	r3, [r4, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   2074e:	4283      	cmp	r3, r0
   20750:	d101      	bne.n	20756 <init_mem_slab_module+0x4e>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   20752:	341c      	adds	r4, #28
   20754:	e7de      	b.n	20714 <init_mem_slab_module+0xc>
		*(char **)p = slab->free_list;
   20756:	6967      	ldr	r7, [r4, #20]
   20758:	600f      	str	r7, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
   2075a:	3301      	adds	r3, #1
		slab->free_list = p;
   2075c:	6161      	str	r1, [r4, #20]
		p += slab->block_size;
   2075e:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   20760:	e7f5      	b.n	2074e <init_mem_slab_module+0x46>
		return -EINVAL;
   20762:	f06f 0015 	mvn.w	r0, #21
	return rc;
   20766:	e7e7      	b.n	20738 <init_mem_slab_module+0x30>
   20768:	200075b0 	.word	0x200075b0
   2076c:	2000755c 	.word	0x2000755c
   20770:	000311c1 	.word	0x000311c1
   20774:	000311e6 	.word	0x000311e6
   20778:	0002a5e8 	.word	0x0002a5e8
   2077c:	0002ad2b 	.word	0x0002ad2b

00020780 <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   20780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   20782:	4604      	mov	r4, r0
   20784:	460d      	mov	r5, r1
   20786:	4616      	mov	r6, r2
   20788:	f04f 0320 	mov.w	r3, #32
   2078c:	f3ef 8711 	mrs	r7, BASEPRI
   20790:	f383 8811 	msr	BASEPRI, r3
   20794:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   20798:	4823      	ldr	r0, [pc, #140]	; (20828 <k_mem_slab_alloc+0xa8>)
   2079a:	f002 f997 	bl	22acc <z_spin_lock_valid>
   2079e:	b968      	cbnz	r0, 207bc <k_mem_slab_alloc+0x3c>
   207a0:	4a22      	ldr	r2, [pc, #136]	; (2082c <k_mem_slab_alloc+0xac>)
   207a2:	4923      	ldr	r1, [pc, #140]	; (20830 <k_mem_slab_alloc+0xb0>)
   207a4:	4823      	ldr	r0, [pc, #140]	; (20834 <k_mem_slab_alloc+0xb4>)
   207a6:	234a      	movs	r3, #74	; 0x4a
   207a8:	f003 fb9b 	bl	23ee2 <printk>
   207ac:	491e      	ldr	r1, [pc, #120]	; (20828 <k_mem_slab_alloc+0xa8>)
   207ae:	4822      	ldr	r0, [pc, #136]	; (20838 <k_mem_slab_alloc+0xb8>)
   207b0:	f003 fb97 	bl	23ee2 <printk>
   207b4:	481d      	ldr	r0, [pc, #116]	; (2082c <k_mem_slab_alloc+0xac>)
   207b6:	214a      	movs	r1, #74	; 0x4a
   207b8:	f003 fbd6 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   207bc:	481a      	ldr	r0, [pc, #104]	; (20828 <k_mem_slab_alloc+0xa8>)
   207be:	f002 f9a3 	bl	22b08 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   207c2:	6963      	ldr	r3, [r4, #20]
   207c4:	b1eb      	cbz	r3, 20802 <k_mem_slab_alloc+0x82>
		/* take a free block */
		*mem = slab->free_list;
   207c6:	602b      	str	r3, [r5, #0]
		slab->free_list = *(char **)(slab->free_list);
   207c8:	681b      	ldr	r3, [r3, #0]
   207ca:	6163      	str	r3, [r4, #20]
		slab->num_used++;
   207cc:	69a3      	ldr	r3, [r4, #24]
   207ce:	3301      	adds	r3, #1
   207d0:	61a3      	str	r3, [r4, #24]
		result = 0;
   207d2:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   207d4:	4814      	ldr	r0, [pc, #80]	; (20828 <k_mem_slab_alloc+0xa8>)
   207d6:	f002 f987 	bl	22ae8 <z_spin_unlock_valid>
   207da:	b968      	cbnz	r0, 207f8 <k_mem_slab_alloc+0x78>
   207dc:	4a13      	ldr	r2, [pc, #76]	; (2082c <k_mem_slab_alloc+0xac>)
   207de:	4917      	ldr	r1, [pc, #92]	; (2083c <k_mem_slab_alloc+0xbc>)
   207e0:	4814      	ldr	r0, [pc, #80]	; (20834 <k_mem_slab_alloc+0xb4>)
   207e2:	235d      	movs	r3, #93	; 0x5d
   207e4:	f003 fb7d 	bl	23ee2 <printk>
   207e8:	490f      	ldr	r1, [pc, #60]	; (20828 <k_mem_slab_alloc+0xa8>)
   207ea:	4815      	ldr	r0, [pc, #84]	; (20840 <k_mem_slab_alloc+0xc0>)
   207ec:	f003 fb79 	bl	23ee2 <printk>
   207f0:	480e      	ldr	r0, [pc, #56]	; (2082c <k_mem_slab_alloc+0xac>)
   207f2:	215d      	movs	r1, #93	; 0x5d
   207f4:	f003 fbb8 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   207f8:	f387 8811 	msr	BASEPRI, r7
   207fc:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   20800:	e010      	b.n	20824 <k_mem_slab_alloc+0xa4>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   20802:	b91e      	cbnz	r6, 2080c <k_mem_slab_alloc+0x8c>
		*mem = NULL;
   20804:	602e      	str	r6, [r5, #0]
		result = -ENOMEM;
   20806:	f06f 040b 	mvn.w	r4, #11
   2080a:	e7e3      	b.n	207d4 <k_mem_slab_alloc+0x54>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   2080c:	4622      	mov	r2, r4
   2080e:	4806      	ldr	r0, [pc, #24]	; (20828 <k_mem_slab_alloc+0xa8>)
   20810:	4633      	mov	r3, r6
   20812:	4639      	mov	r1, r7
   20814:	f001 fc66 	bl	220e4 <z_pend_curr>
		if (result == 0) {
   20818:	4604      	mov	r4, r0
   2081a:	b918      	cbnz	r0, 20824 <k_mem_slab_alloc+0xa4>
			*mem = _current->base.swap_data;
   2081c:	4b09      	ldr	r3, [pc, #36]	; (20844 <k_mem_slab_alloc+0xc4>)
   2081e:	689b      	ldr	r3, [r3, #8]
   20820:	695b      	ldr	r3, [r3, #20]
   20822:	602b      	str	r3, [r5, #0]
}
   20824:	4620      	mov	r0, r4
   20826:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   20828:	20001d74 	.word	0x20001d74
   2082c:	0002ae90 	.word	0x0002ae90
   20830:	0002aeb2 	.word	0x0002aeb2
   20834:	0002a5e8 	.word	0x0002a5e8
   20838:	0002aec7 	.word	0x0002aec7
   2083c:	0002aedf 	.word	0x0002aedf
   20840:	0002aef6 	.word	0x0002aef6
   20844:	20001d80 	.word	0x20001d80

00020848 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   20848:	b570      	push	{r4, r5, r6, lr}
   2084a:	4604      	mov	r4, r0
   2084c:	460d      	mov	r5, r1
	__asm__ volatile(
   2084e:	f04f 0320 	mov.w	r3, #32
   20852:	f3ef 8611 	mrs	r6, BASEPRI
   20856:	f383 8811 	msr	BASEPRI, r3
   2085a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2085e:	4822      	ldr	r0, [pc, #136]	; (208e8 <k_mem_slab_free+0xa0>)
   20860:	f002 f934 	bl	22acc <z_spin_lock_valid>
   20864:	b968      	cbnz	r0, 20882 <k_mem_slab_free+0x3a>
   20866:	4a21      	ldr	r2, [pc, #132]	; (208ec <k_mem_slab_free+0xa4>)
   20868:	4921      	ldr	r1, [pc, #132]	; (208f0 <k_mem_slab_free+0xa8>)
   2086a:	4822      	ldr	r0, [pc, #136]	; (208f4 <k_mem_slab_free+0xac>)
   2086c:	234a      	movs	r3, #74	; 0x4a
   2086e:	f003 fb38 	bl	23ee2 <printk>
   20872:	491d      	ldr	r1, [pc, #116]	; (208e8 <k_mem_slab_free+0xa0>)
   20874:	4820      	ldr	r0, [pc, #128]	; (208f8 <k_mem_slab_free+0xb0>)
   20876:	f003 fb34 	bl	23ee2 <printk>
   2087a:	481c      	ldr	r0, [pc, #112]	; (208ec <k_mem_slab_free+0xa4>)
   2087c:	214a      	movs	r1, #74	; 0x4a
   2087e:	f003 fb73 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   20882:	4819      	ldr	r0, [pc, #100]	; (208e8 <k_mem_slab_free+0xa0>)
   20884:	f002 f940 	bl	22b08 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   20888:	4620      	mov	r0, r4
   2088a:	f001 fcef 	bl	2226c <z_unpend_first_thread>

	if (pending_thread != NULL) {
   2088e:	b160      	cbz	r0, 208aa <k_mem_slab_free+0x62>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   20890:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   20892:	6142      	str	r2, [r0, #20]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   20894:	2100      	movs	r1, #0
   20896:	f8c0 1090 	str.w	r1, [r0, #144]	; 0x90
		z_ready_thread(pending_thread);
   2089a:	f000 fff9 	bl	21890 <z_ready_thread>
		z_reschedule(&lock, key);
   2089e:	4631      	mov	r1, r6
   208a0:	4811      	ldr	r0, [pc, #68]	; (208e8 <k_mem_slab_free+0xa0>)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   208a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   208a6:	f000 bdcd 	b.w	21444 <z_reschedule>
		**(char ***)mem = slab->free_list;
   208aa:	682b      	ldr	r3, [r5, #0]
   208ac:	6962      	ldr	r2, [r4, #20]
   208ae:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   208b0:	682b      	ldr	r3, [r5, #0]
   208b2:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   208b4:	69a3      	ldr	r3, [r4, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   208b6:	480c      	ldr	r0, [pc, #48]	; (208e8 <k_mem_slab_free+0xa0>)
   208b8:	3b01      	subs	r3, #1
   208ba:	61a3      	str	r3, [r4, #24]
   208bc:	f002 f914 	bl	22ae8 <z_spin_unlock_valid>
   208c0:	b968      	cbnz	r0, 208de <k_mem_slab_free+0x96>
   208c2:	4a0a      	ldr	r2, [pc, #40]	; (208ec <k_mem_slab_free+0xa4>)
   208c4:	490d      	ldr	r1, [pc, #52]	; (208fc <k_mem_slab_free+0xb4>)
   208c6:	480b      	ldr	r0, [pc, #44]	; (208f4 <k_mem_slab_free+0xac>)
   208c8:	235d      	movs	r3, #93	; 0x5d
   208ca:	f003 fb0a 	bl	23ee2 <printk>
   208ce:	4906      	ldr	r1, [pc, #24]	; (208e8 <k_mem_slab_free+0xa0>)
   208d0:	480b      	ldr	r0, [pc, #44]	; (20900 <k_mem_slab_free+0xb8>)
   208d2:	f003 fb06 	bl	23ee2 <printk>
   208d6:	4805      	ldr	r0, [pc, #20]	; (208ec <k_mem_slab_free+0xa4>)
   208d8:	215d      	movs	r1, #93	; 0x5d
   208da:	f003 fb45 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   208de:	f386 8811 	msr	BASEPRI, r6
   208e2:	f3bf 8f6f 	isb	sy
}
   208e6:	bd70      	pop	{r4, r5, r6, pc}
   208e8:	20001d74 	.word	0x20001d74
   208ec:	0002ae90 	.word	0x0002ae90
   208f0:	0002aeb2 	.word	0x0002aeb2
   208f4:	0002a5e8 	.word	0x0002a5e8
   208f8:	0002aec7 	.word	0x0002aec7
   208fc:	0002aedf 	.word	0x0002aedf
   20900:	0002aef6 	.word	0x0002aef6

00020904 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
   20904:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   20906:	4d10      	ldr	r5, [pc, #64]	; (20948 <init_static_pools+0x44>)
   20908:	4c10      	ldr	r4, [pc, #64]	; (2094c <init_static_pools+0x48>)
   2090a:	4e11      	ldr	r6, [pc, #68]	; (20950 <init_static_pools+0x4c>)
   2090c:	462f      	mov	r7, r5
   2090e:	42ac      	cmp	r4, r5
   20910:	d90c      	bls.n	2092c <init_static_pools+0x28>
   20912:	4910      	ldr	r1, [pc, #64]	; (20954 <init_static_pools+0x50>)
   20914:	4810      	ldr	r0, [pc, #64]	; (20958 <init_static_pools+0x54>)
   20916:	2328      	movs	r3, #40	; 0x28
   20918:	4632      	mov	r2, r6
   2091a:	f003 fae2 	bl	23ee2 <printk>
   2091e:	480f      	ldr	r0, [pc, #60]	; (2095c <init_static_pools+0x58>)
   20920:	f003 fadf 	bl	23ee2 <printk>
   20924:	2128      	movs	r1, #40	; 0x28
   20926:	4630      	mov	r0, r6
   20928:	f003 fb1e 	bl	23f68 <assert_post_action>
   2092c:	42bc      	cmp	r4, r7
   2092e:	d301      	bcc.n	20934 <init_static_pools+0x30>
		k_mem_pool_init(p);
	}

	return 0;
}
   20930:	2000      	movs	r0, #0
   20932:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   20934:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
   20938:	4620      	mov	r0, r4
   2093a:	e9c4 3305 	strd	r3, r3, [r4, #20]
   2093e:	f003 f9af 	bl	23ca0 <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   20942:	341c      	adds	r4, #28
   20944:	e7e3      	b.n	2090e <init_static_pools+0xa>
   20946:	bf00      	nop
   20948:	200075b0 	.word	0x200075b0
   2094c:	200075b0 	.word	0x200075b0
   20950:	00031203 	.word	0x00031203
   20954:	00031227 	.word	0x00031227
   20958:	0002a5e8 	.word	0x0002a5e8
   2095c:	0002ad2b 	.word	0x0002ad2b

00020960 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, k_timeout_t timeout)
{
   20960:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20964:	4607      	mov	r7, r0
   20966:	b087      	sub	sp, #28
   20968:	460d      	mov	r5, r1
   2096a:	4691      	mov	r9, r2
   2096c:	461c      	mov	r4, r3
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   2096e:	f3ef 8305 	mrs	r3, IPSR
	int ret;
	u64_t end = 0;

	__ASSERT(!(arch_is_in_isr() && !K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");
   20972:	b16b      	cbz	r3, 20990 <k_mem_pool_alloc+0x30>
   20974:	b164      	cbz	r4, 20990 <k_mem_pool_alloc+0x30>
   20976:	492c      	ldr	r1, [pc, #176]	; (20a28 <k_mem_pool_alloc+0xc8>)
   20978:	4a2c      	ldr	r2, [pc, #176]	; (20a2c <k_mem_pool_alloc+0xcc>)
   2097a:	482d      	ldr	r0, [pc, #180]	; (20a30 <k_mem_pool_alloc+0xd0>)
   2097c:	2337      	movs	r3, #55	; 0x37
   2097e:	f003 fab0 	bl	23ee2 <printk>
   20982:	482c      	ldr	r0, [pc, #176]	; (20a34 <k_mem_pool_alloc+0xd4>)
   20984:	f003 faad 	bl	23ee2 <printk>
   20988:	4828      	ldr	r0, [pc, #160]	; (20a2c <k_mem_pool_alloc+0xcc>)
   2098a:	2137      	movs	r1, #55	; 0x37
   2098c:	f003 faec 	bl	23f68 <assert_post_action>

	end = z_timeout_end_calc(timeout);
   20990:	4620      	mov	r0, r4
   20992:	f008 fd40 	bl	29416 <z_timeout_end_calc>
	return pool - &_k_mem_pool_list_start[0];
   20996:	4b28      	ldr	r3, [pc, #160]	; (20a38 <k_mem_pool_alloc+0xd8>)
   20998:	4e28      	ldr	r6, [pc, #160]	; (20a3c <k_mem_pool_alloc+0xdc>)
	end = z_timeout_end_calc(timeout);
   2099a:	9103      	str	r1, [sp, #12]
	return pool - &_k_mem_pool_list_start[0];
   2099c:	1afb      	subs	r3, r7, r3
   2099e:	109b      	asrs	r3, r3, #2
   209a0:	435e      	muls	r6, r3
	end = z_timeout_end_calc(timeout);
   209a2:	4680      	mov	r8, r0
		u32_t level_num, block_num;

		ret = z_sys_mem_pool_block_alloc(&p->base, size,
						 &level_num, &block_num,
						 &block->data);
		block->id.pool = pool_id(p);
   209a4:	b2f6      	uxtb	r6, r6
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
   209a6:	ab05      	add	r3, sp, #20
   209a8:	aa04      	add	r2, sp, #16
   209aa:	9500      	str	r5, [sp, #0]
   209ac:	4649      	mov	r1, r9
   209ae:	4638      	mov	r0, r7
   209b0:	f003 f9bc 	bl	23d2c <z_sys_mem_pool_block_alloc>
		block->id.level = level_num;
   209b4:	9b04      	ldr	r3, [sp, #16]
   209b6:	9a05      	ldr	r2, [sp, #20]
   209b8:	021b      	lsls	r3, r3, #8
   209ba:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
   209be:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
   209c2:	b2f2      	uxtb	r2, r6
   209c4:	4313      	orrs	r3, r2
   209c6:	606b      	str	r3, [r5, #4]
		block->id.block = block_num;

		if (ret == 0 || K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   209c8:	b358      	cbz	r0, 20a22 <k_mem_pool_alloc+0xc2>
   209ca:	b354      	cbz	r4, 20a22 <k_mem_pool_alloc+0xc2>
   209cc:	f110 0f0c 	cmn.w	r0, #12
   209d0:	d127      	bne.n	20a22 <k_mem_pool_alloc+0xc2>
	__asm__ volatile(
   209d2:	f04f 0320 	mov.w	r3, #32
   209d6:	f3ef 8011 	mrs	r0, BASEPRI
   209da:	f383 8811 	msr	BASEPRI, r3
   209de:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
   209e2:	4622      	mov	r2, r4
   209e4:	f107 0114 	add.w	r1, r7, #20
   209e8:	f001 fb22 	bl	22030 <z_pend_curr_irqlock>
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);

		if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   209ec:	1c63      	adds	r3, r4, #1
   209ee:	d0da      	beq.n	209a6 <k_mem_pool_alloc+0x46>
			s64_t remaining = end - z_tick_get();
   209f0:	f002 fc74 	bl	232dc <z_tick_get>
   209f4:	9b03      	ldr	r3, [sp, #12]
   209f6:	ebb8 0a00 	subs.w	sl, r8, r0
   209fa:	eb63 0b01 	sbc.w	fp, r3, r1

			if (remaining <= 0) {
   209fe:	f1ba 0f01 	cmp.w	sl, #1
   20a02:	f17b 0300 	sbcs.w	r3, fp, #0
   20a06:	db0a      	blt.n	20a1e <k_mem_pool_alloc+0xbe>
			return (u32_t)((t * to_hz + off) / from_hz);
   20a08:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   20a0c:	f647 71ff 	movw	r1, #32767	; 0x7fff
   20a10:	2200      	movs	r2, #0
   20a12:	fbe3 120a 	umlal	r1, r2, r3, sl
   20a16:	0bcc      	lsrs	r4, r1, #15
   20a18:	ea44 4442 	orr.w	r4, r4, r2, lsl #17
	while (true) {
   20a1c:	e7c3      	b.n	209a6 <k_mem_pool_alloc+0x46>
			}
			timeout = Z_TIMEOUT_TICKS(remaining);
		}
	}

	return -EAGAIN;
   20a1e:	f06f 000a 	mvn.w	r0, #10
}
   20a22:	b007      	add	sp, #28
   20a24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   20a28:	00031241 	.word	0x00031241
   20a2c:	00031203 	.word	0x00031203
   20a30:	0002a5e8 	.word	0x0002a5e8
   20a34:	00030d23 	.word	0x00030d23
   20a38:	200075b0 	.word	0x200075b0
   20a3c:	b6db6db7 	.word	0xb6db6db7

00020a40 <k_mem_pool_free_id>:
void k_mem_pool_free_id(struct k_mem_block_id *id)
{
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
   20a40:	7803      	ldrb	r3, [r0, #0]
   20a42:	6802      	ldr	r2, [r0, #0]
   20a44:	7841      	ldrb	r1, [r0, #1]
{
   20a46:	b570      	push	{r4, r5, r6, lr}
	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
   20a48:	4c25      	ldr	r4, [pc, #148]	; (20ae0 <k_mem_pool_free_id+0xa0>)
   20a4a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   20a4e:	0b12      	lsrs	r2, r2, #12
   20a50:	f001 010f 	and.w	r1, r1, #15
   20a54:	eb04 0083 	add.w	r0, r4, r3, lsl #2
   20a58:	009d      	lsls	r5, r3, #2
   20a5a:	f7e1 f9a9 	bl	1db0 <z_sys_mem_pool_block_free>
   20a5e:	f04f 0320 	mov.w	r3, #32
   20a62:	f3ef 8611 	mrs	r6, BASEPRI
   20a66:	f383 8811 	msr	BASEPRI, r3
   20a6a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   20a6e:	481d      	ldr	r0, [pc, #116]	; (20ae4 <k_mem_pool_free_id+0xa4>)
   20a70:	f002 f82c 	bl	22acc <z_spin_lock_valid>
   20a74:	b968      	cbnz	r0, 20a92 <k_mem_pool_free_id+0x52>
   20a76:	4a1c      	ldr	r2, [pc, #112]	; (20ae8 <k_mem_pool_free_id+0xa8>)
   20a78:	491c      	ldr	r1, [pc, #112]	; (20aec <k_mem_pool_free_id+0xac>)
   20a7a:	481d      	ldr	r0, [pc, #116]	; (20af0 <k_mem_pool_free_id+0xb0>)
   20a7c:	234a      	movs	r3, #74	; 0x4a
   20a7e:	f003 fa30 	bl	23ee2 <printk>
   20a82:	4918      	ldr	r1, [pc, #96]	; (20ae4 <k_mem_pool_free_id+0xa4>)
   20a84:	481b      	ldr	r0, [pc, #108]	; (20af4 <k_mem_pool_free_id+0xb4>)
   20a86:	f003 fa2c 	bl	23ee2 <printk>
   20a8a:	4817      	ldr	r0, [pc, #92]	; (20ae8 <k_mem_pool_free_id+0xa8>)
   20a8c:	214a      	movs	r1, #74	; 0x4a
   20a8e:	f003 fa6b 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   20a92:	4814      	ldr	r0, [pc, #80]	; (20ae4 <k_mem_pool_free_id+0xa4>)
   20a94:	f002 f838 	bl	22b08 <z_spin_lock_set_owner>
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
   20a98:	f105 0014 	add.w	r0, r5, #20
   20a9c:	4420      	add	r0, r4
   20a9e:	f008 fc0b 	bl	292b8 <z_unpend_all>

	if (need_sched != 0) {
   20aa2:	b128      	cbz	r0, 20ab0 <k_mem_pool_free_id+0x70>
		z_reschedule(&lock, key);
   20aa4:	4631      	mov	r1, r6
   20aa6:	480f      	ldr	r0, [pc, #60]	; (20ae4 <k_mem_pool_free_id+0xa4>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
   20aa8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   20aac:	f000 bcca 	b.w	21444 <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   20ab0:	480c      	ldr	r0, [pc, #48]	; (20ae4 <k_mem_pool_free_id+0xa4>)
   20ab2:	f002 f819 	bl	22ae8 <z_spin_unlock_valid>
   20ab6:	b968      	cbnz	r0, 20ad4 <k_mem_pool_free_id+0x94>
   20ab8:	4a0b      	ldr	r2, [pc, #44]	; (20ae8 <k_mem_pool_free_id+0xa8>)
   20aba:	490f      	ldr	r1, [pc, #60]	; (20af8 <k_mem_pool_free_id+0xb8>)
   20abc:	480c      	ldr	r0, [pc, #48]	; (20af0 <k_mem_pool_free_id+0xb0>)
   20abe:	235d      	movs	r3, #93	; 0x5d
   20ac0:	f003 fa0f 	bl	23ee2 <printk>
   20ac4:	4907      	ldr	r1, [pc, #28]	; (20ae4 <k_mem_pool_free_id+0xa4>)
   20ac6:	480d      	ldr	r0, [pc, #52]	; (20afc <k_mem_pool_free_id+0xbc>)
   20ac8:	f003 fa0b 	bl	23ee2 <printk>
   20acc:	4806      	ldr	r0, [pc, #24]	; (20ae8 <k_mem_pool_free_id+0xa8>)
   20ace:	215d      	movs	r1, #93	; 0x5d
   20ad0:	f003 fa4a 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   20ad4:	f386 8811 	msr	BASEPRI, r6
   20ad8:	f3bf 8f6f 	isb	sy
}
   20adc:	bd70      	pop	{r4, r5, r6, pc}
   20ade:	bf00      	nop
   20ae0:	200075b0 	.word	0x200075b0
   20ae4:	20001d78 	.word	0x20001d78
   20ae8:	0002ae90 	.word	0x0002ae90
   20aec:	0002aeb2 	.word	0x0002aeb2
   20af0:	0002a5e8 	.word	0x0002a5e8
   20af4:	0002aec7 	.word	0x0002aec7
   20af8:	0002aedf 	.word	0x0002aedf
   20afc:	0002aef6 	.word	0x0002aef6

00020b00 <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
   20b00:	b510      	push	{r4, lr}
   20b02:	4604      	mov	r4, r0
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
   20b04:	f008 fbf8 	bl	292f8 <k_is_in_isr>
   20b08:	b948      	cbnz	r0, 20b1e <z_thread_malloc+0x1e>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
   20b0a:	4b06      	ldr	r3, [pc, #24]	; (20b24 <z_thread_malloc+0x24>)
   20b0c:	689b      	ldr	r3, [r3, #8]
   20b0e:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
	}

	if (pool) {
   20b12:	b120      	cbz	r0, 20b1e <z_thread_malloc+0x1e>
		ret = k_mem_pool_malloc(pool, size);
   20b14:	4621      	mov	r1, r4
	} else {
		ret = NULL;
	}

	return ret;
}
   20b16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ret = k_mem_pool_malloc(pool, size);
   20b1a:	f008 bb65 	b.w	291e8 <k_mem_pool_malloc>
}
   20b1e:	2000      	movs	r0, #0
   20b20:	bd10      	pop	{r4, pc}
   20b22:	bf00      	nop
   20b24:	20001d80 	.word	0x20001d80

00020b28 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   20b28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   20b2a:	4604      	mov	r4, r0
   20b2c:	460e      	mov	r6, r1
	__asm__ volatile(
   20b2e:	f04f 0320 	mov.w	r3, #32
   20b32:	f3ef 8711 	mrs	r7, BASEPRI
   20b36:	f383 8811 	msr	BASEPRI, r3
   20b3a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   20b3e:	4861      	ldr	r0, [pc, #388]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20b40:	f001 ffc4 	bl	22acc <z_spin_lock_valid>
   20b44:	b968      	cbnz	r0, 20b62 <z_impl_k_mutex_lock+0x3a>
   20b46:	4a60      	ldr	r2, [pc, #384]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20b48:	4960      	ldr	r1, [pc, #384]	; (20ccc <z_impl_k_mutex_lock+0x1a4>)
   20b4a:	4861      	ldr	r0, [pc, #388]	; (20cd0 <z_impl_k_mutex_lock+0x1a8>)
   20b4c:	234a      	movs	r3, #74	; 0x4a
   20b4e:	f003 f9c8 	bl	23ee2 <printk>
   20b52:	495c      	ldr	r1, [pc, #368]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20b54:	485f      	ldr	r0, [pc, #380]	; (20cd4 <z_impl_k_mutex_lock+0x1ac>)
   20b56:	f003 f9c4 	bl	23ee2 <printk>
   20b5a:	485b      	ldr	r0, [pc, #364]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20b5c:	214a      	movs	r1, #74	; 0x4a
   20b5e:	f003 fa03 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   20b62:	4858      	ldr	r0, [pc, #352]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20b64:	f001 ffd0 	bl	22b08 <z_spin_lock_set_owner>
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   20b68:	68e3      	ldr	r3, [r4, #12]
   20b6a:	4a5b      	ldr	r2, [pc, #364]	; (20cd8 <z_impl_k_mutex_lock+0x1b0>)
   20b6c:	b1f3      	cbz	r3, 20bac <z_impl_k_mutex_lock+0x84>
   20b6e:	68a0      	ldr	r0, [r4, #8]
   20b70:	6891      	ldr	r1, [r2, #8]
   20b72:	4288      	cmp	r0, r1
   20b74:	d03a      	beq.n	20bec <z_impl_k_mutex_lock+0xc4>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   20b76:	2e00      	cmp	r6, #0
   20b78:	d13a      	bne.n	20bf0 <z_impl_k_mutex_lock+0xc8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   20b7a:	4852      	ldr	r0, [pc, #328]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20b7c:	f001 ffb4 	bl	22ae8 <z_spin_unlock_valid>
   20b80:	b968      	cbnz	r0, 20b9e <z_impl_k_mutex_lock+0x76>
   20b82:	4a51      	ldr	r2, [pc, #324]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20b84:	4955      	ldr	r1, [pc, #340]	; (20cdc <z_impl_k_mutex_lock+0x1b4>)
   20b86:	4852      	ldr	r0, [pc, #328]	; (20cd0 <z_impl_k_mutex_lock+0x1a8>)
   20b88:	235d      	movs	r3, #93	; 0x5d
   20b8a:	f003 f9aa 	bl	23ee2 <printk>
   20b8e:	494d      	ldr	r1, [pc, #308]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20b90:	4853      	ldr	r0, [pc, #332]	; (20ce0 <z_impl_k_mutex_lock+0x1b8>)
   20b92:	f003 f9a6 	bl	23ee2 <printk>
   20b96:	484c      	ldr	r0, [pc, #304]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20b98:	215d      	movs	r1, #93	; 0x5d
   20b9a:	f003 f9e5 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   20b9e:	f387 8811 	msr	BASEPRI, r7
   20ba2:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   20ba6:	f06f 000f 	mvn.w	r0, #15
   20baa:	e01e      	b.n	20bea <z_impl_k_mutex_lock+0xc2>
					_current->base.prio :
   20bac:	6891      	ldr	r1, [r2, #8]
   20bae:	f991 100e 	ldrsb.w	r1, [r1, #14]
   20bb2:	4844      	ldr	r0, [pc, #272]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   20bb4:	6121      	str	r1, [r4, #16]
		mutex->lock_count++;
   20bb6:	3301      	adds	r3, #1
   20bb8:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   20bba:	6893      	ldr	r3, [r2, #8]
   20bbc:	60a3      	str	r3, [r4, #8]
   20bbe:	f001 ff93 	bl	22ae8 <z_spin_unlock_valid>
   20bc2:	b968      	cbnz	r0, 20be0 <z_impl_k_mutex_lock+0xb8>
   20bc4:	4a40      	ldr	r2, [pc, #256]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20bc6:	4945      	ldr	r1, [pc, #276]	; (20cdc <z_impl_k_mutex_lock+0x1b4>)
   20bc8:	4841      	ldr	r0, [pc, #260]	; (20cd0 <z_impl_k_mutex_lock+0x1a8>)
   20bca:	235d      	movs	r3, #93	; 0x5d
   20bcc:	f003 f989 	bl	23ee2 <printk>
   20bd0:	493c      	ldr	r1, [pc, #240]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20bd2:	4843      	ldr	r0, [pc, #268]	; (20ce0 <z_impl_k_mutex_lock+0x1b8>)
   20bd4:	f003 f985 	bl	23ee2 <printk>
   20bd8:	483b      	ldr	r0, [pc, #236]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20bda:	215d      	movs	r1, #93	; 0x5d
   20bdc:	f003 f9c4 	bl	23f68 <assert_post_action>
   20be0:	f387 8811 	msr	BASEPRI, r7
   20be4:	f3bf 8f6f 	isb	sy
		return 0;
   20be8:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   20bea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
   20bec:	6921      	ldr	r1, [r4, #16]
   20bee:	e7e0      	b.n	20bb2 <z_impl_k_mutex_lock+0x8a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   20bf0:	f990 300e 	ldrsb.w	r3, [r0, #14]
   20bf4:	f991 100e 	ldrsb.w	r1, [r1, #14]
   20bf8:	4299      	cmp	r1, r3
   20bfa:	bfa8      	it	ge
   20bfc:	4619      	movge	r1, r3
   20bfe:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   20c02:	428b      	cmp	r3, r1
   20c04:	dd40      	ble.n	20c88 <z_impl_k_mutex_lock+0x160>
		return z_set_prio(mutex->owner, new_prio);
   20c06:	f001 fa9b 	bl	22140 <z_set_prio>
   20c0a:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   20c0c:	482d      	ldr	r0, [pc, #180]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20c0e:	4633      	mov	r3, r6
   20c10:	4622      	mov	r2, r4
   20c12:	4639      	mov	r1, r7
   20c14:	f001 fa66 	bl	220e4 <z_pend_curr>
	if (got_mutex == 0) {
   20c18:	2800      	cmp	r0, #0
   20c1a:	d0e6      	beq.n	20bea <z_impl_k_mutex_lock+0xc2>
	__asm__ volatile(
   20c1c:	f04f 0320 	mov.w	r3, #32
   20c20:	f3ef 8611 	mrs	r6, BASEPRI
   20c24:	f383 8811 	msr	BASEPRI, r3
   20c28:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   20c2c:	4825      	ldr	r0, [pc, #148]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20c2e:	f001 ff4d 	bl	22acc <z_spin_lock_valid>
   20c32:	b968      	cbnz	r0, 20c50 <z_impl_k_mutex_lock+0x128>
   20c34:	4a24      	ldr	r2, [pc, #144]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20c36:	4925      	ldr	r1, [pc, #148]	; (20ccc <z_impl_k_mutex_lock+0x1a4>)
   20c38:	4825      	ldr	r0, [pc, #148]	; (20cd0 <z_impl_k_mutex_lock+0x1a8>)
   20c3a:	234a      	movs	r3, #74	; 0x4a
   20c3c:	f003 f951 	bl	23ee2 <printk>
   20c40:	4920      	ldr	r1, [pc, #128]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20c42:	4824      	ldr	r0, [pc, #144]	; (20cd4 <z_impl_k_mutex_lock+0x1ac>)
   20c44:	f003 f94d 	bl	23ee2 <printk>
   20c48:	481f      	ldr	r0, [pc, #124]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20c4a:	214a      	movs	r1, #74	; 0x4a
   20c4c:	f003 f98c 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   20c50:	481c      	ldr	r0, [pc, #112]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20c52:	f001 ff59 	bl	22b08 <z_spin_lock_set_owner>
	return list->head == list;
   20c56:	6823      	ldr	r3, [r4, #0]
   20c58:	6921      	ldr	r1, [r4, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   20c5a:	429c      	cmp	r4, r3
   20c5c:	d007      	beq.n	20c6e <z_impl_k_mutex_lock+0x146>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   20c5e:	b133      	cbz	r3, 20c6e <z_impl_k_mutex_lock+0x146>
   20c60:	f993 300e 	ldrsb.w	r3, [r3, #14]
   20c64:	4299      	cmp	r1, r3
   20c66:	bfa8      	it	ge
   20c68:	4619      	movge	r1, r3
   20c6a:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   20c6e:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   20c70:	f990 300e 	ldrsb.w	r3, [r0, #14]
   20c74:	4299      	cmp	r1, r3
   20c76:	d109      	bne.n	20c8c <z_impl_k_mutex_lock+0x164>
	if (resched) {
   20c78:	b16d      	cbz	r5, 20c96 <z_impl_k_mutex_lock+0x16e>
		z_reschedule(&lock, key);
   20c7a:	4812      	ldr	r0, [pc, #72]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20c7c:	4631      	mov	r1, r6
   20c7e:	f000 fbe1 	bl	21444 <z_reschedule>
	return -EAGAIN;
   20c82:	f06f 000a 	mvn.w	r0, #10
   20c86:	e7b0      	b.n	20bea <z_impl_k_mutex_lock+0xc2>
	bool resched = false;
   20c88:	2500      	movs	r5, #0
   20c8a:	e7bf      	b.n	20c0c <z_impl_k_mutex_lock+0xe4>
		return z_set_prio(mutex->owner, new_prio);
   20c8c:	f001 fa58 	bl	22140 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   20c90:	2800      	cmp	r0, #0
   20c92:	d1f2      	bne.n	20c7a <z_impl_k_mutex_lock+0x152>
   20c94:	e7f0      	b.n	20c78 <z_impl_k_mutex_lock+0x150>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   20c96:	480b      	ldr	r0, [pc, #44]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20c98:	f001 ff26 	bl	22ae8 <z_spin_unlock_valid>
   20c9c:	b968      	cbnz	r0, 20cba <z_impl_k_mutex_lock+0x192>
   20c9e:	4a0a      	ldr	r2, [pc, #40]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20ca0:	490e      	ldr	r1, [pc, #56]	; (20cdc <z_impl_k_mutex_lock+0x1b4>)
   20ca2:	480b      	ldr	r0, [pc, #44]	; (20cd0 <z_impl_k_mutex_lock+0x1a8>)
   20ca4:	235d      	movs	r3, #93	; 0x5d
   20ca6:	f003 f91c 	bl	23ee2 <printk>
   20caa:	4906      	ldr	r1, [pc, #24]	; (20cc4 <z_impl_k_mutex_lock+0x19c>)
   20cac:	480c      	ldr	r0, [pc, #48]	; (20ce0 <z_impl_k_mutex_lock+0x1b8>)
   20cae:	f003 f918 	bl	23ee2 <printk>
   20cb2:	4805      	ldr	r0, [pc, #20]	; (20cc8 <z_impl_k_mutex_lock+0x1a0>)
   20cb4:	215d      	movs	r1, #93	; 0x5d
   20cb6:	f003 f957 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   20cba:	f386 8811 	msr	BASEPRI, r6
   20cbe:	f3bf 8f6f 	isb	sy
   20cc2:	e7de      	b.n	20c82 <z_impl_k_mutex_lock+0x15a>
   20cc4:	20001d7c 	.word	0x20001d7c
   20cc8:	0002ae90 	.word	0x0002ae90
   20ccc:	0002aeb2 	.word	0x0002aeb2
   20cd0:	0002a5e8 	.word	0x0002a5e8
   20cd4:	0002aec7 	.word	0x0002aec7
   20cd8:	20001d80 	.word	0x20001d80
   20cdc:	0002aedf 	.word	0x0002aedf
   20ce0:	0002aef6 	.word	0x0002aef6

00020ce4 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   20ce4:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *new_owner;

	CHECKIF(mutex->owner == NULL) {
   20ce6:	6883      	ldr	r3, [r0, #8]
{
   20ce8:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   20cea:	2b00      	cmp	r3, #0
   20cec:	f000 8092 	beq.w	20e14 <z_impl_k_mutex_unlock+0x130>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   20cf0:	4d4b      	ldr	r5, [pc, #300]	; (20e20 <z_impl_k_mutex_unlock+0x13c>)
   20cf2:	68aa      	ldr	r2, [r5, #8]
   20cf4:	4293      	cmp	r3, r2
   20cf6:	f040 8090 	bne.w	20e1a <z_impl_k_mutex_unlock+0x136>
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
   20cfa:	68c3      	ldr	r3, [r0, #12]
   20cfc:	b94b      	cbnz	r3, 20d12 <z_impl_k_mutex_unlock+0x2e>
   20cfe:	4949      	ldr	r1, [pc, #292]	; (20e24 <z_impl_k_mutex_unlock+0x140>)
   20d00:	4849      	ldr	r0, [pc, #292]	; (20e28 <z_impl_k_mutex_unlock+0x144>)
   20d02:	4a4a      	ldr	r2, [pc, #296]	; (20e2c <z_impl_k_mutex_unlock+0x148>)
   20d04:	23e6      	movs	r3, #230	; 0xe6
   20d06:	f003 f8ec 	bl	23ee2 <printk>
   20d0a:	4848      	ldr	r0, [pc, #288]	; (20e2c <z_impl_k_mutex_unlock+0x148>)
   20d0c:	21e6      	movs	r1, #230	; 0xe6
   20d0e:	f003 f92b 	bl	23f68 <assert_post_action>
   20d12:	f3ef 8305 	mrs	r3, IPSR
}

static inline void z_sched_lock(void)
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
   20d16:	b173      	cbz	r3, 20d36 <z_impl_k_mutex_unlock+0x52>
   20d18:	4945      	ldr	r1, [pc, #276]	; (20e30 <z_impl_k_mutex_unlock+0x14c>)
   20d1a:	4a46      	ldr	r2, [pc, #280]	; (20e34 <z_impl_k_mutex_unlock+0x150>)
   20d1c:	4842      	ldr	r0, [pc, #264]	; (20e28 <z_impl_k_mutex_unlock+0x144>)
   20d1e:	f240 130b 	movw	r3, #267	; 0x10b
   20d22:	f003 f8de 	bl	23ee2 <printk>
   20d26:	4844      	ldr	r0, [pc, #272]	; (20e38 <z_impl_k_mutex_unlock+0x154>)
   20d28:	f003 f8db 	bl	23ee2 <printk>
   20d2c:	4841      	ldr	r0, [pc, #260]	; (20e34 <z_impl_k_mutex_unlock+0x150>)
   20d2e:	f240 110b 	movw	r1, #267	; 0x10b
   20d32:	f003 f919 	bl	23f68 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   20d36:	68ab      	ldr	r3, [r5, #8]
   20d38:	7bdb      	ldrb	r3, [r3, #15]
   20d3a:	2b01      	cmp	r3, #1
   20d3c:	d10e      	bne.n	20d5c <z_impl_k_mutex_unlock+0x78>
   20d3e:	493f      	ldr	r1, [pc, #252]	; (20e3c <z_impl_k_mutex_unlock+0x158>)
   20d40:	4a3c      	ldr	r2, [pc, #240]	; (20e34 <z_impl_k_mutex_unlock+0x150>)
   20d42:	4839      	ldr	r0, [pc, #228]	; (20e28 <z_impl_k_mutex_unlock+0x144>)
   20d44:	f44f 7386 	mov.w	r3, #268	; 0x10c
   20d48:	f003 f8cb 	bl	23ee2 <printk>
   20d4c:	483a      	ldr	r0, [pc, #232]	; (20e38 <z_impl_k_mutex_unlock+0x154>)
   20d4e:	f003 f8c8 	bl	23ee2 <printk>
   20d52:	4838      	ldr	r0, [pc, #224]	; (20e34 <z_impl_k_mutex_unlock+0x150>)
   20d54:	f44f 7186 	mov.w	r1, #268	; 0x10c
   20d58:	f003 f906 	bl	23f68 <assert_post_action>

	--_current->base.sched_locked;
   20d5c:	68aa      	ldr	r2, [r5, #8]
   20d5e:	7bd3      	ldrb	r3, [r2, #15]
   20d60:	3b01      	subs	r3, #1
   20d62:	73d3      	strb	r3, [r2, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
   20d64:	68e3      	ldr	r3, [r4, #12]
   20d66:	2b01      	cmp	r3, #1
   20d68:	d005      	beq.n	20d76 <z_impl_k_mutex_unlock+0x92>
		mutex->lock_count--;
   20d6a:	3b01      	subs	r3, #1
   20d6c:	60e3      	str	r3, [r4, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
   20d6e:	f000 fcc5 	bl	216fc <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
   20d72:	2000      	movs	r0, #0
}
   20d74:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   20d76:	f04f 0320 	mov.w	r3, #32
   20d7a:	f3ef 8511 	mrs	r5, BASEPRI
   20d7e:	f383 8811 	msr	BASEPRI, r3
   20d82:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   20d86:	482e      	ldr	r0, [pc, #184]	; (20e40 <z_impl_k_mutex_unlock+0x15c>)
   20d88:	f001 fea0 	bl	22acc <z_spin_lock_valid>
   20d8c:	b968      	cbnz	r0, 20daa <z_impl_k_mutex_unlock+0xc6>
   20d8e:	4a2d      	ldr	r2, [pc, #180]	; (20e44 <z_impl_k_mutex_unlock+0x160>)
   20d90:	492d      	ldr	r1, [pc, #180]	; (20e48 <z_impl_k_mutex_unlock+0x164>)
   20d92:	4825      	ldr	r0, [pc, #148]	; (20e28 <z_impl_k_mutex_unlock+0x144>)
   20d94:	234a      	movs	r3, #74	; 0x4a
   20d96:	f003 f8a4 	bl	23ee2 <printk>
   20d9a:	4929      	ldr	r1, [pc, #164]	; (20e40 <z_impl_k_mutex_unlock+0x15c>)
   20d9c:	482b      	ldr	r0, [pc, #172]	; (20e4c <z_impl_k_mutex_unlock+0x168>)
   20d9e:	f003 f8a0 	bl	23ee2 <printk>
   20da2:	4828      	ldr	r0, [pc, #160]	; (20e44 <z_impl_k_mutex_unlock+0x160>)
   20da4:	214a      	movs	r1, #74	; 0x4a
   20da6:	f003 f8df 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   20daa:	4825      	ldr	r0, [pc, #148]	; (20e40 <z_impl_k_mutex_unlock+0x15c>)
   20dac:	f001 feac 	bl	22b08 <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   20db0:	68a0      	ldr	r0, [r4, #8]
   20db2:	6921      	ldr	r1, [r4, #16]
	if (mutex->owner->base.prio != new_prio) {
   20db4:	f990 300e 	ldrsb.w	r3, [r0, #14]
   20db8:	4299      	cmp	r1, r3
   20dba:	d001      	beq.n	20dc0 <z_impl_k_mutex_unlock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   20dbc:	f001 f9c0 	bl	22140 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   20dc0:	4620      	mov	r0, r4
   20dc2:	f001 fa53 	bl	2226c <z_unpend_first_thread>
	mutex->owner = new_owner;
   20dc6:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   20dc8:	b160      	cbz	r0, 20de4 <z_impl_k_mutex_unlock+0x100>
		mutex->owner_orig_prio = new_owner->base.prio;
   20dca:	f990 200e 	ldrsb.w	r2, [r0, #14]
   20dce:	6122      	str	r2, [r4, #16]
   20dd0:	2200      	movs	r2, #0
   20dd2:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
		z_ready_thread(new_owner);
   20dd6:	f000 fd5b 	bl	21890 <z_ready_thread>
		z_reschedule(&lock, key);
   20dda:	4819      	ldr	r0, [pc, #100]	; (20e40 <z_impl_k_mutex_unlock+0x15c>)
   20ddc:	4629      	mov	r1, r5
   20dde:	f000 fb31 	bl	21444 <z_reschedule>
   20de2:	e7c4      	b.n	20d6e <z_impl_k_mutex_unlock+0x8a>
		mutex->lock_count = 0U;
   20de4:	60e0      	str	r0, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   20de6:	4816      	ldr	r0, [pc, #88]	; (20e40 <z_impl_k_mutex_unlock+0x15c>)
   20de8:	f001 fe7e 	bl	22ae8 <z_spin_unlock_valid>
   20dec:	b968      	cbnz	r0, 20e0a <z_impl_k_mutex_unlock+0x126>
   20dee:	4a15      	ldr	r2, [pc, #84]	; (20e44 <z_impl_k_mutex_unlock+0x160>)
   20df0:	4917      	ldr	r1, [pc, #92]	; (20e50 <z_impl_k_mutex_unlock+0x16c>)
   20df2:	480d      	ldr	r0, [pc, #52]	; (20e28 <z_impl_k_mutex_unlock+0x144>)
   20df4:	235d      	movs	r3, #93	; 0x5d
   20df6:	f003 f874 	bl	23ee2 <printk>
   20dfa:	4911      	ldr	r1, [pc, #68]	; (20e40 <z_impl_k_mutex_unlock+0x15c>)
   20dfc:	4815      	ldr	r0, [pc, #84]	; (20e54 <z_impl_k_mutex_unlock+0x170>)
   20dfe:	f003 f870 	bl	23ee2 <printk>
   20e02:	4810      	ldr	r0, [pc, #64]	; (20e44 <z_impl_k_mutex_unlock+0x160>)
   20e04:	215d      	movs	r1, #93	; 0x5d
   20e06:	f003 f8af 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   20e0a:	f385 8811 	msr	BASEPRI, r5
   20e0e:	f3bf 8f6f 	isb	sy
   20e12:	e7ac      	b.n	20d6e <z_impl_k_mutex_unlock+0x8a>
		return -EINVAL;
   20e14:	f06f 0015 	mvn.w	r0, #21
   20e18:	e7ac      	b.n	20d74 <z_impl_k_mutex_unlock+0x90>
		return -EPERM;
   20e1a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   20e1e:	e7a9      	b.n	20d74 <z_impl_k_mutex_unlock+0x90>
   20e20:	20001d80 	.word	0x20001d80
   20e24:	0003128e 	.word	0x0003128e
   20e28:	0002a5e8 	.word	0x0002a5e8
   20e2c:	0003126c 	.word	0x0003126c
   20e30:	000312cc 	.word	0x000312cc
   20e34:	000312a5 	.word	0x000312a5
   20e38:	00030d23 	.word	0x00030d23
   20e3c:	000312de 	.word	0x000312de
   20e40:	20001d7c 	.word	0x20001d7c
   20e44:	0002ae90 	.word	0x0002ae90
   20e48:	0002aeb2 	.word	0x0002aeb2
   20e4c:	0002aec7 	.word	0x0002aec7
   20e50:	0002aedf 	.word	0x0002aedf
   20e54:	0002aef6 	.word	0x0002aef6

00020e58 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   20e58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   20e5c:	4604      	mov	r4, r0
   20e5e:	460e      	mov	r6, r1
   20e60:	4690      	mov	r8, r2
   20e62:	4699      	mov	r9, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   20e64:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   20e68:	f04f 0320 	mov.w	r3, #32
   20e6c:	f3ef 8711 	mrs	r7, BASEPRI
   20e70:	f383 8811 	msr	BASEPRI, r3
   20e74:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   20e78:	4628      	mov	r0, r5
   20e7a:	f001 fe27 	bl	22acc <z_spin_lock_valid>
   20e7e:	b968      	cbnz	r0, 20e9c <queue_insert+0x44>
   20e80:	4a33      	ldr	r2, [pc, #204]	; (20f50 <queue_insert+0xf8>)
   20e82:	4934      	ldr	r1, [pc, #208]	; (20f54 <queue_insert+0xfc>)
   20e84:	4834      	ldr	r0, [pc, #208]	; (20f58 <queue_insert+0x100>)
   20e86:	234a      	movs	r3, #74	; 0x4a
   20e88:	f003 f82b 	bl	23ee2 <printk>
   20e8c:	4833      	ldr	r0, [pc, #204]	; (20f5c <queue_insert+0x104>)
   20e8e:	4629      	mov	r1, r5
   20e90:	f003 f827 	bl	23ee2 <printk>
   20e94:	482e      	ldr	r0, [pc, #184]	; (20f50 <queue_insert+0xf8>)
   20e96:	214a      	movs	r1, #74	; 0x4a
   20e98:	f003 f866 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   20e9c:	4628      	mov	r0, r5
   20e9e:	f001 fe33 	bl	22b08 <z_spin_lock_set_owner>
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   20ea2:	f1b9 0f00 	cmp.w	r9, #0
   20ea6:	d02d      	beq.n	20f04 <queue_insert+0xac>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   20ea8:	2008      	movs	r0, #8
   20eaa:	f7ff fe29 	bl	20b00 <z_thread_malloc>
		if (anode == NULL) {
   20eae:	b9c8      	cbnz	r0, 20ee4 <queue_insert+0x8c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   20eb0:	4628      	mov	r0, r5
   20eb2:	f001 fe19 	bl	22ae8 <z_spin_unlock_valid>
   20eb6:	b968      	cbnz	r0, 20ed4 <queue_insert+0x7c>
   20eb8:	4a25      	ldr	r2, [pc, #148]	; (20f50 <queue_insert+0xf8>)
   20eba:	4929      	ldr	r1, [pc, #164]	; (20f60 <queue_insert+0x108>)
   20ebc:	4826      	ldr	r0, [pc, #152]	; (20f58 <queue_insert+0x100>)
   20ebe:	235d      	movs	r3, #93	; 0x5d
   20ec0:	f003 f80f 	bl	23ee2 <printk>
   20ec4:	4827      	ldr	r0, [pc, #156]	; (20f64 <queue_insert+0x10c>)
   20ec6:	4629      	mov	r1, r5
   20ec8:	f003 f80b 	bl	23ee2 <printk>
   20ecc:	4820      	ldr	r0, [pc, #128]	; (20f50 <queue_insert+0xf8>)
   20ece:	215d      	movs	r1, #93	; 0x5d
   20ed0:	f003 f84a 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   20ed4:	f387 8811 	msr	BASEPRI, r7
   20ed8:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   20edc:	f06f 000b 	mvn.w	r0, #11
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
	return 0;
}
   20ee0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, u8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
   20ee4:	2301      	movs	r3, #1
		anode->data = data;
   20ee6:	f8c0 8004 	str.w	r8, [r0, #4]
   20eea:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   20eec:	6803      	ldr	r3, [r0, #0]
   20eee:	f003 0203 	and.w	r2, r3, #3
   20ef2:	b95e      	cbnz	r6, 20f0c <queue_insert+0xb4>
	parent->next_and_flags = cur_flags | (unative_t)child;
   20ef4:	6823      	ldr	r3, [r4, #0]
   20ef6:	4313      	orrs	r3, r2
   20ef8:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   20efa:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   20efc:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   20efe:	b973      	cbnz	r3, 20f1e <queue_insert+0xc6>
	list->tail = node;
   20f00:	6060      	str	r0, [r4, #4]
}
   20f02:	e00c      	b.n	20f1e <queue_insert+0xc6>
	node->next_and_flags = flags;
   20f04:	f8c8 9000 	str.w	r9, [r8]
}
   20f08:	4640      	mov	r0, r8
   20f0a:	e7ef      	b.n	20eec <queue_insert+0x94>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   20f0c:	6833      	ldr	r3, [r6, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   20f0e:	f033 0303 	bics.w	r3, r3, #3
   20f12:	d115      	bne.n	20f40 <queue_insert+0xe8>
	parent->next_and_flags = cur_flags | (unative_t)child;
   20f14:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   20f16:	6862      	ldr	r2, [r4, #4]
   20f18:	b962      	cbnz	r2, 20f34 <queue_insert+0xdc>
	list->head = node;
   20f1a:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   20f1e:	2104      	movs	r1, #4
   20f20:	f104 000c 	add.w	r0, r4, #12
   20f24:	f008 fb18 	bl	29558 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   20f28:	4628      	mov	r0, r5
   20f2a:	4639      	mov	r1, r7
   20f2c:	f000 fa8a 	bl	21444 <z_reschedule>
	return 0;
   20f30:	2000      	movs	r0, #0
   20f32:	e7d5      	b.n	20ee0 <queue_insert+0x88>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   20f34:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   20f36:	f003 0303 	and.w	r3, r3, #3
   20f3a:	4303      	orrs	r3, r0
   20f3c:	6013      	str	r3, [r2, #0]
   20f3e:	e7df      	b.n	20f00 <queue_insert+0xa8>
   20f40:	4313      	orrs	r3, r2
   20f42:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   20f44:	6833      	ldr	r3, [r6, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   20f46:	f003 0303 	and.w	r3, r3, #3
   20f4a:	4303      	orrs	r3, r0
   20f4c:	6033      	str	r3, [r6, #0]
}
   20f4e:	e7e6      	b.n	20f1e <queue_insert+0xc6>
   20f50:	0002ae90 	.word	0x0002ae90
   20f54:	0002aeb2 	.word	0x0002aeb2
   20f58:	0002a5e8 	.word	0x0002a5e8
   20f5c:	0002aec7 	.word	0x0002aec7
   20f60:	0002aedf 	.word	0x0002aedf
   20f64:	0002aef6 	.word	0x0002aef6

00020f68 <z_impl_k_queue_cancel_wait>:
{
   20f68:	b570      	push	{r4, r5, r6, lr}
   20f6a:	4605      	mov	r5, r0
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   20f6c:	f100 0408 	add.w	r4, r0, #8
	__asm__ volatile(
   20f70:	f04f 0320 	mov.w	r3, #32
   20f74:	f3ef 8611 	mrs	r6, BASEPRI
   20f78:	f383 8811 	msr	BASEPRI, r3
   20f7c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   20f80:	4620      	mov	r0, r4
   20f82:	f001 fda3 	bl	22acc <z_spin_lock_valid>
   20f86:	b968      	cbnz	r0, 20fa4 <z_impl_k_queue_cancel_wait+0x3c>
   20f88:	4a0d      	ldr	r2, [pc, #52]	; (20fc0 <z_impl_k_queue_cancel_wait+0x58>)
   20f8a:	490e      	ldr	r1, [pc, #56]	; (20fc4 <z_impl_k_queue_cancel_wait+0x5c>)
   20f8c:	480e      	ldr	r0, [pc, #56]	; (20fc8 <z_impl_k_queue_cancel_wait+0x60>)
   20f8e:	234a      	movs	r3, #74	; 0x4a
   20f90:	f002 ffa7 	bl	23ee2 <printk>
   20f94:	480d      	ldr	r0, [pc, #52]	; (20fcc <z_impl_k_queue_cancel_wait+0x64>)
   20f96:	4621      	mov	r1, r4
   20f98:	f002 ffa3 	bl	23ee2 <printk>
   20f9c:	4808      	ldr	r0, [pc, #32]	; (20fc0 <z_impl_k_queue_cancel_wait+0x58>)
   20f9e:	214a      	movs	r1, #74	; 0x4a
   20fa0:	f002 ffe2 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   20fa4:	4620      	mov	r0, r4
   20fa6:	f001 fdaf 	bl	22b08 <z_spin_lock_set_owner>
	z_handle_obj_poll_events(&queue->poll_events, state);
   20faa:	f105 000c 	add.w	r0, r5, #12
   20fae:	2108      	movs	r1, #8
   20fb0:	f008 fad2 	bl	29558 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   20fb4:	4631      	mov	r1, r6
   20fb6:	4620      	mov	r0, r4
}
   20fb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&queue->lock, key);
   20fbc:	f000 ba42 	b.w	21444 <z_reschedule>
   20fc0:	0002ae90 	.word	0x0002ae90
   20fc4:	0002aeb2 	.word	0x0002aeb2
   20fc8:	0002a5e8 	.word	0x0002a5e8
   20fcc:	0002aec7 	.word	0x0002aec7

00020fd0 <k_queue_append_list>:
}
#include <syscalls/k_queue_alloc_prepend_mrsh.c>
#endif

int k_queue_append_list(struct k_queue *queue, void *head, void *tail)
{
   20fd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20fd4:	4604      	mov	r4, r0
   20fd6:	4617      	mov	r7, r2
	/* invalid head or tail of list */
	CHECKIF(head == NULL || tail == NULL) {
   20fd8:	460d      	mov	r5, r1
   20fda:	2900      	cmp	r1, #0
   20fdc:	d036      	beq.n	2104c <k_queue_append_list+0x7c>
   20fde:	2a00      	cmp	r2, #0
   20fe0:	d034      	beq.n	2104c <k_queue_append_list+0x7c>
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   20fe2:	f100 0608 	add.w	r6, r0, #8
   20fe6:	f04f 0320 	mov.w	r3, #32
   20fea:	f3ef 8811 	mrs	r8, BASEPRI
   20fee:	f383 8811 	msr	BASEPRI, r3
   20ff2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   20ff6:	4630      	mov	r0, r6
   20ff8:	f001 fd68 	bl	22acc <z_spin_lock_valid>
   20ffc:	b968      	cbnz	r0, 2101a <k_queue_append_list+0x4a>
   20ffe:	4a15      	ldr	r2, [pc, #84]	; (21054 <k_queue_append_list+0x84>)
   21000:	4915      	ldr	r1, [pc, #84]	; (21058 <k_queue_append_list+0x88>)
   21002:	4816      	ldr	r0, [pc, #88]	; (2105c <k_queue_append_list+0x8c>)
   21004:	234a      	movs	r3, #74	; 0x4a
   21006:	f002 ff6c 	bl	23ee2 <printk>
   2100a:	4815      	ldr	r0, [pc, #84]	; (21060 <k_queue_append_list+0x90>)
   2100c:	4631      	mov	r1, r6
   2100e:	f002 ff68 	bl	23ee2 <printk>
   21012:	4810      	ldr	r0, [pc, #64]	; (21054 <k_queue_append_list+0x84>)
   21014:	214a      	movs	r1, #74	; 0x4a
   21016:	f002 ffa7 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   2101a:	4630      	mov	r0, r6
   2101c:	f001 fd74 	bl	22b08 <z_spin_lock_set_owner>
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   21020:	6863      	ldr	r3, [r4, #4]
   21022:	b96b      	cbnz	r3, 21040 <k_queue_append_list+0x70>
	list->head = node;
   21024:	6025      	str	r5, [r4, #0]
	z_handle_obj_poll_events(&queue->poll_events, state);
   21026:	2104      	movs	r1, #4
   21028:	f104 000c 	add.w	r0, r4, #12
	list->tail = node;
   2102c:	6067      	str	r7, [r4, #4]
   2102e:	f008 fa93 	bl	29558 <z_handle_obj_poll_events>
#else
	sys_sflist_append_list(&queue->data_q, head, tail);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* !CONFIG_POLL */

	z_reschedule(&queue->lock, key);
   21032:	4630      	mov	r0, r6
   21034:	4641      	mov	r1, r8
   21036:	f000 fa05 	bl	21444 <z_reschedule>

	return 0;
   2103a:	2000      	movs	r0, #0
}
   2103c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   21040:	6819      	ldr	r1, [r3, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   21042:	f001 0103 	and.w	r1, r1, #3
   21046:	430d      	orrs	r5, r1
   21048:	601d      	str	r5, [r3, #0]
}
   2104a:	e7ec      	b.n	21026 <k_queue_append_list+0x56>
		return -EINVAL;
   2104c:	f06f 0015 	mvn.w	r0, #21
   21050:	e7f4      	b.n	2103c <k_queue_append_list+0x6c>
   21052:	bf00      	nop
   21054:	0002ae90 	.word	0x0002ae90
   21058:	0002aeb2 	.word	0x0002aeb2
   2105c:	0002a5e8 	.word	0x0002a5e8
   21060:	0002aec7 	.word	0x0002aec7

00021064 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   21064:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21068:	4605      	mov	r5, r0
   2106a:	b086      	sub	sp, #24
   2106c:	460f      	mov	r7, r1
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2106e:	f100 0408 	add.w	r4, r0, #8
   21072:	f04f 0320 	mov.w	r3, #32
   21076:	f3ef 8811 	mrs	r8, BASEPRI
   2107a:	f383 8811 	msr	BASEPRI, r3
   2107e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21082:	4620      	mov	r0, r4
   21084:	f001 fd22 	bl	22acc <z_spin_lock_valid>
   21088:	b968      	cbnz	r0, 210a6 <z_impl_k_queue_get+0x42>
   2108a:	4a53      	ldr	r2, [pc, #332]	; (211d8 <z_impl_k_queue_get+0x174>)
   2108c:	4953      	ldr	r1, [pc, #332]	; (211dc <z_impl_k_queue_get+0x178>)
   2108e:	4854      	ldr	r0, [pc, #336]	; (211e0 <z_impl_k_queue_get+0x17c>)
   21090:	234a      	movs	r3, #74	; 0x4a
   21092:	f002 ff26 	bl	23ee2 <printk>
   21096:	4853      	ldr	r0, [pc, #332]	; (211e4 <z_impl_k_queue_get+0x180>)
   21098:	4621      	mov	r1, r4
   2109a:	f002 ff22 	bl	23ee2 <printk>
   2109e:	484e      	ldr	r0, [pc, #312]	; (211d8 <z_impl_k_queue_get+0x174>)
   210a0:	214a      	movs	r1, #74	; 0x4a
   210a2:	f002 ff61 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   210a6:	4620      	mov	r0, r4
   210a8:	f001 fd2e 	bl	22b08 <z_spin_lock_set_owner>
Z_GENLIST_IS_EMPTY(sflist)
   210ac:	682e      	ldr	r6, [r5, #0]
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   210ae:	b336      	cbz	r6, 210fe <z_impl_k_queue_get+0x9a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   210b0:	6833      	ldr	r3, [r6, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   210b2:	686a      	ldr	r2, [r5, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   210b4:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   210b8:	4296      	cmp	r6, r2
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   210ba:	4630      	mov	r0, r6
	list->head = node;
   210bc:	602b      	str	r3, [r5, #0]
	list->tail = node;
   210be:	bf08      	it	eq
   210c0:	606b      	streq	r3, [r5, #4]
   210c2:	2101      	movs	r1, #1
   210c4:	f008 f8b0 	bl	29228 <z_queue_node_peek>
   210c8:	4606      	mov	r6, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   210ca:	4620      	mov	r0, r4
   210cc:	f001 fd0c 	bl	22ae8 <z_spin_unlock_valid>
   210d0:	b968      	cbnz	r0, 210ee <z_impl_k_queue_get+0x8a>
   210d2:	4a41      	ldr	r2, [pc, #260]	; (211d8 <z_impl_k_queue_get+0x174>)
   210d4:	4944      	ldr	r1, [pc, #272]	; (211e8 <z_impl_k_queue_get+0x184>)
   210d6:	4842      	ldr	r0, [pc, #264]	; (211e0 <z_impl_k_queue_get+0x17c>)
   210d8:	235d      	movs	r3, #93	; 0x5d
   210da:	f002 ff02 	bl	23ee2 <printk>
   210de:	4843      	ldr	r0, [pc, #268]	; (211ec <z_impl_k_queue_get+0x188>)
   210e0:	4621      	mov	r1, r4
   210e2:	f002 fefe 	bl	23ee2 <printk>
   210e6:	483c      	ldr	r0, [pc, #240]	; (211d8 <z_impl_k_queue_get+0x174>)
   210e8:	215d      	movs	r1, #93	; 0x5d
   210ea:	f002 ff3d 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   210ee:	f388 8811 	msr	BASEPRI, r8
   210f2:	f3bf 8f6f 	isb	sy
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   210f6:	4630      	mov	r0, r6
   210f8:	b006      	add	sp, #24
   210fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   210fe:	4620      	mov	r0, r4
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   21100:	2f00      	cmp	r7, #0
   21102:	d0e3      	beq.n	210cc <z_impl_k_queue_get+0x68>
   21104:	f001 fcf0 	bl	22ae8 <z_spin_unlock_valid>
   21108:	b968      	cbnz	r0, 21126 <z_impl_k_queue_get+0xc2>
   2110a:	4a33      	ldr	r2, [pc, #204]	; (211d8 <z_impl_k_queue_get+0x174>)
   2110c:	4936      	ldr	r1, [pc, #216]	; (211e8 <z_impl_k_queue_get+0x184>)
   2110e:	4834      	ldr	r0, [pc, #208]	; (211e0 <z_impl_k_queue_get+0x17c>)
   21110:	235d      	movs	r3, #93	; 0x5d
   21112:	f002 fee6 	bl	23ee2 <printk>
   21116:	4835      	ldr	r0, [pc, #212]	; (211ec <z_impl_k_queue_get+0x188>)
   21118:	4621      	mov	r1, r4
   2111a:	f002 fee2 	bl	23ee2 <printk>
   2111e:	482e      	ldr	r0, [pc, #184]	; (211d8 <z_impl_k_queue_get+0x174>)
   21120:	215d      	movs	r1, #93	; 0x5d
   21122:	f002 ff21 	bl	23f68 <assert_post_action>
   21126:	f388 8811 	msr	BASEPRI, r8
   2112a:	f3bf 8f6f 	isb	sy
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   2112e:	2104      	movs	r1, #4
   21130:	462b      	mov	r3, r5
   21132:	2200      	movs	r2, #0
   21134:	eb0d 0001 	add.w	r0, sp, r1
   21138:	f002 fb62 	bl	23800 <k_poll_event_init>
	event.state = K_POLL_STATE_NOT_READY;
   2113c:	9b04      	ldr	r3, [sp, #16]
   2113e:	f36f 3310 	bfc	r3, #12, #5
   21142:	9304      	str	r3, [sp, #16]
	return z_impl_k_poll(events, num_events, timeout);
   21144:	2101      	movs	r1, #1
   21146:	463a      	mov	r2, r7
   21148:	a801      	add	r0, sp, #4
   2114a:	f002 fba7 	bl	2389c <z_impl_k_poll>
	if (err && err != -EAGAIN) {
   2114e:	b108      	cbz	r0, 21154 <z_impl_k_queue_get+0xf0>
   21150:	300b      	adds	r0, #11
   21152:	d1d0      	bne.n	210f6 <z_impl_k_queue_get+0x92>
	__asm__ volatile(
   21154:	f04f 0320 	mov.w	r3, #32
   21158:	f3ef 8711 	mrs	r7, BASEPRI
   2115c:	f383 8811 	msr	BASEPRI, r3
   21160:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21164:	4620      	mov	r0, r4
   21166:	f001 fcb1 	bl	22acc <z_spin_lock_valid>
   2116a:	b968      	cbnz	r0, 21188 <z_impl_k_queue_get+0x124>
   2116c:	4a1a      	ldr	r2, [pc, #104]	; (211d8 <z_impl_k_queue_get+0x174>)
   2116e:	491b      	ldr	r1, [pc, #108]	; (211dc <z_impl_k_queue_get+0x178>)
   21170:	481b      	ldr	r0, [pc, #108]	; (211e0 <z_impl_k_queue_get+0x17c>)
   21172:	234a      	movs	r3, #74	; 0x4a
   21174:	f002 feb5 	bl	23ee2 <printk>
   21178:	481a      	ldr	r0, [pc, #104]	; (211e4 <z_impl_k_queue_get+0x180>)
   2117a:	4621      	mov	r1, r4
   2117c:	f002 feb1 	bl	23ee2 <printk>
   21180:	4815      	ldr	r0, [pc, #84]	; (211d8 <z_impl_k_queue_get+0x174>)
   21182:	214a      	movs	r1, #74	; 0x4a
   21184:	f002 fef0 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21188:	4620      	mov	r0, r4
   2118a:	f001 fcbd 	bl	22b08 <z_spin_lock_set_owner>
Z_GENLIST_IS_EMPTY(sflist)
   2118e:	6828      	ldr	r0, [r5, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   21190:	b138      	cbz	r0, 211a2 <z_impl_k_queue_get+0x13e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   21192:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   21194:	686a      	ldr	r2, [r5, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   21196:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2119a:	4290      	cmp	r0, r2
	list->head = node;
   2119c:	602b      	str	r3, [r5, #0]
	list->tail = node;
   2119e:	bf08      	it	eq
   211a0:	606b      	streq	r3, [r5, #4]
	val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   211a2:	2101      	movs	r1, #1
   211a4:	f008 f840 	bl	29228 <z_queue_node_peek>
   211a8:	4606      	mov	r6, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   211aa:	4620      	mov	r0, r4
   211ac:	f001 fc9c 	bl	22ae8 <z_spin_unlock_valid>
   211b0:	b968      	cbnz	r0, 211ce <z_impl_k_queue_get+0x16a>
   211b2:	4a09      	ldr	r2, [pc, #36]	; (211d8 <z_impl_k_queue_get+0x174>)
   211b4:	490c      	ldr	r1, [pc, #48]	; (211e8 <z_impl_k_queue_get+0x184>)
   211b6:	480a      	ldr	r0, [pc, #40]	; (211e0 <z_impl_k_queue_get+0x17c>)
   211b8:	235d      	movs	r3, #93	; 0x5d
   211ba:	f002 fe92 	bl	23ee2 <printk>
   211be:	480b      	ldr	r0, [pc, #44]	; (211ec <z_impl_k_queue_get+0x188>)
   211c0:	4621      	mov	r1, r4
   211c2:	f002 fe8e 	bl	23ee2 <printk>
   211c6:	4804      	ldr	r0, [pc, #16]	; (211d8 <z_impl_k_queue_get+0x174>)
   211c8:	215d      	movs	r1, #93	; 0x5d
   211ca:	f002 fecd 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   211ce:	f387 8811 	msr	BASEPRI, r7
   211d2:	f3bf 8f6f 	isb	sy
	return k_queue_poll(queue, timeout);
   211d6:	e78e      	b.n	210f6 <z_impl_k_queue_get+0x92>
   211d8:	0002ae90 	.word	0x0002ae90
   211dc:	0002aeb2 	.word	0x0002aeb2
   211e0:	0002a5e8 	.word	0x0002a5e8
   211e4:	0002aec7 	.word	0x0002aec7
   211e8:	0002aedf 	.word	0x0002aedf
   211ec:	0002aef6 	.word	0x0002aef6

000211f0 <pended_on.isra.0>:
#include <syscalls/k_thread_resume_mrsh.c>
#endif

static _wait_q_t *pended_on(struct k_thread *thread)
{
	__ASSERT_NO_MSG(thread->base.pended_on);
   211f0:	6803      	ldr	r3, [r0, #0]
static _wait_q_t *pended_on(struct k_thread *thread)
   211f2:	b510      	push	{r4, lr}
   211f4:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(thread->base.pended_on);
   211f6:	b95b      	cbnz	r3, 21210 <pended_on.isra.0+0x20>
   211f8:	4906      	ldr	r1, [pc, #24]	; (21214 <pended_on.isra.0+0x24>)
   211fa:	4807      	ldr	r0, [pc, #28]	; (21218 <pended_on.isra.0+0x28>)
   211fc:	4a07      	ldr	r2, [pc, #28]	; (2121c <pended_on.isra.0+0x2c>)
   211fe:	f240 13d9 	movw	r3, #473	; 0x1d9
   21202:	f002 fe6e 	bl	23ee2 <printk>
   21206:	4805      	ldr	r0, [pc, #20]	; (2121c <pended_on.isra.0+0x2c>)
   21208:	f240 11d9 	movw	r1, #473	; 0x1d9
   2120c:	f002 feac 	bl	23f68 <assert_post_action>

	return thread->base.pended_on;
}
   21210:	6820      	ldr	r0, [r4, #0]
   21212:	bd10      	pop	{r4, pc}
   21214:	00031328 	.word	0x00031328
   21218:	0002a5e8 	.word	0x0002a5e8
   2121c:	00031306 	.word	0x00031306

00021220 <z_reset_time_slice>:
{
   21220:	b510      	push	{r4, lr}
	if (slice_time != 0) {
   21222:	4c08      	ldr	r4, [pc, #32]	; (21244 <z_reset_time_slice+0x24>)
   21224:	6823      	ldr	r3, [r4, #0]
   21226:	b15b      	cbz	r3, 21240 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   21228:	f7e3 f876 	bl	4318 <z_clock_elapsed>
   2122c:	4603      	mov	r3, r0
   2122e:	6820      	ldr	r0, [r4, #0]
   21230:	4a05      	ldr	r2, [pc, #20]	; (21248 <z_reset_time_slice+0x28>)
   21232:	4403      	add	r3, r0
}
   21234:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   21238:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   2123a:	2100      	movs	r1, #0
   2123c:	f001 bf4e 	b.w	230dc <z_set_timeout_expiry>
}
   21240:	bd10      	pop	{r4, pc}
   21242:	bf00      	nop
   21244:	20001dbc 	.word	0x20001dbc
   21248:	20001d80 	.word	0x20001d80

0002124c <k_sched_time_slice_set>:
{
   2124c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2124e:	4605      	mov	r5, r0
   21250:	460c      	mov	r4, r1
	__asm__ volatile(
   21252:	f04f 0320 	mov.w	r3, #32
   21256:	f3ef 8611 	mrs	r6, BASEPRI
   2125a:	f383 8811 	msr	BASEPRI, r3
   2125e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21262:	4820      	ldr	r0, [pc, #128]	; (212e4 <k_sched_time_slice_set+0x98>)
   21264:	f001 fc32 	bl	22acc <z_spin_lock_valid>
   21268:	b968      	cbnz	r0, 21286 <k_sched_time_slice_set+0x3a>
   2126a:	4a1f      	ldr	r2, [pc, #124]	; (212e8 <k_sched_time_slice_set+0x9c>)
   2126c:	491f      	ldr	r1, [pc, #124]	; (212ec <k_sched_time_slice_set+0xa0>)
   2126e:	4820      	ldr	r0, [pc, #128]	; (212f0 <k_sched_time_slice_set+0xa4>)
   21270:	234a      	movs	r3, #74	; 0x4a
   21272:	f002 fe36 	bl	23ee2 <printk>
   21276:	491b      	ldr	r1, [pc, #108]	; (212e4 <k_sched_time_slice_set+0x98>)
   21278:	481e      	ldr	r0, [pc, #120]	; (212f4 <k_sched_time_slice_set+0xa8>)
   2127a:	f002 fe32 	bl	23ee2 <printk>
   2127e:	481a      	ldr	r0, [pc, #104]	; (212e8 <k_sched_time_slice_set+0x9c>)
   21280:	214a      	movs	r1, #74	; 0x4a
   21282:	f002 fe71 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21286:	4817      	ldr	r0, [pc, #92]	; (212e4 <k_sched_time_slice_set+0x98>)
   21288:	f001 fc3e 	bl	22b08 <z_spin_lock_set_owner>
		_current_cpu->slice_ticks = 0;
   2128c:	4b1a      	ldr	r3, [pc, #104]	; (212f8 <k_sched_time_slice_set+0xac>)
   2128e:	2200      	movs	r2, #0
   21290:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   21294:	f240 30e7 	movw	r0, #999	; 0x3e7
   21298:	2100      	movs	r1, #0
   2129a:	611a      	str	r2, [r3, #16]
   2129c:	fbe7 0105 	umlal	r0, r1, r7, r5
   212a0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   212a4:	2300      	movs	r3, #0
   212a6:	f7de ff7b 	bl	1a0 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   212aa:	4b14      	ldr	r3, [pc, #80]	; (212fc <k_sched_time_slice_set+0xb0>)
   212ac:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   212ae:	4b14      	ldr	r3, [pc, #80]	; (21300 <k_sched_time_slice_set+0xb4>)
   212b0:	601c      	str	r4, [r3, #0]
		z_reset_time_slice();
   212b2:	f7ff ffb5 	bl	21220 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   212b6:	480b      	ldr	r0, [pc, #44]	; (212e4 <k_sched_time_slice_set+0x98>)
   212b8:	f001 fc16 	bl	22ae8 <z_spin_unlock_valid>
   212bc:	b968      	cbnz	r0, 212da <k_sched_time_slice_set+0x8e>
   212be:	4a0a      	ldr	r2, [pc, #40]	; (212e8 <k_sched_time_slice_set+0x9c>)
   212c0:	4910      	ldr	r1, [pc, #64]	; (21304 <k_sched_time_slice_set+0xb8>)
   212c2:	480b      	ldr	r0, [pc, #44]	; (212f0 <k_sched_time_slice_set+0xa4>)
   212c4:	235d      	movs	r3, #93	; 0x5d
   212c6:	f002 fe0c 	bl	23ee2 <printk>
   212ca:	4906      	ldr	r1, [pc, #24]	; (212e4 <k_sched_time_slice_set+0x98>)
   212cc:	480e      	ldr	r0, [pc, #56]	; (21308 <k_sched_time_slice_set+0xbc>)
   212ce:	f002 fe08 	bl	23ee2 <printk>
   212d2:	4805      	ldr	r0, [pc, #20]	; (212e8 <k_sched_time_slice_set+0x9c>)
   212d4:	215d      	movs	r1, #93	; 0x5d
   212d6:	f002 fe47 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   212da:	f386 8811 	msr	BASEPRI, r6
   212de:	f3bf 8f6f 	isb	sy
}
   212e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   212e4:	20001db4 	.word	0x20001db4
   212e8:	0002ae90 	.word	0x0002ae90
   212ec:	0002aeb2 	.word	0x0002aeb2
   212f0:	0002a5e8 	.word	0x0002a5e8
   212f4:	0002aec7 	.word	0x0002aec7
   212f8:	20001d80 	.word	0x20001d80
   212fc:	20001dbc 	.word	0x20001dbc
   21300:	20001db8 	.word	0x20001db8
   21304:	0002aedf 	.word	0x0002aedf
   21308:	0002aef6 	.word	0x0002aef6

0002130c <z_find_first_thread_to_unpend>:
	pend(thread, wait_q, timeout);
}

ALWAYS_INLINE struct k_thread *z_find_first_thread_to_unpend(_wait_q_t *wait_q,
						     struct k_thread *from)
{
   2130c:	b538      	push	{r3, r4, r5, lr}
   2130e:	4604      	mov	r4, r0
	__asm__ volatile(
   21310:	f04f 0320 	mov.w	r3, #32
   21314:	f3ef 8511 	mrs	r5, BASEPRI
   21318:	f383 8811 	msr	BASEPRI, r3
   2131c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21320:	4818      	ldr	r0, [pc, #96]	; (21384 <z_find_first_thread_to_unpend+0x78>)
   21322:	f001 fbd3 	bl	22acc <z_spin_lock_valid>
   21326:	b968      	cbnz	r0, 21344 <z_find_first_thread_to_unpend+0x38>
   21328:	4a17      	ldr	r2, [pc, #92]	; (21388 <z_find_first_thread_to_unpend+0x7c>)
   2132a:	4918      	ldr	r1, [pc, #96]	; (2138c <z_find_first_thread_to_unpend+0x80>)
   2132c:	4818      	ldr	r0, [pc, #96]	; (21390 <z_find_first_thread_to_unpend+0x84>)
   2132e:	234a      	movs	r3, #74	; 0x4a
   21330:	f002 fdd7 	bl	23ee2 <printk>
   21334:	4913      	ldr	r1, [pc, #76]	; (21384 <z_find_first_thread_to_unpend+0x78>)
   21336:	4817      	ldr	r0, [pc, #92]	; (21394 <z_find_first_thread_to_unpend+0x88>)
   21338:	f002 fdd3 	bl	23ee2 <printk>
   2133c:	4812      	ldr	r0, [pc, #72]	; (21388 <z_find_first_thread_to_unpend+0x7c>)
   2133e:	214a      	movs	r1, #74	; 0x4a
   21340:	f002 fe12 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21344:	480f      	ldr	r0, [pc, #60]	; (21384 <z_find_first_thread_to_unpend+0x78>)
   21346:	f001 fbdf 	bl	22b08 <z_spin_lock_set_owner>
	ARG_UNUSED(from);

	struct k_thread *ret = NULL;

	LOCKED(&sched_spinlock) {
		ret = _priq_wait_best(&wait_q->waitq);
   2134a:	4620      	mov	r0, r4
   2134c:	f007 ffaa 	bl	292a4 <z_priq_dumb_best>
   21350:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21352:	480c      	ldr	r0, [pc, #48]	; (21384 <z_find_first_thread_to_unpend+0x78>)
   21354:	f001 fbc8 	bl	22ae8 <z_spin_unlock_valid>
   21358:	b968      	cbnz	r0, 21376 <z_find_first_thread_to_unpend+0x6a>
   2135a:	4a0b      	ldr	r2, [pc, #44]	; (21388 <z_find_first_thread_to_unpend+0x7c>)
   2135c:	490e      	ldr	r1, [pc, #56]	; (21398 <z_find_first_thread_to_unpend+0x8c>)
   2135e:	480c      	ldr	r0, [pc, #48]	; (21390 <z_find_first_thread_to_unpend+0x84>)
   21360:	235d      	movs	r3, #93	; 0x5d
   21362:	f002 fdbe 	bl	23ee2 <printk>
   21366:	4907      	ldr	r1, [pc, #28]	; (21384 <z_find_first_thread_to_unpend+0x78>)
   21368:	480c      	ldr	r0, [pc, #48]	; (2139c <z_find_first_thread_to_unpend+0x90>)
   2136a:	f002 fdba 	bl	23ee2 <printk>
   2136e:	4806      	ldr	r0, [pc, #24]	; (21388 <z_find_first_thread_to_unpend+0x7c>)
   21370:	215d      	movs	r1, #93	; 0x5d
   21372:	f002 fdf9 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   21376:	f385 8811 	msr	BASEPRI, r5
   2137a:	f3bf 8f6f 	isb	sy
	}

	return ret;
}
   2137e:	4620      	mov	r0, r4
   21380:	bd38      	pop	{r3, r4, r5, pc}
   21382:	bf00      	nop
   21384:	20001db4 	.word	0x20001db4
   21388:	0002ae90 	.word	0x0002ae90
   2138c:	0002aeb2 	.word	0x0002aeb2
   21390:	0002a5e8 	.word	0x0002a5e8
   21394:	0002aec7 	.word	0x0002aec7
   21398:	0002aedf 	.word	0x0002aedf
   2139c:	0002aef6 	.word	0x0002aef6

000213a0 <z_unpend_thread_no_timeout>:

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
   213a0:	b538      	push	{r3, r4, r5, lr}
   213a2:	4604      	mov	r4, r0
	__asm__ volatile(
   213a4:	f04f 0320 	mov.w	r3, #32
   213a8:	f3ef 8511 	mrs	r5, BASEPRI
   213ac:	f383 8811 	msr	BASEPRI, r3
   213b0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   213b4:	481c      	ldr	r0, [pc, #112]	; (21428 <z_unpend_thread_no_timeout+0x88>)
   213b6:	f001 fb89 	bl	22acc <z_spin_lock_valid>
   213ba:	b968      	cbnz	r0, 213d8 <z_unpend_thread_no_timeout+0x38>
   213bc:	4a1b      	ldr	r2, [pc, #108]	; (2142c <z_unpend_thread_no_timeout+0x8c>)
   213be:	491c      	ldr	r1, [pc, #112]	; (21430 <z_unpend_thread_no_timeout+0x90>)
   213c0:	481c      	ldr	r0, [pc, #112]	; (21434 <z_unpend_thread_no_timeout+0x94>)
   213c2:	234a      	movs	r3, #74	; 0x4a
   213c4:	f002 fd8d 	bl	23ee2 <printk>
   213c8:	4917      	ldr	r1, [pc, #92]	; (21428 <z_unpend_thread_no_timeout+0x88>)
   213ca:	481b      	ldr	r0, [pc, #108]	; (21438 <z_unpend_thread_no_timeout+0x98>)
   213cc:	f002 fd89 	bl	23ee2 <printk>
   213d0:	4816      	ldr	r0, [pc, #88]	; (2142c <z_unpend_thread_no_timeout+0x8c>)
   213d2:	214a      	movs	r1, #74	; 0x4a
   213d4:	f002 fdc8 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   213d8:	4813      	ldr	r0, [pc, #76]	; (21428 <z_unpend_thread_no_timeout+0x88>)
   213da:	f001 fb95 	bl	22b08 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   213de:	f104 0008 	add.w	r0, r4, #8
   213e2:	f7ff ff05 	bl	211f0 <pended_on.isra.0>
   213e6:	4621      	mov	r1, r4
   213e8:	f000 f8e0 	bl	215ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   213ec:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   213ee:	480e      	ldr	r0, [pc, #56]	; (21428 <z_unpend_thread_no_timeout+0x88>)
   213f0:	f023 0302 	bic.w	r3, r3, #2
   213f4:	7363      	strb	r3, [r4, #13]
		z_mark_thread_as_not_pending(thread);
		thread->base.pended_on = NULL;
   213f6:	2300      	movs	r3, #0
   213f8:	60a3      	str	r3, [r4, #8]
   213fa:	f001 fb75 	bl	22ae8 <z_spin_unlock_valid>
   213fe:	b968      	cbnz	r0, 2141c <z_unpend_thread_no_timeout+0x7c>
   21400:	4a0a      	ldr	r2, [pc, #40]	; (2142c <z_unpend_thread_no_timeout+0x8c>)
   21402:	490e      	ldr	r1, [pc, #56]	; (2143c <z_unpend_thread_no_timeout+0x9c>)
   21404:	480b      	ldr	r0, [pc, #44]	; (21434 <z_unpend_thread_no_timeout+0x94>)
   21406:	235d      	movs	r3, #93	; 0x5d
   21408:	f002 fd6b 	bl	23ee2 <printk>
   2140c:	4906      	ldr	r1, [pc, #24]	; (21428 <z_unpend_thread_no_timeout+0x88>)
   2140e:	480c      	ldr	r0, [pc, #48]	; (21440 <z_unpend_thread_no_timeout+0xa0>)
   21410:	f002 fd67 	bl	23ee2 <printk>
   21414:	4805      	ldr	r0, [pc, #20]	; (2142c <z_unpend_thread_no_timeout+0x8c>)
   21416:	215d      	movs	r1, #93	; 0x5d
   21418:	f002 fda6 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   2141c:	f385 8811 	msr	BASEPRI, r5
   21420:	f3bf 8f6f 	isb	sy
	}
}
   21424:	bd38      	pop	{r3, r4, r5, pc}
   21426:	bf00      	nop
   21428:	20001db4 	.word	0x20001db4
   2142c:	0002ae90 	.word	0x0002ae90
   21430:	0002aeb2 	.word	0x0002aeb2
   21434:	0002a5e8 	.word	0x0002a5e8
   21438:	0002aec7 	.word	0x0002aec7
   2143c:	0002aedf 	.word	0x0002aedf
   21440:	0002aef6 	.word	0x0002aef6

00021444 <z_reschedule>:

	return arch_irq_unlocked(key) && !arch_is_in_isr();
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
   21444:	b538      	push	{r3, r4, r5, lr}
   21446:	4604      	mov	r4, r0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   21448:	460d      	mov	r5, r1
   2144a:	b9c1      	cbnz	r1, 2147e <z_reschedule+0x3a>
   2144c:	f3ef 8305 	mrs	r3, IPSR
   21450:	b9ab      	cbnz	r3, 2147e <z_reschedule+0x3a>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21452:	f001 fb49 	bl	22ae8 <z_spin_unlock_valid>
   21456:	b968      	cbnz	r0, 21474 <z_reschedule+0x30>
   21458:	4a14      	ldr	r2, [pc, #80]	; (214ac <z_reschedule+0x68>)
   2145a:	4915      	ldr	r1, [pc, #84]	; (214b0 <z_reschedule+0x6c>)
   2145c:	4815      	ldr	r0, [pc, #84]	; (214b4 <z_reschedule+0x70>)
   2145e:	2374      	movs	r3, #116	; 0x74
   21460:	f002 fd3f 	bl	23ee2 <printk>
   21464:	4814      	ldr	r0, [pc, #80]	; (214b8 <z_reschedule+0x74>)
   21466:	4621      	mov	r1, r4
   21468:	f002 fd3b 	bl	23ee2 <printk>
   2146c:	480f      	ldr	r0, [pc, #60]	; (214ac <z_reschedule+0x68>)
   2146e:	2174      	movs	r1, #116	; 0x74
   21470:	f002 fd7a 	bl	23f68 <assert_post_action>
	if (resched(key.key)) {
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   21474:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   21478:	2000      	movs	r0, #0
   2147a:	f7e3 ba15 	b.w	48a8 <arch_swap>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2147e:	4620      	mov	r0, r4
   21480:	f001 fb32 	bl	22ae8 <z_spin_unlock_valid>
   21484:	b968      	cbnz	r0, 214a2 <z_reschedule+0x5e>
   21486:	4a09      	ldr	r2, [pc, #36]	; (214ac <z_reschedule+0x68>)
   21488:	4909      	ldr	r1, [pc, #36]	; (214b0 <z_reschedule+0x6c>)
   2148a:	480a      	ldr	r0, [pc, #40]	; (214b4 <z_reschedule+0x70>)
   2148c:	235d      	movs	r3, #93	; 0x5d
   2148e:	f002 fd28 	bl	23ee2 <printk>
   21492:	4809      	ldr	r0, [pc, #36]	; (214b8 <z_reschedule+0x74>)
   21494:	4621      	mov	r1, r4
   21496:	f002 fd24 	bl	23ee2 <printk>
   2149a:	4804      	ldr	r0, [pc, #16]	; (214ac <z_reschedule+0x68>)
   2149c:	215d      	movs	r1, #93	; 0x5d
   2149e:	f002 fd63 	bl	23f68 <assert_post_action>
   214a2:	f385 8811 	msr	BASEPRI, r5
   214a6:	f3bf 8f6f 	isb	sy
   214aa:	bd38      	pop	{r3, r4, r5, pc}
   214ac:	0002ae90 	.word	0x0002ae90
   214b0:	0002aedf 	.word	0x0002aedf
   214b4:	0002a5e8 	.word	0x0002a5e8
   214b8:	0002aef6 	.word	0x0002aef6

000214bc <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
   214bc:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   214be:	f04f 0320 	mov.w	r3, #32
   214c2:	f3ef 8511 	mrs	r5, BASEPRI
   214c6:	f383 8811 	msr	BASEPRI, r3
   214ca:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   214ce:	482b      	ldr	r0, [pc, #172]	; (2157c <k_sched_lock+0xc0>)
   214d0:	f001 fafc 	bl	22acc <z_spin_lock_valid>
   214d4:	b968      	cbnz	r0, 214f2 <k_sched_lock+0x36>
   214d6:	4a2a      	ldr	r2, [pc, #168]	; (21580 <k_sched_lock+0xc4>)
   214d8:	492a      	ldr	r1, [pc, #168]	; (21584 <k_sched_lock+0xc8>)
   214da:	482b      	ldr	r0, [pc, #172]	; (21588 <k_sched_lock+0xcc>)
   214dc:	234a      	movs	r3, #74	; 0x4a
   214de:	f002 fd00 	bl	23ee2 <printk>
   214e2:	4926      	ldr	r1, [pc, #152]	; (2157c <k_sched_lock+0xc0>)
   214e4:	4829      	ldr	r0, [pc, #164]	; (2158c <k_sched_lock+0xd0>)
   214e6:	f002 fcfc 	bl	23ee2 <printk>
   214ea:	4825      	ldr	r0, [pc, #148]	; (21580 <k_sched_lock+0xc4>)
   214ec:	214a      	movs	r1, #74	; 0x4a
   214ee:	f002 fd3b 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   214f2:	4822      	ldr	r0, [pc, #136]	; (2157c <k_sched_lock+0xc0>)
   214f4:	f001 fb08 	bl	22b08 <z_spin_lock_set_owner>
   214f8:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   214fc:	b173      	cbz	r3, 2151c <k_sched_lock+0x60>
   214fe:	4924      	ldr	r1, [pc, #144]	; (21590 <k_sched_lock+0xd4>)
   21500:	4a24      	ldr	r2, [pc, #144]	; (21594 <k_sched_lock+0xd8>)
   21502:	4821      	ldr	r0, [pc, #132]	; (21588 <k_sched_lock+0xcc>)
   21504:	f240 130b 	movw	r3, #267	; 0x10b
   21508:	f002 fceb 	bl	23ee2 <printk>
   2150c:	4822      	ldr	r0, [pc, #136]	; (21598 <k_sched_lock+0xdc>)
   2150e:	f002 fce8 	bl	23ee2 <printk>
   21512:	4820      	ldr	r0, [pc, #128]	; (21594 <k_sched_lock+0xd8>)
   21514:	f240 110b 	movw	r1, #267	; 0x10b
   21518:	f002 fd26 	bl	23f68 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   2151c:	4c1f      	ldr	r4, [pc, #124]	; (2159c <k_sched_lock+0xe0>)
   2151e:	68a2      	ldr	r2, [r4, #8]
   21520:	7bd2      	ldrb	r2, [r2, #15]
   21522:	2a01      	cmp	r2, #1
   21524:	d10e      	bne.n	21544 <k_sched_lock+0x88>
   21526:	491e      	ldr	r1, [pc, #120]	; (215a0 <k_sched_lock+0xe4>)
   21528:	4a1a      	ldr	r2, [pc, #104]	; (21594 <k_sched_lock+0xd8>)
   2152a:	4817      	ldr	r0, [pc, #92]	; (21588 <k_sched_lock+0xcc>)
   2152c:	f44f 7386 	mov.w	r3, #268	; 0x10c
   21530:	f002 fcd7 	bl	23ee2 <printk>
   21534:	4818      	ldr	r0, [pc, #96]	; (21598 <k_sched_lock+0xdc>)
   21536:	f002 fcd4 	bl	23ee2 <printk>
   2153a:	4816      	ldr	r0, [pc, #88]	; (21594 <k_sched_lock+0xd8>)
   2153c:	f44f 7186 	mov.w	r1, #268	; 0x10c
   21540:	f002 fd12 	bl	23f68 <assert_post_action>
	--_current->base.sched_locked;
   21544:	68a2      	ldr	r2, [r4, #8]
   21546:	7bd3      	ldrb	r3, [r2, #15]
   21548:	3b01      	subs	r3, #1
   2154a:	73d3      	strb	r3, [r2, #15]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2154c:	480b      	ldr	r0, [pc, #44]	; (2157c <k_sched_lock+0xc0>)
   2154e:	f001 facb 	bl	22ae8 <z_spin_unlock_valid>
   21552:	b968      	cbnz	r0, 21570 <k_sched_lock+0xb4>
   21554:	4a0a      	ldr	r2, [pc, #40]	; (21580 <k_sched_lock+0xc4>)
   21556:	4913      	ldr	r1, [pc, #76]	; (215a4 <k_sched_lock+0xe8>)
   21558:	480b      	ldr	r0, [pc, #44]	; (21588 <k_sched_lock+0xcc>)
   2155a:	235d      	movs	r3, #93	; 0x5d
   2155c:	f002 fcc1 	bl	23ee2 <printk>
   21560:	4906      	ldr	r1, [pc, #24]	; (2157c <k_sched_lock+0xc0>)
   21562:	4811      	ldr	r0, [pc, #68]	; (215a8 <k_sched_lock+0xec>)
   21564:	f002 fcbd 	bl	23ee2 <printk>
   21568:	4805      	ldr	r0, [pc, #20]	; (21580 <k_sched_lock+0xc4>)
   2156a:	215d      	movs	r1, #93	; 0x5d
   2156c:	f002 fcfc 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   21570:	f385 8811 	msr	BASEPRI, r5
   21574:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   21578:	bd38      	pop	{r3, r4, r5, pc}
   2157a:	bf00      	nop
   2157c:	20001db4 	.word	0x20001db4
   21580:	0002ae90 	.word	0x0002ae90
   21584:	0002aeb2 	.word	0x0002aeb2
   21588:	0002a5e8 	.word	0x0002a5e8
   2158c:	0002aec7 	.word	0x0002aec7
   21590:	000312cc 	.word	0x000312cc
   21594:	000312a5 	.word	0x000312a5
   21598:	00030d23 	.word	0x00030d23
   2159c:	20001d80 	.word	0x20001d80
   215a0:	000312de 	.word	0x000312de
   215a4:	0002aedf 	.word	0x0002aedf
   215a8:	0002aef6 	.word	0x0002aef6

000215ac <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   215ac:	4b11      	ldr	r3, [pc, #68]	; (215f4 <z_priq_dumb_remove+0x48>)
   215ae:	f103 0228 	add.w	r2, r3, #40	; 0x28
   215b2:	4282      	cmp	r2, r0
{
   215b4:	b510      	push	{r4, lr}
   215b6:	460c      	mov	r4, r1
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   215b8:	d105      	bne.n	215c6 <z_priq_dumb_remove+0x1a>
   215ba:	689b      	ldr	r3, [r3, #8]
   215bc:	428b      	cmp	r3, r1
   215be:	d102      	bne.n	215c6 <z_priq_dumb_remove+0x1a>
   215c0:	7b4b      	ldrb	r3, [r1, #13]
   215c2:	06db      	lsls	r3, r3, #27
   215c4:	d115      	bne.n	215f2 <z_priq_dumb_remove+0x46>
	    z_is_thread_prevented_from_running(thread)) {
		return;
	}
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   215c6:	4b0c      	ldr	r3, [pc, #48]	; (215f8 <z_priq_dumb_remove+0x4c>)
   215c8:	429c      	cmp	r4, r3
   215ca:	d10b      	bne.n	215e4 <z_priq_dumb_remove+0x38>
   215cc:	490b      	ldr	r1, [pc, #44]	; (215fc <z_priq_dumb_remove+0x50>)
   215ce:	480c      	ldr	r0, [pc, #48]	; (21600 <z_priq_dumb_remove+0x54>)
   215d0:	4a0c      	ldr	r2, [pc, #48]	; (21604 <z_priq_dumb_remove+0x58>)
   215d2:	f240 336a 	movw	r3, #874	; 0x36a
   215d6:	f002 fc84 	bl	23ee2 <printk>
   215da:	480a      	ldr	r0, [pc, #40]	; (21604 <z_priq_dumb_remove+0x58>)
   215dc:	f240 316a 	movw	r1, #874	; 0x36a
   215e0:	f002 fcc2 	bl	23f68 <assert_post_action>
	node->prev->next = node->next;
   215e4:	e9d4 3200 	ldrd	r3, r2, [r4]
   215e8:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   215ea:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   215ec:	2300      	movs	r3, #0
	node->prev = NULL;
   215ee:	e9c4 3300 	strd	r3, r3, [r4]

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   215f2:	bd10      	pop	{r4, pc}
   215f4:	20001d80 	.word	0x20001d80
   215f8:	20001c4c 	.word	0x20001c4c
   215fc:	0003133f 	.word	0x0003133f
   21600:	0002a5e8 	.word	0x0002a5e8
   21604:	00031306 	.word	0x00031306

00021608 <z_unpend_thread>:
{
   21608:	b538      	push	{r3, r4, r5, lr}
   2160a:	4604      	mov	r4, r0
	__asm__ volatile(
   2160c:	f04f 0320 	mov.w	r3, #32
   21610:	f3ef 8511 	mrs	r5, BASEPRI
   21614:	f383 8811 	msr	BASEPRI, r3
   21618:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2161c:	481e      	ldr	r0, [pc, #120]	; (21698 <z_unpend_thread+0x90>)
   2161e:	f001 fa55 	bl	22acc <z_spin_lock_valid>
   21622:	b968      	cbnz	r0, 21640 <z_unpend_thread+0x38>
   21624:	4a1d      	ldr	r2, [pc, #116]	; (2169c <z_unpend_thread+0x94>)
   21626:	491e      	ldr	r1, [pc, #120]	; (216a0 <z_unpend_thread+0x98>)
   21628:	481e      	ldr	r0, [pc, #120]	; (216a4 <z_unpend_thread+0x9c>)
   2162a:	234a      	movs	r3, #74	; 0x4a
   2162c:	f002 fc59 	bl	23ee2 <printk>
   21630:	4919      	ldr	r1, [pc, #100]	; (21698 <z_unpend_thread+0x90>)
   21632:	481d      	ldr	r0, [pc, #116]	; (216a8 <z_unpend_thread+0xa0>)
   21634:	f002 fc55 	bl	23ee2 <printk>
   21638:	4818      	ldr	r0, [pc, #96]	; (2169c <z_unpend_thread+0x94>)
   2163a:	214a      	movs	r1, #74	; 0x4a
   2163c:	f002 fc94 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21640:	4815      	ldr	r0, [pc, #84]	; (21698 <z_unpend_thread+0x90>)
   21642:	f001 fa61 	bl	22b08 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   21646:	f104 0008 	add.w	r0, r4, #8
   2164a:	f7ff fdd1 	bl	211f0 <pended_on.isra.0>
   2164e:	4621      	mov	r1, r4
   21650:	f7ff ffac 	bl	215ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   21654:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21656:	4810      	ldr	r0, [pc, #64]	; (21698 <z_unpend_thread+0x90>)
   21658:	f023 0302 	bic.w	r3, r3, #2
   2165c:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   2165e:	2300      	movs	r3, #0
   21660:	60a3      	str	r3, [r4, #8]
   21662:	f001 fa41 	bl	22ae8 <z_spin_unlock_valid>
   21666:	b968      	cbnz	r0, 21684 <z_unpend_thread+0x7c>
   21668:	4a0c      	ldr	r2, [pc, #48]	; (2169c <z_unpend_thread+0x94>)
   2166a:	4910      	ldr	r1, [pc, #64]	; (216ac <z_unpend_thread+0xa4>)
   2166c:	480d      	ldr	r0, [pc, #52]	; (216a4 <z_unpend_thread+0x9c>)
   2166e:	235d      	movs	r3, #93	; 0x5d
   21670:	f002 fc37 	bl	23ee2 <printk>
   21674:	4908      	ldr	r1, [pc, #32]	; (21698 <z_unpend_thread+0x90>)
   21676:	480e      	ldr	r0, [pc, #56]	; (216b0 <z_unpend_thread+0xa8>)
   21678:	f002 fc33 	bl	23ee2 <printk>
   2167c:	4807      	ldr	r0, [pc, #28]	; (2169c <z_unpend_thread+0x94>)
   2167e:	215d      	movs	r1, #93	; 0x5d
   21680:	f002 fc72 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   21684:	f385 8811 	msr	BASEPRI, r5
   21688:	f3bf 8f6f 	isb	sy
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   2168c:	f104 0018 	add.w	r0, r4, #24
}
   21690:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   21694:	f001 bc42 	b.w	22f1c <z_abort_timeout>
   21698:	20001db4 	.word	0x20001db4
   2169c:	0002ae90 	.word	0x0002ae90
   216a0:	0002aeb2 	.word	0x0002aeb2
   216a4:	0002a5e8 	.word	0x0002a5e8
   216a8:	0002aec7 	.word	0x0002aec7
   216ac:	0002aedf 	.word	0x0002aedf
   216b0:	0002aef6 	.word	0x0002aef6

000216b4 <update_cache>:
{
   216b4:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   216b6:	4c10      	ldr	r4, [pc, #64]	; (216f8 <update_cache+0x44>)
{
   216b8:	4606      	mov	r6, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   216ba:	f104 0028 	add.w	r0, r4, #40	; 0x28
   216be:	f007 fdf1 	bl	292a4 <z_priq_dumb_best>
	if (_current->base.thread_state & _THREAD_ABORTING) {
   216c2:	68a3      	ldr	r3, [r4, #8]
   216c4:	7b59      	ldrb	r1, [r3, #13]
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   216c6:	4605      	mov	r5, r0
	if (_current->base.thread_state & _THREAD_ABORTING) {
   216c8:	0688      	lsls	r0, r1, #26
		_current->base.thread_state |= _THREAD_DEAD;
   216ca:	bf44      	itt	mi
   216cc:	f041 0108 	orrmi.w	r1, r1, #8
   216d0:	7359      	strbmi	r1, [r3, #13]
	return thread ? thread : _current_cpu->idle_thread;
   216d2:	b905      	cbnz	r5, 216d6 <update_cache+0x22>
   216d4:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   216d6:	b94e      	cbnz	r6, 216ec <update_cache+0x38>
	if (z_is_thread_prevented_from_running(_current)) {
   216d8:	7b5a      	ldrb	r2, [r3, #13]
   216da:	06d2      	lsls	r2, r2, #27
   216dc:	d106      	bne.n	216ec <update_cache+0x38>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   216de:	69aa      	ldr	r2, [r5, #24]
   216e0:	b922      	cbnz	r2, 216ec <update_cache+0x38>
	if (is_preempt(_current) || is_metairq(thread)) {
   216e2:	89da      	ldrh	r2, [r3, #14]
   216e4:	2a7f      	cmp	r2, #127	; 0x7f
   216e6:	d901      	bls.n	216ec <update_cache+0x38>
		_kernel.ready_q.cache = _current;
   216e8:	6263      	str	r3, [r4, #36]	; 0x24
}
   216ea:	bd70      	pop	{r4, r5, r6, pc}
		if (thread != _current) {
   216ec:	42ab      	cmp	r3, r5
   216ee:	d001      	beq.n	216f4 <update_cache+0x40>
			z_reset_time_slice();
   216f0:	f7ff fd96 	bl	21220 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   216f4:	6265      	str	r5, [r4, #36]	; 0x24
}
   216f6:	e7f8      	b.n	216ea <update_cache+0x36>
   216f8:	20001d80 	.word	0x20001d80

000216fc <k_sched_unlock>:
{
   216fc:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   216fe:	f04f 0320 	mov.w	r3, #32
   21702:	f3ef 8511 	mrs	r5, BASEPRI
   21706:	f383 8811 	msr	BASEPRI, r3
   2170a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2170e:	482d      	ldr	r0, [pc, #180]	; (217c4 <k_sched_unlock+0xc8>)
   21710:	f001 f9dc 	bl	22acc <z_spin_lock_valid>
   21714:	b968      	cbnz	r0, 21732 <k_sched_unlock+0x36>
   21716:	4a2c      	ldr	r2, [pc, #176]	; (217c8 <k_sched_unlock+0xcc>)
   21718:	492c      	ldr	r1, [pc, #176]	; (217cc <k_sched_unlock+0xd0>)
   2171a:	482d      	ldr	r0, [pc, #180]	; (217d0 <k_sched_unlock+0xd4>)
   2171c:	234a      	movs	r3, #74	; 0x4a
   2171e:	f002 fbe0 	bl	23ee2 <printk>
   21722:	4928      	ldr	r1, [pc, #160]	; (217c4 <k_sched_unlock+0xc8>)
   21724:	482b      	ldr	r0, [pc, #172]	; (217d4 <k_sched_unlock+0xd8>)
   21726:	f002 fbdc 	bl	23ee2 <printk>
   2172a:	4827      	ldr	r0, [pc, #156]	; (217c8 <k_sched_unlock+0xcc>)
   2172c:	214a      	movs	r1, #74	; 0x4a
   2172e:	f002 fc1b 	bl	23f68 <assert_post_action>
		__ASSERT(_current->base.sched_locked != 0, "");
   21732:	4c29      	ldr	r4, [pc, #164]	; (217d8 <k_sched_unlock+0xdc>)
	z_spin_lock_set_owner(l);
   21734:	4823      	ldr	r0, [pc, #140]	; (217c4 <k_sched_unlock+0xc8>)
   21736:	f001 f9e7 	bl	22b08 <z_spin_lock_set_owner>
   2173a:	68a2      	ldr	r2, [r4, #8]
   2173c:	7bd2      	ldrb	r2, [r2, #15]
   2173e:	b972      	cbnz	r2, 2175e <k_sched_unlock+0x62>
   21740:	4926      	ldr	r1, [pc, #152]	; (217dc <k_sched_unlock+0xe0>)
   21742:	4a27      	ldr	r2, [pc, #156]	; (217e0 <k_sched_unlock+0xe4>)
   21744:	4822      	ldr	r0, [pc, #136]	; (217d0 <k_sched_unlock+0xd4>)
   21746:	f240 3309 	movw	r3, #777	; 0x309
   2174a:	f002 fbca 	bl	23ee2 <printk>
   2174e:	4825      	ldr	r0, [pc, #148]	; (217e4 <k_sched_unlock+0xe8>)
   21750:	f002 fbc7 	bl	23ee2 <printk>
   21754:	4822      	ldr	r0, [pc, #136]	; (217e0 <k_sched_unlock+0xe4>)
   21756:	f240 3109 	movw	r1, #777	; 0x309
   2175a:	f002 fc05 	bl	23f68 <assert_post_action>
   2175e:	f3ef 8305 	mrs	r3, IPSR
		__ASSERT(!arch_is_in_isr(), "");
   21762:	b173      	cbz	r3, 21782 <k_sched_unlock+0x86>
   21764:	4920      	ldr	r1, [pc, #128]	; (217e8 <k_sched_unlock+0xec>)
   21766:	4a1e      	ldr	r2, [pc, #120]	; (217e0 <k_sched_unlock+0xe4>)
   21768:	4819      	ldr	r0, [pc, #100]	; (217d0 <k_sched_unlock+0xd4>)
   2176a:	f240 330a 	movw	r3, #778	; 0x30a
   2176e:	f002 fbb8 	bl	23ee2 <printk>
   21772:	481c      	ldr	r0, [pc, #112]	; (217e4 <k_sched_unlock+0xe8>)
   21774:	f002 fbb5 	bl	23ee2 <printk>
   21778:	4819      	ldr	r0, [pc, #100]	; (217e0 <k_sched_unlock+0xe4>)
   2177a:	f240 310a 	movw	r1, #778	; 0x30a
   2177e:	f002 fbf3 	bl	23f68 <assert_post_action>
		++_current->base.sched_locked;
   21782:	68a2      	ldr	r2, [r4, #8]
   21784:	7bd3      	ldrb	r3, [r2, #15]
   21786:	3301      	adds	r3, #1
		update_cache(0);
   21788:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   2178a:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   2178c:	f7ff ff92 	bl	216b4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21790:	480c      	ldr	r0, [pc, #48]	; (217c4 <k_sched_unlock+0xc8>)
   21792:	f001 f9a9 	bl	22ae8 <z_spin_unlock_valid>
   21796:	b968      	cbnz	r0, 217b4 <k_sched_unlock+0xb8>
   21798:	4a0b      	ldr	r2, [pc, #44]	; (217c8 <k_sched_unlock+0xcc>)
   2179a:	4914      	ldr	r1, [pc, #80]	; (217ec <k_sched_unlock+0xf0>)
   2179c:	480c      	ldr	r0, [pc, #48]	; (217d0 <k_sched_unlock+0xd4>)
   2179e:	235d      	movs	r3, #93	; 0x5d
   217a0:	f002 fb9f 	bl	23ee2 <printk>
   217a4:	4907      	ldr	r1, [pc, #28]	; (217c4 <k_sched_unlock+0xc8>)
   217a6:	4812      	ldr	r0, [pc, #72]	; (217f0 <k_sched_unlock+0xf4>)
   217a8:	f002 fb9b 	bl	23ee2 <printk>
   217ac:	4806      	ldr	r0, [pc, #24]	; (217c8 <k_sched_unlock+0xcc>)
   217ae:	215d      	movs	r1, #93	; 0x5d
   217b0:	f002 fbda 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   217b4:	f385 8811 	msr	BASEPRI, r5
   217b8:	f3bf 8f6f 	isb	sy
}
   217bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_unlocked();
   217c0:	f007 bd66 	b.w	29290 <z_reschedule_unlocked>
   217c4:	20001db4 	.word	0x20001db4
   217c8:	0002ae90 	.word	0x0002ae90
   217cc:	0002aeb2 	.word	0x0002aeb2
   217d0:	0002a5e8 	.word	0x0002a5e8
   217d4:	0002aec7 	.word	0x0002aec7
   217d8:	20001d80 	.word	0x20001d80
   217dc:	00031360 	.word	0x00031360
   217e0:	00031306 	.word	0x00031306
   217e4:	00030d23 	.word	0x00030d23
   217e8:	000312cc 	.word	0x000312cc
   217ec:	0002aedf 	.word	0x0002aedf
   217f0:	0002aef6 	.word	0x0002aef6

000217f4 <ready_thread>:
{
   217f4:	b570      	push	{r4, r5, r6, lr}
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   217f6:	7b43      	ldrb	r3, [r0, #13]
   217f8:	06db      	lsls	r3, r3, #27
   217fa:	4604      	mov	r4, r0
   217fc:	d13d      	bne.n	2187a <ready_thread+0x86>
	return !sys_dnode_is_linked(&t->node);
   217fe:	6985      	ldr	r5, [r0, #24]
	if (z_is_thread_ready(thread)) {
   21800:	2d00      	cmp	r5, #0
   21802:	d13a      	bne.n	2187a <ready_thread+0x86>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   21804:	4b1d      	ldr	r3, [pc, #116]	; (2187c <ready_thread+0x88>)
   21806:	4298      	cmp	r0, r3
   21808:	d10b      	bne.n	21822 <ready_thread+0x2e>
   2180a:	491d      	ldr	r1, [pc, #116]	; (21880 <ready_thread+0x8c>)
   2180c:	481d      	ldr	r0, [pc, #116]	; (21884 <ready_thread+0x90>)
   2180e:	4a1e      	ldr	r2, [pc, #120]	; (21888 <ready_thread+0x94>)
   21810:	f44f 7355 	mov.w	r3, #852	; 0x354
   21814:	f002 fb65 	bl	23ee2 <printk>
   21818:	481b      	ldr	r0, [pc, #108]	; (21888 <ready_thread+0x94>)
   2181a:	f44f 7155 	mov.w	r1, #852	; 0x354
   2181e:	f002 fba3 	bl	23f68 <assert_post_action>
	return list->head == list;
   21822:	4a1a      	ldr	r2, [pc, #104]	; (2188c <ready_thread+0x98>)
   21824:	4613      	mov	r3, r2
   21826:	f853 0f28 	ldr.w	r0, [r3, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2182a:	4298      	cmp	r0, r3
   2182c:	bf18      	it	ne
   2182e:	4605      	movne	r5, r0
   21830:	2d00      	cmp	r5, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   21832:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
   21834:	4619      	mov	r1, r3
   21836:	462b      	mov	r3, r5
   21838:	bf38      	it	cc
   2183a:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2183c:	b1bb      	cbz	r3, 2186e <ready_thread+0x7a>
	if (thread_1->base.prio < thread_2->base.prio) {
   2183e:	f994 600e 	ldrsb.w	r6, [r4, #14]
   21842:	f993 500e 	ldrsb.w	r5, [r3, #14]
   21846:	42ae      	cmp	r6, r5
   21848:	db03      	blt.n	21852 <ready_thread+0x5e>
	return (node == list->tail) ? NULL : node->next;
   2184a:	4298      	cmp	r0, r3
   2184c:	d00f      	beq.n	2186e <ready_thread+0x7a>
   2184e:	681b      	ldr	r3, [r3, #0]
   21850:	e7f4      	b.n	2183c <ready_thread+0x48>
	node->prev = successor->prev;
   21852:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   21854:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   21858:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   2185a:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   2185c:	7b63      	ldrb	r3, [r4, #13]
   2185e:	f063 037f 	orn	r3, r3, #127	; 0x7f
   21862:	7363      	strb	r3, [r4, #13]
		update_cache(0);
   21864:	2000      	movs	r0, #0
}
   21866:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		update_cache(0);
   2186a:	f7ff bf23 	b.w	216b4 <update_cache>
	node->prev = list->tail;
   2186e:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   21872:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   21874:	601c      	str	r4, [r3, #0]
	list->tail = node;
   21876:	62d4      	str	r4, [r2, #44]	; 0x2c
}
   21878:	e7f0      	b.n	2185c <ready_thread+0x68>
}
   2187a:	bd70      	pop	{r4, r5, r6, pc}
   2187c:	20001c4c 	.word	0x20001c4c
   21880:	0003133f 	.word	0x0003133f
   21884:	0002a5e8 	.word	0x0002a5e8
   21888:	00031306 	.word	0x00031306
   2188c:	20001d80 	.word	0x20001d80

00021890 <z_ready_thread>:
{
   21890:	b538      	push	{r3, r4, r5, lr}
   21892:	4604      	mov	r4, r0
	__asm__ volatile(
   21894:	f04f 0320 	mov.w	r3, #32
   21898:	f3ef 8511 	mrs	r5, BASEPRI
   2189c:	f383 8811 	msr	BASEPRI, r3
   218a0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   218a4:	4817      	ldr	r0, [pc, #92]	; (21904 <z_ready_thread+0x74>)
   218a6:	f001 f911 	bl	22acc <z_spin_lock_valid>
   218aa:	b968      	cbnz	r0, 218c8 <z_ready_thread+0x38>
   218ac:	4a16      	ldr	r2, [pc, #88]	; (21908 <z_ready_thread+0x78>)
   218ae:	4917      	ldr	r1, [pc, #92]	; (2190c <z_ready_thread+0x7c>)
   218b0:	4817      	ldr	r0, [pc, #92]	; (21910 <z_ready_thread+0x80>)
   218b2:	234a      	movs	r3, #74	; 0x4a
   218b4:	f002 fb15 	bl	23ee2 <printk>
   218b8:	4912      	ldr	r1, [pc, #72]	; (21904 <z_ready_thread+0x74>)
   218ba:	4816      	ldr	r0, [pc, #88]	; (21914 <z_ready_thread+0x84>)
   218bc:	f002 fb11 	bl	23ee2 <printk>
   218c0:	4811      	ldr	r0, [pc, #68]	; (21908 <z_ready_thread+0x78>)
   218c2:	214a      	movs	r1, #74	; 0x4a
   218c4:	f002 fb50 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   218c8:	480e      	ldr	r0, [pc, #56]	; (21904 <z_ready_thread+0x74>)
   218ca:	f001 f91d 	bl	22b08 <z_spin_lock_set_owner>
		ready_thread(thread);
   218ce:	4620      	mov	r0, r4
   218d0:	f7ff ff90 	bl	217f4 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   218d4:	480b      	ldr	r0, [pc, #44]	; (21904 <z_ready_thread+0x74>)
   218d6:	f001 f907 	bl	22ae8 <z_spin_unlock_valid>
   218da:	b968      	cbnz	r0, 218f8 <z_ready_thread+0x68>
   218dc:	4a0a      	ldr	r2, [pc, #40]	; (21908 <z_ready_thread+0x78>)
   218de:	490e      	ldr	r1, [pc, #56]	; (21918 <z_ready_thread+0x88>)
   218e0:	480b      	ldr	r0, [pc, #44]	; (21910 <z_ready_thread+0x80>)
   218e2:	235d      	movs	r3, #93	; 0x5d
   218e4:	f002 fafd 	bl	23ee2 <printk>
   218e8:	4906      	ldr	r1, [pc, #24]	; (21904 <z_ready_thread+0x74>)
   218ea:	480c      	ldr	r0, [pc, #48]	; (2191c <z_ready_thread+0x8c>)
   218ec:	f002 faf9 	bl	23ee2 <printk>
   218f0:	4805      	ldr	r0, [pc, #20]	; (21908 <z_ready_thread+0x78>)
   218f2:	215d      	movs	r1, #93	; 0x5d
   218f4:	f002 fb38 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   218f8:	f385 8811 	msr	BASEPRI, r5
   218fc:	f3bf 8f6f 	isb	sy
}
   21900:	bd38      	pop	{r3, r4, r5, pc}
   21902:	bf00      	nop
   21904:	20001db4 	.word	0x20001db4
   21908:	0002ae90 	.word	0x0002ae90
   2190c:	0002aeb2 	.word	0x0002aeb2
   21910:	0002a5e8 	.word	0x0002a5e8
   21914:	0002aec7 	.word	0x0002aec7
   21918:	0002aedf 	.word	0x0002aedf
   2191c:	0002aef6 	.word	0x0002aef6

00021920 <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
   21920:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   21924:	b570      	push	{r4, r5, r6, lr}
   21926:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   21928:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
   2192c:	2b00      	cmp	r3, #0
   2192e:	d042      	beq.n	219b6 <z_thread_timeout+0x96>
	__asm__ volatile(
   21930:	f04f 0320 	mov.w	r3, #32
   21934:	f3ef 8611 	mrs	r6, BASEPRI
   21938:	f383 8811 	msr	BASEPRI, r3
   2193c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21940:	4822      	ldr	r0, [pc, #136]	; (219cc <z_thread_timeout+0xac>)
   21942:	f001 f8c3 	bl	22acc <z_spin_lock_valid>
   21946:	b968      	cbnz	r0, 21964 <z_thread_timeout+0x44>
   21948:	4a21      	ldr	r2, [pc, #132]	; (219d0 <z_thread_timeout+0xb0>)
   2194a:	4922      	ldr	r1, [pc, #136]	; (219d4 <z_thread_timeout+0xb4>)
   2194c:	4822      	ldr	r0, [pc, #136]	; (219d8 <z_thread_timeout+0xb8>)
   2194e:	234a      	movs	r3, #74	; 0x4a
   21950:	f002 fac7 	bl	23ee2 <printk>
   21954:	491d      	ldr	r1, [pc, #116]	; (219cc <z_thread_timeout+0xac>)
   21956:	4821      	ldr	r0, [pc, #132]	; (219dc <z_thread_timeout+0xbc>)
   21958:	f002 fac3 	bl	23ee2 <printk>
   2195c:	481c      	ldr	r0, [pc, #112]	; (219d0 <z_thread_timeout+0xb0>)
   2195e:	214a      	movs	r1, #74	; 0x4a
   21960:	f002 fb02 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21964:	4819      	ldr	r0, [pc, #100]	; (219cc <z_thread_timeout+0xac>)
   21966:	f001 f8cf 	bl	22b08 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2196a:	f1a4 0010 	sub.w	r0, r4, #16
   2196e:	f7ff fc3f 	bl	211f0 <pended_on.isra.0>
   21972:	4629      	mov	r1, r5
   21974:	f7ff fe1a 	bl	215ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   21978:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2197c:	4813      	ldr	r0, [pc, #76]	; (219cc <z_thread_timeout+0xac>)
   2197e:	f023 0302 	bic.w	r3, r3, #2
   21982:	f804 3c0b 	strb.w	r3, [r4, #-11]
		thread->base.pended_on = NULL;
   21986:	2300      	movs	r3, #0
   21988:	f844 3c10 	str.w	r3, [r4, #-16]
   2198c:	f001 f8ac 	bl	22ae8 <z_spin_unlock_valid>
   21990:	b968      	cbnz	r0, 219ae <z_thread_timeout+0x8e>
   21992:	4a0f      	ldr	r2, [pc, #60]	; (219d0 <z_thread_timeout+0xb0>)
   21994:	4912      	ldr	r1, [pc, #72]	; (219e0 <z_thread_timeout+0xc0>)
   21996:	4810      	ldr	r0, [pc, #64]	; (219d8 <z_thread_timeout+0xb8>)
   21998:	235d      	movs	r3, #93	; 0x5d
   2199a:	f002 faa2 	bl	23ee2 <printk>
   2199e:	490b      	ldr	r1, [pc, #44]	; (219cc <z_thread_timeout+0xac>)
   219a0:	4810      	ldr	r0, [pc, #64]	; (219e4 <z_thread_timeout+0xc4>)
   219a2:	f002 fa9e 	bl	23ee2 <printk>
   219a6:	480a      	ldr	r0, [pc, #40]	; (219d0 <z_thread_timeout+0xb0>)
   219a8:	215d      	movs	r1, #93	; 0x5d
   219aa:	f002 fadd 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   219ae:	f386 8811 	msr	BASEPRI, r6
   219b2:	f3bf 8f6f 	isb	sy
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   219b6:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   219ba:	f023 0314 	bic.w	r3, r3, #20
   219be:	f804 3c0b 	strb.w	r3, [r4, #-11]
	z_ready_thread(thread);
   219c2:	4628      	mov	r0, r5
}
   219c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_ready_thread(thread);
   219c8:	f7ff bf62 	b.w	21890 <z_ready_thread>
   219cc:	20001db4 	.word	0x20001db4
   219d0:	0002ae90 	.word	0x0002ae90
   219d4:	0002aeb2 	.word	0x0002aeb2
   219d8:	0002a5e8 	.word	0x0002a5e8
   219dc:	0002aec7 	.word	0x0002aec7
   219e0:	0002aedf 	.word	0x0002aedf
   219e4:	0002aef6 	.word	0x0002aef6

000219e8 <z_sched_start>:
{
   219e8:	b538      	push	{r3, r4, r5, lr}
   219ea:	4604      	mov	r4, r0
	__asm__ volatile(
   219ec:	f04f 0320 	mov.w	r3, #32
   219f0:	f3ef 8511 	mrs	r5, BASEPRI
   219f4:	f383 8811 	msr	BASEPRI, r3
   219f8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   219fc:	481d      	ldr	r0, [pc, #116]	; (21a74 <z_sched_start+0x8c>)
   219fe:	f001 f865 	bl	22acc <z_spin_lock_valid>
   21a02:	b968      	cbnz	r0, 21a20 <z_sched_start+0x38>
   21a04:	4a1c      	ldr	r2, [pc, #112]	; (21a78 <z_sched_start+0x90>)
   21a06:	491d      	ldr	r1, [pc, #116]	; (21a7c <z_sched_start+0x94>)
   21a08:	481d      	ldr	r0, [pc, #116]	; (21a80 <z_sched_start+0x98>)
   21a0a:	234a      	movs	r3, #74	; 0x4a
   21a0c:	f002 fa69 	bl	23ee2 <printk>
   21a10:	4918      	ldr	r1, [pc, #96]	; (21a74 <z_sched_start+0x8c>)
   21a12:	481c      	ldr	r0, [pc, #112]	; (21a84 <z_sched_start+0x9c>)
   21a14:	f002 fa65 	bl	23ee2 <printk>
   21a18:	4817      	ldr	r0, [pc, #92]	; (21a78 <z_sched_start+0x90>)
   21a1a:	214a      	movs	r1, #74	; 0x4a
   21a1c:	f002 faa4 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21a20:	4814      	ldr	r0, [pc, #80]	; (21a74 <z_sched_start+0x8c>)
   21a22:	f001 f871 	bl	22b08 <z_spin_lock_set_owner>
	if (z_has_thread_started(thread)) {
   21a26:	7b63      	ldrb	r3, [r4, #13]
   21a28:	075a      	lsls	r2, r3, #29
   21a2a:	d416      	bmi.n	21a5a <z_sched_start+0x72>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21a2c:	4811      	ldr	r0, [pc, #68]	; (21a74 <z_sched_start+0x8c>)
   21a2e:	f001 f85b 	bl	22ae8 <z_spin_unlock_valid>
   21a32:	b968      	cbnz	r0, 21a50 <z_sched_start+0x68>
   21a34:	4a10      	ldr	r2, [pc, #64]	; (21a78 <z_sched_start+0x90>)
   21a36:	4914      	ldr	r1, [pc, #80]	; (21a88 <z_sched_start+0xa0>)
   21a38:	4811      	ldr	r0, [pc, #68]	; (21a80 <z_sched_start+0x98>)
   21a3a:	235d      	movs	r3, #93	; 0x5d
   21a3c:	f002 fa51 	bl	23ee2 <printk>
   21a40:	490c      	ldr	r1, [pc, #48]	; (21a74 <z_sched_start+0x8c>)
   21a42:	4812      	ldr	r0, [pc, #72]	; (21a8c <z_sched_start+0xa4>)
   21a44:	f002 fa4d 	bl	23ee2 <printk>
   21a48:	480b      	ldr	r0, [pc, #44]	; (21a78 <z_sched_start+0x90>)
   21a4a:	215d      	movs	r1, #93	; 0x5d
   21a4c:	f002 fa8c 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   21a50:	f385 8811 	msr	BASEPRI, r5
   21a54:	f3bf 8f6f 	isb	sy
}
   21a58:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   21a5a:	f023 0304 	bic.w	r3, r3, #4
	ready_thread(thread);
   21a5e:	4620      	mov	r0, r4
   21a60:	7363      	strb	r3, [r4, #13]
   21a62:	f7ff fec7 	bl	217f4 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   21a66:	4629      	mov	r1, r5
   21a68:	4802      	ldr	r0, [pc, #8]	; (21a74 <z_sched_start+0x8c>)
}
   21a6a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&sched_spinlock, key);
   21a6e:	f7ff bce9 	b.w	21444 <z_reschedule>
   21a72:	bf00      	nop
   21a74:	20001db4 	.word	0x20001db4
   21a78:	0002ae90 	.word	0x0002ae90
   21a7c:	0002aeb2 	.word	0x0002aeb2
   21a80:	0002a5e8 	.word	0x0002a5e8
   21a84:	0002aec7 	.word	0x0002aec7
   21a88:	0002aedf 	.word	0x0002aedf
   21a8c:	0002aef6 	.word	0x0002aef6

00021a90 <z_move_thread_to_end_of_prio_q>:
{
   21a90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   21a92:	4604      	mov	r4, r0
	__asm__ volatile(
   21a94:	f04f 0320 	mov.w	r3, #32
   21a98:	f3ef 8511 	mrs	r5, BASEPRI
   21a9c:	f383 8811 	msr	BASEPRI, r3
   21aa0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21aa4:	4837      	ldr	r0, [pc, #220]	; (21b84 <z_move_thread_to_end_of_prio_q+0xf4>)
   21aa6:	f001 f811 	bl	22acc <z_spin_lock_valid>
   21aaa:	b968      	cbnz	r0, 21ac8 <z_move_thread_to_end_of_prio_q+0x38>
   21aac:	4a36      	ldr	r2, [pc, #216]	; (21b88 <z_move_thread_to_end_of_prio_q+0xf8>)
   21aae:	4937      	ldr	r1, [pc, #220]	; (21b8c <z_move_thread_to_end_of_prio_q+0xfc>)
   21ab0:	4837      	ldr	r0, [pc, #220]	; (21b90 <z_move_thread_to_end_of_prio_q+0x100>)
   21ab2:	234a      	movs	r3, #74	; 0x4a
   21ab4:	f002 fa15 	bl	23ee2 <printk>
   21ab8:	4932      	ldr	r1, [pc, #200]	; (21b84 <z_move_thread_to_end_of_prio_q+0xf4>)
   21aba:	4836      	ldr	r0, [pc, #216]	; (21b94 <z_move_thread_to_end_of_prio_q+0x104>)
   21abc:	f002 fa11 	bl	23ee2 <printk>
   21ac0:	4831      	ldr	r0, [pc, #196]	; (21b88 <z_move_thread_to_end_of_prio_q+0xf8>)
   21ac2:	214a      	movs	r1, #74	; 0x4a
   21ac4:	f002 fa50 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21ac8:	482e      	ldr	r0, [pc, #184]	; (21b84 <z_move_thread_to_end_of_prio_q+0xf4>)
   21aca:	f001 f81d 	bl	22b08 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   21ace:	f994 300d 	ldrsb.w	r3, [r4, #13]
   21ad2:	2b00      	cmp	r3, #0
   21ad4:	da03      	bge.n	21ade <z_move_thread_to_end_of_prio_q+0x4e>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   21ad6:	4830      	ldr	r0, [pc, #192]	; (21b98 <z_move_thread_to_end_of_prio_q+0x108>)
   21ad8:	4621      	mov	r1, r4
   21ada:	f7ff fd67 	bl	215ac <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   21ade:	4b2f      	ldr	r3, [pc, #188]	; (21b9c <z_move_thread_to_end_of_prio_q+0x10c>)
   21ae0:	429c      	cmp	r4, r3
   21ae2:	d10b      	bne.n	21afc <z_move_thread_to_end_of_prio_q+0x6c>
   21ae4:	492e      	ldr	r1, [pc, #184]	; (21ba0 <z_move_thread_to_end_of_prio_q+0x110>)
   21ae6:	482a      	ldr	r0, [pc, #168]	; (21b90 <z_move_thread_to_end_of_prio_q+0x100>)
   21ae8:	4a2e      	ldr	r2, [pc, #184]	; (21ba4 <z_move_thread_to_end_of_prio_q+0x114>)
   21aea:	f44f 7355 	mov.w	r3, #852	; 0x354
   21aee:	f002 f9f8 	bl	23ee2 <printk>
   21af2:	482c      	ldr	r0, [pc, #176]	; (21ba4 <z_move_thread_to_end_of_prio_q+0x114>)
   21af4:	f44f 7155 	mov.w	r1, #852	; 0x354
   21af8:	f002 fa36 	bl	23f68 <assert_post_action>
	return list->head == list;
   21afc:	4a2a      	ldr	r2, [pc, #168]	; (21ba8 <z_move_thread_to_end_of_prio_q+0x118>)
   21afe:	4611      	mov	r1, r2
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   21b00:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
	return list->head == list;
   21b02:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   21b06:	428b      	cmp	r3, r1
   21b08:	bf08      	it	eq
   21b0a:	2300      	moveq	r3, #0
   21b0c:	2b00      	cmp	r3, #0
   21b0e:	bf38      	it	cc
   21b10:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   21b12:	2b00      	cmp	r3, #0
   21b14:	d02f      	beq.n	21b76 <z_move_thread_to_end_of_prio_q+0xe6>
	if (thread_1->base.prio < thread_2->base.prio) {
   21b16:	f994 700e 	ldrsb.w	r7, [r4, #14]
   21b1a:	f993 600e 	ldrsb.w	r6, [r3, #14]
   21b1e:	42b7      	cmp	r7, r6
   21b20:	db03      	blt.n	21b2a <z_move_thread_to_end_of_prio_q+0x9a>
	return (node == list->tail) ? NULL : node->next;
   21b22:	4283      	cmp	r3, r0
   21b24:	d027      	beq.n	21b76 <z_move_thread_to_end_of_prio_q+0xe6>
   21b26:	681b      	ldr	r3, [r3, #0]
   21b28:	e7f3      	b.n	21b12 <z_move_thread_to_end_of_prio_q+0x82>
	node->prev = successor->prev;
   21b2a:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   21b2c:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
   21b30:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   21b32:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   21b34:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
   21b36:	6890      	ldr	r0, [r2, #8]
   21b38:	f063 037f 	orn	r3, r3, #127	; 0x7f
   21b3c:	7363      	strb	r3, [r4, #13]
   21b3e:	1b03      	subs	r3, r0, r4
   21b40:	4258      	negs	r0, r3
   21b42:	4158      	adcs	r0, r3
   21b44:	f7ff fdb6 	bl	216b4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21b48:	480e      	ldr	r0, [pc, #56]	; (21b84 <z_move_thread_to_end_of_prio_q+0xf4>)
   21b4a:	f000 ffcd 	bl	22ae8 <z_spin_unlock_valid>
   21b4e:	b968      	cbnz	r0, 21b6c <z_move_thread_to_end_of_prio_q+0xdc>
   21b50:	4a0d      	ldr	r2, [pc, #52]	; (21b88 <z_move_thread_to_end_of_prio_q+0xf8>)
   21b52:	4916      	ldr	r1, [pc, #88]	; (21bac <z_move_thread_to_end_of_prio_q+0x11c>)
   21b54:	480e      	ldr	r0, [pc, #56]	; (21b90 <z_move_thread_to_end_of_prio_q+0x100>)
   21b56:	235d      	movs	r3, #93	; 0x5d
   21b58:	f002 f9c3 	bl	23ee2 <printk>
   21b5c:	4909      	ldr	r1, [pc, #36]	; (21b84 <z_move_thread_to_end_of_prio_q+0xf4>)
   21b5e:	4814      	ldr	r0, [pc, #80]	; (21bb0 <z_move_thread_to_end_of_prio_q+0x120>)
   21b60:	f002 f9bf 	bl	23ee2 <printk>
   21b64:	4808      	ldr	r0, [pc, #32]	; (21b88 <z_move_thread_to_end_of_prio_q+0xf8>)
   21b66:	215d      	movs	r1, #93	; 0x5d
   21b68:	f002 f9fe 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   21b6c:	f385 8811 	msr	BASEPRI, r5
   21b70:	f3bf 8f6f 	isb	sy
}
   21b74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	node->prev = list->tail;
   21b76:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   21b7a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   21b7c:	601c      	str	r4, [r3, #0]
	list->tail = node;
   21b7e:	62d4      	str	r4, [r2, #44]	; 0x2c
}
   21b80:	e7d8      	b.n	21b34 <z_move_thread_to_end_of_prio_q+0xa4>
   21b82:	bf00      	nop
   21b84:	20001db4 	.word	0x20001db4
   21b88:	0002ae90 	.word	0x0002ae90
   21b8c:	0002aeb2 	.word	0x0002aeb2
   21b90:	0002a5e8 	.word	0x0002a5e8
   21b94:	0002aec7 	.word	0x0002aec7
   21b98:	20001da8 	.word	0x20001da8
   21b9c:	20001c4c 	.word	0x20001c4c
   21ba0:	0003133f 	.word	0x0003133f
   21ba4:	00031306 	.word	0x00031306
   21ba8:	20001d80 	.word	0x20001d80
   21bac:	0002aedf 	.word	0x0002aedf
   21bb0:	0002aef6 	.word	0x0002aef6

00021bb4 <z_time_slice>:
{
   21bb4:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   21bb6:	4a15      	ldr	r2, [pc, #84]	; (21c0c <z_time_slice+0x58>)
   21bb8:	4b15      	ldr	r3, [pc, #84]	; (21c10 <z_time_slice+0x5c>)
   21bba:	6814      	ldr	r4, [r2, #0]
{
   21bbc:	4601      	mov	r1, r0
	if (pending_current == _current) {
   21bbe:	6898      	ldr	r0, [r3, #8]
   21bc0:	42a0      	cmp	r0, r4
   21bc2:	461c      	mov	r4, r3
   21bc4:	d103      	bne.n	21bce <z_time_slice+0x1a>
}
   21bc6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   21bca:	f7ff bb29 	b.w	21220 <z_reset_time_slice>
	pending_current = NULL;
   21bce:	2500      	movs	r5, #0
   21bd0:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
   21bd2:	4a10      	ldr	r2, [pc, #64]	; (21c14 <z_time_slice+0x60>)
   21bd4:	6812      	ldr	r2, [r2, #0]
   21bd6:	b1b2      	cbz	r2, 21c06 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   21bd8:	89c2      	ldrh	r2, [r0, #14]
   21bda:	2a7f      	cmp	r2, #127	; 0x7f
   21bdc:	d813      	bhi.n	21c06 <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   21bde:	4a0e      	ldr	r2, [pc, #56]	; (21c18 <z_time_slice+0x64>)
   21be0:	f990 500e 	ldrsb.w	r5, [r0, #14]
   21be4:	6812      	ldr	r2, [r2, #0]
   21be6:	4295      	cmp	r5, r2
   21be8:	db0d      	blt.n	21c06 <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
   21bea:	4a0c      	ldr	r2, [pc, #48]	; (21c1c <z_time_slice+0x68>)
   21bec:	4290      	cmp	r0, r2
   21bee:	d00a      	beq.n	21c06 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   21bf0:	6982      	ldr	r2, [r0, #24]
   21bf2:	b942      	cbnz	r2, 21c06 <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   21bf4:	691a      	ldr	r2, [r3, #16]
   21bf6:	428a      	cmp	r2, r1
   21bf8:	dc02      	bgt.n	21c00 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   21bfa:	f7ff ff49 	bl	21a90 <z_move_thread_to_end_of_prio_q>
   21bfe:	e7e2      	b.n	21bc6 <z_time_slice+0x12>
			_current_cpu->slice_ticks -= ticks;
   21c00:	1a52      	subs	r2, r2, r1
   21c02:	611a      	str	r2, [r3, #16]
}
   21c04:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   21c06:	2300      	movs	r3, #0
   21c08:	6123      	str	r3, [r4, #16]
   21c0a:	e7fb      	b.n	21c04 <z_time_slice+0x50>
   21c0c:	20001db0 	.word	0x20001db0
   21c10:	20001d80 	.word	0x20001d80
   21c14:	20001dbc 	.word	0x20001dbc
   21c18:	20001db8 	.word	0x20001db8
   21c1c:	20001c4c 	.word	0x20001c4c

00021c20 <z_impl_k_thread_suspend>:
{
   21c20:	b570      	push	{r4, r5, r6, lr}
   21c22:	4604      	mov	r4, r0
	return z_abort_timeout(&thread->base.timeout);
   21c24:	3018      	adds	r0, #24
   21c26:	f001 f979 	bl	22f1c <z_abort_timeout>
	__asm__ volatile(
   21c2a:	f04f 0320 	mov.w	r3, #32
   21c2e:	f3ef 8611 	mrs	r6, BASEPRI
   21c32:	f383 8811 	msr	BASEPRI, r3
   21c36:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21c3a:	4825      	ldr	r0, [pc, #148]	; (21cd0 <z_impl_k_thread_suspend+0xb0>)
   21c3c:	f000 ff46 	bl	22acc <z_spin_lock_valid>
   21c40:	b968      	cbnz	r0, 21c5e <z_impl_k_thread_suspend+0x3e>
   21c42:	4a24      	ldr	r2, [pc, #144]	; (21cd4 <z_impl_k_thread_suspend+0xb4>)
   21c44:	4924      	ldr	r1, [pc, #144]	; (21cd8 <z_impl_k_thread_suspend+0xb8>)
   21c46:	4825      	ldr	r0, [pc, #148]	; (21cdc <z_impl_k_thread_suspend+0xbc>)
   21c48:	234a      	movs	r3, #74	; 0x4a
   21c4a:	f002 f94a 	bl	23ee2 <printk>
   21c4e:	4920      	ldr	r1, [pc, #128]	; (21cd0 <z_impl_k_thread_suspend+0xb0>)
   21c50:	4823      	ldr	r0, [pc, #140]	; (21ce0 <z_impl_k_thread_suspend+0xc0>)
   21c52:	f002 f946 	bl	23ee2 <printk>
   21c56:	481f      	ldr	r0, [pc, #124]	; (21cd4 <z_impl_k_thread_suspend+0xb4>)
   21c58:	214a      	movs	r1, #74	; 0x4a
   21c5a:	f002 f985 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21c5e:	481c      	ldr	r0, [pc, #112]	; (21cd0 <z_impl_k_thread_suspend+0xb0>)
   21c60:	f000 ff52 	bl	22b08 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   21c64:	f994 300d 	ldrsb.w	r3, [r4, #13]
   21c68:	2b00      	cmp	r3, #0
   21c6a:	da07      	bge.n	21c7c <z_impl_k_thread_suspend+0x5c>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   21c6c:	481d      	ldr	r0, [pc, #116]	; (21ce4 <z_impl_k_thread_suspend+0xc4>)
   21c6e:	4621      	mov	r1, r4
   21c70:	f7ff fc9c 	bl	215ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   21c74:	7b63      	ldrb	r3, [r4, #13]
   21c76:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   21c7a:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   21c7c:	4d1a      	ldr	r5, [pc, #104]	; (21ce8 <z_impl_k_thread_suspend+0xc8>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   21c7e:	7b63      	ldrb	r3, [r4, #13]
   21c80:	68a8      	ldr	r0, [r5, #8]
   21c82:	f043 0310 	orr.w	r3, r3, #16
   21c86:	7363      	strb	r3, [r4, #13]
   21c88:	1b03      	subs	r3, r0, r4
   21c8a:	4258      	negs	r0, r3
   21c8c:	4158      	adcs	r0, r3
   21c8e:	f7ff fd11 	bl	216b4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21c92:	480f      	ldr	r0, [pc, #60]	; (21cd0 <z_impl_k_thread_suspend+0xb0>)
   21c94:	f000 ff28 	bl	22ae8 <z_spin_unlock_valid>
   21c98:	b968      	cbnz	r0, 21cb6 <z_impl_k_thread_suspend+0x96>
   21c9a:	4a0e      	ldr	r2, [pc, #56]	; (21cd4 <z_impl_k_thread_suspend+0xb4>)
   21c9c:	4913      	ldr	r1, [pc, #76]	; (21cec <z_impl_k_thread_suspend+0xcc>)
   21c9e:	480f      	ldr	r0, [pc, #60]	; (21cdc <z_impl_k_thread_suspend+0xbc>)
   21ca0:	235d      	movs	r3, #93	; 0x5d
   21ca2:	f002 f91e 	bl	23ee2 <printk>
   21ca6:	490a      	ldr	r1, [pc, #40]	; (21cd0 <z_impl_k_thread_suspend+0xb0>)
   21ca8:	4811      	ldr	r0, [pc, #68]	; (21cf0 <z_impl_k_thread_suspend+0xd0>)
   21caa:	f002 f91a 	bl	23ee2 <printk>
   21cae:	4809      	ldr	r0, [pc, #36]	; (21cd4 <z_impl_k_thread_suspend+0xb4>)
   21cb0:	215d      	movs	r1, #93	; 0x5d
   21cb2:	f002 f959 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   21cb6:	f386 8811 	msr	BASEPRI, r6
   21cba:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   21cbe:	68ab      	ldr	r3, [r5, #8]
   21cc0:	42a3      	cmp	r3, r4
   21cc2:	d103      	bne.n	21ccc <z_impl_k_thread_suspend+0xac>
}
   21cc4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   21cc8:	f007 bae2 	b.w	29290 <z_reschedule_unlocked>
}
   21ccc:	bd70      	pop	{r4, r5, r6, pc}
   21cce:	bf00      	nop
   21cd0:	20001db4 	.word	0x20001db4
   21cd4:	0002ae90 	.word	0x0002ae90
   21cd8:	0002aeb2 	.word	0x0002aeb2
   21cdc:	0002a5e8 	.word	0x0002a5e8
   21ce0:	0002aec7 	.word	0x0002aec7
   21ce4:	20001da8 	.word	0x20001da8
   21ce8:	20001d80 	.word	0x20001d80
   21cec:	0002aedf 	.word	0x0002aedf
   21cf0:	0002aef6 	.word	0x0002aef6

00021cf4 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   21cf4:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
   21cf6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21cfa:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   21cfc:	b103      	cbz	r3, 21d00 <z_thread_single_abort+0xc>
		thread->fn_abort();
   21cfe:	4798      	blx	r3
   21d00:	f104 0018 	add.w	r0, r4, #24
   21d04:	f001 f90a 	bl	22f1c <z_abort_timeout>
	__asm__ volatile(
   21d08:	f04f 0320 	mov.w	r3, #32
   21d0c:	f3ef 8611 	mrs	r6, BASEPRI
   21d10:	f383 8811 	msr	BASEPRI, r3
   21d14:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21d18:	4838      	ldr	r0, [pc, #224]	; (21dfc <z_thread_single_abort+0x108>)
   21d1a:	f000 fed7 	bl	22acc <z_spin_lock_valid>
   21d1e:	b968      	cbnz	r0, 21d3c <z_thread_single_abort+0x48>
   21d20:	4a37      	ldr	r2, [pc, #220]	; (21e00 <z_thread_single_abort+0x10c>)
   21d22:	4938      	ldr	r1, [pc, #224]	; (21e04 <z_thread_single_abort+0x110>)
   21d24:	4838      	ldr	r0, [pc, #224]	; (21e08 <z_thread_single_abort+0x114>)
   21d26:	234a      	movs	r3, #74	; 0x4a
   21d28:	f002 f8db 	bl	23ee2 <printk>
   21d2c:	4933      	ldr	r1, [pc, #204]	; (21dfc <z_thread_single_abort+0x108>)
   21d2e:	4837      	ldr	r0, [pc, #220]	; (21e0c <z_thread_single_abort+0x118>)
   21d30:	f002 f8d7 	bl	23ee2 <printk>
   21d34:	4832      	ldr	r0, [pc, #200]	; (21e00 <z_thread_single_abort+0x10c>)
   21d36:	214a      	movs	r1, #74	; 0x4a
   21d38:	f002 f916 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21d3c:	482f      	ldr	r0, [pc, #188]	; (21dfc <z_thread_single_abort+0x108>)
   21d3e:	f000 fee3 	bl	22b08 <z_spin_lock_set_owner>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   21d42:	7b63      	ldrb	r3, [r4, #13]
   21d44:	06d8      	lsls	r0, r3, #27
   21d46:	d136      	bne.n	21db6 <z_thread_single_abort+0xc2>
		if (z_is_thread_ready(thread)) {
   21d48:	69a2      	ldr	r2, [r4, #24]
   21d4a:	2a00      	cmp	r2, #0
   21d4c:	d133      	bne.n	21db6 <z_thread_single_abort+0xc2>
			if (z_is_thread_queued(thread)) {
   21d4e:	0619      	lsls	r1, r3, #24
   21d50:	d507      	bpl.n	21d62 <z_thread_single_abort+0x6e>
				_priq_run_remove(&_kernel.ready_q.runq,
   21d52:	482f      	ldr	r0, [pc, #188]	; (21e10 <z_thread_single_abort+0x11c>)
   21d54:	4621      	mov	r1, r4
   21d56:	f7ff fc29 	bl	215ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   21d5a:	7b63      	ldrb	r3, [r4, #13]
   21d5c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   21d60:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   21d62:	4b2c      	ldr	r3, [pc, #176]	; (21e14 <z_thread_single_abort+0x120>)
   21d64:	6898      	ldr	r0, [r3, #8]
   21d66:	1b02      	subs	r2, r0, r4
   21d68:	4250      	negs	r0, r2
   21d6a:	4150      	adcs	r0, r2
   21d6c:	f7ff fca2 	bl	216b4 <update_cache>
		thread->base.thread_state |= mask;
   21d70:	7b63      	ldrb	r3, [r4, #13]
   21d72:	f043 0308 	orr.w	r3, r3, #8
   21d76:	7363      	strb	r3, [r4, #13]
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   21d78:	f104 0828 	add.w	r8, r4, #40	; 0x28
			waiter->base.pended_on = NULL;
   21d7c:	2700      	movs	r7, #0
	return list->head == list;
   21d7e:	6aa5      	ldr	r5, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   21d80:	4545      	cmp	r5, r8
   21d82:	d000      	beq.n	21d86 <z_thread_single_abort+0x92>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
   21d84:	bb3d      	cbnz	r5, 21dd6 <z_thread_single_abort+0xe2>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21d86:	481d      	ldr	r0, [pc, #116]	; (21dfc <z_thread_single_abort+0x108>)
   21d88:	f000 feae 	bl	22ae8 <z_spin_unlock_valid>
   21d8c:	b968      	cbnz	r0, 21daa <z_thread_single_abort+0xb6>
   21d8e:	4a1c      	ldr	r2, [pc, #112]	; (21e00 <z_thread_single_abort+0x10c>)
   21d90:	4921      	ldr	r1, [pc, #132]	; (21e18 <z_thread_single_abort+0x124>)
   21d92:	481d      	ldr	r0, [pc, #116]	; (21e08 <z_thread_single_abort+0x114>)
   21d94:	235d      	movs	r3, #93	; 0x5d
   21d96:	f002 f8a4 	bl	23ee2 <printk>
   21d9a:	4918      	ldr	r1, [pc, #96]	; (21dfc <z_thread_single_abort+0x108>)
   21d9c:	481f      	ldr	r0, [pc, #124]	; (21e1c <z_thread_single_abort+0x128>)
   21d9e:	f002 f8a0 	bl	23ee2 <printk>
   21da2:	4817      	ldr	r0, [pc, #92]	; (21e00 <z_thread_single_abort+0x10c>)
   21da4:	215d      	movs	r1, #93	; 0x5d
   21da6:	f002 f8df 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   21daa:	f386 8811 	msr	BASEPRI, r6
   21dae:	f3bf 8f6f 	isb	sy
}
   21db2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (z_is_thread_pending(thread)) {
   21db6:	079b      	lsls	r3, r3, #30
   21db8:	d5da      	bpl.n	21d70 <z_thread_single_abort+0x7c>
				_priq_wait_remove(&pended_on(thread)->waitq,
   21dba:	f104 0008 	add.w	r0, r4, #8
   21dbe:	f7ff fa17 	bl	211f0 <pended_on.isra.0>
   21dc2:	4621      	mov	r1, r4
   21dc4:	f7ff fbf2 	bl	215ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   21dc8:	7b63      	ldrb	r3, [r4, #13]
   21dca:	f023 0302 	bic.w	r3, r3, #2
   21dce:	7363      	strb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   21dd0:	2300      	movs	r3, #0
   21dd2:	60a3      	str	r3, [r4, #8]
   21dd4:	e7cc      	b.n	21d70 <z_thread_single_abort+0x7c>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
   21dd6:	f105 0008 	add.w	r0, r5, #8
   21dda:	f7ff fa09 	bl	211f0 <pended_on.isra.0>
   21dde:	4629      	mov	r1, r5
   21de0:	f7ff fbe4 	bl	215ac <z_priq_dumb_remove>
   21de4:	7b6b      	ldrb	r3, [r5, #13]
			waiter->base.pended_on = NULL;
   21de6:	60af      	str	r7, [r5, #8]
   21de8:	f023 0302 	bic.w	r3, r3, #2
   21dec:	736b      	strb	r3, [r5, #13]
   21dee:	f8c5 7090 	str.w	r7, [r5, #144]	; 0x90
			ready_thread(waiter);
   21df2:	4628      	mov	r0, r5
   21df4:	f7ff fcfe 	bl	217f4 <ready_thread>
   21df8:	e7c1      	b.n	21d7e <z_thread_single_abort+0x8a>
   21dfa:	bf00      	nop
   21dfc:	20001db4 	.word	0x20001db4
   21e00:	0002ae90 	.word	0x0002ae90
   21e04:	0002aeb2 	.word	0x0002aeb2
   21e08:	0002a5e8 	.word	0x0002a5e8
   21e0c:	0002aec7 	.word	0x0002aec7
   21e10:	20001da8 	.word	0x20001da8
   21e14:	20001d80 	.word	0x20001d80
   21e18:	0002aedf 	.word	0x0002aedf
   21e1c:	0002aef6 	.word	0x0002aef6

00021e20 <unready_thread>:
{
   21e20:	b510      	push	{r4, lr}
	if (z_is_thread_queued(thread)) {
   21e22:	f990 300d 	ldrsb.w	r3, [r0, #13]
   21e26:	2b00      	cmp	r3, #0
{
   21e28:	4604      	mov	r4, r0
	if (z_is_thread_queued(thread)) {
   21e2a:	da07      	bge.n	21e3c <unready_thread+0x1c>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   21e2c:	4601      	mov	r1, r0
   21e2e:	4808      	ldr	r0, [pc, #32]	; (21e50 <unready_thread+0x30>)
   21e30:	f7ff fbbc 	bl	215ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   21e34:	7b63      	ldrb	r3, [r4, #13]
   21e36:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   21e3a:	7363      	strb	r3, [r4, #13]
	update_cache(thread == _current);
   21e3c:	4b05      	ldr	r3, [pc, #20]	; (21e54 <unready_thread+0x34>)
   21e3e:	6898      	ldr	r0, [r3, #8]
   21e40:	1b03      	subs	r3, r0, r4
   21e42:	4258      	negs	r0, r3
}
   21e44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	update_cache(thread == _current);
   21e48:	4158      	adcs	r0, r3
   21e4a:	f7ff bc33 	b.w	216b4 <update_cache>
   21e4e:	bf00      	nop
   21e50:	20001da8 	.word	0x20001da8
   21e54:	20001d80 	.word	0x20001d80

00021e58 <z_remove_thread_from_ready_q>:
{
   21e58:	b538      	push	{r3, r4, r5, lr}
   21e5a:	4604      	mov	r4, r0
	__asm__ volatile(
   21e5c:	f04f 0320 	mov.w	r3, #32
   21e60:	f3ef 8511 	mrs	r5, BASEPRI
   21e64:	f383 8811 	msr	BASEPRI, r3
   21e68:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21e6c:	4817      	ldr	r0, [pc, #92]	; (21ecc <z_remove_thread_from_ready_q+0x74>)
   21e6e:	f000 fe2d 	bl	22acc <z_spin_lock_valid>
   21e72:	b968      	cbnz	r0, 21e90 <z_remove_thread_from_ready_q+0x38>
   21e74:	4a16      	ldr	r2, [pc, #88]	; (21ed0 <z_remove_thread_from_ready_q+0x78>)
   21e76:	4917      	ldr	r1, [pc, #92]	; (21ed4 <z_remove_thread_from_ready_q+0x7c>)
   21e78:	4817      	ldr	r0, [pc, #92]	; (21ed8 <z_remove_thread_from_ready_q+0x80>)
   21e7a:	234a      	movs	r3, #74	; 0x4a
   21e7c:	f002 f831 	bl	23ee2 <printk>
   21e80:	4912      	ldr	r1, [pc, #72]	; (21ecc <z_remove_thread_from_ready_q+0x74>)
   21e82:	4816      	ldr	r0, [pc, #88]	; (21edc <z_remove_thread_from_ready_q+0x84>)
   21e84:	f002 f82d 	bl	23ee2 <printk>
   21e88:	4811      	ldr	r0, [pc, #68]	; (21ed0 <z_remove_thread_from_ready_q+0x78>)
   21e8a:	214a      	movs	r1, #74	; 0x4a
   21e8c:	f002 f86c 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21e90:	480e      	ldr	r0, [pc, #56]	; (21ecc <z_remove_thread_from_ready_q+0x74>)
   21e92:	f000 fe39 	bl	22b08 <z_spin_lock_set_owner>
		unready_thread(thread);
   21e96:	4620      	mov	r0, r4
   21e98:	f7ff ffc2 	bl	21e20 <unready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21e9c:	480b      	ldr	r0, [pc, #44]	; (21ecc <z_remove_thread_from_ready_q+0x74>)
   21e9e:	f000 fe23 	bl	22ae8 <z_spin_unlock_valid>
   21ea2:	b968      	cbnz	r0, 21ec0 <z_remove_thread_from_ready_q+0x68>
   21ea4:	4a0a      	ldr	r2, [pc, #40]	; (21ed0 <z_remove_thread_from_ready_q+0x78>)
   21ea6:	490e      	ldr	r1, [pc, #56]	; (21ee0 <z_remove_thread_from_ready_q+0x88>)
   21ea8:	480b      	ldr	r0, [pc, #44]	; (21ed8 <z_remove_thread_from_ready_q+0x80>)
   21eaa:	235d      	movs	r3, #93	; 0x5d
   21eac:	f002 f819 	bl	23ee2 <printk>
   21eb0:	4906      	ldr	r1, [pc, #24]	; (21ecc <z_remove_thread_from_ready_q+0x74>)
   21eb2:	480c      	ldr	r0, [pc, #48]	; (21ee4 <z_remove_thread_from_ready_q+0x8c>)
   21eb4:	f002 f815 	bl	23ee2 <printk>
   21eb8:	4805      	ldr	r0, [pc, #20]	; (21ed0 <z_remove_thread_from_ready_q+0x78>)
   21eba:	215d      	movs	r1, #93	; 0x5d
   21ebc:	f002 f854 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   21ec0:	f385 8811 	msr	BASEPRI, r5
   21ec4:	f3bf 8f6f 	isb	sy
}
   21ec8:	bd38      	pop	{r3, r4, r5, pc}
   21eca:	bf00      	nop
   21ecc:	20001db4 	.word	0x20001db4
   21ed0:	0002ae90 	.word	0x0002ae90
   21ed4:	0002aeb2 	.word	0x0002aeb2
   21ed8:	0002a5e8 	.word	0x0002a5e8
   21edc:	0002aec7 	.word	0x0002aec7
   21ee0:	0002aedf 	.word	0x0002aedf
   21ee4:	0002aef6 	.word	0x0002aef6

00021ee8 <add_to_waitq_locked>:
{
   21ee8:	b538      	push	{r3, r4, r5, lr}
   21eea:	4604      	mov	r4, r0
   21eec:	460d      	mov	r5, r1
	unready_thread(thread);
   21eee:	f7ff ff97 	bl	21e20 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   21ef2:	7b63      	ldrb	r3, [r4, #13]
   21ef4:	f043 0302 	orr.w	r3, r3, #2
   21ef8:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   21efa:	b33d      	cbz	r5, 21f4c <add_to_waitq_locked+0x64>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   21efc:	4b17      	ldr	r3, [pc, #92]	; (21f5c <add_to_waitq_locked+0x74>)
		thread->base.pended_on = wait_q;
   21efe:	60a5      	str	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   21f00:	429c      	cmp	r4, r3
   21f02:	d10b      	bne.n	21f1c <add_to_waitq_locked+0x34>
   21f04:	4916      	ldr	r1, [pc, #88]	; (21f60 <add_to_waitq_locked+0x78>)
   21f06:	4817      	ldr	r0, [pc, #92]	; (21f64 <add_to_waitq_locked+0x7c>)
   21f08:	4a17      	ldr	r2, [pc, #92]	; (21f68 <add_to_waitq_locked+0x80>)
   21f0a:	f44f 7355 	mov.w	r3, #852	; 0x354
   21f0e:	f001 ffe8 	bl	23ee2 <printk>
   21f12:	4815      	ldr	r0, [pc, #84]	; (21f68 <add_to_waitq_locked+0x80>)
   21f14:	f44f 7155 	mov.w	r1, #852	; 0x354
   21f18:	f002 f826 	bl	23f68 <assert_post_action>
	return list->head == list;
   21f1c:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   21f1e:	429d      	cmp	r5, r3
   21f20:	bf08      	it	eq
   21f22:	2300      	moveq	r3, #0
   21f24:	2b00      	cmp	r3, #0
   21f26:	bf38      	it	cc
   21f28:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   21f2a:	b183      	cbz	r3, 21f4e <add_to_waitq_locked+0x66>
	if (thread_1->base.prio < thread_2->base.prio) {
   21f2c:	f994 100e 	ldrsb.w	r1, [r4, #14]
   21f30:	f993 200e 	ldrsb.w	r2, [r3, #14]
   21f34:	4291      	cmp	r1, r2
   21f36:	db04      	blt.n	21f42 <add_to_waitq_locked+0x5a>
	return (node == list->tail) ? NULL : node->next;
   21f38:	686a      	ldr	r2, [r5, #4]
   21f3a:	429a      	cmp	r2, r3
   21f3c:	d007      	beq.n	21f4e <add_to_waitq_locked+0x66>
   21f3e:	681b      	ldr	r3, [r3, #0]
   21f40:	e7f3      	b.n	21f2a <add_to_waitq_locked+0x42>
	node->prev = successor->prev;
   21f42:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   21f44:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   21f48:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   21f4a:	605c      	str	r4, [r3, #4]
}
   21f4c:	bd38      	pop	{r3, r4, r5, pc}
	node->prev = list->tail;
   21f4e:	686b      	ldr	r3, [r5, #4]
   21f50:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   21f52:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   21f54:	6025      	str	r5, [r4, #0]
	list->tail->next = node;
   21f56:	601c      	str	r4, [r3, #0]
	list->tail = node;
   21f58:	606c      	str	r4, [r5, #4]
   21f5a:	e7f7      	b.n	21f4c <add_to_waitq_locked+0x64>
   21f5c:	20001c4c 	.word	0x20001c4c
   21f60:	0003133f 	.word	0x0003133f
   21f64:	0002a5e8 	.word	0x0002a5e8
   21f68:	00031306 	.word	0x00031306

00021f6c <pend>:
{
   21f6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   21f6e:	4604      	mov	r4, r0
   21f70:	460e      	mov	r6, r1
   21f72:	4615      	mov	r5, r2
	__asm__ volatile(
   21f74:	f04f 0320 	mov.w	r3, #32
   21f78:	f3ef 8711 	mrs	r7, BASEPRI
   21f7c:	f383 8811 	msr	BASEPRI, r3
   21f80:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21f84:	4822      	ldr	r0, [pc, #136]	; (22010 <pend+0xa4>)
   21f86:	f000 fda1 	bl	22acc <z_spin_lock_valid>
   21f8a:	b968      	cbnz	r0, 21fa8 <pend+0x3c>
   21f8c:	4a21      	ldr	r2, [pc, #132]	; (22014 <pend+0xa8>)
   21f8e:	4922      	ldr	r1, [pc, #136]	; (22018 <pend+0xac>)
   21f90:	4822      	ldr	r0, [pc, #136]	; (2201c <pend+0xb0>)
   21f92:	234a      	movs	r3, #74	; 0x4a
   21f94:	f001 ffa5 	bl	23ee2 <printk>
   21f98:	491d      	ldr	r1, [pc, #116]	; (22010 <pend+0xa4>)
   21f9a:	4821      	ldr	r0, [pc, #132]	; (22020 <pend+0xb4>)
   21f9c:	f001 ffa1 	bl	23ee2 <printk>
   21fa0:	481c      	ldr	r0, [pc, #112]	; (22014 <pend+0xa8>)
   21fa2:	214a      	movs	r1, #74	; 0x4a
   21fa4:	f001 ffe0 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   21fa8:	4819      	ldr	r0, [pc, #100]	; (22010 <pend+0xa4>)
   21faa:	f000 fdad 	bl	22b08 <z_spin_lock_set_owner>
		add_to_waitq_locked(thread, wait_q);
   21fae:	4620      	mov	r0, r4
   21fb0:	4631      	mov	r1, r6
   21fb2:	f7ff ff99 	bl	21ee8 <add_to_waitq_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   21fb6:	4816      	ldr	r0, [pc, #88]	; (22010 <pend+0xa4>)
   21fb8:	f000 fd96 	bl	22ae8 <z_spin_unlock_valid>
   21fbc:	b968      	cbnz	r0, 21fda <pend+0x6e>
   21fbe:	4a15      	ldr	r2, [pc, #84]	; (22014 <pend+0xa8>)
   21fc0:	4918      	ldr	r1, [pc, #96]	; (22024 <pend+0xb8>)
   21fc2:	4816      	ldr	r0, [pc, #88]	; (2201c <pend+0xb0>)
   21fc4:	235d      	movs	r3, #93	; 0x5d
   21fc6:	f001 ff8c 	bl	23ee2 <printk>
   21fca:	4911      	ldr	r1, [pc, #68]	; (22010 <pend+0xa4>)
   21fcc:	4816      	ldr	r0, [pc, #88]	; (22028 <pend+0xbc>)
   21fce:	f001 ff88 	bl	23ee2 <printk>
   21fd2:	4810      	ldr	r0, [pc, #64]	; (22014 <pend+0xa8>)
   21fd4:	215d      	movs	r1, #93	; 0x5d
   21fd6:	f001 ffc7 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   21fda:	f387 8811 	msr	BASEPRI, r7
   21fde:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   21fe2:	1c6b      	adds	r3, r5, #1
   21fe4:	d013      	beq.n	2200e <pend+0xa2>
   21fe6:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   21fea:	f240 30e7 	movw	r0, #999	; 0x3e7
   21fee:	2100      	movs	r1, #0
   21ff0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   21ff4:	2300      	movs	r3, #0
   21ff6:	fbe6 0105 	umlal	r0, r1, r6, r5
   21ffa:	f7de f8d1 	bl	1a0 <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   21ffe:	490b      	ldr	r1, [pc, #44]	; (2202c <pend+0xc0>)
   22000:	1c42      	adds	r2, r0, #1
   22002:	f104 0018 	add.w	r0, r4, #24
}
   22006:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   2200a:	f000 bedf 	b.w	22dcc <z_add_timeout>
   2200e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   22010:	20001db4 	.word	0x20001db4
   22014:	0002ae90 	.word	0x0002ae90
   22018:	0002aeb2 	.word	0x0002aeb2
   2201c:	0002a5e8 	.word	0x0002a5e8
   22020:	0002aec7 	.word	0x0002aec7
   22024:	0002aedf 	.word	0x0002aedf
   22028:	0002aef6 	.word	0x0002aef6
   2202c:	00021921 	.word	0x00021921

00022030 <z_pend_curr_irqlock>:
{
   22030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pend(_current, wait_q, timeout);
   22032:	4d23      	ldr	r5, [pc, #140]	; (220c0 <z_pend_curr_irqlock+0x90>)
	pending_current = _current;
   22034:	4c23      	ldr	r4, [pc, #140]	; (220c4 <z_pend_curr_irqlock+0x94>)
{
   22036:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
   22038:	68a8      	ldr	r0, [r5, #8]
   2203a:	f7ff ff97 	bl	21f6c <pend>
	pending_current = _current;
   2203e:	68ab      	ldr	r3, [r5, #8]
   22040:	6023      	str	r3, [r4, #0]
   22042:	4630      	mov	r0, r6
   22044:	f7e2 fc30 	bl	48a8 <arch_swap>
   22048:	4606      	mov	r6, r0
	__asm__ volatile(
   2204a:	f04f 0320 	mov.w	r3, #32
   2204e:	f3ef 8711 	mrs	r7, BASEPRI
   22052:	f383 8811 	msr	BASEPRI, r3
   22056:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2205a:	481b      	ldr	r0, [pc, #108]	; (220c8 <z_pend_curr_irqlock+0x98>)
   2205c:	f000 fd36 	bl	22acc <z_spin_lock_valid>
   22060:	b968      	cbnz	r0, 2207e <z_pend_curr_irqlock+0x4e>
   22062:	4a1a      	ldr	r2, [pc, #104]	; (220cc <z_pend_curr_irqlock+0x9c>)
   22064:	491a      	ldr	r1, [pc, #104]	; (220d0 <z_pend_curr_irqlock+0xa0>)
   22066:	481b      	ldr	r0, [pc, #108]	; (220d4 <z_pend_curr_irqlock+0xa4>)
   22068:	234a      	movs	r3, #74	; 0x4a
   2206a:	f001 ff3a 	bl	23ee2 <printk>
   2206e:	4916      	ldr	r1, [pc, #88]	; (220c8 <z_pend_curr_irqlock+0x98>)
   22070:	4819      	ldr	r0, [pc, #100]	; (220d8 <z_pend_curr_irqlock+0xa8>)
   22072:	f001 ff36 	bl	23ee2 <printk>
   22076:	4815      	ldr	r0, [pc, #84]	; (220cc <z_pend_curr_irqlock+0x9c>)
   22078:	214a      	movs	r1, #74	; 0x4a
   2207a:	f001 ff75 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   2207e:	4812      	ldr	r0, [pc, #72]	; (220c8 <z_pend_curr_irqlock+0x98>)
   22080:	f000 fd42 	bl	22b08 <z_spin_lock_set_owner>
		if (pending_current == _current) {
   22084:	6823      	ldr	r3, [r4, #0]
   22086:	68aa      	ldr	r2, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   22088:	480f      	ldr	r0, [pc, #60]	; (220c8 <z_pend_curr_irqlock+0x98>)
   2208a:	429a      	cmp	r2, r3
			pending_current = NULL;
   2208c:	bf04      	itt	eq
   2208e:	2300      	moveq	r3, #0
   22090:	6023      	streq	r3, [r4, #0]
   22092:	f000 fd29 	bl	22ae8 <z_spin_unlock_valid>
   22096:	b968      	cbnz	r0, 220b4 <z_pend_curr_irqlock+0x84>
   22098:	4a0c      	ldr	r2, [pc, #48]	; (220cc <z_pend_curr_irqlock+0x9c>)
   2209a:	4910      	ldr	r1, [pc, #64]	; (220dc <z_pend_curr_irqlock+0xac>)
   2209c:	480d      	ldr	r0, [pc, #52]	; (220d4 <z_pend_curr_irqlock+0xa4>)
   2209e:	235d      	movs	r3, #93	; 0x5d
   220a0:	f001 ff1f 	bl	23ee2 <printk>
   220a4:	4908      	ldr	r1, [pc, #32]	; (220c8 <z_pend_curr_irqlock+0x98>)
   220a6:	480e      	ldr	r0, [pc, #56]	; (220e0 <z_pend_curr_irqlock+0xb0>)
   220a8:	f001 ff1b 	bl	23ee2 <printk>
   220ac:	4807      	ldr	r0, [pc, #28]	; (220cc <z_pend_curr_irqlock+0x9c>)
   220ae:	215d      	movs	r1, #93	; 0x5d
   220b0:	f001 ff5a 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   220b4:	f387 8811 	msr	BASEPRI, r7
   220b8:	f3bf 8f6f 	isb	sy
}
   220bc:	4630      	mov	r0, r6
   220be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   220c0:	20001d80 	.word	0x20001d80
   220c4:	20001db0 	.word	0x20001db0
   220c8:	20001db4 	.word	0x20001db4
   220cc:	0002ae90 	.word	0x0002ae90
   220d0:	0002aeb2 	.word	0x0002aeb2
   220d4:	0002a5e8 	.word	0x0002a5e8
   220d8:	0002aec7 	.word	0x0002aec7
   220dc:	0002aedf 	.word	0x0002aedf
   220e0:	0002aef6 	.word	0x0002aef6

000220e4 <z_pend_curr>:
{
   220e4:	b538      	push	{r3, r4, r5, lr}
   220e6:	460d      	mov	r5, r1
   220e8:	4611      	mov	r1, r2
	pending_current = _current;
   220ea:	4a0f      	ldr	r2, [pc, #60]	; (22128 <z_pend_curr+0x44>)
{
   220ec:	4604      	mov	r4, r0
	pending_current = _current;
   220ee:	6890      	ldr	r0, [r2, #8]
   220f0:	4a0e      	ldr	r2, [pc, #56]	; (2212c <z_pend_curr+0x48>)
   220f2:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
   220f4:	461a      	mov	r2, r3
   220f6:	f7ff ff39 	bl	21f6c <pend>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   220fa:	4620      	mov	r0, r4
   220fc:	f000 fcf4 	bl	22ae8 <z_spin_unlock_valid>
   22100:	b968      	cbnz	r0, 2211e <z_pend_curr+0x3a>
   22102:	4a0b      	ldr	r2, [pc, #44]	; (22130 <z_pend_curr+0x4c>)
   22104:	490b      	ldr	r1, [pc, #44]	; (22134 <z_pend_curr+0x50>)
   22106:	480c      	ldr	r0, [pc, #48]	; (22138 <z_pend_curr+0x54>)
   22108:	2374      	movs	r3, #116	; 0x74
   2210a:	f001 feea 	bl	23ee2 <printk>
   2210e:	480b      	ldr	r0, [pc, #44]	; (2213c <z_pend_curr+0x58>)
   22110:	4621      	mov	r1, r4
   22112:	f001 fee6 	bl	23ee2 <printk>
   22116:	4806      	ldr	r0, [pc, #24]	; (22130 <z_pend_curr+0x4c>)
   22118:	2174      	movs	r1, #116	; 0x74
   2211a:	f001 ff25 	bl	23f68 <assert_post_action>
   2211e:	4628      	mov	r0, r5
}
   22120:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   22124:	f7e2 bbc0 	b.w	48a8 <arch_swap>
   22128:	20001d80 	.word	0x20001d80
   2212c:	20001db0 	.word	0x20001db0
   22130:	0002ae90 	.word	0x0002ae90
   22134:	0002aedf 	.word	0x0002aedf
   22138:	0002a5e8 	.word	0x0002a5e8
   2213c:	0002aef6 	.word	0x0002aef6

00022140 <z_set_prio>:
{
   22140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22142:	4604      	mov	r4, r0
   22144:	460e      	mov	r6, r1
	__asm__ volatile(
   22146:	f04f 0320 	mov.w	r3, #32
   2214a:	f3ef 8711 	mrs	r7, BASEPRI
   2214e:	f383 8811 	msr	BASEPRI, r3
   22152:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   22156:	4839      	ldr	r0, [pc, #228]	; (2223c <z_set_prio+0xfc>)
   22158:	f000 fcb8 	bl	22acc <z_spin_lock_valid>
   2215c:	b968      	cbnz	r0, 2217a <z_set_prio+0x3a>
   2215e:	4a38      	ldr	r2, [pc, #224]	; (22240 <z_set_prio+0x100>)
   22160:	4938      	ldr	r1, [pc, #224]	; (22244 <z_set_prio+0x104>)
   22162:	4839      	ldr	r0, [pc, #228]	; (22248 <z_set_prio+0x108>)
   22164:	234a      	movs	r3, #74	; 0x4a
   22166:	f001 febc 	bl	23ee2 <printk>
   2216a:	4934      	ldr	r1, [pc, #208]	; (2223c <z_set_prio+0xfc>)
   2216c:	4837      	ldr	r0, [pc, #220]	; (2224c <z_set_prio+0x10c>)
   2216e:	f001 feb8 	bl	23ee2 <printk>
   22172:	4833      	ldr	r0, [pc, #204]	; (22240 <z_set_prio+0x100>)
   22174:	214a      	movs	r1, #74	; 0x4a
   22176:	f001 fef7 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   2217a:	4830      	ldr	r0, [pc, #192]	; (2223c <z_set_prio+0xfc>)
   2217c:	f000 fcc4 	bl	22b08 <z_spin_lock_set_owner>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   22180:	7b63      	ldrb	r3, [r4, #13]
   22182:	06db      	lsls	r3, r3, #27
   22184:	b276      	sxtb	r6, r6
   22186:	d155      	bne.n	22234 <z_set_prio+0xf4>
	return !sys_dnode_is_linked(&t->node);
   22188:	69a5      	ldr	r5, [r4, #24]
		if (need_sched) {
   2218a:	2d00      	cmp	r5, #0
   2218c:	d152      	bne.n	22234 <z_set_prio+0xf4>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   2218e:	4830      	ldr	r0, [pc, #192]	; (22250 <z_set_prio+0x110>)
   22190:	4621      	mov	r1, r4
   22192:	f7ff fa0b 	bl	215ac <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   22196:	4b2f      	ldr	r3, [pc, #188]	; (22254 <z_set_prio+0x114>)
				thread->base.prio = prio;
   22198:	73a6      	strb	r6, [r4, #14]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2219a:	429c      	cmp	r4, r3
   2219c:	d10b      	bne.n	221b6 <z_set_prio+0x76>
   2219e:	492e      	ldr	r1, [pc, #184]	; (22258 <z_set_prio+0x118>)
   221a0:	4829      	ldr	r0, [pc, #164]	; (22248 <z_set_prio+0x108>)
   221a2:	4a2e      	ldr	r2, [pc, #184]	; (2225c <z_set_prio+0x11c>)
   221a4:	f44f 7355 	mov.w	r3, #852	; 0x354
   221a8:	f001 fe9b 	bl	23ee2 <printk>
   221ac:	482b      	ldr	r0, [pc, #172]	; (2225c <z_set_prio+0x11c>)
   221ae:	f44f 7155 	mov.w	r1, #852	; 0x354
   221b2:	f001 fed9 	bl	23f68 <assert_post_action>
	return list->head == list;
   221b6:	4a2a      	ldr	r2, [pc, #168]	; (22260 <z_set_prio+0x120>)
   221b8:	4613      	mov	r3, r2
   221ba:	f853 0f28 	ldr.w	r0, [r3, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   221be:	4298      	cmp	r0, r3
   221c0:	bf18      	it	ne
   221c2:	4605      	movne	r5, r0
   221c4:	2d00      	cmp	r5, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   221c6:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
   221c8:	4619      	mov	r1, r3
   221ca:	462b      	mov	r3, r5
   221cc:	bf38      	it	cc
   221ce:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   221d0:	b353      	cbz	r3, 22228 <z_set_prio+0xe8>
	if (thread_1->base.prio < thread_2->base.prio) {
   221d2:	f994 600e 	ldrsb.w	r6, [r4, #14]
   221d6:	f993 500e 	ldrsb.w	r5, [r3, #14]
   221da:	42ae      	cmp	r6, r5
   221dc:	db03      	blt.n	221e6 <z_set_prio+0xa6>
	return (node == list->tail) ? NULL : node->next;
   221de:	4298      	cmp	r0, r3
   221e0:	d022      	beq.n	22228 <z_set_prio+0xe8>
   221e2:	681b      	ldr	r3, [r3, #0]
   221e4:	e7f4      	b.n	221d0 <z_set_prio+0x90>
	node->prev = successor->prev;
   221e6:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   221e8:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   221ec:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   221ee:	605c      	str	r4, [r3, #4]
			update_cache(1);
   221f0:	2001      	movs	r0, #1
   221f2:	f7ff fa5f 	bl	216b4 <update_cache>
   221f6:	2401      	movs	r4, #1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   221f8:	4810      	ldr	r0, [pc, #64]	; (2223c <z_set_prio+0xfc>)
   221fa:	f000 fc75 	bl	22ae8 <z_spin_unlock_valid>
   221fe:	b968      	cbnz	r0, 2221c <z_set_prio+0xdc>
   22200:	4a0f      	ldr	r2, [pc, #60]	; (22240 <z_set_prio+0x100>)
   22202:	4918      	ldr	r1, [pc, #96]	; (22264 <z_set_prio+0x124>)
   22204:	4810      	ldr	r0, [pc, #64]	; (22248 <z_set_prio+0x108>)
   22206:	235d      	movs	r3, #93	; 0x5d
   22208:	f001 fe6b 	bl	23ee2 <printk>
   2220c:	490b      	ldr	r1, [pc, #44]	; (2223c <z_set_prio+0xfc>)
   2220e:	4816      	ldr	r0, [pc, #88]	; (22268 <z_set_prio+0x128>)
   22210:	f001 fe67 	bl	23ee2 <printk>
   22214:	480a      	ldr	r0, [pc, #40]	; (22240 <z_set_prio+0x100>)
   22216:	215d      	movs	r1, #93	; 0x5d
   22218:	f001 fea6 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   2221c:	f387 8811 	msr	BASEPRI, r7
   22220:	f3bf 8f6f 	isb	sy
}
   22224:	4620      	mov	r0, r4
   22226:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	node->prev = list->tail;
   22228:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   2222c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   2222e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   22230:	62d4      	str	r4, [r2, #44]	; 0x2c
}
   22232:	e7dd      	b.n	221f0 <z_set_prio+0xb0>
			thread->base.prio = prio;
   22234:	73a6      	strb	r6, [r4, #14]
   22236:	2400      	movs	r4, #0
   22238:	e7de      	b.n	221f8 <z_set_prio+0xb8>
   2223a:	bf00      	nop
   2223c:	20001db4 	.word	0x20001db4
   22240:	0002ae90 	.word	0x0002ae90
   22244:	0002aeb2 	.word	0x0002aeb2
   22248:	0002a5e8 	.word	0x0002a5e8
   2224c:	0002aec7 	.word	0x0002aec7
   22250:	20001da8 	.word	0x20001da8
   22254:	20001c4c 	.word	0x20001c4c
   22258:	0003133f 	.word	0x0003133f
   2225c:	00031306 	.word	0x00031306
   22260:	20001d80 	.word	0x20001d80
   22264:	0002aedf 	.word	0x0002aedf
   22268:	0002aef6 	.word	0x0002aef6

0002226c <z_unpend_first_thread>:
{
   2226c:	b538      	push	{r3, r4, r5, lr}
   2226e:	4604      	mov	r4, r0
	__asm__ volatile(
   22270:	f04f 0320 	mov.w	r3, #32
   22274:	f3ef 8511 	mrs	r5, BASEPRI
   22278:	f383 8811 	msr	BASEPRI, r3
   2227c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   22280:	483b      	ldr	r0, [pc, #236]	; (22370 <z_unpend_first_thread+0x104>)
   22282:	f000 fc23 	bl	22acc <z_spin_lock_valid>
   22286:	b968      	cbnz	r0, 222a4 <z_unpend_first_thread+0x38>
   22288:	4a3a      	ldr	r2, [pc, #232]	; (22374 <z_unpend_first_thread+0x108>)
   2228a:	493b      	ldr	r1, [pc, #236]	; (22378 <z_unpend_first_thread+0x10c>)
   2228c:	483b      	ldr	r0, [pc, #236]	; (2237c <z_unpend_first_thread+0x110>)
   2228e:	234a      	movs	r3, #74	; 0x4a
   22290:	f001 fe27 	bl	23ee2 <printk>
   22294:	4936      	ldr	r1, [pc, #216]	; (22370 <z_unpend_first_thread+0x104>)
   22296:	483a      	ldr	r0, [pc, #232]	; (22380 <z_unpend_first_thread+0x114>)
   22298:	f001 fe23 	bl	23ee2 <printk>
   2229c:	4835      	ldr	r0, [pc, #212]	; (22374 <z_unpend_first_thread+0x108>)
   2229e:	214a      	movs	r1, #74	; 0x4a
   222a0:	f001 fe62 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   222a4:	4832      	ldr	r0, [pc, #200]	; (22370 <z_unpend_first_thread+0x104>)
   222a6:	f000 fc2f 	bl	22b08 <z_spin_lock_set_owner>
		ret = _priq_wait_best(&wait_q->waitq);
   222aa:	4620      	mov	r0, r4
   222ac:	f006 fffa 	bl	292a4 <z_priq_dumb_best>
   222b0:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   222b2:	482f      	ldr	r0, [pc, #188]	; (22370 <z_unpend_first_thread+0x104>)
   222b4:	f000 fc18 	bl	22ae8 <z_spin_unlock_valid>
   222b8:	b968      	cbnz	r0, 222d6 <z_unpend_first_thread+0x6a>
   222ba:	4a2e      	ldr	r2, [pc, #184]	; (22374 <z_unpend_first_thread+0x108>)
   222bc:	4931      	ldr	r1, [pc, #196]	; (22384 <z_unpend_first_thread+0x118>)
   222be:	482f      	ldr	r0, [pc, #188]	; (2237c <z_unpend_first_thread+0x110>)
   222c0:	235d      	movs	r3, #93	; 0x5d
   222c2:	f001 fe0e 	bl	23ee2 <printk>
   222c6:	492a      	ldr	r1, [pc, #168]	; (22370 <z_unpend_first_thread+0x104>)
   222c8:	482f      	ldr	r0, [pc, #188]	; (22388 <z_unpend_first_thread+0x11c>)
   222ca:	f001 fe0a 	bl	23ee2 <printk>
   222ce:	4829      	ldr	r0, [pc, #164]	; (22374 <z_unpend_first_thread+0x108>)
   222d0:	215d      	movs	r1, #93	; 0x5d
   222d2:	f001 fe49 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   222d6:	f385 8811 	msr	BASEPRI, r5
   222da:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   222de:	2c00      	cmp	r4, #0
   222e0:	d043      	beq.n	2236a <z_unpend_first_thread+0xfe>
	__asm__ volatile(
   222e2:	f04f 0320 	mov.w	r3, #32
   222e6:	f3ef 8511 	mrs	r5, BASEPRI
   222ea:	f383 8811 	msr	BASEPRI, r3
   222ee:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   222f2:	481f      	ldr	r0, [pc, #124]	; (22370 <z_unpend_first_thread+0x104>)
   222f4:	f000 fbea 	bl	22acc <z_spin_lock_valid>
   222f8:	b968      	cbnz	r0, 22316 <z_unpend_first_thread+0xaa>
   222fa:	4a1e      	ldr	r2, [pc, #120]	; (22374 <z_unpend_first_thread+0x108>)
   222fc:	491e      	ldr	r1, [pc, #120]	; (22378 <z_unpend_first_thread+0x10c>)
   222fe:	481f      	ldr	r0, [pc, #124]	; (2237c <z_unpend_first_thread+0x110>)
   22300:	234a      	movs	r3, #74	; 0x4a
   22302:	f001 fdee 	bl	23ee2 <printk>
   22306:	491a      	ldr	r1, [pc, #104]	; (22370 <z_unpend_first_thread+0x104>)
   22308:	481d      	ldr	r0, [pc, #116]	; (22380 <z_unpend_first_thread+0x114>)
   2230a:	f001 fdea 	bl	23ee2 <printk>
   2230e:	4819      	ldr	r0, [pc, #100]	; (22374 <z_unpend_first_thread+0x108>)
   22310:	214a      	movs	r1, #74	; 0x4a
   22312:	f001 fe29 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   22316:	4816      	ldr	r0, [pc, #88]	; (22370 <z_unpend_first_thread+0x104>)
   22318:	f000 fbf6 	bl	22b08 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2231c:	f104 0008 	add.w	r0, r4, #8
   22320:	f7fe ff66 	bl	211f0 <pended_on.isra.0>
   22324:	4621      	mov	r1, r4
   22326:	f7ff f941 	bl	215ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2232a:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2232c:	4810      	ldr	r0, [pc, #64]	; (22370 <z_unpend_first_thread+0x104>)
   2232e:	f023 0302 	bic.w	r3, r3, #2
   22332:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   22334:	2300      	movs	r3, #0
   22336:	60a3      	str	r3, [r4, #8]
   22338:	f000 fbd6 	bl	22ae8 <z_spin_unlock_valid>
   2233c:	b968      	cbnz	r0, 2235a <z_unpend_first_thread+0xee>
   2233e:	4a0d      	ldr	r2, [pc, #52]	; (22374 <z_unpend_first_thread+0x108>)
   22340:	4910      	ldr	r1, [pc, #64]	; (22384 <z_unpend_first_thread+0x118>)
   22342:	480e      	ldr	r0, [pc, #56]	; (2237c <z_unpend_first_thread+0x110>)
   22344:	235d      	movs	r3, #93	; 0x5d
   22346:	f001 fdcc 	bl	23ee2 <printk>
   2234a:	4909      	ldr	r1, [pc, #36]	; (22370 <z_unpend_first_thread+0x104>)
   2234c:	480e      	ldr	r0, [pc, #56]	; (22388 <z_unpend_first_thread+0x11c>)
   2234e:	f001 fdc8 	bl	23ee2 <printk>
   22352:	4808      	ldr	r0, [pc, #32]	; (22374 <z_unpend_first_thread+0x108>)
   22354:	215d      	movs	r1, #93	; 0x5d
   22356:	f001 fe07 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   2235a:	f385 8811 	msr	BASEPRI, r5
   2235e:	f3bf 8f6f 	isb	sy
	return z_abort_timeout(&thread->base.timeout);
   22362:	f104 0018 	add.w	r0, r4, #24
   22366:	f000 fdd9 	bl	22f1c <z_abort_timeout>
}
   2236a:	4620      	mov	r0, r4
   2236c:	bd38      	pop	{r3, r4, r5, pc}
   2236e:	bf00      	nop
   22370:	20001db4 	.word	0x20001db4
   22374:	0002ae90 	.word	0x0002ae90
   22378:	0002aeb2 	.word	0x0002aeb2
   2237c:	0002a5e8 	.word	0x0002a5e8
   22380:	0002aec7 	.word	0x0002aec7
   22384:	0002aedf 	.word	0x0002aedf
   22388:	0002aef6 	.word	0x0002aef6

0002238c <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   2238c:	4b04      	ldr	r3, [pc, #16]	; (223a0 <z_sched_init+0x14>)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   2238e:	2100      	movs	r1, #0
   22390:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   22394:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   22398:	4608      	mov	r0, r1
   2239a:	f7fe bf57 	b.w	2124c <k_sched_time_slice_set>
   2239e:	bf00      	nop
   223a0:	20001d80 	.word	0x20001d80

000223a4 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   223a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   223a6:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   223aa:	b173      	cbz	r3, 223ca <z_impl_k_yield+0x26>
   223ac:	4946      	ldr	r1, [pc, #280]	; (224c8 <z_impl_k_yield+0x124>)
   223ae:	4a47      	ldr	r2, [pc, #284]	; (224cc <z_impl_k_yield+0x128>)
   223b0:	4847      	ldr	r0, [pc, #284]	; (224d0 <z_impl_k_yield+0x12c>)
   223b2:	f240 435f 	movw	r3, #1119	; 0x45f
   223b6:	f001 fd94 	bl	23ee2 <printk>
   223ba:	4846      	ldr	r0, [pc, #280]	; (224d4 <z_impl_k_yield+0x130>)
   223bc:	f001 fd91 	bl	23ee2 <printk>
   223c0:	4842      	ldr	r0, [pc, #264]	; (224cc <z_impl_k_yield+0x128>)
   223c2:	f240 415f 	movw	r1, #1119	; 0x45f
   223c6:	f001 fdcf 	bl	23f68 <assert_post_action>

	if (!z_is_idle_thread_object(_current)) {
   223ca:	4c43      	ldr	r4, [pc, #268]	; (224d8 <z_impl_k_yield+0x134>)
   223cc:	4e43      	ldr	r6, [pc, #268]	; (224dc <z_impl_k_yield+0x138>)
   223ce:	68a2      	ldr	r2, [r4, #8]
   223d0:	42b2      	cmp	r2, r6
   223d2:	d067      	beq.n	224a4 <z_impl_k_yield+0x100>
	__asm__ volatile(
   223d4:	f04f 0320 	mov.w	r3, #32
   223d8:	f3ef 8711 	mrs	r7, BASEPRI
   223dc:	f383 8811 	msr	BASEPRI, r3
   223e0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   223e4:	483e      	ldr	r0, [pc, #248]	; (224e0 <z_impl_k_yield+0x13c>)
   223e6:	f000 fb71 	bl	22acc <z_spin_lock_valid>
   223ea:	b968      	cbnz	r0, 22408 <z_impl_k_yield+0x64>
   223ec:	4a3d      	ldr	r2, [pc, #244]	; (224e4 <z_impl_k_yield+0x140>)
   223ee:	493e      	ldr	r1, [pc, #248]	; (224e8 <z_impl_k_yield+0x144>)
   223f0:	4837      	ldr	r0, [pc, #220]	; (224d0 <z_impl_k_yield+0x12c>)
   223f2:	234a      	movs	r3, #74	; 0x4a
   223f4:	f001 fd75 	bl	23ee2 <printk>
   223f8:	4939      	ldr	r1, [pc, #228]	; (224e0 <z_impl_k_yield+0x13c>)
   223fa:	483c      	ldr	r0, [pc, #240]	; (224ec <z_impl_k_yield+0x148>)
   223fc:	f001 fd71 	bl	23ee2 <printk>
   22400:	4838      	ldr	r0, [pc, #224]	; (224e4 <z_impl_k_yield+0x140>)
   22402:	214a      	movs	r1, #74	; 0x4a
   22404:	f001 fdb0 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   22408:	4835      	ldr	r0, [pc, #212]	; (224e0 <z_impl_k_yield+0x13c>)
   2240a:	f000 fb7d 	bl	22b08 <z_spin_lock_set_owner>
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
   2240e:	68a1      	ldr	r1, [r4, #8]
   22410:	4837      	ldr	r0, [pc, #220]	; (224f0 <z_impl_k_yield+0x14c>)
   22412:	f7ff f8cb 	bl	215ac <z_priq_dumb_remove>
						 _current);
			}
			_priq_run_add(&_kernel.ready_q.runq, _current);
   22416:	68a5      	ldr	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   22418:	42b5      	cmp	r5, r6
   2241a:	d10b      	bne.n	22434 <z_impl_k_yield+0x90>
   2241c:	4935      	ldr	r1, [pc, #212]	; (224f4 <z_impl_k_yield+0x150>)
   2241e:	482c      	ldr	r0, [pc, #176]	; (224d0 <z_impl_k_yield+0x12c>)
   22420:	4a2a      	ldr	r2, [pc, #168]	; (224cc <z_impl_k_yield+0x128>)
   22422:	f44f 7355 	mov.w	r3, #852	; 0x354
   22426:	f001 fd5c 	bl	23ee2 <printk>
   2242a:	4828      	ldr	r0, [pc, #160]	; (224cc <z_impl_k_yield+0x128>)
   2242c:	f44f 7155 	mov.w	r1, #852	; 0x354
   22430:	f001 fd9a 	bl	23f68 <assert_post_action>
	return list->head == list;
   22434:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   22436:	492e      	ldr	r1, [pc, #184]	; (224f0 <z_impl_k_yield+0x14c>)
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   22438:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2243a:	428b      	cmp	r3, r1
   2243c:	bf08      	it	eq
   2243e:	2300      	moveq	r3, #0
   22440:	2b00      	cmp	r3, #0
   22442:	bf38      	it	cc
   22444:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   22446:	2b00      	cmp	r3, #0
   22448:	d038      	beq.n	224bc <z_impl_k_yield+0x118>
	if (thread_1->base.prio < thread_2->base.prio) {
   2244a:	f995 600e 	ldrsb.w	r6, [r5, #14]
   2244e:	f993 000e 	ldrsb.w	r0, [r3, #14]
   22452:	4286      	cmp	r6, r0
   22454:	db03      	blt.n	2245e <z_impl_k_yield+0xba>
	return (node == list->tail) ? NULL : node->next;
   22456:	4293      	cmp	r3, r2
   22458:	d030      	beq.n	224bc <z_impl_k_yield+0x118>
   2245a:	681b      	ldr	r3, [r3, #0]
   2245c:	e7f3      	b.n	22446 <z_impl_k_yield+0xa2>
	node->prev = successor->prev;
   2245e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   22460:	e9c5 3200 	strd	r3, r2, [r5]
	successor->prev->next = node;
   22464:	6015      	str	r5, [r2, #0]
	successor->prev = node;
   22466:	605d      	str	r5, [r3, #4]
			z_mark_thread_as_queued(_current);
   22468:	68a2      	ldr	r2, [r4, #8]
	thread->base.thread_state |= states;
   2246a:	7b53      	ldrb	r3, [r2, #13]
   2246c:	f063 037f 	orn	r3, r3, #127	; 0x7f
			update_cache(1);
   22470:	2001      	movs	r0, #1
   22472:	7353      	strb	r3, [r2, #13]
   22474:	f7ff f91e 	bl	216b4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   22478:	4819      	ldr	r0, [pc, #100]	; (224e0 <z_impl_k_yield+0x13c>)
   2247a:	f000 fb35 	bl	22ae8 <z_spin_unlock_valid>
   2247e:	b968      	cbnz	r0, 2249c <z_impl_k_yield+0xf8>
   22480:	4a18      	ldr	r2, [pc, #96]	; (224e4 <z_impl_k_yield+0x140>)
   22482:	491d      	ldr	r1, [pc, #116]	; (224f8 <z_impl_k_yield+0x154>)
   22484:	4812      	ldr	r0, [pc, #72]	; (224d0 <z_impl_k_yield+0x12c>)
   22486:	235d      	movs	r3, #93	; 0x5d
   22488:	f001 fd2b 	bl	23ee2 <printk>
   2248c:	4914      	ldr	r1, [pc, #80]	; (224e0 <z_impl_k_yield+0x13c>)
   2248e:	481b      	ldr	r0, [pc, #108]	; (224fc <z_impl_k_yield+0x158>)
   22490:	f001 fd27 	bl	23ee2 <printk>
   22494:	4813      	ldr	r0, [pc, #76]	; (224e4 <z_impl_k_yield+0x140>)
   22496:	215d      	movs	r1, #93	; 0x5d
   22498:	f001 fd66 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   2249c:	f387 8811 	msr	BASEPRI, r7
   224a0:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   224a4:	f04f 0320 	mov.w	r3, #32
   224a8:	f3ef 8011 	mrs	r0, BASEPRI
   224ac:	f383 8811 	msr	BASEPRI, r3
   224b0:	f3bf 8f6f 	isb	sy
		}
	}
	z_swap_unlocked();
}
   224b4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   224b8:	f7e2 b9f6 	b.w	48a8 <arch_swap>
	node->prev = list->tail;
   224bc:	e9c5 1200 	strd	r1, r2, [r5]
	list->tail->next = node;
   224c0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   224c2:	601d      	str	r5, [r3, #0]
	list->tail = node;
   224c4:	62e5      	str	r5, [r4, #44]	; 0x2c
}
   224c6:	e7cf      	b.n	22468 <z_impl_k_yield+0xc4>
   224c8:	000312cc 	.word	0x000312cc
   224cc:	00031306 	.word	0x00031306
   224d0:	0002a5e8 	.word	0x0002a5e8
   224d4:	00030d23 	.word	0x00030d23
   224d8:	20001d80 	.word	0x20001d80
   224dc:	20001c4c 	.word	0x20001c4c
   224e0:	20001db4 	.word	0x20001db4
   224e4:	0002ae90 	.word	0x0002ae90
   224e8:	0002aeb2 	.word	0x0002aeb2
   224ec:	0002aec7 	.word	0x0002aec7
   224f0:	20001da8 	.word	0x20001da8
   224f4:	0003133f 	.word	0x0003133f
   224f8:	0002aedf 	.word	0x0002aedf
   224fc:	0002aef6 	.word	0x0002aef6

00022500 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
{
   22500:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   22502:	4604      	mov	r4, r0
   22504:	f3ef 8305 	mrs	r3, IPSR
#ifdef CONFIG_MULTITHREADING
	u32_t expected_wakeup_time;

	__ASSERT(!arch_is_in_isr(), "");
   22508:	b173      	cbz	r3, 22528 <z_tick_sleep+0x28>
   2250a:	493b      	ldr	r1, [pc, #236]	; (225f8 <z_tick_sleep+0xf8>)
   2250c:	4a3b      	ldr	r2, [pc, #236]	; (225fc <z_tick_sleep+0xfc>)
   2250e:	483c      	ldr	r0, [pc, #240]	; (22600 <z_tick_sleep+0x100>)
   22510:	f240 437d 	movw	r3, #1149	; 0x47d
   22514:	f001 fce5 	bl	23ee2 <printk>
   22518:	483a      	ldr	r0, [pc, #232]	; (22604 <z_tick_sleep+0x104>)
   2251a:	f001 fce2 	bl	23ee2 <printk>
   2251e:	4837      	ldr	r0, [pc, #220]	; (225fc <z_tick_sleep+0xfc>)
   22520:	f240 417d 	movw	r1, #1149	; 0x47d
   22524:	f001 fd20 	bl	23f68 <assert_post_action>

	K_DEBUG("thread %p for %d ticks\n", _current, ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   22528:	b924      	cbnz	r4, 22534 <z_tick_sleep+0x34>
	z_impl_k_yield();
   2252a:	f7ff ff3b 	bl	223a4 <z_impl_k_yield>
		return ticks;
	}
#endif

	return 0;
}
   2252e:	4620      	mov	r0, r4
   22530:	b003      	add	sp, #12
   22532:	bdf0      	pop	{r4, r5, r6, r7, pc}
	expected_wakeup_time = ticks + z_tick_get_32();
   22534:	f006 ff69 	bl	2940a <z_tick_get_32>
	ticks += _TICK_ALIGN;
   22538:	1c66      	adds	r6, r4, #1
	struct k_spinlock local_lock = {};
   2253a:	2300      	movs	r3, #0
	expected_wakeup_time = ticks + z_tick_get_32();
   2253c:	1834      	adds	r4, r6, r0
	struct k_spinlock local_lock = {};
   2253e:	9301      	str	r3, [sp, #4]
   22540:	f04f 0320 	mov.w	r3, #32
   22544:	f3ef 8711 	mrs	r7, BASEPRI
   22548:	f383 8811 	msr	BASEPRI, r3
   2254c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   22550:	a801      	add	r0, sp, #4
   22552:	f000 fabb 	bl	22acc <z_spin_lock_valid>
   22556:	b968      	cbnz	r0, 22574 <z_tick_sleep+0x74>
   22558:	4a2b      	ldr	r2, [pc, #172]	; (22608 <z_tick_sleep+0x108>)
   2255a:	492c      	ldr	r1, [pc, #176]	; (2260c <z_tick_sleep+0x10c>)
   2255c:	4828      	ldr	r0, [pc, #160]	; (22600 <z_tick_sleep+0x100>)
   2255e:	234a      	movs	r3, #74	; 0x4a
   22560:	f001 fcbf 	bl	23ee2 <printk>
   22564:	482a      	ldr	r0, [pc, #168]	; (22610 <z_tick_sleep+0x110>)
   22566:	a901      	add	r1, sp, #4
   22568:	f001 fcbb 	bl	23ee2 <printk>
   2256c:	4826      	ldr	r0, [pc, #152]	; (22608 <z_tick_sleep+0x108>)
   2256e:	214a      	movs	r1, #74	; 0x4a
   22570:	f001 fcfa 	bl	23f68 <assert_post_action>
	pending_current = _current;
   22574:	4d27      	ldr	r5, [pc, #156]	; (22614 <z_tick_sleep+0x114>)
	z_spin_lock_set_owner(l);
   22576:	a801      	add	r0, sp, #4
   22578:	f000 fac6 	bl	22b08 <z_spin_lock_set_owner>
   2257c:	4b26      	ldr	r3, [pc, #152]	; (22618 <z_tick_sleep+0x118>)
   2257e:	68a8      	ldr	r0, [r5, #8]
   22580:	6018      	str	r0, [r3, #0]
	z_remove_thread_from_ready_q(_current);
   22582:	f7ff fc69 	bl	21e58 <z_remove_thread_from_ready_q>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   22586:	68a8      	ldr	r0, [r5, #8]
   22588:	4924      	ldr	r1, [pc, #144]	; (2261c <z_tick_sleep+0x11c>)
   2258a:	4632      	mov	r2, r6
   2258c:	3018      	adds	r0, #24
   2258e:	f000 fc1d 	bl	22dcc <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   22592:	68aa      	ldr	r2, [r5, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
   22594:	7b53      	ldrb	r3, [r2, #13]
   22596:	f043 0310 	orr.w	r3, r3, #16
   2259a:	7353      	strb	r3, [r2, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2259c:	a801      	add	r0, sp, #4
   2259e:	f000 faa3 	bl	22ae8 <z_spin_unlock_valid>
   225a2:	b968      	cbnz	r0, 225c0 <z_tick_sleep+0xc0>
   225a4:	4a18      	ldr	r2, [pc, #96]	; (22608 <z_tick_sleep+0x108>)
   225a6:	491e      	ldr	r1, [pc, #120]	; (22620 <z_tick_sleep+0x120>)
   225a8:	4815      	ldr	r0, [pc, #84]	; (22600 <z_tick_sleep+0x100>)
   225aa:	2374      	movs	r3, #116	; 0x74
   225ac:	f001 fc99 	bl	23ee2 <printk>
   225b0:	481c      	ldr	r0, [pc, #112]	; (22624 <z_tick_sleep+0x124>)
   225b2:	a901      	add	r1, sp, #4
   225b4:	f001 fc95 	bl	23ee2 <printk>
   225b8:	4813      	ldr	r0, [pc, #76]	; (22608 <z_tick_sleep+0x108>)
   225ba:	2174      	movs	r1, #116	; 0x74
   225bc:	f001 fcd4 	bl	23f68 <assert_post_action>
   225c0:	4638      	mov	r0, r7
   225c2:	f7e2 f971 	bl	48a8 <arch_swap>
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
   225c6:	68ab      	ldr	r3, [r5, #8]
   225c8:	7b5b      	ldrb	r3, [r3, #13]
   225ca:	06db      	lsls	r3, r3, #27
   225cc:	d50e      	bpl.n	225ec <z_tick_sleep+0xec>
   225ce:	4916      	ldr	r1, [pc, #88]	; (22628 <z_tick_sleep+0x128>)
   225d0:	4a0a      	ldr	r2, [pc, #40]	; (225fc <z_tick_sleep+0xfc>)
   225d2:	480b      	ldr	r0, [pc, #44]	; (22600 <z_tick_sleep+0x100>)
   225d4:	f240 43a2 	movw	r3, #1186	; 0x4a2
   225d8:	f001 fc83 	bl	23ee2 <printk>
   225dc:	4809      	ldr	r0, [pc, #36]	; (22604 <z_tick_sleep+0x104>)
   225de:	f001 fc80 	bl	23ee2 <printk>
   225e2:	4806      	ldr	r0, [pc, #24]	; (225fc <z_tick_sleep+0xfc>)
   225e4:	f240 41a2 	movw	r1, #1186	; 0x4a2
   225e8:	f001 fcbe 	bl	23f68 <assert_post_action>
	ticks = expected_wakeup_time - z_tick_get_32();
   225ec:	f006 ff0d 	bl	2940a <z_tick_get_32>
   225f0:	1a24      	subs	r4, r4, r0
   225f2:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   225f6:	e79a      	b.n	2252e <z_tick_sleep+0x2e>
   225f8:	000312cc 	.word	0x000312cc
   225fc:	00031306 	.word	0x00031306
   22600:	0002a5e8 	.word	0x0002a5e8
   22604:	00030d23 	.word	0x00030d23
   22608:	0002ae90 	.word	0x0002ae90
   2260c:	0002aeb2 	.word	0x0002aeb2
   22610:	0002aec7 	.word	0x0002aec7
   22614:	20001d80 	.word	0x20001d80
   22618:	20001db0 	.word	0x20001db0
   2261c:	00021921 	.word	0x00021921
   22620:	0002aedf 	.word	0x0002aedf
   22624:	0002aef6 	.word	0x0002aef6
   22628:	00031388 	.word	0x00031388

0002262c <z_impl_k_sleep>:

s32_t z_impl_k_sleep(k_timeout_t timeout)
{
   2262c:	b538      	push	{r3, r4, r5, lr}
   2262e:	4604      	mov	r4, r0
   22630:	f3ef 8305 	mrs	r3, IPSR
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
   22634:	b173      	cbz	r3, 22654 <z_impl_k_sleep+0x28>
   22636:	4916      	ldr	r1, [pc, #88]	; (22690 <z_impl_k_sleep+0x64>)
   22638:	4a16      	ldr	r2, [pc, #88]	; (22694 <z_impl_k_sleep+0x68>)
   2263a:	4817      	ldr	r0, [pc, #92]	; (22698 <z_impl_k_sleep+0x6c>)
   2263c:	f240 43b1 	movw	r3, #1201	; 0x4b1
   22640:	f001 fc4f 	bl	23ee2 <printk>
   22644:	4815      	ldr	r0, [pc, #84]	; (2269c <z_impl_k_sleep+0x70>)
   22646:	f001 fc4c 	bl	23ee2 <printk>
   2264a:	4812      	ldr	r0, [pc, #72]	; (22694 <z_impl_k_sleep+0x68>)
   2264c:	f240 41b1 	movw	r1, #1201	; 0x4b1
   22650:	f001 fc8a 	bl	23f68 <assert_post_action>

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   22654:	1c63      	adds	r3, r4, #1
   22656:	d105      	bne.n	22664 <z_impl_k_sleep+0x38>
		k_thread_suspend(_current);
   22658:	4b11      	ldr	r3, [pc, #68]	; (226a0 <z_impl_k_sleep+0x74>)
   2265a:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   2265c:	f7ff fae0 	bl	21c20 <z_impl_k_thread_suspend>
	ticks = timeout.ticks;
#endif

	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   22660:	4620      	mov	r0, r4
   22662:	bd38      	pop	{r3, r4, r5, pc}
   22664:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   22668:	f240 30e7 	movw	r0, #999	; 0x3e7
   2266c:	2100      	movs	r1, #0
   2266e:	2300      	movs	r3, #0
   22670:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   22674:	fbe5 0104 	umlal	r0, r1, r5, r4
   22678:	f7dd fd92 	bl	1a0 <__aeabi_uldivmod>
	ticks = z_tick_sleep(ticks);
   2267c:	f7ff ff40 	bl	22500 <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
   22680:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   22684:	fba0 0103 	umull	r0, r1, r0, r3
   22688:	0bc4      	lsrs	r4, r0, #15
   2268a:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   2268e:	e7e7      	b.n	22660 <z_impl_k_sleep+0x34>
   22690:	000312cc 	.word	0x000312cc
   22694:	00031306 	.word	0x00031306
   22698:	0002a5e8 	.word	0x0002a5e8
   2269c:	00030d23 	.word	0x00030d23
   226a0:	20001d80 	.word	0x20001d80

000226a4 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   226a4:	4b01      	ldr	r3, [pc, #4]	; (226ac <z_impl_k_current_get+0x8>)
   226a6:	6898      	ldr	r0, [r3, #8]
   226a8:	4770      	bx	lr
   226aa:	bf00      	nop
   226ac:	20001d80 	.word	0x20001d80

000226b0 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   226b0:	b538      	push	{r3, r4, r5, lr}
   226b2:	4604      	mov	r4, r0
   226b4:	f04f 0320 	mov.w	r3, #32
   226b8:	f3ef 8511 	mrs	r5, BASEPRI
   226bc:	f383 8811 	msr	BASEPRI, r3
   226c0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   226c4:	4817      	ldr	r0, [pc, #92]	; (22724 <z_impl_k_sem_give+0x74>)
   226c6:	f000 fa01 	bl	22acc <z_spin_lock_valid>
   226ca:	b968      	cbnz	r0, 226e8 <z_impl_k_sem_give+0x38>
   226cc:	4a16      	ldr	r2, [pc, #88]	; (22728 <z_impl_k_sem_give+0x78>)
   226ce:	4917      	ldr	r1, [pc, #92]	; (2272c <z_impl_k_sem_give+0x7c>)
   226d0:	4817      	ldr	r0, [pc, #92]	; (22730 <z_impl_k_sem_give+0x80>)
   226d2:	234a      	movs	r3, #74	; 0x4a
   226d4:	f001 fc05 	bl	23ee2 <printk>
   226d8:	4912      	ldr	r1, [pc, #72]	; (22724 <z_impl_k_sem_give+0x74>)
   226da:	4816      	ldr	r0, [pc, #88]	; (22734 <z_impl_k_sem_give+0x84>)
   226dc:	f001 fc01 	bl	23ee2 <printk>
   226e0:	4811      	ldr	r0, [pc, #68]	; (22728 <z_impl_k_sem_give+0x78>)
   226e2:	214a      	movs	r1, #74	; 0x4a
   226e4:	f001 fc40 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   226e8:	480e      	ldr	r0, [pc, #56]	; (22724 <z_impl_k_sem_give+0x74>)
   226ea:	f000 fa0d 	bl	22b08 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   226ee:	4620      	mov	r0, r4
   226f0:	f7ff fdbc 	bl	2226c <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
   226f4:	b150      	cbz	r0, 2270c <z_impl_k_sem_give+0x5c>
   226f6:	2200      	movs	r2, #0
   226f8:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   226fc:	f7ff f8c8 	bl	21890 <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   22700:	4629      	mov	r1, r5
   22702:	4808      	ldr	r0, [pc, #32]	; (22724 <z_impl_k_sem_give+0x74>)
}
   22704:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   22708:	f7fe be9c 	b.w	21444 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   2270c:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   22710:	429a      	cmp	r2, r3
   22712:	bf18      	it	ne
   22714:	3301      	addne	r3, #1
   22716:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   22718:	2102      	movs	r1, #2
   2271a:	f104 0010 	add.w	r0, r4, #16
   2271e:	f006 ff1b 	bl	29558 <z_handle_obj_poll_events>
}
   22722:	e7ed      	b.n	22700 <z_impl_k_sem_give+0x50>
   22724:	20001dc0 	.word	0x20001dc0
   22728:	0002ae90 	.word	0x0002ae90
   2272c:	0002aeb2 	.word	0x0002aeb2
   22730:	0002a5e8 	.word	0x0002a5e8
   22734:	0002aec7 	.word	0x0002aec7

00022738 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   22738:	b570      	push	{r4, r5, r6, lr}
   2273a:	4604      	mov	r4, r0
   2273c:	460d      	mov	r5, r1
   2273e:	f3ef 8305 	mrs	r3, IPSR
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
   22742:	b16b      	cbz	r3, 22760 <z_impl_k_sem_take+0x28>
   22744:	b161      	cbz	r1, 22760 <z_impl_k_sem_take+0x28>
   22746:	4934      	ldr	r1, [pc, #208]	; (22818 <z_impl_k_sem_take+0xe0>)
   22748:	4a34      	ldr	r2, [pc, #208]	; (2281c <z_impl_k_sem_take+0xe4>)
   2274a:	4835      	ldr	r0, [pc, #212]	; (22820 <z_impl_k_sem_take+0xe8>)
   2274c:	238c      	movs	r3, #140	; 0x8c
   2274e:	f001 fbc8 	bl	23ee2 <printk>
   22752:	4834      	ldr	r0, [pc, #208]	; (22824 <z_impl_k_sem_take+0xec>)
   22754:	f001 fbc5 	bl	23ee2 <printk>
   22758:	4830      	ldr	r0, [pc, #192]	; (2281c <z_impl_k_sem_take+0xe4>)
   2275a:	218c      	movs	r1, #140	; 0x8c
   2275c:	f001 fc04 	bl	23f68 <assert_post_action>
   22760:	f04f 0320 	mov.w	r3, #32
   22764:	f3ef 8611 	mrs	r6, BASEPRI
   22768:	f383 8811 	msr	BASEPRI, r3
   2276c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   22770:	482d      	ldr	r0, [pc, #180]	; (22828 <z_impl_k_sem_take+0xf0>)
   22772:	f000 f9ab 	bl	22acc <z_spin_lock_valid>
   22776:	b968      	cbnz	r0, 22794 <z_impl_k_sem_take+0x5c>
   22778:	4a2c      	ldr	r2, [pc, #176]	; (2282c <z_impl_k_sem_take+0xf4>)
   2277a:	492d      	ldr	r1, [pc, #180]	; (22830 <z_impl_k_sem_take+0xf8>)
   2277c:	4828      	ldr	r0, [pc, #160]	; (22820 <z_impl_k_sem_take+0xe8>)
   2277e:	234a      	movs	r3, #74	; 0x4a
   22780:	f001 fbaf 	bl	23ee2 <printk>
   22784:	4928      	ldr	r1, [pc, #160]	; (22828 <z_impl_k_sem_take+0xf0>)
   22786:	482b      	ldr	r0, [pc, #172]	; (22834 <z_impl_k_sem_take+0xfc>)
   22788:	f001 fbab 	bl	23ee2 <printk>
   2278c:	4827      	ldr	r0, [pc, #156]	; (2282c <z_impl_k_sem_take+0xf4>)
   2278e:	214a      	movs	r1, #74	; 0x4a
   22790:	f001 fbea 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   22794:	4824      	ldr	r0, [pc, #144]	; (22828 <z_impl_k_sem_take+0xf0>)
   22796:	f000 f9b7 	bl	22b08 <z_spin_lock_set_owner>
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   2279a:	68a3      	ldr	r3, [r4, #8]
   2279c:	b1cb      	cbz	r3, 227d2 <z_impl_k_sem_take+0x9a>
		sem->count--;
   2279e:	3b01      	subs	r3, #1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   227a0:	4821      	ldr	r0, [pc, #132]	; (22828 <z_impl_k_sem_take+0xf0>)
   227a2:	60a3      	str	r3, [r4, #8]
   227a4:	f000 f9a0 	bl	22ae8 <z_spin_unlock_valid>
   227a8:	b968      	cbnz	r0, 227c6 <z_impl_k_sem_take+0x8e>
   227aa:	4a20      	ldr	r2, [pc, #128]	; (2282c <z_impl_k_sem_take+0xf4>)
   227ac:	4922      	ldr	r1, [pc, #136]	; (22838 <z_impl_k_sem_take+0x100>)
   227ae:	481c      	ldr	r0, [pc, #112]	; (22820 <z_impl_k_sem_take+0xe8>)
   227b0:	235d      	movs	r3, #93	; 0x5d
   227b2:	f001 fb96 	bl	23ee2 <printk>
   227b6:	491c      	ldr	r1, [pc, #112]	; (22828 <z_impl_k_sem_take+0xf0>)
   227b8:	4820      	ldr	r0, [pc, #128]	; (2283c <z_impl_k_sem_take+0x104>)
   227ba:	f001 fb92 	bl	23ee2 <printk>
   227be:	481b      	ldr	r0, [pc, #108]	; (2282c <z_impl_k_sem_take+0xf4>)
   227c0:	215d      	movs	r1, #93	; 0x5d
   227c2:	f001 fbd1 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   227c6:	f386 8811 	msr	BASEPRI, r6
   227ca:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   227ce:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
   227d0:	bd70      	pop	{r4, r5, r6, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   227d2:	b9c5      	cbnz	r5, 22806 <z_impl_k_sem_take+0xce>
   227d4:	4814      	ldr	r0, [pc, #80]	; (22828 <z_impl_k_sem_take+0xf0>)
   227d6:	f000 f987 	bl	22ae8 <z_spin_unlock_valid>
   227da:	b968      	cbnz	r0, 227f8 <z_impl_k_sem_take+0xc0>
   227dc:	4a13      	ldr	r2, [pc, #76]	; (2282c <z_impl_k_sem_take+0xf4>)
   227de:	4916      	ldr	r1, [pc, #88]	; (22838 <z_impl_k_sem_take+0x100>)
   227e0:	480f      	ldr	r0, [pc, #60]	; (22820 <z_impl_k_sem_take+0xe8>)
   227e2:	235d      	movs	r3, #93	; 0x5d
   227e4:	f001 fb7d 	bl	23ee2 <printk>
   227e8:	490f      	ldr	r1, [pc, #60]	; (22828 <z_impl_k_sem_take+0xf0>)
   227ea:	4814      	ldr	r0, [pc, #80]	; (2283c <z_impl_k_sem_take+0x104>)
   227ec:	f001 fb79 	bl	23ee2 <printk>
   227f0:	480e      	ldr	r0, [pc, #56]	; (2282c <z_impl_k_sem_take+0xf4>)
   227f2:	215d      	movs	r1, #93	; 0x5d
   227f4:	f001 fbb8 	bl	23f68 <assert_post_action>
   227f8:	f386 8811 	msr	BASEPRI, r6
   227fc:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   22800:	f06f 000f 	mvn.w	r0, #15
		goto out;
   22804:	e7e4      	b.n	227d0 <z_impl_k_sem_take+0x98>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   22806:	462b      	mov	r3, r5
   22808:	4622      	mov	r2, r4
   2280a:	4631      	mov	r1, r6
   2280c:	4806      	ldr	r0, [pc, #24]	; (22828 <z_impl_k_sem_take+0xf0>)
}
   2280e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   22812:	f7ff bc67 	b.w	220e4 <z_pend_curr>
   22816:	bf00      	nop
   22818:	000313e0 	.word	0x000313e0
   2281c:	000313c0 	.word	0x000313c0
   22820:	0002a5e8 	.word	0x0002a5e8
   22824:	00030d23 	.word	0x00030d23
   22828:	20001dc0 	.word	0x20001dc0
   2282c:	0002ae90 	.word	0x0002ae90
   22830:	0002aeb2 	.word	0x0002aeb2
   22834:	0002aec7 	.word	0x0002aec7
   22838:	0002aedf 	.word	0x0002aedf
   2283c:	0002aef6 	.word	0x0002aef6

00022840 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   22840:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   22842:	4c08      	ldr	r4, [pc, #32]	; (22864 <k_sys_work_q_init+0x24>)
   22844:	4908      	ldr	r1, [pc, #32]	; (22868 <k_sys_work_q_init+0x28>)
   22846:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2284a:	f44f 6200 	mov.w	r2, #2048	; 0x800
   2284e:	4620      	mov	r0, r4
   22850:	f000 f962 	bl	22b18 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   22854:	4905      	ldr	r1, [pc, #20]	; (2286c <k_sys_work_q_init+0x2c>)
   22856:	f104 0014 	add.w	r0, r4, #20
   2285a:	f000 f809 	bl	22870 <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   2285e:	2000      	movs	r0, #0
   22860:	bd10      	pop	{r4, pc}
   22862:	bf00      	nop
   22864:	20001dc4 	.word	0x20001dc4
   22868:	200043a0 	.word	0x200043a0
   2286c:	00031410 	.word	0x00031410

00022870 <z_impl_k_thread_name_set>:
	k_spin_unlock(&z_thread_monitor_lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
   22870:	b510      	push	{r4, lr}
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
   22872:	4604      	mov	r4, r0
   22874:	b908      	cbnz	r0, 2287a <z_impl_k_thread_name_set+0xa>
		thread = _current;
   22876:	4b05      	ldr	r3, [pc, #20]	; (2288c <z_impl_k_thread_name_set+0x1c>)
   22878:	689c      	ldr	r4, [r3, #8]
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
   2287a:	2220      	movs	r2, #32
   2287c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   22880:	f003 f9bf 	bl	25c02 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
   22884:	2000      	movs	r0, #0
   22886:	f884 007b 	strb.w	r0, [r4, #123]	; 0x7b
#else
	ARG_UNUSED(thread);
	ARG_UNUSED(value);
	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
   2288a:	bd10      	pop	{r4, pc}
   2288c:	20001d80 	.word	0x20001d80

00022890 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   22890:	b570      	push	{r4, r5, r6, lr}
   22892:	b086      	sub	sp, #24
	sys_dlist_init(&w->waitq);
   22894:	f100 0628 	add.w	r6, r0, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   22898:	e9c0 660a 	strd	r6, r6, [r0, #40]	; 0x28
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2289c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   2289e:	9604      	str	r6, [sp, #16]
   228a0:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   228a2:	9603      	str	r6, [sp, #12]
   228a4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   228a6:	9602      	str	r6, [sp, #8]
   228a8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
{
   228aa:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   228ac:	9601      	str	r6, [sp, #4]
   228ae:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   228b0:	9600      	str	r6, [sp, #0]
{
   228b2:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   228b4:	f7e2 f8c2 	bl	4a3c <arch_new_thread>
	new_thread->next_thread = _kernel.threads;
	_kernel.threads = new_thread;
	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
#ifdef CONFIG_THREAD_NAME
	if (name != NULL) {
   228b8:	b145      	cbz	r5, 228cc <z_setup_new_thread+0x3c>
		strncpy(new_thread->name, name,
   228ba:	221f      	movs	r2, #31
   228bc:	4629      	mov	r1, r5
   228be:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   228c2:	f003 f99e 	bl	25c02 <strncpy>
			CONFIG_THREAD_MAX_NAME_LEN - 1);
		/* Ensure NULL termination, truncate if longer */
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
   228c6:	2300      	movs	r3, #0
   228c8:	f884 307b 	strb.w	r3, [r4, #123]	; 0x7b
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   228cc:	4b04      	ldr	r3, [pc, #16]	; (228e0 <z_setup_new_thread+0x50>)
   228ce:	689b      	ldr	r3, [r3, #8]
   228d0:	b10b      	cbz	r3, 228d6 <z_setup_new_thread+0x46>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   228d2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   228d6:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
	sys_trace_thread_create(new_thread);
}
   228da:	b006      	add	sp, #24
   228dc:	bd70      	pop	{r4, r5, r6, pc}
   228de:	bf00      	nop
   228e0:	20001d80 	.word	0x20001d80

000228e4 <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, k_timeout_t delay)
{
   228e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   228e8:	b087      	sub	sp, #28
   228ea:	e9dd 9512 	ldrd	r9, r5, [sp, #72]	; 0x48
   228ee:	4604      	mov	r4, r0
   228f0:	460e      	mov	r6, r1
   228f2:	4617      	mov	r7, r2
   228f4:	4698      	mov	r8, r3
   228f6:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
   228fa:	b173      	cbz	r3, 2291a <z_impl_k_thread_create+0x36>
   228fc:	4927      	ldr	r1, [pc, #156]	; (2299c <z_impl_k_thread_create+0xb8>)
   228fe:	4a28      	ldr	r2, [pc, #160]	; (229a0 <z_impl_k_thread_create+0xbc>)
   22900:	4828      	ldr	r0, [pc, #160]	; (229a4 <z_impl_k_thread_create+0xc0>)
   22902:	f240 236b 	movw	r3, #619	; 0x26b
   22906:	f001 faec 	bl	23ee2 <printk>
   2290a:	4827      	ldr	r0, [pc, #156]	; (229a8 <z_impl_k_thread_create+0xc4>)
   2290c:	f001 fae9 	bl	23ee2 <printk>
   22910:	4823      	ldr	r0, [pc, #140]	; (229a0 <z_impl_k_thread_create+0xbc>)
   22912:	f240 216b 	movw	r1, #619	; 0x26b
   22916:	f001 fb27 	bl	23f68 <assert_post_action>

	/* Special case, only for unit tests */
#if defined(CONFIG_TEST) && defined(CONFIG_ARCH_HAS_USERSPACE) && !defined(CONFIG_USERSPACE)
	__ASSERT((options & K_USER) == 0,
   2291a:	f019 0f04 	tst.w	r9, #4
   2291e:	d00e      	beq.n	2293e <z_impl_k_thread_create+0x5a>
   22920:	4922      	ldr	r1, [pc, #136]	; (229ac <z_impl_k_thread_create+0xc8>)
   22922:	4a1f      	ldr	r2, [pc, #124]	; (229a0 <z_impl_k_thread_create+0xbc>)
   22924:	481f      	ldr	r0, [pc, #124]	; (229a4 <z_impl_k_thread_create+0xc0>)
   22926:	f240 236f 	movw	r3, #623	; 0x26f
   2292a:	f001 fada 	bl	23ee2 <printk>
   2292e:	4820      	ldr	r0, [pc, #128]	; (229b0 <z_impl_k_thread_create+0xcc>)
   22930:	f001 fad7 	bl	23ee2 <printk>
   22934:	481a      	ldr	r0, [pc, #104]	; (229a0 <z_impl_k_thread_create+0xbc>)
   22936:	f240 216f 	movw	r1, #623	; 0x26f
   2293a:	f001 fb15 	bl	23f68 <assert_post_action>
		 "Platform is capable of user mode, and test thread created with K_USER option,"
		 " but neither CONFIG_TEST_USERSPACE nor CONFIG_USERSPACE is set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2293e:	2300      	movs	r3, #0
   22940:	e9cd 9304 	strd	r9, r3, [sp, #16]
   22944:	9b11      	ldr	r3, [sp, #68]	; 0x44
   22946:	9303      	str	r3, [sp, #12]
   22948:	9b10      	ldr	r3, [sp, #64]	; 0x40
   2294a:	9302      	str	r3, [sp, #8]
   2294c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   2294e:	9301      	str	r3, [sp, #4]
   22950:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   22952:	9300      	str	r3, [sp, #0]
   22954:	463a      	mov	r2, r7
   22956:	4643      	mov	r3, r8
   22958:	4631      	mov	r1, r6
   2295a:	4620      	mov	r0, r4
   2295c:	f7ff ff98 	bl	22890 <z_setup_new_thread>
			  prio, options, NULL);

	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   22960:	1c6b      	adds	r3, r5, #1
   22962:	d003      	beq.n	2296c <z_impl_k_thread_create+0x88>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   22964:	b935      	cbnz	r5, 22974 <z_impl_k_thread_create+0x90>
	z_sched_start(thread);
   22966:	4620      	mov	r0, r4
   22968:	f7ff f83e 	bl	219e8 <z_sched_start>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
   2296c:	4620      	mov	r0, r4
   2296e:	b007      	add	sp, #28
   22970:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
   22974:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   22978:	f240 30e7 	movw	r0, #999	; 0x3e7
   2297c:	2100      	movs	r1, #0
   2297e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   22982:	2300      	movs	r3, #0
   22984:	fbe6 0105 	umlal	r0, r1, r6, r5
   22988:	f7dd fc0a 	bl	1a0 <__aeabi_uldivmod>
   2298c:	4909      	ldr	r1, [pc, #36]	; (229b4 <z_impl_k_thread_create+0xd0>)
   2298e:	1c42      	adds	r2, r0, #1
   22990:	f104 0018 	add.w	r0, r4, #24
   22994:	f000 fa1a 	bl	22dcc <z_add_timeout>
}
   22998:	e7e8      	b.n	2296c <z_impl_k_thread_create+0x88>
   2299a:	bf00      	nop
   2299c:	000312cc 	.word	0x000312cc
   229a0:	00031419 	.word	0x00031419
   229a4:	0002a5e8 	.word	0x0002a5e8
   229a8:	0003143c 	.word	0x0003143c
   229ac:	00031461 	.word	0x00031461
   229b0:	00031481 	.word	0x00031481
   229b4:	00021921 	.word	0x00021921

000229b8 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
   229b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   229bc:	4f3c      	ldr	r7, [pc, #240]	; (22ab0 <z_init_static_threads+0xf8>)
   229be:	4d3d      	ldr	r5, [pc, #244]	; (22ab4 <z_init_static_threads+0xfc>)
   229c0:	f8df 8100 	ldr.w	r8, [pc, #256]	; 22ac4 <z_init_static_threads+0x10c>
{
   229c4:	b087      	sub	sp, #28
   229c6:	463e      	mov	r6, r7
	_FOREACH_STATIC_THREAD(thread_data) {
   229c8:	42bd      	cmp	r5, r7
   229ca:	d90e      	bls.n	229ea <z_init_static_threads+0x32>
   229cc:	493a      	ldr	r1, [pc, #232]	; (22ab8 <z_init_static_threads+0x100>)
   229ce:	483b      	ldr	r0, [pc, #236]	; (22abc <z_init_static_threads+0x104>)
   229d0:	f44f 7334 	mov.w	r3, #720	; 0x2d0
   229d4:	4642      	mov	r2, r8
   229d6:	f001 fa84 	bl	23ee2 <printk>
   229da:	4839      	ldr	r0, [pc, #228]	; (22ac0 <z_init_static_threads+0x108>)
   229dc:	f001 fa81 	bl	23ee2 <printk>
   229e0:	f44f 7134 	mov.w	r1, #720	; 0x2d0
   229e4:	4640      	mov	r0, r8
   229e6:	f001 fabf 	bl	23f68 <assert_post_action>
   229ea:	42b5      	cmp	r5, r6
   229ec:	f105 0430 	add.w	r4, r5, #48	; 0x30
   229f0:	d31f      	bcc.n	22a32 <z_init_static_threads+0x7a>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
   229f2:	f7fe fd63 	bl	214bc <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   229f6:	4c2f      	ldr	r4, [pc, #188]	; (22ab4 <z_init_static_threads+0xfc>)
   229f8:	4d32      	ldr	r5, [pc, #200]	; (22ac4 <z_init_static_threads+0x10c>)
   229fa:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 22ab8 <z_init_static_threads+0x100>
   229fe:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 22abc <z_init_static_threads+0x104>
   22a02:	42b4      	cmp	r4, r6
   22a04:	d90e      	bls.n	22a24 <z_init_static_threads+0x6c>
   22a06:	4641      	mov	r1, r8
   22a08:	f240 23ef 	movw	r3, #751	; 0x2ef
   22a0c:	462a      	mov	r2, r5
   22a0e:	4648      	mov	r0, r9
   22a10:	f001 fa67 	bl	23ee2 <printk>
   22a14:	482a      	ldr	r0, [pc, #168]	; (22ac0 <z_init_static_threads+0x108>)
   22a16:	f001 fa64 	bl	23ee2 <printk>
   22a1a:	f240 21ef 	movw	r1, #751	; 0x2ef
   22a1e:	4628      	mov	r0, r5
   22a20:	f001 faa2 	bl	23f68 <assert_post_action>
   22a24:	42b4      	cmp	r4, r6
   22a26:	d321      	bcc.n	22a6c <z_init_static_threads+0xb4>
			schedule_new_thread(thread_data->init_thread,
					    K_MSEC(thread_data->init_delay));
		}
	}
	k_sched_unlock();
}
   22a28:	b007      	add	sp, #28
   22a2a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   22a2e:	f7fe be65 	b.w	216fc <k_sched_unlock>
		z_setup_new_thread(
   22a32:	f854 3c04 	ldr.w	r3, [r4, #-4]
   22a36:	9305      	str	r3, [sp, #20]
   22a38:	f854 3c10 	ldr.w	r3, [r4, #-16]
   22a3c:	9304      	str	r3, [sp, #16]
   22a3e:	f854 3c14 	ldr.w	r3, [r4, #-20]
   22a42:	9303      	str	r3, [sp, #12]
   22a44:	f854 3c18 	ldr.w	r3, [r4, #-24]
   22a48:	9302      	str	r3, [sp, #8]
   22a4a:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   22a4e:	9301      	str	r3, [sp, #4]
   22a50:	f854 3c20 	ldr.w	r3, [r4, #-32]
   22a54:	9300      	str	r3, [sp, #0]
   22a56:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   22a5a:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   22a5e:	f7ff ff17 	bl	22890 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   22a62:	f854 3c30 	ldr.w	r3, [r4, #-48]
   22a66:	655d      	str	r5, [r3, #84]	; 0x54
   22a68:	4625      	mov	r5, r4
   22a6a:	e7ad      	b.n	229c8 <z_init_static_threads+0x10>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   22a6c:	f8d4 c024 	ldr.w	ip, [r4, #36]	; 0x24
   22a70:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
   22a74:	d006      	beq.n	22a84 <z_init_static_threads+0xcc>
			schedule_new_thread(thread_data->init_thread,
   22a76:	6827      	ldr	r7, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   22a78:	f1bc 0f00 	cmp.w	ip, #0
   22a7c:	d104      	bne.n	22a88 <z_init_static_threads+0xd0>
	z_sched_start(thread);
   22a7e:	4638      	mov	r0, r7
   22a80:	f7fe ffb2 	bl	219e8 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   22a84:	3430      	adds	r4, #48	; 0x30
   22a86:	e7bc      	b.n	22a02 <z_init_static_threads+0x4a>
   22a88:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
   22a8c:	f240 30e7 	movw	r0, #999	; 0x3e7
   22a90:	2100      	movs	r1, #0
   22a92:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   22a96:	2300      	movs	r3, #0
   22a98:	fbee 010c 	umlal	r0, r1, lr, ip
   22a9c:	f7dd fb80 	bl	1a0 <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   22aa0:	4909      	ldr	r1, [pc, #36]	; (22ac8 <z_init_static_threads+0x110>)
   22aa2:	1c42      	adds	r2, r0, #1
   22aa4:	f107 0018 	add.w	r0, r7, #24
   22aa8:	f000 f990 	bl	22dcc <z_add_timeout>
}
   22aac:	e7ea      	b.n	22a84 <z_init_static_threads+0xcc>
   22aae:	bf00      	nop
   22ab0:	2000755c 	.word	0x2000755c
   22ab4:	2000755c 	.word	0x2000755c
   22ab8:	00031510 	.word	0x00031510
   22abc:	0002a5e8 	.word	0x0002a5e8
   22ac0:	0002ad2b 	.word	0x0002ad2b
   22ac4:	00031419 	.word	0x00031419
   22ac8:	00021921 	.word	0x00021921

00022acc <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
   22acc:	6800      	ldr	r0, [r0, #0]

	if (thread_cpu) {
   22ace:	b138      	cbz	r0, 22ae0 <z_spin_lock_valid+0x14>
		if ((thread_cpu & 3) == _current_cpu->id) {
   22ad0:	4b04      	ldr	r3, [pc, #16]	; (22ae4 <z_spin_lock_valid+0x18>)
   22ad2:	7d1b      	ldrb	r3, [r3, #20]
   22ad4:	f000 0003 	and.w	r0, r0, #3
   22ad8:	1ac0      	subs	r0, r0, r3
   22ada:	bf18      	it	ne
   22adc:	2001      	movne	r0, #1
   22ade:	4770      	bx	lr
			return false;
		}
	}
	return true;
   22ae0:	2001      	movs	r0, #1
}
   22ae2:	4770      	bx	lr
   22ae4:	20001d80 	.word	0x20001d80

00022ae8 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
   22ae8:	4906      	ldr	r1, [pc, #24]	; (22b04 <z_spin_unlock_valid+0x1c>)
{
   22aea:	4603      	mov	r3, r0
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
   22aec:	688a      	ldr	r2, [r1, #8]
   22aee:	7d08      	ldrb	r0, [r1, #20]
   22af0:	6819      	ldr	r1, [r3, #0]
   22af2:	4302      	orrs	r2, r0
   22af4:	4291      	cmp	r1, r2
   22af6:	f04f 0000 	mov.w	r0, #0
		return false;
	}
	l->thread_cpu = 0;
   22afa:	bf04      	itt	eq
   22afc:	6018      	streq	r0, [r3, #0]
	return true;
   22afe:	2001      	moveq	r0, #1
}
   22b00:	4770      	bx	lr
   22b02:	bf00      	nop
   22b04:	20001d80 	.word	0x20001d80

00022b08 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
   22b08:	4a02      	ldr	r2, [pc, #8]	; (22b14 <z_spin_lock_set_owner+0xc>)
   22b0a:	7d11      	ldrb	r1, [r2, #20]
   22b0c:	6893      	ldr	r3, [r2, #8]
   22b0e:	430b      	orrs	r3, r1
   22b10:	6003      	str	r3, [r0, #0]
}
   22b12:	4770      	bx	lr
   22b14:	20001d80 	.word	0x20001d80

00022b18 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   22b18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   22b1c:	4604      	mov	r4, r0
   22b1e:	b086      	sub	sp, #24
   22b20:	460d      	mov	r5, r1
   22b22:	4616      	mov	r6, r2
   22b24:	461f      	mov	r7, r3
	z_impl_k_queue_init(queue);
   22b26:	f006 fb8b 	bl	29240 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   22b2a:	f104 0814 	add.w	r8, r4, #20
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   22b2e:	2000      	movs	r0, #0
   22b30:	e9cd 0004 	strd	r0, r0, [sp, #16]
   22b34:	e9cd 0702 	strd	r0, r7, [sp, #8]
   22b38:	e9cd 4000 	strd	r4, r0, [sp]
   22b3c:	4b06      	ldr	r3, [pc, #24]	; (22b58 <k_work_q_start+0x40>)
   22b3e:	4632      	mov	r2, r6
   22b40:	4629      	mov	r1, r5
   22b42:	4640      	mov	r0, r8
   22b44:	f7ff fece 	bl	228e4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   22b48:	4904      	ldr	r1, [pc, #16]	; (22b5c <k_work_q_start+0x44>)
   22b4a:	4640      	mov	r0, r8
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   22b4c:	b006      	add	sp, #24
   22b4e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   22b52:	f7ff be8d 	b.w	22870 <z_impl_k_thread_name_set>
   22b56:	bf00      	nop
   22b58:	00023f2b 	.word	0x00023f2b
   22b5c:	0003153d 	.word	0x0003153d

00022b60 <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   k_timeout_t delay)
{
   22b60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   22b64:	4606      	mov	r6, r0
   22b66:	460d      	mov	r5, r1
   22b68:	4617      	mov	r7, r2
	__asm__ volatile(
   22b6a:	f04f 0320 	mov.w	r3, #32
   22b6e:	f3ef 8811 	mrs	r8, BASEPRI
   22b72:	f383 8811 	msr	BASEPRI, r3
   22b76:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   22b7a:	4839      	ldr	r0, [pc, #228]	; (22c60 <k_delayed_work_submit_to_queue+0x100>)
   22b7c:	f7ff ffa6 	bl	22acc <z_spin_lock_valid>
   22b80:	b968      	cbnz	r0, 22b9e <k_delayed_work_submit_to_queue+0x3e>
   22b82:	4a38      	ldr	r2, [pc, #224]	; (22c64 <k_delayed_work_submit_to_queue+0x104>)
   22b84:	4938      	ldr	r1, [pc, #224]	; (22c68 <k_delayed_work_submit_to_queue+0x108>)
   22b86:	4839      	ldr	r0, [pc, #228]	; (22c6c <k_delayed_work_submit_to_queue+0x10c>)
   22b88:	234a      	movs	r3, #74	; 0x4a
   22b8a:	f001 f9aa 	bl	23ee2 <printk>
   22b8e:	4934      	ldr	r1, [pc, #208]	; (22c60 <k_delayed_work_submit_to_queue+0x100>)
   22b90:	4837      	ldr	r0, [pc, #220]	; (22c70 <k_delayed_work_submit_to_queue+0x110>)
   22b92:	f001 f9a6 	bl	23ee2 <printk>
   22b96:	4833      	ldr	r0, [pc, #204]	; (22c64 <k_delayed_work_submit_to_queue+0x104>)
   22b98:	214a      	movs	r1, #74	; 0x4a
   22b9a:	f001 f9e5 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   22b9e:	4830      	ldr	r0, [pc, #192]	; (22c60 <k_delayed_work_submit_to_queue+0x100>)
   22ba0:	f7ff ffb2 	bl	22b08 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   22ba4:	69eb      	ldr	r3, [r5, #28]
   22ba6:	b30b      	cbz	r3, 22bec <k_delayed_work_submit_to_queue+0x8c>
   22ba8:	42b3      	cmp	r3, r6
   22baa:	d155      	bne.n	22c58 <k_delayed_work_submit_to_queue+0xf8>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
   22bac:	4628      	mov	r0, r5
   22bae:	f006 fbdb 	bl	29368 <work_cancel>
		/* -EALREADY indicates the work has already completed so this
		 * is likely a recurring work.
		 */
		if (err == -EALREADY) {
   22bb2:	f110 0f45 	cmn.w	r0, #69	; 0x45
		err = work_cancel(work);
   22bb6:	4604      	mov	r4, r0
		if (err == -EALREADY) {
   22bb8:	d01a      	beq.n	22bf0 <k_delayed_work_submit_to_queue+0x90>
			err = 0;
		} else if (err < 0) {
   22bba:	2800      	cmp	r0, #0
   22bbc:	da19      	bge.n	22bf2 <k_delayed_work_submit_to_queue+0x92>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   22bbe:	4828      	ldr	r0, [pc, #160]	; (22c60 <k_delayed_work_submit_to_queue+0x100>)
   22bc0:	f7ff ff92 	bl	22ae8 <z_spin_unlock_valid>
   22bc4:	b968      	cbnz	r0, 22be2 <k_delayed_work_submit_to_queue+0x82>
   22bc6:	4a27      	ldr	r2, [pc, #156]	; (22c64 <k_delayed_work_submit_to_queue+0x104>)
   22bc8:	492a      	ldr	r1, [pc, #168]	; (22c74 <k_delayed_work_submit_to_queue+0x114>)
   22bca:	4828      	ldr	r0, [pc, #160]	; (22c6c <k_delayed_work_submit_to_queue+0x10c>)
   22bcc:	235d      	movs	r3, #93	; 0x5d
   22bce:	f001 f988 	bl	23ee2 <printk>
   22bd2:	4923      	ldr	r1, [pc, #140]	; (22c60 <k_delayed_work_submit_to_queue+0x100>)
   22bd4:	4828      	ldr	r0, [pc, #160]	; (22c78 <k_delayed_work_submit_to_queue+0x118>)
   22bd6:	f001 f984 	bl	23ee2 <printk>
   22bda:	4822      	ldr	r0, [pc, #136]	; (22c64 <k_delayed_work_submit_to_queue+0x104>)
   22bdc:	215d      	movs	r1, #93	; 0x5d
   22bde:	f001 f9c3 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   22be2:	f388 8811 	msr	BASEPRI, r8
   22be6:	f3bf 8f6f 	isb	sy
	/* Add timeout */
	z_add_timeout(&work->timeout, work_timeout, delay);

done:
	k_spin_unlock(&lock, key);
	return err;
   22bea:	e01f      	b.n	22c2c <k_delayed_work_submit_to_queue+0xcc>
	if (work->work_q == work_q) {
   22bec:	2e00      	cmp	r6, #0
   22bee:	d0dd      	beq.n	22bac <k_delayed_work_submit_to_queue+0x4c>
	int err = 0;
   22bf0:	2400      	movs	r4, #0
	work->work_q = work_q;
   22bf2:	61ee      	str	r6, [r5, #28]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   22bf4:	b9ef      	cbnz	r7, 22c32 <k_delayed_work_submit_to_queue+0xd2>
   22bf6:	481a      	ldr	r0, [pc, #104]	; (22c60 <k_delayed_work_submit_to_queue+0x100>)
   22bf8:	f7ff ff76 	bl	22ae8 <z_spin_unlock_valid>
   22bfc:	b968      	cbnz	r0, 22c1a <k_delayed_work_submit_to_queue+0xba>
   22bfe:	4a19      	ldr	r2, [pc, #100]	; (22c64 <k_delayed_work_submit_to_queue+0x104>)
   22c00:	491c      	ldr	r1, [pc, #112]	; (22c74 <k_delayed_work_submit_to_queue+0x114>)
   22c02:	481a      	ldr	r0, [pc, #104]	; (22c6c <k_delayed_work_submit_to_queue+0x10c>)
   22c04:	235d      	movs	r3, #93	; 0x5d
   22c06:	f001 f96c 	bl	23ee2 <printk>
   22c0a:	4915      	ldr	r1, [pc, #84]	; (22c60 <k_delayed_work_submit_to_queue+0x100>)
   22c0c:	481a      	ldr	r0, [pc, #104]	; (22c78 <k_delayed_work_submit_to_queue+0x118>)
   22c0e:	f001 f968 	bl	23ee2 <printk>
   22c12:	4814      	ldr	r0, [pc, #80]	; (22c64 <k_delayed_work_submit_to_queue+0x104>)
   22c14:	215d      	movs	r1, #93	; 0x5d
   22c16:	f001 f9a7 	bl	23f68 <assert_post_action>
   22c1a:	f388 8811 	msr	BASEPRI, r8
   22c1e:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
   22c22:	4629      	mov	r1, r5
   22c24:	4630      	mov	r0, r6
   22c26:	f006 fb82 	bl	2932e <k_work_submit_to_queue>
		return 0;
   22c2a:	2400      	movs	r4, #0
}
   22c2c:	4620      	mov	r0, r4
   22c2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   22c32:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   22c36:	f240 30e7 	movw	r0, #999	; 0x3e7
   22c3a:	2100      	movs	r1, #0
   22c3c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   22c40:	2300      	movs	r3, #0
   22c42:	fbe6 0107 	umlal	r0, r1, r6, r7
   22c46:	f7dd faab 	bl	1a0 <__aeabi_uldivmod>
	z_add_timeout(&work->timeout, work_timeout, delay);
   22c4a:	490c      	ldr	r1, [pc, #48]	; (22c7c <k_delayed_work_submit_to_queue+0x11c>)
   22c4c:	1c42      	adds	r2, r0, #1
   22c4e:	f105 000c 	add.w	r0, r5, #12
   22c52:	f000 f8bb 	bl	22dcc <z_add_timeout>
   22c56:	e7b2      	b.n	22bbe <k_delayed_work_submit_to_queue+0x5e>
		err = -EADDRINUSE;
   22c58:	f06f 042f 	mvn.w	r4, #47	; 0x2f
   22c5c:	e7af      	b.n	22bbe <k_delayed_work_submit_to_queue+0x5e>
   22c5e:	bf00      	nop
   22c60:	20001e6c 	.word	0x20001e6c
   22c64:	0002ae90 	.word	0x0002ae90
   22c68:	0002aeb2 	.word	0x0002aeb2
   22c6c:	0002a5e8 	.word	0x0002a5e8
   22c70:	0002aec7 	.word	0x0002aec7
   22c74:	0002aedf 	.word	0x0002aedf
   22c78:	0002aef6 	.word	0x0002aef6
   22c7c:	0002935f 	.word	0x0002935f

00022c80 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
   22c80:	b538      	push	{r3, r4, r5, lr}
	if (!work->work_q) {
   22c82:	69c3      	ldr	r3, [r0, #28]
{
   22c84:	4604      	mov	r4, r0
	if (!work->work_q) {
   22c86:	2b00      	cmp	r3, #0
   22c88:	d038      	beq.n	22cfc <k_delayed_work_cancel+0x7c>
	__asm__ volatile(
   22c8a:	f04f 0320 	mov.w	r3, #32
   22c8e:	f3ef 8511 	mrs	r5, BASEPRI
   22c92:	f383 8811 	msr	BASEPRI, r3
   22c96:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   22c9a:	481a      	ldr	r0, [pc, #104]	; (22d04 <k_delayed_work_cancel+0x84>)
   22c9c:	f7ff ff16 	bl	22acc <z_spin_lock_valid>
   22ca0:	b968      	cbnz	r0, 22cbe <k_delayed_work_cancel+0x3e>
   22ca2:	4a19      	ldr	r2, [pc, #100]	; (22d08 <k_delayed_work_cancel+0x88>)
   22ca4:	4919      	ldr	r1, [pc, #100]	; (22d0c <k_delayed_work_cancel+0x8c>)
   22ca6:	481a      	ldr	r0, [pc, #104]	; (22d10 <k_delayed_work_cancel+0x90>)
   22ca8:	234a      	movs	r3, #74	; 0x4a
   22caa:	f001 f91a 	bl	23ee2 <printk>
   22cae:	4915      	ldr	r1, [pc, #84]	; (22d04 <k_delayed_work_cancel+0x84>)
   22cb0:	4818      	ldr	r0, [pc, #96]	; (22d14 <k_delayed_work_cancel+0x94>)
   22cb2:	f001 f916 	bl	23ee2 <printk>
   22cb6:	4814      	ldr	r0, [pc, #80]	; (22d08 <k_delayed_work_cancel+0x88>)
   22cb8:	214a      	movs	r1, #74	; 0x4a
   22cba:	f001 f955 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   22cbe:	4811      	ldr	r0, [pc, #68]	; (22d04 <k_delayed_work_cancel+0x84>)
   22cc0:	f7ff ff22 	bl	22b08 <z_spin_lock_set_owner>
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = work_cancel(work);
   22cc4:	4620      	mov	r0, r4
   22cc6:	f006 fb4f 	bl	29368 <work_cancel>
   22cca:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   22ccc:	480d      	ldr	r0, [pc, #52]	; (22d04 <k_delayed_work_cancel+0x84>)
   22cce:	f7ff ff0b 	bl	22ae8 <z_spin_unlock_valid>
   22cd2:	b968      	cbnz	r0, 22cf0 <k_delayed_work_cancel+0x70>
   22cd4:	4a0c      	ldr	r2, [pc, #48]	; (22d08 <k_delayed_work_cancel+0x88>)
   22cd6:	4910      	ldr	r1, [pc, #64]	; (22d18 <k_delayed_work_cancel+0x98>)
   22cd8:	480d      	ldr	r0, [pc, #52]	; (22d10 <k_delayed_work_cancel+0x90>)
   22cda:	235d      	movs	r3, #93	; 0x5d
   22cdc:	f001 f901 	bl	23ee2 <printk>
   22ce0:	4908      	ldr	r1, [pc, #32]	; (22d04 <k_delayed_work_cancel+0x84>)
   22ce2:	480e      	ldr	r0, [pc, #56]	; (22d1c <k_delayed_work_cancel+0x9c>)
   22ce4:	f001 f8fd 	bl	23ee2 <printk>
   22ce8:	4807      	ldr	r0, [pc, #28]	; (22d08 <k_delayed_work_cancel+0x88>)
   22cea:	215d      	movs	r1, #93	; 0x5d
   22cec:	f001 f93c 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   22cf0:	f385 8811 	msr	BASEPRI, r5
   22cf4:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   22cf8:	4620      	mov	r0, r4
   22cfa:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   22cfc:	f06f 0415 	mvn.w	r4, #21
   22d00:	e7fa      	b.n	22cf8 <k_delayed_work_cancel+0x78>
   22d02:	bf00      	nop
   22d04:	20001e6c 	.word	0x20001e6c
   22d08:	0002ae90 	.word	0x0002ae90
   22d0c:	0002aeb2 	.word	0x0002aeb2
   22d10:	0002a5e8 	.word	0x0002a5e8
   22d14:	0002aec7 	.word	0x0002aec7
   22d18:	0002aedf 	.word	0x0002aedf
   22d1c:	0002aef6 	.word	0x0002aef6

00022d20 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   22d20:	4b03      	ldr	r3, [pc, #12]	; (22d30 <elapsed+0x10>)
   22d22:	681b      	ldr	r3, [r3, #0]
   22d24:	b90b      	cbnz	r3, 22d2a <elapsed+0xa>
   22d26:	f7e1 baf7 	b.w	4318 <z_clock_elapsed>
}
   22d2a:	2000      	movs	r0, #0
   22d2c:	4770      	bx	lr
   22d2e:	bf00      	nop
   22d30:	20001e70 	.word	0x20001e70

00022d34 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   22d34:	6803      	ldr	r3, [r0, #0]
   22d36:	b140      	cbz	r0, 22d4a <remove_timeout+0x16>
   22d38:	4a07      	ldr	r2, [pc, #28]	; (22d58 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   22d3a:	6852      	ldr	r2, [r2, #4]
   22d3c:	4290      	cmp	r0, r2
   22d3e:	d004      	beq.n	22d4a <remove_timeout+0x16>
	if (next(t) != NULL) {
   22d40:	b11b      	cbz	r3, 22d4a <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   22d42:	689a      	ldr	r2, [r3, #8]
   22d44:	6881      	ldr	r1, [r0, #8]
   22d46:	440a      	add	r2, r1
   22d48:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   22d4a:	6842      	ldr	r2, [r0, #4]
   22d4c:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   22d4e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   22d50:	2300      	movs	r3, #0
	node->prev = NULL;
   22d52:	e9c0 3300 	strd	r3, r3, [r0]
}
   22d56:	4770      	bx	lr
   22d58:	200073d0 	.word	0x200073d0

00022d5c <next_timeout>:
	return list->head == list;
   22d5c:	4b0b      	ldr	r3, [pc, #44]	; (22d8c <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   22d5e:	b510      	push	{r4, lr}
   22d60:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   22d62:	429c      	cmp	r4, r3
   22d64:	bf08      	it	eq
   22d66:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   22d68:	f7ff ffda 	bl	22d20 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   22d6c:	b154      	cbz	r4, 22d84 <next_timeout+0x28>
   22d6e:	68a3      	ldr	r3, [r4, #8]
   22d70:	1a18      	subs	r0, r3, r0
   22d72:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   22d76:	4b06      	ldr	r3, [pc, #24]	; (22d90 <next_timeout+0x34>)
   22d78:	691b      	ldr	r3, [r3, #16]
   22d7a:	b113      	cbz	r3, 22d82 <next_timeout+0x26>
   22d7c:	4298      	cmp	r0, r3
   22d7e:	bfa8      	it	ge
   22d80:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   22d82:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   22d84:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   22d88:	e7f5      	b.n	22d76 <next_timeout+0x1a>
   22d8a:	bf00      	nop
   22d8c:	200073d0 	.word	0x200073d0
   22d90:	20001d80 	.word	0x20001d80

00022d94 <timeout_rem>:
	return ret;
}

/* must be locked */
static k_ticks_t timeout_rem(struct _timeout *timeout)
{
   22d94:	4602      	mov	r2, r0
	k_ticks_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   22d96:	6800      	ldr	r0, [r0, #0]
{
   22d98:	b510      	push	{r4, lr}
	if (z_is_inactive_timeout(timeout)) {
   22d9a:	b148      	cbz	r0, 22db0 <timeout_rem+0x1c>
	return list->head == list;
   22d9c:	490a      	ldr	r1, [pc, #40]	; (22dc8 <timeout_rem+0x34>)
   22d9e:	680b      	ldr	r3, [r1, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   22da0:	428b      	cmp	r3, r1
   22da2:	d00e      	beq.n	22dc2 <timeout_rem+0x2e>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   22da4:	6849      	ldr	r1, [r1, #4]
   22da6:	2400      	movs	r4, #0
		return 0;
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   22da8:	b91b      	cbnz	r3, 22db2 <timeout_rem+0x1e>
		if (timeout == t) {
			break;
		}
	}

	return ticks - elapsed();
   22daa:	f7ff ffb9 	bl	22d20 <elapsed>
   22dae:	1a20      	subs	r0, r4, r0
}
   22db0:	bd10      	pop	{r4, pc}
		ticks += t->dticks;
   22db2:	6898      	ldr	r0, [r3, #8]
		if (timeout == t) {
   22db4:	4293      	cmp	r3, r2
		ticks += t->dticks;
   22db6:	4404      	add	r4, r0
		if (timeout == t) {
   22db8:	d0f7      	beq.n	22daa <timeout_rem+0x16>
	return (node == list->tail) ? NULL : node->next;
   22dba:	428b      	cmp	r3, r1
   22dbc:	d0f5      	beq.n	22daa <timeout_rem+0x16>
   22dbe:	681b      	ldr	r3, [r3, #0]
   22dc0:	e7f2      	b.n	22da8 <timeout_rem+0x14>
   22dc2:	2400      	movs	r4, #0
   22dc4:	e7f1      	b.n	22daa <timeout_rem+0x16>
   22dc6:	bf00      	nop
   22dc8:	200073d0 	.word	0x200073d0

00022dcc <z_add_timeout>:
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   22dcc:	6803      	ldr	r3, [r0, #0]
{
   22dce:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   22dd2:	4604      	mov	r4, r0
   22dd4:	460e      	mov	r6, r1
   22dd6:	4615      	mov	r5, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   22dd8:	b163      	cbz	r3, 22df4 <z_add_timeout+0x28>
   22dda:	4944      	ldr	r1, [pc, #272]	; (22eec <z_add_timeout+0x120>)
   22ddc:	4a44      	ldr	r2, [pc, #272]	; (22ef0 <z_add_timeout+0x124>)
   22dde:	4845      	ldr	r0, [pc, #276]	; (22ef4 <z_add_timeout+0x128>)
   22de0:	2363      	movs	r3, #99	; 0x63
   22de2:	f001 f87e 	bl	23ee2 <printk>
   22de6:	4844      	ldr	r0, [pc, #272]	; (22ef8 <z_add_timeout+0x12c>)
   22de8:	f001 f87b 	bl	23ee2 <printk>
   22dec:	4840      	ldr	r0, [pc, #256]	; (22ef0 <z_add_timeout+0x124>)
   22dee:	2163      	movs	r1, #99	; 0x63
   22df0:	f001 f8ba 	bl	23f68 <assert_post_action>
	to->fn = fn;
   22df4:	2d01      	cmp	r5, #1
   22df6:	bf38      	it	cc
   22df8:	2501      	movcc	r5, #1
   22dfa:	60e6      	str	r6, [r4, #12]
	__asm__ volatile(
   22dfc:	f04f 0320 	mov.w	r3, #32
   22e00:	f3ef 8711 	mrs	r7, BASEPRI
   22e04:	f383 8811 	msr	BASEPRI, r3
   22e08:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   22e0c:	483b      	ldr	r0, [pc, #236]	; (22efc <z_add_timeout+0x130>)
   22e0e:	f7ff fe5d 	bl	22acc <z_spin_lock_valid>
   22e12:	b968      	cbnz	r0, 22e30 <z_add_timeout+0x64>
   22e14:	4a3a      	ldr	r2, [pc, #232]	; (22f00 <z_add_timeout+0x134>)
   22e16:	493b      	ldr	r1, [pc, #236]	; (22f04 <z_add_timeout+0x138>)
   22e18:	4836      	ldr	r0, [pc, #216]	; (22ef4 <z_add_timeout+0x128>)
   22e1a:	234a      	movs	r3, #74	; 0x4a
   22e1c:	f001 f861 	bl	23ee2 <printk>
   22e20:	4936      	ldr	r1, [pc, #216]	; (22efc <z_add_timeout+0x130>)
   22e22:	4839      	ldr	r0, [pc, #228]	; (22f08 <z_add_timeout+0x13c>)
   22e24:	f001 f85d 	bl	23ee2 <printk>
   22e28:	4835      	ldr	r0, [pc, #212]	; (22f00 <z_add_timeout+0x134>)
   22e2a:	214a      	movs	r1, #74	; 0x4a
   22e2c:	f001 f89c 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   22e30:	4832      	ldr	r0, [pc, #200]	; (22efc <z_add_timeout+0x130>)
   22e32:	f7ff fe69 	bl	22b08 <z_spin_lock_set_owner>
		to->dticks = ticks + elapsed();
   22e36:	f7ff ff73 	bl	22d20 <elapsed>
   22e3a:	4405      	add	r5, r0
   22e3c:	60a5      	str	r5, [r4, #8]
	return list->head == list;
   22e3e:	4d33      	ldr	r5, [pc, #204]	; (22f0c <z_add_timeout+0x140>)
   22e40:	682e      	ldr	r6, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   22e42:	42ae      	cmp	r6, r5
   22e44:	d006      	beq.n	22e54 <z_add_timeout+0x88>
			__ASSERT(t->dticks >= 0, "");
   22e46:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 22ef0 <z_add_timeout+0x124>
   22e4a:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 22f18 <z_add_timeout+0x14c>
   22e4e:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 22ef4 <z_add_timeout+0x128>
		for (t = first(); t != NULL; t = next(t)) {
   22e52:	b936      	cbnz	r6, 22e62 <z_add_timeout+0x96>
	node->prev = list->tail;
   22e54:	686b      	ldr	r3, [r5, #4]
   22e56:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   22e58:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   22e5a:	6025      	str	r5, [r4, #0]
	list->tail->next = node;
   22e5c:	601c      	str	r4, [r3, #0]
	list->tail = node;
   22e5e:	606c      	str	r4, [r5, #4]
}
   22e60:	e01a      	b.n	22e98 <z_add_timeout+0xcc>
			__ASSERT(t->dticks >= 0, "");
   22e62:	68b3      	ldr	r3, [r6, #8]
   22e64:	2b00      	cmp	r3, #0
   22e66:	da0c      	bge.n	22e82 <z_add_timeout+0xb6>
   22e68:	4641      	mov	r1, r8
   22e6a:	236c      	movs	r3, #108	; 0x6c
   22e6c:	4652      	mov	r2, sl
   22e6e:	4648      	mov	r0, r9
   22e70:	f001 f837 	bl	23ee2 <printk>
   22e74:	4820      	ldr	r0, [pc, #128]	; (22ef8 <z_add_timeout+0x12c>)
   22e76:	f001 f834 	bl	23ee2 <printk>
   22e7a:	216c      	movs	r1, #108	; 0x6c
   22e7c:	4650      	mov	r0, sl
   22e7e:	f001 f873 	bl	23f68 <assert_post_action>
			if (t->dticks > to->dticks) {
   22e82:	68b2      	ldr	r2, [r6, #8]
   22e84:	68a3      	ldr	r3, [r4, #8]
   22e86:	429a      	cmp	r2, r3
   22e88:	dd28      	ble.n	22edc <z_add_timeout+0x110>
				t->dticks -= to->dticks;
   22e8a:	1ad3      	subs	r3, r2, r3
   22e8c:	60b3      	str	r3, [r6, #8]
	node->prev = successor->prev;
   22e8e:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   22e90:	e9c4 6300 	strd	r6, r3, [r4]
	successor->prev->next = node;
   22e94:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   22e96:	6074      	str	r4, [r6, #4]
	return list->head == list;
   22e98:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   22e9a:	42ab      	cmp	r3, r5
   22e9c:	d006      	beq.n	22eac <z_add_timeout+0xe0>
		if (to == first()) {
   22e9e:	429c      	cmp	r4, r3
   22ea0:	d104      	bne.n	22eac <z_add_timeout+0xe0>
			z_clock_set_timeout(next_timeout(), false);
   22ea2:	f7ff ff5b 	bl	22d5c <next_timeout>
   22ea6:	2100      	movs	r1, #0
   22ea8:	f7e1 f9aa 	bl	4200 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   22eac:	4813      	ldr	r0, [pc, #76]	; (22efc <z_add_timeout+0x130>)
   22eae:	f7ff fe1b 	bl	22ae8 <z_spin_unlock_valid>
   22eb2:	b968      	cbnz	r0, 22ed0 <z_add_timeout+0x104>
   22eb4:	4a12      	ldr	r2, [pc, #72]	; (22f00 <z_add_timeout+0x134>)
   22eb6:	4916      	ldr	r1, [pc, #88]	; (22f10 <z_add_timeout+0x144>)
   22eb8:	480e      	ldr	r0, [pc, #56]	; (22ef4 <z_add_timeout+0x128>)
   22eba:	235d      	movs	r3, #93	; 0x5d
   22ebc:	f001 f811 	bl	23ee2 <printk>
   22ec0:	490e      	ldr	r1, [pc, #56]	; (22efc <z_add_timeout+0x130>)
   22ec2:	4814      	ldr	r0, [pc, #80]	; (22f14 <z_add_timeout+0x148>)
   22ec4:	f001 f80d 	bl	23ee2 <printk>
   22ec8:	480d      	ldr	r0, [pc, #52]	; (22f00 <z_add_timeout+0x134>)
   22eca:	215d      	movs	r1, #93	; 0x5d
   22ecc:	f001 f84c 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   22ed0:	f387 8811 	msr	BASEPRI, r7
   22ed4:	f3bf 8f6f 	isb	sy
}
   22ed8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			to->dticks -= t->dticks;
   22edc:	1a9b      	subs	r3, r3, r2
   22ede:	60a3      	str	r3, [r4, #8]
	return (node == list->tail) ? NULL : node->next;
   22ee0:	686b      	ldr	r3, [r5, #4]
   22ee2:	429e      	cmp	r6, r3
   22ee4:	d0b6      	beq.n	22e54 <z_add_timeout+0x88>
   22ee6:	6836      	ldr	r6, [r6, #0]
   22ee8:	e7b3      	b.n	22e52 <z_add_timeout+0x86>
   22eea:	bf00      	nop
   22eec:	0003156b 	.word	0x0003156b
   22ef0:	00031547 	.word	0x00031547
   22ef4:	0002a5e8 	.word	0x0002a5e8
   22ef8:	00030d23 	.word	0x00030d23
   22efc:	20001e74 	.word	0x20001e74
   22f00:	0002ae90 	.word	0x0002ae90
   22f04:	0002aeb2 	.word	0x0002aeb2
   22f08:	0002aec7 	.word	0x0002aec7
   22f0c:	200073d0 	.word	0x200073d0
   22f10:	0002aedf 	.word	0x0002aedf
   22f14:	0002aef6 	.word	0x0002aef6
   22f18:	0003158b 	.word	0x0003158b

00022f1c <z_abort_timeout>:
{
   22f1c:	b538      	push	{r3, r4, r5, lr}
   22f1e:	4604      	mov	r4, r0
	__asm__ volatile(
   22f20:	f04f 0320 	mov.w	r3, #32
   22f24:	f3ef 8511 	mrs	r5, BASEPRI
   22f28:	f383 8811 	msr	BASEPRI, r3
   22f2c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   22f30:	481a      	ldr	r0, [pc, #104]	; (22f9c <z_abort_timeout+0x80>)
   22f32:	f7ff fdcb 	bl	22acc <z_spin_lock_valid>
   22f36:	b968      	cbnz	r0, 22f54 <z_abort_timeout+0x38>
   22f38:	4a19      	ldr	r2, [pc, #100]	; (22fa0 <z_abort_timeout+0x84>)
   22f3a:	491a      	ldr	r1, [pc, #104]	; (22fa4 <z_abort_timeout+0x88>)
   22f3c:	481a      	ldr	r0, [pc, #104]	; (22fa8 <z_abort_timeout+0x8c>)
   22f3e:	234a      	movs	r3, #74	; 0x4a
   22f40:	f000 ffcf 	bl	23ee2 <printk>
   22f44:	4915      	ldr	r1, [pc, #84]	; (22f9c <z_abort_timeout+0x80>)
   22f46:	4819      	ldr	r0, [pc, #100]	; (22fac <z_abort_timeout+0x90>)
   22f48:	f000 ffcb 	bl	23ee2 <printk>
   22f4c:	4814      	ldr	r0, [pc, #80]	; (22fa0 <z_abort_timeout+0x84>)
   22f4e:	214a      	movs	r1, #74	; 0x4a
   22f50:	f001 f80a 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   22f54:	4811      	ldr	r0, [pc, #68]	; (22f9c <z_abort_timeout+0x80>)
   22f56:	f7ff fdd7 	bl	22b08 <z_spin_lock_set_owner>
		if (sys_dnode_is_linked(&to->node)) {
   22f5a:	6823      	ldr	r3, [r4, #0]
   22f5c:	b1db      	cbz	r3, 22f96 <z_abort_timeout+0x7a>
			remove_timeout(to);
   22f5e:	4620      	mov	r0, r4
   22f60:	f7ff fee8 	bl	22d34 <remove_timeout>
			ret = 0;
   22f64:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   22f66:	480d      	ldr	r0, [pc, #52]	; (22f9c <z_abort_timeout+0x80>)
   22f68:	f7ff fdbe 	bl	22ae8 <z_spin_unlock_valid>
   22f6c:	b968      	cbnz	r0, 22f8a <z_abort_timeout+0x6e>
   22f6e:	4a0c      	ldr	r2, [pc, #48]	; (22fa0 <z_abort_timeout+0x84>)
   22f70:	490f      	ldr	r1, [pc, #60]	; (22fb0 <z_abort_timeout+0x94>)
   22f72:	480d      	ldr	r0, [pc, #52]	; (22fa8 <z_abort_timeout+0x8c>)
   22f74:	235d      	movs	r3, #93	; 0x5d
   22f76:	f000 ffb4 	bl	23ee2 <printk>
   22f7a:	4908      	ldr	r1, [pc, #32]	; (22f9c <z_abort_timeout+0x80>)
   22f7c:	480d      	ldr	r0, [pc, #52]	; (22fb4 <z_abort_timeout+0x98>)
   22f7e:	f000 ffb0 	bl	23ee2 <printk>
   22f82:	4807      	ldr	r0, [pc, #28]	; (22fa0 <z_abort_timeout+0x84>)
   22f84:	215d      	movs	r1, #93	; 0x5d
   22f86:	f000 ffef 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   22f8a:	f385 8811 	msr	BASEPRI, r5
   22f8e:	f3bf 8f6f 	isb	sy
}
   22f92:	4620      	mov	r0, r4
   22f94:	bd38      	pop	{r3, r4, r5, pc}
	int ret = -EINVAL;
   22f96:	f06f 0415 	mvn.w	r4, #21
   22f9a:	e7e4      	b.n	22f66 <z_abort_timeout+0x4a>
   22f9c:	20001e74 	.word	0x20001e74
   22fa0:	0002ae90 	.word	0x0002ae90
   22fa4:	0002aeb2 	.word	0x0002aeb2
   22fa8:	0002a5e8 	.word	0x0002a5e8
   22fac:	0002aec7 	.word	0x0002aec7
   22fb0:	0002aedf 	.word	0x0002aedf
   22fb4:	0002aef6 	.word	0x0002aef6

00022fb8 <z_timeout_remaining>:

k_ticks_t z_timeout_remaining(struct _timeout *timeout)
{
   22fb8:	b538      	push	{r3, r4, r5, lr}
   22fba:	4604      	mov	r4, r0
	__asm__ volatile(
   22fbc:	f04f 0320 	mov.w	r3, #32
   22fc0:	f3ef 8511 	mrs	r5, BASEPRI
   22fc4:	f383 8811 	msr	BASEPRI, r3
   22fc8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   22fcc:	4818      	ldr	r0, [pc, #96]	; (23030 <z_timeout_remaining+0x78>)
   22fce:	f7ff fd7d 	bl	22acc <z_spin_lock_valid>
   22fd2:	b968      	cbnz	r0, 22ff0 <z_timeout_remaining+0x38>
   22fd4:	4a17      	ldr	r2, [pc, #92]	; (23034 <z_timeout_remaining+0x7c>)
   22fd6:	4918      	ldr	r1, [pc, #96]	; (23038 <z_timeout_remaining+0x80>)
   22fd8:	4818      	ldr	r0, [pc, #96]	; (2303c <z_timeout_remaining+0x84>)
   22fda:	234a      	movs	r3, #74	; 0x4a
   22fdc:	f000 ff81 	bl	23ee2 <printk>
   22fe0:	4913      	ldr	r1, [pc, #76]	; (23030 <z_timeout_remaining+0x78>)
   22fe2:	4817      	ldr	r0, [pc, #92]	; (23040 <z_timeout_remaining+0x88>)
   22fe4:	f000 ff7d 	bl	23ee2 <printk>
   22fe8:	4812      	ldr	r0, [pc, #72]	; (23034 <z_timeout_remaining+0x7c>)
   22fea:	214a      	movs	r1, #74	; 0x4a
   22fec:	f000 ffbc 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   22ff0:	480f      	ldr	r0, [pc, #60]	; (23030 <z_timeout_remaining+0x78>)
   22ff2:	f7ff fd89 	bl	22b08 <z_spin_lock_set_owner>
	k_ticks_t ticks = 0;

	LOCKED(&timeout_lock) {
		ticks = timeout_rem(timeout);
   22ff6:	4620      	mov	r0, r4
   22ff8:	f7ff fecc 	bl	22d94 <timeout_rem>
   22ffc:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   22ffe:	480c      	ldr	r0, [pc, #48]	; (23030 <z_timeout_remaining+0x78>)
   23000:	f7ff fd72 	bl	22ae8 <z_spin_unlock_valid>
   23004:	b968      	cbnz	r0, 23022 <z_timeout_remaining+0x6a>
   23006:	4a0b      	ldr	r2, [pc, #44]	; (23034 <z_timeout_remaining+0x7c>)
   23008:	490e      	ldr	r1, [pc, #56]	; (23044 <z_timeout_remaining+0x8c>)
   2300a:	480c      	ldr	r0, [pc, #48]	; (2303c <z_timeout_remaining+0x84>)
   2300c:	235d      	movs	r3, #93	; 0x5d
   2300e:	f000 ff68 	bl	23ee2 <printk>
   23012:	4907      	ldr	r1, [pc, #28]	; (23030 <z_timeout_remaining+0x78>)
   23014:	480c      	ldr	r0, [pc, #48]	; (23048 <z_timeout_remaining+0x90>)
   23016:	f000 ff64 	bl	23ee2 <printk>
   2301a:	4806      	ldr	r0, [pc, #24]	; (23034 <z_timeout_remaining+0x7c>)
   2301c:	215d      	movs	r1, #93	; 0x5d
   2301e:	f000 ffa3 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   23022:	f385 8811 	msr	BASEPRI, r5
   23026:	f3bf 8f6f 	isb	sy
	}

	return ticks;
}
   2302a:	4620      	mov	r0, r4
   2302c:	bd38      	pop	{r3, r4, r5, pc}
   2302e:	bf00      	nop
   23030:	20001e74 	.word	0x20001e74
   23034:	0002ae90 	.word	0x0002ae90
   23038:	0002aeb2 	.word	0x0002aeb2
   2303c:	0002a5e8 	.word	0x0002a5e8
   23040:	0002aec7 	.word	0x0002aec7
   23044:	0002aedf 	.word	0x0002aedf
   23048:	0002aef6 	.word	0x0002aef6

0002304c <z_get_next_timeout_expiry>:

	return ticks;
}

s32_t z_get_next_timeout_expiry(void)
{
   2304c:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   2304e:	f04f 0320 	mov.w	r3, #32
   23052:	f3ef 8511 	mrs	r5, BASEPRI
   23056:	f383 8811 	msr	BASEPRI, r3
   2305a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2305e:	4818      	ldr	r0, [pc, #96]	; (230c0 <z_get_next_timeout_expiry+0x74>)
   23060:	f7ff fd34 	bl	22acc <z_spin_lock_valid>
   23064:	b968      	cbnz	r0, 23082 <z_get_next_timeout_expiry+0x36>
   23066:	4a17      	ldr	r2, [pc, #92]	; (230c4 <z_get_next_timeout_expiry+0x78>)
   23068:	4917      	ldr	r1, [pc, #92]	; (230c8 <z_get_next_timeout_expiry+0x7c>)
   2306a:	4818      	ldr	r0, [pc, #96]	; (230cc <z_get_next_timeout_expiry+0x80>)
   2306c:	234a      	movs	r3, #74	; 0x4a
   2306e:	f000 ff38 	bl	23ee2 <printk>
   23072:	4913      	ldr	r1, [pc, #76]	; (230c0 <z_get_next_timeout_expiry+0x74>)
   23074:	4816      	ldr	r0, [pc, #88]	; (230d0 <z_get_next_timeout_expiry+0x84>)
   23076:	f000 ff34 	bl	23ee2 <printk>
   2307a:	4812      	ldr	r0, [pc, #72]	; (230c4 <z_get_next_timeout_expiry+0x78>)
   2307c:	214a      	movs	r1, #74	; 0x4a
   2307e:	f000 ff73 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   23082:	480f      	ldr	r0, [pc, #60]	; (230c0 <z_get_next_timeout_expiry+0x74>)
   23084:	f7ff fd40 	bl	22b08 <z_spin_lock_set_owner>
	s32_t ret = (s32_t) K_TICKS_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
   23088:	f7ff fe68 	bl	22d5c <next_timeout>
   2308c:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2308e:	480c      	ldr	r0, [pc, #48]	; (230c0 <z_get_next_timeout_expiry+0x74>)
   23090:	f7ff fd2a 	bl	22ae8 <z_spin_unlock_valid>
   23094:	b968      	cbnz	r0, 230b2 <z_get_next_timeout_expiry+0x66>
   23096:	4a0b      	ldr	r2, [pc, #44]	; (230c4 <z_get_next_timeout_expiry+0x78>)
   23098:	490e      	ldr	r1, [pc, #56]	; (230d4 <z_get_next_timeout_expiry+0x88>)
   2309a:	480c      	ldr	r0, [pc, #48]	; (230cc <z_get_next_timeout_expiry+0x80>)
   2309c:	235d      	movs	r3, #93	; 0x5d
   2309e:	f000 ff20 	bl	23ee2 <printk>
   230a2:	4907      	ldr	r1, [pc, #28]	; (230c0 <z_get_next_timeout_expiry+0x74>)
   230a4:	480c      	ldr	r0, [pc, #48]	; (230d8 <z_get_next_timeout_expiry+0x8c>)
   230a6:	f000 ff1c 	bl	23ee2 <printk>
   230aa:	4806      	ldr	r0, [pc, #24]	; (230c4 <z_get_next_timeout_expiry+0x78>)
   230ac:	215d      	movs	r1, #93	; 0x5d
   230ae:	f000 ff5b 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   230b2:	f385 8811 	msr	BASEPRI, r5
   230b6:	f3bf 8f6f 	isb	sy
	}
	return ret;
}
   230ba:	4620      	mov	r0, r4
   230bc:	bd38      	pop	{r3, r4, r5, pc}
   230be:	bf00      	nop
   230c0:	20001e74 	.word	0x20001e74
   230c4:	0002ae90 	.word	0x0002ae90
   230c8:	0002aeb2 	.word	0x0002aeb2
   230cc:	0002a5e8 	.word	0x0002a5e8
   230d0:	0002aec7 	.word	0x0002aec7
   230d4:	0002aedf 	.word	0x0002aedf
   230d8:	0002aef6 	.word	0x0002aef6

000230dc <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
   230dc:	b570      	push	{r4, r5, r6, lr}
   230de:	4604      	mov	r4, r0
   230e0:	460d      	mov	r5, r1
	__asm__ volatile(
   230e2:	f04f 0320 	mov.w	r3, #32
   230e6:	f3ef 8611 	mrs	r6, BASEPRI
   230ea:	f383 8811 	msr	BASEPRI, r3
   230ee:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   230f2:	481b      	ldr	r0, [pc, #108]	; (23160 <z_set_timeout_expiry+0x84>)
   230f4:	f7ff fcea 	bl	22acc <z_spin_lock_valid>
   230f8:	b968      	cbnz	r0, 23116 <z_set_timeout_expiry+0x3a>
   230fa:	4a1a      	ldr	r2, [pc, #104]	; (23164 <z_set_timeout_expiry+0x88>)
   230fc:	491a      	ldr	r1, [pc, #104]	; (23168 <z_set_timeout_expiry+0x8c>)
   230fe:	481b      	ldr	r0, [pc, #108]	; (2316c <z_set_timeout_expiry+0x90>)
   23100:	234a      	movs	r3, #74	; 0x4a
   23102:	f000 feee 	bl	23ee2 <printk>
   23106:	4916      	ldr	r1, [pc, #88]	; (23160 <z_set_timeout_expiry+0x84>)
   23108:	4819      	ldr	r0, [pc, #100]	; (23170 <z_set_timeout_expiry+0x94>)
   2310a:	f000 feea 	bl	23ee2 <printk>
   2310e:	4815      	ldr	r0, [pc, #84]	; (23164 <z_set_timeout_expiry+0x88>)
   23110:	214a      	movs	r1, #74	; 0x4a
   23112:	f000 ff29 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   23116:	4812      	ldr	r0, [pc, #72]	; (23160 <z_set_timeout_expiry+0x84>)
   23118:	f7ff fcf6 	bl	22b08 <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next = next_timeout();
   2311c:	f7ff fe1e 	bl	22d5c <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   23120:	2801      	cmp	r0, #1
   23122:	dd05      	ble.n	23130 <z_set_timeout_expiry+0x54>
   23124:	42a0      	cmp	r0, r4
   23126:	dd03      	ble.n	23130 <z_set_timeout_expiry+0x54>
			z_clock_set_timeout(ticks, idle);
   23128:	4629      	mov	r1, r5
   2312a:	4620      	mov	r0, r4
   2312c:	f7e1 f868 	bl	4200 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   23130:	480b      	ldr	r0, [pc, #44]	; (23160 <z_set_timeout_expiry+0x84>)
   23132:	f7ff fcd9 	bl	22ae8 <z_spin_unlock_valid>
   23136:	b968      	cbnz	r0, 23154 <z_set_timeout_expiry+0x78>
   23138:	4a0a      	ldr	r2, [pc, #40]	; (23164 <z_set_timeout_expiry+0x88>)
   2313a:	490e      	ldr	r1, [pc, #56]	; (23174 <z_set_timeout_expiry+0x98>)
   2313c:	480b      	ldr	r0, [pc, #44]	; (2316c <z_set_timeout_expiry+0x90>)
   2313e:	235d      	movs	r3, #93	; 0x5d
   23140:	f000 fecf 	bl	23ee2 <printk>
   23144:	4906      	ldr	r1, [pc, #24]	; (23160 <z_set_timeout_expiry+0x84>)
   23146:	480c      	ldr	r0, [pc, #48]	; (23178 <z_set_timeout_expiry+0x9c>)
   23148:	f000 fecb 	bl	23ee2 <printk>
   2314c:	4805      	ldr	r0, [pc, #20]	; (23164 <z_set_timeout_expiry+0x88>)
   2314e:	215d      	movs	r1, #93	; 0x5d
   23150:	f000 ff0a 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   23154:	f386 8811 	msr	BASEPRI, r6
   23158:	f3bf 8f6f 	isb	sy
		}
	}
}
   2315c:	bd70      	pop	{r4, r5, r6, pc}
   2315e:	bf00      	nop
   23160:	20001e74 	.word	0x20001e74
   23164:	0002ae90 	.word	0x0002ae90
   23168:	0002aeb2 	.word	0x0002aeb2
   2316c:	0002a5e8 	.word	0x0002a5e8
   23170:	0002aec7 	.word	0x0002aec7
   23174:	0002aedf 	.word	0x0002aedf
   23178:	0002aef6 	.word	0x0002aef6

0002317c <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
   2317c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   23180:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   23182:	f7fe fd17 	bl	21bb4 <z_time_slice>
	__asm__ volatile(
   23186:	f04f 0320 	mov.w	r3, #32
   2318a:	f3ef 8511 	mrs	r5, BASEPRI
   2318e:	f383 8811 	msr	BASEPRI, r3
   23192:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   23196:	4847      	ldr	r0, [pc, #284]	; (232b4 <z_clock_announce+0x138>)
   23198:	f7ff fc98 	bl	22acc <z_spin_lock_valid>
   2319c:	b968      	cbnz	r0, 231ba <z_clock_announce+0x3e>
   2319e:	4a46      	ldr	r2, [pc, #280]	; (232b8 <z_clock_announce+0x13c>)
   231a0:	4946      	ldr	r1, [pc, #280]	; (232bc <z_clock_announce+0x140>)
   231a2:	4847      	ldr	r0, [pc, #284]	; (232c0 <z_clock_announce+0x144>)
   231a4:	234a      	movs	r3, #74	; 0x4a
   231a6:	f000 fe9c 	bl	23ee2 <printk>
   231aa:	4942      	ldr	r1, [pc, #264]	; (232b4 <z_clock_announce+0x138>)
   231ac:	4845      	ldr	r0, [pc, #276]	; (232c4 <z_clock_announce+0x148>)
   231ae:	f000 fe98 	bl	23ee2 <printk>
   231b2:	4841      	ldr	r0, [pc, #260]	; (232b8 <z_clock_announce+0x13c>)
   231b4:	214a      	movs	r1, #74	; 0x4a
   231b6:	f000 fed7 	bl	23f68 <assert_post_action>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   231ba:	4e43      	ldr	r6, [pc, #268]	; (232c8 <z_clock_announce+0x14c>)
   231bc:	4f43      	ldr	r7, [pc, #268]	; (232cc <z_clock_announce+0x150>)
	z_spin_lock_set_owner(l);
   231be:	483d      	ldr	r0, [pc, #244]	; (232b4 <z_clock_announce+0x138>)
	return list->head == list;
   231c0:	f8df 8114 	ldr.w	r8, [pc, #276]	; 232d8 <z_clock_announce+0x15c>
   231c4:	f7ff fca0 	bl	22b08 <z_spin_lock_set_owner>
   231c8:	46b9      	mov	r9, r7
   231ca:	6034      	str	r4, [r6, #0]
   231cc:	f8d8 4000 	ldr.w	r4, [r8]
   231d0:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   231d2:	4544      	cmp	r4, r8
   231d4:	e9d7 0100 	ldrd	r0, r1, [r7]
   231d8:	d005      	beq.n	231e6 <z_clock_announce+0x6a>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   231da:	b124      	cbz	r4, 231e6 <z_clock_announce+0x6a>
   231dc:	68a3      	ldr	r3, [r4, #8]
   231de:	4293      	cmp	r3, r2
   231e0:	dd25      	ble.n	2322e <z_clock_announce+0xb2>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   231e2:	1a9b      	subs	r3, r3, r2
   231e4:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
   231e6:	1880      	adds	r0, r0, r2
   231e8:	eb41 71e2 	adc.w	r1, r1, r2, asr #31
	announce_remaining = 0;
   231ec:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   231ee:	e9c9 0100 	strd	r0, r1, [r9]
	announce_remaining = 0;
   231f2:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
   231f4:	f7ff fdb2 	bl	22d5c <next_timeout>
   231f8:	4621      	mov	r1, r4
   231fa:	f7e1 f801 	bl	4200 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   231fe:	482d      	ldr	r0, [pc, #180]	; (232b4 <z_clock_announce+0x138>)
   23200:	f7ff fc72 	bl	22ae8 <z_spin_unlock_valid>
   23204:	b968      	cbnz	r0, 23222 <z_clock_announce+0xa6>
   23206:	4a2c      	ldr	r2, [pc, #176]	; (232b8 <z_clock_announce+0x13c>)
   23208:	4931      	ldr	r1, [pc, #196]	; (232d0 <z_clock_announce+0x154>)
   2320a:	482d      	ldr	r0, [pc, #180]	; (232c0 <z_clock_announce+0x144>)
   2320c:	235d      	movs	r3, #93	; 0x5d
   2320e:	f000 fe68 	bl	23ee2 <printk>
   23212:	4928      	ldr	r1, [pc, #160]	; (232b4 <z_clock_announce+0x138>)
   23214:	482f      	ldr	r0, [pc, #188]	; (232d4 <z_clock_announce+0x158>)
   23216:	f000 fe64 	bl	23ee2 <printk>
   2321a:	4827      	ldr	r0, [pc, #156]	; (232b8 <z_clock_announce+0x13c>)
   2321c:	215d      	movs	r1, #93	; 0x5d
   2321e:	f000 fea3 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   23222:	f385 8811 	msr	BASEPRI, r5
   23226:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   2322a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
   2322e:	18c0      	adds	r0, r0, r3
   23230:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
		announce_remaining -= dt;
   23234:	1ad3      	subs	r3, r2, r3
   23236:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
   23238:	2300      	movs	r3, #0
		curr_tick += dt;
   2323a:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
   2323e:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
   23240:	4620      	mov	r0, r4
   23242:	f7ff fd77 	bl	22d34 <remove_timeout>
   23246:	481b      	ldr	r0, [pc, #108]	; (232b4 <z_clock_announce+0x138>)
   23248:	f7ff fc4e 	bl	22ae8 <z_spin_unlock_valid>
   2324c:	b968      	cbnz	r0, 2326a <z_clock_announce+0xee>
   2324e:	4a1a      	ldr	r2, [pc, #104]	; (232b8 <z_clock_announce+0x13c>)
   23250:	491f      	ldr	r1, [pc, #124]	; (232d0 <z_clock_announce+0x154>)
   23252:	481b      	ldr	r0, [pc, #108]	; (232c0 <z_clock_announce+0x144>)
   23254:	235d      	movs	r3, #93	; 0x5d
   23256:	f000 fe44 	bl	23ee2 <printk>
   2325a:	4916      	ldr	r1, [pc, #88]	; (232b4 <z_clock_announce+0x138>)
   2325c:	481d      	ldr	r0, [pc, #116]	; (232d4 <z_clock_announce+0x158>)
   2325e:	f000 fe40 	bl	23ee2 <printk>
   23262:	4815      	ldr	r0, [pc, #84]	; (232b8 <z_clock_announce+0x13c>)
   23264:	215d      	movs	r1, #93	; 0x5d
   23266:	f000 fe7f 	bl	23f68 <assert_post_action>
   2326a:	f385 8811 	msr	BASEPRI, r5
   2326e:	f3bf 8f6f 	isb	sy
		t->fn(t);
   23272:	68e3      	ldr	r3, [r4, #12]
   23274:	4620      	mov	r0, r4
   23276:	4798      	blx	r3
	__asm__ volatile(
   23278:	f04f 0320 	mov.w	r3, #32
   2327c:	f3ef 8511 	mrs	r5, BASEPRI
   23280:	f383 8811 	msr	BASEPRI, r3
   23284:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   23288:	480a      	ldr	r0, [pc, #40]	; (232b4 <z_clock_announce+0x138>)
   2328a:	f7ff fc1f 	bl	22acc <z_spin_lock_valid>
   2328e:	b968      	cbnz	r0, 232ac <z_clock_announce+0x130>
   23290:	4a09      	ldr	r2, [pc, #36]	; (232b8 <z_clock_announce+0x13c>)
   23292:	490a      	ldr	r1, [pc, #40]	; (232bc <z_clock_announce+0x140>)
   23294:	480a      	ldr	r0, [pc, #40]	; (232c0 <z_clock_announce+0x144>)
   23296:	234a      	movs	r3, #74	; 0x4a
   23298:	f000 fe23 	bl	23ee2 <printk>
   2329c:	4905      	ldr	r1, [pc, #20]	; (232b4 <z_clock_announce+0x138>)
   2329e:	4809      	ldr	r0, [pc, #36]	; (232c4 <z_clock_announce+0x148>)
   232a0:	f000 fe1f 	bl	23ee2 <printk>
   232a4:	4804      	ldr	r0, [pc, #16]	; (232b8 <z_clock_announce+0x13c>)
   232a6:	214a      	movs	r1, #74	; 0x4a
   232a8:	f000 fe5e 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   232ac:	4801      	ldr	r0, [pc, #4]	; (232b4 <z_clock_announce+0x138>)
   232ae:	f7ff fc2b 	bl	22b08 <z_spin_lock_set_owner>
	return k;
   232b2:	e78b      	b.n	231cc <z_clock_announce+0x50>
   232b4:	20001e74 	.word	0x20001e74
   232b8:	0002ae90 	.word	0x0002ae90
   232bc:	0002aeb2 	.word	0x0002aeb2
   232c0:	0002a5e8 	.word	0x0002a5e8
   232c4:	0002aec7 	.word	0x0002aec7
   232c8:	20001e70 	.word	0x20001e70
   232cc:	20000140 	.word	0x20000140
   232d0:	0002aedf 	.word	0x0002aedf
   232d4:	0002aef6 	.word	0x0002aef6
   232d8:	200073d0 	.word	0x200073d0

000232dc <z_tick_get>:

s64_t z_tick_get(void)
{
   232dc:	b570      	push	{r4, r5, r6, lr}
   232de:	f04f 0320 	mov.w	r3, #32
   232e2:	f3ef 8611 	mrs	r6, BASEPRI
   232e6:	f383 8811 	msr	BASEPRI, r3
   232ea:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   232ee:	481b      	ldr	r0, [pc, #108]	; (2335c <z_tick_get+0x80>)
   232f0:	f7ff fbec 	bl	22acc <z_spin_lock_valid>
   232f4:	b968      	cbnz	r0, 23312 <z_tick_get+0x36>
   232f6:	4a1a      	ldr	r2, [pc, #104]	; (23360 <z_tick_get+0x84>)
   232f8:	491a      	ldr	r1, [pc, #104]	; (23364 <z_tick_get+0x88>)
   232fa:	481b      	ldr	r0, [pc, #108]	; (23368 <z_tick_get+0x8c>)
   232fc:	234a      	movs	r3, #74	; 0x4a
   232fe:	f000 fdf0 	bl	23ee2 <printk>
   23302:	4916      	ldr	r1, [pc, #88]	; (2335c <z_tick_get+0x80>)
   23304:	4819      	ldr	r0, [pc, #100]	; (2336c <z_tick_get+0x90>)
   23306:	f000 fdec 	bl	23ee2 <printk>
   2330a:	4815      	ldr	r0, [pc, #84]	; (23360 <z_tick_get+0x84>)
   2330c:	214a      	movs	r1, #74	; 0x4a
   2330e:	f000 fe2b 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   23312:	4812      	ldr	r0, [pc, #72]	; (2335c <z_tick_get+0x80>)
   23314:	f7ff fbf8 	bl	22b08 <z_spin_lock_set_owner>
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   23318:	f7e0 fffe 	bl	4318 <z_clock_elapsed>
   2331c:	4b14      	ldr	r3, [pc, #80]	; (23370 <z_tick_get+0x94>)
   2331e:	e9d3 4500 	ldrd	r4, r5, [r3]
   23322:	1824      	adds	r4, r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   23324:	480d      	ldr	r0, [pc, #52]	; (2335c <z_tick_get+0x80>)
   23326:	f145 0500 	adc.w	r5, r5, #0
   2332a:	f7ff fbdd 	bl	22ae8 <z_spin_unlock_valid>
   2332e:	b968      	cbnz	r0, 2334c <z_tick_get+0x70>
   23330:	4a0b      	ldr	r2, [pc, #44]	; (23360 <z_tick_get+0x84>)
   23332:	4910      	ldr	r1, [pc, #64]	; (23374 <z_tick_get+0x98>)
   23334:	480c      	ldr	r0, [pc, #48]	; (23368 <z_tick_get+0x8c>)
   23336:	235d      	movs	r3, #93	; 0x5d
   23338:	f000 fdd3 	bl	23ee2 <printk>
   2333c:	4907      	ldr	r1, [pc, #28]	; (2335c <z_tick_get+0x80>)
   2333e:	480e      	ldr	r0, [pc, #56]	; (23378 <z_tick_get+0x9c>)
   23340:	f000 fdcf 	bl	23ee2 <printk>
   23344:	4806      	ldr	r0, [pc, #24]	; (23360 <z_tick_get+0x84>)
   23346:	215d      	movs	r1, #93	; 0x5d
   23348:	f000 fe0e 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   2334c:	f386 8811 	msr	BASEPRI, r6
   23350:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   23354:	4620      	mov	r0, r4
   23356:	4629      	mov	r1, r5
   23358:	bd70      	pop	{r4, r5, r6, pc}
   2335a:	bf00      	nop
   2335c:	20001e74 	.word	0x20001e74
   23360:	0002ae90 	.word	0x0002ae90
   23364:	0002aeb2 	.word	0x0002aeb2
   23368:	0002a5e8 	.word	0x0002a5e8
   2336c:	0002aec7 	.word	0x0002aec7
   23370:	20000140 	.word	0x20000140
   23374:	0002aedf 	.word	0x0002aedf
   23378:	0002aef6 	.word	0x0002aef6

0002337c <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   2337c:	6a02      	ldr	r2, [r0, #32]
{
   2337e:	b538      	push	{r3, r4, r5, lr}
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   23380:	1c53      	adds	r3, r2, #1
   23382:	2b01      	cmp	r3, #1
{
   23384:	4604      	mov	r4, r0
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   23386:	d902      	bls.n	2338e <z_timer_expiration_handler+0x12>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   23388:	490c      	ldr	r1, [pc, #48]	; (233bc <z_timer_expiration_handler+0x40>)
   2338a:	f7ff fd1f 	bl	22dcc <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   2338e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   23390:	3301      	adds	r3, #1
   23392:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   23394:	69a3      	ldr	r3, [r4, #24]
   23396:	b10b      	cbz	r3, 2339c <z_timer_expiration_handler+0x20>
		timer->expiry_fn(timer);
   23398:	4620      	mov	r0, r4
   2339a:	4798      	blx	r3
	return list->head == list;
   2339c:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   233a0:	42a5      	cmp	r5, r4
   233a2:	d009      	beq.n	233b8 <z_timer_expiration_handler+0x3c>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   233a4:	b145      	cbz	r5, 233b8 <z_timer_expiration_handler+0x3c>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   233a6:	4628      	mov	r0, r5
   233a8:	f7fd fffa 	bl	213a0 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
   233ac:	4628      	mov	r0, r5
   233ae:	f7fe fa6f 	bl	21890 <z_ready_thread>
   233b2:	2300      	movs	r3, #0
   233b4:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90

	arch_thread_return_value_set(thread, 0);
}
   233b8:	bd38      	pop	{r3, r4, r5, pc}
   233ba:	bf00      	nop
   233bc:	0002337d 	.word	0x0002337d

000233c0 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   233c0:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   233c4:	f240 38e7 	movw	r8, #999	; 0x3e7
   233c8:	f04f 0900 	mov.w	r9, #0
   233cc:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   233d0:	46c3      	mov	fp, r8
   233d2:	46cc      	mov	ip, r9
   233d4:	fbe7 bc01 	umlal	fp, ip, r7, r1
   233d8:	4604      	mov	r4, r0
   233da:	4616      	mov	r6, r2
   233dc:	4661      	mov	r1, ip
   233de:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   233e2:	2300      	movs	r3, #0
   233e4:	4658      	mov	r0, fp
   233e6:	f7dc fedb 	bl	1a0 <__aeabi_uldivmod>
   233ea:	4649      	mov	r1, r9
   233ec:	4605      	mov	r5, r0
   233ee:	4640      	mov	r0, r8
   233f0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   233f4:	2300      	movs	r3, #0
   233f6:	fbe7 0106 	umlal	r0, r1, r7, r6
   233fa:	f7dc fed1 	bl	1a0 <__aeabi_uldivmod>
   233fe:	4606      	mov	r6, r0
	if (Z_TICK_ABS(duration.ticks) < 0) {
		duration.ticks = MAX(duration.ticks - 1, 0);
	}
#endif

	(void)z_abort_timeout(&timer->timeout);
   23400:	4620      	mov	r0, r4
   23402:	f7ff fd8b 	bl	22f1c <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   23406:	2300      	movs	r3, #0
	period = k_ms_to_ticks_ceil32(period);
   23408:	6226      	str	r6, [r4, #32]
	timer->status = 0U;
   2340a:	6263      	str	r3, [r4, #36]	; 0x24

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   2340c:	462a      	mov	r2, r5
   2340e:	4620      	mov	r0, r4
   23410:	4902      	ldr	r1, [pc, #8]	; (2341c <z_impl_k_timer_start+0x5c>)
		     duration);
}
   23412:	e8bd 4bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   23416:	f7ff bcd9 	b.w	22dcc <z_add_timeout>
   2341a:	bf00      	nop
   2341c:	0002337d 	.word	0x0002337d

00023420 <k_poll_poller_cb>:

	return events_registered;
}

static int k_poll_poller_cb(struct k_poll_event *event, u32_t state)
{
   23420:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   23422:	6883      	ldr	r3, [r0, #8]
   23424:	685c      	ldr	r4, [r3, #4]
{
   23426:	460d      	mov	r5, r1

	__ASSERT(thread != NULL, "poller should have a thread\n");
   23428:	b964      	cbnz	r4, 23444 <k_poll_poller_cb+0x24>
   2342a:	4916      	ldr	r1, [pc, #88]	; (23484 <k_poll_poller_cb+0x64>)
   2342c:	4a16      	ldr	r2, [pc, #88]	; (23488 <k_poll_poller_cb+0x68>)
   2342e:	4817      	ldr	r0, [pc, #92]	; (2348c <k_poll_poller_cb+0x6c>)
   23430:	23e0      	movs	r3, #224	; 0xe0
   23432:	f000 fd56 	bl	23ee2 <printk>
   23436:	4816      	ldr	r0, [pc, #88]	; (23490 <k_poll_poller_cb+0x70>)
   23438:	f000 fd53 	bl	23ee2 <printk>
   2343c:	4812      	ldr	r0, [pc, #72]	; (23488 <k_poll_poller_cb+0x68>)
   2343e:	21e0      	movs	r1, #224	; 0xe0
   23440:	f000 fd92 	bl	23f68 <assert_post_action>

	if (!z_is_thread_pending(thread)) {
   23444:	7b63      	ldrb	r3, [r4, #13]
   23446:	079a      	lsls	r2, r3, #30
   23448:	d50f      	bpl.n	2346a <k_poll_poller_cb+0x4a>
		return 0;
	}

	if (z_is_thread_timeout_expired(thread)) {
   2344a:	6a23      	ldr	r3, [r4, #32]
   2344c:	3302      	adds	r3, #2
   2344e:	d015      	beq.n	2347c <k_poll_poller_cb+0x5c>
		return -EAGAIN;
	}

	z_unpend_thread(thread);
   23450:	4620      	mov	r0, r4
   23452:	f7fe f8d9 	bl	21608 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   23456:	2d08      	cmp	r5, #8
   23458:	bf0c      	ite	eq
   2345a:	f06f 0303 	mvneq.w	r3, #3
   2345e:	2300      	movne	r3, #0
   23460:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   23464:	7b63      	ldrb	r3, [r4, #13]
   23466:	06db      	lsls	r3, r3, #27
   23468:	d001      	beq.n	2346e <k_poll_poller_cb+0x4e>
		state == K_POLL_STATE_CANCELLED ? -EINTR : 0);

	if (!z_is_thread_ready(thread)) {
		return 0;
   2346a:	2000      	movs	r0, #0
	}

	z_ready_thread(thread);

	return 0;
}
   2346c:	bd38      	pop	{r3, r4, r5, pc}
	if (!z_is_thread_ready(thread)) {
   2346e:	69a5      	ldr	r5, [r4, #24]
   23470:	2d00      	cmp	r5, #0
   23472:	d1fa      	bne.n	2346a <k_poll_poller_cb+0x4a>
	z_ready_thread(thread);
   23474:	4620      	mov	r0, r4
   23476:	f7fe fa0b 	bl	21890 <z_ready_thread>
	return 0;
   2347a:	e7f6      	b.n	2346a <k_poll_poller_cb+0x4a>
		return -EAGAIN;
   2347c:	f06f 000a 	mvn.w	r0, #10
   23480:	e7f4      	b.n	2346c <k_poll_poller_cb+0x4c>
   23482:	bf00      	nop
   23484:	000315bb 	.word	0x000315bb
   23488:	0003159a 	.word	0x0003159a
   2348c:	0002a5e8 	.word	0x0002a5e8
   23490:	000315d1 	.word	0x000315d1

00023494 <clear_event_registrations>:
{
   23494:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   23498:	2414      	movs	r4, #20
		__ASSERT(false, "invalid event type\n");
   2349a:	4d4a      	ldr	r5, [pc, #296]	; (235c4 <clear_event_registrations+0x130>)
   2349c:	f8df 9160 	ldr.w	r9, [pc, #352]	; 23600 <clear_event_registrations+0x16c>
   234a0:	4f49      	ldr	r7, [pc, #292]	; (235c8 <clear_event_registrations+0x134>)
{
   234a2:	4680      	mov	r8, r0
   234a4:	4616      	mov	r6, r2
	while (num_events--) {
   234a6:	fb04 0401 	mla	r4, r4, r1, r0
   234aa:	4544      	cmp	r4, r8
   234ac:	d101      	bne.n	234b2 <clear_event_registrations+0x1e>
}
   234ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	event->poller = NULL;
   234b2:	2300      	movs	r3, #0
   234b4:	f844 3c0c 	str.w	r3, [r4, #-12]
	switch (event->type) {
   234b8:	f814 3c07 	ldrb.w	r3, [r4, #-7]
   234bc:	f003 030f 	and.w	r3, r3, #15
   234c0:	2b04      	cmp	r3, #4
   234c2:	d83d      	bhi.n	23540 <clear_event_registrations+0xac>
   234c4:	e8df f003 	tbb	[pc, r3]
   234c8:	3c032d49 	.word	0x3c032d49
   234cc:	1e          	.byte	0x1e
   234cd:	00          	.byte	0x00
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   234ce:	f854 3c04 	ldr.w	r3, [r4, #-4]
   234d2:	b963      	cbnz	r3, 234ee <clear_event_registrations+0x5a>
   234d4:	493d      	ldr	r1, [pc, #244]	; (235cc <clear_event_registrations+0x138>)
   234d6:	2396      	movs	r3, #150	; 0x96
   234d8:	462a      	mov	r2, r5
   234da:	4638      	mov	r0, r7
   234dc:	f000 fd01 	bl	23ee2 <printk>
   234e0:	483b      	ldr	r0, [pc, #236]	; (235d0 <clear_event_registrations+0x13c>)
   234e2:	f000 fcfe 	bl	23ee2 <printk>
   234e6:	2196      	movs	r1, #150	; 0x96
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   234e8:	4628      	mov	r0, r5
   234ea:	f000 fd3d 	bl	23f68 <assert_post_action>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   234ee:	f854 3c14 	ldr.w	r3, [r4, #-20]
   234f2:	b393      	cbz	r3, 2355a <clear_event_registrations+0xc6>
	node->prev->next = node->next;
   234f4:	f854 2c10 	ldr.w	r2, [r4, #-16]
   234f8:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   234fa:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   234fc:	2300      	movs	r3, #0
	node->prev = NULL;
   234fe:	e944 3305 	strd	r3, r3, [r4, #-20]
	sys_dnode_init(node);
}
   23502:	e02a      	b.n	2355a <clear_event_registrations+0xc6>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   23504:	f854 3c04 	ldr.w	r3, [r4, #-4]
   23508:	2b00      	cmp	r3, #0
   2350a:	d1f0      	bne.n	234ee <clear_event_registrations+0x5a>
   2350c:	4931      	ldr	r1, [pc, #196]	; (235d4 <clear_event_registrations+0x140>)
   2350e:	239a      	movs	r3, #154	; 0x9a
   23510:	462a      	mov	r2, r5
   23512:	4638      	mov	r0, r7
   23514:	f000 fce5 	bl	23ee2 <printk>
   23518:	482f      	ldr	r0, [pc, #188]	; (235d8 <clear_event_registrations+0x144>)
   2351a:	f000 fce2 	bl	23ee2 <printk>
   2351e:	219a      	movs	r1, #154	; 0x9a
   23520:	e7e2      	b.n	234e8 <clear_event_registrations+0x54>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   23522:	f854 3c04 	ldr.w	r3, [r4, #-4]
   23526:	2b00      	cmp	r3, #0
   23528:	d1e1      	bne.n	234ee <clear_event_registrations+0x5a>
   2352a:	492c      	ldr	r1, [pc, #176]	; (235dc <clear_event_registrations+0x148>)
   2352c:	239e      	movs	r3, #158	; 0x9e
   2352e:	462a      	mov	r2, r5
   23530:	4638      	mov	r0, r7
   23532:	f000 fcd6 	bl	23ee2 <printk>
   23536:	482a      	ldr	r0, [pc, #168]	; (235e0 <clear_event_registrations+0x14c>)
   23538:	f000 fcd3 	bl	23ee2 <printk>
   2353c:	219e      	movs	r1, #158	; 0x9e
   2353e:	e7d3      	b.n	234e8 <clear_event_registrations+0x54>
		__ASSERT(false, "invalid event type\n");
   23540:	4649      	mov	r1, r9
   23542:	23a5      	movs	r3, #165	; 0xa5
   23544:	462a      	mov	r2, r5
   23546:	4638      	mov	r0, r7
   23548:	f000 fccb 	bl	23ee2 <printk>
   2354c:	4825      	ldr	r0, [pc, #148]	; (235e4 <clear_event_registrations+0x150>)
   2354e:	f000 fcc8 	bl	23ee2 <printk>
   23552:	21a5      	movs	r1, #165	; 0xa5
   23554:	4628      	mov	r0, r5
   23556:	f000 fd07 	bl	23f68 <assert_post_action>
   2355a:	4823      	ldr	r0, [pc, #140]	; (235e8 <clear_event_registrations+0x154>)
   2355c:	f7ff fac4 	bl	22ae8 <z_spin_unlock_valid>
   23560:	b968      	cbnz	r0, 2357e <clear_event_registrations+0xea>
   23562:	4a22      	ldr	r2, [pc, #136]	; (235ec <clear_event_registrations+0x158>)
   23564:	4922      	ldr	r1, [pc, #136]	; (235f0 <clear_event_registrations+0x15c>)
   23566:	235d      	movs	r3, #93	; 0x5d
   23568:	4638      	mov	r0, r7
   2356a:	f000 fcba 	bl	23ee2 <printk>
   2356e:	491e      	ldr	r1, [pc, #120]	; (235e8 <clear_event_registrations+0x154>)
   23570:	4820      	ldr	r0, [pc, #128]	; (235f4 <clear_event_registrations+0x160>)
   23572:	f000 fcb6 	bl	23ee2 <printk>
   23576:	481d      	ldr	r0, [pc, #116]	; (235ec <clear_event_registrations+0x158>)
   23578:	215d      	movs	r1, #93	; 0x5d
   2357a:	f000 fcf5 	bl	23f68 <assert_post_action>
   2357e:	f386 8811 	msr	BASEPRI, r6
   23582:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   23586:	f04f 0320 	mov.w	r3, #32
   2358a:	f3ef 8611 	mrs	r6, BASEPRI
   2358e:	f383 8811 	msr	BASEPRI, r3
   23592:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   23596:	4814      	ldr	r0, [pc, #80]	; (235e8 <clear_event_registrations+0x154>)
   23598:	f7ff fa98 	bl	22acc <z_spin_lock_valid>
   2359c:	b968      	cbnz	r0, 235ba <clear_event_registrations+0x126>
   2359e:	4a13      	ldr	r2, [pc, #76]	; (235ec <clear_event_registrations+0x158>)
   235a0:	4915      	ldr	r1, [pc, #84]	; (235f8 <clear_event_registrations+0x164>)
   235a2:	234a      	movs	r3, #74	; 0x4a
   235a4:	4638      	mov	r0, r7
   235a6:	f000 fc9c 	bl	23ee2 <printk>
   235aa:	490f      	ldr	r1, [pc, #60]	; (235e8 <clear_event_registrations+0x154>)
   235ac:	4813      	ldr	r0, [pc, #76]	; (235fc <clear_event_registrations+0x168>)
   235ae:	f000 fc98 	bl	23ee2 <printk>
   235b2:	480e      	ldr	r0, [pc, #56]	; (235ec <clear_event_registrations+0x158>)
   235b4:	214a      	movs	r1, #74	; 0x4a
   235b6:	f000 fcd7 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   235ba:	480b      	ldr	r0, [pc, #44]	; (235e8 <clear_event_registrations+0x154>)
   235bc:	f7ff faa4 	bl	22b08 <z_spin_lock_set_owner>
	return k;
   235c0:	3c14      	subs	r4, #20
   235c2:	e772      	b.n	234aa <clear_event_registrations+0x16>
   235c4:	0003159a 	.word	0x0003159a
   235c8:	0002a5e8 	.word	0x0002a5e8
   235cc:	000315f0 	.word	0x000315f0
   235d0:	0003160a 	.word	0x0003160a
   235d4:	0003161f 	.word	0x0003161f
   235d8:	0003163b 	.word	0x0003163b
   235dc:	0003164c 	.word	0x0003164c
   235e0:	00031669 	.word	0x00031669
   235e4:	00031680 	.word	0x00031680
   235e8:	20001e78 	.word	0x20001e78
   235ec:	0002ae90 	.word	0x0002ae90
   235f0:	0002aedf 	.word	0x0002aedf
   235f4:	0002aef6 	.word	0x0002aef6
   235f8:	0002aeb2 	.word	0x0002aeb2
   235fc:	0002aec7 	.word	0x0002aec7
   23600:	0002e3c9 	.word	0x0002e3c9

00023604 <register_events>:
{
   23604:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   23608:	2700      	movs	r7, #0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2360a:	4e6c      	ldr	r6, [pc, #432]	; (237bc <register_events+0x1b8>)
   2360c:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 237f8 <register_events+0x1f4>
   23610:	f8df a1e8 	ldr.w	sl, [pc, #488]	; 237fc <register_events+0x1f8>
{
   23614:	9100      	str	r1, [sp, #0]
   23616:	4615      	mov	r5, r2
   23618:	9301      	str	r3, [sp, #4]
   2361a:	4604      	mov	r4, r0
	int events_registered = 0;
   2361c:	46b9      	mov	r9, r7
	for (int ii = 0; ii < num_events; ii++) {
   2361e:	9b00      	ldr	r3, [sp, #0]
   23620:	429f      	cmp	r7, r3
   23622:	db03      	blt.n	2362c <register_events+0x28>
}
   23624:	4648      	mov	r0, r9
   23626:	b003      	add	sp, #12
   23628:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2362c:	f04f 0320 	mov.w	r3, #32
   23630:	f3ef 8b11 	mrs	fp, BASEPRI
   23634:	f383 8811 	msr	BASEPRI, r3
   23638:	f3bf 8f6f 	isb	sy
   2363c:	4630      	mov	r0, r6
   2363e:	f7ff fa45 	bl	22acc <z_spin_lock_valid>
   23642:	b968      	cbnz	r0, 23660 <register_events+0x5c>
   23644:	485e      	ldr	r0, [pc, #376]	; (237c0 <register_events+0x1bc>)
   23646:	234a      	movs	r3, #74	; 0x4a
   23648:	4642      	mov	r2, r8
   2364a:	4651      	mov	r1, sl
   2364c:	f000 fc49 	bl	23ee2 <printk>
   23650:	485c      	ldr	r0, [pc, #368]	; (237c4 <register_events+0x1c0>)
   23652:	4631      	mov	r1, r6
   23654:	f000 fc45 	bl	23ee2 <printk>
   23658:	214a      	movs	r1, #74	; 0x4a
   2365a:	4640      	mov	r0, r8
   2365c:	f000 fc84 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   23660:	4630      	mov	r0, r6
   23662:	f7ff fa51 	bl	22b08 <z_spin_lock_set_owner>
	switch (event->type) {
   23666:	7b63      	ldrb	r3, [r4, #13]
   23668:	f003 030f 	and.w	r3, r3, #15
   2366c:	2b04      	cmp	r3, #4
   2366e:	d844      	bhi.n	236fa <register_events+0xf6>
   23670:	e8df f003 	tbb	[pc, r3]
   23674:	43033d2d 	.word	0x43033d2d
   23678:	2a          	.byte	0x2a
   23679:	00          	.byte	0x00
		if (k_sem_count_get(event->sem) > 0) {
   2367a:	6923      	ldr	r3, [r4, #16]
   2367c:	689b      	ldr	r3, [r3, #8]
   2367e:	b333      	cbz	r3, 236ce <register_events+0xca>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   23680:	2202      	movs	r2, #2
	event->state |= state;
   23682:	68e3      	ldr	r3, [r4, #12]
   23684:	f3c3 3004 	ubfx	r0, r3, #12, #5
   23688:	4302      	orrs	r2, r0
	event->poller = NULL;
   2368a:	2100      	movs	r1, #0
	event->state |= state;
   2368c:	f362 3310 	bfi	r3, r2, #12, #5
	event->poller = NULL;
   23690:	60a1      	str	r1, [r4, #8]
	event->state |= state;
   23692:	60e3      	str	r3, [r4, #12]
			poller->is_polling = false;
   23694:	7029      	strb	r1, [r5, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   23696:	4630      	mov	r0, r6
   23698:	f7ff fa26 	bl	22ae8 <z_spin_unlock_valid>
   2369c:	b968      	cbnz	r0, 236ba <register_events+0xb6>
   2369e:	494a      	ldr	r1, [pc, #296]	; (237c8 <register_events+0x1c4>)
   236a0:	4847      	ldr	r0, [pc, #284]	; (237c0 <register_events+0x1bc>)
   236a2:	235d      	movs	r3, #93	; 0x5d
   236a4:	4642      	mov	r2, r8
   236a6:	f000 fc1c 	bl	23ee2 <printk>
   236aa:	4848      	ldr	r0, [pc, #288]	; (237cc <register_events+0x1c8>)
   236ac:	4631      	mov	r1, r6
   236ae:	f000 fc18 	bl	23ee2 <printk>
   236b2:	215d      	movs	r1, #93	; 0x5d
   236b4:	4640      	mov	r0, r8
   236b6:	f000 fc57 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   236ba:	f38b 8811 	msr	BASEPRI, fp
   236be:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   236c2:	3701      	adds	r7, #1
   236c4:	3414      	adds	r4, #20
   236c6:	e7aa      	b.n	2361e <register_events+0x1a>
		if (!k_queue_is_empty(event->queue)) {
   236c8:	6923      	ldr	r3, [r4, #16]
   236ca:	681b      	ldr	r3, [r3, #0]
   236cc:	bb33      	cbnz	r3, 2371c <register_events+0x118>
		} else if (!just_check && poller->is_polling) {
   236ce:	9b01      	ldr	r3, [sp, #4]
   236d0:	2b00      	cmp	r3, #0
   236d2:	d1e0      	bne.n	23696 <register_events+0x92>
   236d4:	782b      	ldrb	r3, [r5, #0]
   236d6:	2b00      	cmp	r3, #0
   236d8:	d0dd      	beq.n	23696 <register_events+0x92>
	switch (event->type) {
   236da:	7b63      	ldrb	r3, [r4, #13]
   236dc:	f003 030f 	and.w	r3, r3, #15
   236e0:	2b04      	cmp	r3, #4
   236e2:	d85d      	bhi.n	237a0 <register_events+0x19c>
   236e4:	e8df f003 	tbb	[pc, r3]
   236e8:	5c1c4931 	.word	0x5c1c4931
   236ec:	35          	.byte	0x35
   236ed:	00          	.byte	0x00
		if (event->signal->signaled != 0U) {
   236ee:	6923      	ldr	r3, [r4, #16]
   236f0:	689b      	ldr	r3, [r3, #8]
   236f2:	2b00      	cmp	r3, #0
   236f4:	d0eb      	beq.n	236ce <register_events+0xca>
			*state = K_POLL_STATE_SIGNALED;
   236f6:	2201      	movs	r2, #1
   236f8:	e7c3      	b.n	23682 <register_events+0x7e>
		__ASSERT(false, "invalid event type (0x%x)\n", event->type);
   236fa:	4a35      	ldr	r2, [pc, #212]	; (237d0 <register_events+0x1cc>)
   236fc:	4935      	ldr	r1, [pc, #212]	; (237d4 <register_events+0x1d0>)
   236fe:	4830      	ldr	r0, [pc, #192]	; (237c0 <register_events+0x1bc>)
   23700:	2350      	movs	r3, #80	; 0x50
   23702:	f000 fbee 	bl	23ee2 <printk>
   23706:	7b61      	ldrb	r1, [r4, #13]
   23708:	4833      	ldr	r0, [pc, #204]	; (237d8 <register_events+0x1d4>)
   2370a:	f001 010f 	and.w	r1, r1, #15
   2370e:	f000 fbe8 	bl	23ee2 <printk>
   23712:	482f      	ldr	r0, [pc, #188]	; (237d0 <register_events+0x1cc>)
   23714:	2150      	movs	r1, #80	; 0x50
   23716:	f000 fc27 	bl	23f68 <assert_post_action>
		break;
   2371a:	e7d8      	b.n	236ce <register_events+0xca>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   2371c:	2204      	movs	r2, #4
   2371e:	e7b0      	b.n	23682 <register_events+0x7e>
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   23720:	6923      	ldr	r3, [r4, #16]
   23722:	b963      	cbnz	r3, 2373e <register_events+0x13a>
   23724:	492d      	ldr	r1, [pc, #180]	; (237dc <register_events+0x1d8>)
   23726:	4a2a      	ldr	r2, [pc, #168]	; (237d0 <register_events+0x1cc>)
   23728:	4825      	ldr	r0, [pc, #148]	; (237c0 <register_events+0x1bc>)
   2372a:	2375      	movs	r3, #117	; 0x75
   2372c:	f000 fbd9 	bl	23ee2 <printk>
   23730:	482b      	ldr	r0, [pc, #172]	; (237e0 <register_events+0x1dc>)
   23732:	f000 fbd6 	bl	23ee2 <printk>
   23736:	4826      	ldr	r0, [pc, #152]	; (237d0 <register_events+0x1cc>)
   23738:	2175      	movs	r1, #117	; 0x75
   2373a:	f000 fc15 	bl	23f68 <assert_post_action>
		add_event(&event->sem->poll_events, event, poller);
   2373e:	6920      	ldr	r0, [r4, #16]
   23740:	462a      	mov	r2, r5
   23742:	4621      	mov	r1, r4
   23744:	3010      	adds	r0, #16
		add_event(&event->queue->poll_events, event, poller);
   23746:	f005 fed6 	bl	294f6 <add_event>
	event->poller = poller;
   2374a:	60a5      	str	r5, [r4, #8]
				events_registered += 1;
   2374c:	f109 0901 	add.w	r9, r9, #1
   23750:	e7a1      	b.n	23696 <register_events+0x92>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   23752:	6923      	ldr	r3, [r4, #16]
   23754:	b963      	cbnz	r3, 23770 <register_events+0x16c>
   23756:	4923      	ldr	r1, [pc, #140]	; (237e4 <register_events+0x1e0>)
   23758:	4a1d      	ldr	r2, [pc, #116]	; (237d0 <register_events+0x1cc>)
   2375a:	4819      	ldr	r0, [pc, #100]	; (237c0 <register_events+0x1bc>)
   2375c:	2379      	movs	r3, #121	; 0x79
   2375e:	f000 fbc0 	bl	23ee2 <printk>
   23762:	4821      	ldr	r0, [pc, #132]	; (237e8 <register_events+0x1e4>)
   23764:	f000 fbbd 	bl	23ee2 <printk>
   23768:	4819      	ldr	r0, [pc, #100]	; (237d0 <register_events+0x1cc>)
   2376a:	2179      	movs	r1, #121	; 0x79
   2376c:	f000 fbfc 	bl	23f68 <assert_post_action>
		add_event(&event->queue->poll_events, event, poller);
   23770:	6920      	ldr	r0, [r4, #16]
   23772:	462a      	mov	r2, r5
   23774:	4621      	mov	r1, r4
   23776:	300c      	adds	r0, #12
   23778:	e7e5      	b.n	23746 <register_events+0x142>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   2377a:	6923      	ldr	r3, [r4, #16]
   2377c:	b963      	cbnz	r3, 23798 <register_events+0x194>
   2377e:	491b      	ldr	r1, [pc, #108]	; (237ec <register_events+0x1e8>)
   23780:	4a13      	ldr	r2, [pc, #76]	; (237d0 <register_events+0x1cc>)
   23782:	480f      	ldr	r0, [pc, #60]	; (237c0 <register_events+0x1bc>)
   23784:	237d      	movs	r3, #125	; 0x7d
   23786:	f000 fbac 	bl	23ee2 <printk>
   2378a:	4819      	ldr	r0, [pc, #100]	; (237f0 <register_events+0x1ec>)
   2378c:	f000 fba9 	bl	23ee2 <printk>
   23790:	480f      	ldr	r0, [pc, #60]	; (237d0 <register_events+0x1cc>)
   23792:	217d      	movs	r1, #125	; 0x7d
   23794:	f000 fbe8 	bl	23f68 <assert_post_action>
		add_event(&event->signal->poll_events, event, poller);
   23798:	6920      	ldr	r0, [r4, #16]
   2379a:	462a      	mov	r2, r5
   2379c:	4621      	mov	r1, r4
   2379e:	e7d2      	b.n	23746 <register_events+0x142>
		__ASSERT(false, "invalid event type\n");
   237a0:	4a0b      	ldr	r2, [pc, #44]	; (237d0 <register_events+0x1cc>)
   237a2:	490c      	ldr	r1, [pc, #48]	; (237d4 <register_events+0x1d0>)
   237a4:	4806      	ldr	r0, [pc, #24]	; (237c0 <register_events+0x1bc>)
   237a6:	2384      	movs	r3, #132	; 0x84
   237a8:	f000 fb9b 	bl	23ee2 <printk>
   237ac:	4811      	ldr	r0, [pc, #68]	; (237f4 <register_events+0x1f0>)
   237ae:	f000 fb98 	bl	23ee2 <printk>
   237b2:	4807      	ldr	r0, [pc, #28]	; (237d0 <register_events+0x1cc>)
   237b4:	2184      	movs	r1, #132	; 0x84
   237b6:	f000 fbd7 	bl	23f68 <assert_post_action>
		break;
   237ba:	e7c6      	b.n	2374a <register_events+0x146>
   237bc:	20001e78 	.word	0x20001e78
   237c0:	0002a5e8 	.word	0x0002a5e8
   237c4:	0002aec7 	.word	0x0002aec7
   237c8:	0002aedf 	.word	0x0002aedf
   237cc:	0002aef6 	.word	0x0002aef6
   237d0:	0003159a 	.word	0x0003159a
   237d4:	0002e3c9 	.word	0x0002e3c9
   237d8:	00031696 	.word	0x00031696
   237dc:	000315f0 	.word	0x000315f0
   237e0:	0003160a 	.word	0x0003160a
   237e4:	0003161f 	.word	0x0003161f
   237e8:	0003163b 	.word	0x0003163b
   237ec:	0003164c 	.word	0x0003164c
   237f0:	00031669 	.word	0x00031669
   237f4:	00031680 	.word	0x00031680
   237f8:	0002ae90 	.word	0x0002ae90
   237fc:	0002aeb2 	.word	0x0002aeb2

00023800 <k_poll_event_init>:
{
   23800:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   23802:	4605      	mov	r5, r0
   23804:	460f      	mov	r7, r1
   23806:	461e      	mov	r6, r3
	__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,
   23808:	4614      	mov	r4, r2
   2380a:	b162      	cbz	r2, 23826 <k_poll_event_init+0x26>
   2380c:	491b      	ldr	r1, [pc, #108]	; (2387c <k_poll_event_init+0x7c>)
   2380e:	4a1c      	ldr	r2, [pc, #112]	; (23880 <k_poll_event_init+0x80>)
   23810:	481c      	ldr	r0, [pc, #112]	; (23884 <k_poll_event_init+0x84>)
   23812:	2329      	movs	r3, #41	; 0x29
   23814:	f000 fb65 	bl	23ee2 <printk>
   23818:	481b      	ldr	r0, [pc, #108]	; (23888 <k_poll_event_init+0x88>)
   2381a:	f000 fb62 	bl	23ee2 <printk>
   2381e:	4818      	ldr	r0, [pc, #96]	; (23880 <k_poll_event_init+0x80>)
   23820:	2129      	movs	r1, #41	; 0x29
   23822:	f000 fba1 	bl	23f68 <assert_post_action>
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
   23826:	2f0f      	cmp	r7, #15
   23828:	d90c      	bls.n	23844 <k_poll_event_init+0x44>
   2382a:	4918      	ldr	r1, [pc, #96]	; (2388c <k_poll_event_init+0x8c>)
   2382c:	4a14      	ldr	r2, [pc, #80]	; (23880 <k_poll_event_init+0x80>)
   2382e:	4815      	ldr	r0, [pc, #84]	; (23884 <k_poll_event_init+0x84>)
   23830:	232b      	movs	r3, #43	; 0x2b
   23832:	f000 fb56 	bl	23ee2 <printk>
   23836:	4816      	ldr	r0, [pc, #88]	; (23890 <k_poll_event_init+0x90>)
   23838:	f000 fb53 	bl	23ee2 <printk>
   2383c:	4810      	ldr	r0, [pc, #64]	; (23880 <k_poll_event_init+0x80>)
   2383e:	212b      	movs	r1, #43	; 0x2b
   23840:	f000 fb92 	bl	23f68 <assert_post_action>
	__ASSERT(obj != NULL, "must provide an object\n");
   23844:	b966      	cbnz	r6, 23860 <k_poll_event_init+0x60>
   23846:	4913      	ldr	r1, [pc, #76]	; (23894 <k_poll_event_init+0x94>)
   23848:	4a0d      	ldr	r2, [pc, #52]	; (23880 <k_poll_event_init+0x80>)
   2384a:	480e      	ldr	r0, [pc, #56]	; (23884 <k_poll_event_init+0x84>)
   2384c:	232c      	movs	r3, #44	; 0x2c
   2384e:	f000 fb48 	bl	23ee2 <printk>
   23852:	4811      	ldr	r0, [pc, #68]	; (23898 <k_poll_event_init+0x98>)
   23854:	f000 fb45 	bl	23ee2 <printk>
   23858:	4809      	ldr	r0, [pc, #36]	; (23880 <k_poll_event_init+0x80>)
   2385a:	212c      	movs	r1, #44	; 0x2c
   2385c:	f000 fb84 	bl	23f68 <assert_post_action>
	event->poller = NULL;
   23860:	2300      	movs	r3, #0
	event->type = type;
   23862:	0464      	lsls	r4, r4, #17
   23864:	023f      	lsls	r7, r7, #8
	event->poller = NULL;
   23866:	60ab      	str	r3, [r5, #8]
	event->type = type;
   23868:	f404 3400 	and.w	r4, r4, #131072	; 0x20000
   2386c:	7b2b      	ldrb	r3, [r5, #12]
   2386e:	f407 6770 	and.w	r7, r7, #3840	; 0xf00
   23872:	433c      	orrs	r4, r7
   23874:	431c      	orrs	r4, r3
	event->obj = obj;
   23876:	e9c5 4603 	strd	r4, r6, [r5, #12]
}
   2387a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2387c:	000316b3 	.word	0x000316b3
   23880:	0003159a 	.word	0x0003159a
   23884:	0002a5e8 	.word	0x0002a5e8
   23888:	000316d3 	.word	0x000316d3
   2388c:	000316f9 	.word	0x000316f9
   23890:	0003171d 	.word	0x0003171d
   23894:	0003172d 	.word	0x0003172d
   23898:	00031740 	.word	0x00031740

0002389c <z_impl_k_poll>:

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
   2389c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2389e:	b087      	sub	sp, #28
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   238a0:	2301      	movs	r3, #1
   238a2:	f88d 300c 	strb.w	r3, [sp, #12]
				  .thread     = _current,
   238a6:	4b71      	ldr	r3, [pc, #452]	; (23a6c <z_impl_k_poll+0x1d0>)
	struct _poller poller = { .is_polling = true,
   238a8:	689b      	ldr	r3, [r3, #8]
   238aa:	9304      	str	r3, [sp, #16]
   238ac:	4b70      	ldr	r3, [pc, #448]	; (23a70 <z_impl_k_poll+0x1d4>)
   238ae:	9305      	str	r3, [sp, #20]
{
   238b0:	4604      	mov	r4, r0
   238b2:	460e      	mov	r6, r1
   238b4:	4615      	mov	r5, r2
   238b6:	f3ef 8305 	mrs	r3, IPSR
				  .cb         = k_poll_poller_cb };

	__ASSERT(!arch_is_in_isr(), "");
   238ba:	b173      	cbz	r3, 238da <z_impl_k_poll+0x3e>
   238bc:	496d      	ldr	r1, [pc, #436]	; (23a74 <z_impl_k_poll+0x1d8>)
   238be:	4a6e      	ldr	r2, [pc, #440]	; (23a78 <z_impl_k_poll+0x1dc>)
   238c0:	486e      	ldr	r0, [pc, #440]	; (23a7c <z_impl_k_poll+0x1e0>)
   238c2:	f44f 7380 	mov.w	r3, #256	; 0x100
   238c6:	f000 fb0c 	bl	23ee2 <printk>
   238ca:	486d      	ldr	r0, [pc, #436]	; (23a80 <z_impl_k_poll+0x1e4>)
   238cc:	f000 fb09 	bl	23ee2 <printk>
   238d0:	4869      	ldr	r0, [pc, #420]	; (23a78 <z_impl_k_poll+0x1dc>)
   238d2:	f44f 7180 	mov.w	r1, #256	; 0x100
   238d6:	f000 fb47 	bl	23f68 <assert_post_action>
	__ASSERT(events != NULL, "NULL events\n");
   238da:	b974      	cbnz	r4, 238fa <z_impl_k_poll+0x5e>
   238dc:	4969      	ldr	r1, [pc, #420]	; (23a84 <z_impl_k_poll+0x1e8>)
   238de:	4a66      	ldr	r2, [pc, #408]	; (23a78 <z_impl_k_poll+0x1dc>)
   238e0:	4866      	ldr	r0, [pc, #408]	; (23a7c <z_impl_k_poll+0x1e0>)
   238e2:	f240 1301 	movw	r3, #257	; 0x101
   238e6:	f000 fafc 	bl	23ee2 <printk>
   238ea:	4867      	ldr	r0, [pc, #412]	; (23a88 <z_impl_k_poll+0x1ec>)
   238ec:	f000 faf9 	bl	23ee2 <printk>
   238f0:	4861      	ldr	r0, [pc, #388]	; (23a78 <z_impl_k_poll+0x1dc>)
   238f2:	f240 1101 	movw	r1, #257	; 0x101
   238f6:	f000 fb37 	bl	23f68 <assert_post_action>
	__ASSERT(num_events >= 0, "<0 events\n");
   238fa:	2e00      	cmp	r6, #0
   238fc:	da0e      	bge.n	2391c <z_impl_k_poll+0x80>
   238fe:	4963      	ldr	r1, [pc, #396]	; (23a8c <z_impl_k_poll+0x1f0>)
   23900:	4a5d      	ldr	r2, [pc, #372]	; (23a78 <z_impl_k_poll+0x1dc>)
   23902:	485e      	ldr	r0, [pc, #376]	; (23a7c <z_impl_k_poll+0x1e0>)
   23904:	f44f 7381 	mov.w	r3, #258	; 0x102
   23908:	f000 faeb 	bl	23ee2 <printk>
   2390c:	4860      	ldr	r0, [pc, #384]	; (23a90 <z_impl_k_poll+0x1f4>)
   2390e:	f000 fae8 	bl	23ee2 <printk>
   23912:	4859      	ldr	r0, [pc, #356]	; (23a78 <z_impl_k_poll+0x1dc>)
   23914:	f44f 7181 	mov.w	r1, #258	; 0x102
   23918:	f000 fb26 	bl	23f68 <assert_post_action>

	events_registered = register_events(events, num_events, &poller,
   2391c:	fab5 f385 	clz	r3, r5
   23920:	4631      	mov	r1, r6
   23922:	095b      	lsrs	r3, r3, #5
   23924:	aa03      	add	r2, sp, #12
   23926:	4620      	mov	r0, r4
   23928:	f7ff fe6c 	bl	23604 <register_events>
   2392c:	4606      	mov	r6, r0
	__asm__ volatile(
   2392e:	f04f 0320 	mov.w	r3, #32
   23932:	f3ef 8711 	mrs	r7, BASEPRI
   23936:	f383 8811 	msr	BASEPRI, r3
   2393a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2393e:	4855      	ldr	r0, [pc, #340]	; (23a94 <z_impl_k_poll+0x1f8>)
   23940:	f7ff f8c4 	bl	22acc <z_spin_lock_valid>
   23944:	b968      	cbnz	r0, 23962 <z_impl_k_poll+0xc6>
   23946:	4a54      	ldr	r2, [pc, #336]	; (23a98 <z_impl_k_poll+0x1fc>)
   23948:	4954      	ldr	r1, [pc, #336]	; (23a9c <z_impl_k_poll+0x200>)
   2394a:	484c      	ldr	r0, [pc, #304]	; (23a7c <z_impl_k_poll+0x1e0>)
   2394c:	234a      	movs	r3, #74	; 0x4a
   2394e:	f000 fac8 	bl	23ee2 <printk>
   23952:	4950      	ldr	r1, [pc, #320]	; (23a94 <z_impl_k_poll+0x1f8>)
   23954:	4852      	ldr	r0, [pc, #328]	; (23aa0 <z_impl_k_poll+0x204>)
   23956:	f000 fac4 	bl	23ee2 <printk>
   2395a:	484f      	ldr	r0, [pc, #316]	; (23a98 <z_impl_k_poll+0x1fc>)
   2395c:	214a      	movs	r1, #74	; 0x4a
   2395e:	f000 fb03 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   23962:	484c      	ldr	r0, [pc, #304]	; (23a94 <z_impl_k_poll+0x1f8>)
   23964:	f7ff f8d0 	bl	22b08 <z_spin_lock_set_owner>
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   23968:	f89d 300c 	ldrb.w	r3, [sp, #12]
   2396c:	b9f3      	cbnz	r3, 239ac <z_impl_k_poll+0x110>
		clear_event_registrations(events, events_registered, key);
   2396e:	4620      	mov	r0, r4
   23970:	463a      	mov	r2, r7
   23972:	4631      	mov	r1, r6
   23974:	f7ff fd8e 	bl	23494 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   23978:	4846      	ldr	r0, [pc, #280]	; (23a94 <z_impl_k_poll+0x1f8>)
   2397a:	f7ff f8b5 	bl	22ae8 <z_spin_unlock_valid>
   2397e:	b968      	cbnz	r0, 2399c <z_impl_k_poll+0x100>
   23980:	4a45      	ldr	r2, [pc, #276]	; (23a98 <z_impl_k_poll+0x1fc>)
   23982:	4948      	ldr	r1, [pc, #288]	; (23aa4 <z_impl_k_poll+0x208>)
   23984:	483d      	ldr	r0, [pc, #244]	; (23a7c <z_impl_k_poll+0x1e0>)
   23986:	235d      	movs	r3, #93	; 0x5d
   23988:	f000 faab 	bl	23ee2 <printk>
   2398c:	4941      	ldr	r1, [pc, #260]	; (23a94 <z_impl_k_poll+0x1f8>)
   2398e:	4846      	ldr	r0, [pc, #280]	; (23aa8 <z_impl_k_poll+0x20c>)
   23990:	f000 faa7 	bl	23ee2 <printk>
   23994:	4840      	ldr	r0, [pc, #256]	; (23a98 <z_impl_k_poll+0x1fc>)
   23996:	215d      	movs	r1, #93	; 0x5d
   23998:	f000 fae6 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   2399c:	f387 8811 	msr	BASEPRI, r7
   239a0:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		return 0;
   239a4:	2500      	movs	r5, #0
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
   239a6:	4628      	mov	r0, r5
   239a8:	b007      	add	sp, #28
   239aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	poller.is_polling = false;
   239ac:	2300      	movs	r3, #0
   239ae:	f88d 300c 	strb.w	r3, [sp, #12]
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   239b2:	b9c5      	cbnz	r5, 239e6 <z_impl_k_poll+0x14a>
   239b4:	4837      	ldr	r0, [pc, #220]	; (23a94 <z_impl_k_poll+0x1f8>)
   239b6:	f7ff f897 	bl	22ae8 <z_spin_unlock_valid>
   239ba:	b968      	cbnz	r0, 239d8 <z_impl_k_poll+0x13c>
   239bc:	4a36      	ldr	r2, [pc, #216]	; (23a98 <z_impl_k_poll+0x1fc>)
   239be:	4939      	ldr	r1, [pc, #228]	; (23aa4 <z_impl_k_poll+0x208>)
   239c0:	482e      	ldr	r0, [pc, #184]	; (23a7c <z_impl_k_poll+0x1e0>)
   239c2:	235d      	movs	r3, #93	; 0x5d
   239c4:	f000 fa8d 	bl	23ee2 <printk>
   239c8:	4932      	ldr	r1, [pc, #200]	; (23a94 <z_impl_k_poll+0x1f8>)
   239ca:	4837      	ldr	r0, [pc, #220]	; (23aa8 <z_impl_k_poll+0x20c>)
   239cc:	f000 fa89 	bl	23ee2 <printk>
   239d0:	4831      	ldr	r0, [pc, #196]	; (23a98 <z_impl_k_poll+0x1fc>)
   239d2:	215d      	movs	r1, #93	; 0x5d
   239d4:	f000 fac8 	bl	23f68 <assert_post_action>
   239d8:	f387 8811 	msr	BASEPRI, r7
   239dc:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   239e0:	f06f 050a 	mvn.w	r5, #10
   239e4:	e7df      	b.n	239a6 <z_impl_k_poll+0x10a>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   239e6:	aa01      	add	r2, sp, #4
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   239e8:	462b      	mov	r3, r5
   239ea:	4639      	mov	r1, r7
   239ec:	4829      	ldr	r0, [pc, #164]	; (23a94 <z_impl_k_poll+0x1f8>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   239ee:	e9cd 2201 	strd	r2, r2, [sp, #4]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   239f2:	f7fe fb77 	bl	220e4 <z_pend_curr>
   239f6:	4605      	mov	r5, r0
	__asm__ volatile(
   239f8:	f04f 0320 	mov.w	r3, #32
   239fc:	f3ef 8711 	mrs	r7, BASEPRI
   23a00:	f383 8811 	msr	BASEPRI, r3
   23a04:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   23a08:	4822      	ldr	r0, [pc, #136]	; (23a94 <z_impl_k_poll+0x1f8>)
   23a0a:	f7ff f85f 	bl	22acc <z_spin_lock_valid>
   23a0e:	b968      	cbnz	r0, 23a2c <z_impl_k_poll+0x190>
   23a10:	4a21      	ldr	r2, [pc, #132]	; (23a98 <z_impl_k_poll+0x1fc>)
   23a12:	4922      	ldr	r1, [pc, #136]	; (23a9c <z_impl_k_poll+0x200>)
   23a14:	4819      	ldr	r0, [pc, #100]	; (23a7c <z_impl_k_poll+0x1e0>)
   23a16:	234a      	movs	r3, #74	; 0x4a
   23a18:	f000 fa63 	bl	23ee2 <printk>
   23a1c:	491d      	ldr	r1, [pc, #116]	; (23a94 <z_impl_k_poll+0x1f8>)
   23a1e:	4820      	ldr	r0, [pc, #128]	; (23aa0 <z_impl_k_poll+0x204>)
   23a20:	f000 fa5f 	bl	23ee2 <printk>
   23a24:	481c      	ldr	r0, [pc, #112]	; (23a98 <z_impl_k_poll+0x1fc>)
   23a26:	214a      	movs	r1, #74	; 0x4a
   23a28:	f000 fa9e 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   23a2c:	4819      	ldr	r0, [pc, #100]	; (23a94 <z_impl_k_poll+0x1f8>)
   23a2e:	f7ff f86b 	bl	22b08 <z_spin_lock_set_owner>
	clear_event_registrations(events, events_registered, key);
   23a32:	4620      	mov	r0, r4
   23a34:	463a      	mov	r2, r7
   23a36:	4631      	mov	r1, r6
   23a38:	f7ff fd2c 	bl	23494 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   23a3c:	4815      	ldr	r0, [pc, #84]	; (23a94 <z_impl_k_poll+0x1f8>)
   23a3e:	f7ff f853 	bl	22ae8 <z_spin_unlock_valid>
   23a42:	b968      	cbnz	r0, 23a60 <z_impl_k_poll+0x1c4>
   23a44:	4a14      	ldr	r2, [pc, #80]	; (23a98 <z_impl_k_poll+0x1fc>)
   23a46:	4917      	ldr	r1, [pc, #92]	; (23aa4 <z_impl_k_poll+0x208>)
   23a48:	480c      	ldr	r0, [pc, #48]	; (23a7c <z_impl_k_poll+0x1e0>)
   23a4a:	235d      	movs	r3, #93	; 0x5d
   23a4c:	f000 fa49 	bl	23ee2 <printk>
   23a50:	4910      	ldr	r1, [pc, #64]	; (23a94 <z_impl_k_poll+0x1f8>)
   23a52:	4815      	ldr	r0, [pc, #84]	; (23aa8 <z_impl_k_poll+0x20c>)
   23a54:	f000 fa45 	bl	23ee2 <printk>
   23a58:	480f      	ldr	r0, [pc, #60]	; (23a98 <z_impl_k_poll+0x1fc>)
   23a5a:	215d      	movs	r1, #93	; 0x5d
   23a5c:	f000 fa84 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   23a60:	f387 8811 	msr	BASEPRI, r7
   23a64:	f3bf 8f6f 	isb	sy
	return swap_rc;
   23a68:	e79d      	b.n	239a6 <z_impl_k_poll+0x10a>
   23a6a:	bf00      	nop
   23a6c:	20001d80 	.word	0x20001d80
   23a70:	00023421 	.word	0x00023421
   23a74:	000312cc 	.word	0x000312cc
   23a78:	0003159a 	.word	0x0003159a
   23a7c:	0002a5e8 	.word	0x0002a5e8
   23a80:	00030d23 	.word	0x00030d23
   23a84:	0003175a 	.word	0x0003175a
   23a88:	00031770 	.word	0x00031770
   23a8c:	0003177f 	.word	0x0003177f
   23a90:	0003178f 	.word	0x0003178f
   23a94:	20001e78 	.word	0x20001e78
   23a98:	0002ae90 	.word	0x0002ae90
   23a9c:	0002aeb2 	.word	0x0002aeb2
   23aa0:	0002aec7 	.word	0x0002aec7
   23aa4:	0002aedf 	.word	0x0002aedf
   23aa8:	0002aef6 	.word	0x0002aef6

00023aac <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
   23aac:	b570      	push	{r4, r5, r6, lr}
   23aae:	4604      	mov	r4, r0
   23ab0:	460d      	mov	r5, r1
	__asm__ volatile(
   23ab2:	f04f 0320 	mov.w	r3, #32
   23ab6:	f3ef 8611 	mrs	r6, BASEPRI
   23aba:	f383 8811 	msr	BASEPRI, r3
   23abe:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   23ac2:	4821      	ldr	r0, [pc, #132]	; (23b48 <z_impl_k_poll_signal_raise+0x9c>)
   23ac4:	f7ff f802 	bl	22acc <z_spin_lock_valid>
   23ac8:	b968      	cbnz	r0, 23ae6 <z_impl_k_poll_signal_raise+0x3a>
   23aca:	4a20      	ldr	r2, [pc, #128]	; (23b4c <z_impl_k_poll_signal_raise+0xa0>)
   23acc:	4920      	ldr	r1, [pc, #128]	; (23b50 <z_impl_k_poll_signal_raise+0xa4>)
   23ace:	4821      	ldr	r0, [pc, #132]	; (23b54 <z_impl_k_poll_signal_raise+0xa8>)
   23ad0:	234a      	movs	r3, #74	; 0x4a
   23ad2:	f000 fa06 	bl	23ee2 <printk>
   23ad6:	491c      	ldr	r1, [pc, #112]	; (23b48 <z_impl_k_poll_signal_raise+0x9c>)
   23ad8:	481f      	ldr	r0, [pc, #124]	; (23b58 <z_impl_k_poll_signal_raise+0xac>)
   23ada:	f000 fa02 	bl	23ee2 <printk>
   23ade:	481b      	ldr	r0, [pc, #108]	; (23b4c <z_impl_k_poll_signal_raise+0xa0>)
   23ae0:	214a      	movs	r1, #74	; 0x4a
   23ae2:	f000 fa41 	bl	23f68 <assert_post_action>
	z_spin_lock_set_owner(l);
   23ae6:	4818      	ldr	r0, [pc, #96]	; (23b48 <z_impl_k_poll_signal_raise+0x9c>)
   23ae8:	f7ff f80e 	bl	22b08 <z_spin_lock_set_owner>
	return list->head == list;
   23aec:	6820      	ldr	r0, [r4, #0]
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
   23aee:	60e5      	str	r5, [r4, #12]
	signal->signaled = 1U;
   23af0:	2101      	movs	r1, #1

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   23af2:	4284      	cmp	r4, r0
   23af4:	60a1      	str	r1, [r4, #8]
   23af6:	d117      	bne.n	23b28 <z_impl_k_poll_signal_raise+0x7c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   23af8:	4813      	ldr	r0, [pc, #76]	; (23b48 <z_impl_k_poll_signal_raise+0x9c>)
   23afa:	f7fe fff5 	bl	22ae8 <z_spin_unlock_valid>
   23afe:	b968      	cbnz	r0, 23b1c <z_impl_k_poll_signal_raise+0x70>
   23b00:	4a12      	ldr	r2, [pc, #72]	; (23b4c <z_impl_k_poll_signal_raise+0xa0>)
   23b02:	4916      	ldr	r1, [pc, #88]	; (23b5c <z_impl_k_poll_signal_raise+0xb0>)
   23b04:	4813      	ldr	r0, [pc, #76]	; (23b54 <z_impl_k_poll_signal_raise+0xa8>)
   23b06:	235d      	movs	r3, #93	; 0x5d
   23b08:	f000 f9eb 	bl	23ee2 <printk>
   23b0c:	490e      	ldr	r1, [pc, #56]	; (23b48 <z_impl_k_poll_signal_raise+0x9c>)
   23b0e:	4814      	ldr	r0, [pc, #80]	; (23b60 <z_impl_k_poll_signal_raise+0xb4>)
   23b10:	f000 f9e7 	bl	23ee2 <printk>
   23b14:	480d      	ldr	r0, [pc, #52]	; (23b4c <z_impl_k_poll_signal_raise+0xa0>)
   23b16:	215d      	movs	r1, #93	; 0x5d
   23b18:	f000 fa26 	bl	23f68 <assert_post_action>
	__asm__ volatile(
   23b1c:	f386 8811 	msr	BASEPRI, r6
   23b20:	f3bf 8f6f 	isb	sy

	poll_event = (struct k_poll_event *)sys_dlist_get(&signal->poll_events);
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
   23b24:	2400      	movs	r4, #0
   23b26:	e00d      	b.n	23b44 <z_impl_k_poll_signal_raise+0x98>
	node->prev->next = node->next;
   23b28:	e9d0 3200 	ldrd	r3, r2, [r0]
   23b2c:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   23b2e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   23b30:	2300      	movs	r3, #0
	node->prev = NULL;
   23b32:	e9c0 3300 	strd	r3, r3, [r0]
	}

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   23b36:	f005 fcc3 	bl	294c0 <signal_poll_event>

	z_reschedule(&lock, key);
   23b3a:	4631      	mov	r1, r6
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   23b3c:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
   23b3e:	4802      	ldr	r0, [pc, #8]	; (23b48 <z_impl_k_poll_signal_raise+0x9c>)
   23b40:	f7fd fc80 	bl	21444 <z_reschedule>
	return rc;
}
   23b44:	4620      	mov	r0, r4
   23b46:	bd70      	pop	{r4, r5, r6, pc}
   23b48:	20001e78 	.word	0x20001e78
   23b4c:	0002ae90 	.word	0x0002ae90
   23b50:	0002aeb2 	.word	0x0002aeb2
   23b54:	0002a5e8 	.word	0x0002a5e8
   23b58:	0002aec7 	.word	0x0002aec7
   23b5c:	0002aedf 	.word	0x0002aedf
   23b60:	0002aef6 	.word	0x0002aef6

00023b64 <prov_reset>:
	bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT);
   23b64:	2003      	movs	r0, #3
   23b66:	f7f2 bcff 	b.w	16568 <bt_mesh_prov_enable>

00023b6a <u8_to_dec>:
 */

#include <sys/util.h>

u8_t u8_to_dec(char *buf, u8_t buflen, u8_t value)
{
   23b6a:	b5f0      	push	{r4, r5, r6, r7, lr}
			buflen--;
			num_digits++;
		}

		value -= digit * divisor;
		divisor /= 10;
   23b6c:	f04f 0c0a 	mov.w	ip, #10
{
   23b70:	4605      	mov	r5, r0
	while (buflen > 0 && divisor > 0) {
   23b72:	2604      	movs	r6, #4
	u8_t num_digits = 0;
   23b74:	2000      	movs	r0, #0
	u8_t divisor = 100;
   23b76:	2464      	movs	r4, #100	; 0x64
	while (buflen > 0 && divisor > 0) {
   23b78:	b111      	cbz	r1, 23b80 <u8_to_dec+0x16>
   23b7a:	3e01      	subs	r6, #1
   23b7c:	d101      	bne.n	23b82 <u8_to_dec+0x18>
	}

	if (buflen) {
		*buf = '\0';
   23b7e:	702e      	strb	r6, [r5, #0]
	}

	return num_digits;
}
   23b80:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (digit != 0 || divisor == 1 || num_digits != 0) {
   23b82:	42a2      	cmp	r2, r4
		digit = value / divisor;
   23b84:	fbb2 f7f4 	udiv	r7, r2, r4
   23b88:	b2fb      	uxtb	r3, r7
		if (digit != 0 || divisor == 1 || num_digits != 0) {
   23b8a:	d202      	bcs.n	23b92 <u8_to_dec+0x28>
   23b8c:	2c01      	cmp	r4, #1
   23b8e:	d000      	beq.n	23b92 <u8_to_dec+0x28>
   23b90:	b130      	cbz	r0, 23ba0 <u8_to_dec+0x36>
			*buf = (char)digit + '0';
   23b92:	3330      	adds	r3, #48	; 0x30
   23b94:	f805 3b01 	strb.w	r3, [r5], #1
			buflen--;
   23b98:	3901      	subs	r1, #1
			num_digits++;
   23b9a:	1c43      	adds	r3, r0, #1
			buflen--;
   23b9c:	b2c9      	uxtb	r1, r1
			num_digits++;
   23b9e:	b2d8      	uxtb	r0, r3
		value -= digit * divisor;
   23ba0:	fb04 2217 	mls	r2, r4, r7, r2
   23ba4:	b2d2      	uxtb	r2, r2
		divisor /= 10;
   23ba6:	fbb4 f4fc 	udiv	r4, r4, ip
   23baa:	e7e5      	b.n	23b78 <u8_to_dec+0xe>

00023bac <char2hex>:
#include <errno.h>
#include <sys/util.h>

int char2hex(char c, u8_t *x)
{
	if (c >= '0' && c <= '9') {
   23bac:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   23bb0:	b2db      	uxtb	r3, r3
   23bb2:	2b09      	cmp	r3, #9
   23bb4:	d802      	bhi.n	23bbc <char2hex+0x10>
		*x = c - '0';
   23bb6:	700b      	strb	r3, [r1, #0]
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
	}

	return 0;
   23bb8:	2000      	movs	r0, #0
   23bba:	4770      	bx	lr
	} else if (c >= 'a' && c <= 'f') {
   23bbc:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   23bc0:	2b05      	cmp	r3, #5
   23bc2:	d802      	bhi.n	23bca <char2hex+0x1e>
		*x = c - 'a' + 10;
   23bc4:	3857      	subs	r0, #87	; 0x57
   23bc6:	7008      	strb	r0, [r1, #0]
   23bc8:	e7f6      	b.n	23bb8 <char2hex+0xc>
	} else if (c >= 'A' && c <= 'F') {
   23bca:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   23bce:	2b05      	cmp	r3, #5
   23bd0:	d801      	bhi.n	23bd6 <char2hex+0x2a>
		*x = c - 'A' + 10;
   23bd2:	3837      	subs	r0, #55	; 0x37
   23bd4:	e7f7      	b.n	23bc6 <char2hex+0x1a>
		return -EINVAL;
   23bd6:	f06f 0015 	mvn.w	r0, #21
}
   23bda:	4770      	bx	lr

00023bdc <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, u8_t *buf, size_t buflen)
{
   23bdc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   23bde:	4604      	mov	r4, r0
	u8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
   23be0:	f001 0001 	and.w	r0, r1, #1
   23be4:	eb00 0551 	add.w	r5, r0, r1, lsr #1
   23be8:	429d      	cmp	r5, r3
   23bea:	ea4f 0651 	mov.w	r6, r1, lsr #1
   23bee:	d903      	bls.n	23bf8 <hex2bin+0x1c>
		return 0;
   23bf0:	2500      	movs	r5, #0
		}
		buf[i] += dec;
	}

	return hexlen / 2 + hexlen % 2;
}
   23bf2:	4628      	mov	r0, r5
   23bf4:	b003      	add	sp, #12
   23bf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (hexlen % 2) {
   23bf8:	b158      	cbz	r0, 23c12 <hex2bin+0x36>
		if (char2hex(hex[0], &dec) < 0) {
   23bfa:	7820      	ldrb	r0, [r4, #0]
   23bfc:	f10d 0107 	add.w	r1, sp, #7
   23c00:	f7ff ffd4 	bl	23bac <char2hex>
   23c04:	2800      	cmp	r0, #0
   23c06:	dbf3      	blt.n	23bf0 <hex2bin+0x14>
		buf[0] = dec;
   23c08:	f89d 3007 	ldrb.w	r3, [sp, #7]
   23c0c:	f802 3b01 	strb.w	r3, [r2], #1
		hex++;
   23c10:	3401      	adds	r4, #1
	for (size_t i = 0; i < hexlen / 2; i++) {
   23c12:	3401      	adds	r4, #1
   23c14:	4416      	add	r6, r2
   23c16:	42b2      	cmp	r2, r6
   23c18:	d0eb      	beq.n	23bf2 <hex2bin+0x16>
		if (char2hex(hex[2 * i], &dec) < 0) {
   23c1a:	f814 0c01 	ldrb.w	r0, [r4, #-1]
   23c1e:	f10d 0107 	add.w	r1, sp, #7
   23c22:	f7ff ffc3 	bl	23bac <char2hex>
   23c26:	2800      	cmp	r0, #0
   23c28:	dbe2      	blt.n	23bf0 <hex2bin+0x14>
		buf[i] = dec << 4;
   23c2a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   23c2e:	011b      	lsls	r3, r3, #4
   23c30:	7013      	strb	r3, [r2, #0]
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
   23c32:	f814 0b02 	ldrb.w	r0, [r4], #2
   23c36:	f10d 0107 	add.w	r1, sp, #7
   23c3a:	f7ff ffb7 	bl	23bac <char2hex>
   23c3e:	2800      	cmp	r0, #0
   23c40:	dbd6      	blt.n	23bf0 <hex2bin+0x14>
		buf[i] += dec;
   23c42:	7813      	ldrb	r3, [r2, #0]
   23c44:	f89d 1007 	ldrb.w	r1, [sp, #7]
   23c48:	440b      	add	r3, r1
   23c4a:	f802 3b01 	strb.w	r3, [r2], #1
	for (size_t i = 0; i < hexlen / 2; i++) {
   23c4e:	e7e2      	b.n	23c16 <hex2bin+0x3a>

00023c50 <get_bit_ptr>:
{
   23c50:	b570      	push	{r4, r5, r6, lr}
   23c52:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
   23c54:	f990 000b 	ldrsb.w	r0, [r0, #11]
   23c58:	240c      	movs	r4, #12
{
   23c5a:	460d      	mov	r5, r1
   23c5c:	434c      	muls	r4, r1
		p->levels[level].bits : p->levels[level].bits_p;
   23c5e:	42a8      	cmp	r0, r5
   23c60:	eb06 0104 	add.w	r1, r6, r4
   23c64:	bfb8      	it	lt
   23c66:	5931      	ldrlt	r1, [r6, r4]
	*word = &bitarray[bn / 32];
   23c68:	2a00      	cmp	r2, #0
   23c6a:	4610      	mov	r0, r2
   23c6c:	bfb8      	it	lt
   23c6e:	f102 001f 	addlt.w	r0, r2, #31
   23c72:	1140      	asrs	r0, r0, #5
   23c74:	eb01 0180 	add.w	r1, r1, r0, lsl #2
   23c78:	6019      	str	r1, [r3, #0]
}
   23c7a:	f002 001f 	and.w	r0, r2, #31
   23c7e:	bd70      	pop	{r4, r5, r6, pc}

00023c80 <pool_irq_lock.isra.0.part.0>:
	__asm__ volatile(
   23c80:	f04f 0320 	mov.w	r3, #32
   23c84:	f3ef 8011 	mrs	r0, BASEPRI
   23c88:	f383 8811 	msr	BASEPRI, r3
   23c8c:	f3bf 8f6f 	isb	sy
}
   23c90:	4770      	bx	lr

00023c92 <pool_irq_unlock.isra.0>:
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   23c92:	07c3      	lsls	r3, r0, #31
   23c94:	d503      	bpl.n	23c9e <pool_irq_unlock.isra.0+0xc>
	__asm__ volatile(
   23c96:	f381 8811 	msr	BASEPRI, r1
   23c9a:	f3bf 8f6f 	isb	sy
}
   23c9e:	4770      	bx	lr

00023ca0 <z_sys_mem_pool_base_init>:
{
   23ca0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   23ca4:	6846      	ldr	r6, [r0, #4]
   23ca6:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   23ca8:	6801      	ldr	r1, [r0, #0]
	for (i = 0; i < p->n_levels; i++) {
   23caa:	f890 800a 	ldrb.w	r8, [r0, #10]
	p->max_inline_level = -1;
   23cae:	23ff      	movs	r3, #255	; 0xff
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   23cb0:	fb06 fc07 	mul.w	ip, r6, r7
	p->max_inline_level = -1;
   23cb4:	72c3      	strb	r3, [r0, #11]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   23cb6:	4461      	add	r1, ip
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   23cb8:	4632      	mov	r2, r6
	for (i = 0; i < p->n_levels; i++) {
   23cba:	2300      	movs	r3, #0
		sys_dlist_init(&p->levels[i].free_list);
   23cbc:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < p->n_levels; i++) {
   23cc0:	4598      	cmp	r8, r3
   23cc2:	dc05      	bgt.n	23cd0 <z_sys_mem_pool_base_init+0x30>
   23cc4:	2300      	movs	r3, #0
	for (i = 0; i < p->n_max; i++) {
   23cc6:	4619      	mov	r1, r3
   23cc8:	428f      	cmp	r7, r1
   23cca:	dc20      	bgt.n	23d0e <z_sys_mem_pool_base_init+0x6e>
}
   23ccc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sys_dlist_init(&p->levels[i].free_list);
   23cd0:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		int nblocks = buflen / sz;
   23cd4:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
   23cd8:	fb09 fe03 	mul.w	lr, r9, r3
   23cdc:	eb0a 040e 	add.w	r4, sl, lr
   23ce0:	f104 0b04 	add.w	fp, r4, #4
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   23ce4:	2d20      	cmp	r5, #32
	list->tail = (sys_dnode_t *)list;
   23ce6:	e9c4 bb01 	strd	fp, fp, [r4, #4]
   23cea:	d805      	bhi.n	23cf8 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
   23cec:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
   23cee:	0892      	lsrs	r2, r2, #2
   23cf0:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
   23cf4:	3301      	adds	r3, #1
   23cf6:	e7e3      	b.n	23cc0 <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
   23cf8:	f115 041f 	adds.w	r4, r5, #31
   23cfc:	bf48      	it	mi
   23cfe:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
   23d02:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
   23d04:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
   23d08:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   23d0c:	e7ef      	b.n	23cee <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
   23d0e:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
   23d10:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
   23d12:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
   23d16:	18ec      	adds	r4, r5, r3
	node->next = list;
   23d18:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
   23d1c:	6895      	ldr	r5, [r2, #8]
   23d1e:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
   23d20:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
   23d22:	3101      	adds	r1, #1
   23d24:	602c      	str	r4, [r5, #0]
	list->tail = node;
   23d26:	4433      	add	r3, r6
   23d28:	6094      	str	r4, [r2, #8]
   23d2a:	e7cd      	b.n	23cc8 <z_sys_mem_pool_base_init+0x28>

00023d2c <z_sys_mem_pool_block_alloc>:
{
   23d2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23d30:	b087      	sub	sp, #28
   23d32:	af00      	add	r7, sp, #0
   23d34:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   23d38:	7a82      	ldrb	r2, [r0, #10]
   23d3a:	0093      	lsls	r3, r2, #2
   23d3c:	3307      	adds	r3, #7
   23d3e:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   23d42:	ebad 0d03 	sub.w	sp, sp, r3
   23d46:	46ea      	mov	sl, sp
	lsizes[0] = p->max_sz;
   23d48:	4653      	mov	r3, sl
{
   23d4a:	4605      	mov	r5, r0
	lsizes[0] = p->max_sz;
   23d4c:	6840      	ldr	r0, [r0, #4]
   23d4e:	f843 0904 	str.w	r0, [r3], #-4
	for (i = 0; i < p->n_levels; i++) {
   23d52:	2400      	movs	r4, #0
   23d54:	42a2      	cmp	r2, r4
   23d56:	f104 39ff 	add.w	r9, r4, #4294967295	; 0xffffffff
   23d5a:	dd09      	ble.n	23d70 <z_sys_mem_pool_block_alloc+0x44>
		if (i > 0) {
   23d5c:	b124      	cbz	r4, 23d68 <z_sys_mem_pool_block_alloc+0x3c>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
   23d5e:	6818      	ldr	r0, [r3, #0]
   23d60:	0880      	lsrs	r0, r0, #2
   23d62:	f020 0003 	bic.w	r0, r0, #3
   23d66:	6058      	str	r0, [r3, #4]
		if (lsizes[i] < size) {
   23d68:	f853 0f04 	ldr.w	r0, [r3, #4]!
   23d6c:	4288      	cmp	r0, r1
   23d6e:	d208      	bcs.n	23d82 <z_sys_mem_pool_block_alloc+0x56>
	if (alloc_l < 0) {
   23d70:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   23d74:	d107      	bne.n	23d86 <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
   23d76:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   23d78:	2300      	movs	r3, #0
   23d7a:	6013      	str	r3, [r2, #0]
		return -ENOMEM;
   23d7c:	f06f 000b 	mvn.w	r0, #11
   23d80:	e02e      	b.n	23de0 <z_sys_mem_pool_block_alloc+0xb4>
	for (i = 0; i < p->n_levels; i++) {
   23d82:	3401      	adds	r4, #1
   23d84:	e7e6      	b.n	23d54 <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   23d86:	7c2e      	ldrb	r6, [r5, #16]
   23d88:	f016 0601 	ands.w	r6, r6, #1
   23d8c:	d002      	beq.n	23d94 <z_sys_mem_pool_block_alloc+0x68>
   23d8e:	f7ff ff77 	bl	23c80 <pool_irq_lock.isra.0.part.0>
   23d92:	4606      	mov	r6, r0
	for (i = alloc_l; i >= 0; i--) {
   23d94:	68ea      	ldr	r2, [r5, #12]
   23d96:	230c      	movs	r3, #12
   23d98:	fb03 2309 	mla	r3, r3, r9, r2
	block = sys_dlist_get(&p->levels[l].free_list);
   23d9c:	46c8      	mov	r8, r9
	return list->head == list;
   23d9e:	461a      	mov	r2, r3
   23da0:	f852 4f04 	ldr.w	r4, [r2, #4]!
	if (!sys_dlist_is_empty(list)) {
   23da4:	4294      	cmp	r4, r2
   23da6:	d11f      	bne.n	23de8 <z_sys_mem_pool_block_alloc+0xbc>
	for (i = alloc_l; i >= 0; i--) {
   23da8:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   23dac:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   23db0:	f1a3 030c 	sub.w	r3, r3, #12
   23db4:	d1f3      	bne.n	23d9e <z_sys_mem_pool_block_alloc+0x72>
   23db6:	2400      	movs	r4, #0
	pool_irq_unlock(p, key);
   23db8:	7c28      	ldrb	r0, [r5, #16]
   23dba:	4631      	mov	r1, r6
   23dbc:	f7ff ff69 	bl	23c92 <pool_irq_unlock.isra.0>
	*data_p = data;
   23dc0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   23dc2:	601c      	str	r4, [r3, #0]
	if (data == NULL) {
   23dc4:	2c00      	cmp	r4, #0
   23dc6:	d0d9      	beq.n	23d7c <z_sys_mem_pool_block_alloc+0x50>
	*level_p = alloc_l;
   23dc8:	68bb      	ldr	r3, [r7, #8]
   23dca:	f8c3 9000 	str.w	r9, [r3]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   23dce:	682b      	ldr	r3, [r5, #0]
   23dd0:	1ae4      	subs	r4, r4, r3
   23dd2:	f85a 3029 	ldr.w	r3, [sl, r9, lsl #2]
   23dd6:	fb94 f4f3 	sdiv	r4, r4, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
   23dda:	687b      	ldr	r3, [r7, #4]
	return 0;
   23ddc:	2000      	movs	r0, #0
	*block_p = block_num(p, data, lsizes[alloc_l]);
   23dde:	601c      	str	r4, [r3, #0]
}
   23de0:	371c      	adds	r7, #28
   23de2:	46bd      	mov	sp, r7
   23de4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	node->prev->next = node->next;
   23de8:	e9d4 3200 	ldrd	r3, r2, [r4]
   23dec:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   23dee:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   23df0:	2300      	movs	r3, #0
	node->prev = NULL;
   23df2:	e9c4 3300 	strd	r3, r3, [r4]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   23df6:	6829      	ldr	r1, [r5, #0]
		data = block_alloc(p, i, lsizes[i]);
   23df8:	f85a 0028 	ldr.w	r0, [sl, r8, lsl #2]
	int bit = get_bit_ptr(p, level, bn, &word);
   23dfc:	f107 0314 	add.w	r3, r7, #20
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   23e00:	1a62      	subs	r2, r4, r1
	int bit = get_bit_ptr(p, level, bn, &word);
   23e02:	4641      	mov	r1, r8
   23e04:	fb92 f2f0 	sdiv	r2, r2, r0
   23e08:	4628      	mov	r0, r5
   23e0a:	f7ff ff21 	bl	23c50 <get_bit_ptr>
	*word |= (1<<bit);
   23e0e:	f8d7 c014 	ldr.w	ip, [r7, #20]
   23e12:	2101      	movs	r1, #1
   23e14:	f8dc 2000 	ldr.w	r2, [ip]
   23e18:	6039      	str	r1, [r7, #0]
   23e1a:	fa01 f000 	lsl.w	r0, r1, r0
   23e1e:	4302      	orrs	r2, r0
   23e20:	f8cc 2000 	str.w	r2, [ip]
	int bit = get_bit_ptr(p, level, bn, &word);
   23e24:	469b      	mov	fp, r3
			for (from_l = i; from_l < alloc_l; from_l++) {
   23e26:	45c8      	cmp	r8, r9
   23e28:	dac6      	bge.n	23db8 <z_sys_mem_pool_block_alloc+0x8c>
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   23e2a:	682a      	ldr	r2, [r5, #0]
   23e2c:	f85a 3028 	ldr.w	r3, [sl, r8, lsl #2]
	set_alloc_bit(p, l + 1, 4*bn);
   23e30:	f108 0801 	add.w	r8, r8, #1
	int bit = get_bit_ptr(p, level, bn, &word);
   23e34:	4641      	mov	r1, r8
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   23e36:	1aa2      	subs	r2, r4, r2
	int bit = get_bit_ptr(p, level, bn, &word);
   23e38:	4628      	mov	r0, r5
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   23e3a:	fb92 f2f3 	sdiv	r2, r2, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   23e3e:	465b      	mov	r3, fp
   23e40:	0092      	lsls	r2, r2, #2
   23e42:	f7ff ff05 	bl	23c50 <get_bit_ptr>
	*word |= (1<<bit);
   23e46:	697a      	ldr	r2, [r7, #20]
   23e48:	683b      	ldr	r3, [r7, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   23e4a:	68e9      	ldr	r1, [r5, #12]
	*word |= (1<<bit);
   23e4c:	fa03 f000 	lsl.w	r0, r3, r0
   23e50:	6813      	ldr	r3, [r2, #0]
   23e52:	4303      	orrs	r3, r0
   23e54:	6013      	str	r3, [r2, #0]
		int lsz = lsizes[l + 1];
   23e56:	f85a 0028 	ldr.w	r0, [sl, r8, lsl #2]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   23e5a:	230c      	movs	r3, #12
   23e5c:	fb03 1108 	mla	r1, r3, r8, r1
   23e60:	2203      	movs	r2, #3
   23e62:	f101 0e04 	add.w	lr, r1, #4
   23e66:	1823      	adds	r3, r4, r0
   23e68:	60fa      	str	r2, [r7, #12]
	node->prev = list->tail;
   23e6a:	688a      	ldr	r2, [r1, #8]
   23e6c:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   23e6e:	688a      	ldr	r2, [r1, #8]
	node->next = list;
   23e70:	f8c3 e000 	str.w	lr, [r3]
	list->tail->next = node;
   23e74:	6013      	str	r3, [r2, #0]
	for (i = 1; i < 4; i++) {
   23e76:	68fa      	ldr	r2, [r7, #12]
	list->tail = node;
   23e78:	608b      	str	r3, [r1, #8]
   23e7a:	3a01      	subs	r2, #1
   23e7c:	4403      	add	r3, r0
   23e7e:	60fa      	str	r2, [r7, #12]
   23e80:	d1f3      	bne.n	23e6a <z_sys_mem_pool_block_alloc+0x13e>
				pool_irq_unlock(p, key);
   23e82:	7c28      	ldrb	r0, [r5, #16]
   23e84:	4631      	mov	r1, r6
   23e86:	f7ff ff04 	bl	23c92 <pool_irq_unlock.isra.0>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   23e8a:	7c2b      	ldrb	r3, [r5, #16]
   23e8c:	07db      	lsls	r3, r3, #31
   23e8e:	d503      	bpl.n	23e98 <z_sys_mem_pool_block_alloc+0x16c>
   23e90:	f7ff fef6 	bl	23c80 <pool_irq_lock.isra.0.part.0>
   23e94:	4606      	mov	r6, r0
   23e96:	e7c6      	b.n	23e26 <z_sys_mem_pool_block_alloc+0xfa>
		return 0;
   23e98:	68fe      	ldr	r6, [r7, #12]
			for (from_l = i; from_l < alloc_l; from_l++) {
   23e9a:	e7c4      	b.n	23e26 <z_sys_mem_pool_block_alloc+0xfa>

00023e9c <arch_printk_char_out>:
}
   23e9c:	2000      	movs	r0, #0
   23e9e:	4770      	bx	lr

00023ea0 <print_err>:
{
   23ea0:	b570      	push	{r4, r5, r6, lr}
   23ea2:	4604      	mov	r4, r0
   23ea4:	460d      	mov	r5, r1
	out('E', ctx);
   23ea6:	2045      	movs	r0, #69	; 0x45
   23ea8:	47a0      	blx	r4
	out('R', ctx);
   23eaa:	4629      	mov	r1, r5
   23eac:	2052      	movs	r0, #82	; 0x52
   23eae:	47a0      	blx	r4
	out('R', ctx);
   23eb0:	4629      	mov	r1, r5
   23eb2:	4623      	mov	r3, r4
   23eb4:	2052      	movs	r0, #82	; 0x52
}
   23eb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   23eba:	4718      	bx	r3

00023ebc <str_out>:
{
   23ebc:	b530      	push	{r4, r5, lr}
   23ebe:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   23ec0:	680c      	ldr	r4, [r1, #0]
   23ec2:	1c55      	adds	r5, r2, #1
   23ec4:	b114      	cbz	r4, 23ecc <str_out+0x10>
   23ec6:	684b      	ldr	r3, [r1, #4]
   23ec8:	4293      	cmp	r3, r2
   23eca:	dc01      	bgt.n	23ed0 <str_out+0x14>
		ctx->count++;
   23ecc:	608d      	str	r5, [r1, #8]
}
   23ece:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   23ed0:	3b01      	subs	r3, #1
   23ed2:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   23ed4:	bf08      	it	eq
   23ed6:	2200      	moveq	r2, #0
   23ed8:	608d      	str	r5, [r1, #8]
   23eda:	bf0c      	ite	eq
   23edc:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   23ede:	54a0      	strbne	r0, [r4, r2]
   23ee0:	e7f5      	b.n	23ece <str_out+0x12>

00023ee2 <printk>:
{
   23ee2:	b40f      	push	{r0, r1, r2, r3}
   23ee4:	b507      	push	{r0, r1, r2, lr}
   23ee6:	a904      	add	r1, sp, #16
   23ee8:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   23eec:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   23eee:	f7de fa1f 	bl	2330 <vprintk>
}
   23ef2:	b003      	add	sp, #12
   23ef4:	f85d eb04 	ldr.w	lr, [sp], #4
   23ef8:	b004      	add	sp, #16
   23efa:	4770      	bx	lr

00023efc <snprintk>:
{
   23efc:	b40c      	push	{r2, r3}
   23efe:	b507      	push	{r0, r1, r2, lr}
   23f00:	ab04      	add	r3, sp, #16
   23f02:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   23f06:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   23f08:	f7de fa20 	bl	234c <vsnprintk>
}
   23f0c:	b003      	add	sp, #12
   23f0e:	f85d eb04 	ldr.w	lr, [sp], #4
   23f12:	b002      	add	sp, #8
   23f14:	4770      	bx	lr

00023f16 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   23f16:	4604      	mov	r4, r0
   23f18:	b508      	push	{r3, lr}
   23f1a:	4608      	mov	r0, r1
   23f1c:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   23f1e:	461a      	mov	r2, r3
   23f20:	47a0      	blx	r4
	return z_impl_k_current_get();
   23f22:	f7fe fbbf 	bl	226a4 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   23f26:	f7e1 f925 	bl	5174 <z_impl_k_thread_abort>

00023f2a <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   23f2a:	b510      	push	{r4, lr}
   23f2c:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   23f2e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   23f32:	4620      	mov	r0, r4
   23f34:	f7fd f896 	bl	21064 <z_impl_k_queue_get>
   23f38:	4603      	mov	r3, r0
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   23f3a:	2800      	cmp	r0, #0
   23f3c:	d0f7      	beq.n	23f2e <z_work_q_main+0x4>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   23f3e:	3308      	adds	r3, #8
			continue;
		}

		handler = work->handler;
   23f40:	6842      	ldr	r2, [r0, #4]
   23f42:	f3bf 8f5b 	dmb	ish
   23f46:	e853 1f00 	ldrex	r1, [r3]
   23f4a:	f021 0c01 	bic.w	ip, r1, #1
   23f4e:	e843 ce00 	strex	lr, ip, [r3]
   23f52:	f1be 0f00 	cmp.w	lr, #0
   23f56:	d1f6      	bne.n	23f46 <z_work_q_main+0x1c>
   23f58:	f3bf 8f5b 	dmb	ish

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   23f5c:	07cb      	lsls	r3, r1, #31
   23f5e:	d500      	bpl.n	23f62 <z_work_q_main+0x38>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   23f60:	4790      	blx	r2
	z_impl_k_yield();
   23f62:	f7fe fa1f 	bl	223a4 <z_impl_k_yield>
}
   23f66:	e7e2      	b.n	23f2e <z_work_q_main+0x4>

00023f68 <assert_post_action>:
	if (_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
   23f68:	4040      	eors	r0, r0
   23f6a:	f380 8811 	msr	BASEPRI, r0
   23f6e:	f04f 0004 	mov.w	r0, #4
   23f72:	df02      	svc	2
}
   23f74:	4770      	bx	lr

00023f76 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   23f76:	4770      	bx	lr

00023f78 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   23f78:	2300      	movs	r3, #0
	list->head = NULL;
   23f7a:	e9c0 3300 	strd	r3, r3, [r0]
}
   23f7e:	4770      	bx	lr

00023f80 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   23f80:	6803      	ldr	r3, [r0, #0]
   23f82:	b923      	cbnz	r3, 23f8e <log_list_add_tail+0xe>
		list->head = msg;
   23f84:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   23f86:	2300      	movs	r3, #0
	list->tail = msg;
   23f88:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   23f8a:	600b      	str	r3, [r1, #0]
}
   23f8c:	4770      	bx	lr
		list->tail->next = msg;
   23f8e:	6843      	ldr	r3, [r0, #4]
   23f90:	6019      	str	r1, [r3, #0]
   23f92:	e7f8      	b.n	23f86 <log_list_add_tail+0x6>

00023f94 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   23f94:	6800      	ldr	r0, [r0, #0]
   23f96:	4770      	bx	lr

00023f98 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
   23f98:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
   23f9a:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
   23f9c:	b108      	cbz	r0, 23fa2 <log_list_head_get+0xa>
		list->head = list->head->next;
   23f9e:	6802      	ldr	r2, [r0, #0]
   23fa0:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
   23fa2:	4770      	bx	lr

00023fa4 <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   23fa4:	6843      	ldr	r3, [r0, #4]
}
   23fa6:	7958      	ldrb	r0, [r3, #5]
   23fa8:	4770      	bx	lr

00023faa <z_log_msg_std_alloc>:
{
   23faa:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   23fac:	f7de fd14 	bl	29d8 <log_msg_chunk_alloc>
	if (msg != NULL) {
   23fb0:	b118      	cbz	r0, 23fba <z_log_msg_std_alloc+0x10>
		msg->hdr.ref_cnt = 1;
   23fb2:	2301      	movs	r3, #1
   23fb4:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   23fb6:	2300      	movs	r3, #0
   23fb8:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
   23fba:	bd08      	pop	{r3, pc}

00023fbc <k_cycle_get_32_wrapper>:
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
   23fbc:	f7e0 b9fc 	b.w	43b8 <z_timer_cycle_get_32>

00023fc0 <dummy_timestamp>:
   23fc0:	2000      	movs	r0, #0
   23fc2:	4770      	bx	lr

00023fc4 <log_0>:
{
   23fc4:	b538      	push	{r3, r4, r5, lr}
   23fc6:	4605      	mov	r5, r0
   23fc8:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   23fca:	f7ff ffee 	bl	23faa <z_log_msg_std_alloc>

	if (msg != NULL) {
   23fce:	b128      	cbz	r0, 23fdc <log_0+0x18>
		msg->str = str;
   23fd0:	6105      	str	r5, [r0, #16]
		msg_finalize(msg, src_level);
   23fd2:	4621      	mov	r1, r4
}
   23fd4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   23fd8:	f7de bc04 	b.w	27e4 <msg_finalize>
}
   23fdc:	bd38      	pop	{r3, r4, r5, pc}

00023fde <log_1>:
{
   23fde:	b570      	push	{r4, r5, r6, lr}
   23fe0:	4606      	mov	r6, r0
   23fe2:	460d      	mov	r5, r1
   23fe4:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   23fe6:	f7ff ffe0 	bl	23faa <z_log_msg_std_alloc>

	if (msg != NULL) {
   23fea:	b158      	cbz	r0, 24004 <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
   23fec:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
   23fee:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   23ff0:	2101      	movs	r1, #1
   23ff2:	f361 1207 	bfi	r2, r1, #4, #4
   23ff6:	7242      	strb	r2, [r0, #9]
		msg->payload.single.args[0] = arg1;
   23ff8:	6145      	str	r5, [r0, #20]
		msg_finalize(msg, src_level);
   23ffa:	4621      	mov	r1, r4
}
   23ffc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   24000:	f7de bbf0 	b.w	27e4 <msg_finalize>
}
   24004:	bd70      	pop	{r4, r5, r6, pc}

00024006 <log_2>:
{
   24006:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2400a:	4680      	mov	r8, r0
   2400c:	460f      	mov	r7, r1
   2400e:	4616      	mov	r6, r2
   24010:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   24012:	f7ff ffca 	bl	23faa <z_log_msg_std_alloc>

	if (msg != NULL) {
   24016:	b168      	cbz	r0, 24034 <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
   24018:	7a43      	ldrb	r3, [r0, #9]
		msg->str = str;
   2401a:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->hdr.params.std.nargs = 2U;
   2401e:	2202      	movs	r2, #2
   24020:	f362 1307 	bfi	r3, r2, #4, #4
   24024:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   24026:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg_finalize(msg, src_level);
   2402a:	4629      	mov	r1, r5
}
   2402c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   24030:	f7de bbd8 	b.w	27e4 <msg_finalize>
}
   24034:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024038 <log_3>:
{
   24038:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2403c:	4680      	mov	r8, r0
   2403e:	f8bd 9020 	ldrh.w	r9, [sp, #32]
   24042:	460f      	mov	r7, r1
   24044:	4616      	mov	r6, r2
   24046:	461d      	mov	r5, r3
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   24048:	f7ff ffaf 	bl	23faa <z_log_msg_std_alloc>

	if (msg != NULL) {
   2404c:	b170      	cbz	r0, 2406c <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
   2404e:	7a43      	ldrb	r3, [r0, #9]
		msg->str = str;
   24050:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->hdr.params.std.nargs = 3U;
   24054:	2203      	movs	r2, #3
   24056:	f362 1307 	bfi	r3, r2, #4, #4
   2405a:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   2405c:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->payload.single.args[2] = arg3;
   24060:	61c5      	str	r5, [r0, #28]
		msg_finalize(msg, src_level);
   24062:	4649      	mov	r1, r9
}
   24064:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   24068:	f7de bbbc 	b.w	27e4 <msg_finalize>
}
   2406c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00024070 <log_n>:
{
   24070:	b510      	push	{r4, lr}
   24072:	461c      	mov	r4, r3
		struct log_msg *msg = log_msg_create_n(str, args, narg);
   24074:	f7de fd04 	bl	2a80 <log_msg_create_n>
		if (msg == NULL) {
   24078:	b120      	cbz	r0, 24084 <log_n+0x14>
		msg_finalize(msg, src_level);
   2407a:	4621      	mov	r1, r4
}
   2407c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		msg_finalize(msg, src_level);
   24080:	f7de bbb0 	b.w	27e4 <msg_finalize>
}
   24084:	bd10      	pop	{r4, pc}

00024086 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   24086:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2408a:	461c      	mov	r4, r3
	u32_t available_len = msg->hdr.params.hexdump.length;
   2408c:	8903      	ldrh	r3, [r0, #8]
{
   2408e:	f89d 8020 	ldrb.w	r8, [sp, #32]
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
   24092:	ebb4 0f93 	cmp.w	r4, r3, lsr #2
{
   24096:	460e      	mov	r6, r1
   24098:	4611      	mov	r1, r2
	u32_t available_len = msg->hdr.params.hexdump.length;
   2409a:	ea4f 0293 	mov.w	r2, r3, lsr #2
	if (offset >= available_len) {
   2409e:	d303      	bcc.n	240a8 <log_msg_hexdump_data_op+0x22>
		*length = 0;
   240a0:	2300      	movs	r3, #0
   240a2:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   240a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   240a8:	680b      	ldr	r3, [r1, #0]
   240aa:	4423      	add	r3, r4
   240ac:	4293      	cmp	r3, r2
		*length = available_len - offset;
   240ae:	bf84      	itt	hi
   240b0:	1b13      	subhi	r3, r2, r4
   240b2:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   240b4:	2a0c      	cmp	r2, #12
	req_len = *length;
   240b6:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   240ba:	d929      	bls.n	24110 <log_msg_hexdump_data_op+0x8a>
	if (offset < chunk_len) {
   240bc:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   240be:	6947      	ldr	r7, [r0, #20]
	if (offset < chunk_len) {
   240c0:	d82c      	bhi.n	2411c <log_msg_hexdump_data_op+0x96>
		head_data = msg->payload.ext.data.bytes;
   240c2:	3018      	adds	r0, #24
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   240c4:	2208      	movs	r2, #8
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   240c6:	454a      	cmp	r2, r9
   240c8:	bf28      	it	cs
   240ca:	464a      	movcs	r2, r9
   240cc:	4615      	mov	r5, r2
		if (put_op) {
   240ce:	4420      	add	r0, r4
   240d0:	f1b8 0f00 	cmp.w	r8, #0
   240d4:	d01f      	beq.n	24116 <log_msg_hexdump_data_op+0x90>
			(void)memcpy(&head_data[offset], data, cpy_len);
   240d6:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
   240d8:	f001 fde6 	bl	25ca8 <memcpy>
		req_len -= cpy_len;
   240dc:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   240e0:	442e      	add	r6, r5
	while (req_len > 0) {
   240e2:	f1b9 0f00 	cmp.w	r9, #0
   240e6:	d0dd      	beq.n	240a4 <log_msg_hexdump_data_op+0x1e>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   240e8:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   240ec:	454d      	cmp	r5, r9
   240ee:	bf28      	it	cs
   240f0:	464d      	movcs	r5, r9
		if (put_op) {
   240f2:	1d20      	adds	r0, r4, #4
   240f4:	4438      	add	r0, r7
			(void)memcpy(&cont->payload.bytes[offset],
   240f6:	462a      	mov	r2, r5
		if (put_op) {
   240f8:	f1b8 0f00 	cmp.w	r8, #0
   240fc:	d014      	beq.n	24128 <log_msg_hexdump_data_op+0xa2>
			(void)memcpy(&cont->payload.bytes[offset],
   240fe:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
   24100:	f001 fdd2 	bl	25ca8 <memcpy>
		req_len -= cpy_len;
   24104:	eba9 0905 	sub.w	r9, r9, r5
		cont = cont->next;
   24108:	683f      	ldr	r7, [r7, #0]
		data += cpy_len;
   2410a:	442e      	add	r6, r5
		offset = 0;
   2410c:	2400      	movs	r4, #0
   2410e:	e7e8      	b.n	240e2 <log_msg_hexdump_data_op+0x5c>
		head_data = msg->payload.single.bytes;
   24110:	3014      	adds	r0, #20
	struct log_msg_cont *cont = NULL;
   24112:	2700      	movs	r7, #0
   24114:	e7d7      	b.n	240c6 <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
   24116:	4601      	mov	r1, r0
   24118:	4630      	mov	r0, r6
   2411a:	e7dd      	b.n	240d8 <log_msg_hexdump_data_op+0x52>
		offset -= chunk_len;
   2411c:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   2411e:	2c1b      	cmp	r4, #27
   24120:	d9df      	bls.n	240e2 <log_msg_hexdump_data_op+0x5c>
			cont = cont->next;
   24122:	683f      	ldr	r7, [r7, #0]
			offset -= chunk_len;
   24124:	3c1c      	subs	r4, #28
   24126:	e7fa      	b.n	2411e <log_msg_hexdump_data_op+0x98>
			(void)memcpy(data, &cont->payload.bytes[offset],
   24128:	4601      	mov	r1, r0
   2412a:	4630      	mov	r0, r6
   2412c:	e7e8      	b.n	24100 <log_msg_hexdump_data_op+0x7a>

0002412e <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   2412e:	3004      	adds	r0, #4
   24130:	f3bf 8f5b 	dmb	ish
   24134:	e850 3f00 	ldrex	r3, [r0]
   24138:	3301      	adds	r3, #1
   2413a:	e840 3200 	strex	r2, r3, [r0]
   2413e:	2a00      	cmp	r2, #0
   24140:	d1f8      	bne.n	24134 <log_msg_get+0x6>
   24142:	f3bf 8f5b 	dmb	ish
}
   24146:	4770      	bx	lr

00024148 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   24148:	7a40      	ldrb	r0, [r0, #9]
}
   2414a:	0900      	lsrs	r0, r0, #4
   2414c:	4770      	bx	lr

0002414e <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   2414e:	7a43      	ldrb	r3, [r0, #9]
   24150:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
   24154:	ea4f 1213 	mov.w	r2, r3, lsr #4
   24158:	d216      	bcs.n	24188 <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   2415a:	2a03      	cmp	r2, #3
   2415c:	d803      	bhi.n	24166 <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
   2415e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   24162:	6948      	ldr	r0, [r1, #20]
   24164:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   24166:	2901      	cmp	r1, #1
   24168:	d803      	bhi.n	24172 <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
   2416a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   2416e:	6988      	ldr	r0, [r1, #24]
   24170:	4770      	bx	lr
	cont = msg->payload.ext.next;
   24172:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   24174:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   24176:	2906      	cmp	r1, #6
   24178:	d803      	bhi.n	24182 <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
   2417a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   2417e:	6848      	ldr	r0, [r1, #4]
   24180:	4770      	bx	lr
		cont = cont->next;
   24182:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
   24184:	3907      	subs	r1, #7
		cont = cont->next;
   24186:	e7f6      	b.n	24176 <log_msg_arg_get+0x28>
		return 0;
   24188:	2000      	movs	r0, #0
}
   2418a:	4770      	bx	lr

0002418c <log_msg_put>:
{
   2418c:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   2418e:	1d02      	adds	r2, r0, #4
   24190:	f3bf 8f5b 	dmb	ish
   24194:	e852 1f00 	ldrex	r1, [r2]
   24198:	3901      	subs	r1, #1
   2419a:	e842 1c00 	strex	ip, r1, [r2]
   2419e:	f1bc 0f00 	cmp.w	ip, #0
   241a2:	d1f7      	bne.n	24194 <log_msg_put+0x8>
   241a4:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
   241a8:	685b      	ldr	r3, [r3, #4]
   241aa:	b90b      	cbnz	r3, 241b0 <log_msg_put+0x24>
		msg_free(msg);
   241ac:	f7de bc26 	b.w	29fc <msg_free>
}
   241b0:	4770      	bx	lr

000241b2 <log_msg_str_get>:
}
   241b2:	6900      	ldr	r0, [r0, #16]
   241b4:	4770      	bx	lr

000241b6 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
   241b6:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   241b8:	2400      	movs	r4, #0
   241ba:	9400      	str	r4, [sp, #0]
   241bc:	f7ff ff63 	bl	24086 <log_msg_hexdump_data_op>
}
   241c0:	b002      	add	sp, #8
   241c2:	bd10      	pop	{r4, pc}

000241c4 <buffer_write>:
{
   241c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   241c6:	4606      	mov	r6, r0
   241c8:	460d      	mov	r5, r1
   241ca:	4614      	mov	r4, r2
   241cc:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   241ce:	4621      	mov	r1, r4
   241d0:	4628      	mov	r0, r5
   241d2:	463a      	mov	r2, r7
   241d4:	47b0      	blx	r6
	} while (len != 0);
   241d6:	1a24      	subs	r4, r4, r0
		buf += processed;
   241d8:	4405      	add	r5, r0
	} while (len != 0);
   241da:	d1f8      	bne.n	241ce <buffer_write+0xa>
}
   241dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000241de <std_print>:
{
   241de:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   241e2:	b08e      	sub	sp, #56	; 0x38
   241e4:	af0e      	add	r7, sp, #56	; 0x38
   241e6:	4680      	mov	r8, r0
   241e8:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   241ea:	f7ff ffe2 	bl	241b2 <log_msg_str_get>
   241ee:	4606      	mov	r6, r0
	u32_t nargs = log_msg_nargs_get(msg);
   241f0:	4640      	mov	r0, r8
   241f2:	f7ff ffa9 	bl	24148 <log_msg_nargs_get>
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   241f6:	0083      	lsls	r3, r0, #2
   241f8:	3307      	adds	r3, #7
   241fa:	f023 0307 	bic.w	r3, r3, #7
   241fe:	ebad 0d03 	sub.w	sp, sp, r3
	u32_t nargs = log_msg_nargs_get(msg);
   24202:	4682      	mov	sl, r0
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   24204:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   24206:	f04f 0900 	mov.w	r9, #0
   2420a:	45d1      	cmp	r9, sl
   2420c:	d116      	bne.n	2423c <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   2420e:	4640      	mov	r0, r8
   24210:	f7ff ff9a 	bl	24148 <log_msg_nargs_get>
   24214:	280f      	cmp	r0, #15
   24216:	d81e      	bhi.n	24256 <std_print+0x78>
   24218:	e8df f010 	tbh	[pc, r0, lsl #1]
   2421c:	00200019 	.word	0x00200019
   24220:	002d0026 	.word	0x002d0026
   24224:	00410036 	.word	0x00410036
   24228:	005d004e 	.word	0x005d004e
   2422c:	0081006e 	.word	0x0081006e
   24230:	00ad0096 	.word	0x00ad0096
   24234:	00e100c6 	.word	0x00e100c6
   24238:	011d00fe 	.word	0x011d00fe
		args[i] = log_msg_arg_get(msg, i);
   2423c:	4649      	mov	r1, r9
   2423e:	4640      	mov	r0, r8
   24240:	f7ff ff85 	bl	2414e <log_msg_arg_get>
   24244:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
   24248:	f109 0901 	add.w	r9, r9, #1
   2424c:	e7dd      	b.n	2420a <std_print+0x2c>
		print_formatted(log_output, str);
   2424e:	4631      	mov	r1, r6
   24250:	4628      	mov	r0, r5
   24252:	f7de fc7d 	bl	2b50 <print_formatted>
}
   24256:	46bd      	mov	sp, r7
   24258:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, str, args[0]);
   2425c:	6822      	ldr	r2, [r4, #0]
   2425e:	4631      	mov	r1, r6
   24260:	4628      	mov	r0, r5
   24262:	f7de fc75 	bl	2b50 <print_formatted>
		break;
   24266:	e7f6      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1]);
   24268:	e9d4 2300 	ldrd	r2, r3, [r4]
   2426c:	4631      	mov	r1, r6
   2426e:	4628      	mov	r0, r5
   24270:	f7de fc6e 	bl	2b50 <print_formatted>
		break;
   24274:	e7ef      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2]);
   24276:	68a3      	ldr	r3, [r4, #8]
   24278:	9300      	str	r3, [sp, #0]
   2427a:	e9d4 2300 	ldrd	r2, r3, [r4]
   2427e:	4631      	mov	r1, r6
   24280:	4628      	mov	r0, r5
   24282:	f7de fc65 	bl	2b50 <print_formatted>
		break;
   24286:	e7e6      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   24288:	68e3      	ldr	r3, [r4, #12]
   2428a:	9301      	str	r3, [sp, #4]
   2428c:	68a3      	ldr	r3, [r4, #8]
   2428e:	9300      	str	r3, [sp, #0]
   24290:	e9d4 2300 	ldrd	r2, r3, [r4]
   24294:	4631      	mov	r1, r6
   24296:	4628      	mov	r0, r5
   24298:	f7de fc5a 	bl	2b50 <print_formatted>
		break;
   2429c:	e7db      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   2429e:	6923      	ldr	r3, [r4, #16]
   242a0:	9302      	str	r3, [sp, #8]
   242a2:	68e3      	ldr	r3, [r4, #12]
   242a4:	9301      	str	r3, [sp, #4]
   242a6:	68a3      	ldr	r3, [r4, #8]
   242a8:	9300      	str	r3, [sp, #0]
   242aa:	e9d4 2300 	ldrd	r2, r3, [r4]
   242ae:	4631      	mov	r1, r6
   242b0:	4628      	mov	r0, r5
   242b2:	f7de fc4d 	bl	2b50 <print_formatted>
		break;
   242b6:	e7ce      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   242b8:	6963      	ldr	r3, [r4, #20]
   242ba:	9303      	str	r3, [sp, #12]
   242bc:	6923      	ldr	r3, [r4, #16]
   242be:	9302      	str	r3, [sp, #8]
   242c0:	68e3      	ldr	r3, [r4, #12]
   242c2:	9301      	str	r3, [sp, #4]
   242c4:	68a3      	ldr	r3, [r4, #8]
   242c6:	9300      	str	r3, [sp, #0]
   242c8:	e9d4 2300 	ldrd	r2, r3, [r4]
   242cc:	4631      	mov	r1, r6
   242ce:	4628      	mov	r0, r5
   242d0:	f7de fc3e 	bl	2b50 <print_formatted>
		break;
   242d4:	e7bf      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   242d6:	69a3      	ldr	r3, [r4, #24]
   242d8:	9304      	str	r3, [sp, #16]
   242da:	6963      	ldr	r3, [r4, #20]
   242dc:	9303      	str	r3, [sp, #12]
   242de:	6923      	ldr	r3, [r4, #16]
   242e0:	9302      	str	r3, [sp, #8]
   242e2:	68e3      	ldr	r3, [r4, #12]
   242e4:	9301      	str	r3, [sp, #4]
   242e6:	68a3      	ldr	r3, [r4, #8]
   242e8:	9300      	str	r3, [sp, #0]
   242ea:	e9d4 2300 	ldrd	r2, r3, [r4]
   242ee:	4631      	mov	r1, r6
   242f0:	4628      	mov	r0, r5
   242f2:	f7de fc2d 	bl	2b50 <print_formatted>
		break;
   242f6:	e7ae      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   242f8:	69e3      	ldr	r3, [r4, #28]
   242fa:	9305      	str	r3, [sp, #20]
   242fc:	69a3      	ldr	r3, [r4, #24]
   242fe:	9304      	str	r3, [sp, #16]
   24300:	6963      	ldr	r3, [r4, #20]
   24302:	9303      	str	r3, [sp, #12]
   24304:	6923      	ldr	r3, [r4, #16]
   24306:	9302      	str	r3, [sp, #8]
   24308:	68e3      	ldr	r3, [r4, #12]
   2430a:	9301      	str	r3, [sp, #4]
   2430c:	68a3      	ldr	r3, [r4, #8]
   2430e:	9300      	str	r3, [sp, #0]
   24310:	e9d4 2300 	ldrd	r2, r3, [r4]
   24314:	4631      	mov	r1, r6
   24316:	4628      	mov	r0, r5
   24318:	f7de fc1a 	bl	2b50 <print_formatted>
		break;
   2431c:	e79b      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   2431e:	6a23      	ldr	r3, [r4, #32]
   24320:	9306      	str	r3, [sp, #24]
   24322:	69e3      	ldr	r3, [r4, #28]
   24324:	9305      	str	r3, [sp, #20]
   24326:	69a3      	ldr	r3, [r4, #24]
   24328:	9304      	str	r3, [sp, #16]
   2432a:	6963      	ldr	r3, [r4, #20]
   2432c:	9303      	str	r3, [sp, #12]
   2432e:	6923      	ldr	r3, [r4, #16]
   24330:	9302      	str	r3, [sp, #8]
   24332:	68e3      	ldr	r3, [r4, #12]
   24334:	9301      	str	r3, [sp, #4]
   24336:	68a3      	ldr	r3, [r4, #8]
   24338:	9300      	str	r3, [sp, #0]
   2433a:	e9d4 2300 	ldrd	r2, r3, [r4]
   2433e:	4631      	mov	r1, r6
   24340:	4628      	mov	r0, r5
   24342:	f7de fc05 	bl	2b50 <print_formatted>
		break;
   24346:	e786      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   24348:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2434a:	9307      	str	r3, [sp, #28]
   2434c:	6a23      	ldr	r3, [r4, #32]
   2434e:	9306      	str	r3, [sp, #24]
   24350:	69e3      	ldr	r3, [r4, #28]
   24352:	9305      	str	r3, [sp, #20]
   24354:	69a3      	ldr	r3, [r4, #24]
   24356:	9304      	str	r3, [sp, #16]
   24358:	6963      	ldr	r3, [r4, #20]
   2435a:	9303      	str	r3, [sp, #12]
   2435c:	6923      	ldr	r3, [r4, #16]
   2435e:	9302      	str	r3, [sp, #8]
   24360:	68e3      	ldr	r3, [r4, #12]
   24362:	9301      	str	r3, [sp, #4]
   24364:	68a3      	ldr	r3, [r4, #8]
   24366:	9300      	str	r3, [sp, #0]
   24368:	e9d4 2300 	ldrd	r2, r3, [r4]
   2436c:	4631      	mov	r1, r6
   2436e:	4628      	mov	r0, r5
   24370:	f7de fbee 	bl	2b50 <print_formatted>
		break;
   24374:	e76f      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   24376:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   24378:	9308      	str	r3, [sp, #32]
   2437a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2437c:	9307      	str	r3, [sp, #28]
   2437e:	6a23      	ldr	r3, [r4, #32]
   24380:	9306      	str	r3, [sp, #24]
   24382:	69e3      	ldr	r3, [r4, #28]
   24384:	9305      	str	r3, [sp, #20]
   24386:	69a3      	ldr	r3, [r4, #24]
   24388:	9304      	str	r3, [sp, #16]
   2438a:	6963      	ldr	r3, [r4, #20]
   2438c:	9303      	str	r3, [sp, #12]
   2438e:	6923      	ldr	r3, [r4, #16]
   24390:	9302      	str	r3, [sp, #8]
   24392:	68e3      	ldr	r3, [r4, #12]
   24394:	9301      	str	r3, [sp, #4]
   24396:	68a3      	ldr	r3, [r4, #8]
   24398:	9300      	str	r3, [sp, #0]
   2439a:	e9d4 2300 	ldrd	r2, r3, [r4]
   2439e:	4631      	mov	r1, r6
   243a0:	4628      	mov	r0, r5
   243a2:	f7de fbd5 	bl	2b50 <print_formatted>
		break;
   243a6:	e756      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   243a8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   243aa:	9309      	str	r3, [sp, #36]	; 0x24
   243ac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   243ae:	9308      	str	r3, [sp, #32]
   243b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   243b2:	9307      	str	r3, [sp, #28]
   243b4:	6a23      	ldr	r3, [r4, #32]
   243b6:	9306      	str	r3, [sp, #24]
   243b8:	69e3      	ldr	r3, [r4, #28]
   243ba:	9305      	str	r3, [sp, #20]
   243bc:	69a3      	ldr	r3, [r4, #24]
   243be:	9304      	str	r3, [sp, #16]
   243c0:	6963      	ldr	r3, [r4, #20]
   243c2:	9303      	str	r3, [sp, #12]
   243c4:	6923      	ldr	r3, [r4, #16]
   243c6:	9302      	str	r3, [sp, #8]
   243c8:	68e3      	ldr	r3, [r4, #12]
   243ca:	9301      	str	r3, [sp, #4]
   243cc:	68a3      	ldr	r3, [r4, #8]
   243ce:	9300      	str	r3, [sp, #0]
   243d0:	e9d4 2300 	ldrd	r2, r3, [r4]
   243d4:	4631      	mov	r1, r6
   243d6:	4628      	mov	r0, r5
   243d8:	f7de fbba 	bl	2b50 <print_formatted>
		break;
   243dc:	e73b      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   243de:	6b23      	ldr	r3, [r4, #48]	; 0x30
   243e0:	930a      	str	r3, [sp, #40]	; 0x28
   243e2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   243e4:	9309      	str	r3, [sp, #36]	; 0x24
   243e6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   243e8:	9308      	str	r3, [sp, #32]
   243ea:	6a63      	ldr	r3, [r4, #36]	; 0x24
   243ec:	9307      	str	r3, [sp, #28]
   243ee:	6a23      	ldr	r3, [r4, #32]
   243f0:	9306      	str	r3, [sp, #24]
   243f2:	69e3      	ldr	r3, [r4, #28]
   243f4:	9305      	str	r3, [sp, #20]
   243f6:	69a3      	ldr	r3, [r4, #24]
   243f8:	9304      	str	r3, [sp, #16]
   243fa:	6963      	ldr	r3, [r4, #20]
   243fc:	9303      	str	r3, [sp, #12]
   243fe:	6923      	ldr	r3, [r4, #16]
   24400:	9302      	str	r3, [sp, #8]
   24402:	68e3      	ldr	r3, [r4, #12]
   24404:	9301      	str	r3, [sp, #4]
   24406:	68a3      	ldr	r3, [r4, #8]
   24408:	9300      	str	r3, [sp, #0]
   2440a:	e9d4 2300 	ldrd	r2, r3, [r4]
   2440e:	4631      	mov	r1, r6
   24410:	4628      	mov	r0, r5
   24412:	f7de fb9d 	bl	2b50 <print_formatted>
		break;
   24416:	e71e      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   24418:	6b63      	ldr	r3, [r4, #52]	; 0x34
   2441a:	930b      	str	r3, [sp, #44]	; 0x2c
   2441c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   2441e:	930a      	str	r3, [sp, #40]	; 0x28
   24420:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   24422:	9309      	str	r3, [sp, #36]	; 0x24
   24424:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   24426:	9308      	str	r3, [sp, #32]
   24428:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2442a:	9307      	str	r3, [sp, #28]
   2442c:	6a23      	ldr	r3, [r4, #32]
   2442e:	9306      	str	r3, [sp, #24]
   24430:	69e3      	ldr	r3, [r4, #28]
   24432:	9305      	str	r3, [sp, #20]
   24434:	69a3      	ldr	r3, [r4, #24]
   24436:	9304      	str	r3, [sp, #16]
   24438:	6963      	ldr	r3, [r4, #20]
   2443a:	9303      	str	r3, [sp, #12]
   2443c:	6923      	ldr	r3, [r4, #16]
   2443e:	9302      	str	r3, [sp, #8]
   24440:	68e3      	ldr	r3, [r4, #12]
   24442:	9301      	str	r3, [sp, #4]
   24444:	68a3      	ldr	r3, [r4, #8]
   24446:	9300      	str	r3, [sp, #0]
   24448:	e9d4 2300 	ldrd	r2, r3, [r4]
   2444c:	4631      	mov	r1, r6
   2444e:	4628      	mov	r0, r5
   24450:	f7de fb7e 	bl	2b50 <print_formatted>
		break;
   24454:	e6ff      	b.n	24256 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   24456:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   24458:	930c      	str	r3, [sp, #48]	; 0x30
   2445a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   2445c:	930b      	str	r3, [sp, #44]	; 0x2c
   2445e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   24460:	930a      	str	r3, [sp, #40]	; 0x28
   24462:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   24464:	9309      	str	r3, [sp, #36]	; 0x24
   24466:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   24468:	9308      	str	r3, [sp, #32]
   2446a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2446c:	9307      	str	r3, [sp, #28]
   2446e:	6a23      	ldr	r3, [r4, #32]
   24470:	9306      	str	r3, [sp, #24]
   24472:	69e3      	ldr	r3, [r4, #28]
   24474:	9305      	str	r3, [sp, #20]
   24476:	69a3      	ldr	r3, [r4, #24]
   24478:	9304      	str	r3, [sp, #16]
   2447a:	6963      	ldr	r3, [r4, #20]
   2447c:	9303      	str	r3, [sp, #12]
   2447e:	6923      	ldr	r3, [r4, #16]
   24480:	9302      	str	r3, [sp, #8]
   24482:	68e3      	ldr	r3, [r4, #12]
   24484:	9301      	str	r3, [sp, #4]
   24486:	68a3      	ldr	r3, [r4, #8]
   24488:	9300      	str	r3, [sp, #0]
   2448a:	e9d4 2300 	ldrd	r2, r3, [r4]
   2448e:	4631      	mov	r1, r6
   24490:	4628      	mov	r0, r5
   24492:	f7de fb5d 	bl	2b50 <print_formatted>
}
   24496:	e6de      	b.n	24256 <std_print+0x78>

00024498 <log_output_flush>:
		     log_output->control_block->offset,
   24498:	6842      	ldr	r2, [r0, #4]
	buffer_write(log_output->func, log_output->buf,
   2449a:	6881      	ldr	r1, [r0, #8]
{
   2449c:	b510      	push	{r4, lr}
   2449e:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
   244a0:	e9d2 2300 	ldrd	r2, r3, [r2]
   244a4:	6800      	ldr	r0, [r0, #0]
   244a6:	f7ff fe8d 	bl	241c4 <buffer_write>
	log_output->control_block->offset = 0;
   244aa:	6863      	ldr	r3, [r4, #4]
   244ac:	2200      	movs	r2, #0
   244ae:	601a      	str	r2, [r3, #0]
}
   244b0:	bd10      	pop	{r4, pc}

000244b2 <char_out>:
{
   244b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   244b4:	460d      	mov	r5, r1
   244b6:	4616      	mov	r6, r2
	for (size_t i = 0; i < length; i++) {
   244b8:	4604      	mov	r4, r0
   244ba:	1847      	adds	r7, r0, r1
   244bc:	42bc      	cmp	r4, r7
   244be:	d101      	bne.n	244c4 <char_out+0x12>
}
   244c0:	4628      	mov	r0, r5
   244c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		uart_poll_out(dev, data[i]);
   244c4:	f814 1b01 	ldrb.w	r1, [r4], #1
   244c8:	6873      	ldr	r3, [r6, #4]
   244ca:	4630      	mov	r0, r6
   244cc:	685b      	ldr	r3, [r3, #4]
   244ce:	4798      	blx	r3
	for (size_t i = 0; i < length; i++) {
   244d0:	e7f4      	b.n	244bc <char_out+0xa>

000244d2 <flash_write_protection_set>:
	return api->write_protection(dev, enable);
   244d2:	6843      	ldr	r3, [r0, #4]
   244d4:	68db      	ldr	r3, [r3, #12]
   244d6:	4718      	bx	r3

000244d8 <nvs_flash_rd>:
{
   244d8:	b470      	push	{r4, r5, r6}
	offset += addr & ADDR_OFFS_MASK;
   244da:	6806      	ldr	r6, [r0, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   244dc:	8984      	ldrh	r4, [r0, #12]
	rc = flash_read(fs->flash_device, offset, data, len);
   244de:	6a80      	ldr	r0, [r0, #40]	; 0x28
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   244e0:	0c0d      	lsrs	r5, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   244e2:	fa16 f181 	uxtah	r1, r6, r1
   244e6:	fb05 1104 	mla	r1, r5, r4, r1
	return api->read(dev, offset, data, len);
   244ea:	6844      	ldr	r4, [r0, #4]
   244ec:	6824      	ldr	r4, [r4, #0]
   244ee:	46a4      	mov	ip, r4
}
   244f0:	bc70      	pop	{r4, r5, r6}
   244f2:	4760      	bx	ip

000244f4 <nvs_flash_block_cmp>:
{
   244f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   244f8:	7c05      	ldrb	r5, [r0, #16]
   244fa:	426d      	negs	r5, r5
{
   244fc:	b089      	sub	sp, #36	; 0x24
   244fe:	4681      	mov	r9, r0
   24500:	460e      	mov	r6, r1
   24502:	4617      	mov	r7, r2
   24504:	461c      	mov	r4, r3
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   24506:	f005 0520 	and.w	r5, r5, #32
	while (len) {
   2450a:	b91c      	cbnz	r4, 24514 <nvs_flash_block_cmp+0x20>
	return 0;
   2450c:	4620      	mov	r0, r4
}
   2450e:	b009      	add	sp, #36	; 0x24
   24510:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bytes_to_cmp = MIN(block_size, len);
   24514:	42ac      	cmp	r4, r5
   24516:	46a0      	mov	r8, r4
   24518:	bf28      	it	cs
   2451a:	46a8      	movcs	r8, r5
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_cmp);
   2451c:	4643      	mov	r3, r8
   2451e:	466a      	mov	r2, sp
   24520:	4631      	mov	r1, r6
   24522:	4648      	mov	r0, r9
   24524:	f7ff ffd8 	bl	244d8 <nvs_flash_rd>
		if (rc) {
   24528:	2800      	cmp	r0, #0
   2452a:	d1f0      	bne.n	2450e <nvs_flash_block_cmp+0x1a>
		rc = memcmp(data8, buf, bytes_to_cmp);
   2452c:	4642      	mov	r2, r8
   2452e:	4669      	mov	r1, sp
   24530:	4638      	mov	r0, r7
   24532:	f001 fba9 	bl	25c88 <memcmp>
		if (rc) {
   24536:	b920      	cbnz	r0, 24542 <nvs_flash_block_cmp+0x4e>
		len -= bytes_to_cmp;
   24538:	eba4 0408 	sub.w	r4, r4, r8
		addr += bytes_to_cmp;
   2453c:	4446      	add	r6, r8
		data8 += bytes_to_cmp;
   2453e:	4447      	add	r7, r8
   24540:	e7e3      	b.n	2450a <nvs_flash_block_cmp+0x16>
			return 1;
   24542:	2001      	movs	r0, #1
   24544:	e7e3      	b.n	2450e <nvs_flash_block_cmp+0x1a>

00024546 <nvs_ate_crc8_check>:
{
   24546:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   24548:	4601      	mov	r1, r0
{
   2454a:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   2454c:	2207      	movs	r2, #7
   2454e:	20ff      	movs	r0, #255	; 0xff
   24550:	f7dd fc16 	bl	1d80 <crc8_ccitt>
	if (crc8 == entry->crc8) {
   24554:	79e3      	ldrb	r3, [r4, #7]
}
   24556:	1a18      	subs	r0, r3, r0
   24558:	bf18      	it	ne
   2455a:	2001      	movne	r0, #1
   2455c:	bd10      	pop	{r4, pc}

0002455e <nvs_ate_crc8_update>:
{
   2455e:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   24560:	4601      	mov	r1, r0
{
   24562:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   24564:	2207      	movs	r2, #7
   24566:	20ff      	movs	r0, #255	; 0xff
   24568:	f7dd fc0a 	bl	1d80 <crc8_ccitt>
	entry->crc8 = crc8;
   2456c:	71e0      	strb	r0, [r4, #7]
}
   2456e:	bd10      	pop	{r4, pc}

00024570 <nvs_al_size.isra.0>:
static inline size_t nvs_al_size(struct nvs_fs *fs, size_t len)
   24570:	4603      	mov	r3, r0
	if (fs->write_block_size <= 1U) {
   24572:	2b01      	cmp	r3, #1
static inline size_t nvs_al_size(struct nvs_fs *fs, size_t len)
   24574:	4608      	mov	r0, r1
	return (len + (fs->write_block_size - 1U)) & ~(fs->write_block_size - 1U);
   24576:	bf81      	itttt	hi
   24578:	f103 31ff 	addhi.w	r1, r3, #4294967295	; 0xffffffff
   2457c:	1809      	addhi	r1, r1, r0
   2457e:	4258      	neghi	r0, r3
   24580:	4008      	andhi	r0, r1
}
   24582:	4770      	bx	lr

00024584 <nvs_sector_advance.isra.0>:
	*addr += (1 << ADDR_SECT_SHIFT);
   24584:	680b      	ldr	r3, [r1, #0]
   24586:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
   2458a:	0c1a      	lsrs	r2, r3, #16
   2458c:	ebb0 4f13 	cmp.w	r0, r3, lsr #16
		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
   24590:	bf08      	it	eq
   24592:	eba3 4302 	subeq.w	r3, r3, r2, lsl #16
   24596:	600b      	str	r3, [r1, #0]
}
   24598:	4770      	bx	lr

0002459a <nvs_flash_cmp_const.constprop.0>:
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   2459a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   2459e:	7c05      	ldrb	r5, [r0, #16]
   245a0:	426d      	negs	r5, r5
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   245a2:	b088      	sub	sp, #32
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   245a4:	f005 0520 	and.w	r5, r5, #32
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   245a8:	4607      	mov	r7, r0
   245aa:	460e      	mov	r6, r1
   245ac:	4614      	mov	r4, r2
	(void)memset(cmp, value, block_size);
   245ae:	21ff      	movs	r1, #255	; 0xff
   245b0:	462a      	mov	r2, r5
   245b2:	4668      	mov	r0, sp
   245b4:	f001 fba3 	bl	25cfe <memset>
	while (len) {
   245b8:	b91c      	cbnz	r4, 245c2 <nvs_flash_cmp_const.constprop.0+0x28>
	return 0;
   245ba:	4620      	mov	r0, r4
}
   245bc:	b008      	add	sp, #32
   245be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bytes_to_cmp = MIN(block_size, len);
   245c2:	42a5      	cmp	r5, r4
   245c4:	46a8      	mov	r8, r5
   245c6:	bf28      	it	cs
   245c8:	46a0      	movcs	r8, r4
		rc = nvs_flash_block_cmp(fs, addr, cmp, bytes_to_cmp);
   245ca:	4643      	mov	r3, r8
   245cc:	466a      	mov	r2, sp
   245ce:	4631      	mov	r1, r6
   245d0:	4638      	mov	r0, r7
   245d2:	f7ff ff8f 	bl	244f4 <nvs_flash_block_cmp>
		if (rc) {
   245d6:	2800      	cmp	r0, #0
   245d8:	d1f0      	bne.n	245bc <nvs_flash_cmp_const.constprop.0+0x22>
		len -= bytes_to_cmp;
   245da:	eba4 0408 	sub.w	r4, r4, r8
		addr += bytes_to_cmp;
   245de:	4446      	add	r6, r8
   245e0:	e7ea      	b.n	245b8 <nvs_flash_cmp_const.constprop.0+0x1e>

000245e2 <nvs_flash_erase_sector>:
{
   245e2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	addr &= ADDR_SECT_MASK;
   245e6:	0c0e      	lsrs	r6, r1, #16
   245e8:	0436      	lsls	r6, r6, #16
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   245ea:	8982      	ldrh	r2, [r0, #12]
   245ec:	4631      	mov	r1, r6
{
   245ee:	4605      	mov	r5, r0
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   245f0:	f7ff ffd3 	bl	2459a <nvs_flash_cmp_const.constprop.0>
	if (rc <= 0) {
   245f4:	1e04      	subs	r4, r0, #0
   245f6:	dd17      	ble.n	24628 <nvs_flash_erase_sector+0x46>
	rc = flash_write_protection_set(fs->flash_device, 0);
   245f8:	6aa8      	ldr	r0, [r5, #40]	; 0x28
	offset = fs->offset;
   245fa:	682f      	ldr	r7, [r5, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   245fc:	f8b5 800c 	ldrh.w	r8, [r5, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   24600:	2100      	movs	r1, #0
   24602:	f7ff ff66 	bl	244d2 <flash_write_protection_set>
	if (rc) {
   24606:	4604      	mov	r4, r0
   24608:	b970      	cbnz	r0, 24628 <nvs_flash_erase_sector+0x46>
	rc = flash_erase(fs->flash_device, offset, fs->sector_size);
   2460a:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   2460c:	89aa      	ldrh	r2, [r5, #12]
	return api->erase(dev, offset, size);
   2460e:	6843      	ldr	r3, [r0, #4]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   24610:	0c31      	lsrs	r1, r6, #16
   24612:	689b      	ldr	r3, [r3, #8]
   24614:	fb08 7101 	mla	r1, r8, r1, r7
   24618:	4798      	blx	r3
	if (rc) {
   2461a:	4604      	mov	r4, r0
   2461c:	b920      	cbnz	r0, 24628 <nvs_flash_erase_sector+0x46>
	(void) flash_write_protection_set(fs->flash_device, 1);
   2461e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
	return api->write_protection(dev, enable);
   24620:	6843      	ldr	r3, [r0, #4]
   24622:	2101      	movs	r1, #1
   24624:	68db      	ldr	r3, [r3, #12]
   24626:	4798      	blx	r3
}
   24628:	4620      	mov	r0, r4
   2462a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002462e <nvs_flash_al_wrt.part.0>:
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   2462e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	offset = fs->offset;
   24632:	f8d0 a000 	ldr.w	sl, [r0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   24636:	8987      	ldrh	r7, [r0, #12]
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   24638:	b088      	sub	sp, #32
   2463a:	4605      	mov	r5, r0
   2463c:	460c      	mov	r4, r1
	rc = flash_write_protection_set(fs->flash_device, 0);
   2463e:	6a80      	ldr	r0, [r0, #40]	; 0x28
   24640:	2100      	movs	r1, #0
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   24642:	4690      	mov	r8, r2
   24644:	461e      	mov	r6, r3
	rc = flash_write_protection_set(fs->flash_device, 0);
   24646:	f7ff ff44 	bl	244d2 <flash_write_protection_set>
	if (rc) {
   2464a:	bb78      	cbnz	r0, 246ac <nvs_flash_al_wrt.part.0+0x7e>
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   2464c:	ea4f 4914 	mov.w	r9, r4, lsr #16
	offset += addr & ADDR_OFFS_MASK;
   24650:	fa1a f484 	uxtah	r4, sl, r4
   24654:	fb07 4909 	mla	r9, r7, r9, r4
	blen = len & ~(fs->write_block_size - 1U);
   24658:	7c2f      	ldrb	r7, [r5, #16]
   2465a:	427f      	negs	r7, r7
	if (blen > 0) {
   2465c:	4037      	ands	r7, r6
   2465e:	d00b      	beq.n	24678 <nvs_flash_al_wrt.part.0+0x4a>
		rc = flash_write(fs->flash_device, offset, data8, blen);
   24660:	6aa8      	ldr	r0, [r5, #40]	; 0x28
	return api->write(dev, offset, data, len);
   24662:	6843      	ldr	r3, [r0, #4]
   24664:	4642      	mov	r2, r8
   24666:	685c      	ldr	r4, [r3, #4]
   24668:	4649      	mov	r1, r9
   2466a:	463b      	mov	r3, r7
   2466c:	47a0      	blx	r4
		if (rc) {
   2466e:	4604      	mov	r4, r0
   24670:	b9b8      	cbnz	r0, 246a2 <nvs_flash_al_wrt.part.0+0x74>
		len -= blen;
   24672:	1bf6      	subs	r6, r6, r7
		offset += blen;
   24674:	44b9      	add	r9, r7
		data8 += blen;
   24676:	44b8      	add	r8, r7
	if (len) {
   24678:	b1de      	cbz	r6, 246b2 <nvs_flash_al_wrt.part.0+0x84>
		memcpy(buf, data8, len);
   2467a:	4632      	mov	r2, r6
   2467c:	4641      	mov	r1, r8
   2467e:	4668      	mov	r0, sp
   24680:	f001 fb12 	bl	25ca8 <memcpy>
		(void)memset(buf + len, 0xff, fs->write_block_size - len);
   24684:	7c2a      	ldrb	r2, [r5, #16]
   24686:	21ff      	movs	r1, #255	; 0xff
   24688:	1b92      	subs	r2, r2, r6
   2468a:	eb0d 0006 	add.w	r0, sp, r6
   2468e:	f001 fb36 	bl	25cfe <memset>
		rc = flash_write(fs->flash_device, offset, buf,
   24692:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   24694:	7c2b      	ldrb	r3, [r5, #16]
   24696:	6842      	ldr	r2, [r0, #4]
   24698:	4649      	mov	r1, r9
   2469a:	6854      	ldr	r4, [r2, #4]
   2469c:	466a      	mov	r2, sp
   2469e:	47a0      	blx	r4
   246a0:	4604      	mov	r4, r0
	(void) flash_write_protection_set(fs->flash_device, 1);
   246a2:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   246a4:	2101      	movs	r1, #1
   246a6:	f7ff ff14 	bl	244d2 <flash_write_protection_set>
	return rc;
   246aa:	4620      	mov	r0, r4
}
   246ac:	b008      	add	sp, #32
   246ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
end:
   246b2:	4634      	mov	r4, r6
   246b4:	e7f5      	b.n	246a2 <nvs_flash_al_wrt.part.0+0x74>

000246b6 <nvs_flash_ate_wrt>:
{
   246b6:	b510      	push	{r4, lr}
   246b8:	460a      	mov	r2, r1
	if (!len) {
   246ba:	2308      	movs	r3, #8
   246bc:	6841      	ldr	r1, [r0, #4]
{
   246be:	4604      	mov	r4, r0
   246c0:	f7ff ffb5 	bl	2462e <nvs_flash_al_wrt.part.0>
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
   246c4:	2108      	movs	r1, #8
   246c6:	4602      	mov	r2, r0
   246c8:	7c20      	ldrb	r0, [r4, #16]
   246ca:	f7ff ff51 	bl	24570 <nvs_al_size.isra.0>
   246ce:	6863      	ldr	r3, [r4, #4]
   246d0:	1a1b      	subs	r3, r3, r0
   246d2:	6063      	str	r3, [r4, #4]
}
   246d4:	4610      	mov	r0, r2
   246d6:	bd10      	pop	{r4, pc}

000246d8 <nvs_delete>:
	return nvs_write(fs, id, NULL, 0);
   246d8:	2300      	movs	r3, #0
   246da:	461a      	mov	r2, r3
   246dc:	f7de bf82 	b.w	35e4 <nvs_write>

000246e0 <nvs_read>:

ssize_t nvs_read(struct nvs_fs *fs, u16_t id, void *data, size_t len)
{
   246e0:	b513      	push	{r0, r1, r4, lr}
	int rc;

	rc = nvs_read_hist(fs, id, data, len, 0);
   246e2:	2400      	movs	r4, #0
   246e4:	9400      	str	r4, [sp, #0]
   246e6:	f7df f85d 	bl	37a4 <nvs_read_hist>
	return rc;
}
   246ea:	b002      	add	sp, #8
   246ec:	bd10      	pop	{r4, pc}

000246ee <get_sectors_cb>:
{
   246ee:	b570      	push	{r4, r5, r6, lr}
	if (info->start_offset < data->area_off) {
   246f0:	6802      	ldr	r2, [r0, #0]
   246f2:	684c      	ldr	r4, [r1, #4]
   246f4:	42a2      	cmp	r2, r4
   246f6:	d316      	bcc.n	24726 <get_sectors_cb+0x38>
	} else if (info->start_offset >= data->area_off + data->area_len) {
   246f8:	688b      	ldr	r3, [r1, #8]
   246fa:	4423      	add	r3, r4
   246fc:	429a      	cmp	r2, r3
   246fe:	d206      	bcs.n	2470e <get_sectors_cb+0x20>
	} else if (data->ret_idx >= data->ret_len) {
   24700:	e9d1 3504 	ldrd	r3, r5, [r1, #16]
   24704:	42ab      	cmp	r3, r5
   24706:	d304      	bcc.n	24712 <get_sectors_cb+0x24>
		data->status = -ENOMEM;
   24708:	f06f 030b 	mvn.w	r3, #11
   2470c:	618b      	str	r3, [r1, #24]
		*bail_value = false;
   2470e:	2000      	movs	r0, #0
   24710:	e00a      	b.n	24728 <get_sectors_cb+0x3a>
	ret[data->ret_idx].fs_off = info->start_offset - data->area_off;
   24712:	68cd      	ldr	r5, [r1, #12]
   24714:	1b12      	subs	r2, r2, r4
   24716:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
   2471a:	f845 2033 	str.w	r2, [r5, r3, lsl #3]
	ret[data->ret_idx].fs_size = info->size;
   2471e:	6842      	ldr	r2, [r0, #4]
   24720:	6072      	str	r2, [r6, #4]
	data->ret_idx++;
   24722:	3301      	adds	r3, #1
   24724:	610b      	str	r3, [r1, #16]
		*bail_value = true;
   24726:	2001      	movs	r0, #1
}
   24728:	bd70      	pop	{r4, r5, r6, pc}

0002472a <settings_load>:
	return settings_load_subtree(NULL);
   2472a:	2000      	movs	r0, #0
   2472c:	f7df b92e 	b.w	398c <settings_load_subtree>

00024730 <settings_delete>:
	return settings_save_one(name, NULL, 0);
   24730:	2200      	movs	r2, #0
   24732:	4611      	mov	r1, r2
   24734:	f7df b8f2 	b.w	391c <settings_save_one>

00024738 <settings_name_steq>:
{
   24738:	4603      	mov	r3, r0
   2473a:	b530      	push	{r4, r5, lr}
   2473c:	4608      	mov	r0, r1
	if (next) {
   2473e:	b10a      	cbz	r2, 24744 <settings_name_steq+0xc>
		*next = NULL;
   24740:	2100      	movs	r1, #0
   24742:	6011      	str	r1, [r2, #0]
	if ((!name) || (!key)) {
   24744:	b163      	cbz	r3, 24760 <settings_name_steq+0x28>
   24746:	b190      	cbz	r0, 2476e <settings_name_steq+0x36>
   24748:	1e41      	subs	r1, r0, #1
   2474a:	4618      	mov	r0, r3
	while ((*key != '\0') && (*key == *name) &&
   2474c:	f811 5f01 	ldrb.w	r5, [r1, #1]!
   24750:	4604      	mov	r4, r0
   24752:	f810 3b01 	ldrb.w	r3, [r0], #1
   24756:	b15d      	cbz	r5, 24770 <settings_name_steq+0x38>
   24758:	429d      	cmp	r5, r3
   2475a:	d101      	bne.n	24760 <settings_name_steq+0x28>
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
   2475c:	2d3d      	cmp	r5, #61	; 0x3d
   2475e:	d1f5      	bne.n	2474c <settings_name_steq+0x14>
	return 0;
   24760:	2000      	movs	r0, #0
   24762:	e004      	b.n	2476e <settings_name_steq+0x36>
	if ((*name == SETTINGS_NAME_END) || (*name == '\0')) {
   24764:	2b3d      	cmp	r3, #61	; 0x3d
   24766:	d008      	beq.n	2477a <settings_name_steq+0x42>
   24768:	fab3 f083 	clz	r0, r3
   2476c:	0940      	lsrs	r0, r0, #5
}
   2476e:	bd30      	pop	{r4, r5, pc}
	if (*name == SETTINGS_NAME_SEPARATOR) {
   24770:	2b2f      	cmp	r3, #47	; 0x2f
   24772:	d1f7      	bne.n	24764 <settings_name_steq+0x2c>
		if (next) {
   24774:	b10a      	cbz	r2, 2477a <settings_name_steq+0x42>
			*next = name + 1;
   24776:	3401      	adds	r4, #1
   24778:	6014      	str	r4, [r2, #0]
		return 1;
   2477a:	2001      	movs	r0, #1
   2477c:	e7f7      	b.n	2476e <settings_name_steq+0x36>

0002477e <settings_name_next>:
{
   2477e:	b530      	push	{r4, r5, lr}
   24780:	4603      	mov	r3, r0
	if (next) {
   24782:	b109      	cbz	r1, 24788 <settings_name_next+0xa>
		*next = NULL;
   24784:	2200      	movs	r2, #0
   24786:	600a      	str	r2, [r1, #0]
	if (!name) {
   24788:	b16b      	cbz	r3, 247a6 <settings_name_next+0x28>
   2478a:	461a      	mov	r2, r3
   2478c:	4614      	mov	r4, r2
   2478e:	1ad0      	subs	r0, r2, r3
	while ((*name != '\0') && (*name != SETTINGS_NAME_END) &&
   24790:	f812 5b01 	ldrb.w	r5, [r2], #1
   24794:	b135      	cbz	r5, 247a4 <settings_name_next+0x26>
   24796:	2d3d      	cmp	r5, #61	; 0x3d
   24798:	d004      	beq.n	247a4 <settings_name_next+0x26>
   2479a:	2d2f      	cmp	r5, #47	; 0x2f
   2479c:	d1f6      	bne.n	2478c <settings_name_next+0xe>
		if (next) {
   2479e:	b109      	cbz	r1, 247a4 <settings_name_next+0x26>
			*next = name + 1;
   247a0:	3401      	adds	r4, #1
   247a2:	600c      	str	r4, [r1, #0]
}
   247a4:	bd30      	pop	{r4, r5, pc}
		return 0;
   247a6:	4618      	mov	r0, r3
   247a8:	e7fc      	b.n	247a4 <settings_name_next+0x26>

000247aa <settings_nvs_read_fn>:
{
   247aa:	b510      	push	{r4, lr}
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   247ac:	4613      	mov	r3, r2
{
   247ae:	4614      	mov	r4, r2
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   247b0:	460a      	mov	r2, r1
   247b2:	8881      	ldrh	r1, [r0, #4]
   247b4:	6800      	ldr	r0, [r0, #0]
   247b6:	f7ff ff93 	bl	246e0 <nvs_read>
}
   247ba:	42a0      	cmp	r0, r4
   247bc:	bfa8      	it	ge
   247be:	4620      	movge	r0, r4
   247c0:	bd10      	pop	{r4, pc}

000247c2 <settings_nvs_save>:
{
   247c2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   247c6:	b097      	sub	sp, #92	; 0x5c
   247c8:	4604      	mov	r4, r0
   247ca:	9201      	str	r2, [sp, #4]
   247cc:	469b      	mov	fp, r3
	if (!name) {
   247ce:	4689      	mov	r9, r1
   247d0:	2900      	cmp	r1, #0
   247d2:	d067      	beq.n	248a4 <settings_nvs_save+0xe2>
	delete = ((value == NULL) || (val_len == 0));
   247d4:	b1da      	cbz	r2, 2480e <settings_nvs_save+0x4c>
   247d6:	fabb f78b 	clz	r7, fp
   247da:	097f      	lsrs	r7, r7, #5
	name_id = cf->last_name_id + 1;
   247dc:	8ea5      	ldrh	r5, [r4, #52]	; 0x34
   247de:	3501      	adds	r5, #1
   247e0:	b2ad      	uxth	r5, r5
	write_name_id = cf->last_name_id + 1;
   247e2:	46a8      	mov	r8, r5
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   247e4:	f104 0a08 	add.w	sl, r4, #8
		name_id--;
   247e8:	1e6e      	subs	r6, r5, #1
   247ea:	b2b6      	uxth	r6, r6
		if (name_id == NVS_NAMECNT_ID) {
   247ec:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   247f0:	d02e      	beq.n	24850 <settings_nvs_save+0x8e>
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   247f2:	234a      	movs	r3, #74	; 0x4a
   247f4:	aa03      	add	r2, sp, #12
   247f6:	4631      	mov	r1, r6
   247f8:	4650      	mov	r0, sl
   247fa:	f7ff ff71 	bl	246e0 <nvs_read>
		if (rc < 0) {
   247fe:	2800      	cmp	r0, #0
   24800:	da07      	bge.n	24812 <settings_nvs_save+0x50>
			if (rc == -ENOENT) {
   24802:	f110 0f02 	cmn.w	r0, #2
   24806:	bf08      	it	eq
   24808:	46b0      	moveq	r8, r6
   2480a:	4635      	mov	r5, r6
   2480c:	e7ec      	b.n	247e8 <settings_nvs_save+0x26>
	delete = ((value == NULL) || (val_len == 0));
   2480e:	2701      	movs	r7, #1
   24810:	e7e4      	b.n	247dc <settings_nvs_save+0x1a>
		rdname[rc] = '\0';
   24812:	ab16      	add	r3, sp, #88	; 0x58
   24814:	4418      	add	r0, r3
   24816:	2300      	movs	r3, #0
   24818:	f800 3c4c 	strb.w	r3, [r0, #-76]
		if (strcmp(name, rdname)) {
   2481c:	a903      	add	r1, sp, #12
   2481e:	4648      	mov	r0, r9
   24820:	f001 fa17 	bl	25c52 <strcmp>
   24824:	2800      	cmp	r0, #0
   24826:	d1f0      	bne.n	2480a <settings_nvs_save+0x48>
		if ((delete) && (name_id == cf->last_name_id)) {
   24828:	2f00      	cmp	r7, #0
   2482a:	d039      	beq.n	248a0 <settings_nvs_save+0xde>
   2482c:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   2482e:	42b3      	cmp	r3, r6
   24830:	d140      	bne.n	248b4 <settings_nvs_save+0xf2>
			cf->last_name_id--;
   24832:	4622      	mov	r2, r4
   24834:	1e73      	subs	r3, r6, #1
   24836:	f822 3f34 	strh.w	r3, [r2, #52]!
			rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
   2483a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   2483e:	2302      	movs	r3, #2
   24840:	4650      	mov	r0, sl
   24842:	f7de fecf 	bl	35e4 <nvs_write>
			if (rc < 0) {
   24846:	2800      	cmp	r0, #0
   24848:	da34      	bge.n	248b4 <settings_nvs_save+0xf2>
}
   2484a:	b017      	add	sp, #92	; 0x5c
   2484c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (delete) {
   24850:	bb5f      	cbnz	r7, 248aa <settings_nvs_save+0xe8>
	write_name = true;
   24852:	2701      	movs	r7, #1
	if (write_name_id == NVS_NAMECNT_ID + NVS_NAME_ID_OFFSET) {
   24854:	f5b8 4f40 	cmp.w	r8, #49152	; 0xc000
   24858:	d029      	beq.n	248ae <settings_nvs_save+0xec>
	rc = nvs_write(&cf->cf_nvs, write_name_id + NVS_NAME_ID_OFFSET,
   2485a:	f104 0508 	add.w	r5, r4, #8
   2485e:	f508 4180 	add.w	r1, r8, #16384	; 0x4000
   24862:	9a01      	ldr	r2, [sp, #4]
   24864:	465b      	mov	r3, fp
   24866:	b289      	uxth	r1, r1
   24868:	4628      	mov	r0, r5
   2486a:	f7de febb 	bl	35e4 <nvs_write>
	if (write_name) {
   2486e:	b157      	cbz	r7, 24886 <settings_nvs_save+0xc4>
		rc = nvs_write(&cf->cf_nvs, write_name_id, name, strlen(name));
   24870:	4648      	mov	r0, r9
   24872:	f001 f9e7 	bl	25c44 <strlen>
   24876:	464a      	mov	r2, r9
   24878:	4603      	mov	r3, r0
   2487a:	4641      	mov	r1, r8
   2487c:	4628      	mov	r0, r5
   2487e:	f7de feb1 	bl	35e4 <nvs_write>
		if (rc < 0) {
   24882:	2800      	cmp	r0, #0
   24884:	dbe1      	blt.n	2484a <settings_nvs_save+0x88>
	if (write_name_id > cf->last_name_id) {
   24886:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   24888:	4543      	cmp	r3, r8
   2488a:	d220      	bcs.n	248ce <settings_nvs_save+0x10c>
		cf->last_name_id = write_name_id;
   2488c:	4622      	mov	r2, r4
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   2488e:	2302      	movs	r3, #2
		cf->last_name_id = write_name_id;
   24890:	f822 8f34 	strh.w	r8, [r2, #52]!
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   24894:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   24898:	4628      	mov	r0, r5
   2489a:	f7de fea3 	bl	35e4 <nvs_write>
   2489e:	e016      	b.n	248ce <settings_nvs_save+0x10c>
   248a0:	46b0      	mov	r8, r6
   248a2:	e7d7      	b.n	24854 <settings_nvs_save+0x92>
		return -EINVAL;
   248a4:	f06f 0015 	mvn.w	r0, #21
   248a8:	e7cf      	b.n	2484a <settings_nvs_save+0x88>
		return 0;
   248aa:	2000      	movs	r0, #0
   248ac:	e7cd      	b.n	2484a <settings_nvs_save+0x88>
		return -ENOMEM;
   248ae:	f06f 000b 	mvn.w	r0, #11
   248b2:	e7ca      	b.n	2484a <settings_nvs_save+0x88>
			rc = nvs_delete(&cf->cf_nvs, name_id);
   248b4:	4631      	mov	r1, r6
   248b6:	4650      	mov	r0, sl
   248b8:	f7ff ff0e 	bl	246d8 <nvs_delete>
			if (rc >= 0) {
   248bc:	2800      	cmp	r0, #0
   248be:	dbc4      	blt.n	2484a <settings_nvs_save+0x88>
				rc = nvs_delete(&cf->cf_nvs, name_id +
   248c0:	f505 517f 	add.w	r1, r5, #16320	; 0x3fc0
   248c4:	313f      	adds	r1, #63	; 0x3f
   248c6:	b289      	uxth	r1, r1
   248c8:	4650      	mov	r0, sl
   248ca:	f7ff ff05 	bl	246d8 <nvs_delete>
	if (rc < 0) {
   248ce:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   248d2:	e7ba      	b.n	2484a <settings_nvs_save+0x88>

000248d4 <settings_nvs_backend_init>:
{
   248d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	rc = nvs_init(&cf->cf_nvs, cf->flash_dev_name);
   248d6:	f100 0608 	add.w	r6, r0, #8
   248da:	6b81      	ldr	r1, [r0, #56]	; 0x38
{
   248dc:	4604      	mov	r4, r0
	rc = nvs_init(&cf->cf_nvs, cf->flash_dev_name);
   248de:	4630      	mov	r0, r6
   248e0:	f7de fd38 	bl	3354 <nvs_init>
	if (rc) {
   248e4:	4605      	mov	r5, r0
   248e6:	b970      	cbnz	r0, 24906 <settings_nvs_backend_init+0x32>
	rc = nvs_read(&cf->cf_nvs, NVS_NAMECNT_ID, &last_name_id,
   248e8:	2302      	movs	r3, #2
   248ea:	f10d 0206 	add.w	r2, sp, #6
   248ee:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   248f2:	4630      	mov	r0, r6
   248f4:	f7ff fef4 	bl	246e0 <nvs_read>
	if (rc < 0) {
   248f8:	2800      	cmp	r0, #0
		cf->last_name_id = last_name_id;
   248fa:	bfac      	ite	ge
   248fc:	f8bd 3006 	ldrhge.w	r3, [sp, #6]
		cf->last_name_id = NVS_NAMECNT_ID;
   24900:	f44f 4300 	movlt.w	r3, #32768	; 0x8000
		cf->last_name_id = last_name_id;
   24904:	86a3      	strh	r3, [r4, #52]	; 0x34
}
   24906:	4628      	mov	r0, r5
   24908:	b002      	add	sp, #8
   2490a:	bd70      	pop	{r4, r5, r6, pc}

0002490c <clk_init>:
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   2490c:	2200      	movs	r2, #0
{
   2490e:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   24910:	2101      	movs	r1, #1
{
   24912:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   24914:	4610      	mov	r0, r2
   24916:	f7e0 f851 	bl	49bc <z_arm_irq_priority_set>
	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
   2491a:	2000      	movs	r0, #0
   2491c:	f7e0 f81c 	bl	4958 <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
   24920:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   24924:	2201      	movs	r2, #1
   24926:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
   2492a:	2203      	movs	r2, #3
   2492c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		sys_slist_init(&(get_sub_data(dev, i)->list));
   24930:	68a3      	ldr	r3, [r4, #8]
	list->head = NULL;
   24932:	2000      	movs	r0, #0
	list->tail = NULL;
   24934:	e9c3 0000 	strd	r0, r0, [r3]
   24938:	68a3      	ldr	r3, [r4, #8]
   2493a:	e9c3 0003 	strd	r0, r0, [r3, #12]
}
   2493e:	bd10      	pop	{r4, pc}

00024940 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   24940:	2200      	movs	r2, #0
   24942:	f7df ba8b 	b.w	3e5c <clock_async_start>

00024946 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   24946:	4770      	bx	lr

00024948 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   24948:	f7df bd88 	b.w	445c <_DoInit>

0002494c <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(struct device *unused)
{
   2494c:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   2494e:	f7ff fffb 	bl	24948 <SEGGER_RTT_Init>

	return 0;
}
   24952:	2000      	movs	r0, #0
   24954:	bd08      	pop	{r3, pc}

00024956 <_copy>:

#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
   24956:	b538      	push	{r3, r4, r5, lr}
   24958:	460d      	mov	r5, r1
	if (from_len <= to_len) {
   2495a:	42ab      	cmp	r3, r5
{
   2495c:	4611      	mov	r1, r2
   2495e:	461c      	mov	r4, r3
	if (from_len <= to_len) {
   24960:	d804      	bhi.n	2496c <_copy+0x16>
		(void)memcpy(to, from, from_len);
   24962:	461a      	mov	r2, r3
   24964:	f001 f9a0 	bl	25ca8 <memcpy>
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
   24968:	4620      	mov	r0, r4
   2496a:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   2496c:	2400      	movs	r4, #0
   2496e:	e7fb      	b.n	24968 <_copy+0x12>

00024970 <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
	(void)memset(to, val, len);
   24970:	f001 b9c5 	b.w	25cfe <memset>

00024974 <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   24974:	09c3      	lsrs	r3, r0, #7
   24976:	005a      	lsls	r2, r3, #1
   24978:	4413      	add	r3, r2
   2497a:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   2497e:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   24982:	b2c0      	uxtb	r0, r0
   24984:	4770      	bx	lr

00024986 <uECC_make_key>:
	}
	return 0;
}

int uECC_make_key(uint8_t *public_key, uint8_t *private_key, uECC_Curve curve)
{
   24986:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2498a:	4606      	mov	r6, r0
   2498c:	b0a9      	sub	sp, #164	; 0xa4
   2498e:	4688      	mov	r8, r1
   24990:	4614      	mov	r4, r2
   24992:	2740      	movs	r7, #64	; 0x40
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
        		return 0;
		}

		/* computing modular reduction of _random (see FIPS 186.4 B.4.1): */
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   24994:	f102 0924 	add.w	r9, r2, #36	; 0x24
		uECC_RNG_Function rng_function = uECC_get_rng();
   24998:	f7df fde6 	bl	4568 <uECC_get_rng>
		if (!rng_function ||
   2499c:	4603      	mov	r3, r0
   2499e:	2800      	cmp	r0, #0
   249a0:	d03e      	beq.n	24a20 <uECC_make_key+0x9a>
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
   249a2:	2140      	movs	r1, #64	; 0x40
   249a4:	a808      	add	r0, sp, #32
   249a6:	4798      	blx	r3
		if (!rng_function ||
   249a8:	b3d0      	cbz	r0, 24a20 <uECC_make_key+0x9a>
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   249aa:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
   249ae:	f112 031f 	adds.w	r3, r2, #31
   249b2:	bf48      	it	mi
   249b4:	f102 033e 	addmi.w	r3, r2, #62	; 0x3e
   249b8:	466d      	mov	r5, sp
   249ba:	464a      	mov	r2, r9
   249bc:	a908      	add	r1, sp, #32
   249be:	4628      	mov	r0, r5
   249c0:	f343 1347 	sbfx	r3, r3, #5, #8
   249c4:	f000 fa03 	bl	24dce <uECC_vli_mmod>

		/* Computing public-key from private: */
		if (EccPoint_compute_public_key(_public, _private, curve)) {
   249c8:	4622      	mov	r2, r4
   249ca:	4629      	mov	r1, r5
   249cc:	a818      	add	r0, sp, #96	; 0x60
   249ce:	f000 fe19 	bl	25604 <EccPoint_compute_public_key>
   249d2:	b318      	cbz	r0, 24a1c <uECC_make_key+0x96>

			/* Converting buffers to correct bit order: */
			uECC_vli_nativeToBytes(private_key,
					       BITS_TO_BYTES(curve->num_n_bits),
   249d4:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
			uECC_vli_nativeToBytes(private_key,
   249d8:	1dd9      	adds	r1, r3, #7
   249da:	bf48      	it	mi
   249dc:	f103 010e 	addmi.w	r1, r3, #14
   249e0:	462a      	mov	r2, r5
   249e2:	4640      	mov	r0, r8
   249e4:	10c9      	asrs	r1, r1, #3
   249e6:	f000 fe35 	bl	25654 <uECC_vli_nativeToBytes>
					       _private);
			uECC_vli_nativeToBytes(public_key,
   249ea:	f994 1001 	ldrsb.w	r1, [r4, #1]
   249ee:	aa18      	add	r2, sp, #96	; 0x60
   249f0:	4630      	mov	r0, r6
   249f2:	f000 fe2f 	bl	25654 <uECC_vli_nativeToBytes>
					       curve->num_bytes,
					       _public);
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   249f6:	f994 1001 	ldrsb.w	r1, [r4, #1]
 					       curve->num_bytes,
					       _public + curve->num_words);
   249fa:	f994 2000 	ldrsb.w	r2, [r4]
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   249fe:	ab18      	add	r3, sp, #96	; 0x60
   24a00:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   24a04:	1870      	adds	r0, r6, r1
   24a06:	f000 fe25 	bl	25654 <uECC_vli_nativeToBytes>
#ifdef TINYCRYPT_ARCH_HAS_SET_SECURE
extern void _set_secure(void *to, uint8_t val, unsigned int len);
#else /* ! TINYCRYPT_ARCH_HAS_SET_SECURE */
static inline void _set_secure(void *to, uint8_t val, unsigned int len)
{
  (void) memset(to, val, len);
   24a0a:	2220      	movs	r2, #32
   24a0c:	2100      	movs	r1, #0
   24a0e:	4628      	mov	r0, r5
   24a10:	f001 f975 	bl	25cfe <memset>

			/* erasing temporary buffer that stored secret: */
			_set_secure(_private, 0, NUM_ECC_BYTES);

      			return 1;
   24a14:	2001      	movs	r0, #1
    		}
  	}
	return 0;
}
   24a16:	b029      	add	sp, #164	; 0xa4
   24a18:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
   24a1c:	3f01      	subs	r7, #1
   24a1e:	d1bb      	bne.n	24998 <uECC_make_key+0x12>
        		return 0;
   24a20:	2000      	movs	r0, #0
   24a22:	e7f8      	b.n	24a16 <uECC_make_key+0x90>

00024a24 <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key, const uint8_t *private_key,
		       uint8_t *secret, uECC_Curve curve)
{
   24a24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   24a28:	461c      	mov	r4, r3
	uECC_word_t tmp[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {_private, tmp};
	uECC_word_t *initial_Z = 0;
	uECC_word_t carry;
	wordcount_t num_words = curve->num_words;
	wordcount_t num_bytes = curve->num_bytes;
   24a2a:	f993 7001 	ldrsb.w	r7, [r3, #1]
	wordcount_t num_words = curve->num_words;
   24a2e:	f993 a000 	ldrsb.w	sl, [r3]
	int r;

	/* Converting buffers to correct bit order: */
	uECC_vli_bytesToNative(_private,
      			       private_key,
			       BITS_TO_BYTES(curve->num_n_bits));
   24a32:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
   24a36:	b0a4      	sub	sp, #144	; 0x90
   24a38:	4690      	mov	r8, r2
	uECC_vli_bytesToNative(_private,
   24a3a:	1dda      	adds	r2, r3, #7
   24a3c:	bf48      	it	mi
   24a3e:	f103 020e 	addmi.w	r2, r3, #14
	uECC_word_t *p2[2] = {_private, tmp};
   24a42:	ad04      	add	r5, sp, #16
{
   24a44:	4681      	mov	r9, r0
	uECC_word_t *p2[2] = {_private, tmp};
   24a46:	ae0c      	add	r6, sp, #48	; 0x30
	uECC_vli_bytesToNative(_private,
   24a48:	4628      	mov	r0, r5
   24a4a:	10d2      	asrs	r2, r2, #3
	uECC_word_t *p2[2] = {_private, tmp};
   24a4c:	9502      	str	r5, [sp, #8]
   24a4e:	9603      	str	r6, [sp, #12]
	uECC_vli_bytesToNative(_private,
   24a50:	f000 fe14 	bl	2567c <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(_public,
   24a54:	463a      	mov	r2, r7
   24a56:	4649      	mov	r1, r9
   24a58:	a814      	add	r0, sp, #80	; 0x50
   24a5a:	f000 fe0f 	bl	2567c <uECC_vli_bytesToNative>
      			       public_key,
			       num_bytes);
	uECC_vli_bytesToNative(_public + num_words,
   24a5e:	ab14      	add	r3, sp, #80	; 0x50
   24a60:	eb09 0107 	add.w	r1, r9, r7
   24a64:	eb03 008a 	add.w	r0, r3, sl, lsl #2
   24a68:	463a      	mov	r2, r7
   24a6a:	f000 fe07 	bl	2567c <uECC_vli_bytesToNative>
			       public_key + num_bytes,
			       num_bytes);

	/* Regularize the bitcount for the private key so that attackers cannot use a
	 * side channel attack to learn the number of leading zeros. */
	carry = regularize_k(_private, _private, tmp, curve);
   24a6e:	4623      	mov	r3, r4
   24a70:	4632      	mov	r2, r6
   24a72:	4629      	mov	r1, r5
   24a74:	4628      	mov	r0, r5
   24a76:	f000 fd99 	bl	255ac <regularize_k>
			goto clear_and_out;
    		}
    		initial_Z = p2[carry];
  	}

	EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1,
   24a7a:	fab0 f080 	clz	r0, r0
   24a7e:	9401      	str	r4, [sp, #4]
   24a80:	ab24      	add	r3, sp, #144	; 0x90
   24a82:	0940      	lsrs	r0, r0, #5
   24a84:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   24a88:	8863      	ldrh	r3, [r4, #2]
   24a8a:	3301      	adds	r3, #1
   24a8c:	b21b      	sxth	r3, r3
   24a8e:	9300      	str	r3, [sp, #0]
   24a90:	a914      	add	r1, sp, #80	; 0x50
   24a92:	2300      	movs	r3, #0
   24a94:	f850 2c88 	ldr.w	r2, [r0, #-136]
   24a98:	4608      	mov	r0, r1
   24a9a:	f000 fcb8 	bl	2540e <EccPoint_mult>
		      curve);

	uECC_vli_nativeToBytes(secret, num_bytes, _public);
   24a9e:	aa14      	add	r2, sp, #80	; 0x50
   24aa0:	4639      	mov	r1, r7
   24aa2:	4640      	mov	r0, r8
   24aa4:	f000 fdd6 	bl	25654 <uECC_vli_nativeToBytes>
	r = !EccPoint_isZero(_public, curve);
   24aa8:	4621      	mov	r1, r4
   24aaa:	a814      	add	r0, sp, #80	; 0x50
   24aac:	f000 fc24 	bl	252f8 <EccPoint_isZero>
   24ab0:	af02      	add	r7, sp, #8
   24ab2:	4604      	mov	r4, r0
   24ab4:	2208      	movs	r2, #8
   24ab6:	2100      	movs	r1, #0
   24ab8:	4638      	mov	r0, r7
   24aba:	f001 f920 	bl	25cfe <memset>
   24abe:	2220      	movs	r2, #32
   24ac0:	2100      	movs	r1, #0
   24ac2:	4630      	mov	r0, r6
   24ac4:	f001 f91b 	bl	25cfe <memset>
   24ac8:	2220      	movs	r2, #32
   24aca:	2100      	movs	r1, #0
   24acc:	4628      	mov	r0, r5
   24ace:	f001 f916 	bl	25cfe <memset>
	_set_secure(p2, 0, sizeof(p2));
	_set_secure(tmp, 0, sizeof(tmp));
	_set_secure(_private, 0, sizeof(_private));

	return r;
}
   24ad2:	fab4 f084 	clz	r0, r4
   24ad6:	0940      	lsrs	r0, r0, #5
   24ad8:	b024      	add	sp, #144	; 0x90
   24ada:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00024ade <uECC_vli_add>:
{
   24ade:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   24ae0:	2400      	movs	r4, #0
{
   24ae2:	4606      	mov	r6, r0
	uECC_word_t carry = 0;
   24ae4:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   24ae6:	b265      	sxtb	r5, r4
   24ae8:	42ab      	cmp	r3, r5
   24aea:	dc00      	bgt.n	24aee <uECC_vli_add+0x10>
}
   24aec:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
   24aee:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
   24af2:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
   24af6:	443d      	add	r5, r7
   24af8:	4405      	add	r5, r0
		carry = cond_set(val, carry, (sum != left[i]));
   24afa:	42af      	cmp	r7, r5
		uECC_word_t val = (sum < left[i]);
   24afc:	bf8c      	ite	hi
   24afe:	2701      	movhi	r7, #1
   24b00:	2700      	movls	r7, #0
		result[i] = sum;
   24b02:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   24b06:	bf18      	it	ne
   24b08:	4638      	movne	r0, r7
	for (i = 0; i < num_words; ++i) {
   24b0a:	3401      	adds	r4, #1
   24b0c:	e7eb      	b.n	24ae6 <uECC_vli_add+0x8>

00024b0e <uECC_vli_rshift1>:
	vli += num_words;
   24b0e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	uECC_word_t carry = 0;
   24b12:	2300      	movs	r3, #0
	while (vli-- > end) {
   24b14:	4288      	cmp	r0, r1
   24b16:	d300      	bcc.n	24b1a <uECC_vli_rshift1+0xc>
}
   24b18:	4770      	bx	lr
		uECC_word_t temp = *vli;
   24b1a:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
   24b1e:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
   24b22:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
   24b24:	07d3      	lsls	r3, r2, #31
   24b26:	e7f5      	b.n	24b14 <uECC_vli_rshift1+0x6>

00024b28 <vli_modInv_update>:
	if (!EVEN(uv)) {
   24b28:	6803      	ldr	r3, [r0, #0]
{
   24b2a:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
   24b2c:	f013 0601 	ands.w	r6, r3, #1
{
   24b30:	4605      	mov	r5, r0
   24b32:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
   24b34:	d005      	beq.n	24b42 <vli_modInv_update+0x1a>
		carry = uECC_vli_add(uv, uv, mod, num_words);
   24b36:	4613      	mov	r3, r2
   24b38:	460a      	mov	r2, r1
   24b3a:	4601      	mov	r1, r0
   24b3c:	f7ff ffcf 	bl	24ade <uECC_vli_add>
   24b40:	4606      	mov	r6, r0
	uECC_vli_rshift1(uv, num_words);
   24b42:	4621      	mov	r1, r4
   24b44:	4628      	mov	r0, r5
   24b46:	f7ff ffe2 	bl	24b0e <uECC_vli_rshift1>
	if (carry) {
   24b4a:	b146      	cbz	r6, 24b5e <vli_modInv_update+0x36>
		uv[num_words - 1] |= HIGH_BIT_SET;
   24b4c:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
   24b50:	3a01      	subs	r2, #1
   24b52:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
   24b56:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   24b5a:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
}
   24b5e:	bd70      	pop	{r4, r5, r6, pc}

00024b60 <uECC_vli_mult>:
{
   24b60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (k = 0; k < num_words; ++k) {
   24b64:	2500      	movs	r5, #0
{
   24b66:	b087      	sub	sp, #28
   24b68:	e9cd 1200 	strd	r1, r2, [sp]
	uECC_word_t r1 = 0;
   24b6c:	462c      	mov	r4, r5
	uECC_word_t r0 = 0;
   24b6e:	462a      	mov	r2, r5
	for (k = 0; k < num_words; ++k) {
   24b70:	fa4f f885 	sxtb.w	r8, r5
   24b74:	4543      	cmp	r3, r8
   24b76:	dc16      	bgt.n	24ba6 <uECC_vli_mult+0x46>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
   24b78:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   24b7c:	eb05 0543 	add.w	r5, r5, r3, lsl #1
   24b80:	9502      	str	r5, [sp, #8]
   24b82:	f04f 0a00 	mov.w	sl, #0
   24b86:	9e02      	ldr	r6, [sp, #8]
   24b88:	fa53 fe8a 	uxtab	lr, r3, sl
   24b8c:	fa4f fe8e 	sxtb.w	lr, lr
   24b90:	45b6      	cmp	lr, r6
   24b92:	fa5f f58a 	uxtb.w	r5, sl
   24b96:	db2d      	blt.n	24bf4 <uECC_vli_mult+0x94>
	result[num_words * 2 - 1] = r0;
   24b98:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   24b9c:	f840 2c04 	str.w	r2, [r0, #-4]
}
   24ba0:	b007      	add	sp, #28
   24ba2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24ba6:	9e01      	ldr	r6, [sp, #4]
	for (k = 0; k < num_words; ++k) {
   24ba8:	f04f 0c00 	mov.w	ip, #0
   24bac:	eb06 0985 	add.w	r9, r6, r5, lsl #2
   24bb0:	46e6      	mov	lr, ip
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
   24bb2:	e9cd 2402 	strd	r2, r4, [sp, #8]
	uECC_dword_t p = (uECC_dword_t)a * b;
   24bb6:	9900      	ldr	r1, [sp, #0]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   24bb8:	f859 7904 	ldr.w	r7, [r9], #-4
	uECC_dword_t p = (uECC_dword_t)a * b;
   24bbc:	f851 602c 	ldr.w	r6, [r1, ip, lsl #2]
   24bc0:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   24bc4:	fba7 ab06 	umull	sl, fp, r7, r6
   24bc8:	eb1a 0601 	adds.w	r6, sl, r1
   24bcc:	f10c 0c01 	add.w	ip, ip, #1
   24bd0:	eb5b 0702 	adcs.w	r7, fp, r2
		for (i = 0; i <= k; ++i) {
   24bd4:	fa4f fa8c 	sxtb.w	sl, ip
   24bd8:	bf2c      	ite	cs
   24bda:	2201      	movcs	r2, #1
   24bdc:	2200      	movcc	r2, #0
   24bde:	45c2      	cmp	sl, r8
	*r2 += (r01 < p);
   24be0:	4496      	add	lr, r2
	*r1 = r01 >> uECC_WORD_BITS;
   24be2:	463c      	mov	r4, r7
	*r0 = (uECC_word_t)r01;
   24be4:	4632      	mov	r2, r6
		for (i = 0; i <= k; ++i) {
   24be6:	dde4      	ble.n	24bb2 <uECC_vli_mult+0x52>
		result[k] = r0;
   24be8:	f840 6025 	str.w	r6, [r0, r5, lsl #2]
	*r1 = r01 >> uECC_WORD_BITS;
   24bec:	463a      	mov	r2, r7
   24bee:	3501      	adds	r5, #1
	*r2 += (r01 < p);
   24bf0:	4674      	mov	r4, lr
   24bf2:	e7bd      	b.n	24b70 <uECC_vli_mult+0x10>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   24bf4:	3501      	adds	r5, #1
   24bf6:	9900      	ldr	r1, [sp, #0]
   24bf8:	9e01      	ldr	r6, [sp, #4]
   24bfa:	fa4f fc85 	sxtb.w	ip, r5
   24bfe:	ebae 0b0c 	sub.w	fp, lr, ip
   24c02:	eb01 058c 	add.w	r5, r1, ip, lsl #2
   24c06:	eb06 0b8b 	add.w	fp, r6, fp, lsl #2
   24c0a:	4621      	mov	r1, r4
   24c0c:	2400      	movs	r4, #0
   24c0e:	459c      	cmp	ip, r3
   24c10:	db05      	blt.n	24c1e <uECC_vli_mult+0xbe>
		result[k] = r0;
   24c12:	f840 202e 	str.w	r2, [r0, lr, lsl #2]
	for (k = num_words; k < num_words * 2 - 1; ++k) {
   24c16:	f10a 0a01 	add.w	sl, sl, #1
		result[k] = r0;
   24c1a:	460a      	mov	r2, r1
   24c1c:	e7b3      	b.n	24b86 <uECC_vli_mult+0x26>
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
   24c1e:	e9cd 2104 	strd	r2, r1, [sp, #16]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   24c22:	f855 7b04 	ldr.w	r7, [r5], #4
   24c26:	f85b 6904 	ldr.w	r6, [fp], #-4
	r01 += p;
   24c2a:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
	uECC_dword_t p = (uECC_dword_t)a * b;
   24c2e:	fba7 6706 	umull	r6, r7, r7, r6
   24c32:	eb16 0801 	adds.w	r8, r6, r1
   24c36:	eb57 0902 	adcs.w	r9, r7, r2
   24c3a:	bf2c      	ite	cs
   24c3c:	2201      	movcs	r2, #1
   24c3e:	2200      	movcc	r2, #0
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   24c40:	f10c 0c01 	add.w	ip, ip, #1
	*r2 += (r01 < p);
   24c44:	4414      	add	r4, r2
	*r1 = r01 >> uECC_WORD_BITS;
   24c46:	4649      	mov	r1, r9
	*r0 = (uECC_word_t)r01;
   24c48:	4642      	mov	r2, r8
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   24c4a:	fa4f fc8c 	sxtb.w	ip, ip
   24c4e:	e7de      	b.n	24c0e <uECC_vli_mult+0xae>

00024c50 <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
   24c50:	2300      	movs	r3, #0
{
   24c52:	b510      	push	{r4, lr}
		 vli[i] = 0;
   24c54:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
   24c56:	b25a      	sxtb	r2, r3
   24c58:	4291      	cmp	r1, r2
   24c5a:	dc00      	bgt.n	24c5e <uECC_vli_clear+0xe>
}
   24c5c:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
   24c5e:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
   24c62:	3301      	adds	r3, #1
   24c64:	e7f7      	b.n	24c56 <uECC_vli_clear+0x6>

00024c66 <uECC_vli_isZero>:
{
   24c66:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   24c68:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
   24c6a:	461a      	mov	r2, r3
	for (i = 0; i < num_words; ++i) {
   24c6c:	b25c      	sxtb	r4, r3
   24c6e:	42a1      	cmp	r1, r4
   24c70:	dc03      	bgt.n	24c7a <uECC_vli_isZero+0x14>
}
   24c72:	fab2 f082 	clz	r0, r2
   24c76:	0940      	lsrs	r0, r0, #5
   24c78:	bd10      	pop	{r4, pc}
		bits |= vli[i];
   24c7a:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   24c7e:	3301      	adds	r3, #1
   24c80:	4322      	orrs	r2, r4
	for (i = 0; i < num_words; ++i) {
   24c82:	e7f3      	b.n	24c6c <uECC_vli_isZero+0x6>

00024c84 <uECC_vli_testBit>:
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   24c84:	114a      	asrs	r2, r1, #5
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   24c86:	2301      	movs	r3, #1
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   24c88:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   24c8c:	f001 011f 	and.w	r1, r1, #31
   24c90:	fa03 f101 	lsl.w	r1, r3, r1
}
   24c94:	4008      	ands	r0, r1
   24c96:	4770      	bx	lr

00024c98 <uECC_vli_numBits>:
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   24c98:	3901      	subs	r1, #1
   24c9a:	b24b      	sxtb	r3, r1
{
   24c9c:	4602      	mov	r2, r0
   24c9e:	eb00 0183 	add.w	r1, r0, r3, lsl #2
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   24ca2:	2b00      	cmp	r3, #0
   24ca4:	da03      	bge.n	24cae <uECC_vli_numBits+0x16>
	return (i + 1);
   24ca6:	3301      	adds	r3, #1
   24ca8:	b258      	sxtb	r0, r3
	if (num_digits == 0) {
   24caa:	b938      	cbnz	r0, 24cbc <uECC_vli_numBits+0x24>
   24cac:	4770      	bx	lr
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   24cae:	f851 0904 	ldr.w	r0, [r1], #-4
   24cb2:	2800      	cmp	r0, #0
   24cb4:	d1f7      	bne.n	24ca6 <uECC_vli_numBits+0xe>
   24cb6:	3b01      	subs	r3, #1
   24cb8:	b25b      	sxtb	r3, r3
   24cba:	e7f2      	b.n	24ca2 <uECC_vli_numBits+0xa>
	digit = vli[num_digits - 1];
   24cbc:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
   24cc0:	3b01      	subs	r3, #1
   24cc2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
	for (i = 0; digit; ++i) {
   24cc6:	2300      	movs	r3, #0
   24cc8:	b922      	cbnz	r2, 24cd4 <uECC_vli_numBits+0x3c>
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
   24cca:	3801      	subs	r0, #1
   24ccc:	eb03 1040 	add.w	r0, r3, r0, lsl #5
   24cd0:	b200      	sxth	r0, r0
}
   24cd2:	4770      	bx	lr
		digit >>= 1;
   24cd4:	0852      	lsrs	r2, r2, #1
	for (i = 0; digit; ++i) {
   24cd6:	3301      	adds	r3, #1
   24cd8:	e7f6      	b.n	24cc8 <uECC_vli_numBits+0x30>

00024cda <uECC_vli_set>:
{
   24cda:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   24cdc:	2300      	movs	r3, #0
   24cde:	b25c      	sxtb	r4, r3
   24ce0:	42a2      	cmp	r2, r4
   24ce2:	dc00      	bgt.n	24ce6 <uECC_vli_set+0xc>
}
   24ce4:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
   24ce6:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
   24cea:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
   24cee:	3301      	adds	r3, #1
   24cf0:	e7f5      	b.n	24cde <uECC_vli_set+0x4>

00024cf2 <uECC_vli_cmp_unsafe>:
{
   24cf2:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
   24cf4:	3a01      	subs	r2, #1
   24cf6:	b253      	sxtb	r3, r2
   24cf8:	009a      	lsls	r2, r3, #2
   24cfa:	2b00      	cmp	r3, #0
   24cfc:	da01      	bge.n	24d02 <uECC_vli_cmp_unsafe+0x10>
	return 0;
   24cfe:	2000      	movs	r0, #0
}
   24d00:	bd30      	pop	{r4, r5, pc}
		if (left[i] > right[i]) {
   24d02:	5885      	ldr	r5, [r0, r2]
   24d04:	588c      	ldr	r4, [r1, r2]
   24d06:	42a5      	cmp	r5, r4
   24d08:	d805      	bhi.n	24d16 <uECC_vli_cmp_unsafe+0x24>
		} else if (left[i] < right[i]) {
   24d0a:	f1a2 0204 	sub.w	r2, r2, #4
   24d0e:	d304      	bcc.n	24d1a <uECC_vli_cmp_unsafe+0x28>
	for (i = num_words - 1; i >= 0; --i) {
   24d10:	3b01      	subs	r3, #1
   24d12:	b25b      	sxtb	r3, r3
   24d14:	e7f1      	b.n	24cfa <uECC_vli_cmp_unsafe+0x8>
			return 1;
   24d16:	2001      	movs	r0, #1
   24d18:	e7f2      	b.n	24d00 <uECC_vli_cmp_unsafe+0xe>
			return -1;
   24d1a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24d1e:	e7ef      	b.n	24d00 <uECC_vli_cmp_unsafe+0xe>

00024d20 <uECC_vli_equal>:
	for (i = num_words - 1; i >= 0; --i) {
   24d20:	3a01      	subs	r2, #1
   24d22:	b253      	sxtb	r3, r2
{
   24d24:	b570      	push	{r4, r5, r6, lr}
   24d26:	009a      	lsls	r2, r3, #2
	uECC_word_t diff = 0;
   24d28:	2400      	movs	r4, #0
	for (i = num_words - 1; i >= 0; --i) {
   24d2a:	2b00      	cmp	r3, #0
   24d2c:	da03      	bge.n	24d36 <uECC_vli_equal+0x16>
}
   24d2e:	1e20      	subs	r0, r4, #0
   24d30:	bf18      	it	ne
   24d32:	2001      	movne	r0, #1
   24d34:	bd70      	pop	{r4, r5, r6, pc}
		diff |= (left[i] ^ right[i]);
   24d36:	5885      	ldr	r5, [r0, r2]
   24d38:	588e      	ldr	r6, [r1, r2]
	for (i = num_words - 1; i >= 0; --i) {
   24d3a:	3b01      	subs	r3, #1
		diff |= (left[i] ^ right[i]);
   24d3c:	4075      	eors	r5, r6
   24d3e:	432c      	orrs	r4, r5
	for (i = num_words - 1; i >= 0; --i) {
   24d40:	b25b      	sxtb	r3, r3
   24d42:	3a04      	subs	r2, #4
   24d44:	e7f1      	b.n	24d2a <uECC_vli_equal+0xa>

00024d46 <uECC_vli_sub>:
{
   24d46:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   24d48:	2400      	movs	r4, #0
{
   24d4a:	4606      	mov	r6, r0
   24d4c:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
   24d4e:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   24d50:	b265      	sxtb	r5, r4
   24d52:	45ac      	cmp	ip, r5
   24d54:	dc00      	bgt.n	24d58 <uECC_vli_sub+0x12>
}
   24d56:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
   24d58:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
   24d5c:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   24d60:	1a3d      	subs	r5, r7, r0
   24d62:	1aed      	subs	r5, r5, r3
		borrow = cond_set(val, borrow, (diff != left[i]));
   24d64:	42af      	cmp	r7, r5
		uECC_word_t val = (diff > left[i]);
   24d66:	bf34      	ite	cc
   24d68:	2701      	movcc	r7, #1
   24d6a:	2700      	movcs	r7, #0
		result[i] = diff;
   24d6c:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   24d70:	bf18      	it	ne
   24d72:	4638      	movne	r0, r7
	for (i = 0; i < num_words; ++i) {
   24d74:	3401      	adds	r4, #1
   24d76:	e7eb      	b.n	24d50 <uECC_vli_sub+0xa>

00024d78 <uECC_vli_modAdd>:
{
   24d78:	b570      	push	{r4, r5, r6, lr}
   24d7a:	f99d 6010 	ldrsb.w	r6, [sp, #16]
   24d7e:	461d      	mov	r5, r3
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   24d80:	4633      	mov	r3, r6
{
   24d82:	4604      	mov	r4, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   24d84:	f7ff feab 	bl	24ade <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
   24d88:	b930      	cbnz	r0, 24d98 <uECC_vli_modAdd+0x20>
   24d8a:	4632      	mov	r2, r6
   24d8c:	4621      	mov	r1, r4
   24d8e:	4628      	mov	r0, r5
   24d90:	f7ff ffaf 	bl	24cf2 <uECC_vli_cmp_unsafe>
   24d94:	2801      	cmp	r0, #1
   24d96:	d007      	beq.n	24da8 <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
   24d98:	4633      	mov	r3, r6
   24d9a:	462a      	mov	r2, r5
   24d9c:	4621      	mov	r1, r4
   24d9e:	4620      	mov	r0, r4
}
   24da0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
   24da4:	f7ff bfcf 	b.w	24d46 <uECC_vli_sub>
}
   24da8:	bd70      	pop	{r4, r5, r6, pc}

00024daa <uECC_vli_modSub>:
{
   24daa:	b570      	push	{r4, r5, r6, lr}
   24dac:	f99d 6010 	ldrsb.w	r6, [sp, #16]
   24db0:	461d      	mov	r5, r3
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   24db2:	4633      	mov	r3, r6
{
   24db4:	4604      	mov	r4, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   24db6:	f7ff ffc6 	bl	24d46 <uECC_vli_sub>
	if (l_borrow) {
   24dba:	b138      	cbz	r0, 24dcc <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
   24dbc:	4633      	mov	r3, r6
   24dbe:	462a      	mov	r2, r5
   24dc0:	4621      	mov	r1, r4
   24dc2:	4620      	mov	r0, r4
}
   24dc4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
   24dc8:	f7ff be89 	b.w	24ade <uECC_vli_add>
}
   24dcc:	bd70      	pop	{r4, r5, r6, pc}

00024dce <uECC_vli_mmod>:
{
   24dce:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24dd2:	b0a5      	sub	sp, #148	; 0x94
   24dd4:	461d      	mov	r5, r3
	uECC_word_t *v[2] = {tmp, product};
   24dd6:	ab14      	add	r3, sp, #80	; 0x50
   24dd8:	e9cd 3102 	strd	r3, r1, [sp, #8]
{
   24ddc:	4680      	mov	r8, r0
			   uECC_vli_numBits(mod, num_words);
   24dde:	4629      	mov	r1, r5
   24de0:	4610      	mov	r0, r2
{
   24de2:	4616      	mov	r6, r2
			   uECC_vli_numBits(mod, num_words);
   24de4:	f7ff ff58 	bl	24c98 <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
   24de8:	ebc0 1485 	rsb	r4, r0, r5, lsl #6
   24dec:	b224      	sxth	r4, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   24dee:	2c00      	cmp	r4, #0
   24df0:	4621      	mov	r1, r4
   24df2:	bfb8      	it	lt
   24df4:	f104 011f 	addlt.w	r1, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   24df8:	4263      	negs	r3, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   24dfa:	f341 1147 	sbfx	r1, r1, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   24dfe:	f003 031f 	and.w	r3, r3, #31
	uECC_vli_clear(mod_multiple, word_shift);
   24e02:	a804      	add	r0, sp, #16
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   24e04:	f004 071f 	and.w	r7, r4, #31
   24e08:	bf58      	it	pl
   24e0a:	425f      	negpl	r7, r3
	uECC_vli_clear(mod_multiple, word_shift);
   24e0c:	f7ff ff20 	bl	24c50 <uECC_vli_clear>
	if (bit_shift > 0) {
   24e10:	2f00      	cmp	r7, #0
   24e12:	b208      	sxth	r0, r1
   24e14:	dd2b      	ble.n	24e6e <uECC_vli_mmod+0xa0>
   24e16:	ab04      	add	r3, sp, #16
	uECC_word_t carry = 0;
   24e18:	2200      	movs	r2, #0
   24e1a:	eb03 0180 	add.w	r1, r3, r0, lsl #2
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   24e1e:	f1c7 0e20 	rsb	lr, r7, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   24e22:	4613      	mov	r3, r2
   24e24:	429d      	cmp	r5, r3
   24e26:	d817      	bhi.n	24e58 <uECC_vli_mmod+0x8a>
		for (i = 0; i < num_words * 2; ++i) {
   24e28:	006b      	lsls	r3, r5, #1
   24e2a:	9301      	str	r3, [sp, #4]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   24e2c:	ab04      	add	r3, sp, #16
   24e2e:	eb03 0985 	add.w	r9, r3, r5, lsl #2
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   24e32:	1e6f      	subs	r7, r5, #1
   24e34:	ab24      	add	r3, sp, #144	; 0x90
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   24e36:	2601      	movs	r6, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   24e38:	eb03 0787 	add.w	r7, r3, r7, lsl #2
	for (index = 1; shift >= 0; --shift) {
   24e3c:	2c00      	cmp	r4, #0
   24e3e:	da54      	bge.n	24eea <uECC_vli_mmod+0x11c>
	uECC_vli_set(result, v[index], num_words);
   24e40:	ab24      	add	r3, sp, #144	; 0x90
   24e42:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   24e46:	462a      	mov	r2, r5
   24e48:	f856 1c88 	ldr.w	r1, [r6, #-136]
   24e4c:	4640      	mov	r0, r8
   24e4e:	f7ff ff44 	bl	24cda <uECC_vli_set>
}
   24e52:	b025      	add	sp, #148	; 0x94
   24e54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
   24e58:	f856 c023 	ldr.w	ip, [r6, r3, lsl #2]
   24e5c:	fa0c f007 	lsl.w	r0, ip, r7
   24e60:	4302      	orrs	r2, r0
   24e62:	f841 2b04 	str.w	r2, [r1], #4
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   24e66:	3301      	adds	r3, #1
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   24e68:	fa2c f20e 	lsr.w	r2, ip, lr
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   24e6c:	e7da      	b.n	24e24 <uECC_vli_mmod+0x56>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
   24e6e:	ab04      	add	r3, sp, #16
   24e70:	462a      	mov	r2, r5
   24e72:	4631      	mov	r1, r6
   24e74:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   24e78:	f7ff ff2f 	bl	24cda <uECC_vli_set>
   24e7c:	e7d4      	b.n	24e28 <uECC_vli_mmod+0x5a>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   24e7e:	fa0f fe82 	sxth.w	lr, r2
   24e82:	f85a 3c88 	ldr.w	r3, [sl, #-136]
   24e86:	f853 b02e 	ldr.w	fp, [r3, lr, lsl #2]
   24e8a:	ab24      	add	r3, sp, #144	; 0x90
   24e8c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   24e90:	3001      	adds	r0, #1
   24e92:	f852 3c80 	ldr.w	r3, [r2, #-128]
   24e96:	440b      	add	r3, r1
   24e98:	ebbb 0303 	subs.w	r3, fp, r3
   24e9c:	bf34      	ite	cc
   24e9e:	2201      	movcc	r2, #1
   24ea0:	2200      	movcs	r2, #0
			if (diff != v[index][i]) {
   24ea2:	459b      	cmp	fp, r3
				borrow = (diff > v[index][i]);
   24ea4:	bf18      	it	ne
   24ea6:	4611      	movne	r1, r2
			v[1 - index][i] = diff;
   24ea8:	f85c 2c88 	ldr.w	r2, [ip, #-136]
   24eac:	f842 302e 	str.w	r3, [r2, lr, lsl #2]
		for (i = 0; i < num_words * 2; ++i) {
   24eb0:	9b01      	ldr	r3, [sp, #4]
   24eb2:	b242      	sxtb	r2, r0
   24eb4:	429a      	cmp	r2, r3
   24eb6:	dbe2      	blt.n	24e7e <uECC_vli_mmod+0xb0>
		index = !(index ^ borrow);
   24eb8:	1a73      	subs	r3, r6, r1
   24eba:	425e      	negs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   24ebc:	4629      	mov	r1, r5
   24ebe:	a804      	add	r0, sp, #16
		index = !(index ^ borrow);
   24ec0:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   24ec2:	f7ff fe24 	bl	24b0e <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   24ec6:	ab24      	add	r3, sp, #144	; 0x90
   24ec8:	eb03 0385 	add.w	r3, r3, r5, lsl #2
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   24ecc:	4629      	mov	r1, r5
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   24ece:	f853 2c80 	ldr.w	r2, [r3, #-128]
   24ed2:	f857 3c80 	ldr.w	r3, [r7, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   24ed6:	4648      	mov	r0, r9
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   24ed8:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
	for (index = 1; shift >= 0; --shift) {
   24edc:	3c01      	subs	r4, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   24ede:	f847 3c80 	str.w	r3, [r7, #-128]
	for (index = 1; shift >= 0; --shift) {
   24ee2:	b224      	sxth	r4, r4
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   24ee4:	f7ff fe13 	bl	24b0e <uECC_vli_rshift1>
	for (index = 1; shift >= 0; --shift) {
   24ee8:	e7a8      	b.n	24e3c <uECC_vli_mmod+0x6e>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   24eea:	ab24      	add	r3, sp, #144	; 0x90
   24eec:	2000      	movs	r0, #0
			v[1 - index][i] = diff;
   24eee:	f1c6 0c01 	rsb	ip, r6, #1
		uECC_word_t borrow = 0;
   24ef2:	4601      	mov	r1, r0
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   24ef4:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
   24ef8:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
   24efc:	e7d8      	b.n	24eb0 <uECC_vli_mmod+0xe2>

00024efe <uECC_vli_modMult_fast>:
{
   24efe:	b530      	push	{r4, r5, lr}
   24f00:	461c      	mov	r4, r3
   24f02:	b091      	sub	sp, #68	; 0x44
   24f04:	4605      	mov	r5, r0
	uECC_vli_mult(product, left, right, curve->num_words);
   24f06:	f993 3000 	ldrsb.w	r3, [r3]
   24f0a:	4668      	mov	r0, sp
   24f0c:	f7ff fe28 	bl	24b60 <uECC_vli_mult>
	curve->mmod_fast(result, product);
   24f10:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
   24f14:	4669      	mov	r1, sp
   24f16:	4628      	mov	r0, r5
   24f18:	4798      	blx	r3
}
   24f1a:	b011      	add	sp, #68	; 0x44
   24f1c:	bd30      	pop	{r4, r5, pc}

00024f1e <uECC_vli_modSquare_fast>:
{
   24f1e:	4613      	mov	r3, r2
	uECC_vli_modMult_fast(result, left, left, curve);
   24f20:	460a      	mov	r2, r1
   24f22:	f7ff bfec 	b.w	24efe <uECC_vli_modMult_fast>

00024f26 <double_jacobian_default>:
{
   24f26:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
   24f2a:	f993 6000 	ldrsb.w	r6, [r3]
{
   24f2e:	b092      	sub	sp, #72	; 0x48
   24f30:	4604      	mov	r4, r0
   24f32:	4689      	mov	r9, r1
	if (uECC_vli_isZero(Z1, num_words)) {
   24f34:	4610      	mov	r0, r2
   24f36:	4631      	mov	r1, r6
{
   24f38:	4615      	mov	r5, r2
   24f3a:	461f      	mov	r7, r3
	if (uECC_vli_isZero(Z1, num_words)) {
   24f3c:	f7ff fe93 	bl	24c66 <uECC_vli_isZero>
   24f40:	2800      	cmp	r0, #0
   24f42:	f040 8091 	bne.w	25068 <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
   24f46:	463a      	mov	r2, r7
   24f48:	4649      	mov	r1, r9
   24f4a:	a802      	add	r0, sp, #8
   24f4c:	f7ff ffe7 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
   24f50:	463b      	mov	r3, r7
   24f52:	aa02      	add	r2, sp, #8
   24f54:	4621      	mov	r1, r4
   24f56:	a80a      	add	r0, sp, #40	; 0x28
   24f58:	f7ff ffd1 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
   24f5c:	a902      	add	r1, sp, #8
   24f5e:	4608      	mov	r0, r1
   24f60:	463a      	mov	r2, r7
   24f62:	f7ff ffdc 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
   24f66:	463b      	mov	r3, r7
   24f68:	462a      	mov	r2, r5
   24f6a:	4649      	mov	r1, r9
   24f6c:	4648      	mov	r0, r9
   24f6e:	f7ff ffc6 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   24f72:	f107 0804 	add.w	r8, r7, #4
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
   24f76:	463a      	mov	r2, r7
   24f78:	4629      	mov	r1, r5
   24f7a:	4628      	mov	r0, r5
   24f7c:	f7ff ffcf 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   24f80:	4643      	mov	r3, r8
   24f82:	462a      	mov	r2, r5
   24f84:	4621      	mov	r1, r4
   24f86:	4620      	mov	r0, r4
   24f88:	9600      	str	r6, [sp, #0]
   24f8a:	f7ff fef5 	bl	24d78 <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
   24f8e:	4643      	mov	r3, r8
   24f90:	462a      	mov	r2, r5
   24f92:	4629      	mov	r1, r5
   24f94:	4628      	mov	r0, r5
   24f96:	9600      	str	r6, [sp, #0]
   24f98:	f7ff feee 	bl	24d78 <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
   24f9c:	4643      	mov	r3, r8
   24f9e:	462a      	mov	r2, r5
   24fa0:	4621      	mov	r1, r4
   24fa2:	4628      	mov	r0, r5
   24fa4:	9600      	str	r6, [sp, #0]
   24fa6:	f7ff ff00 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
   24faa:	463b      	mov	r3, r7
   24fac:	462a      	mov	r2, r5
   24fae:	4621      	mov	r1, r4
   24fb0:	4620      	mov	r0, r4
   24fb2:	f7ff ffa4 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
   24fb6:	4643      	mov	r3, r8
   24fb8:	4622      	mov	r2, r4
   24fba:	4621      	mov	r1, r4
   24fbc:	4628      	mov	r0, r5
   24fbe:	9600      	str	r6, [sp, #0]
   24fc0:	f7ff feda 	bl	24d78 <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
   24fc4:	4643      	mov	r3, r8
   24fc6:	9600      	str	r6, [sp, #0]
   24fc8:	462a      	mov	r2, r5
   24fca:	4621      	mov	r1, r4
   24fcc:	4620      	mov	r0, r4
   24fce:	f7ff fed3 	bl	24d78 <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   24fd2:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
   24fd4:	07db      	lsls	r3, r3, #31
   24fd6:	d54a      	bpl.n	2506e <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   24fd8:	4633      	mov	r3, r6
   24fda:	4642      	mov	r2, r8
   24fdc:	4621      	mov	r1, r4
   24fde:	4620      	mov	r0, r4
   24fe0:	f7ff fd7d 	bl	24ade <uECC_vli_add>
		uECC_vli_rshift1(X1, num_words);
   24fe4:	4631      	mov	r1, r6
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   24fe6:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
   24fe8:	4620      	mov	r0, r4
   24fea:	f7ff fd90 	bl	24b0e <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
   24fee:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
   24ff2:	3b01      	subs	r3, #1
   24ff4:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
   24ff8:	ea42 72ca 	orr.w	r2, r2, sl, lsl #31
   24ffc:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
   25000:	463a      	mov	r2, r7
   25002:	4621      	mov	r1, r4
   25004:	4628      	mov	r0, r5
   25006:	f7ff ff8a 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
   2500a:	4643      	mov	r3, r8
   2500c:	aa0a      	add	r2, sp, #40	; 0x28
   2500e:	4629      	mov	r1, r5
   25010:	4628      	mov	r0, r5
   25012:	9600      	str	r6, [sp, #0]
   25014:	f7ff fec9 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
   25018:	4643      	mov	r3, r8
   2501a:	aa0a      	add	r2, sp, #40	; 0x28
   2501c:	4629      	mov	r1, r5
   2501e:	4628      	mov	r0, r5
   25020:	9600      	str	r6, [sp, #0]
   25022:	f7ff fec2 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
   25026:	a90a      	add	r1, sp, #40	; 0x28
   25028:	4608      	mov	r0, r1
   2502a:	4643      	mov	r3, r8
   2502c:	462a      	mov	r2, r5
   2502e:	9600      	str	r6, [sp, #0]
   25030:	f7ff febb 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
   25034:	463b      	mov	r3, r7
   25036:	aa0a      	add	r2, sp, #40	; 0x28
   25038:	4621      	mov	r1, r4
   2503a:	4620      	mov	r0, r4
   2503c:	f7ff ff5f 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
   25040:	aa02      	add	r2, sp, #8
   25042:	4643      	mov	r3, r8
   25044:	4610      	mov	r0, r2
   25046:	4621      	mov	r1, r4
   25048:	9600      	str	r6, [sp, #0]
   2504a:	f7ff feae 	bl	24daa <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
   2504e:	4632      	mov	r2, r6
   25050:	4629      	mov	r1, r5
   25052:	4620      	mov	r0, r4
   25054:	f7ff fe41 	bl	24cda <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
   25058:	4649      	mov	r1, r9
   2505a:	4628      	mov	r0, r5
   2505c:	f7ff fe3d 	bl	24cda <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
   25060:	a902      	add	r1, sp, #8
   25062:	4648      	mov	r0, r9
   25064:	f7ff fe39 	bl	24cda <uECC_vli_set>
}
   25068:	b012      	add	sp, #72	; 0x48
   2506a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
   2506e:	4631      	mov	r1, r6
   25070:	4620      	mov	r0, r4
   25072:	f7ff fd4c 	bl	24b0e <uECC_vli_rshift1>
   25076:	e7c3      	b.n	25000 <double_jacobian_default+0xda>

00025078 <x_side_default>:
{
   25078:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2507c:	4615      	mov	r5, r2
   2507e:	b08a      	sub	sp, #40	; 0x28
   25080:	4604      	mov	r4, r0
   25082:	460e      	mov	r6, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   25084:	221c      	movs	r2, #28
   25086:	2100      	movs	r1, #0
   25088:	a803      	add	r0, sp, #12
   2508a:	f000 fe38 	bl	25cfe <memset>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   2508e:	1d2f      	adds	r7, r5, #4
	wordcount_t num_words = curve->num_words;
   25090:	f995 8000 	ldrsb.w	r8, [r5]
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   25094:	2303      	movs	r3, #3
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   25096:	462a      	mov	r2, r5
   25098:	4631      	mov	r1, r6
   2509a:	4620      	mov	r0, r4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   2509c:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   2509e:	f7ff ff3e 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   250a2:	463b      	mov	r3, r7
   250a4:	aa02      	add	r2, sp, #8
   250a6:	4621      	mov	r1, r4
   250a8:	4620      	mov	r0, r4
   250aa:	f8cd 8000 	str.w	r8, [sp]
   250ae:	f7ff fe7c 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
   250b2:	462b      	mov	r3, r5
   250b4:	4632      	mov	r2, r6
   250b6:	4621      	mov	r1, r4
   250b8:	4620      	mov	r0, r4
   250ba:	f7ff ff20 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
   250be:	f8cd 8000 	str.w	r8, [sp]
   250c2:	463b      	mov	r3, r7
   250c4:	f105 0284 	add.w	r2, r5, #132	; 0x84
   250c8:	4621      	mov	r1, r4
   250ca:	4620      	mov	r0, r4
   250cc:	f7ff fe54 	bl	24d78 <uECC_vli_modAdd>
}
   250d0:	b00a      	add	sp, #40	; 0x28
   250d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000250d6 <XYcZ_addC>:
   or P => P - Q, Q => P + Q
 */
static void XYcZ_addC(uECC_word_t * X1, uECC_word_t * Y1,
		      uECC_word_t * X2, uECC_word_t * Y2,
		      uECC_Curve curve)
{
   250d6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   250da:	b09a      	sub	sp, #104	; 0x68
   250dc:	4616      	mov	r6, r2
   250de:	f8dd 8088 	ldr.w	r8, [sp, #136]	; 0x88
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	uECC_word_t t6[NUM_ECC_WORDS];
	uECC_word_t t7[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   250e2:	4644      	mov	r4, r8
{
   250e4:	4699      	mov	r9, r3
	wordcount_t num_words = curve->num_words;
   250e6:	f914 5b04 	ldrsb.w	r5, [r4], #4

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   250ea:	9500      	str	r5, [sp, #0]
{
   250ec:	4607      	mov	r7, r0
   250ee:	468a      	mov	sl, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   250f0:	4623      	mov	r3, r4
   250f2:	4602      	mov	r2, r0
   250f4:	4631      	mov	r1, r6
   250f6:	a802      	add	r0, sp, #8
   250f8:	f7ff fe57 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   250fc:	a902      	add	r1, sp, #8
   250fe:	4642      	mov	r2, r8
   25100:	4608      	mov	r0, r1
   25102:	f7ff ff0c 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   25106:	4643      	mov	r3, r8
   25108:	aa02      	add	r2, sp, #8
   2510a:	4639      	mov	r1, r7
   2510c:	4638      	mov	r0, r7
   2510e:	f7ff fef6 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   25112:	4643      	mov	r3, r8
   25114:	aa02      	add	r2, sp, #8
   25116:	4631      	mov	r1, r6
   25118:	4630      	mov	r0, r6
   2511a:	f7ff fef0 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
   2511e:	4623      	mov	r3, r4
   25120:	4652      	mov	r2, sl
   25122:	4649      	mov	r1, r9
   25124:	a802      	add	r0, sp, #8
   25126:	9500      	str	r5, [sp, #0]
   25128:	f7ff fe26 	bl	24d78 <uECC_vli_modAdd>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   2512c:	4623      	mov	r3, r4
   2512e:	4652      	mov	r2, sl
   25130:	4649      	mov	r1, r9
   25132:	4648      	mov	r0, r9
   25134:	9500      	str	r5, [sp, #0]
   25136:	f7ff fe38 	bl	24daa <uECC_vli_modSub>

	uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
   2513a:	4623      	mov	r3, r4
   2513c:	463a      	mov	r2, r7
   2513e:	4631      	mov	r1, r6
   25140:	a80a      	add	r0, sp, #40	; 0x28
   25142:	9500      	str	r5, [sp, #0]
   25144:	f7ff fe31 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, t6, curve); /* t2 = y1 * (C - B) = E */
   25148:	4643      	mov	r3, r8
   2514a:	aa0a      	add	r2, sp, #40	; 0x28
   2514c:	4651      	mov	r1, sl
   2514e:	4650      	mov	r0, sl
   25150:	f7ff fed5 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
   25154:	4623      	mov	r3, r4
   25156:	4632      	mov	r2, r6
   25158:	4639      	mov	r1, r7
   2515a:	a80a      	add	r0, sp, #40	; 0x28
   2515c:	9500      	str	r5, [sp, #0]
   2515e:	f7ff fe0b 	bl	24d78 <uECC_vli_modAdd>
	uECC_vli_modSquare_fast(X2, Y2, curve); /* t3 = (y2 - y1)^2 = D */
   25162:	4642      	mov	r2, r8
   25164:	4649      	mov	r1, r9
   25166:	4630      	mov	r0, r6
   25168:	f7ff fed9 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
   2516c:	4623      	mov	r3, r4
   2516e:	aa0a      	add	r2, sp, #40	; 0x28
   25170:	4631      	mov	r1, r6
   25172:	4630      	mov	r0, r6
   25174:	9500      	str	r5, [sp, #0]
   25176:	f7ff fe18 	bl	24daa <uECC_vli_modSub>

	uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
   2517a:	4623      	mov	r3, r4
   2517c:	4632      	mov	r2, r6
   2517e:	4639      	mov	r1, r7
   25180:	a812      	add	r0, sp, #72	; 0x48
   25182:	9500      	str	r5, [sp, #0]
   25184:	f7ff fe11 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, t7, curve); /* t4 = (y2 - y1)*(B - x3) */
   25188:	4643      	mov	r3, r8
   2518a:	aa12      	add	r2, sp, #72	; 0x48
   2518c:	4649      	mov	r1, r9
   2518e:	4648      	mov	r0, r9
   25190:	f7ff feb5 	bl	24efe <uECC_vli_modMult_fast>
	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words);
   25194:	4623      	mov	r3, r4
   25196:	4652      	mov	r2, sl
   25198:	4649      	mov	r1, r9
   2519a:	4648      	mov	r0, r9
   2519c:	9500      	str	r5, [sp, #0]
   2519e:	f7ff fe04 	bl	24daa <uECC_vli_modSub>

	uECC_vli_modSquare_fast(t7, t5, curve); /* t7 = (y2 + y1)^2 = F */
   251a2:	4642      	mov	r2, r8
   251a4:	a902      	add	r1, sp, #8
   251a6:	a812      	add	r0, sp, #72	; 0x48
   251a8:	f7ff feb9 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
   251ac:	a912      	add	r1, sp, #72	; 0x48
   251ae:	4623      	mov	r3, r4
   251b0:	aa0a      	add	r2, sp, #40	; 0x28
   251b2:	4608      	mov	r0, r1
   251b4:	9500      	str	r5, [sp, #0]
   251b6:	f7ff fdf8 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
   251ba:	4623      	mov	r3, r4
   251bc:	463a      	mov	r2, r7
   251be:	a912      	add	r1, sp, #72	; 0x48
   251c0:	a80a      	add	r0, sp, #40	; 0x28
   251c2:	9500      	str	r5, [sp, #0]
   251c4:	f7ff fdf1 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modMult_fast(t6, t6, t5, curve); /* t6 = (y2+y1)*(x3' - B) */
   251c8:	a90a      	add	r1, sp, #40	; 0x28
   251ca:	4643      	mov	r3, r8
   251cc:	aa02      	add	r2, sp, #8
   251ce:	4608      	mov	r0, r1
   251d0:	f7ff fe95 	bl	24efe <uECC_vli_modMult_fast>
	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
	uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words);
   251d4:	4623      	mov	r3, r4
   251d6:	4652      	mov	r2, sl
   251d8:	a90a      	add	r1, sp, #40	; 0x28
   251da:	4650      	mov	r0, sl
   251dc:	9500      	str	r5, [sp, #0]
   251de:	f7ff fde4 	bl	24daa <uECC_vli_modSub>

	uECC_vli_set(X1, t7, num_words);
   251e2:	462a      	mov	r2, r5
   251e4:	a912      	add	r1, sp, #72	; 0x48
   251e6:	4638      	mov	r0, r7
   251e8:	f7ff fd77 	bl	24cda <uECC_vli_set>
}
   251ec:	b01a      	add	sp, #104	; 0x68
   251ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000251f2 <uECC_vli_modInv>:
{
   251f2:	b5f0      	push	{r4, r5, r6, r7, lr}
   251f4:	460f      	mov	r7, r1
   251f6:	b0a1      	sub	sp, #132	; 0x84
   251f8:	4606      	mov	r6, r0
	if (uECC_vli_isZero(input, num_words)) {
   251fa:	4619      	mov	r1, r3
   251fc:	4638      	mov	r0, r7
{
   251fe:	4615      	mov	r5, r2
   25200:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
   25202:	f7ff fd30 	bl	24c66 <uECC_vli_isZero>
   25206:	b120      	cbz	r0, 25212 <uECC_vli_modInv+0x20>
		uECC_vli_clear(result, num_words);
   25208:	4630      	mov	r0, r6
   2520a:	f7ff fd21 	bl	24c50 <uECC_vli_clear>
}
   2520e:	b021      	add	sp, #132	; 0x84
   25210:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uECC_vli_set(a, input, num_words);
   25212:	4622      	mov	r2, r4
   25214:	4639      	mov	r1, r7
   25216:	4668      	mov	r0, sp
   25218:	f7ff fd5f 	bl	24cda <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
   2521c:	4629      	mov	r1, r5
   2521e:	a808      	add	r0, sp, #32
   25220:	f7ff fd5b 	bl	24cda <uECC_vli_set>
	uECC_vli_clear(u, num_words);
   25224:	a810      	add	r0, sp, #64	; 0x40
   25226:	4621      	mov	r1, r4
   25228:	f7ff fd12 	bl	24c50 <uECC_vli_clear>
	u[0] = 1;
   2522c:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
   2522e:	a818      	add	r0, sp, #96	; 0x60
	u[0] = 1;
   25230:	9310      	str	r3, [sp, #64]	; 0x40
	uECC_vli_clear(v, num_words);
   25232:	f7ff fd0d 	bl	24c50 <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
   25236:	4622      	mov	r2, r4
   25238:	a908      	add	r1, sp, #32
   2523a:	4668      	mov	r0, sp
   2523c:	f7ff fd59 	bl	24cf2 <uECC_vli_cmp_unsafe>
   25240:	b928      	cbnz	r0, 2524e <uECC_vli_modInv+0x5c>
  	uECC_vli_set(result, u, num_words);
   25242:	4622      	mov	r2, r4
   25244:	a910      	add	r1, sp, #64	; 0x40
   25246:	4630      	mov	r0, r6
   25248:	f7ff fd47 	bl	24cda <uECC_vli_set>
   2524c:	e7df      	b.n	2520e <uECC_vli_modInv+0x1c>
		if (EVEN(a)) {
   2524e:	9b00      	ldr	r3, [sp, #0]
   25250:	07da      	lsls	r2, r3, #31
   25252:	d409      	bmi.n	25268 <uECC_vli_modInv+0x76>
			uECC_vli_rshift1(a, num_words);
   25254:	4621      	mov	r1, r4
   25256:	4668      	mov	r0, sp
   25258:	f7ff fc59 	bl	24b0e <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
   2525c:	4622      	mov	r2, r4
   2525e:	4629      	mov	r1, r5
   25260:	a810      	add	r0, sp, #64	; 0x40
      			vli_modInv_update(v, mod, num_words);
   25262:	f7ff fc61 	bl	24b28 <vli_modInv_update>
   25266:	e7e6      	b.n	25236 <uECC_vli_modInv+0x44>
    		} else if (EVEN(b)) {
   25268:	9b08      	ldr	r3, [sp, #32]
   2526a:	07db      	lsls	r3, r3, #31
   2526c:	d407      	bmi.n	2527e <uECC_vli_modInv+0x8c>
			uECC_vli_rshift1(b, num_words);
   2526e:	4621      	mov	r1, r4
   25270:	a808      	add	r0, sp, #32
   25272:	f7ff fc4c 	bl	24b0e <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
   25276:	4622      	mov	r2, r4
   25278:	4629      	mov	r1, r5
   2527a:	a818      	add	r0, sp, #96	; 0x60
   2527c:	e7f1      	b.n	25262 <uECC_vli_modInv+0x70>
		} else if (cmpResult > 0) {
   2527e:	2800      	cmp	r0, #0
			uECC_vli_sub(a, a, b, num_words);
   25280:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
   25282:	dd1c      	ble.n	252be <uECC_vli_modInv+0xcc>
			uECC_vli_sub(a, a, b, num_words);
   25284:	aa08      	add	r2, sp, #32
   25286:	4669      	mov	r1, sp
   25288:	4668      	mov	r0, sp
   2528a:	f7ff fd5c 	bl	24d46 <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
   2528e:	4621      	mov	r1, r4
   25290:	4668      	mov	r0, sp
   25292:	f7ff fc3c 	bl	24b0e <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
   25296:	4622      	mov	r2, r4
   25298:	a918      	add	r1, sp, #96	; 0x60
   2529a:	a810      	add	r0, sp, #64	; 0x40
   2529c:	f7ff fd29 	bl	24cf2 <uECC_vli_cmp_unsafe>
   252a0:	2800      	cmp	r0, #0
   252a2:	da05      	bge.n	252b0 <uECC_vli_modInv+0xbe>
        			uECC_vli_add(u, u, mod, num_words);
   252a4:	a910      	add	r1, sp, #64	; 0x40
   252a6:	4623      	mov	r3, r4
   252a8:	462a      	mov	r2, r5
   252aa:	4608      	mov	r0, r1
   252ac:	f7ff fc17 	bl	24ade <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
   252b0:	a910      	add	r1, sp, #64	; 0x40
   252b2:	4623      	mov	r3, r4
   252b4:	aa18      	add	r2, sp, #96	; 0x60
   252b6:	4608      	mov	r0, r1
   252b8:	f7ff fd45 	bl	24d46 <uECC_vli_sub>
   252bc:	e7ce      	b.n	2525c <uECC_vli_modInv+0x6a>
      			uECC_vli_sub(b, b, a, num_words);
   252be:	a908      	add	r1, sp, #32
   252c0:	466a      	mov	r2, sp
   252c2:	4608      	mov	r0, r1
   252c4:	f7ff fd3f 	bl	24d46 <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
   252c8:	4621      	mov	r1, r4
   252ca:	a808      	add	r0, sp, #32
   252cc:	f7ff fc1f 	bl	24b0e <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
   252d0:	4622      	mov	r2, r4
   252d2:	a910      	add	r1, sp, #64	; 0x40
   252d4:	a818      	add	r0, sp, #96	; 0x60
   252d6:	f7ff fd0c 	bl	24cf2 <uECC_vli_cmp_unsafe>
   252da:	2800      	cmp	r0, #0
   252dc:	da05      	bge.n	252ea <uECC_vli_modInv+0xf8>
        			uECC_vli_add(v, v, mod, num_words);
   252de:	a918      	add	r1, sp, #96	; 0x60
   252e0:	4623      	mov	r3, r4
   252e2:	462a      	mov	r2, r5
   252e4:	4608      	mov	r0, r1
   252e6:	f7ff fbfa 	bl	24ade <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
   252ea:	a918      	add	r1, sp, #96	; 0x60
   252ec:	4623      	mov	r3, r4
   252ee:	aa10      	add	r2, sp, #64	; 0x40
   252f0:	4608      	mov	r0, r1
   252f2:	f7ff fd28 	bl	24d46 <uECC_vli_sub>
   252f6:	e7be      	b.n	25276 <uECC_vli_modInv+0x84>

000252f8 <EccPoint_isZero>:
	return uECC_vli_isZero(point, curve->num_words * 2);
   252f8:	7809      	ldrb	r1, [r1, #0]
   252fa:	0049      	lsls	r1, r1, #1
   252fc:	b249      	sxtb	r1, r1
   252fe:	f7ff bcb2 	b.w	24c66 <uECC_vli_isZero>

00025302 <apply_z>:
{
   25302:	b5f0      	push	{r4, r5, r6, r7, lr}
   25304:	4615      	mov	r5, r2
   25306:	b089      	sub	sp, #36	; 0x24
   25308:	461c      	mov	r4, r3
   2530a:	4607      	mov	r7, r0
   2530c:	460e      	mov	r6, r1
	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
   2530e:	461a      	mov	r2, r3
   25310:	4629      	mov	r1, r5
   25312:	4668      	mov	r0, sp
   25314:	f7ff fe03 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
   25318:	4623      	mov	r3, r4
   2531a:	466a      	mov	r2, sp
   2531c:	4639      	mov	r1, r7
   2531e:	4638      	mov	r0, r7
   25320:	f7ff fded 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
   25324:	4623      	mov	r3, r4
   25326:	462a      	mov	r2, r5
   25328:	4669      	mov	r1, sp
   2532a:	4668      	mov	r0, sp
   2532c:	f7ff fde7 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
   25330:	4623      	mov	r3, r4
   25332:	466a      	mov	r2, sp
   25334:	4631      	mov	r1, r6
   25336:	4630      	mov	r0, r6
   25338:	f7ff fde1 	bl	24efe <uECC_vli_modMult_fast>
}
   2533c:	b009      	add	sp, #36	; 0x24
   2533e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00025340 <XYcZ_add>:
{
   25340:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   25344:	b08a      	sub	sp, #40	; 0x28
   25346:	4614      	mov	r4, r2
   25348:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
	wordcount_t num_words = curve->num_words;
   2534c:	4655      	mov	r5, sl
{
   2534e:	461f      	mov	r7, r3
	wordcount_t num_words = curve->num_words;
   25350:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   25354:	9600      	str	r6, [sp, #0]
{
   25356:	4680      	mov	r8, r0
   25358:	4689      	mov	r9, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   2535a:	462b      	mov	r3, r5
   2535c:	4602      	mov	r2, r0
   2535e:	4621      	mov	r1, r4
   25360:	a802      	add	r0, sp, #8
   25362:	f7ff fd22 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   25366:	a902      	add	r1, sp, #8
   25368:	4652      	mov	r2, sl
   2536a:	4608      	mov	r0, r1
   2536c:	f7ff fdd7 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   25370:	4653      	mov	r3, sl
   25372:	aa02      	add	r2, sp, #8
   25374:	4641      	mov	r1, r8
   25376:	4640      	mov	r0, r8
   25378:	f7ff fdc1 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   2537c:	4653      	mov	r3, sl
   2537e:	aa02      	add	r2, sp, #8
   25380:	4621      	mov	r1, r4
   25382:	4620      	mov	r0, r4
   25384:	f7ff fdbb 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   25388:	462b      	mov	r3, r5
   2538a:	464a      	mov	r2, r9
   2538c:	4639      	mov	r1, r7
   2538e:	4638      	mov	r0, r7
   25390:	9600      	str	r6, [sp, #0]
   25392:	f7ff fd0a 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
   25396:	4652      	mov	r2, sl
   25398:	4639      	mov	r1, r7
   2539a:	a802      	add	r0, sp, #8
   2539c:	f7ff fdbf 	bl	24f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
   253a0:	a902      	add	r1, sp, #8
   253a2:	462b      	mov	r3, r5
   253a4:	4642      	mov	r2, r8
   253a6:	4608      	mov	r0, r1
   253a8:	9600      	str	r6, [sp, #0]
   253aa:	f7ff fcfe 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
   253ae:	a902      	add	r1, sp, #8
   253b0:	462b      	mov	r3, r5
   253b2:	4622      	mov	r2, r4
   253b4:	4608      	mov	r0, r1
   253b6:	9600      	str	r6, [sp, #0]
   253b8:	f7ff fcf7 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
   253bc:	462b      	mov	r3, r5
   253be:	4642      	mov	r2, r8
   253c0:	4621      	mov	r1, r4
   253c2:	4620      	mov	r0, r4
   253c4:	9600      	str	r6, [sp, #0]
   253c6:	f7ff fcf0 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
   253ca:	4653      	mov	r3, sl
   253cc:	4622      	mov	r2, r4
   253ce:	4649      	mov	r1, r9
   253d0:	4648      	mov	r0, r9
   253d2:	f7ff fd94 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
   253d6:	462b      	mov	r3, r5
   253d8:	aa02      	add	r2, sp, #8
   253da:	4641      	mov	r1, r8
   253dc:	4620      	mov	r0, r4
   253de:	9600      	str	r6, [sp, #0]
   253e0:	f7ff fce3 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
   253e4:	4653      	mov	r3, sl
   253e6:	4622      	mov	r2, r4
   253e8:	4639      	mov	r1, r7
   253ea:	4638      	mov	r0, r7
   253ec:	f7ff fd87 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
   253f0:	462b      	mov	r3, r5
   253f2:	464a      	mov	r2, r9
   253f4:	4639      	mov	r1, r7
   253f6:	4638      	mov	r0, r7
   253f8:	9600      	str	r6, [sp, #0]
   253fa:	f7ff fcd6 	bl	24daa <uECC_vli_modSub>
	uECC_vli_set(X2, t5, num_words);
   253fe:	4632      	mov	r2, r6
   25400:	a902      	add	r1, sp, #8
   25402:	4620      	mov	r0, r4
   25404:	f7ff fc69 	bl	24cda <uECC_vli_set>
}
   25408:	b00a      	add	sp, #40	; 0x28
   2540a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0002540e <EccPoint_mult>:

void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
		   const uECC_word_t * scalar,
		   const uECC_word_t * initial_Z,
		   bitcount_t num_bits, uECC_Curve curve) 
{
   2540e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25412:	b0b1      	sub	sp, #196	; 0xc4
   25414:	e9cd 0103 	strd	r0, r1, [sp, #12]
   25418:	9c3b      	ldr	r4, [sp, #236]	; 0xec
	uECC_word_t Rx[2][NUM_ECC_WORDS];
	uECC_word_t Ry[2][NUM_ECC_WORDS];
	uECC_word_t z[NUM_ECC_WORDS];
	bitcount_t i;
	uECC_word_t nb;
	wordcount_t num_words = curve->num_words;
   2541a:	f994 7000 	ldrsb.w	r7, [r4]

	uECC_vli_set(Rx[1], point, num_words);
   2541e:	a818      	add	r0, sp, #96	; 0x60
{
   25420:	4692      	mov	sl, r2
	uECC_vli_set(Rx[1], point, num_words);
   25422:	463a      	mov	r2, r7
{
   25424:	461e      	mov	r6, r3
	uECC_vli_set(Rx[1], point, num_words);
   25426:	f7ff fc58 	bl	24cda <uECC_vli_set>
  	uECC_vli_set(Ry[1], point + num_words, num_words);
   2542a:	00bb      	lsls	r3, r7, #2
   2542c:	9305      	str	r3, [sp, #20]
   2542e:	9b04      	ldr	r3, [sp, #16]
   25430:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   25434:	4619      	mov	r1, r3
   25436:	a828      	add	r0, sp, #160	; 0xa0
   25438:	9302      	str	r3, [sp, #8]
   2543a:	f7ff fc4e 	bl	24cda <uECC_vli_set>
	wordcount_t num_words = curve->num_words;
   2543e:	f994 5000 	ldrsb.w	r5, [r4]
	if (initial_Z) {
   25442:	2e00      	cmp	r6, #0
   25444:	f000 8088 	beq.w	25558 <EccPoint_mult+0x14a>
		uECC_vli_set(z, initial_Z, num_words);
   25448:	462a      	mov	r2, r5
   2544a:	4631      	mov	r1, r6
   2544c:	a808      	add	r0, sp, #32
   2544e:	f7ff fc44 	bl	24cda <uECC_vli_set>
	uECC_vli_set(X2, X1, num_words);
   25452:	f10d 0840 	add.w	r8, sp, #64	; 0x40
   25456:	462a      	mov	r2, r5
   25458:	a918      	add	r1, sp, #96	; 0x60
   2545a:	4640      	mov	r0, r8
	uECC_vli_set(Y2, Y1, num_words);
   2545c:	f10d 0980 	add.w	r9, sp, #128	; 0x80
	uECC_vli_set(X2, X1, num_words);
   25460:	f7ff fc3b 	bl	24cda <uECC_vli_set>
	uECC_vli_set(Y2, Y1, num_words);
   25464:	a928      	add	r1, sp, #160	; 0xa0
   25466:	4648      	mov	r0, r9
   25468:	f7ff fc37 	bl	24cda <uECC_vli_set>
	apply_z(X1, Y1, z, curve);
   2546c:	4623      	mov	r3, r4
   2546e:	aa08      	add	r2, sp, #32
   25470:	a928      	add	r1, sp, #160	; 0xa0
   25472:	a818      	add	r0, sp, #96	; 0x60
   25474:	f7ff ff45 	bl	25302 <apply_z>
	curve->double_jacobian(X1, Y1, z, curve);
   25478:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
   2547c:	4623      	mov	r3, r4
   2547e:	aa08      	add	r2, sp, #32
   25480:	a928      	add	r1, sp, #160	; 0xa0
   25482:	a818      	add	r0, sp, #96	; 0x60
   25484:	47a8      	blx	r5
	apply_z(X2, Y2, z, curve);
   25486:	4623      	mov	r3, r4
   25488:	aa08      	add	r2, sp, #32
   2548a:	4649      	mov	r1, r9
   2548c:	4640      	mov	r0, r8
   2548e:	f7ff ff38 	bl	25302 <apply_z>

	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

	for (i = num_bits - 2; i > 0; --i) {
   25492:	f9bd 50e8 	ldrsh.w	r5, [sp, #232]	; 0xe8
   25496:	3d02      	subs	r5, #2
   25498:	b22d      	sxth	r5, r5
   2549a:	2d00      	cmp	r5, #0
   2549c:	dc63      	bgt.n	25566 <EccPoint_mult+0x158>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   2549e:	f8da 5000 	ldr.w	r5, [sl]
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
	}

	nb = !uECC_vli_testBit(scalar, 0);
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   254a2:	9400      	str	r4, [sp, #0]
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   254a4:	f005 0601 	and.w	r6, r5, #1
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   254a8:	ab10      	add	r3, sp, #64	; 0x40
   254aa:	eb03 1846 	add.w	r8, r3, r6, lsl #5
   254ae:	43ed      	mvns	r5, r5
   254b0:	ab20      	add	r3, sp, #128	; 0x80
   254b2:	eb03 1646 	add.w	r6, r3, r6, lsl #5
   254b6:	f005 0501 	and.w	r5, r5, #1
   254ba:	ab10      	add	r3, sp, #64	; 0x40
   254bc:	eb03 1945 	add.w	r9, r3, r5, lsl #5
   254c0:	ab20      	add	r3, sp, #128	; 0x80
   254c2:	eb03 1545 	add.w	r5, r3, r5, lsl #5

	/* Find final 1/Z value. */
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   254c6:	f104 0a04 	add.w	sl, r4, #4
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   254ca:	462b      	mov	r3, r5
   254cc:	464a      	mov	r2, r9
   254ce:	4631      	mov	r1, r6
   254d0:	4640      	mov	r0, r8
   254d2:	f7ff fe00 	bl	250d6 <XYcZ_addC>
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   254d6:	4653      	mov	r3, sl
   254d8:	aa10      	add	r2, sp, #64	; 0x40
   254da:	a918      	add	r1, sp, #96	; 0x60
   254dc:	a808      	add	r0, sp, #32
   254de:	9700      	str	r7, [sp, #0]
   254e0:	f7ff fc63 	bl	24daa <uECC_vli_modSub>
	uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve); /* Yb * (X1 - X0) */
   254e4:	a908      	add	r1, sp, #32
   254e6:	4623      	mov	r3, r4
   254e8:	4632      	mov	r2, r6
   254ea:	4608      	mov	r0, r1
   254ec:	f7ff fd07 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(z, z, point, curve); /* xP * Yb * (X1 - X0) */
   254f0:	a908      	add	r1, sp, #32
   254f2:	9a04      	ldr	r2, [sp, #16]
   254f4:	4623      	mov	r3, r4
   254f6:	4608      	mov	r0, r1
   254f8:	f7ff fd01 	bl	24efe <uECC_vli_modMult_fast>
	uECC_vli_modInv(z, z, curve->p, num_words); /* 1 / (xP * Yb * (X1 - X0))*/
   254fc:	a908      	add	r1, sp, #32
   254fe:	463b      	mov	r3, r7
   25500:	4652      	mov	r2, sl
   25502:	4608      	mov	r0, r1
   25504:	f7ff fe75 	bl	251f2 <uECC_vli_modInv>
	/* yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, point + num_words, curve);
   25508:	a908      	add	r1, sp, #32
   2550a:	9a02      	ldr	r2, [sp, #8]
   2550c:	4623      	mov	r3, r4
   2550e:	4608      	mov	r0, r1
   25510:	f7ff fcf5 	bl	24efe <uECC_vli_modMult_fast>
	/* Xb * yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve);
   25514:	a908      	add	r1, sp, #32
   25516:	4623      	mov	r3, r4
   25518:	4642      	mov	r2, r8
   2551a:	4608      	mov	r0, r1
   2551c:	f7ff fcef 	bl	24efe <uECC_vli_modMult_fast>
	/* End 1/Z calculation */

	XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   25520:	9400      	str	r4, [sp, #0]
   25522:	4633      	mov	r3, r6
   25524:	4642      	mov	r2, r8
   25526:	4629      	mov	r1, r5
   25528:	4648      	mov	r0, r9
   2552a:	f7ff ff09 	bl	25340 <XYcZ_add>
	apply_z(Rx[0], Ry[0], z, curve);
   2552e:	4623      	mov	r3, r4
   25530:	aa08      	add	r2, sp, #32
   25532:	a920      	add	r1, sp, #128	; 0x80
   25534:	a810      	add	r0, sp, #64	; 0x40
   25536:	f7ff fee4 	bl	25302 <apply_z>

	uECC_vli_set(result, Rx[0], num_words);
   2553a:	9803      	ldr	r0, [sp, #12]
   2553c:	463a      	mov	r2, r7
   2553e:	a910      	add	r1, sp, #64	; 0x40
   25540:	f7ff fbcb 	bl	24cda <uECC_vli_set>
	uECC_vli_set(result + num_words, Ry[0], num_words);
   25544:	9b03      	ldr	r3, [sp, #12]
   25546:	9c05      	ldr	r4, [sp, #20]
   25548:	4423      	add	r3, r4
   2554a:	a920      	add	r1, sp, #128	; 0x80
   2554c:	4618      	mov	r0, r3
   2554e:	f7ff fbc4 	bl	24cda <uECC_vli_set>
}
   25552:	b031      	add	sp, #196	; 0xc4
   25554:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uECC_vli_clear(z, num_words);
   25558:	4629      	mov	r1, r5
   2555a:	a808      	add	r0, sp, #32
   2555c:	f7ff fb78 	bl	24c50 <uECC_vli_clear>
		z[0] = 1;
   25560:	2301      	movs	r3, #1
   25562:	9308      	str	r3, [sp, #32]
   25564:	e775      	b.n	25452 <EccPoint_mult+0x44>
		nb = !uECC_vli_testBit(scalar, i);
   25566:	4629      	mov	r1, r5
   25568:	4650      	mov	r0, sl
   2556a:	f7ff fb8b 	bl	24c84 <uECC_vli_testBit>
   2556e:	fab0 f680 	clz	r6, r0
   25572:	0976      	lsrs	r6, r6, #5
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   25574:	f1c6 0101 	rsb	r1, r6, #1
   25578:	eb08 1b46 	add.w	fp, r8, r6, lsl #5
   2557c:	eb09 1646 	add.w	r6, r9, r6, lsl #5
   25580:	eb08 1041 	add.w	r0, r8, r1, lsl #5
   25584:	4633      	mov	r3, r6
   25586:	eb09 1141 	add.w	r1, r9, r1, lsl #5
   2558a:	465a      	mov	r2, fp
   2558c:	9400      	str	r4, [sp, #0]
   2558e:	e9cd 0106 	strd	r0, r1, [sp, #24]
   25592:	f7ff fda0 	bl	250d6 <XYcZ_addC>
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   25596:	9907      	ldr	r1, [sp, #28]
   25598:	9806      	ldr	r0, [sp, #24]
   2559a:	9400      	str	r4, [sp, #0]
   2559c:	460b      	mov	r3, r1
   2559e:	4602      	mov	r2, r0
   255a0:	4631      	mov	r1, r6
   255a2:	4658      	mov	r0, fp
   255a4:	f7ff fecc 	bl	25340 <XYcZ_add>
	for (i = num_bits - 2; i > 0; --i) {
   255a8:	3d01      	subs	r5, #1
   255aa:	e775      	b.n	25498 <EccPoint_mult+0x8a>

000255ac <regularize_k>:

uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
			 uECC_word_t *k1, uECC_Curve curve)
{
   255ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   255b0:	f9b3 9002 	ldrsh.w	r9, [r3, #2]
   255b4:	f119 081f 	adds.w	r8, r9, #31
{
   255b8:	461d      	mov	r5, r3
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   255ba:	bf48      	it	mi
   255bc:	f109 083e 	addmi.w	r8, r9, #62	; 0x3e
{
   255c0:	460e      	mov	r6, r1
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   255c2:	f348 1847 	sbfx	r8, r8, #5, #8

	bitcount_t num_n_bits = curve->num_n_bits;

	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   255c6:	3524      	adds	r5, #36	; 0x24
   255c8:	4601      	mov	r1, r0
{
   255ca:	4617      	mov	r7, r2
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   255cc:	4643      	mov	r3, r8
   255ce:	462a      	mov	r2, r5
   255d0:	4630      	mov	r0, r6
   255d2:	f7ff fa84 	bl	24ade <uECC_vli_add>
   255d6:	4604      	mov	r4, r0
   255d8:	b990      	cbnz	r0, 25600 <regularize_k+0x54>
   255da:	ebb9 1f48 	cmp.w	r9, r8, lsl #5
   255de:	da06      	bge.n	255ee <regularize_k+0x42>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
			     uECC_vli_testBit(k0, num_n_bits));
   255e0:	4649      	mov	r1, r9
   255e2:	4630      	mov	r0, r6
   255e4:	f7ff fb4e 	bl	24c84 <uECC_vli_testBit>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
   255e8:	1e04      	subs	r4, r0, #0
   255ea:	bf18      	it	ne
   255ec:	2401      	movne	r4, #1

	uECC_vli_add(k1, k0, curve->n, num_n_words);
   255ee:	4643      	mov	r3, r8
   255f0:	462a      	mov	r2, r5
   255f2:	4631      	mov	r1, r6
   255f4:	4638      	mov	r0, r7
   255f6:	f7ff fa72 	bl	24ade <uECC_vli_add>

	return carry;
}
   255fa:	4620      	mov	r0, r4
   255fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   25600:	2401      	movs	r4, #1
   25602:	e7f4      	b.n	255ee <regularize_k+0x42>

00025604 <EccPoint_compute_public_key>:

uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
					uECC_word_t *private_key,
					uECC_Curve curve)
{
   25604:	b530      	push	{r4, r5, lr}
   25606:	4614      	mov	r4, r2
   25608:	b095      	sub	sp, #84	; 0x54
   2560a:	4605      	mov	r5, r0

	uECC_word_t tmp1[NUM_ECC_WORDS];
 	uECC_word_t tmp2[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {tmp1, tmp2};
   2560c:	aa0c      	add	r2, sp, #48	; 0x30
	uECC_word_t carry;

	/* Regularize the bitcount for the private key so that attackers cannot
	 * use a side channel attack to learn the number of leading zeros. */
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   2560e:	4623      	mov	r3, r4
{
   25610:	4608      	mov	r0, r1
	uECC_word_t *p2[2] = {tmp1, tmp2};
   25612:	a904      	add	r1, sp, #16
   25614:	9102      	str	r1, [sp, #8]
   25616:	9203      	str	r2, [sp, #12]
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   25618:	f7ff ffc8 	bl	255ac <regularize_k>

	EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
   2561c:	fab0 f380 	clz	r3, r0
   25620:	095b      	lsrs	r3, r3, #5
   25622:	aa14      	add	r2, sp, #80	; 0x50
   25624:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   25628:	8863      	ldrh	r3, [r4, #2]
   2562a:	9401      	str	r4, [sp, #4]
   2562c:	3301      	adds	r3, #1
   2562e:	b21b      	sxth	r3, r3
   25630:	9300      	str	r3, [sp, #0]
   25632:	f852 2c48 	ldr.w	r2, [r2, #-72]
   25636:	2300      	movs	r3, #0
   25638:	f104 0144 	add.w	r1, r4, #68	; 0x44
   2563c:	4628      	mov	r0, r5
   2563e:	f7ff fee6 	bl	2540e <EccPoint_mult>

	if (EccPoint_isZero(result, curve)) {
   25642:	4621      	mov	r1, r4
   25644:	4628      	mov	r0, r5
   25646:	f7ff fe57 	bl	252f8 <EccPoint_isZero>
		return 0;
	}
	return 1;
}
   2564a:	fab0 f080 	clz	r0, r0
   2564e:	0940      	lsrs	r0, r0, #5
   25650:	b015      	add	sp, #84	; 0x54
   25652:	bd30      	pop	{r4, r5, pc}

00025654 <uECC_vli_nativeToBytes>:

/* Converts an integer in uECC native format to big-endian bytes. */
void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
			    const unsigned int *native)
{
   25654:	b5f0      	push	{r4, r5, r6, r7, lr}
	wordcount_t i;
	for (i = 0; i < num_bytes; ++i) {
   25656:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
   25658:	1e4f      	subs	r7, r1, #1
   2565a:	b26c      	sxtb	r4, r5
	for (i = 0; i < num_bytes; ++i) {
   2565c:	428c      	cmp	r4, r1
   2565e:	f105 0501 	add.w	r5, r5, #1
   25662:	db00      	blt.n	25666 <uECC_vli_nativeToBytes+0x12>
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
	}
}
   25664:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   25666:	1b3b      	subs	r3, r7, r4
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
   25668:	f023 0603 	bic.w	r6, r3, #3
   2566c:	f003 0303 	and.w	r3, r3, #3
   25670:	5996      	ldr	r6, [r2, r6]
   25672:	00db      	lsls	r3, r3, #3
   25674:	fa26 f303 	lsr.w	r3, r6, r3
   25678:	5503      	strb	r3, [r0, r4]
	for (i = 0; i < num_bytes; ++i) {
   2567a:	e7ee      	b.n	2565a <uECC_vli_nativeToBytes+0x6>

0002567c <uECC_vli_bytesToNative>:

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
   2567c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2567e:	460e      	mov	r6, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   25680:	1cd1      	adds	r1, r2, #3
   25682:	bf48      	it	mi
   25684:	1d91      	addmi	r1, r2, #6
   25686:	f341 0187 	sbfx	r1, r1, #2, #8
{
   2568a:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   2568c:	f7ff fae0 	bl	24c50 <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
   25690:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
   25692:	1e67      	subs	r7, r4, #1
   25694:	b26a      	sxtb	r2, r5
	for (i = 0; i < num_bytes; ++i) {
   25696:	42a2      	cmp	r2, r4
   25698:	f105 0501 	add.w	r5, r5, #1
   2569c:	db00      	blt.n	256a0 <uECC_vli_bytesToNative+0x24>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
   2569e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   256a0:	1abb      	subs	r3, r7, r2
		native[b / uECC_WORD_SIZE] |=
   256a2:	f023 0103 	bic.w	r1, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
   256a6:	5cb2      	ldrb	r2, [r6, r2]
   256a8:	f003 0303 	and.w	r3, r3, #3
   256ac:	00db      	lsls	r3, r3, #3
   256ae:	fa02 f303 	lsl.w	r3, r2, r3
		native[b / uECC_WORD_SIZE] |=
   256b2:	5842      	ldr	r2, [r0, r1]
   256b4:	431a      	orrs	r2, r3
   256b6:	5042      	str	r2, [r0, r1]
	for (i = 0; i < num_bytes; ++i) {
   256b8:	e7ec      	b.n	25694 <uECC_vli_bytesToNative+0x18>

000256ba <uECC_valid_point>:
	return 0;
}


int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve)
{
   256ba:	b5f0      	push	{r4, r5, r6, r7, lr}
   256bc:	b091      	sub	sp, #68	; 0x44
	uECC_word_t tmp1[NUM_ECC_WORDS];
	uECC_word_t tmp2[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   256be:	f991 6000 	ldrsb.w	r6, [r1]
{
   256c2:	4605      	mov	r5, r0
   256c4:	460c      	mov	r4, r1

	/* The point at infinity is invalid. */
	if (EccPoint_isZero(point, curve)) {
   256c6:	f7ff fe17 	bl	252f8 <EccPoint_isZero>
   256ca:	bb28      	cbnz	r0, 25718 <uECC_valid_point+0x5e>
		return -1;
	}

	/* x and y must be smaller than p. */
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   256cc:	1d27      	adds	r7, r4, #4
   256ce:	4632      	mov	r2, r6
   256d0:	4629      	mov	r1, r5
   256d2:	4638      	mov	r0, r7
   256d4:	f7ff fb0d 	bl	24cf2 <uECC_vli_cmp_unsafe>
   256d8:	2801      	cmp	r0, #1
   256da:	d120      	bne.n	2571e <uECC_valid_point+0x64>
		uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
   256dc:	eb05 0186 	add.w	r1, r5, r6, lsl #2
   256e0:	4632      	mov	r2, r6
   256e2:	4638      	mov	r0, r7
   256e4:	f7ff fb05 	bl	24cf2 <uECC_vli_cmp_unsafe>
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   256e8:	2801      	cmp	r0, #1
   256ea:	d118      	bne.n	2571e <uECC_valid_point+0x64>
		return -2;
	}

	uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
   256ec:	4622      	mov	r2, r4
   256ee:	4668      	mov	r0, sp
   256f0:	f7ff fc15 	bl	24f1e <uECC_vli_modSquare_fast>
	curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
   256f4:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
   256f8:	4622      	mov	r2, r4
   256fa:	4629      	mov	r1, r5
   256fc:	a808      	add	r0, sp, #32
   256fe:	4798      	blx	r3

	/* Make sure that y^2 == x^3 + ax + b */
	if (uECC_vli_equal(tmp1, tmp2, num_words) != 0)
   25700:	4632      	mov	r2, r6
   25702:	a908      	add	r1, sp, #32
   25704:	4668      	mov	r0, sp
   25706:	f7ff fb0b 	bl	24d20 <uECC_vli_equal>
   2570a:	2800      	cmp	r0, #0
		return -3;
   2570c:	bf0c      	ite	eq
   2570e:	2000      	moveq	r0, #0
   25710:	f06f 0002 	mvnne.w	r0, #2

	return 0;
}
   25714:	b011      	add	sp, #68	; 0x44
   25716:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -1;
   25718:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2571c:	e7fa      	b.n	25714 <uECC_valid_point+0x5a>
		return -2;
   2571e:	f06f 0001 	mvn.w	r0, #1
   25722:	e7f7      	b.n	25714 <uECC_valid_point+0x5a>

00025724 <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve)
{
   25724:	b570      	push	{r4, r5, r6, lr}
   25726:	460c      	mov	r4, r1
   25728:	b090      	sub	sp, #64	; 0x40

	uECC_word_t _public[NUM_ECC_WORDS * 2];

	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
	uECC_vli_bytesToNative(
	_public + curve->num_words,
   2572a:	4626      	mov	r6, r4
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   2572c:	f991 2001 	ldrsb.w	r2, [r1, #1]
{
   25730:	4605      	mov	r5, r0
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   25732:	4601      	mov	r1, r0
   25734:	4668      	mov	r0, sp
   25736:	f7ff ffa1 	bl	2567c <uECC_vli_bytesToNative>
	public_key + curve->num_bytes,
   2573a:	f994 2001 	ldrsb.w	r2, [r4, #1]
	_public + curve->num_words,
   2573e:	f916 0b44 	ldrsb.w	r0, [r6], #68
	uECC_vli_bytesToNative(
   25742:	18a9      	adds	r1, r5, r2
   25744:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
   25748:	f7ff ff98 	bl	2567c <uECC_vli_bytesToNative>
	curve->num_bytes);

	if (uECC_vli_cmp_unsafe(_public, curve->G, NUM_ECC_WORDS * 2) == 0) {
   2574c:	2210      	movs	r2, #16
   2574e:	4631      	mov	r1, r6
   25750:	4668      	mov	r0, sp
   25752:	f7ff face 	bl	24cf2 <uECC_vli_cmp_unsafe>
   25756:	b128      	cbz	r0, 25764 <uECC_valid_public_key+0x40>
		return -4;
	}

	return uECC_valid_point(_public, curve);
   25758:	4621      	mov	r1, r4
   2575a:	4668      	mov	r0, sp
   2575c:	f7ff ffad 	bl	256ba <uECC_valid_point>
}
   25760:	b010      	add	sp, #64	; 0x40
   25762:	bd70      	pop	{r4, r5, r6, pc}
		return -4;
   25764:	f06f 0003 	mvn.w	r0, #3
   25768:	e7fa      	b.n	25760 <uECC_valid_public_key+0x3c>

0002576a <add_round_key>:
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   2576a:	78cb      	ldrb	r3, [r1, #3]
   2576c:	7802      	ldrb	r2, [r0, #0]
   2576e:	4053      	eors	r3, r2
   25770:	7003      	strb	r3, [r0, #0]
   25772:	884b      	ldrh	r3, [r1, #2]
   25774:	7842      	ldrb	r2, [r0, #1]
   25776:	4053      	eors	r3, r2
   25778:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   2577a:	680a      	ldr	r2, [r1, #0]
   2577c:	7883      	ldrb	r3, [r0, #2]
   2577e:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   25782:	7083      	strb	r3, [r0, #2]
   25784:	680a      	ldr	r2, [r1, #0]
   25786:	78c3      	ldrb	r3, [r0, #3]
   25788:	4053      	eors	r3, r2
   2578a:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   2578c:	79cb      	ldrb	r3, [r1, #7]
   2578e:	7902      	ldrb	r2, [r0, #4]
   25790:	4053      	eors	r3, r2
   25792:	7103      	strb	r3, [r0, #4]
   25794:	88cb      	ldrh	r3, [r1, #6]
   25796:	7942      	ldrb	r2, [r0, #5]
   25798:	4053      	eors	r3, r2
   2579a:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   2579c:	684a      	ldr	r2, [r1, #4]
   2579e:	7983      	ldrb	r3, [r0, #6]
   257a0:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   257a4:	7183      	strb	r3, [r0, #6]
   257a6:	684a      	ldr	r2, [r1, #4]
   257a8:	79c3      	ldrb	r3, [r0, #7]
   257aa:	4053      	eors	r3, r2
   257ac:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   257ae:	7acb      	ldrb	r3, [r1, #11]
   257b0:	7a02      	ldrb	r2, [r0, #8]
   257b2:	4053      	eors	r3, r2
   257b4:	7203      	strb	r3, [r0, #8]
   257b6:	7a42      	ldrb	r2, [r0, #9]
   257b8:	894b      	ldrh	r3, [r1, #10]
   257ba:	4053      	eors	r3, r2
   257bc:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   257be:	688a      	ldr	r2, [r1, #8]
   257c0:	7a83      	ldrb	r3, [r0, #10]
   257c2:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   257c6:	7283      	strb	r3, [r0, #10]
   257c8:	688a      	ldr	r2, [r1, #8]
   257ca:	7ac3      	ldrb	r3, [r0, #11]
   257cc:	4053      	eors	r3, r2
   257ce:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   257d0:	7bcb      	ldrb	r3, [r1, #15]
   257d2:	7b02      	ldrb	r2, [r0, #12]
   257d4:	4053      	eors	r3, r2
   257d6:	7303      	strb	r3, [r0, #12]
   257d8:	89cb      	ldrh	r3, [r1, #14]
   257da:	7b42      	ldrb	r2, [r0, #13]
   257dc:	4053      	eors	r3, r2
   257de:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   257e0:	68ca      	ldr	r2, [r1, #12]
   257e2:	7b83      	ldrb	r3, [r0, #14]
   257e4:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   257e8:	7383      	strb	r3, [r0, #14]
   257ea:	68ca      	ldr	r2, [r1, #12]
   257ec:	7bc3      	ldrb	r3, [r0, #15]
   257ee:	4053      	eors	r3, r2
   257f0:	73c3      	strb	r3, [r0, #15]
}
   257f2:	4770      	bx	lr

000257f4 <shift_rows>:
{
   257f4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   257f6:	7802      	ldrb	r2, [r0, #0]
   257f8:	f88d 2000 	strb.w	r2, [sp]
   257fc:	7942      	ldrb	r2, [r0, #5]
   257fe:	f88d 2001 	strb.w	r2, [sp, #1]
   25802:	7a82      	ldrb	r2, [r0, #10]
   25804:	f88d 2002 	strb.w	r2, [sp, #2]
   25808:	7bc2      	ldrb	r2, [r0, #15]
   2580a:	f88d 2003 	strb.w	r2, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   2580e:	7902      	ldrb	r2, [r0, #4]
   25810:	f88d 2004 	strb.w	r2, [sp, #4]
   25814:	7a42      	ldrb	r2, [r0, #9]
   25816:	f88d 2005 	strb.w	r2, [sp, #5]
   2581a:	7b82      	ldrb	r2, [r0, #14]
   2581c:	f88d 2006 	strb.w	r2, [sp, #6]
   25820:	78c2      	ldrb	r2, [r0, #3]
   25822:	f88d 2007 	strb.w	r2, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   25826:	7a02      	ldrb	r2, [r0, #8]
   25828:	f88d 2008 	strb.w	r2, [sp, #8]
   2582c:	7b42      	ldrb	r2, [r0, #13]
   2582e:	f88d 2009 	strb.w	r2, [sp, #9]
   25832:	7882      	ldrb	r2, [r0, #2]
   25834:	f88d 200a 	strb.w	r2, [sp, #10]
   25838:	79c2      	ldrb	r2, [r0, #7]
   2583a:	f88d 200b 	strb.w	r2, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   2583e:	7b02      	ldrb	r2, [r0, #12]
   25840:	f88d 200c 	strb.w	r2, [sp, #12]
   25844:	7842      	ldrb	r2, [r0, #1]
   25846:	7ac3      	ldrb	r3, [r0, #11]
   25848:	f88d 200d 	strb.w	r2, [sp, #13]
   2584c:	7982      	ldrb	r2, [r0, #6]
   2584e:	f88d 200e 	strb.w	r2, [sp, #14]
   25852:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   25856:	2310      	movs	r3, #16
   25858:	466a      	mov	r2, sp
   2585a:	4619      	mov	r1, r3
   2585c:	f7ff f87b 	bl	24956 <_copy>
}
   25860:	b005      	add	sp, #20
   25862:	f85d fb04 	ldr.w	pc, [sp], #4

00025866 <mult_row_column>:
{
   25866:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25868:	4606      	mov	r6, r0
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   2586a:	7808      	ldrb	r0, [r1, #0]
{
   2586c:	460c      	mov	r4, r1
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   2586e:	f7ff f881 	bl	24974 <_double_byte>
   25872:	4605      	mov	r5, r0
   25874:	7860      	ldrb	r0, [r4, #1]
   25876:	f7ff f87d 	bl	24974 <_double_byte>
   2587a:	78a2      	ldrb	r2, [r4, #2]
   2587c:	7863      	ldrb	r3, [r4, #1]
   2587e:	4053      	eors	r3, r2
   25880:	78e2      	ldrb	r2, [r4, #3]
   25882:	4053      	eors	r3, r2
   25884:	405d      	eors	r5, r3
   25886:	4045      	eors	r5, r0
   25888:	7035      	strb	r5, [r6, #0]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   2588a:	7860      	ldrb	r0, [r4, #1]
   2588c:	7827      	ldrb	r7, [r4, #0]
   2588e:	f7ff f871 	bl	24974 <_double_byte>
   25892:	4605      	mov	r5, r0
   25894:	78a0      	ldrb	r0, [r4, #2]
   25896:	f7ff f86d 	bl	24974 <_double_byte>
   2589a:	78a3      	ldrb	r3, [r4, #2]
   2589c:	405f      	eors	r7, r3
   2589e:	78e3      	ldrb	r3, [r4, #3]
   258a0:	405f      	eors	r7, r3
   258a2:	407d      	eors	r5, r7
   258a4:	4045      	eors	r5, r0
   258a6:	7075      	strb	r5, [r6, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   258a8:	78a0      	ldrb	r0, [r4, #2]
   258aa:	7865      	ldrb	r5, [r4, #1]
   258ac:	7827      	ldrb	r7, [r4, #0]
   258ae:	f7ff f861 	bl	24974 <_double_byte>
   258b2:	406f      	eors	r7, r5
   258b4:	4605      	mov	r5, r0
   258b6:	78e0      	ldrb	r0, [r4, #3]
   258b8:	f7ff f85c 	bl	24974 <_double_byte>
   258bc:	78e3      	ldrb	r3, [r4, #3]
   258be:	405f      	eors	r7, r3
   258c0:	407d      	eors	r5, r7
   258c2:	4045      	eors	r5, r0
   258c4:	70b5      	strb	r5, [r6, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   258c6:	7820      	ldrb	r0, [r4, #0]
   258c8:	f7ff f854 	bl	24974 <_double_byte>
   258cc:	7863      	ldrb	r3, [r4, #1]
   258ce:	7825      	ldrb	r5, [r4, #0]
   258d0:	405d      	eors	r5, r3
   258d2:	78a3      	ldrb	r3, [r4, #2]
   258d4:	405d      	eors	r5, r3
   258d6:	4045      	eors	r5, r0
   258d8:	78e0      	ldrb	r0, [r4, #3]
   258da:	f7ff f84b 	bl	24974 <_double_byte>
   258de:	b2ed      	uxtb	r5, r5
   258e0:	4045      	eors	r5, r0
   258e2:	70f5      	strb	r5, [r6, #3]
}
   258e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000258e6 <gf_double>:
 *           the in and out buffers do not overlap.
 *  effects: doubles the GF(2^n) value pointed to by "in" and places
 *           the result in the GF(2^n) value pointed to by "out."
 */
void gf_double(uint8_t *out, uint8_t *in)
{
   258e6:	b510      	push	{r4, lr}

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   258e8:	460a      	mov	r2, r1

	out += (TC_AES_BLOCK_SIZE - 1);
   258ea:	300f      	adds	r0, #15
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   258ec:	f912 3b10 	ldrsb.w	r3, [r2], #16
   258f0:	2b00      	cmp	r3, #0
   258f2:	bfb4      	ite	lt
   258f4:	2387      	movlt	r3, #135	; 0x87
   258f6:	2300      	movge	r3, #0
	for (;;) {
		*out-- = (*x << 1) ^ carry;
   258f8:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
   258fc:	ea83 0344 	eor.w	r3, r3, r4, lsl #1
		if (x == in) {
   25900:	4291      	cmp	r1, r2
		*out-- = (*x << 1) ^ carry;
   25902:	f800 3901 	strb.w	r3, [r0], #-1
		if (x == in) {
   25906:	d002      	beq.n	2590e <gf_double+0x28>
			break;
		}
		carry = *x-- >> 7;
   25908:	7813      	ldrb	r3, [r2, #0]
   2590a:	09db      	lsrs	r3, r3, #7
		*out-- = (*x << 1) ^ carry;
   2590c:	e7f4      	b.n	258f8 <gf_double+0x12>
	}
}
   2590e:	bd10      	pop	{r4, pc}

00025910 <tc_cmac_erase>:

	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
   25910:	b508      	push	{r3, lr}
	if (s == (TCCmacState_t) 0) {
   25912:	b120      	cbz	r0, 2591e <tc_cmac_erase+0xe>
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
   25914:	2258      	movs	r2, #88	; 0x58
   25916:	2100      	movs	r1, #0
   25918:	f7ff f82a 	bl	24970 <_set>
   2591c:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   2591e:	bd08      	pop	{r3, pc}

00025920 <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
   25920:	b510      	push	{r4, lr}
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   25922:	4604      	mov	r4, r0
   25924:	b188      	cbz	r0, 2594a <tc_cmac_init+0x2a>
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   25926:	2210      	movs	r2, #16
   25928:	2100      	movs	r1, #0
   2592a:	f7ff f821 	bl	24970 <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
   2592e:	2210      	movs	r2, #16
   25930:	f104 0030 	add.w	r0, r4, #48	; 0x30
   25934:	2100      	movs	r1, #0
   25936:	f7ff f81b 	bl	24970 <_set>
	s->leftover_offset = 0;
   2593a:	2300      	movs	r3, #0
   2593c:	6463      	str	r3, [r4, #68]	; 0x44

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
   2593e:	2200      	movs	r2, #0
   25940:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   25944:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
   25948:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   2594a:	bd10      	pop	{r4, pc}

0002594c <tc_cmac_setup>:
{
   2594c:	b570      	push	{r4, r5, r6, lr}
   2594e:	460d      	mov	r5, r1
   25950:	4616      	mov	r6, r2
	if (s == (TCCmacState_t) 0 ||
   25952:	4604      	mov	r4, r0
   25954:	b310      	cbz	r0, 2599c <tc_cmac_setup+0x50>
   25956:	b311      	cbz	r1, 2599e <tc_cmac_setup+0x52>
	_set(s, 0, sizeof(*s));
   25958:	2258      	movs	r2, #88	; 0x58
   2595a:	2100      	movs	r1, #0
   2595c:	f7ff f808 	bl	24970 <_set>
	tc_aes128_set_encrypt_key(s->sched, key);
   25960:	4629      	mov	r1, r5
	s->sched = sched;
   25962:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
   25964:	4630      	mov	r0, r6
   25966:	f7de fed5 	bl	4714 <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   2596a:	2210      	movs	r2, #16
   2596c:	2100      	movs	r1, #0
   2596e:	4620      	mov	r0, r4
   25970:	f7fe fffe 	bl	24970 <_set>
	gf_double (s->K1, s->iv);
   25974:	f104 0510 	add.w	r5, r4, #16
	tc_aes_encrypt(s->iv, s->iv, s->sched);
   25978:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   2597a:	4621      	mov	r1, r4
   2597c:	4620      	mov	r0, r4
   2597e:	f7de ff1b 	bl	47b8 <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
   25982:	4621      	mov	r1, r4
   25984:	4628      	mov	r0, r5
   25986:	f7ff ffae 	bl	258e6 <gf_double>
	gf_double (s->K2, s->K1);
   2598a:	4629      	mov	r1, r5
   2598c:	f104 0020 	add.w	r0, r4, #32
   25990:	f7ff ffa9 	bl	258e6 <gf_double>
	tc_cmac_init(s);
   25994:	4620      	mov	r0, r4
   25996:	f7ff ffc3 	bl	25920 <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
   2599a:	2001      	movs	r0, #1
}
   2599c:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   2599e:	4608      	mov	r0, r1
   259a0:	e7fc      	b.n	2599c <tc_cmac_setup+0x50>

000259a2 <tc_cmac_update>:

int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
   259a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   259a6:	460d      	mov	r5, r1
   259a8:	4616      	mov	r6, r2
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   259aa:	4604      	mov	r4, r0
   259ac:	2800      	cmp	r0, #0
   259ae:	d062      	beq.n	25a76 <tc_cmac_update+0xd4>
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
   259b0:	b912      	cbnz	r2, 259b8 <tc_cmac_update+0x16>
		/* save leftover data for next time */
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
   259b2:	2001      	movs	r0, #1
}
   259b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (data == (const uint8_t *) 0) {
   259b8:	2900      	cmp	r1, #0
   259ba:	d05c      	beq.n	25a76 <tc_cmac_update+0xd4>
	if (s->countdown == 0) {
   259bc:	e9d0 0114 	ldrd	r0, r1, [r0, #80]	; 0x50
   259c0:	ea50 0301 	orrs.w	r3, r0, r1
   259c4:	d057      	beq.n	25a76 <tc_cmac_update+0xd4>
	s->countdown--;
   259c6:	f110 32ff 	adds.w	r2, r0, #4294967295	; 0xffffffff
	if (s->leftover_offset > 0) {
   259ca:	f8d4 8044 	ldr.w	r8, [r4, #68]	; 0x44
	s->countdown--;
   259ce:	f141 33ff 	adc.w	r3, r1, #4294967295	; 0xffffffff
   259d2:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
	if (s->leftover_offset > 0) {
   259d6:	f1b8 0f00 	cmp.w	r8, #0
   259da:	d02a      	beq.n	25a32 <tc_cmac_update+0x90>
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
   259dc:	f1c8 0710 	rsb	r7, r8, #16
		if (data_length < remaining_space) {
   259e0:	f108 0030 	add.w	r0, r8, #48	; 0x30
   259e4:	42be      	cmp	r6, r7
   259e6:	4420      	add	r0, r4
   259e8:	d208      	bcs.n	259fc <tc_cmac_update+0x5a>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   259ea:	462a      	mov	r2, r5
   259ec:	4633      	mov	r3, r6
   259ee:	4631      	mov	r1, r6
   259f0:	f7fe ffb1 	bl	24956 <_copy>
			s->leftover_offset += data_length;
   259f4:	6c62      	ldr	r2, [r4, #68]	; 0x44
   259f6:	4432      	add	r2, r6
   259f8:	6462      	str	r2, [r4, #68]	; 0x44
			return TC_CRYPTO_SUCCESS;
   259fa:	e7da      	b.n	259b2 <tc_cmac_update+0x10>
		_copy(&s->leftover[s->leftover_offset],
   259fc:	463b      	mov	r3, r7
   259fe:	462a      	mov	r2, r5
   25a00:	4639      	mov	r1, r7
   25a02:	f7fe ffa8 	bl	24956 <_copy>
		data_length -= remaining_space;
   25a06:	3e10      	subs	r6, #16
		s->leftover_offset = 0;
   25a08:	2300      	movs	r3, #0
   25a0a:	6463      	str	r3, [r4, #68]	; 0x44
		data_length -= remaining_space;
   25a0c:	4446      	add	r6, r8
		data += remaining_space;
   25a0e:	443d      	add	r5, r7
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   25a10:	1e63      	subs	r3, r4, #1
   25a12:	f104 010f 	add.w	r1, r4, #15
			s->iv[i] ^= s->leftover[i];
   25a16:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   25a1a:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   25a1e:	428b      	cmp	r3, r1
			s->iv[i] ^= s->leftover[i];
   25a20:	ea82 0200 	eor.w	r2, r2, r0
   25a24:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   25a26:	d1f6      	bne.n	25a16 <tc_cmac_update+0x74>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   25a28:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   25a2a:	4621      	mov	r1, r4
   25a2c:	4620      	mov	r0, r4
   25a2e:	f7de fec3 	bl	47b8 <tc_aes_encrypt>
   25a32:	f104 070f 	add.w	r7, r4, #15
	while (data_length > TC_AES_BLOCK_SIZE) {
   25a36:	2e10      	cmp	r6, #16
   25a38:	d80a      	bhi.n	25a50 <tc_cmac_update+0xae>
	if (data_length > 0) {
   25a3a:	2e00      	cmp	r6, #0
   25a3c:	d0b9      	beq.n	259b2 <tc_cmac_update+0x10>
		_copy(s->leftover, data_length, data, data_length);
   25a3e:	4633      	mov	r3, r6
   25a40:	462a      	mov	r2, r5
   25a42:	4631      	mov	r1, r6
   25a44:	f104 0030 	add.w	r0, r4, #48	; 0x30
   25a48:	f7fe ff85 	bl	24956 <_copy>
		s->leftover_offset = data_length;
   25a4c:	6466      	str	r6, [r4, #68]	; 0x44
   25a4e:	e7b0      	b.n	259b2 <tc_cmac_update+0x10>
   25a50:	1e63      	subs	r3, r4, #1
   25a52:	1e69      	subs	r1, r5, #1
			s->iv[i] ^= data[i];
   25a54:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   25a58:	f811 0f01 	ldrb.w	r0, [r1, #1]!
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   25a5c:	42bb      	cmp	r3, r7
			s->iv[i] ^= data[i];
   25a5e:	ea82 0200 	eor.w	r2, r2, r0
   25a62:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   25a64:	d1f6      	bne.n	25a54 <tc_cmac_update+0xb2>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   25a66:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   25a68:	4621      	mov	r1, r4
   25a6a:	4620      	mov	r0, r4
   25a6c:	f7de fea4 	bl	47b8 <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
   25a70:	3510      	adds	r5, #16
		data_length  -= TC_AES_BLOCK_SIZE;
   25a72:	3e10      	subs	r6, #16
   25a74:	e7df      	b.n	25a36 <tc_cmac_update+0x94>
		return TC_CRYPTO_FAIL;
   25a76:	2000      	movs	r0, #0
   25a78:	e79c      	b.n	259b4 <tc_cmac_update+0x12>

00025a7a <tc_cmac_final>:

int tc_cmac_final(uint8_t *tag, TCCmacState_t s)
{
   25a7a:	b570      	push	{r4, r5, r6, lr}
   25a7c:	460c      	mov	r4, r1
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   25a7e:	4605      	mov	r5, r0
   25a80:	b1e8      	cbz	r0, 25abe <tc_cmac_final+0x44>
   25a82:	b369      	cbz	r1, 25ae0 <tc_cmac_final+0x66>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
   25a84:	6c4a      	ldr	r2, [r1, #68]	; 0x44
   25a86:	2a10      	cmp	r2, #16
   25a88:	d11a      	bne.n	25ac0 <tc_cmac_final+0x46>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
   25a8a:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   25a8c:	1e63      	subs	r3, r4, #1
   25a8e:	3901      	subs	r1, #1
   25a90:	f104 000f 	add.w	r0, r4, #15
		s->iv[i] ^= s->leftover[i] ^ k[i];
   25a94:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   25a98:	f893 6030 	ldrb.w	r6, [r3, #48]	; 0x30
   25a9c:	4072      	eors	r2, r6
   25a9e:	f811 6f01 	ldrb.w	r6, [r1, #1]!
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   25aa2:	4298      	cmp	r0, r3
		s->iv[i] ^= s->leftover[i] ^ k[i];
   25aa4:	ea82 0206 	eor.w	r2, r2, r6
   25aa8:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   25aaa:	d1f3      	bne.n	25a94 <tc_cmac_final+0x1a>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
   25aac:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   25aae:	4621      	mov	r1, r4
   25ab0:	4628      	mov	r0, r5
   25ab2:	f7de fe81 	bl	47b8 <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
   25ab6:	4620      	mov	r0, r4
   25ab8:	f7ff ff2a 	bl	25910 <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
   25abc:	2001      	movs	r0, #1
}
   25abe:	bd70      	pop	{r4, r5, r6, pc}
		_set(&s->leftover[s->leftover_offset], 0, remaining);
   25ac0:	f102 0030 	add.w	r0, r2, #48	; 0x30
   25ac4:	2100      	movs	r1, #0
   25ac6:	f1c2 0210 	rsb	r2, r2, #16
   25aca:	4420      	add	r0, r4
   25acc:	f7fe ff50 	bl	24970 <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   25ad0:	6c63      	ldr	r3, [r4, #68]	; 0x44
   25ad2:	4423      	add	r3, r4
   25ad4:	2280      	movs	r2, #128	; 0x80
   25ad6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
   25ada:	f104 0120 	add.w	r1, r4, #32
   25ade:	e7d5      	b.n	25a8c <tc_cmac_final+0x12>
		return TC_CRYPTO_FAIL;
   25ae0:	4608      	mov	r0, r1
   25ae2:	e7ec      	b.n	25abe <tc_cmac_final+0x44>

00025ae4 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   25ae4:	2100      	movs	r1, #0
   25ae6:	2001      	movs	r0, #1
   25ae8:	f7df b852 	b.w	4b90 <z_arm_fatal_error>

00025aec <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   25aec:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
   25aee:	6800      	ldr	r0, [r0, #0]
   25af0:	f7df b84e 	b.w	4b90 <z_arm_fatal_error>

00025af4 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   25af4:	b508      	push	{r3, lr}
	handler();
   25af6:	f7df f883 	bl	4c00 <z_SysNmiOnReset>
	z_arm_exc_exit();
}
   25afa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
   25afe:	f7de bec5 	b.w	488c <z_arm_exc_exit>

00025b02 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
   25b02:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   25b06:	4684      	mov	ip, r0
   25b08:	4688      	mov	r8, r1
	register const char *s = nptr;
   25b0a:	4601      	mov	r1, r0
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
   25b0c:	460c      	mov	r4, r1
   25b0e:	f814 3b01 	ldrb.w	r3, [r4], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   25b12:	2b20      	cmp	r3, #32
   25b14:	d033      	beq.n	25b7e <strtol+0x7c>
   25b16:	f1a3 0009 	sub.w	r0, r3, #9
   25b1a:	2804      	cmp	r0, #4
   25b1c:	d92f      	bls.n	25b7e <strtol+0x7c>
	} while (isspace(c));
	if (c == '-') {
   25b1e:	2b2d      	cmp	r3, #45	; 0x2d
   25b20:	d12f      	bne.n	25b82 <strtol+0x80>
		neg = 1;
		c = *s++;
   25b22:	784b      	ldrb	r3, [r1, #1]
   25b24:	1c8c      	adds	r4, r1, #2
		neg = 1;
   25b26:	2101      	movs	r1, #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
   25b28:	2a00      	cmp	r2, #0
   25b2a:	d05c      	beq.n	25be6 <strtol+0xe4>
   25b2c:	2a10      	cmp	r2, #16
   25b2e:	d109      	bne.n	25b44 <strtol+0x42>
   25b30:	2b30      	cmp	r3, #48	; 0x30
   25b32:	d107      	bne.n	25b44 <strtol+0x42>
	    c == '0' && (*s == 'x' || *s == 'X')) {
   25b34:	7823      	ldrb	r3, [r4, #0]
   25b36:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   25b3a:	2b58      	cmp	r3, #88	; 0x58
   25b3c:	d14e      	bne.n	25bdc <strtol+0xda>
		c = s[1];
   25b3e:	7863      	ldrb	r3, [r4, #1]
		s += 2;
		base = 16;
   25b40:	2210      	movs	r2, #16
		s += 2;
   25b42:	3402      	adds	r4, #2
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
   25b44:	f101 4700 	add.w	r7, r1, #2147483648	; 0x80000000
   25b48:	3f01      	subs	r7, #1
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
   25b4a:	2600      	movs	r6, #0
	cutlim = cutoff % (unsigned long)base;
   25b4c:	fbb7 fef2 	udiv	lr, r7, r2
	for (acc = 0, any = 0;; c = *s++) {
   25b50:	4630      	mov	r0, r6
	cutlim = cutoff % (unsigned long)base;
   25b52:	fb02 791e 	mls	r9, r2, lr, r7
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   25b56:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
		if (isdigit(c)) {
   25b5a:	2d09      	cmp	r5, #9
   25b5c:	d817      	bhi.n	25b8e <strtol+0x8c>
			c -= '0';
   25b5e:	462b      	mov	r3, r5
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
   25b60:	429a      	cmp	r2, r3
   25b62:	dd24      	ble.n	25bae <strtol+0xac>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
   25b64:	1c75      	adds	r5, r6, #1
   25b66:	d007      	beq.n	25b78 <strtol+0x76>
   25b68:	4570      	cmp	r0, lr
   25b6a:	d81d      	bhi.n	25ba8 <strtol+0xa6>
   25b6c:	d101      	bne.n	25b72 <strtol+0x70>
   25b6e:	454b      	cmp	r3, r9
   25b70:	dc1a      	bgt.n	25ba8 <strtol+0xa6>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
   25b72:	fb00 3002 	mla	r0, r0, r2, r3
			any = 1;
   25b76:	2601      	movs	r6, #1
	for (acc = 0, any = 0;; c = *s++) {
   25b78:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit(c)) {
   25b7c:	e7eb      	b.n	25b56 <strtol+0x54>
{
   25b7e:	4621      	mov	r1, r4
   25b80:	e7c4      	b.n	25b0c <strtol+0xa>
	} else if (c == '+') {
   25b82:	2b2b      	cmp	r3, #43	; 0x2b
		c = *s++;
   25b84:	bf04      	itt	eq
   25b86:	784b      	ldrbeq	r3, [r1, #1]
   25b88:	1c8c      	addeq	r4, r1, #2
	register int neg = 0, any, cutlim;
   25b8a:	2100      	movs	r1, #0
   25b8c:	e7cc      	b.n	25b28 <strtol+0x26>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   25b8e:	f043 0520 	orr.w	r5, r3, #32
   25b92:	3d61      	subs	r5, #97	; 0x61
		} else if (isalpha(c)) {
   25b94:	2d19      	cmp	r5, #25
   25b96:	d80a      	bhi.n	25bae <strtol+0xac>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   25b98:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
   25b9c:	2d1a      	cmp	r5, #26
   25b9e:	bf34      	ite	cc
   25ba0:	2537      	movcc	r5, #55	; 0x37
   25ba2:	2557      	movcs	r5, #87	; 0x57
   25ba4:	1b5b      	subs	r3, r3, r5
   25ba6:	e7db      	b.n	25b60 <strtol+0x5e>
			any = -1;
   25ba8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   25bac:	e7e4      	b.n	25b78 <strtol+0x76>
		}
	}

	if (any < 0) {
   25bae:	1c73      	adds	r3, r6, #1
   25bb0:	d109      	bne.n	25bc6 <strtol+0xc4>
   25bb2:	f7fa fc2f 	bl	20414 <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
   25bb6:	2326      	movs	r3, #38	; 0x26
   25bb8:	6003      	str	r3, [r0, #0]
		acc = neg ? LONG_MIN : LONG_MAX;
   25bba:	4638      	mov	r0, r7
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
   25bbc:	f1b8 0f00 	cmp.w	r8, #0
   25bc0:	d107      	bne.n	25bd2 <strtol+0xd0>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
   25bc2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (neg) {
   25bc6:	b101      	cbz	r1, 25bca <strtol+0xc8>
		acc = -acc;
   25bc8:	4240      	negs	r0, r0
	if (endptr != NULL) {
   25bca:	f1b8 0f00 	cmp.w	r8, #0
   25bce:	d0f8      	beq.n	25bc2 <strtol+0xc0>
		*endptr = (char *)(any ? s - 1 : nptr);
   25bd0:	b10e      	cbz	r6, 25bd6 <strtol+0xd4>
   25bd2:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
   25bd6:	f8c8 c000 	str.w	ip, [r8]
	return acc;
   25bda:	e7f2      	b.n	25bc2 <strtol+0xc0>
	if (base == 0) {
   25bdc:	2330      	movs	r3, #48	; 0x30
   25bde:	2a00      	cmp	r2, #0
   25be0:	d1b0      	bne.n	25b44 <strtol+0x42>
		base = c == '0' ? 8 : 10;
   25be2:	2208      	movs	r2, #8
   25be4:	e7ae      	b.n	25b44 <strtol+0x42>
	if ((base == 0 || base == 16) &&
   25be6:	2b30      	cmp	r3, #48	; 0x30
   25be8:	d0a4      	beq.n	25b34 <strtol+0x32>
		base = c == '0' ? 8 : 10;
   25bea:	220a      	movs	r2, #10
   25bec:	e7aa      	b.n	25b44 <strtol+0x42>

00025bee <strcpy>:

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   25bee:	3901      	subs	r1, #1
   25bf0:	4603      	mov	r3, r0
   25bf2:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   25bf6:	b90a      	cbnz	r2, 25bfc <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   25bf8:	701a      	strb	r2, [r3, #0]

	return dest;
}
   25bfa:	4770      	bx	lr
		*d = *s;
   25bfc:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   25c00:	e7f7      	b.n	25bf2 <strcpy+0x4>

00025c02 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
   25c02:	b570      	push	{r4, r5, r6, lr}
   25c04:	3901      	subs	r1, #1
   25c06:	4605      	mov	r5, r0
   25c08:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   25c0a:	b142      	cbz	r2, 25c1e <strncpy+0x1c>
   25c0c:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   25c10:	1e56      	subs	r6, r2, #1
   25c12:	b92b      	cbnz	r3, 25c20 <strncpy+0x1e>
   25c14:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
   25c16:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
   25c1a:	42a2      	cmp	r2, r4
   25c1c:	d1fb      	bne.n	25c16 <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
   25c1e:	bd70      	pop	{r4, r5, r6, pc}
		*d = *s;
   25c20:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
   25c24:	4632      	mov	r2, r6
   25c26:	e7ef      	b.n	25c08 <strncpy+0x6>

00025c28 <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
   25c28:	b2c9      	uxtb	r1, r1

	while ((*s != tmp) && (*s != '\0')) {
   25c2a:	4603      	mov	r3, r0
   25c2c:	781a      	ldrb	r2, [r3, #0]
   25c2e:	428a      	cmp	r2, r1
   25c30:	4618      	mov	r0, r3
   25c32:	f103 0301 	add.w	r3, r3, #1
   25c36:	d004      	beq.n	25c42 <strchr+0x1a>
   25c38:	2a00      	cmp	r2, #0
   25c3a:	d1f7      	bne.n	25c2c <strchr+0x4>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
   25c3c:	2900      	cmp	r1, #0
   25c3e:	bf18      	it	ne
   25c40:	2000      	movne	r0, #0
}
   25c42:	4770      	bx	lr

00025c44 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   25c44:	4603      	mov	r3, r0
	size_t n = 0;
   25c46:	2000      	movs	r0, #0

	while (*s != '\0') {
   25c48:	5c1a      	ldrb	r2, [r3, r0]
   25c4a:	b902      	cbnz	r2, 25c4e <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   25c4c:	4770      	bx	lr
		n++;
   25c4e:	3001      	adds	r0, #1
   25c50:	e7fa      	b.n	25c48 <strlen+0x4>

00025c52 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   25c52:	1e43      	subs	r3, r0, #1
   25c54:	3901      	subs	r1, #1
   25c56:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   25c5a:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   25c5e:	4282      	cmp	r2, r0
   25c60:	d101      	bne.n	25c66 <strcmp+0x14>
   25c62:	2a00      	cmp	r2, #0
   25c64:	d1f7      	bne.n	25c56 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   25c66:	1a10      	subs	r0, r2, r0
   25c68:	4770      	bx	lr

00025c6a <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
   25c6a:	b530      	push	{r4, r5, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   25c6c:	2400      	movs	r4, #0
   25c6e:	42a2      	cmp	r2, r4
   25c70:	d008      	beq.n	25c84 <strncmp+0x1a>
   25c72:	5d03      	ldrb	r3, [r0, r4]
   25c74:	5d0d      	ldrb	r5, [r1, r4]
   25c76:	42ab      	cmp	r3, r5
   25c78:	d102      	bne.n	25c80 <strncmp+0x16>
   25c7a:	3401      	adds	r4, #1
   25c7c:	2b00      	cmp	r3, #0
   25c7e:	d1f6      	bne.n	25c6e <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
   25c80:	1b58      	subs	r0, r3, r5
   25c82:	e000      	b.n	25c86 <strncmp+0x1c>
   25c84:	2000      	movs	r0, #0
}
   25c86:	bd30      	pop	{r4, r5, pc}

00025c88 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
   25c88:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
   25c8a:	b15a      	cbz	r2, 25ca4 <memcmp+0x1c>
   25c8c:	3901      	subs	r1, #1
   25c8e:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
   25c90:	f810 2b01 	ldrb.w	r2, [r0], #1
   25c94:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   25c98:	42a0      	cmp	r0, r4
   25c9a:	d001      	beq.n	25ca0 <memcmp+0x18>
   25c9c:	429a      	cmp	r2, r3
   25c9e:	d0f7      	beq.n	25c90 <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
   25ca0:	1ad0      	subs	r0, r2, r3
}
   25ca2:	bd10      	pop	{r4, pc}
		return 0;
   25ca4:	4610      	mov	r0, r2
   25ca6:	e7fc      	b.n	25ca2 <memcmp+0x1a>

00025ca8 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
   25ca8:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
   25caa:	ea81 0400 	eor.w	r4, r1, r0
   25cae:	07a5      	lsls	r5, r4, #30
   25cb0:	4603      	mov	r3, r0
   25cb2:	d00b      	beq.n	25ccc <memcpy+0x24>
   25cb4:	3b01      	subs	r3, #1
   25cb6:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
   25cb8:	4291      	cmp	r1, r2
   25cba:	d11b      	bne.n	25cf4 <memcpy+0x4c>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   25cbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
   25cbe:	2a00      	cmp	r2, #0
   25cc0:	d0fc      	beq.n	25cbc <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
   25cc2:	f811 4b01 	ldrb.w	r4, [r1], #1
   25cc6:	f803 4b01 	strb.w	r4, [r3], #1
			n--;
   25cca:	3a01      	subs	r2, #1
		while (((uintptr_t)d_byte) & mask) {
   25ccc:	079c      	lsls	r4, r3, #30
   25cce:	d1f6      	bne.n	25cbe <memcpy+0x16>
   25cd0:	f022 0403 	bic.w	r4, r2, #3
   25cd4:	1f1d      	subs	r5, r3, #4
   25cd6:	0896      	lsrs	r6, r2, #2
   25cd8:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
   25cda:	42b9      	cmp	r1, r7
   25cdc:	d105      	bne.n	25cea <memcpy+0x42>
   25cde:	f06f 0503 	mvn.w	r5, #3
   25ce2:	fb05 2206 	mla	r2, r5, r6, r2
   25ce6:	4423      	add	r3, r4
   25ce8:	e7e4      	b.n	25cb4 <memcpy+0xc>
			*(d_word++) = *(s_word++);
   25cea:	f851 cb04 	ldr.w	ip, [r1], #4
   25cee:	f845 cf04 	str.w	ip, [r5, #4]!
			n -= sizeof(mem_word_t);
   25cf2:	e7f2      	b.n	25cda <memcpy+0x32>
		*(d_byte++) = *(s_byte++);
   25cf4:	f811 4b01 	ldrb.w	r4, [r1], #1
   25cf8:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   25cfc:	e7dc      	b.n	25cb8 <memcpy+0x10>

00025cfe <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
   25cfe:	b570      	push	{r4, r5, r6, lr}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
   25d00:	b2c9      	uxtb	r1, r1
	unsigned char *d_byte = (unsigned char *)buf;
   25d02:	4603      	mov	r3, r0

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   25d04:	079c      	lsls	r4, r3, #30
   25d06:	d111      	bne.n	25d2c <memset+0x2e>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
   25d08:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
   25d0c:	f022 0603 	bic.w	r6, r2, #3
   25d10:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
   25d14:	441e      	add	r6, r3
   25d16:	0894      	lsrs	r4, r2, #2
   25d18:	42b3      	cmp	r3, r6
   25d1a:	d10d      	bne.n	25d38 <memset+0x3a>
   25d1c:	f06f 0503 	mvn.w	r5, #3
   25d20:	fb05 2204 	mla	r2, r5, r4, r2
   25d24:	441a      	add	r2, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
   25d26:	4293      	cmp	r3, r2
   25d28:	d109      	bne.n	25d3e <memset+0x40>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   25d2a:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
   25d2c:	2a00      	cmp	r2, #0
   25d2e:	d0fc      	beq.n	25d2a <memset+0x2c>
		*(d_byte++) = c_byte;
   25d30:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   25d34:	3a01      	subs	r2, #1
   25d36:	e7e5      	b.n	25d04 <memset+0x6>
		*(d_word++) = c_word;
   25d38:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
   25d3c:	e7ec      	b.n	25d18 <memset+0x1a>
		*(d_byte++) = c_byte;
   25d3e:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   25d42:	e7f0      	b.n	25d26 <memset+0x28>

00025d44 <_to_x>:
{
   25d44:	b5f0      	push	{r4, r5, r6, r7, lr}
   25d46:	4603      	mov	r3, r0
   25d48:	4614      	mov	r4, r2
   25d4a:	4602      	mov	r2, r0
		unsigned int d = n % base;
   25d4c:	fbb1 f0f4 	udiv	r0, r1, r4
   25d50:	fb04 1510 	mls	r5, r4, r0, r1
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   25d54:	2d09      	cmp	r5, #9
   25d56:	460f      	mov	r7, r1
   25d58:	bf8c      	ite	hi
   25d5a:	2627      	movhi	r6, #39	; 0x27
   25d5c:	2600      	movls	r6, #0
		n /= base;
   25d5e:	4601      	mov	r1, r0
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   25d60:	3530      	adds	r5, #48	; 0x30
   25d62:	4610      	mov	r0, r2
   25d64:	4435      	add	r5, r6
	} while (n);
   25d66:	42a7      	cmp	r7, r4
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   25d68:	f800 5b01 	strb.w	r5, [r0], #1
	} while (n);
   25d6c:	d205      	bcs.n	25d7a <_to_x+0x36>
	*buf = 0;
   25d6e:	2100      	movs	r1, #0
   25d70:	7001      	strb	r1, [r0, #0]
	len = buf - start;
   25d72:	1ac0      	subs	r0, r0, r3
	for (buf--; buf > start; buf--, start++) {
   25d74:	429a      	cmp	r2, r3
   25d76:	d802      	bhi.n	25d7e <_to_x+0x3a>
}
   25d78:	bdf0      	pop	{r4, r5, r6, r7, pc}
   25d7a:	4602      	mov	r2, r0
   25d7c:	e7e6      	b.n	25d4c <_to_x+0x8>
		char tmp = *buf;
   25d7e:	7811      	ldrb	r1, [r2, #0]
		*buf = *start;
   25d80:	781c      	ldrb	r4, [r3, #0]
   25d82:	f802 4901 	strb.w	r4, [r2], #-1
		*start = tmp;
   25d86:	f803 1b01 	strb.w	r1, [r3], #1
	for (buf--; buf > start; buf--, start++) {
   25d8a:	e7f3      	b.n	25d74 <_to_x+0x30>

00025d8c <_rlrshift>:
{
   25d8c:	b570      	push	{r4, r5, r6, lr}
	*v = (*v & 1) + (*v >> 1);
   25d8e:	e9d0 6500 	ldrd	r6, r5, [r0]
   25d92:	0872      	lsrs	r2, r6, #1
   25d94:	f006 0301 	and.w	r3, r6, #1
   25d98:	ea42 72c5 	orr.w	r2, r2, r5, lsl #31
   25d9c:	189b      	adds	r3, r3, r2
   25d9e:	f04f 0100 	mov.w	r1, #0
   25da2:	ea4f 0455 	mov.w	r4, r5, lsr #1
   25da6:	eb44 0101 	adc.w	r1, r4, r1
   25daa:	e9c0 3100 	strd	r3, r1, [r0]
}
   25dae:	bd70      	pop	{r4, r5, r6, pc}

00025db0 <_ldiv5>:
	uint64_t rem = *v, quot = 0U, q;
   25db0:	e9d0 3200 	ldrd	r3, r2, [r0]
{
   25db4:	b5f0      	push	{r4, r5, r6, r7, lr}
	rem += 2U;
   25db6:	3302      	adds	r3, #2
		q = (uint64_t)(hi / 5U) << shifts[i];
   25db8:	f04f 0705 	mov.w	r7, #5
   25dbc:	f04f 0c00 	mov.w	ip, #0
	rem += 2U;
   25dc0:	f142 0200 	adc.w	r2, r2, #0
		rem -= q * 5U;
   25dc4:	ebb3 060c 	subs.w	r6, r3, ip
		q = (uint64_t)(hi / 5U) << shifts[i];
   25dc8:	fbb2 fef7 	udiv	lr, r2, r7
		rem -= q * 5U;
   25dcc:	fb07 f10e 	mul.w	r1, r7, lr
   25dd0:	eb62 0101 	sbc.w	r1, r2, r1
		hi = rem >> shifts[i];
   25dd4:	08f2      	lsrs	r2, r6, #3
   25dd6:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
		q = (uint64_t)(hi / 5U) << shifts[i];
   25dda:	fbb2 f1f7 	udiv	r1, r2, r7
   25dde:	00ca      	lsls	r2, r1, #3
		quot += q;
   25de0:	eb1c 0402 	adds.w	r4, ip, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
   25de4:	ea4f 7351 	mov.w	r3, r1, lsr #29
		quot += q;
   25de8:	eb4e 0503 	adc.w	r5, lr, r3
		rem -= q * 5U;
   25dec:	fba2 2307 	umull	r2, r3, r2, r7
   25df0:	1ab3      	subs	r3, r6, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
   25df2:	fbb3 f3f7 	udiv	r3, r3, r7
		quot += q;
   25df6:	18e4      	adds	r4, r4, r3
   25df8:	f145 0500 	adc.w	r5, r5, #0
	*v = quot;
   25dfc:	e9c0 4500 	strd	r4, r5, [r0]
}
   25e00:	bdf0      	pop	{r4, r5, r6, r7, pc}

00025e02 <_get_digit>:
	if (*digit_count > 0) {
   25e02:	680b      	ldr	r3, [r1, #0]
   25e04:	2b00      	cmp	r3, #0
{
   25e06:	b570      	push	{r4, r5, r6, lr}
   25e08:	4604      	mov	r4, r0
	if (*digit_count > 0) {
   25e0a:	dd0f      	ble.n	25e2c <_get_digit+0x2a>
		*fr = *fr * 10U;
   25e0c:	6822      	ldr	r2, [r4, #0]
   25e0e:	6840      	ldr	r0, [r0, #4]
		*digit_count -= 1;
   25e10:	3b01      	subs	r3, #1
   25e12:	600b      	str	r3, [r1, #0]
		*fr = *fr * 10U;
   25e14:	210a      	movs	r1, #10
   25e16:	fba2 5601 	umull	r5, r6, r2, r1
   25e1a:	fb01 6600 	mla	r6, r1, r0, r6
		*fr &= 0x0FFFFFFFFFFFFFFFull;
   25e1e:	f026 4370 	bic.w	r3, r6, #4026531840	; 0xf0000000
   25e22:	e9c4 5300 	strd	r5, r3, [r4]
		rval = ((*fr >> 60) & 0xF) + '0';
   25e26:	0f30      	lsrs	r0, r6, #28
   25e28:	3030      	adds	r0, #48	; 0x30
}
   25e2a:	bd70      	pop	{r4, r5, r6, pc}
		rval = '0';
   25e2c:	2030      	movs	r0, #48	; 0x30
   25e2e:	e7fc      	b.n	25e2a <_get_digit+0x28>

00025e30 <_stdout_hook_default>:
}
   25e30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   25e34:	4770      	bx	lr

00025e36 <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
   25e36:	684b      	ldr	r3, [r1, #4]
   25e38:	2b01      	cmp	r3, #1
   25e3a:	dd07      	ble.n	25e4c <sprintf_out+0x16>
		*(p->ptr) = c;
   25e3c:	680b      	ldr	r3, [r1, #0]
   25e3e:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
   25e40:	680b      	ldr	r3, [r1, #0]
   25e42:	3301      	adds	r3, #1
   25e44:	600b      	str	r3, [r1, #0]
		p->len -= 1;
   25e46:	684b      	ldr	r3, [r1, #4]
   25e48:	3b01      	subs	r3, #1
   25e4a:	604b      	str	r3, [r1, #4]
}
   25e4c:	2000      	movs	r0, #0
   25e4e:	4770      	bx	lr

00025e50 <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
   25e50:	f7fa b958 	b.w	20104 <SystemInit>

00025e54 <send_cmd_status>:
{
   25e54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   25e58:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   25e5c:	4606      	mov	r6, r0
   25e5e:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   25e60:	200f      	movs	r0, #15
   25e62:	2100      	movs	r1, #0
   25e64:	f7e2 fdd0 	bl	8a08 <bt_buf_get_evt>
	*(u8_t *)net_buf_user_data(buf) = type;
   25e68:	2701      	movs	r7, #1
	hdr = net_buf_add(buf, sizeof(*hdr));
   25e6a:	f100 0808 	add.w	r8, r0, #8
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   25e6e:	4604      	mov	r4, r0
   25e70:	7507      	strb	r7, [r0, #20]
	hdr = net_buf_add(buf, sizeof(*hdr));
   25e72:	2102      	movs	r1, #2
   25e74:	4640      	mov	r0, r8
   25e76:	f7f9 fa2f 	bl	1f2d8 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   25e7a:	230f      	movs	r3, #15
	hdr->len = sizeof(*evt);
   25e7c:	2104      	movs	r1, #4
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   25e7e:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*evt);
   25e80:	7041      	strb	r1, [r0, #1]
	evt = net_buf_add(buf, sizeof(*evt));
   25e82:	4640      	mov	r0, r8
   25e84:	f7f9 fa28 	bl	1f2d8 <net_buf_simple_add>
	evt->ncmd = 1U;
   25e88:	7047      	strb	r7, [r0, #1]
	evt->status = status;
   25e8a:	7005      	strb	r5, [r0, #0]
	evt->opcode = sys_cpu_to_le16(opcode);
   25e8c:	8046      	strh	r6, [r0, #2]
	bt_recv_prio(buf);
   25e8e:	4620      	mov	r0, r4
}
   25e90:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_recv_prio(buf);
   25e94:	f7e1 bcbe 	b.w	7814 <bt_recv_prio>

00025e98 <default_CSPRNG>:
{
   25e98:	b508      	push	{r3, lr}
	return !bt_rand(dst, len);
   25e9a:	f002 fa7a 	bl	28392 <bt_rand>
}
   25e9e:	fab0 f080 	clz	r0, r0
   25ea2:	0940      	lsrs	r0, r0, #5
   25ea4:	bd08      	pop	{r3, pc}

00025ea6 <bt_settings_decode_key>:
{
   25ea6:	b570      	push	{r4, r5, r6, lr}
   25ea8:	460d      	mov	r5, r1
	if (settings_name_next(key, NULL) != 13) {
   25eaa:	2100      	movs	r1, #0
{
   25eac:	4604      	mov	r4, r0
	if (settings_name_next(key, NULL) != 13) {
   25eae:	f7fe fc66 	bl	2477e <settings_name_next>
   25eb2:	280d      	cmp	r0, #13
   25eb4:	d118      	bne.n	25ee8 <bt_settings_decode_key+0x42>
	if (key[12] == '0') {
   25eb6:	7b23      	ldrb	r3, [r4, #12]
   25eb8:	2b30      	cmp	r3, #48	; 0x30
   25eba:	d111      	bne.n	25ee0 <bt_settings_decode_key+0x3a>
		addr->type = BT_ADDR_LE_PUBLIC;
   25ebc:	2300      	movs	r3, #0
   25ebe:	702b      	strb	r3, [r5, #0]
   25ec0:	f104 060c 	add.w	r6, r4, #12
   25ec4:	3506      	adds	r5, #6
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
   25ec6:	462a      	mov	r2, r5
   25ec8:	4620      	mov	r0, r4
   25eca:	2301      	movs	r3, #1
   25ecc:	2102      	movs	r1, #2
   25ece:	3402      	adds	r4, #2
   25ed0:	f7fd fe84 	bl	23bdc <hex2bin>
	for (u8_t i = 0; i < 6; i++) {
   25ed4:	42b4      	cmp	r4, r6
   25ed6:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
   25eda:	d1f4      	bne.n	25ec6 <bt_settings_decode_key+0x20>
	return 0;
   25edc:	2000      	movs	r0, #0
}
   25ede:	bd70      	pop	{r4, r5, r6, pc}
	} else if (key[12] == '1') {
   25ee0:	2b31      	cmp	r3, #49	; 0x31
   25ee2:	d101      	bne.n	25ee8 <bt_settings_decode_key+0x42>
		addr->type = BT_ADDR_LE_RANDOM;
   25ee4:	2301      	movs	r3, #1
   25ee6:	e7ea      	b.n	25ebe <bt_settings_decode_key+0x18>
		return -EINVAL;
   25ee8:	f06f 0015 	mvn.w	r0, #21
   25eec:	e7f7      	b.n	25ede <bt_settings_decode_key+0x38>

00025eee <xor16>:
#define BT_DBG_ENABLED IS_ENABLED(CONFIG_BT_DEBUG_HCI_CORE)
#define LOG_MODULE_NAME bt_aes_ccm
#include "common/log.h"

static inline void xor16(u8_t *dst, const u8_t *a, const u8_t *b)
{
   25eee:	b510      	push	{r4, lr}
	dst[0] = a[0] ^ b[0];
   25ef0:	780b      	ldrb	r3, [r1, #0]
   25ef2:	7814      	ldrb	r4, [r2, #0]
   25ef4:	4063      	eors	r3, r4
   25ef6:	7003      	strb	r3, [r0, #0]
	dst[1] = a[1] ^ b[1];
   25ef8:	7854      	ldrb	r4, [r2, #1]
   25efa:	784b      	ldrb	r3, [r1, #1]
   25efc:	4063      	eors	r3, r4
   25efe:	7043      	strb	r3, [r0, #1]
	dst[2] = a[2] ^ b[2];
   25f00:	7894      	ldrb	r4, [r2, #2]
   25f02:	788b      	ldrb	r3, [r1, #2]
   25f04:	4063      	eors	r3, r4
   25f06:	7083      	strb	r3, [r0, #2]
	dst[3] = a[3] ^ b[3];
   25f08:	78d4      	ldrb	r4, [r2, #3]
   25f0a:	78cb      	ldrb	r3, [r1, #3]
   25f0c:	4063      	eors	r3, r4
   25f0e:	70c3      	strb	r3, [r0, #3]
	dst[4] = a[4] ^ b[4];
   25f10:	7914      	ldrb	r4, [r2, #4]
   25f12:	790b      	ldrb	r3, [r1, #4]
   25f14:	4063      	eors	r3, r4
   25f16:	7103      	strb	r3, [r0, #4]
	dst[5] = a[5] ^ b[5];
   25f18:	7954      	ldrb	r4, [r2, #5]
   25f1a:	794b      	ldrb	r3, [r1, #5]
   25f1c:	4063      	eors	r3, r4
   25f1e:	7143      	strb	r3, [r0, #5]
	dst[6] = a[6] ^ b[6];
   25f20:	7994      	ldrb	r4, [r2, #6]
   25f22:	798b      	ldrb	r3, [r1, #6]
   25f24:	4063      	eors	r3, r4
   25f26:	7183      	strb	r3, [r0, #6]
	dst[7] = a[7] ^ b[7];
   25f28:	79d4      	ldrb	r4, [r2, #7]
   25f2a:	79cb      	ldrb	r3, [r1, #7]
   25f2c:	4063      	eors	r3, r4
   25f2e:	71c3      	strb	r3, [r0, #7]
	dst[8] = a[8] ^ b[8];
   25f30:	7a14      	ldrb	r4, [r2, #8]
   25f32:	7a0b      	ldrb	r3, [r1, #8]
   25f34:	4063      	eors	r3, r4
   25f36:	7203      	strb	r3, [r0, #8]
	dst[9] = a[9] ^ b[9];
   25f38:	7a54      	ldrb	r4, [r2, #9]
   25f3a:	7a4b      	ldrb	r3, [r1, #9]
   25f3c:	4063      	eors	r3, r4
   25f3e:	7243      	strb	r3, [r0, #9]
	dst[10] = a[10] ^ b[10];
   25f40:	7a8b      	ldrb	r3, [r1, #10]
   25f42:	7a94      	ldrb	r4, [r2, #10]
   25f44:	4063      	eors	r3, r4
   25f46:	7283      	strb	r3, [r0, #10]
	dst[11] = a[11] ^ b[11];
   25f48:	7ad4      	ldrb	r4, [r2, #11]
   25f4a:	7acb      	ldrb	r3, [r1, #11]
   25f4c:	4063      	eors	r3, r4
   25f4e:	72c3      	strb	r3, [r0, #11]
	dst[12] = a[12] ^ b[12];
   25f50:	7b14      	ldrb	r4, [r2, #12]
   25f52:	7b0b      	ldrb	r3, [r1, #12]
   25f54:	4063      	eors	r3, r4
   25f56:	7303      	strb	r3, [r0, #12]
	dst[13] = a[13] ^ b[13];
   25f58:	7b54      	ldrb	r4, [r2, #13]
   25f5a:	7b4b      	ldrb	r3, [r1, #13]
   25f5c:	4063      	eors	r3, r4
   25f5e:	7343      	strb	r3, [r0, #13]
	dst[14] = a[14] ^ b[14];
   25f60:	7b94      	ldrb	r4, [r2, #14]
   25f62:	7b8b      	ldrb	r3, [r1, #14]
   25f64:	4063      	eors	r3, r4
   25f66:	7383      	strb	r3, [r0, #14]
	dst[15] = a[15] ^ b[15];
   25f68:	7bcb      	ldrb	r3, [r1, #15]
   25f6a:	7bd2      	ldrb	r2, [r2, #15]
   25f6c:	4053      	eors	r3, r2
   25f6e:	73c3      	strb	r3, [r0, #15]
}
   25f70:	bd10      	pop	{r4, pc}

00025f72 <ccm_crypt>:
	return 0;
}

static int ccm_crypt(const u8_t key[16], const u8_t nonce[13],
		     const u8_t *in_msg, u8_t *out_msg, size_t msg_len)
{
   25f72:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25f76:	b089      	sub	sp, #36	; 0x24
   25f78:	4699      	mov	r9, r3
   25f7a:	9d12      	ldr	r5, [sp, #72]	; 0x48
	blk_cnt = (msg_len + 15) / 16;
	if (!last_blk) {
		last_blk = 16U;
	}

	a_i[0] = 0x01;
   25f7c:	2301      	movs	r3, #1
	blk_cnt = (msg_len + 15) / 16;
   25f7e:	f105 060f 	add.w	r6, r5, #15
{
   25f82:	4607      	mov	r7, r0
		last_blk = 16U;
   25f84:	f015 050f 	ands.w	r5, r5, #15
{
   25f88:	4690      	mov	r8, r2
	memcpy(&a_i[1], nonce, 13);
   25f8a:	eb0d 0003 	add.w	r0, sp, r3
   25f8e:	f04f 020d 	mov.w	r2, #13
	blk_cnt = (msg_len + 15) / 16;
   25f92:	ea4f 1616 	mov.w	r6, r6, lsr #4
		last_blk = 16U;
   25f96:	bf08      	it	eq
   25f98:	2510      	moveq	r5, #16
	a_i[0] = 0x01;
   25f9a:	f88d 3000 	strb.w	r3, [sp]
	memcpy(&a_i[1], nonce, 13);
   25f9e:	f7ff fe83 	bl	25ca8 <memcpy>

	for (j = 0; j < blk_cnt; j++) {
   25fa2:	b2b6      	uxth	r6, r6
   25fa4:	2400      	movs	r4, #0
		if (err) {
			return err;
		}

		/* Encrypted = Payload[0-15] ^ C_1 */
		if (j < blk_cnt - 1) {
   25fa6:	f106 3aff 	add.w	sl, r6, #4294967295	; 0xffffffff
	for (j = 0; j < blk_cnt; j++) {
   25faa:	42b4      	cmp	r4, r6
   25fac:	d304      	bcc.n	25fb8 <ccm_crypt+0x46>
				out_msg[(j * 16) + i] =
					in_msg[(j * 16) + i] ^ s_i[i];
			}
		}
	}
	return 0;
   25fae:	2100      	movs	r1, #0
}
   25fb0:	4608      	mov	r0, r1
   25fb2:	b009      	add	sp, #36	; 0x24
   25fb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	dst[0] = val >> 8;
   25fb8:	f104 0b01 	add.w	fp, r4, #1
   25fbc:	f3cb 2307 	ubfx	r3, fp, #8, #8
		err = bt_encrypt_be(key, a_i, s_i);
   25fc0:	4669      	mov	r1, sp
   25fc2:	aa04      	add	r2, sp, #16
   25fc4:	4638      	mov	r0, r7
   25fc6:	f88d 300e 	strb.w	r3, [sp, #14]
	dst[1] = val;
   25fca:	f88d b00f 	strb.w	fp, [sp, #15]
   25fce:	f002 f9e2 	bl	28396 <bt_encrypt_be>
		if (err) {
   25fd2:	4601      	mov	r1, r0
   25fd4:	2800      	cmp	r0, #0
   25fd6:	d1eb      	bne.n	25fb0 <ccm_crypt+0x3e>
		if (j < blk_cnt - 1) {
   25fd8:	45a2      	cmp	sl, r4
   25fda:	eb08 1204 	add.w	r2, r8, r4, lsl #4
   25fde:	eb09 1004 	add.w	r0, r9, r4, lsl #4
   25fe2:	d904      	bls.n	25fee <ccm_crypt+0x7c>
			xor16(&out_msg[j * 16], s_i, &in_msg[j * 16]);
   25fe4:	a904      	add	r1, sp, #16
   25fe6:	f7ff ff82 	bl	25eee <xor16>
	for (j = 0; j < blk_cnt; j++) {
   25fea:	465c      	mov	r4, fp
   25fec:	e7dd      	b.n	25faa <ccm_crypt+0x38>
   25fee:	f10d 0c10 	add.w	ip, sp, #16
					in_msg[(j * 16) + i] ^ s_i[i];
   25ff2:	f812 3b01 	ldrb.w	r3, [r2], #1
   25ff6:	f81c 4b01 	ldrb.w	r4, [ip], #1
			for (i = 0; i < last_blk; i++) {
   25ffa:	3101      	adds	r1, #1
				out_msg[(j * 16) + i] =
   25ffc:	4063      	eors	r3, r4
			for (i = 0; i < last_blk; i++) {
   25ffe:	428d      	cmp	r5, r1
				out_msg[(j * 16) + i] =
   26000:	f800 3b01 	strb.w	r3, [r0], #1
			for (i = 0; i < last_blk; i++) {
   26004:	d8f5      	bhi.n	25ff2 <ccm_crypt+0x80>
   26006:	e7f0      	b.n	25fea <ccm_crypt+0x78>

00026008 <ccm_auth>:
{
   26008:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2600c:	b08f      	sub	sp, #60	; 0x3c
		last_blk = 16U;
   2600e:	f013 0a0f 	ands.w	sl, r3, #15
{
   26012:	4680      	mov	r8, r0
   26014:	9201      	str	r2, [sp, #4]
   26016:	461d      	mov	r5, r3
	memcpy(b + 1, nonce, 13);
   26018:	f04f 020d 	mov.w	r2, #13
	b[0] = 0x01;
   2601c:	f04f 0301 	mov.w	r3, #1
	memcpy(b + 1, nonce, 13);
   26020:	f10d 0b08 	add.w	fp, sp, #8
   26024:	f10d 0009 	add.w	r0, sp, #9
	err = bt_encrypt_be(key, b, s0);
   26028:	f10d 0928 	add.w	r9, sp, #40	; 0x28
		last_blk = 16U;
   2602c:	bf08      	it	eq
   2602e:	f04f 0a10 	moveq.w	sl, #16
	b[0] = 0x01;
   26032:	f88d 3008 	strb.w	r3, [sp, #8]
{
   26036:	9c19      	ldr	r4, [sp, #100]	; 0x64
	memcpy(b + 1, nonce, 13);
   26038:	f7ff fe36 	bl	25ca8 <memcpy>
	dst[0] = val >> 8;
   2603c:	2300      	movs	r3, #0
	err = bt_encrypt_be(key, b, s0);
   2603e:	464a      	mov	r2, r9
   26040:	4659      	mov	r1, fp
   26042:	4640      	mov	r0, r8
   26044:	f8ad 3016 	strh.w	r3, [sp, #22]
   26048:	f002 f9a5 	bl	28396 <bt_encrypt_be>
	if (err) {
   2604c:	4606      	mov	r6, r0
   2604e:	2800      	cmp	r0, #0
   26050:	d15f      	bne.n	26112 <ccm_auth+0x10a>
	b[0] = (((mic_size - 2) / 2) << 3) | ((!!aad_len) << 6) | 0x01;
   26052:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   26054:	f88d 0016 	strb.w	r0, [sp, #22]
   26058:	3b02      	subs	r3, #2
   2605a:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   2605e:	ea4f 0383 	mov.w	r3, r3, lsl #2
   26062:	bf14      	ite	ne
   26064:	2240      	movne	r2, #64	; 0x40
   26066:	2200      	moveq	r2, #0
   26068:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
   2606c:	4313      	orrs	r3, r2
   2606e:	f043 0301 	orr.w	r3, r3, #1
	err = bt_encrypt_be(key, b, X0);
   26072:	aa06      	add	r2, sp, #24
   26074:	4659      	mov	r1, fp
   26076:	4640      	mov	r0, r8
	b[0] = (((mic_size - 2) / 2) << 3) | ((!!aad_len) << 6) | 0x01;
   26078:	f88d 3008 	strb.w	r3, [sp, #8]
	dst[1] = val;
   2607c:	f88d 5017 	strb.w	r5, [sp, #23]
	err = bt_encrypt_be(key, b, X0);
   26080:	f002 f989 	bl	28396 <bt_encrypt_be>
	if (err) {
   26084:	4607      	mov	r7, r0
   26086:	bbb0      	cbnz	r0, 260f6 <ccm_auth+0xee>
	if (aad_len) {
   26088:	b3ac      	cbz	r4, 260f6 <ccm_auth+0xee>
			b[i] = X0[i] ^ b[i];
   2608a:	f89d 1018 	ldrb.w	r1, [sp, #24]
   2608e:	f88d 1008 	strb.w	r1, [sp, #8]
   26092:	f89d 1019 	ldrb.w	r1, [sp, #25]
   26096:	4061      	eors	r1, r4
		aad_len += sizeof(u16_t);
   26098:	3402      	adds	r4, #2
			b[i] = X0[i] ^ b[i];
   2609a:	f88d 1009 	strb.w	r1, [sp, #9]
		aad_len += sizeof(u16_t);
   2609e:	b2e4      	uxtb	r4, r4
		while (aad_len > 16) {
   260a0:	2002      	movs	r0, #2
				b[i] = X0[i] ^ aad[j];
   260a2:	aa06      	add	r2, sp, #24
		while (aad_len > 16) {
   260a4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   260a6:	2c10      	cmp	r4, #16
   260a8:	eb03 0107 	add.w	r1, r3, r7
   260ac:	460b      	mov	r3, r1
   260ae:	d80a      	bhi.n	260c6 <ccm_auth+0xbe>
   260b0:	aa06      	add	r2, sp, #24
		for (; i < aad_len; i++, j++) {
   260b2:	42a0      	cmp	r0, r4
   260b4:	4621      	mov	r1, r4
   260b6:	db30      	blt.n	2611a <ccm_auth+0x112>
		for (i = aad_len; i < 16; i++) {
   260b8:	290f      	cmp	r1, #15
   260ba:	dd36      	ble.n	2612a <ccm_auth+0x122>
		err = bt_encrypt_be(key, b, X0);
   260bc:	a902      	add	r1, sp, #8
   260be:	4640      	mov	r0, r8
   260c0:	f002 f969 	bl	28396 <bt_encrypt_be>
		if (err) {
   260c4:	e017      	b.n	260f6 <ccm_auth+0xee>
		while (aad_len > 16) {
   260c6:	4601      	mov	r1, r0
				b[i] = X0[i] ^ aad[j];
   260c8:	f811 e002 	ldrb.w	lr, [r1, r2]
   260cc:	f813 cb01 	ldrb.w	ip, [r3], #1
   260d0:	ea8c 0c0e 	eor.w	ip, ip, lr
   260d4:	f801 c00b 	strb.w	ip, [r1, fp]
				i++, j++;
   260d8:	3101      	adds	r1, #1
			} while (i < 16);
   260da:	2910      	cmp	r1, #16
   260dc:	d1f4      	bne.n	260c8 <ccm_auth+0xc0>
   260de:	f1c0 0010 	rsb	r0, r0, #16
   260e2:	4407      	add	r7, r0
			err = bt_encrypt_be(key, b, X0);
   260e4:	4659      	mov	r1, fp
   260e6:	4640      	mov	r0, r8
   260e8:	f002 f955 	bl	28396 <bt_encrypt_be>
   260ec:	3c10      	subs	r4, #16
   260ee:	b2e4      	uxtb	r4, r4
			if (err) {
   260f0:	aa06      	add	r2, sp, #24
   260f2:	2800      	cmp	r0, #0
   260f4:	d0d6      	beq.n	260a4 <ccm_auth+0x9c>
	blk_cnt = (msg_len + 15) / 16;
   260f6:	350f      	adds	r5, #15
			memcpy(&b[i], &Xn[i], 16 - i);
   260f8:	ab06      	add	r3, sp, #24
	for (j = 0; j < blk_cnt; j++) {
   260fa:	f3c5 150f 	ubfx	r5, r5, #4, #16
   260fe:	2700      	movs	r7, #0
			memcpy(&b[i], &Xn[i], 16 - i);
   26100:	eb03 040a 	add.w	r4, r3, sl
	for (j = 0; j < blk_cnt; j++) {
   26104:	42bd      	cmp	r5, r7
   26106:	dc15      	bgt.n	26134 <ccm_auth+0x12c>
	for (i = 0; i < mic_size; i++) {
   26108:	2300      	movs	r3, #0
		mic[i] = s0[i] ^ Xn[i];
   2610a:	a906      	add	r1, sp, #24
	for (i = 0; i < mic_size; i++) {
   2610c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   2610e:	4293      	cmp	r3, r2
   26110:	d13b      	bne.n	2618a <ccm_auth+0x182>
}
   26112:	4630      	mov	r0, r6
   26114:	b00f      	add	sp, #60	; 0x3c
   26116:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			b[i] = X0[i] ^ aad[j];
   2611a:	5c17      	ldrb	r7, [r2, r0]
   2611c:	f813 1b01 	ldrb.w	r1, [r3], #1
   26120:	4079      	eors	r1, r7
   26122:	af02      	add	r7, sp, #8
   26124:	5439      	strb	r1, [r7, r0]
		for (; i < aad_len; i++, j++) {
   26126:	3001      	adds	r0, #1
   26128:	e7c3      	b.n	260b2 <ccm_auth+0xaa>
			b[i] = X0[i];
   2612a:	a802      	add	r0, sp, #8
   2612c:	5c53      	ldrb	r3, [r2, r1]
   2612e:	5443      	strb	r3, [r0, r1]
		for (i = aad_len; i < 16; i++) {
   26130:	3101      	adds	r1, #1
   26132:	e7c1      	b.n	260b8 <ccm_auth+0xb0>
		if (j + 1 == blk_cnt) {
   26134:	013a      	lsls	r2, r7, #4
   26136:	9b01      	ldr	r3, [sp, #4]
   26138:	3701      	adds	r7, #1
   2613a:	42bd      	cmp	r5, r7
   2613c:	441a      	add	r2, r3
   2613e:	d11f      	bne.n	26180 <ccm_auth+0x178>
   26140:	f10d 0c18 	add.w	ip, sp, #24
   26144:	a802      	add	r0, sp, #8
			for (i = 0; i < last_blk; i++) {
   26146:	2300      	movs	r3, #0
				b[i] = Xn[i] ^ cleartext_msg[(j * 16) + i];
   26148:	f81c 1b01 	ldrb.w	r1, [ip], #1
   2614c:	f812 eb01 	ldrb.w	lr, [r2], #1
			for (i = 0; i < last_blk; i++) {
   26150:	3301      	adds	r3, #1
				b[i] = Xn[i] ^ cleartext_msg[(j * 16) + i];
   26152:	ea81 010e 	eor.w	r1, r1, lr
			for (i = 0; i < last_blk; i++) {
   26156:	459a      	cmp	sl, r3
				b[i] = Xn[i] ^ cleartext_msg[(j * 16) + i];
   26158:	f800 1b01 	strb.w	r1, [r0], #1
			for (i = 0; i < last_blk; i++) {
   2615c:	dcf4      	bgt.n	26148 <ccm_auth+0x140>
			memcpy(&b[i], &Xn[i], 16 - i);
   2615e:	ab02      	add	r3, sp, #8
   26160:	f1ca 0210 	rsb	r2, sl, #16
   26164:	4621      	mov	r1, r4
   26166:	eb03 000a 	add.w	r0, r3, sl
   2616a:	f7ff fd9d 	bl	25ca8 <memcpy>
		err = bt_encrypt_be(key, b, Xn);
   2616e:	aa06      	add	r2, sp, #24
   26170:	a902      	add	r1, sp, #8
   26172:	4640      	mov	r0, r8
   26174:	f002 f90f 	bl	28396 <bt_encrypt_be>
		if (err) {
   26178:	2800      	cmp	r0, #0
   2617a:	d0c3      	beq.n	26104 <ccm_auth+0xfc>
		err = bt_encrypt_be(key, b, Xn);
   2617c:	4606      	mov	r6, r0
   2617e:	e7c8      	b.n	26112 <ccm_auth+0x10a>
			xor16(b, Xn, &cleartext_msg[j * 16]);
   26180:	a906      	add	r1, sp, #24
   26182:	a802      	add	r0, sp, #8
   26184:	f7ff feb3 	bl	25eee <xor16>
   26188:	e7f1      	b.n	2616e <ccm_auth+0x166>
		mic[i] = s0[i] ^ Xn[i];
   2618a:	5c58      	ldrb	r0, [r3, r1]
   2618c:	f819 2003 	ldrb.w	r2, [r9, r3]
   26190:	4042      	eors	r2, r0
   26192:	981a      	ldr	r0, [sp, #104]	; 0x68
   26194:	54c2      	strb	r2, [r0, r3]
	for (i = 0; i < mic_size; i++) {
   26196:	3301      	adds	r3, #1
   26198:	e7b8      	b.n	2610c <ccm_auth+0x104>

0002619a <bt_ccm_decrypt>:

int bt_ccm_decrypt(const u8_t key[16], u8_t nonce[13], const u8_t *enc_msg,
		   size_t msg_len, const u8_t *aad, size_t aad_len,
		   u8_t *out_msg, size_t mic_size)
{
   2619a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2619e:	b089      	sub	sp, #36	; 0x24
   261a0:	e9dd ba13 	ldrd	fp, sl, [sp, #76]	; 0x4c
	u8_t mic[16];

	if (aad_len >= 0xff00 || mic_size > sizeof(mic)) {
   261a4:	f5bb 4f7f 	cmp.w	fp, #65280	; 0xff00
{
   261a8:	9e15      	ldr	r6, [sp, #84]	; 0x54
   261aa:	4607      	mov	r7, r0
   261ac:	4688      	mov	r8, r1
   261ae:	4615      	mov	r5, r2
   261b0:	461c      	mov	r4, r3
	if (aad_len >= 0xff00 || mic_size > sizeof(mic)) {
   261b2:	d21e      	bcs.n	261f2 <bt_ccm_decrypt+0x58>
   261b4:	2e10      	cmp	r6, #16
   261b6:	d81c      	bhi.n	261f2 <bt_ccm_decrypt+0x58>
		return -EINVAL;
	}

	ccm_crypt(key, nonce, enc_msg, out_msg, msg_len);
   261b8:	9300      	str	r3, [sp, #0]
   261ba:	4653      	mov	r3, sl
   261bc:	f7ff fed9 	bl	25f72 <ccm_crypt>

	ccm_auth(key, nonce, out_msg, msg_len, aad, aad_len, mic, mic_size);
   261c0:	f10d 0910 	add.w	r9, sp, #16
   261c4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   261c6:	9300      	str	r3, [sp, #0]
   261c8:	4652      	mov	r2, sl
   261ca:	4623      	mov	r3, r4
   261cc:	4641      	mov	r1, r8
   261ce:	e9cd b901 	strd	fp, r9, [sp, #4]
   261d2:	9603      	str	r6, [sp, #12]
   261d4:	4638      	mov	r0, r7
   261d6:	f7ff ff17 	bl	26008 <ccm_auth>

	if (memcmp(mic, enc_msg + msg_len, mic_size)) {
   261da:	4632      	mov	r2, r6
   261dc:	1929      	adds	r1, r5, r4
   261de:	4648      	mov	r0, r9
   261e0:	f7ff fd52 	bl	25c88 <memcmp>
   261e4:	2800      	cmp	r0, #0
		return -EBADMSG;
   261e6:	bf18      	it	ne
   261e8:	f06f 004c 	mvnne.w	r0, #76	; 0x4c
	}

	return 0;
}
   261ec:	b009      	add	sp, #36	; 0x24
   261ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -EINVAL;
   261f2:	f06f 0015 	mvn.w	r0, #21
   261f6:	e7f9      	b.n	261ec <bt_ccm_decrypt+0x52>

000261f8 <bt_ccm_encrypt>:

int bt_ccm_encrypt(const u8_t key[16], u8_t nonce[13], const u8_t *msg,
		   size_t msg_len, const u8_t *aad, size_t aad_len,
		   u8_t *out_msg, size_t mic_size)
{
   261f8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   261fc:	4617      	mov	r7, r2
   261fe:	e9dd 280b 	ldrd	r2, r8, [sp, #44]	; 0x2c
	BT_DBG("nonce %s", bt_hex(nonce, 13));
	BT_DBG("msg (len %zu) %s", msg_len, bt_hex(msg, msg_len));
	BT_DBG("aad_len %zu mic_size %zu", aad_len, mic_size);

	/* Unsupported AAD size */
	if (aad_len >= 0xff00 || mic_size > 16) {
   26202:	f5b2 4f7f 	cmp.w	r2, #65280	; 0xff00
{
   26206:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
   2620a:	4605      	mov	r5, r0
   2620c:	460e      	mov	r6, r1
   2620e:	461c      	mov	r4, r3
	u8_t *mic = out_msg + msg_len;
   26210:	eb08 0e03 	add.w	lr, r8, r3
	if (aad_len >= 0xff00 || mic_size > 16) {
   26214:	d215      	bcs.n	26242 <bt_ccm_encrypt+0x4a>
   26216:	f1bc 0f10 	cmp.w	ip, #16
   2621a:	d812      	bhi.n	26242 <bt_ccm_encrypt+0x4a>
		return -EINVAL;
	}

	ccm_auth(key, nonce, out_msg, msg_len, aad, aad_len, mic, mic_size);
   2621c:	9201      	str	r2, [sp, #4]
   2621e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   26220:	9200      	str	r2, [sp, #0]
   26222:	e9cd ec02 	strd	lr, ip, [sp, #8]
   26226:	4642      	mov	r2, r8
   26228:	f7ff feee 	bl	26008 <ccm_auth>

	ccm_crypt(key, nonce, msg, out_msg, msg_len);
   2622c:	9400      	str	r4, [sp, #0]
   2622e:	4643      	mov	r3, r8
   26230:	463a      	mov	r2, r7
   26232:	4631      	mov	r1, r6
   26234:	4628      	mov	r0, r5
   26236:	f7ff fe9c 	bl	25f72 <ccm_crypt>

	return 0;
   2623a:	2000      	movs	r0, #0
}
   2623c:	b004      	add	sp, #16
   2623e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EINVAL;
   26242:	f06f 0015 	mvn.w	r0, #21
   26246:	e7f9      	b.n	2623c <bt_ccm_encrypt+0x44>

00026248 <bt_uuid_cmp>:
{
   26248:	b510      	push	{r4, lr}
   2624a:	460c      	mov	r4, r1
	if (u1->type != u2->type) {
   2624c:	7801      	ldrb	r1, [r0, #0]
   2624e:	7822      	ldrb	r2, [r4, #0]
   26250:	428a      	cmp	r2, r1
{
   26252:	b08a      	sub	sp, #40	; 0x28
	if (u1->type != u2->type) {
   26254:	d00e      	beq.n	26274 <bt_uuid_cmp+0x2c>
	uuid_to_uuid128(u1, &uuid1);
   26256:	4669      	mov	r1, sp
   26258:	f7e0 f9e0 	bl	661c <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
   2625c:	a905      	add	r1, sp, #20
   2625e:	4620      	mov	r0, r4
   26260:	f7e0 f9dc 	bl	661c <uuid_to_uuid128>
	return memcmp(uuid1.val, uuid2.val, 16);
   26264:	2210      	movs	r2, #16
   26266:	f10d 0115 	add.w	r1, sp, #21
   2626a:	f10d 0001 	add.w	r0, sp, #1
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   2626e:	f7ff fd0b 	bl	25c88 <memcmp>
   26272:	e007      	b.n	26284 <bt_uuid_cmp+0x3c>
	switch (u1->type) {
   26274:	2a01      	cmp	r2, #1
   26276:	d007      	beq.n	26288 <bt_uuid_cmp+0x40>
   26278:	2a02      	cmp	r2, #2
   2627a:	d008      	beq.n	2628e <bt_uuid_cmp+0x46>
   2627c:	b95a      	cbnz	r2, 26296 <bt_uuid_cmp+0x4e>
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
   2627e:	8840      	ldrh	r0, [r0, #2]
   26280:	8863      	ldrh	r3, [r4, #2]
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   26282:	1ac0      	subs	r0, r0, r3
}
   26284:	b00a      	add	sp, #40	; 0x28
   26286:	bd10      	pop	{r4, pc}
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   26288:	6840      	ldr	r0, [r0, #4]
   2628a:	6863      	ldr	r3, [r4, #4]
   2628c:	e7f9      	b.n	26282 <bt_uuid_cmp+0x3a>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   2628e:	2210      	movs	r2, #16
   26290:	1c61      	adds	r1, r4, #1
   26292:	3001      	adds	r0, #1
   26294:	e7eb      	b.n	2626e <bt_uuid_cmp+0x26>
	switch (u1->type) {
   26296:	f06f 0015 	mvn.w	r0, #21
   2629a:	e7f3      	b.n	26284 <bt_uuid_cmp+0x3c>

0002629c <bt_uuid_create>:
	switch (data_len) {
   2629c:	2a04      	cmp	r2, #4
{
   2629e:	b538      	push	{r3, r4, r5, lr}
   262a0:	460c      	mov	r4, r1
	switch (data_len) {
   262a2:	d00d      	beq.n	262c0 <bt_uuid_create+0x24>
   262a4:	2a10      	cmp	r2, #16
   262a6:	d019      	beq.n	262dc <bt_uuid_create+0x40>
   262a8:	2a02      	cmp	r2, #2
   262aa:	f04f 0300 	mov.w	r3, #0
   262ae:	d11b      	bne.n	262e8 <bt_uuid_create+0x4c>
		uuid->type = BT_UUID_TYPE_16;
   262b0:	7003      	strb	r3, [r0, #0]
	return ((u16_t)src[1] << 8) | src[0];
   262b2:	784a      	ldrb	r2, [r1, #1]
   262b4:	780b      	ldrb	r3, [r1, #0]
   262b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		BT_UUID_16(uuid)->val = sys_get_le16(data);
   262ba:	8043      	strh	r3, [r0, #2]
	return true;
   262bc:	2001      	movs	r0, #1
}
   262be:	bd38      	pop	{r3, r4, r5, pc}
		uuid->type = BT_UUID_TYPE_32;
   262c0:	2301      	movs	r3, #1
   262c2:	7003      	strb	r3, [r0, #0]
   262c4:	78a2      	ldrb	r2, [r4, #2]
   262c6:	78c9      	ldrb	r1, [r1, #3]
   262c8:	7865      	ldrb	r5, [r4, #1]
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   262ca:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
	return ((u16_t)src[1] << 8) | src[0];
   262ce:	7822      	ldrb	r2, [r4, #0]
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   262d0:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
   262d4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
		BT_UUID_32(uuid)->val = sys_get_le32(data);
   262d8:	6042      	str	r2, [r0, #4]
		break;
   262da:	e7ef      	b.n	262bc <bt_uuid_create+0x20>
		uuid->type = BT_UUID_TYPE_128;
   262dc:	2302      	movs	r3, #2
   262de:	f800 3b01 	strb.w	r3, [r0], #1
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
   262e2:	f7ff fce1 	bl	25ca8 <memcpy>
		break;
   262e6:	e7e9      	b.n	262bc <bt_uuid_create+0x20>
	switch (data_len) {
   262e8:	4618      	mov	r0, r3
   262ea:	e7e8      	b.n	262be <bt_uuid_create+0x22>

000262ec <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   262ec:	f3bf 8f5b 	dmb	ish
   262f0:	6800      	ldr	r0, [r0, #0]
   262f2:	f3bf 8f5b 	dmb	ish
}
   262f6:	4770      	bx	lr

000262f8 <bt_addr_le_copy>:
   262f8:	2207      	movs	r2, #7
   262fa:	f7ff bcd5 	b.w	25ca8 <memcpy>

000262fe <atomic_or>:
{
   262fe:	4603      	mov	r3, r0
}
   26300:	f3bf 8f5b 	dmb	ish
   26304:	e853 0f00 	ldrex	r0, [r3]
   26308:	ea40 0201 	orr.w	r2, r0, r1
   2630c:	e843 2c00 	strex	ip, r2, [r3]
   26310:	f1bc 0f00 	cmp.w	ip, #0
   26314:	d1f6      	bne.n	26304 <atomic_or+0x6>
   26316:	f3bf 8f5b 	dmb	ish
   2631a:	4770      	bx	lr

0002631c <atomic_test_and_set_bit>:
{
   2631c:	b508      	push	{r3, lr}
	atomic_val_t mask = ATOMIC_MASK(bit);
   2631e:	2301      	movs	r3, #1
   26320:	fa03 f101 	lsl.w	r1, r3, r1
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   26324:	f7ff ffeb 	bl	262fe <atomic_or>
	return (old & mask) != 0;
   26328:	4201      	tst	r1, r0
}
   2632a:	bf14      	ite	ne
   2632c:	2001      	movne	r0, #1
   2632e:	2000      	moveq	r0, #0
   26330:	bd08      	pop	{r3, pc}

00026332 <atomic_and>:
{
   26332:	4603      	mov	r3, r0
}
   26334:	f3bf 8f5b 	dmb	ish
   26338:	e853 0f00 	ldrex	r0, [r3]
   2633c:	ea00 0201 	and.w	r2, r0, r1
   26340:	e843 2c00 	strex	ip, r2, [r3]
   26344:	f1bc 0f00 	cmp.w	ip, #0
   26348:	d1f6      	bne.n	26338 <atomic_and+0x6>
   2634a:	f3bf 8f5b 	dmb	ish
   2634e:	4770      	bx	lr

00026350 <atomic_set_bit_to>:
{
   26350:	460b      	mov	r3, r1
   26352:	b410      	push	{r4}
   26354:	095b      	lsrs	r3, r3, #5
	atomic_val_t mask = ATOMIC_MASK(bit);
   26356:	f001 041f 	and.w	r4, r1, #31
   2635a:	2101      	movs	r1, #1
   2635c:	40a1      	lsls	r1, r4
	if (val) {
   2635e:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   26362:	b112      	cbz	r2, 2636a <atomic_set_bit_to+0x1a>
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
	}
}
   26364:	bc10      	pop	{r4}
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   26366:	f7ff bfca 	b.w	262fe <atomic_or>
}
   2636a:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2636c:	43c9      	mvns	r1, r1
   2636e:	f7ff bfe0 	b.w	26332 <atomic_and>

00026372 <le_adv_set_private_addr.isra.0>:
static int le_adv_set_private_addr(struct bt_le_ext_adv *adv)
   26372:	b507      	push	{r0, r1, r2, lr}
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
   26374:	2106      	movs	r1, #6
   26376:	4668      	mov	r0, sp
   26378:	f002 f80b 	bl	28392 <bt_rand>
	if (err) {
   2637c:	b940      	cbnz	r0, 26390 <le_adv_set_private_addr.isra.0+0x1e>
	nrpa.val[5] &= 0x3f;
   2637e:	f89d 3005 	ldrb.w	r3, [sp, #5]
		return set_random_address(addr);
   26382:	4668      	mov	r0, sp
	nrpa.val[5] &= 0x3f;
   26384:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   26388:	f88d 3005 	strb.w	r3, [sp, #5]
		return set_random_address(addr);
   2638c:	f7e1 f8f0 	bl	7570 <set_random_address>
}
   26390:	b003      	add	sp, #12
   26392:	f85d fb04 	ldr.w	pc, [sp], #4

00026396 <bt_hci_disconnect>:
{
   26396:	b570      	push	{r4, r5, r6, lr}
   26398:	4606      	mov	r6, r0
   2639a:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
   2639c:	f240 4006 	movw	r0, #1030	; 0x406
   263a0:	2103      	movs	r1, #3
   263a2:	f7e0 fe15 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
   263a6:	4604      	mov	r4, r0
   263a8:	b160      	cbz	r0, 263c4 <bt_hci_disconnect+0x2e>
	disconn = net_buf_add(buf, sizeof(*disconn));
   263aa:	2103      	movs	r1, #3
   263ac:	3008      	adds	r0, #8
   263ae:	f7f8 ff93 	bl	1f2d8 <net_buf_simple_add>
	disconn->reason = reason;
   263b2:	7085      	strb	r5, [r0, #2]
	disconn->handle = sys_cpu_to_le16(handle);
   263b4:	8006      	strh	r6, [r0, #0]
	return bt_hci_cmd_send(BT_HCI_OP_DISCONNECT, buf);
   263b6:	4621      	mov	r1, r4
   263b8:	f240 4006 	movw	r0, #1030	; 0x406
}
   263bc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_hci_cmd_send(BT_HCI_OP_DISCONNECT, buf);
   263c0:	f7e0 be4e 	b.w	7060 <bt_hci_cmd_send>
}
   263c4:	f06f 0036 	mvn.w	r0, #54	; 0x36
   263c8:	bd70      	pop	{r4, r5, r6, pc}

000263ca <bt_le_conn_params_valid>:
	if (param->interval_min > param->interval_max ||
   263ca:	8802      	ldrh	r2, [r0, #0]
   263cc:	8843      	ldrh	r3, [r0, #2]
   263ce:	429a      	cmp	r2, r3
{
   263d0:	b510      	push	{r4, lr}
	if (param->interval_min > param->interval_max ||
   263d2:	d818      	bhi.n	26406 <bt_le_conn_params_valid+0x3c>
   263d4:	2a05      	cmp	r2, #5
   263d6:	d916      	bls.n	26406 <bt_le_conn_params_valid+0x3c>
	    param->interval_min < 6 || param->interval_max > 3200) {
   263d8:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   263dc:	d813      	bhi.n	26406 <bt_le_conn_params_valid+0x3c>
	if (param->latency > 499) {
   263de:	8884      	ldrh	r4, [r0, #4]
   263e0:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
   263e4:	d20f      	bcs.n	26406 <bt_le_conn_params_valid+0x3c>
	if (param->timeout < 10 || param->timeout > 3200 ||
   263e6:	88c1      	ldrh	r1, [r0, #6]
   263e8:	f1a1 020a 	sub.w	r2, r1, #10
   263ec:	b292      	uxth	r2, r2
   263ee:	f640 4076 	movw	r0, #3190	; 0xc76
   263f2:	4282      	cmp	r2, r0
   263f4:	d807      	bhi.n	26406 <bt_le_conn_params_valid+0x3c>
	     ((1 + param->latency) * param->interval_max))) {
   263f6:	fb04 3303 	mla	r3, r4, r3, r3
	if (param->timeout < 10 || param->timeout > 3200 ||
   263fa:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
   263fe:	bf34      	ite	cc
   26400:	2001      	movcc	r0, #1
   26402:	2000      	movcs	r0, #0
}
   26404:	bd10      	pop	{r4, pc}
		return false;
   26406:	2000      	movs	r0, #0
   26408:	e7fc      	b.n	26404 <bt_le_conn_params_valid+0x3a>

0002640a <bt_addr_le_create_static>:
	addr->type = BT_ADDR_LE_RANDOM;
   2640a:	2301      	movs	r3, #1
{
   2640c:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
   2640e:	2106      	movs	r1, #6
{
   26410:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   26412:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   26416:	f001 ffbc 	bl	28392 <bt_rand>
	if (err) {
   2641a:	b918      	cbnz	r0, 26424 <bt_addr_le_create_static+0x1a>
	BT_ADDR_SET_STATIC(&addr->a);
   2641c:	79a3      	ldrb	r3, [r4, #6]
   2641e:	f063 033f 	orn	r3, r3, #63	; 0x3f
   26422:	71a3      	strb	r3, [r4, #6]
}
   26424:	bd10      	pop	{r4, pc}

00026426 <bt_send>:
		return bt_hci_ecc_send(buf);
   26426:	f7df bef7 	b.w	6218 <bt_hci_ecc_send>

0002642a <bt_addr_le_is_bonded>:
}
   2642a:	2000      	movs	r0, #0
   2642c:	4770      	bx	lr

0002642e <bt_le_adv_start>:
{
   2642e:	b513      	push	{r0, r1, r4, lr}
	if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
   26430:	6844      	ldr	r4, [r0, #4]
   26432:	f014 0410 	ands.w	r4, r4, #16
   26436:	d106      	bne.n	26446 <bt_le_adv_start+0x18>
	return bt_le_adv_start_legacy(param, ad, ad_len, sd, sd_len, peer);
   26438:	9401      	str	r4, [sp, #4]
   2643a:	9c04      	ldr	r4, [sp, #16]
   2643c:	9400      	str	r4, [sp, #0]
   2643e:	f7e1 ff35 	bl	82ac <bt_le_adv_start_legacy>
}
   26442:	b002      	add	sp, #8
   26444:	bd10      	pop	{r4, pc}
		return -EINVAL;
   26446:	f06f 0015 	mvn.w	r0, #21
   2644a:	e7fa      	b.n	26442 <bt_le_adv_start+0x14>

0002644c <le_enh_conn_complete>:
	enh_conn_complete((void *)buf->data);
   2644c:	6880      	ldr	r0, [r0, #8]
   2644e:	f7e2 b8ff 	b.w	8650 <enh_conn_complete>

00026452 <le_legacy_conn_complete>:
{
   26452:	b510      	push	{r4, lr}
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
   26454:	6881      	ldr	r1, [r0, #8]
{
   26456:	b08a      	sub	sp, #40	; 0x28
	enh.status         = evt->status;
   26458:	780b      	ldrb	r3, [r1, #0]
   2645a:	f88d 3008 	strb.w	r3, [sp, #8]
	enh.handle         = evt->handle;
   2645e:	f8b1 3001 	ldrh.w	r3, [r1, #1]
   26462:	f8ad 3009 	strh.w	r3, [sp, #9]
	enh.role           = evt->role;
   26466:	78cb      	ldrb	r3, [r1, #3]
   26468:	f88d 300b 	strb.w	r3, [sp, #11]
	enh.interval       = evt->interval;
   2646c:	f8b1 300b 	ldrh.w	r3, [r1, #11]
   26470:	f8ad 301f 	strh.w	r3, [sp, #31]
	enh.latency        = evt->latency;
   26474:	f8b1 300d 	ldrh.w	r3, [r1, #13]
   26478:	f8ad 3021 	strh.w	r3, [sp, #33]	; 0x21
	enh.supv_timeout   = evt->supv_timeout;
   2647c:	f8b1 300f 	ldrh.w	r3, [r1, #15]
   26480:	f8ad 3023 	strh.w	r3, [sp, #35]	; 0x23
	enh.clock_accuracy = evt->clock_accuracy;
   26484:	7c4b      	ldrb	r3, [r1, #17]
   26486:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   2648a:	a803      	add	r0, sp, #12
   2648c:	3104      	adds	r1, #4
   2648e:	f7ff ff33 	bl	262f8 <bt_addr_le_copy>
		bt_addr_copy(&enh.local_rpa, BT_ADDR_ANY);
   26492:	2400      	movs	r4, #0
	memcpy(dst, src, sizeof(*dst));
   26494:	4669      	mov	r1, sp
   26496:	2206      	movs	r2, #6
   26498:	f10d 0013 	add.w	r0, sp, #19
   2649c:	9400      	str	r4, [sp, #0]
   2649e:	f8ad 4004 	strh.w	r4, [sp, #4]
   264a2:	f7ff fc01 	bl	25ca8 <memcpy>
   264a6:	2206      	movs	r2, #6
   264a8:	4669      	mov	r1, sp
   264aa:	f10d 0019 	add.w	r0, sp, #25
	bt_addr_copy(&enh.peer_rpa, BT_ADDR_ANY);
   264ae:	9400      	str	r4, [sp, #0]
   264b0:	f8ad 4004 	strh.w	r4, [sp, #4]
   264b4:	f7ff fbf8 	bl	25ca8 <memcpy>
	enh_conn_complete(&enh);
   264b8:	a802      	add	r0, sp, #8
   264ba:	f7e2 f8c9 	bl	8650 <enh_conn_complete>
}
   264be:	b00a      	add	sp, #40	; 0x28
   264c0:	bd10      	pop	{r4, pc}

000264c2 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   264c2:	f3bf 8f5b 	dmb	ish
   264c6:	6800      	ldr	r0, [r0, #0]
   264c8:	f3bf 8f5b 	dmb	ish
}
   264cc:	4770      	bx	lr

000264ce <bt_conn_reset_rx_state>:
	if (!conn->rx_len) {
   264ce:	8983      	ldrh	r3, [r0, #12]
{
   264d0:	b510      	push	{r4, lr}
   264d2:	4604      	mov	r4, r0
	if (!conn->rx_len) {
   264d4:	b12b      	cbz	r3, 264e2 <bt_conn_reset_rx_state+0x14>
	net_buf_unref(conn->rx);
   264d6:	6900      	ldr	r0, [r0, #16]
   264d8:	f7f8 fdf6 	bl	1f0c8 <net_buf_unref>
	conn->rx = NULL;
   264dc:	2300      	movs	r3, #0
   264de:	6123      	str	r3, [r4, #16]
	conn->rx_len = 0U;
   264e0:	81a3      	strh	r3, [r4, #12]
}
   264e2:	bd10      	pop	{r4, pc}

000264e4 <atomic_dec>:
{
   264e4:	4603      	mov	r3, r0
}
   264e6:	f3bf 8f5b 	dmb	ish
   264ea:	e853 0f00 	ldrex	r0, [r3]
   264ee:	1e42      	subs	r2, r0, #1
   264f0:	e843 2100 	strex	r1, r2, [r3]
   264f4:	2900      	cmp	r1, #0
   264f6:	d1f8      	bne.n	264ea <atomic_dec+0x6>
   264f8:	f3bf 8f5b 	dmb	ish
   264fc:	4770      	bx	lr

000264fe <atomic_inc>:
{
   264fe:	4603      	mov	r3, r0
}
   26500:	f3bf 8f5b 	dmb	ish
   26504:	e853 0f00 	ldrex	r0, [r3]
   26508:	1c42      	adds	r2, r0, #1
   2650a:	e843 2100 	strex	r1, r2, [r3]
   2650e:	2900      	cmp	r1, #0
   26510:	d1f8      	bne.n	26504 <atomic_inc+0x6>
   26512:	f3bf 8f5b 	dmb	ish
   26516:	4770      	bx	lr

00026518 <tx_notify>:
{
   26518:	b570      	push	{r4, r5, r6, lr}
   2651a:	4604      	mov	r4, r0
	__asm__ volatile(
   2651c:	f04f 0220 	mov.w	r2, #32
   26520:	f3ef 8311 	mrs	r3, BASEPRI
   26524:	f382 8811 	msr	BASEPRI, r2
   26528:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   2652c:	6a20      	ldr	r0, [r4, #32]
		if (sys_slist_is_empty(&conn->tx_complete)) {
   2652e:	b920      	cbnz	r0, 2653a <tx_notify+0x22>
	__asm__ volatile(
   26530:	f383 8811 	msr	BASEPRI, r3
   26534:	f3bf 8f6f 	isb	sy
}
   26538:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2653a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2653c:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   2653e:	6222      	str	r2, [r4, #32]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   26540:	4288      	cmp	r0, r1
	list->tail = node;
   26542:	bf08      	it	eq
   26544:	6262      	streq	r2, [r4, #36]	; 0x24
   26546:	f383 8811 	msr	BASEPRI, r3
   2654a:	f3bf 8f6f 	isb	sy
		user_data = tx->user_data;
   2654e:	e9d0 5601 	ldrd	r5, r6, [r0, #4]
		tx_free(tx);
   26552:	f7e2 fb19 	bl	8b88 <tx_free>
		cb(conn, user_data);
   26556:	4631      	mov	r1, r6
   26558:	4620      	mov	r0, r4
   2655a:	47a8      	blx	r5
	while (1) {
   2655c:	e7de      	b.n	2651c <tx_notify+0x4>

0002655e <tx_complete_work>:
	tx_notify(conn);
   2655e:	3828      	subs	r0, #40	; 0x28
   26560:	f7ff bfda 	b.w	26518 <tx_notify>

00026564 <bt_conn_get_security>:
}
   26564:	2001      	movs	r0, #1
   26566:	4770      	bx	lr

00026568 <bt_conn_is_peer_addr_le>:
{
   26568:	b538      	push	{r3, r4, r5, lr}
	if (id != conn->id) {
   2656a:	7a03      	ldrb	r3, [r0, #8]
   2656c:	428b      	cmp	r3, r1
{
   2656e:	4604      	mov	r4, r0
   26570:	4615      	mov	r5, r2
	if (id != conn->id) {
   26572:	d115      	bne.n	265a0 <bt_conn_is_peer_addr_le+0x38>
	return memcmp(a, b, sizeof(*a));
   26574:	f100 0174 	add.w	r1, r0, #116	; 0x74
   26578:	2207      	movs	r2, #7
   2657a:	4628      	mov	r0, r5
   2657c:	f7ff fb84 	bl	25c88 <memcmp>
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   26580:	b180      	cbz	r0, 265a4 <bt_conn_is_peer_addr_le+0x3c>
	if (conn->role == BT_HCI_ROLE_MASTER) {
   26582:	78e3      	ldrb	r3, [r4, #3]
   26584:	2207      	movs	r2, #7
   26586:	b943      	cbnz	r3, 2659a <bt_conn_is_peer_addr_le+0x32>
   26588:	f104 0182 	add.w	r1, r4, #130	; 0x82
   2658c:	4628      	mov	r0, r5
   2658e:	f7ff fb7b 	bl	25c88 <memcmp>
	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
   26592:	fab0 f080 	clz	r0, r0
   26596:	0940      	lsrs	r0, r0, #5
}
   26598:	bd38      	pop	{r3, r4, r5, pc}
   2659a:	f104 017b 	add.w	r1, r4, #123	; 0x7b
   2659e:	e7f5      	b.n	2658c <bt_conn_is_peer_addr_le+0x24>
		return false;
   265a0:	2000      	movs	r0, #0
   265a2:	e7f9      	b.n	26598 <bt_conn_is_peer_addr_le+0x30>
		return true;
   265a4:	2001      	movs	r0, #1
   265a6:	e7f7      	b.n	26598 <bt_conn_is_peer_addr_le+0x30>

000265a8 <bt_conn_ref>:
{
   265a8:	b510      	push	{r4, lr}
   265aa:	4604      	mov	r4, r0
	atomic_val_t old = atomic_inc(&conn->ref);
   265ac:	3050      	adds	r0, #80	; 0x50
   265ae:	f7ff ffa6 	bl	264fe <atomic_inc>
}
   265b2:	4620      	mov	r0, r4
   265b4:	bd10      	pop	{r4, pc}

000265b6 <bt_conn_unref>:
	atomic_val_t old = atomic_dec(&conn->ref);
   265b6:	3050      	adds	r0, #80	; 0x50
   265b8:	f7ff bf94 	b.w	264e4 <atomic_dec>

000265bc <bt_conn_disconnect>:
{
   265bc:	b538      	push	{r3, r4, r5, lr}
   265be:	7a83      	ldrb	r3, [r0, #10]
   265c0:	3b01      	subs	r3, #1
   265c2:	4604      	mov	r4, r0
   265c4:	2b06      	cmp	r3, #6
   265c6:	d805      	bhi.n	265d4 <bt_conn_disconnect+0x18>
   265c8:	e8df f003 	tbb	[pc, r3]
   265cc:	0e040408 	.word	0x0e040408
   265d0:	160c      	.short	0x160c
   265d2:	0c          	.byte	0x0c
   265d3:	00          	.byte	0x00
	switch (conn->state) {
   265d4:	f06f 0538 	mvn.w	r5, #56	; 0x38
}
   265d8:	4628      	mov	r0, r5
   265da:	bd38      	pop	{r3, r4, r5, pc}
		conn->err = reason;
   265dc:	7241      	strb	r1, [r0, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   265de:	2100      	movs	r1, #0
   265e0:	f7e2 fdc4 	bl	916c <bt_conn_set_state>
		return 0;
   265e4:	2500      	movs	r5, #0
   265e6:	e7f7      	b.n	265d8 <bt_conn_disconnect+0x1c>
		conn->err = reason;
   265e8:	7241      	strb	r1, [r0, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   265ea:	2100      	movs	r1, #0
   265ec:	f7e2 fdbe 	bl	916c <bt_conn_set_state>
}
   265f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			return bt_le_adv_stop();
   265f4:	f7e1 bf60 	b.w	84b8 <bt_le_adv_stop>
	err = bt_hci_disconnect(conn->handle, reason);
   265f8:	8800      	ldrh	r0, [r0, #0]
   265fa:	f7ff fecc 	bl	26396 <bt_hci_disconnect>
	if (err) {
   265fe:	4605      	mov	r5, r0
   26600:	2800      	cmp	r0, #0
   26602:	d1e9      	bne.n	265d8 <bt_conn_disconnect+0x1c>
	bt_conn_set_state(conn, BT_CONN_DISCONNECT);
   26604:	2107      	movs	r1, #7
   26606:	4620      	mov	r0, r4
   26608:	f7e2 fdb0 	bl	916c <bt_conn_set_state>
	return 0;
   2660c:	e7e4      	b.n	265d8 <bt_conn_disconnect+0x1c>

0002660e <bt_conn_le_conn_update>:
{
   2660e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   26610:	4607      	mov	r7, r0
   26612:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   26614:	f242 0013 	movw	r0, #8211	; 0x2013
   26618:	210e      	movs	r1, #14
   2661a:	f7e0 fcd9 	bl	6fd0 <bt_hci_cmd_create>
	if (!buf) {
   2661e:	4606      	mov	r6, r0
   26620:	b1d0      	cbz	r0, 26658 <bt_conn_le_conn_update+0x4a>
	conn_update = net_buf_add(buf, sizeof(*conn_update));
   26622:	210e      	movs	r1, #14
   26624:	3008      	adds	r0, #8
   26626:	f7f8 fe57 	bl	1f2d8 <net_buf_simple_add>
	(void)memset(conn_update, 0, sizeof(*conn_update));
   2662a:	220e      	movs	r2, #14
	conn_update = net_buf_add(buf, sizeof(*conn_update));
   2662c:	4604      	mov	r4, r0
	(void)memset(conn_update, 0, sizeof(*conn_update));
   2662e:	2100      	movs	r1, #0
   26630:	f7ff fb65 	bl	25cfe <memset>
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   26634:	883b      	ldrh	r3, [r7, #0]
   26636:	8023      	strh	r3, [r4, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   26638:	882b      	ldrh	r3, [r5, #0]
   2663a:	8063      	strh	r3, [r4, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   2663c:	886b      	ldrh	r3, [r5, #2]
   2663e:	80a3      	strh	r3, [r4, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   26640:	88ab      	ldrh	r3, [r5, #4]
   26642:	80e3      	strh	r3, [r4, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   26644:	88eb      	ldrh	r3, [r5, #6]
   26646:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   26648:	4631      	mov	r1, r6
   2664a:	2200      	movs	r2, #0
}
   2664c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   26650:	f242 0013 	movw	r0, #8211	; 0x2013
   26654:	f7e0 be34 	b.w	72c0 <bt_hci_cmd_send_sync>
}
   26658:	f06f 0036 	mvn.w	r0, #54	; 0x36
   2665c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002665e <l2cap_connected>:
}
   2665e:	4770      	bx	lr

00026660 <l2cap_disconnected>:
   26660:	4770      	bx	lr

00026662 <bt_l2cap_chan_remove>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   26662:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
   26664:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   26666:	b17b      	cbz	r3, 26688 <bt_l2cap_chan_remove+0x26>
   26668:	3b08      	subs	r3, #8
   2666a:	2200      	movs	r2, #0
   2666c:	b163      	cbz	r3, 26688 <bt_l2cap_chan_remove+0x26>
		if (chan == ch) {
   2666e:	428b      	cmp	r3, r1
   26670:	f103 0408 	add.w	r4, r3, #8
   26674:	d10f      	bne.n	26696 <bt_l2cap_chan_remove+0x34>
Z_GENLIST_REMOVE(slist, snode)
   26676:	688b      	ldr	r3, [r1, #8]
   26678:	b93a      	cbnz	r2, 2668a <bt_l2cap_chan_remove+0x28>
   2667a:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
	list->head = node;
   2667c:	6483      	str	r3, [r0, #72]	; 0x48
Z_GENLIST_REMOVE(slist, snode)
   2667e:	4294      	cmp	r4, r2
   26680:	d100      	bne.n	26684 <bt_l2cap_chan_remove+0x22>
	list->tail = node;
   26682:	64c3      	str	r3, [r0, #76]	; 0x4c
	parent->next = child;
   26684:	2300      	movs	r3, #0
   26686:	608b      	str	r3, [r1, #8]
}
   26688:	bd10      	pop	{r4, pc}
   2668a:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   2668c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   2668e:	429c      	cmp	r4, r3
	list->tail = node;
   26690:	bf08      	it	eq
   26692:	64c2      	streq	r2, [r0, #76]	; 0x4c
}
   26694:	e7f6      	b.n	26684 <bt_l2cap_chan_remove+0x22>
Z_GENLIST_PEEK_NEXT(slist, snode)
   26696:	2c00      	cmp	r4, #0
   26698:	d0f6      	beq.n	26688 <bt_l2cap_chan_remove+0x26>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2669a:	689b      	ldr	r3, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2669c:	2b00      	cmp	r3, #0
   2669e:	d0f3      	beq.n	26688 <bt_l2cap_chan_remove+0x26>
   266a0:	3b08      	subs	r3, #8
   266a2:	4622      	mov	r2, r4
   266a4:	e7e2      	b.n	2666c <bt_l2cap_chan_remove+0xa>

000266a6 <bt_l2cap_chan_del>:
	if (!chan->conn) {
   266a6:	6803      	ldr	r3, [r0, #0]
{
   266a8:	b510      	push	{r4, lr}
   266aa:	4604      	mov	r4, r0
	if (!chan->conn) {
   266ac:	b12b      	cbz	r3, 266ba <bt_l2cap_chan_del+0x14>
	if (chan->ops->disconnected) {
   266ae:	6843      	ldr	r3, [r0, #4]
   266b0:	685b      	ldr	r3, [r3, #4]
   266b2:	b103      	cbz	r3, 266b6 <bt_l2cap_chan_del+0x10>
		chan->ops->disconnected(chan);
   266b4:	4798      	blx	r3
	chan->conn = NULL;
   266b6:	2300      	movs	r3, #0
   266b8:	6023      	str	r3, [r4, #0]
	if (chan->destroy) {
   266ba:	68e3      	ldr	r3, [r4, #12]
   266bc:	b11b      	cbz	r3, 266c6 <bt_l2cap_chan_del+0x20>
		chan->destroy(chan);
   266be:	4620      	mov	r0, r4
}
   266c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		chan->destroy(chan);
   266c4:	4718      	bx	r3
}
   266c6:	bd10      	pop	{r4, pc}

000266c8 <bt_l2cap_disconnected>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   266c8:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
   266ca:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   266cc:	b18b      	cbz	r3, 266f2 <bt_l2cap_disconnected+0x2a>
   266ce:	f1b3 0008 	subs.w	r0, r3, #8
   266d2:	d00e      	beq.n	266f2 <bt_l2cap_disconnected+0x2a>
   266d4:	681c      	ldr	r4, [r3, #0]
   266d6:	b104      	cbz	r4, 266da <bt_l2cap_disconnected+0x12>
   266d8:	3c08      	subs	r4, #8
		bt_l2cap_chan_del(chan);
   266da:	f7ff ffe4 	bl	266a6 <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   266de:	b144      	cbz	r4, 266f2 <bt_l2cap_disconnected+0x2a>
Z_GENLIST_PEEK_NEXT(slist, snode)
   266e0:	f114 0308 	adds.w	r3, r4, #8
   266e4:	d002      	beq.n	266ec <bt_l2cap_disconnected+0x24>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   266e6:	68a3      	ldr	r3, [r4, #8]
   266e8:	b103      	cbz	r3, 266ec <bt_l2cap_disconnected+0x24>
   266ea:	3b08      	subs	r3, #8
{
   266ec:	4620      	mov	r0, r4
   266ee:	461c      	mov	r4, r3
   266f0:	e7f3      	b.n	266da <bt_l2cap_disconnected+0x12>
}
   266f2:	bd10      	pop	{r4, pc}

000266f4 <bt_l2cap_create_pdu_timeout>:
	return bt_conn_create_pdu_timeout(pool,
   266f4:	3104      	adds	r1, #4
   266f6:	f7e2 bee9 	b.w	94cc <bt_conn_create_pdu_timeout>

000266fa <bt_l2cap_send_cb>:
{
   266fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   266fe:	4614      	mov	r4, r2
   26700:	4605      	mov	r5, r0
   26702:	460f      	mov	r7, r1
	hdr = net_buf_push(buf, sizeof(*hdr));
   26704:	f102 0008 	add.w	r0, r2, #8
   26708:	2104      	movs	r1, #4
{
   2670a:	461e      	mov	r6, r3
   2670c:	f8dd 8018 	ldr.w	r8, [sp, #24]
	hdr = net_buf_push(buf, sizeof(*hdr));
   26710:	f7f8 fd7e 	bl	1f210 <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   26714:	89a2      	ldrh	r2, [r4, #12]
	hdr->cid = sys_cpu_to_le16(cid);
   26716:	8047      	strh	r7, [r0, #2]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   26718:	3a04      	subs	r2, #4
   2671a:	8002      	strh	r2, [r0, #0]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   2671c:	4643      	mov	r3, r8
   2671e:	4632      	mov	r2, r6
   26720:	4621      	mov	r1, r4
   26722:	4628      	mov	r0, r5
}
   26724:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_conn_send_cb(conn, buf, cb, user_data);
   26728:	f7e2 bc3c 	b.w	8fa4 <bt_conn_send_cb>

0002672c <bt_l2cap_le_lookup_tx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2672c:	6c80      	ldr	r0, [r0, #72]	; 0x48
   2672e:	b160      	cbz	r0, 2674a <bt_l2cap_le_lookup_tx_cid+0x1e>
   26730:	3808      	subs	r0, #8
   26732:	b900      	cbnz	r0, 26736 <bt_l2cap_le_lookup_tx_cid+0xa>
   26734:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
   26736:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
   2673a:	428b      	cmp	r3, r1
   2673c:	d005      	beq.n	2674a <bt_l2cap_le_lookup_tx_cid+0x1e>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2673e:	f110 0308 	adds.w	r3, r0, #8
   26742:	d001      	beq.n	26748 <bt_l2cap_le_lookup_tx_cid+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   26744:	6880      	ldr	r0, [r0, #8]
   26746:	e7f2      	b.n	2672e <bt_l2cap_le_lookup_tx_cid+0x2>
	return NULL;
   26748:	4618      	mov	r0, r3
}
   2674a:	4770      	bx	lr

0002674c <bt_l2cap_le_lookup_rx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2674c:	6c80      	ldr	r0, [r0, #72]	; 0x48
   2674e:	b158      	cbz	r0, 26768 <bt_l2cap_le_lookup_rx_cid+0x1c>
   26750:	3808      	subs	r0, #8
   26752:	b900      	cbnz	r0, 26756 <bt_l2cap_le_lookup_rx_cid+0xa>
   26754:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   26756:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   26758:	428b      	cmp	r3, r1
   2675a:	d005      	beq.n	26768 <bt_l2cap_le_lookup_rx_cid+0x1c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2675c:	f110 0308 	adds.w	r3, r0, #8
   26760:	d001      	beq.n	26766 <bt_l2cap_le_lookup_rx_cid+0x1a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   26762:	6880      	ldr	r0, [r0, #8]
   26764:	e7f3      	b.n	2674e <bt_l2cap_le_lookup_rx_cid+0x2>
	return NULL;
   26766:	4618      	mov	r0, r3
}
   26768:	4770      	bx	lr

0002676a <bt_l2cap_init>:
void bt_l2cap_init(void)
{
	if (IS_ENABLED(CONFIG_BT_BREDR)) {
		bt_l2cap_br_init();
	}
}
   2676a:	4770      	bx	lr

0002676c <att_prepare_write_req>:
}
   2676c:	2006      	movs	r0, #6
   2676e:	4770      	bx	lr

00026770 <att_op_get_type>:
	switch (op) {
   26770:	281e      	cmp	r0, #30
   26772:	d816      	bhi.n	267a2 <att_op_get_type+0x32>
   26774:	b308      	cbz	r0, 267ba <att_op_get_type+0x4a>
   26776:	1e43      	subs	r3, r0, #1
   26778:	2b1d      	cmp	r3, #29
   2677a:	d81e      	bhi.n	267ba <att_op_get_type+0x4a>
   2677c:	e8df f003 	tbb	[pc, r3]
   26780:	23172317 	.word	0x23172317
   26784:	23172317 	.word	0x23172317
   26788:	23172317 	.word	0x23172317
   2678c:	23172317 	.word	0x23172317
   26790:	1d172317 	.word	0x1d172317
   26794:	2317231d 	.word	0x2317231d
   26798:	1d191d17 	.word	0x1d191d17
   2679c:	0f1b      	.short	0x0f1b
   2679e:	2004      	movs	r0, #4
   267a0:	4770      	bx	lr
   267a2:	f000 037f 	and.w	r3, r0, #127	; 0x7f
   267a6:	2b52      	cmp	r3, #82	; 0x52
   267a8:	d107      	bne.n	267ba <att_op_get_type+0x4a>
		return ATT_COMMAND;
   267aa:	2000      	movs	r0, #0
}
   267ac:	4770      	bx	lr
		return ATT_RESPONSE;
   267ae:	2002      	movs	r0, #2
   267b0:	4770      	bx	lr
		return ATT_NOTIFICATION;
   267b2:	2003      	movs	r0, #3
   267b4:	4770      	bx	lr
		return ATT_INDICATION;
   267b6:	2005      	movs	r0, #5
   267b8:	4770      	bx	lr
		return ATT_COMMAND;
   267ba:	f010 0f40 	tst.w	r0, #64	; 0x40
   267be:	bf0c      	ite	eq
   267c0:	2006      	moveq	r0, #6
   267c2:	2000      	movne	r0, #0
   267c4:	4770      	bx	lr
		return ATT_REQUEST;
   267c6:	2001      	movs	r0, #1
   267c8:	4770      	bx	lr

000267ca <bt_gatt_foreach_attr>:
{
   267ca:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   267cc:	e9cd 2301 	strd	r2, r3, [sp, #4]
   267d0:	2300      	movs	r3, #0
   267d2:	9300      	str	r3, [sp, #0]
   267d4:	461a      	mov	r2, r3
   267d6:	f7e4 fd8b 	bl	b2f0 <bt_gatt_foreach_attr_type>
}
   267da:	b005      	add	sp, #20
   267dc:	f85d fb04 	ldr.w	pc, [sp], #4

000267e0 <read_group_cb>:
{
   267e0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_att *att = data->att;
   267e4:	680e      	ldr	r6, [r1, #0]
{
   267e6:	4605      	mov	r5, r0
   267e8:	460c      	mov	r4, r1
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   267ea:	f04f 0800 	mov.w	r8, #0
   267ee:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   267f2:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = att->chan.chan.conn;
   267f4:	6837      	ldr	r7, [r6, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   267f6:	f88d 8008 	strb.w	r8, [sp, #8]
   267fa:	a902      	add	r1, sp, #8
   267fc:	f8ad 300a 	strh.w	r3, [sp, #10]
   26800:	f7ff fd22 	bl	26248 <bt_uuid_cmp>
   26804:	b198      	cbz	r0, 2682e <read_group_cb+0x4e>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   26806:	f642 0301 	movw	r3, #10241	; 0x2801
   2680a:	6828      	ldr	r0, [r5, #0]
   2680c:	f88d 800c 	strb.w	r8, [sp, #12]
   26810:	a903      	add	r1, sp, #12
   26812:	f8ad 300e 	strh.w	r3, [sp, #14]
   26816:	f7ff fd17 	bl	26248 <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   2681a:	b140      	cbz	r0, 2682e <read_group_cb+0x4e>
		if (data->group &&
   2681c:	6923      	ldr	r3, [r4, #16]
   2681e:	b123      	cbz	r3, 2682a <read_group_cb+0x4a>
		    attr->handle > sys_le16_to_cpu(data->group->end_handle)) {
   26820:	8a2a      	ldrh	r2, [r5, #16]
		if (data->group &&
   26822:	8859      	ldrh	r1, [r3, #2]
   26824:	4291      	cmp	r1, r2
   26826:	d200      	bcs.n	2682a <read_group_cb+0x4a>
			data->group->end_handle = sys_cpu_to_le16(attr->handle);
   26828:	805a      	strh	r2, [r3, #2]
	return BT_GATT_ITER_CONTINUE;
   2682a:	2001      	movs	r0, #1
   2682c:	e012      	b.n	26854 <read_group_cb+0x74>
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   2682e:	6861      	ldr	r1, [r4, #4]
   26830:	6828      	ldr	r0, [r5, #0]
   26832:	f7ff fd09 	bl	26248 <bt_uuid_cmp>
   26836:	b110      	cbz	r0, 2683e <read_group_cb+0x5e>
		data->group = NULL;
   26838:	2300      	movs	r3, #0
   2683a:	6123      	str	r3, [r4, #16]
		return BT_GATT_ITER_CONTINUE;
   2683c:	e7f5      	b.n	2682a <read_group_cb+0x4a>
	if (data->rsp->len &&
   2683e:	68e3      	ldr	r3, [r4, #12]
   26840:	68a0      	ldr	r0, [r4, #8]
   26842:	781a      	ldrb	r2, [r3, #0]
   26844:	b14a      	cbz	r2, 2685a <read_group_cb+0x7a>
	    att->chan.tx.mtu - data->buf->len < data->rsp->len) {
   26846:	f8b6 3042 	ldrh.w	r3, [r6, #66]	; 0x42
   2684a:	8981      	ldrh	r1, [r0, #12]
   2684c:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
   2684e:	4293      	cmp	r3, r2
   26850:	da03      	bge.n	2685a <read_group_cb+0x7a>
		return BT_GATT_ITER_STOP;
   26852:	2000      	movs	r0, #0
}
   26854:	b004      	add	sp, #16
   26856:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   2685a:	2104      	movs	r1, #4
   2685c:	3008      	adds	r0, #8
   2685e:	f7f8 fd3b 	bl	1f2d8 <net_buf_simple_add>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   26862:	68a1      	ldr	r1, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   26864:	8a2b      	ldrh	r3, [r5, #16]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   26866:	898a      	ldrh	r2, [r1, #12]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   26868:	6120      	str	r0, [r4, #16]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   2686a:	8003      	strh	r3, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(attr->handle);
   2686c:	8043      	strh	r3, [r0, #2]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   2686e:	f8b6 3042 	ldrh.w	r3, [r6, #66]	; 0x42
   26872:	6889      	ldr	r1, [r1, #8]
   26874:	2600      	movs	r6, #0
   26876:	1a9b      	subs	r3, r3, r2
   26878:	9600      	str	r6, [sp, #0]
   2687a:	440a      	add	r2, r1
   2687c:	f8d5 8004 	ldr.w	r8, [r5, #4]
   26880:	4629      	mov	r1, r5
   26882:	b29b      	uxth	r3, r3
   26884:	4638      	mov	r0, r7
   26886:	47c0      	blx	r8
	if (read < 0) {
   26888:	1e01      	subs	r1, r0, #0
   2688a:	dbe2      	blt.n	26852 <read_group_cb+0x72>
	if (!data->rsp->len) {
   2688c:	68e5      	ldr	r5, [r4, #12]
   2688e:	68a0      	ldr	r0, [r4, #8]
   26890:	782a      	ldrb	r2, [r5, #0]
   26892:	1d0b      	adds	r3, r1, #4
   26894:	b922      	cbnz	r2, 268a0 <read_group_cb+0xc0>
		data->rsp->len = read + sizeof(*data->group);
   26896:	702b      	strb	r3, [r5, #0]
	net_buf_add(data->buf, read);
   26898:	3008      	adds	r0, #8
   2689a:	f7f8 fd1d 	bl	1f2d8 <net_buf_simple_add>
   2689e:	e7c4      	b.n	2682a <read_group_cb+0x4a>
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   268a0:	429a      	cmp	r2, r3
   268a2:	d0f9      	beq.n	26898 <read_group_cb+0xb8>
		data->buf->len -= sizeof(*data->group);
   268a4:	8983      	ldrh	r3, [r0, #12]
   268a6:	3b04      	subs	r3, #4
   268a8:	8183      	strh	r3, [r0, #12]
		return false;
   268aa:	e7d2      	b.n	26852 <read_group_cb+0x72>

000268ac <read_type_cb>:
{
   268ac:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct bt_att *att = data->att;
   268b0:	f8d1 8000 	ldr.w	r8, [r1]
{
   268b4:	4606      	mov	r6, r0
   268b6:	460d      	mov	r5, r1
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   268b8:	6800      	ldr	r0, [r0, #0]
   268ba:	6849      	ldr	r1, [r1, #4]
	struct bt_conn *conn = att->chan.chan.conn;
   268bc:	f8d8 9000 	ldr.w	r9, [r8]
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   268c0:	f7ff fcc2 	bl	26248 <bt_uuid_cmp>
   268c4:	4607      	mov	r7, r0
   268c6:	2800      	cmp	r0, #0
   268c8:	d14a      	bne.n	26960 <read_type_cb+0xb4>
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   268ca:	2215      	movs	r2, #21
   268cc:	4631      	mov	r1, r6
   268ce:	4648      	mov	r0, r9
   268d0:	f000 fb35 	bl	26f3e <bt_gatt_check_perm>
   268d4:	4604      	mov	r4, r0
   268d6:	7528      	strb	r0, [r5, #20]
	if (data->err) {
   268d8:	b140      	cbz	r0, 268ec <read_type_cb+0x40>
		if (data->rsp->len) {
   268da:	68eb      	ldr	r3, [r5, #12]
   268dc:	781c      	ldrb	r4, [r3, #0]
   268de:	b10c      	cbz	r4, 268e4 <read_type_cb+0x38>
			data->err = 0x00;
   268e0:	752f      	strb	r7, [r5, #20]
		return BT_GATT_ITER_STOP;
   268e2:	463c      	mov	r4, r7
}
   268e4:	4620      	mov	r0, r4
   268e6:	b003      	add	sp, #12
   268e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data->item = net_buf_add(data->buf, sizeof(*data->item));
   268ec:	68a8      	ldr	r0, [r5, #8]
   268ee:	2102      	movs	r1, #2
   268f0:	3008      	adds	r0, #8
   268f2:	f7f8 fcf1 	bl	1f2d8 <net_buf_simple_add>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   268f6:	68a9      	ldr	r1, [r5, #8]
	data->item->handle = sys_cpu_to_le16(attr->handle);
   268f8:	8a33      	ldrh	r3, [r6, #16]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   268fa:	898a      	ldrh	r2, [r1, #12]
	data->item = net_buf_add(data->buf, sizeof(*data->item));
   268fc:	6128      	str	r0, [r5, #16]
	data->item->handle = sys_cpu_to_le16(attr->handle);
   268fe:	8003      	strh	r3, [r0, #0]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   26900:	f8b8 3042 	ldrh.w	r3, [r8, #66]	; 0x42
   26904:	6889      	ldr	r1, [r1, #8]
   26906:	9400      	str	r4, [sp, #0]
   26908:	1a9b      	subs	r3, r3, r2
   2690a:	6877      	ldr	r7, [r6, #4]
   2690c:	440a      	add	r2, r1
   2690e:	b29b      	uxth	r3, r3
   26910:	4631      	mov	r1, r6
   26912:	4648      	mov	r0, r9
   26914:	47b8      	blx	r7
	if (read < 0) {
   26916:	1e01      	subs	r1, r0, #0
   26918:	da07      	bge.n	2692a <read_type_cb+0x7e>
	if (err < 0 && err >= -0xff) {
   2691a:	f111 0fff 	cmn.w	r1, #255	; 0xff
		return -err;
   2691e:	bf26      	itte	cs
   26920:	4249      	negcs	r1, r1
   26922:	b2c9      	uxtbcs	r1, r1
	return BT_ATT_ERR_UNLIKELY;
   26924:	210e      	movcc	r1, #14
		data->err = err_to_att(read);
   26926:	7529      	strb	r1, [r5, #20]
		return BT_GATT_ITER_STOP;
   26928:	e7dc      	b.n	268e4 <read_type_cb+0x38>
	if (!data->rsp->len) {
   2692a:	68ee      	ldr	r6, [r5, #12]
   2692c:	68a8      	ldr	r0, [r5, #8]
   2692e:	7832      	ldrb	r2, [r6, #0]
   26930:	1c8b      	adds	r3, r1, #2
   26932:	b97a      	cbnz	r2, 26954 <read_type_cb+0xa8>
		data->rsp->len = read + sizeof(*data->item);
   26934:	7033      	strb	r3, [r6, #0]
	net_buf_add(data->buf, read);
   26936:	3008      	adds	r0, #8
   26938:	f7f8 fcce 	bl	1f2d8 <net_buf_simple_add>
	return att->chan.tx.mtu - data->buf->len > data->rsp->len ?
   2693c:	68ab      	ldr	r3, [r5, #8]
   2693e:	f8b8 4042 	ldrh.w	r4, [r8, #66]	; 0x42
   26942:	8998      	ldrh	r0, [r3, #12]
   26944:	68eb      	ldr	r3, [r5, #12]
   26946:	1a24      	subs	r4, r4, r0
   26948:	7818      	ldrb	r0, [r3, #0]
	       BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   2694a:	4284      	cmp	r4, r0
   2694c:	bfd4      	ite	le
   2694e:	2400      	movle	r4, #0
   26950:	2401      	movgt	r4, #1
   26952:	e7c7      	b.n	268e4 <read_type_cb+0x38>
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   26954:	429a      	cmp	r2, r3
   26956:	d0ee      	beq.n	26936 <read_type_cb+0x8a>
		data->buf->len -= sizeof(*data->item);
   26958:	8983      	ldrh	r3, [r0, #12]
   2695a:	3b02      	subs	r3, #2
   2695c:	8183      	strh	r3, [r0, #12]
		return BT_GATT_ITER_STOP;
   2695e:	e7c1      	b.n	268e4 <read_type_cb+0x38>
		return BT_GATT_ITER_CONTINUE;
   26960:	2401      	movs	r4, #1
   26962:	e7bf      	b.n	268e4 <read_type_cb+0x38>

00026964 <find_info_cb>:
	if (!data->rsp) {
   26964:	688b      	ldr	r3, [r1, #8]
{
   26966:	b570      	push	{r4, r5, r6, lr}
	struct bt_att *att = data->att;
   26968:	680e      	ldr	r6, [r1, #0]
{
   2696a:	4605      	mov	r5, r0
   2696c:	460c      	mov	r4, r1
	if (!data->rsp) {
   2696e:	b963      	cbnz	r3, 2698a <find_info_cb+0x26>
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   26970:	6848      	ldr	r0, [r1, #4]
   26972:	2101      	movs	r1, #1
   26974:	3008      	adds	r0, #8
   26976:	f7f8 fcaf 	bl	1f2d8 <net_buf_simple_add>
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   2697a:	682b      	ldr	r3, [r5, #0]
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   2697c:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   2697e:	781b      	ldrb	r3, [r3, #0]
   26980:	2b00      	cmp	r3, #0
   26982:	bf0c      	ite	eq
   26984:	2301      	moveq	r3, #1
   26986:	2302      	movne	r3, #2
   26988:	7003      	strb	r3, [r0, #0]
	switch (data->rsp->format) {
   2698a:	68a3      	ldr	r3, [r4, #8]
   2698c:	781b      	ldrb	r3, [r3, #0]
   2698e:	2b01      	cmp	r3, #1
   26990:	d003      	beq.n	2699a <find_info_cb+0x36>
   26992:	2b02      	cmp	r3, #2
   26994:	d01a      	beq.n	269cc <find_info_cb+0x68>
			return BT_GATT_ITER_STOP;
   26996:	2000      	movs	r0, #0
   26998:	e017      	b.n	269ca <find_info_cb+0x66>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   2699a:	682b      	ldr	r3, [r5, #0]
   2699c:	781b      	ldrb	r3, [r3, #0]
   2699e:	2b00      	cmp	r3, #0
   269a0:	d1f9      	bne.n	26996 <find_info_cb+0x32>
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   269a2:	6860      	ldr	r0, [r4, #4]
   269a4:	2104      	movs	r1, #4
   269a6:	3008      	adds	r0, #8
   269a8:	f7f8 fc96 	bl	1f2d8 <net_buf_simple_add>
		data->info16->handle = sys_cpu_to_le16(attr->handle);
   269ac:	8a2b      	ldrh	r3, [r5, #16]
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   269ae:	60e0      	str	r0, [r4, #12]
		data->info16->handle = sys_cpu_to_le16(attr->handle);
   269b0:	8003      	strh	r3, [r0, #0]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   269b2:	682b      	ldr	r3, [r5, #0]
   269b4:	885b      	ldrh	r3, [r3, #2]
   269b6:	8043      	strh	r3, [r0, #2]
		if (att->chan.tx.mtu - data->buf->len >
   269b8:	6863      	ldr	r3, [r4, #4]
   269ba:	f8b6 0042 	ldrh.w	r0, [r6, #66]	; 0x42
   269be:	899b      	ldrh	r3, [r3, #12]
   269c0:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   269c2:	2804      	cmp	r0, #4
   269c4:	bf94      	ite	ls
   269c6:	2000      	movls	r0, #0
   269c8:	2001      	movhi	r0, #1
}
   269ca:	bd70      	pop	{r4, r5, r6, pc}
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   269cc:	682b      	ldr	r3, [r5, #0]
   269ce:	781b      	ldrb	r3, [r3, #0]
   269d0:	2b02      	cmp	r3, #2
   269d2:	d1e0      	bne.n	26996 <find_info_cb+0x32>
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   269d4:	6860      	ldr	r0, [r4, #4]
   269d6:	2112      	movs	r1, #18
   269d8:	3008      	adds	r0, #8
   269da:	f7f8 fc7d 	bl	1f2d8 <net_buf_simple_add>
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   269de:	6829      	ldr	r1, [r5, #0]
		data->info128->handle = sys_cpu_to_le16(attr->handle);
   269e0:	8a2b      	ldrh	r3, [r5, #16]
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   269e2:	60e0      	str	r0, [r4, #12]
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   269e4:	2210      	movs	r2, #16
		data->info128->handle = sys_cpu_to_le16(attr->handle);
   269e6:	f820 3b02 	strh.w	r3, [r0], #2
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   269ea:	3101      	adds	r1, #1
   269ec:	f7ff f95c 	bl	25ca8 <memcpy>
		if (att->chan.tx.mtu - data->buf->len >
   269f0:	6863      	ldr	r3, [r4, #4]
   269f2:	f8b6 0042 	ldrh.w	r0, [r6, #66]	; 0x42
   269f6:	899b      	ldrh	r3, [r3, #12]
   269f8:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   269fa:	2812      	cmp	r0, #18
   269fc:	e7e2      	b.n	269c4 <find_info_cb+0x60>

000269fe <att_exec_write_req>:
   269fe:	2006      	movs	r0, #6
   26a00:	4770      	bx	lr

00026a02 <att_pdu_sent>:
{
   26a02:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   26a06:	4607      	mov	r7, r0
	struct bt_att *att = att_get(conn);
   26a08:	f7e3 f924 	bl	9c54 <att_get>
   26a0c:	4605      	mov	r5, r0
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
   26a0e:	f100 08e0 	add.w	r8, r0, #224	; 0xe0
   26a12:	2100      	movs	r1, #0
   26a14:	4640      	mov	r0, r8
   26a16:	f7f8 fa1f 	bl	1ee58 <net_buf_get>
   26a1a:	4604      	mov	r4, r0
   26a1c:	b928      	cbnz	r0, 26a2a <att_pdu_sent+0x28>
	z_impl_k_sem_give(sem);
   26a1e:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
}
   26a22:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   26a26:	f7fb be43 	b.w	226b0 <z_impl_k_sem_give>
		if (att->req && att->req->buf == buf) {
   26a2a:	f8d5 609c 	ldr.w	r6, [r5, #156]	; 0x9c
   26a2e:	b14e      	cbz	r6, 26a44 <att_pdu_sent+0x42>
   26a30:	6933      	ldr	r3, [r6, #16]
   26a32:	42a3      	cmp	r3, r4
   26a34:	d106      	bne.n	26a44 <att_pdu_sent+0x42>
	state->offset = net_buf_simple_headroom(buf);
   26a36:	f104 0008 	add.w	r0, r4, #8
   26a3a:	f002 f9b0 	bl	28d9e <net_buf_simple_headroom>
	state->len = buf->len;
   26a3e:	89a3      	ldrh	r3, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
   26a40:	81b0      	strh	r0, [r6, #12]
	state->len = buf->len;
   26a42:	81f3      	strh	r3, [r6, #14]
		if (!att_send(conn, buf, NULL, NULL)) {
   26a44:	2300      	movs	r3, #0
   26a46:	461a      	mov	r2, r3
   26a48:	4621      	mov	r1, r4
   26a4a:	4638      	mov	r0, r7
   26a4c:	f7e3 f8c2 	bl	9bd4 <att_send>
   26a50:	2800      	cmp	r0, #0
   26a52:	d1de      	bne.n	26a12 <att_pdu_sent+0x10>
}
   26a54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00026a58 <att_cfm_sent>:
{
   26a58:	b538      	push	{r3, r4, r5, lr}
   26a5a:	4604      	mov	r4, r0
   26a5c:	460d      	mov	r5, r1
	struct bt_att *att = att_get(conn);
   26a5e:	f7e3 f8f9 	bl	9c54 <att_get>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   26a62:	f3bf 8f5b 	dmb	ish
   26a66:	f100 0398 	add.w	r3, r0, #152	; 0x98
   26a6a:	e853 2f00 	ldrex	r2, [r3]
   26a6e:	f022 0202 	bic.w	r2, r2, #2
   26a72:	e843 2100 	strex	r1, r2, [r3]
   26a76:	2900      	cmp	r1, #0
   26a78:	d1f7      	bne.n	26a6a <att_cfm_sent+0x12>
   26a7a:	f3bf 8f5b 	dmb	ish
	att_pdu_sent(conn, user_data);
   26a7e:	4629      	mov	r1, r5
   26a80:	4620      	mov	r0, r4
}
   26a82:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
   26a86:	f7ff bfbc 	b.w	26a02 <att_pdu_sent>

00026a8a <att_rsp_sent>:
{
   26a8a:	b538      	push	{r3, r4, r5, lr}
   26a8c:	4604      	mov	r4, r0
   26a8e:	460d      	mov	r5, r1
	struct bt_att *att = att_get(conn);
   26a90:	f7e3 f8e0 	bl	9c54 <att_get>
   26a94:	f3bf 8f5b 	dmb	ish
   26a98:	f100 0398 	add.w	r3, r0, #152	; 0x98
   26a9c:	e853 2f00 	ldrex	r2, [r3]
   26aa0:	f022 0201 	bic.w	r2, r2, #1
   26aa4:	e843 2100 	strex	r1, r2, [r3]
   26aa8:	2900      	cmp	r1, #0
   26aaa:	d1f7      	bne.n	26a9c <att_rsp_sent+0x12>
   26aac:	f3bf 8f5b 	dmb	ish
	att_pdu_sent(conn, user_data);
   26ab0:	4629      	mov	r1, r5
   26ab2:	4620      	mov	r0, r4
}
   26ab4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
   26ab8:	f7ff bfa3 	b.w	26a02 <att_pdu_sent>

00026abc <write_cb>:
{
   26abc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   26abe:	460c      	mov	r4, r1
   26ac0:	4606      	mov	r6, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
   26ac2:	4601      	mov	r1, r0
   26ac4:	222a      	movs	r2, #42	; 0x2a
   26ac6:	6820      	ldr	r0, [r4, #0]
   26ac8:	f000 fa39 	bl	26f3e <bt_gatt_check_perm>
   26acc:	4605      	mov	r5, r0
   26ace:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   26ad0:	bb00      	cbnz	r0, 26b14 <write_cb+0x58>
	if (!data->req) {
   26ad2:	7a23      	ldrb	r3, [r4, #8]
	write = attr->write(data->conn, attr, data->value, data->len,
   26ad4:	68b7      	ldr	r7, [r6, #8]
   26ad6:	68e2      	ldr	r2, [r4, #12]
   26ad8:	6820      	ldr	r0, [r4, #0]
	if (!data->req) {
   26ada:	2b00      	cmp	r3, #0
		flags |= BT_GATT_WRITE_FLAG_CMD;
   26adc:	bf14      	ite	ne
   26ade:	2300      	movne	r3, #0
   26ae0:	2302      	moveq	r3, #2
	write = attr->write(data->conn, attr, data->value, data->len,
   26ae2:	9301      	str	r3, [sp, #4]
   26ae4:	8a63      	ldrh	r3, [r4, #18]
   26ae6:	9300      	str	r3, [sp, #0]
   26ae8:	4631      	mov	r1, r6
   26aea:	8a23      	ldrh	r3, [r4, #16]
   26aec:	47b8      	blx	r7
	if (write < 0 || write != data->len) {
   26aee:	1e03      	subs	r3, r0, #0
   26af0:	db05      	blt.n	26afe <write_cb+0x42>
   26af2:	8a22      	ldrh	r2, [r4, #16]
   26af4:	4293      	cmp	r3, r2
   26af6:	d10b      	bne.n	26b10 <write_cb+0x54>
	data->err = 0U;
   26af8:	7525      	strb	r5, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
   26afa:	2501      	movs	r5, #1
   26afc:	e005      	b.n	26b0a <write_cb+0x4e>
	if (err < 0 && err >= -0xff) {
   26afe:	f113 0fff 	cmn.w	r3, #255	; 0xff
   26b02:	d305      	bcc.n	26b10 <write_cb+0x54>
		return -err;
   26b04:	425b      	negs	r3, r3
   26b06:	b2db      	uxtb	r3, r3
		data->err = err_to_att(write);
   26b08:	7523      	strb	r3, [r4, #20]
}
   26b0a:	4628      	mov	r0, r5
   26b0c:	b003      	add	sp, #12
   26b0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return BT_ATT_ERR_UNLIKELY;
   26b10:	230e      	movs	r3, #14
   26b12:	e7f9      	b.n	26b08 <write_cb+0x4c>
		return BT_GATT_ITER_STOP;
   26b14:	2500      	movs	r5, #0
   26b16:	e7f8      	b.n	26b0a <write_cb+0x4e>

00026b18 <read_cb>:
{
   26b18:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   26b1c:	4606      	mov	r6, r0
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   26b1e:	6888      	ldr	r0, [r1, #8]
	struct bt_att *att = data->att;
   26b20:	f8d1 9000 	ldr.w	r9, [r1]
{
   26b24:	460c      	mov	r4, r1
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   26b26:	3008      	adds	r0, #8
   26b28:	2100      	movs	r1, #0
	struct bt_conn *conn = att->chan.chan.conn;
   26b2a:	f8d9 8000 	ldr.w	r8, [r9]
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   26b2e:	f7f8 fbd3 	bl	1f2d8 <net_buf_simple_add>
	data->err = 0x00;
   26b32:	2700      	movs	r7, #0
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   26b34:	60e0      	str	r0, [r4, #12]
	data->err = 0x00;
   26b36:	7427      	strb	r7, [r4, #16]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   26b38:	2215      	movs	r2, #21
   26b3a:	4631      	mov	r1, r6
   26b3c:	4640      	mov	r0, r8
   26b3e:	f000 f9fe 	bl	26f3e <bt_gatt_check_perm>
   26b42:	4605      	mov	r5, r0
   26b44:	7420      	strb	r0, [r4, #16]
	if (data->err) {
   26b46:	bb00      	cbnz	r0, 26b8a <read_cb+0x72>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   26b48:	68a1      	ldr	r1, [r4, #8]
   26b4a:	f8b9 3042 	ldrh.w	r3, [r9, #66]	; 0x42
   26b4e:	898a      	ldrh	r2, [r1, #12]
   26b50:	6889      	ldr	r1, [r1, #8]
   26b52:	88a0      	ldrh	r0, [r4, #4]
   26b54:	9000      	str	r0, [sp, #0]
   26b56:	1a9b      	subs	r3, r3, r2
   26b58:	6877      	ldr	r7, [r6, #4]
   26b5a:	440a      	add	r2, r1
   26b5c:	b29b      	uxth	r3, r3
   26b5e:	4631      	mov	r1, r6
   26b60:	4640      	mov	r0, r8
   26b62:	47b8      	blx	r7
	if (read < 0) {
   26b64:	1e01      	subs	r1, r0, #0
   26b66:	da0a      	bge.n	26b7e <read_cb+0x66>
	if (err < 0 && err >= -0xff) {
   26b68:	f111 0fff 	cmn.w	r1, #255	; 0xff
		return -err;
   26b6c:	bf26      	itte	cs
   26b6e:	4249      	negcs	r1, r1
   26b70:	b2c9      	uxtbcs	r1, r1
	return BT_ATT_ERR_UNLIKELY;
   26b72:	210e      	movcc	r1, #14
		data->err = err_to_att(read);
   26b74:	7421      	strb	r1, [r4, #16]
}
   26b76:	4628      	mov	r0, r5
   26b78:	b003      	add	sp, #12
   26b7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	net_buf_add(data->buf, read);
   26b7e:	68a0      	ldr	r0, [r4, #8]
   26b80:	3008      	adds	r0, #8
   26b82:	f7f8 fba9 	bl	1f2d8 <net_buf_simple_add>
	return BT_GATT_ITER_CONTINUE;
   26b86:	2501      	movs	r5, #1
   26b88:	e7f5      	b.n	26b76 <read_cb+0x5e>
		return BT_GATT_ITER_STOP;
   26b8a:	463d      	mov	r5, r7
   26b8c:	e7f3      	b.n	26b76 <read_cb+0x5e>

00026b8e <att_read_blob_req>:
{
   26b8e:	b507      	push	{r0, r1, r2, lr}
	req = (void *)buf->data;
   26b90:	688a      	ldr	r2, [r1, #8]
	return att_read_rsp(att, BT_ATT_OP_READ_BLOB_REQ,
   26b92:	8813      	ldrh	r3, [r2, #0]
   26b94:	8852      	ldrh	r2, [r2, #2]
   26b96:	9200      	str	r2, [sp, #0]
   26b98:	210c      	movs	r1, #12
   26b9a:	220d      	movs	r2, #13
   26b9c:	f7e3 fbc4 	bl	a328 <att_read_rsp>
}
   26ba0:	b003      	add	sp, #12
   26ba2:	f85d fb04 	ldr.w	pc, [sp], #4

00026ba6 <att_read_req>:
{
   26ba6:	b507      	push	{r0, r1, r2, lr}
	handle = sys_le16_to_cpu(req->handle);
   26ba8:	688b      	ldr	r3, [r1, #8]
	return att_read_rsp(att, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   26baa:	2200      	movs	r2, #0
   26bac:	881b      	ldrh	r3, [r3, #0]
   26bae:	9200      	str	r2, [sp, #0]
   26bb0:	210a      	movs	r1, #10
   26bb2:	220b      	movs	r2, #11
   26bb4:	f7e3 fbb8 	bl	a328 <att_read_rsp>
}
   26bb8:	b003      	add	sp, #12
   26bba:	f85d fb04 	ldr.w	pc, [sp], #4

00026bbe <bt_att_init>:
	bt_gatt_init();
   26bbe:	f7e4 bae1 	b.w	b184 <bt_gatt_init>

00026bc2 <bt_att_get_mtu>:
{
   26bc2:	b508      	push	{r3, lr}
	att = att_chan_get(conn);
   26bc4:	f7e3 f898 	bl	9cf8 <att_chan_get>
	if (!att) {
   26bc8:	b108      	cbz	r0, 26bce <bt_att_get_mtu+0xc>
	return att->chan.tx.mtu;
   26bca:	f8b0 0042 	ldrh.w	r0, [r0, #66]	; 0x42
}
   26bce:	bd08      	pop	{r3, pc}

00026bd0 <att_req_destroy>:
{
   26bd0:	b510      	push	{r4, lr}
   26bd2:	4604      	mov	r4, r0
	if (req->buf) {
   26bd4:	6900      	ldr	r0, [r0, #16]
   26bd6:	b108      	cbz	r0, 26bdc <att_req_destroy+0xc>
		net_buf_unref(req->buf);
   26bd8:	f7f8 fa76 	bl	1f0c8 <net_buf_unref>
	if (req->destroy) {
   26bdc:	68a3      	ldr	r3, [r4, #8]
   26bde:	b10b      	cbz	r3, 26be4 <att_req_destroy+0x14>
		req->destroy(req);
   26be0:	4620      	mov	r0, r4
   26be2:	4798      	blx	r3
	bt_att_req_free(req);
   26be4:	4620      	mov	r0, r4
}
   26be6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_att_req_free(req);
   26bea:	f7e3 bd73 	b.w	a6d4 <bt_att_req_free>

00026bee <att_confirm>:
	return att_handle_rsp(att, buf->data, buf->len, 0);
   26bee:	898a      	ldrh	r2, [r1, #12]
   26bf0:	6889      	ldr	r1, [r1, #8]
   26bf2:	2300      	movs	r3, #0
   26bf4:	f7e3 bd7a 	b.w	a6ec <att_handle_rsp>

00026bf8 <att_reset>:
{
   26bf8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   26bfa:	4604      	mov	r4, r0
	while ((buf = k_fifo_get(&att->tx_queue, K_NO_WAIT))) {
   26bfc:	f100 05e0 	add.w	r5, r0, #224	; 0xe0
	return z_impl_k_queue_get(queue, timeout);
   26c00:	2100      	movs	r1, #0
   26c02:	4628      	mov	r0, r5
   26c04:	f7fa fa2e 	bl	21064 <z_impl_k_queue_get>
   26c08:	bb00      	cbnz	r0, 26c4c <att_reset+0x54>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   26c0a:	f3bf 8f5b 	dmb	ish
   26c0e:	f104 0398 	add.w	r3, r4, #152	; 0x98
   26c12:	e853 2f00 	ldrex	r2, [r3]
   26c16:	f042 0204 	orr.w	r2, r2, #4
   26c1a:	e843 2100 	strex	r1, r2, [r3]
   26c1e:	2900      	cmp	r1, #0
   26c20:	d1f7      	bne.n	26c12 <att_reset+0x1a>
   26c22:	f3bf 8f5b 	dmb	ish
   26c26:	2504      	movs	r5, #4
		k_sem_give(&att->tx_sem);
   26c28:	f104 06c8 	add.w	r6, r4, #200	; 0xc8
	z_impl_k_sem_give(sem);
   26c2c:	4630      	mov	r0, r6
   26c2e:	f7fb fd3f 	bl	226b0 <z_impl_k_sem_give>
	for (i = 0; i < CONFIG_BT_ATT_TX_MAX; i++) {
   26c32:	3d01      	subs	r5, #1
   26c34:	d1fa      	bne.n	26c2c <att_reset+0x34>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   26c36:	f8d4 60a0 	ldr.w	r6, [r4, #160]	; 0xa0
   26c3a:	b956      	cbnz	r6, 26c52 <att_reset+0x5a>
	if (!att->req) {
   26c3c:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
	list->head = NULL;
   26c40:	2200      	movs	r2, #0
	list->tail = NULL;
   26c42:	e9c4 2228 	strd	r2, r2, [r4, #160]	; 0xa0
   26c46:	b9e3      	cbnz	r3, 26c82 <att_reset+0x8a>
}
   26c48:	b003      	add	sp, #12
   26c4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		net_buf_unref(buf);
   26c4c:	f7f8 fa3c 	bl	1f0c8 <net_buf_unref>
   26c50:	e7d6      	b.n	26c00 <att_reset+0x8>
	return node->next;
   26c52:	6835      	ldr	r5, [r6, #0]
   26c54:	2d00      	cmp	r5, #0
   26c56:	bf38      	it	cc
   26c58:	2500      	movcc	r5, #0
		if (req->func) {
   26c5a:	6877      	ldr	r7, [r6, #4]
   26c5c:	b12f      	cbz	r7, 26c6a <att_reset+0x72>
			req->func(NULL, BT_ATT_ERR_UNLIKELY, NULL, 0, req);
   26c5e:	2300      	movs	r3, #0
   26c60:	9600      	str	r6, [sp, #0]
   26c62:	461a      	mov	r2, r3
   26c64:	210e      	movs	r1, #14
   26c66:	4618      	mov	r0, r3
   26c68:	47b8      	blx	r7
		att_req_destroy(req);
   26c6a:	4630      	mov	r0, r6
   26c6c:	f7ff ffb0 	bl	26bd0 <att_req_destroy>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   26c70:	2d00      	cmp	r5, #0
   26c72:	d0e3      	beq.n	26c3c <att_reset+0x44>
   26c74:	682b      	ldr	r3, [r5, #0]
   26c76:	2b00      	cmp	r3, #0
   26c78:	bf38      	it	cc
   26c7a:	2300      	movcc	r3, #0
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   26c7c:	462e      	mov	r6, r5
   26c7e:	461d      	mov	r5, r3
   26c80:	e7eb      	b.n	26c5a <att_reset+0x62>
	att_handle_rsp(att, NULL, 0, BT_ATT_ERR_UNLIKELY);
   26c82:	230e      	movs	r3, #14
   26c84:	4611      	mov	r1, r2
   26c86:	4620      	mov	r0, r4
}
   26c88:	b003      	add	sp, #12
   26c8a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	att_handle_rsp(att, NULL, 0, BT_ATT_ERR_UNLIKELY);
   26c8e:	f7e3 bd2d 	b.w	a6ec <att_handle_rsp>

00026c92 <bt_att_disconnected>:
{
   26c92:	b510      	push	{r4, lr}
   26c94:	4604      	mov	r4, r0
	att_reset(att);
   26c96:	f7ff ffaf 	bl	26bf8 <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
   26c9a:	6820      	ldr	r0, [r4, #0]
}
   26c9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_gatt_disconnected(ch->chan.conn);
   26ca0:	f7e5 b810 	b.w	bcc4 <bt_gatt_disconnected>

00026ca4 <found_attr>:
	*found = attr;
   26ca4:	6008      	str	r0, [r1, #0]
}
   26ca6:	2000      	movs	r0, #0
   26ca8:	4770      	bx	lr

00026caa <gatt_ccc_changed>:
{
   26caa:	460b      	mov	r3, r1
		if (ccc->cfg[i].value > value) {
   26cac:	8909      	ldrh	r1, [r1, #8]
	if (value != ccc->value) {
   26cae:	895a      	ldrh	r2, [r3, #10]
   26cb0:	428a      	cmp	r2, r1
   26cb2:	d003      	beq.n	26cbc <gatt_ccc_changed+0x12>
		ccc->value = value;
   26cb4:	8159      	strh	r1, [r3, #10]
		if (ccc->cfg_changed) {
   26cb6:	68db      	ldr	r3, [r3, #12]
   26cb8:	b103      	cbz	r3, 26cbc <gatt_ccc_changed+0x12>
			ccc->cfg_changed(attr, value);
   26cba:	4718      	bx	r3
}
   26cbc:	4770      	bx	lr

00026cbe <gatt_indicate_rsp>:
{
   26cbe:	b410      	push	{r4}
   26cc0:	9b01      	ldr	r3, [sp, #4]
   26cc2:	460a      	mov	r2, r1
	params->func(conn, params->attr, err);
   26cc4:	e9d3 1401 	ldrd	r1, r4, [r3, #4]
   26cc8:	4623      	mov	r3, r4
}
   26cca:	bc10      	pop	{r4}
	params->func(conn, params->attr, err);
   26ccc:	4718      	bx	r3

00026cce <sc_restore_rsp>:
}
   26cce:	4770      	bx	lr

00026cd0 <write_name>:
{
   26cd0:	b570      	push	{r4, r5, r6, lr}
   26cd2:	b088      	sub	sp, #32
   26cd4:	4615      	mov	r5, r2
   26cd6:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   26cda:	2100      	movs	r1, #0
   26cdc:	2218      	movs	r2, #24
   26cde:	a802      	add	r0, sp, #8
{
   26ce0:	461c      	mov	r4, r3
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   26ce2:	9101      	str	r1, [sp, #4]
   26ce4:	f7ff f80b 	bl	25cfe <memset>
	if (offset) {
   26ce8:	b966      	cbnz	r6, 26d04 <write_name+0x34>
	if (len >= sizeof(value)) {
   26cea:	2c1b      	cmp	r4, #27
   26cec:	d80d      	bhi.n	26d0a <write_name+0x3a>
	memcpy(value, buf, len);
   26cee:	4622      	mov	r2, r4
   26cf0:	4629      	mov	r1, r5
   26cf2:	a801      	add	r0, sp, #4
   26cf4:	f7fe ffd8 	bl	25ca8 <memcpy>
	bt_set_name(value);
   26cf8:	a801      	add	r0, sp, #4
   26cfa:	f7e1 f911 	bl	7f20 <bt_set_name>
	return len;
   26cfe:	4620      	mov	r0, r4
}
   26d00:	b008      	add	sp, #32
   26d02:	bd70      	pop	{r4, r5, r6, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   26d04:	f06f 0006 	mvn.w	r0, #6
   26d08:	e7fa      	b.n	26d00 <write_name+0x30>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   26d0a:	f06f 000c 	mvn.w	r0, #12
   26d0e:	e7f7      	b.n	26d00 <write_name+0x30>

00026d10 <match_uuid>:
   26d10:	6008      	str	r0, [r1, #0]
   26d12:	2000      	movs	r0, #0
   26d14:	4770      	bx	lr

00026d16 <ccc_find_cfg>:
{
   26d16:	b510      	push	{r4, lr}
		if (id == ccc->cfg[i].id &&
   26d18:	7803      	ldrb	r3, [r0, #0]
   26d1a:	4293      	cmp	r3, r2
{
   26d1c:	4604      	mov	r4, r0
		if (id == ccc->cfg[i].id &&
   26d1e:	d001      	beq.n	26d24 <ccc_find_cfg+0xe>
	return NULL;
   26d20:	2000      	movs	r0, #0
}
   26d22:	bd10      	pop	{r4, pc}
   26d24:	2207      	movs	r2, #7
   26d26:	3001      	adds	r0, #1
   26d28:	f7fe ffae 	bl	25c88 <memcmp>
		if (id == ccc->cfg[i].id &&
   26d2c:	2800      	cmp	r0, #0
   26d2e:	d1f7      	bne.n	26d20 <ccc_find_cfg+0xa>
			return &ccc->cfg[i];
   26d30:	4620      	mov	r0, r4
   26d32:	e7f6      	b.n	26d22 <ccc_find_cfg+0xc>

00026d34 <sc_clear_by_conn>:
{
   26d34:	b508      	push	{r3, lr}
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
   26d36:	f100 0174 	add.w	r1, r0, #116	; 0x74
   26d3a:	7a00      	ldrb	r0, [r0, #8]
   26d3c:	f7e3 ff64 	bl	ac08 <find_sc_cfg>
	if (cfg) {
   26d40:	b118      	cbz	r0, 26d4a <sc_clear_by_conn+0x16>
}
   26d42:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		sc_clear(cfg);
   26d46:	f7e3 be11 	b.w	a96c <sc_clear>
}
   26d4a:	bd08      	pop	{r3, pc}

00026d4c <find_ccc_cfg>:
{
   26d4c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   26d4e:	460c      	mov	r4, r1
   26d50:	1c4d      	adds	r5, r1, #1
		if (conn) {
   26d52:	b148      	cbz	r0, 26d68 <find_ccc_cfg+0x1c>
			if (bt_conn_is_peer_addr_le(conn, cfg->id,
   26d54:	7809      	ldrb	r1, [r1, #0]
   26d56:	462a      	mov	r2, r5
   26d58:	f7ff fc06 	bl	26568 <bt_conn_is_peer_addr_le>
   26d5c:	2800      	cmp	r0, #0
	return NULL;
   26d5e:	bf08      	it	eq
   26d60:	2400      	moveq	r4, #0
}
   26d62:	4620      	mov	r0, r4
   26d64:	b003      	add	sp, #12
   26d66:	bd30      	pop	{r4, r5, pc}
		} else if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   26d68:	9000      	str	r0, [sp, #0]
   26d6a:	2207      	movs	r2, #7
   26d6c:	f8cd 0003 	str.w	r0, [sp, #3]
   26d70:	4669      	mov	r1, sp
   26d72:	4628      	mov	r0, r5
   26d74:	f7fe ff88 	bl	25c88 <memcmp>
   26d78:	2800      	cmp	r0, #0
	return NULL;
   26d7a:	bf18      	it	ne
   26d7c:	2400      	movne	r4, #0
   26d7e:	e7f0      	b.n	26d62 <find_ccc_cfg+0x16>

00026d80 <clear_ccc_cfg>:
{
   26d80:	b537      	push	{r0, r1, r2, r4, r5, lr}
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   26d82:	2500      	movs	r5, #0
{
   26d84:	4604      	mov	r4, r0
	memcpy(dst, src, sizeof(*dst));
   26d86:	2207      	movs	r2, #7
   26d88:	4669      	mov	r1, sp
   26d8a:	3001      	adds	r0, #1
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   26d8c:	9500      	str	r5, [sp, #0]
   26d8e:	f8cd 5003 	str.w	r5, [sp, #3]
   26d92:	f7fe ff89 	bl	25ca8 <memcpy>
	cfg->id = 0U;
   26d96:	7025      	strb	r5, [r4, #0]
	cfg->value = 0U;
   26d98:	8125      	strh	r5, [r4, #8]
}
   26d9a:	b003      	add	sp, #12
   26d9c:	bd30      	pop	{r4, r5, pc}

00026d9e <read_appearance>:
{
   26d9e:	b513      	push	{r0, r1, r4, lr}
   26da0:	f8bd 1010 	ldrh.w	r1, [sp, #16]
   26da4:	4610      	mov	r0, r2
	if (offset > value_len) {
   26da6:	2902      	cmp	r1, #2
	u16_t appearance = sys_cpu_to_le16(gap_appearance);
   26da8:	f04f 0200 	mov.w	r2, #0
   26dac:	f8ad 2006 	strh.w	r2, [sp, #6]
	if (offset > value_len) {
   26db0:	d80d      	bhi.n	26dce <read_appearance+0x30>
	len = MIN(buf_len, value_len - offset);
   26db2:	f1c1 0402 	rsb	r4, r1, #2
   26db6:	429c      	cmp	r4, r3
   26db8:	bfa8      	it	ge
   26dba:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   26dbc:	f10d 0306 	add.w	r3, sp, #6
   26dc0:	4622      	mov	r2, r4
   26dc2:	4419      	add	r1, r3
   26dc4:	f7fe ff70 	bl	25ca8 <memcpy>
}
   26dc8:	4620      	mov	r0, r4
   26dca:	b002      	add	sp, #8
   26dcc:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   26dce:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   26dd2:	e7f9      	b.n	26dc8 <read_appearance+0x2a>

00026dd4 <read_name>:
{
   26dd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   26dd8:	4698      	mov	r8, r3
   26dda:	f8bd 6018 	ldrh.w	r6, [sp, #24]
   26dde:	4615      	mov	r5, r2
	const char *name = bt_get_name();
   26de0:	f7e1 f8ec 	bl	7fbc <bt_get_name>
   26de4:	4607      	mov	r7, r0
				 strlen(name));
   26de6:	f7fe ff2d 	bl	25c44 <strlen>
	if (offset > value_len) {
   26dea:	b283      	uxth	r3, r0
   26dec:	42b3      	cmp	r3, r6
   26dee:	d30c      	bcc.n	26e0a <read_name+0x36>
	len = MIN(buf_len, value_len - offset);
   26df0:	1b9c      	subs	r4, r3, r6
   26df2:	4544      	cmp	r4, r8
   26df4:	bfa8      	it	ge
   26df6:	4644      	movge	r4, r8
   26df8:	b2a4      	uxth	r4, r4
	memcpy(buf, (u8_t *)value + offset, len);
   26dfa:	4622      	mov	r2, r4
   26dfc:	19b9      	adds	r1, r7, r6
   26dfe:	4628      	mov	r0, r5
   26e00:	f7fe ff52 	bl	25ca8 <memcpy>
}
   26e04:	4620      	mov	r0, r4
   26e06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   26e0a:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   26e0e:	e7f9      	b.n	26e04 <read_name+0x30>

00026e10 <bt_gatt_attr_read_ccc>:
{
   26e10:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	cfg = find_ccc_cfg(conn, ccc);
   26e12:	68c9      	ldr	r1, [r1, #12]
{
   26e14:	f8bd 6020 	ldrh.w	r6, [sp, #32]
   26e18:	4615      	mov	r5, r2
   26e1a:	461f      	mov	r7, r3
	cfg = find_ccc_cfg(conn, ccc);
   26e1c:	f7ff ff96 	bl	26d4c <find_ccc_cfg>
	if (cfg) {
   26e20:	b100      	cbz	r0, 26e24 <bt_gatt_attr_read_ccc+0x14>
		value = sys_cpu_to_le16(cfg->value);
   26e22:	8900      	ldrh	r0, [r0, #8]
   26e24:	f8ad 0006 	strh.w	r0, [sp, #6]
	if (offset > value_len) {
   26e28:	2e02      	cmp	r6, #2
   26e2a:	d80e      	bhi.n	26e4a <bt_gatt_attr_read_ccc+0x3a>
	len = MIN(buf_len, value_len - offset);
   26e2c:	f1c6 0402 	rsb	r4, r6, #2
   26e30:	42bc      	cmp	r4, r7
   26e32:	bfa8      	it	ge
   26e34:	463c      	movge	r4, r7
	memcpy(buf, (u8_t *)value + offset, len);
   26e36:	f10d 0306 	add.w	r3, sp, #6
   26e3a:	4622      	mov	r2, r4
   26e3c:	1999      	adds	r1, r3, r6
   26e3e:	4628      	mov	r0, r5
   26e40:	f7fe ff32 	bl	25ca8 <memcpy>
}
   26e44:	4620      	mov	r0, r4
   26e46:	b003      	add	sp, #12
   26e48:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   26e4a:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   26e4e:	e7f9      	b.n	26e44 <bt_gatt_attr_read_ccc+0x34>

00026e50 <bt_gatt_attr_read_service>:
{
   26e50:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_uuid *uuid = attr->user_data;
   26e52:	68c9      	ldr	r1, [r1, #12]
{
   26e54:	f8bd 5018 	ldrh.w	r5, [sp, #24]
   26e58:	461c      	mov	r4, r3
	if (uuid->type == BT_UUID_TYPE_16) {
   26e5a:	780b      	ldrb	r3, [r1, #0]
{
   26e5c:	4610      	mov	r0, r2
	if (uuid->type == BT_UUID_TYPE_16) {
   26e5e:	b993      	cbnz	r3, 26e86 <bt_gatt_attr_read_service+0x36>
		u16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   26e60:	884b      	ldrh	r3, [r1, #2]
   26e62:	f8ad 3006 	strh.w	r3, [sp, #6]
	if (offset > value_len) {
   26e66:	2d02      	cmp	r5, #2
   26e68:	d819      	bhi.n	26e9e <bt_gatt_attr_read_service+0x4e>
	len = MIN(buf_len, value_len - offset);
   26e6a:	f1c5 0202 	rsb	r2, r5, #2
   26e6e:	4294      	cmp	r4, r2
   26e70:	bfa8      	it	ge
   26e72:	4614      	movge	r4, r2
	memcpy(buf, (u8_t *)value + offset, len);
   26e74:	f10d 0306 	add.w	r3, sp, #6
   26e78:	4622      	mov	r2, r4
   26e7a:	1959      	adds	r1, r3, r5
   26e7c:	f7fe ff14 	bl	25ca8 <memcpy>
}
   26e80:	4620      	mov	r0, r4
   26e82:	b003      	add	sp, #12
   26e84:	bd30      	pop	{r4, r5, pc}
	if (offset > value_len) {
   26e86:	2d10      	cmp	r5, #16
				 BT_UUID_128(uuid)->val, 16);
   26e88:	f101 0101 	add.w	r1, r1, #1
	if (offset > value_len) {
   26e8c:	d807      	bhi.n	26e9e <bt_gatt_attr_read_service+0x4e>
	len = MIN(buf_len, value_len - offset);
   26e8e:	f1c5 0210 	rsb	r2, r5, #16
   26e92:	4294      	cmp	r4, r2
   26e94:	bfa8      	it	ge
   26e96:	4614      	movge	r4, r2
	memcpy(buf, (u8_t *)value + offset, len);
   26e98:	4622      	mov	r2, r4
   26e9a:	4429      	add	r1, r5
   26e9c:	e7ee      	b.n	26e7c <bt_gatt_attr_read_service+0x2c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   26e9e:	f06f 0406 	mvn.w	r4, #6
   26ea2:	e7ed      	b.n	26e80 <bt_gatt_attr_read_service+0x30>

00026ea4 <sc_ccc_cfg_write>:
	if (value == BT_GATT_CCC_INDICATE) {
   26ea4:	2a02      	cmp	r2, #2
{
   26ea6:	b510      	push	{r4, lr}
	if (value == BT_GATT_CCC_INDICATE) {
   26ea8:	d108      	bne.n	26ebc <sc_ccc_cfg_write+0x18>
		sc_save(conn->id, &conn->le.dst, 0, 0);
   26eaa:	2300      	movs	r3, #0
   26eac:	f100 0174 	add.w	r1, r0, #116	; 0x74
   26eb0:	461a      	mov	r2, r3
   26eb2:	7a00      	ldrb	r0, [r0, #8]
   26eb4:	f7e3 ff82 	bl	adbc <sc_save>
}
   26eb8:	2002      	movs	r0, #2
   26eba:	bd10      	pop	{r4, pc}
		sc_clear_by_conn(conn);
   26ebc:	f7ff ff3a 	bl	26d34 <sc_clear_by_conn>
   26ec0:	e7fa      	b.n	26eb8 <sc_ccc_cfg_write+0x14>

00026ec2 <bt_gatt_attr_read_chrc>:
{
   26ec2:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_gatt_chrc *chrc = attr->user_data;
   26ec4:	68cf      	ldr	r7, [r1, #12]
{
   26ec6:	b087      	sub	sp, #28
   26ec8:	4608      	mov	r0, r1
   26eca:	461c      	mov	r4, r3
	pdu.properties = chrc->properties;
   26ecc:	79bb      	ldrb	r3, [r7, #6]
   26ece:	f88d 3004 	strb.w	r3, [sp, #4]
{
   26ed2:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
   26ed6:	4615      	mov	r5, r2
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   26ed8:	f7e4 f9f2 	bl	b2c0 <bt_gatt_attr_value_handle>
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   26edc:	6839      	ldr	r1, [r7, #0]
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   26ede:	f8ad 0005 	strh.w	r0, [sp, #5]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   26ee2:	780b      	ldrb	r3, [r1, #0]
   26ee4:	b99b      	cbnz	r3, 26f0e <bt_gatt_attr_read_chrc+0x4c>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   26ee6:	884b      	ldrh	r3, [r1, #2]
   26ee8:	f8ad 3007 	strh.w	r3, [sp, #7]
		value_len += 2U;
   26eec:	2105      	movs	r1, #5
	if (offset > value_len) {
   26eee:	42b1      	cmp	r1, r6
   26ef0:	d315      	bcc.n	26f1e <bt_gatt_attr_read_chrc+0x5c>
	len = MIN(buf_len, value_len - offset);
   26ef2:	1b89      	subs	r1, r1, r6
   26ef4:	42a1      	cmp	r1, r4
   26ef6:	bfa8      	it	ge
   26ef8:	4621      	movge	r1, r4
   26efa:	b28c      	uxth	r4, r1
	memcpy(buf, (u8_t *)value + offset, len);
   26efc:	ab01      	add	r3, sp, #4
   26efe:	4622      	mov	r2, r4
   26f00:	1999      	adds	r1, r3, r6
   26f02:	4628      	mov	r0, r5
   26f04:	f7fe fed0 	bl	25ca8 <memcpy>
}
   26f08:	4620      	mov	r0, r4
   26f0a:	b007      	add	sp, #28
   26f0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
   26f0e:	3101      	adds	r1, #1
   26f10:	2210      	movs	r2, #16
   26f12:	f10d 0007 	add.w	r0, sp, #7
   26f16:	f7fe fec7 	bl	25ca8 <memcpy>
		value_len += 16U;
   26f1a:	2113      	movs	r1, #19
   26f1c:	e7e7      	b.n	26eee <bt_gatt_attr_read_chrc+0x2c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   26f1e:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   26f22:	e7f1      	b.n	26f08 <bt_gatt_attr_read_chrc+0x46>

00026f24 <bt_gatt_foreach_attr>:
{
   26f24:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   26f26:	e9cd 2301 	strd	r2, r3, [sp, #4]
   26f2a:	2300      	movs	r3, #0
   26f2c:	9300      	str	r3, [sp, #0]
   26f2e:	461a      	mov	r2, r3
   26f30:	f7e4 f9de 	bl	b2f0 <bt_gatt_foreach_attr_type>
}
   26f34:	b005      	add	sp, #20
   26f36:	f85d fb04 	ldr.w	pc, [sp], #4

00026f3a <bt_gatt_get_mtu>:
	return bt_att_get_mtu(conn);
   26f3a:	f7ff be42 	b.w	26bc2 <bt_att_get_mtu>

00026f3e <bt_gatt_check_perm>:
	if ((mask & BT_GATT_PERM_READ) &&
   26f3e:	07d3      	lsls	r3, r2, #31
{
   26f40:	b510      	push	{r4, lr}
   26f42:	7c8c      	ldrb	r4, [r1, #18]
	if ((mask & BT_GATT_PERM_READ) &&
   26f44:	d504      	bpl.n	26f50 <bt_gatt_check_perm+0x12>
   26f46:	f014 0f15 	tst.w	r4, #21
   26f4a:	d017      	beq.n	26f7c <bt_gatt_check_perm+0x3e>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   26f4c:	684b      	ldr	r3, [r1, #4]
   26f4e:	b1ab      	cbz	r3, 26f7c <bt_gatt_check_perm+0x3e>
	if ((mask & BT_GATT_PERM_WRITE) &&
   26f50:	0793      	lsls	r3, r2, #30
   26f52:	d504      	bpl.n	26f5e <bt_gatt_check_perm+0x20>
   26f54:	f014 0f2a 	tst.w	r4, #42	; 0x2a
   26f58:	d012      	beq.n	26f80 <bt_gatt_check_perm+0x42>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   26f5a:	688b      	ldr	r3, [r1, #8]
   26f5c:	b183      	cbz	r3, 26f80 <bt_gatt_check_perm+0x42>
	mask &= attr->perm;
   26f5e:	4014      	ands	r4, r2
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   26f60:	f014 0f30 	tst.w	r4, #48	; 0x30
   26f64:	d104      	bne.n	26f70 <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   26f66:	f014 000c 	ands.w	r0, r4, #12
   26f6a:	bf18      	it	ne
   26f6c:	200f      	movne	r0, #15
}
   26f6e:	bd10      	pop	{r4, pc}
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   26f70:	f7ff faf8 	bl	26564 <bt_conn_get_security>
   26f74:	2802      	cmp	r0, #2
   26f76:	d8f6      	bhi.n	26f66 <bt_gatt_check_perm+0x28>
			return BT_ATT_ERR_AUTHENTICATION;
   26f78:	2005      	movs	r0, #5
   26f7a:	e7f8      	b.n	26f6e <bt_gatt_check_perm+0x30>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   26f7c:	2002      	movs	r0, #2
   26f7e:	e7f6      	b.n	26f6e <bt_gatt_check_perm+0x30>
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   26f80:	2003      	movs	r0, #3
   26f82:	e7f4      	b.n	26f6e <bt_gatt_check_perm+0x30>

00026f84 <bt_gatt_change_aware>:
}
   26f84:	2001      	movs	r0, #1
   26f86:	4770      	bx	lr

00026f88 <bt_smp_recv>:
{
   26f88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	buf = bt_l2cap_create_pdu(NULL, 0);
   26f8a:	2100      	movs	r1, #0
	struct bt_conn *conn = chan->conn;
   26f8c:	6807      	ldr	r7, [r0, #0]
	buf = bt_l2cap_create_pdu(NULL, 0);
   26f8e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   26f92:	4608      	mov	r0, r1
   26f94:	f7ff fbae 	bl	266f4 <bt_l2cap_create_pdu_timeout>
	hdr = net_buf_add(buf, sizeof(*hdr));
   26f98:	f100 0608 	add.w	r6, r0, #8
	buf = bt_l2cap_create_pdu(NULL, 0);
   26f9c:	4604      	mov	r4, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
   26f9e:	2101      	movs	r1, #1
   26fa0:	4630      	mov	r0, r6
   26fa2:	f7f8 f999 	bl	1f2d8 <net_buf_simple_add>
	hdr->code = BT_SMP_CMD_PAIRING_FAIL;
   26fa6:	2505      	movs	r5, #5
   26fa8:	7005      	strb	r5, [r0, #0]
	rsp = net_buf_add(buf, sizeof(*rsp));
   26faa:	2101      	movs	r1, #1
   26fac:	4630      	mov	r0, r6
   26fae:	f7f8 f993 	bl	1f2d8 <net_buf_simple_add>
	rsp->reason = BT_SMP_ERR_PAIRING_NOTSUPP;
   26fb2:	7005      	strb	r5, [r0, #0]
   26fb4:	2500      	movs	r5, #0
   26fb6:	9500      	str	r5, [sp, #0]
   26fb8:	462b      	mov	r3, r5
   26fba:	4622      	mov	r2, r4
   26fbc:	2106      	movs	r1, #6
   26fbe:	4638      	mov	r0, r7
   26fc0:	f7ff fb9b 	bl	266fa <bt_l2cap_send_cb>
}
   26fc4:	4628      	mov	r0, r5
   26fc6:	b003      	add	sp, #12
   26fc8:	bdf0      	pop	{r4, r5, r6, r7, pc}

00026fca <bt_smp_sign>:
   26fca:	f06f 0022 	mvn.w	r0, #34	; 0x22
   26fce:	4770      	bx	lr

00026fd0 <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_fixed_chan, BT_L2CAP_CID_SMP, bt_smp_accept, NULL);

int bt_smp_init(void)
{
	return 0;
}
   26fd0:	2000      	movs	r0, #0
   26fd2:	4770      	bx	lr

00026fd4 <model_start>:
	if (mod->cb && mod->cb->start) {
   26fd4:	6983      	ldr	r3, [r0, #24]
   26fd6:	b113      	cbz	r3, 26fde <model_start+0xa>
   26fd8:	685b      	ldr	r3, [r3, #4]
   26fda:	b103      	cbz	r3, 26fde <model_start+0xa>
		mod->cb->start(mod);
   26fdc:	4718      	bx	r3
}
   26fde:	4770      	bx	lr

00026fe0 <bt_mesh_init>:
{
   26fe0:	b538      	push	{r3, r4, r5, lr}
   26fe2:	4605      	mov	r5, r0
	err = bt_mesh_comp_register(comp);
   26fe4:	4608      	mov	r0, r1
   26fe6:	f7e8 fd2f 	bl	fa48 <bt_mesh_comp_register>
	if (err) {
   26fea:	4604      	mov	r4, r0
   26fec:	b980      	cbnz	r0, 27010 <bt_mesh_init+0x30>
		bt_mesh_proxy_init();
   26fee:	f7f1 f833 	bl	18058 <bt_mesh_proxy_init>
		err = bt_mesh_prov_init(prov);
   26ff2:	4628      	mov	r0, r5
   26ff4:	f7ef fa96 	bl	16524 <bt_mesh_prov_init>
		if (err) {
   26ff8:	4604      	mov	r4, r0
   26ffa:	b948      	cbnz	r0, 27010 <bt_mesh_init+0x30>
	bt_mesh_net_init();
   26ffc:	f7e6 fdc0 	bl	db80 <bt_mesh_net_init>
	bt_mesh_trans_init();
   27000:	f7e8 f928 	bl	f254 <bt_mesh_trans_init>
	bt_mesh_beacon_init();
   27004:	f7e5 fab2 	bl	c56c <bt_mesh_beacon_init>
	bt_mesh_adv_init();
   27008:	f7e5 f8c2 	bl	c190 <bt_mesh_adv_init>
		bt_mesh_settings_init();
   2700c:	f7ec ff22 	bl	13e54 <bt_mesh_settings_init>
}
   27010:	4620      	mov	r0, r4
   27012:	bd38      	pop	{r3, r4, r5, pc}

00027014 <beacon_complete>:
{
   27014:	b510      	push	{r4, lr}
   27016:	460c      	mov	r4, r1
	return z_impl_k_uptime_ticks();
   27018:	f002 f9fb 	bl	29412 <z_impl_k_uptime_ticks>
			return (t * to_hz + off) / from_hz;
   2701c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   27020:	460a      	mov	r2, r1
   27022:	fba0 0103 	umull	r0, r1, r0, r3
   27026:	fb03 1102 	mla	r1, r3, r2, r1
   2702a:	0bc3      	lsrs	r3, r0, #15
   2702c:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
	return (u32_t)k_uptime_get();
   27030:	6023      	str	r3, [r4, #0]
}
   27032:	bd10      	pop	{r4, pc}

00027034 <friend_cred_clear>:
	cred->addr = BT_MESH_ADDR_UNASSIGNED;
   27034:	2100      	movs	r1, #0
	cred->net_idx = BT_MESH_KEY_UNUSED;
   27036:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2703a:	8003      	strh	r3, [r0, #0]
	cred->addr = BT_MESH_ADDR_UNASSIGNED;
   2703c:	8041      	strh	r1, [r0, #2]
	cred->lpn_counter = 0U;
   2703e:	8081      	strh	r1, [r0, #4]
	cred->frnd_counter = 0U;
   27040:	80c1      	strh	r1, [r0, #6]
	(void)memset(cred->cred, 0, sizeof(cred->cred));
   27042:	2242      	movs	r2, #66	; 0x42
   27044:	3008      	adds	r0, #8
   27046:	f7fe be5a 	b.w	25cfe <memset>

0002704a <bt_mesh_net_flags>:
{
   2704a:	b508      	push	{r3, lr}
	if (sub && sub->kr_flag) {
   2704c:	4602      	mov	r2, r0
   2704e:	b100      	cbz	r0, 27052 <bt_mesh_net_flags+0x8>
	u8_t flags = 0x00;
   27050:	7f82      	ldrb	r2, [r0, #30]
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   27052:	f7e5 fc47 	bl	c8e4 <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS)) {
   27056:	0743      	lsls	r3, r0, #29
		flags |= BT_MESH_NET_FLAG_IVU;
   27058:	bf48      	it	mi
   2705a:	f042 0202 	orrmi.w	r2, r2, #2
}
   2705e:	4610      	mov	r0, r2
   27060:	bd08      	pop	{r3, pc}

00027062 <bt_mesh_net_sec_update>:
{
   27062:	b510      	push	{r4, lr}
		bt_mesh_friend_sec_update(sub ? sub->net_idx : BT_MESH_KEY_ANY);
   27064:	4604      	mov	r4, r0
   27066:	b158      	cbz	r0, 27080 <bt_mesh_net_sec_update+0x1e>
   27068:	8b80      	ldrh	r0, [r0, #28]
   2706a:	f7ed fd95 	bl	14b98 <bt_mesh_friend_sec_update>
	    bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED) {
   2706e:	f7eb fa95 	bl	1259c <bt_mesh_gatt_proxy_get>
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
   27072:	2801      	cmp	r0, #1
   27074:	d107      	bne.n	27086 <bt_mesh_net_sec_update+0x24>
		bt_mesh_proxy_beacon_send(sub);
   27076:	4620      	mov	r0, r4
}
   27078:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_mesh_proxy_beacon_send(sub);
   2707c:	f7f0 bc92 	b.w	179a4 <bt_mesh_proxy_beacon_send>
		bt_mesh_friend_sec_update(sub ? sub->net_idx : BT_MESH_KEY_ANY);
   27080:	f64f 70ff 	movw	r0, #65535	; 0xffff
   27084:	e7f1      	b.n	2706a <bt_mesh_net_sec_update+0x8>
}
   27086:	bd10      	pop	{r4, pc}

00027088 <send_cb_finalize>:
{
   27088:	b570      	push	{r4, r5, r6, lr}
   2708a:	460d      	mov	r5, r1
	if (!cb) {
   2708c:	4604      	mov	r4, r0
   2708e:	b160      	cbz	r0, 270aa <send_cb_finalize+0x22>
	if (cb->start) {
   27090:	6803      	ldr	r3, [r0, #0]
   27092:	b11b      	cbz	r3, 2709c <send_cb_finalize+0x14>
		cb->start(0, 0, cb_data);
   27094:	460a      	mov	r2, r1
   27096:	2100      	movs	r1, #0
   27098:	4608      	mov	r0, r1
   2709a:	4798      	blx	r3
	if (cb->end) {
   2709c:	6863      	ldr	r3, [r4, #4]
   2709e:	b123      	cbz	r3, 270aa <send_cb_finalize+0x22>
		cb->end(0, cb_data);
   270a0:	4629      	mov	r1, r5
   270a2:	2000      	movs	r0, #0
	}
}
   270a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		cb->end(0, cb_data);
   270a8:	4718      	bx	r3
}
   270aa:	bd70      	pop	{r4, r5, r6, pc}

000270ac <seg_tx_buf_build>:
{
   270ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   270b0:	f890 3020 	ldrb.w	r3, [r0, #32]
	u16_t seq_zero = tx->seq_auth & TRANS_SEQ_ZERO_MASK;
   270b4:	f8b0 8010 	ldrh.w	r8, [r0, #16]
		return BT_MESH_APP_SEG_SDU_MAX;
   270b8:	f013 0f20 	tst.w	r3, #32
	u8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   270bc:	8b83      	ldrh	r3, [r0, #28]
		return BT_MESH_APP_SEG_SDU_MAX;
   270be:	bf14      	ite	ne
   270c0:	2708      	movne	r7, #8
   270c2:	270c      	moveq	r7, #12
	u8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   270c4:	fb07 3311 	mls	r3, r7, r1, r3
{
   270c8:	4604      	mov	r4, r0
	u8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   270ca:	429f      	cmp	r7, r3
{
   270cc:	460e      	mov	r6, r1
	net_buf_simple_add_u8(buf, tx->hdr);
   270ce:	7f81      	ldrb	r1, [r0, #30]
   270d0:	4610      	mov	r0, r2
{
   270d2:	4615      	mov	r5, r2
	u8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   270d4:	bfa8      	it	ge
   270d6:	b2df      	uxtbge	r7, r3
	net_buf_simple_add_u8(buf, tx->hdr);
   270d8:	f001 fe79 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(buf, (tx->aszmic << 7) | seq_zero >> 6);
   270dc:	f894 3020 	ldrb.w	r3, [r4, #32]
	u16_t seq_zero = tx->seq_auth & TRANS_SEQ_ZERO_MASK;
   270e0:	f3c8 080c 	ubfx	r8, r8, #0, #13
	net_buf_simple_add_u8(buf, (tx->aszmic << 7) | seq_zero >> 6);
   270e4:	f3c3 1380 	ubfx	r3, r3, #6, #1
   270e8:	ea4f 1198 	mov.w	r1, r8, lsr #6
   270ec:	ea41 11c3 	orr.w	r1, r1, r3, lsl #7
   270f0:	4628      	mov	r0, r5
   270f2:	f001 fe6c 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(buf, (((seq_zero & 0x3f) << 2) | (seg_o >> 3)));
   270f6:	08f1      	lsrs	r1, r6, #3
   270f8:	ea41 0188 	orr.w	r1, r1, r8, lsl #2
   270fc:	b2c9      	uxtb	r1, r1
   270fe:	4628      	mov	r0, r5
   27100:	f001 fe65 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_u8(buf, ((seg_o & 0x07) << 5) | tx->seg_n);
   27104:	f894 1020 	ldrb.w	r1, [r4, #32]
   27108:	f3c1 0104 	ubfx	r1, r1, #0, #5
   2710c:	ea41 1146 	orr.w	r1, r1, r6, lsl #5
	net_buf_simple_add_mem(buf, tx->seg[seg_o], len);
   27110:	eb04 0486 	add.w	r4, r4, r6, lsl #2
	net_buf_simple_add_u8(buf, ((seg_o & 0x07) << 5) | tx->seg_n);
   27114:	b2c9      	uxtb	r1, r1
   27116:	4628      	mov	r0, r5
   27118:	f001 fe59 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_mem(buf, tx->seg[seg_o], len);
   2711c:	6861      	ldr	r1, [r4, #4]
   2711e:	463a      	mov	r2, r7
   27120:	4628      	mov	r0, r5
}
   27122:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	net_buf_simple_add_mem(buf, tx->seg[seg_o], len);
   27126:	f001 be46 	b.w	28db6 <net_buf_simple_add_mem>

0002712a <ack_timeout>:
{
   2712a:	b538      	push	{r3, r4, r5, lr}
	if (rx->ttl == BT_MESH_TTL_DEFAULT) {
   2712c:	f890 4020 	ldrb.w	r4, [r0, #32]
   27130:	2cff      	cmp	r4, #255	; 0xff
{
   27132:	4605      	mov	r5, r0
	if (rx->ttl == BT_MESH_TTL_DEFAULT) {
   27134:	d102      	bne.n	2713c <ack_timeout+0x12>
		ttl = bt_mesh_default_ttl_get();
   27136:	f7eb faa9 	bl	1268c <bt_mesh_default_ttl_get>
   2713a:	4604      	mov	r4, r0
	to += K_MSEC(((rx->seg_n + 1) - popcount(rx->block)) * 100U);
   2713c:	6a68      	ldr	r0, [r5, #36]	; 0x24
   2713e:	f7d9 f847 	bl	1d0 <__popcountsi2>
   27142:	7feb      	ldrb	r3, [r5, #31]
   27144:	f003 031f 	and.w	r3, r3, #31
   27148:	1a18      	subs	r0, r3, r0
   2714a:	2364      	movs	r3, #100	; 0x64
   2714c:	fb00 3303 	mla	r3, r0, r3, r3
	to = K_MSEC(150 + (ttl * 50U));
   27150:	2296      	movs	r2, #150	; 0x96
   27152:	2032      	movs	r0, #50	; 0x32
   27154:	fb10 2004 	smlabb	r0, r0, r4, r2
	to += K_MSEC(((rx->seg_n + 1) - popcount(rx->block)) * 100U);
   27158:	4418      	add	r0, r3
}
   2715a:	f5b0 7fc8 	cmp.w	r0, #400	; 0x190
   2715e:	bfb8      	it	lt
   27160:	f44f 70c8 	movlt.w	r0, #400	; 0x190
   27164:	bd38      	pop	{r3, r4, r5, pc}

00027166 <seg_rx_assemble>:
{
   27166:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf->data = buf->__buf;
   2716a:	688b      	ldr	r3, [r1, #8]
   2716c:	600b      	str	r3, [r1, #0]
	buf->len  = 0U;
   2716e:	2500      	movs	r5, #0
   27170:	4606      	mov	r6, r0
   27172:	460c      	mov	r4, r1
   27174:	4617      	mov	r7, r2
   27176:	808d      	strh	r5, [r1, #4]
	for (i = 0; i <= rx->seg_n; i++) {
   27178:	f100 0804 	add.w	r8, r0, #4
				       MIN(seg_len(rx->ctl),
   2717c:	7ff3      	ldrb	r3, [r6, #31]
		net_buf_simple_add_mem(buf, rx->seg[i],
   2717e:	f858 1b04 	ldr.w	r1, [r8], #4
		return BT_MESH_APP_SEG_SDU_MAX;
   27182:	f013 0f20 	tst.w	r3, #32
				       MIN(seg_len(rx->ctl),
   27186:	8bb3      	ldrh	r3, [r6, #28]
		return BT_MESH_APP_SEG_SDU_MAX;
   27188:	bf14      	ite	ne
   2718a:	2208      	movne	r2, #8
   2718c:	220c      	moveq	r2, #12
				       MIN(seg_len(rx->ctl),
   2718e:	fb05 3312 	mls	r3, r5, r2, r3
		net_buf_simple_add_mem(buf, rx->seg[i],
   27192:	429a      	cmp	r2, r3
   27194:	bfa8      	it	ge
   27196:	461a      	movge	r2, r3
   27198:	4620      	mov	r0, r4
   2719a:	f001 fe0c 	bl	28db6 <net_buf_simple_add_mem>
	for (i = 0; i <= rx->seg_n; i++) {
   2719e:	7ff3      	ldrb	r3, [r6, #31]
   271a0:	3501      	adds	r5, #1
   271a2:	461a      	mov	r2, r3
   271a4:	f003 031f 	and.w	r3, r3, #31
   271a8:	42ab      	cmp	r3, r5
   271aa:	dae7      	bge.n	2717c <seg_rx_assemble+0x16>
	if (!rx->ctl) {
   271ac:	0693      	lsls	r3, r2, #26
   271ae:	d407      	bmi.n	271c0 <seg_rx_assemble+0x5a>
		buf->len -= APP_MIC_LEN(aszmic);
   271b0:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
   271b4:	2f00      	cmp	r7, #0
   271b6:	bf14      	ite	ne
   271b8:	2208      	movne	r2, #8
   271ba:	2204      	moveq	r2, #4
   271bc:	1a9b      	subs	r3, r3, r2
   271be:	80a3      	strh	r3, [r4, #4]
}
   271c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000271c4 <seg_retransmit>:
	seg_tx_send_unacked(tx);
   271c4:	3830      	subs	r0, #48	; 0x30
   271c6:	f7e6 bec5 	b.w	df54 <seg_tx_send_unacked>

000271ca <seg_sent>:
	schedule_retransmit(tx);
   271ca:	4608      	mov	r0, r1
   271cc:	f7e7 b8dc 	b.w	e388 <schedule_retransmit>

000271d0 <seg_send_start>:
{
   271d0:	b538      	push	{r3, r4, r5, lr}
	if (!tx->started && tx->cb && tx->cb->start) {
   271d2:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
   271d6:	069b      	lsls	r3, r3, #26
{
   271d8:	460d      	mov	r5, r1
   271da:	4614      	mov	r4, r2
	if (!tx->started && tx->cb && tx->cb->start) {
   271dc:	d40b      	bmi.n	271f6 <seg_send_start+0x26>
   271de:	6a93      	ldr	r3, [r2, #40]	; 0x28
   271e0:	b14b      	cbz	r3, 271f6 <seg_send_start+0x26>
   271e2:	681b      	ldr	r3, [r3, #0]
   271e4:	b13b      	cbz	r3, 271f6 <seg_send_start+0x26>
		tx->cb->start(duration, err, tx->cb_data);
   271e6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   271e8:	4798      	blx	r3
		tx->started = 1U;
   271ea:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
   271ee:	f043 0320 	orr.w	r3, r3, #32
   271f2:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	if (err) {
   271f6:	b125      	cbz	r5, 27202 <seg_send_start+0x32>
		schedule_retransmit(tx);
   271f8:	4620      	mov	r0, r4
}
   271fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		schedule_retransmit(tx);
   271fe:	f7e7 b8c3 	b.w	e388 <schedule_retransmit>
}
   27202:	bd38      	pop	{r3, r4, r5, pc}

00027204 <bt_mesh_ctl_send>:
{
   27204:	b5f0      	push	{r4, r5, r6, r7, lr}
   27206:	b089      	sub	sp, #36	; 0x24
   27208:	4604      	mov	r4, r0
   2720a:	4608      	mov	r0, r1
   2720c:	f88d 000f 	strb.w	r0, [sp, #15]
   27210:	4611      	mov	r1, r2
	net_buf_simple_init_with_data(&buf, data, data_len);
   27212:	a805      	add	r0, sp, #20
   27214:	461a      	mov	r2, r3
{
   27216:	461d      	mov	r5, r3
   27218:	e9dd 670e 	ldrd	r6, r7, [sp, #56]	; 0x38
	net_buf_simple_init_with_data(&buf, data, data_len);
   2721c:	f001 fd73 	bl	28d06 <net_buf_simple_init_with_data>
	if (data_len > BT_MESH_SDU_UNSEG_MAX) {
   27220:	6862      	ldr	r2, [r4, #4]
   27222:	2d0b      	cmp	r5, #11
		tx->ctx->send_rel = true;
   27224:	bf84      	itt	hi
   27226:	2301      	movhi	r3, #1
   27228:	7293      	strbhi	r3, [r2, #10]
	tx->ctx->app_idx = BT_MESH_KEY_UNUSED;
   2722a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2722e:	8053      	strh	r3, [r2, #2]
	if (tx->ctx->send_rel) {
   27230:	7a92      	ldrb	r2, [r2, #10]
   27232:	f10d 030f 	add.w	r3, sp, #15
		return send_seg(tx, &buf, cb, cb_data, &ctl_op);
   27236:	9300      	str	r3, [sp, #0]
   27238:	463b      	mov	r3, r7
	if (tx->ctx->send_rel) {
   2723a:	b132      	cbz	r2, 2724a <bt_mesh_ctl_send+0x46>
		return send_seg(tx, &buf, cb, cb_data, &ctl_op);
   2723c:	4632      	mov	r2, r6
   2723e:	a905      	add	r1, sp, #20
   27240:	4620      	mov	r0, r4
   27242:	f7e6 ff2f 	bl	e0a4 <send_seg>
}
   27246:	b009      	add	sp, #36	; 0x24
   27248:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return send_unseg(tx, &buf, cb, cb_data, &ctl_op);
   2724a:	4632      	mov	r2, r6
   2724c:	a905      	add	r1, sp, #20
   2724e:	4620      	mov	r0, r4
   27250:	f7e6 fcaa 	bl	dba8 <send_unseg>
   27254:	e7f7      	b.n	27246 <bt_mesh_ctl_send+0x42>

00027256 <send_ack>:
{
   27256:	b5f0      	push	{r4, r5, r6, r7, lr}
   27258:	b08b      	sub	sp, #44	; 0x2c
	struct bt_mesh_msg_ctx ctx = {
   2725a:	8b87      	ldrh	r7, [r0, #28]
{
   2725c:	f89d 4048 	ldrb.w	r4, [sp, #72]	; 0x48
	struct bt_mesh_msg_ctx ctx = {
   27260:	f8ad 7010 	strh.w	r7, [sp, #16]
{
   27264:	460d      	mov	r5, r1
	struct bt_mesh_msg_ctx ctx = {
   27266:	f64f 77ff 	movw	r7, #65535	; 0xffff
   2726a:	2100      	movs	r1, #0
   2726c:	f88d 301b 	strb.w	r3, [sp, #27]
	struct bt_mesh_net_tx tx = {
   27270:	ab04      	add	r3, sp, #16
{
   27272:	9e11      	ldr	r6, [sp, #68]	; 0x44
	struct bt_mesh_msg_ctx ctx = {
   27274:	f8cd 1016 	str.w	r1, [sp, #22]
   27278:	f88d 101a 	strb.w	r1, [sp, #26]
   2727c:	f8ad 7012 	strh.w	r7, [sp, #18]
   27280:	f8ad 2014 	strh.w	r2, [sp, #20]
	struct bt_mesh_net_tx tx = {
   27284:	9109      	str	r1, [sp, #36]	; 0x24
   27286:	9007      	str	r0, [sp, #28]
   27288:	9308      	str	r3, [sp, #32]
   2728a:	b33c      	cbz	r4, 272dc <send_ack+0x86>
		.src = obo ? bt_mesh_primary_addr() : src,
   2728c:	f7e8 fc0e 	bl	faac <bt_mesh_primary_addr>
	struct bt_mesh_net_tx tx = {
   27290:	f8ad 0024 	strh.w	r0, [sp, #36]	; 0x24
		.xmit = bt_mesh_net_transmit_get(),
   27294:	f7ea ffb6 	bl	12204 <bt_mesh_net_transmit_get>
	if (!BT_MESH_ADDR_IS_UNICAST(src)) {
   27298:	b22d      	sxth	r5, r5
   2729a:	2d00      	cmp	r5, #0
	struct bt_mesh_net_tx tx = {
   2729c:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
	if (!BT_MESH_ADDR_IS_UNICAST(src)) {
   272a0:	dd1e      	ble.n	272e0 <send_ack+0x8a>
	u16_t seq_zero = *seq_auth & TRANS_SEQ_ZERO_MASK;
   272a2:	9b10      	ldr	r3, [sp, #64]	; 0x40
   272a4:	881b      	ldrh	r3, [r3, #0]
	sys_put_be16(((seq_zero << 2) & 0x7ffc) | (obo << 15), buf);
   272a6:	03e4      	lsls	r4, r4, #15
   272a8:	f3c3 030c 	ubfx	r3, r3, #0, #13
   272ac:	ea44 0483 	orr.w	r4, r4, r3, lsl #2
	sys_put_be16(val >> 16, dst);
   272b0:	0c33      	lsrs	r3, r6, #16
	dst[0] = val >> 8;
   272b2:	0e32      	lsrs	r2, r6, #24
	dst[1] = val;
   272b4:	f88d 300b 	strb.w	r3, [sp, #11]
	return bt_mesh_ctl_send(&tx, TRANS_CTL_OP_ACK, buf, sizeof(buf),
   272b8:	2100      	movs	r1, #0
	dst[0] = val >> 8;
   272ba:	ba73      	rev16	r3, r6
   272bc:	ba64      	rev16	r4, r4
   272be:	f88d 200a 	strb.w	r2, [sp, #10]
   272c2:	f8ad 300c 	strh.w	r3, [sp, #12]
   272c6:	e9cd 1100 	strd	r1, r1, [sp]
   272ca:	2306      	movs	r3, #6
   272cc:	aa02      	add	r2, sp, #8
   272ce:	a807      	add	r0, sp, #28
   272d0:	f8ad 4008 	strh.w	r4, [sp, #8]
   272d4:	f7ff ff96 	bl	27204 <bt_mesh_ctl_send>
}
   272d8:	b00b      	add	sp, #44	; 0x2c
   272da:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct bt_mesh_net_tx tx = {
   272dc:	4628      	mov	r0, r5
   272de:	e7d7      	b.n	27290 <send_ack+0x3a>
		return 0;
   272e0:	2000      	movs	r0, #0
   272e2:	e7f9      	b.n	272d8 <send_ack+0x82>

000272e4 <bt_mesh_heartbeat_send>:
{
   272e4:	b510      	push	{r4, lr}
   272e6:	b08a      	sub	sp, #40	; 0x28
	struct bt_mesh_cfg_srv *cfg = bt_mesh_cfg_get();
   272e8:	f7eb fabe 	bl	12868 <bt_mesh_cfg_get>
   272ec:	4604      	mov	r4, r0
	struct bt_mesh_msg_ctx ctx = {
   272ee:	f64f 72ff 	movw	r2, #65535	; 0xffff
   272f2:	f8ad 2012 	strh.w	r2, [sp, #18]
   272f6:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
		.net_idx = cfg->hb_pub.net_idx,
   272f8:	8e80      	ldrh	r0, [r0, #52]	; 0x34
	struct bt_mesh_msg_ctx ctx = {
   272fa:	f8ad 2014 	strh.w	r2, [sp, #20]
   272fe:	2300      	movs	r3, #0
   27300:	f894 2031 	ldrb.w	r2, [r4, #49]	; 0x31
   27304:	f88d 201b 	strb.w	r2, [sp, #27]
	struct bt_mesh_net_tx tx = {
   27308:	e9cd 3307 	strd	r3, r3, [sp, #28]
	struct bt_mesh_msg_ctx ctx = {
   2730c:	f8cd 3016 	str.w	r3, [sp, #22]
   27310:	f88d 301a 	strb.w	r3, [sp, #26]
	struct bt_mesh_net_tx tx = {
   27314:	9309      	str	r3, [sp, #36]	; 0x24
	struct bt_mesh_msg_ctx ctx = {
   27316:	f8ad 0010 	strh.w	r0, [sp, #16]
		.sub = bt_mesh_subnet_get(cfg->hb_pub.net_idx),
   2731a:	f7e5 fb67 	bl	c9ec <bt_mesh_subnet_get>
	struct bt_mesh_net_tx tx = {
   2731e:	ab04      	add	r3, sp, #16
   27320:	9007      	str	r0, [sp, #28]
		.src = bt_mesh_model_elem(cfg->model)->addr,
   27322:	6820      	ldr	r0, [r4, #0]
	struct bt_mesh_net_tx tx = {
   27324:	9308      	str	r3, [sp, #32]
		.src = bt_mesh_model_elem(cfg->model)->addr,
   27326:	f7e8 fb3f 	bl	f9a8 <bt_mesh_model_elem>
	struct bt_mesh_net_tx tx = {
   2732a:	8803      	ldrh	r3, [r0, #0]
   2732c:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
		.xmit = bt_mesh_net_transmit_get(),
   27330:	f7ea ff68 	bl	12204 <bt_mesh_net_transmit_get>
	if (cfg->hb_pub.dst == BT_MESH_ADDR_UNASSIGNED) {
   27334:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
	struct bt_mesh_net_tx tx = {
   27336:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
	if (cfg->hb_pub.dst == BT_MESH_ADDR_UNASSIGNED) {
   2733a:	b30b      	cbz	r3, 27380 <bt_mesh_heartbeat_send+0x9c>
	hb.init_ttl = cfg->hb_pub.ttl;
   2733c:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
   27340:	f88d 300c 	strb.w	r3, [sp, #12]
	if (bt_mesh_relay_get() == BT_MESH_RELAY_ENABLED) {
   27344:	f7ea ffda 	bl	122fc <bt_mesh_relay_get>
	u16_t feat = 0U;
   27348:	1e43      	subs	r3, r0, #1
   2734a:	425c      	negs	r4, r3
   2734c:	415c      	adcs	r4, r3
	if (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED) {
   2734e:	f7eb f925 	bl	1259c <bt_mesh_gatt_proxy_get>
   27352:	2801      	cmp	r0, #1
		feat |= BT_MESH_FEAT_PROXY;
   27354:	bf08      	it	eq
   27356:	f044 0402 	orreq.w	r4, r4, #2
	if (bt_mesh_friend_get() == BT_MESH_FRIEND_ENABLED) {
   2735a:	f7ea ffd9 	bl	12310 <bt_mesh_friend_get>
   2735e:	2801      	cmp	r0, #1
	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_HEARTBEAT, &hb, sizeof(hb),
   27360:	f04f 0300 	mov.w	r3, #0
		feat |= BT_MESH_FEAT_FRIEND;
   27364:	bf08      	it	eq
   27366:	f044 0404 	orreq.w	r4, r4, #4
	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_HEARTBEAT, &hb, sizeof(hb),
   2736a:	e9cd 3300 	strd	r3, r3, [sp]
	hb.feat = sys_cpu_to_be16(feat);
   2736e:	0224      	lsls	r4, r4, #8
	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_HEARTBEAT, &hb, sizeof(hb),
   27370:	2303      	movs	r3, #3
   27372:	aa03      	add	r2, sp, #12
   27374:	210a      	movs	r1, #10
   27376:	a807      	add	r0, sp, #28
	hb.feat = sys_cpu_to_be16(feat);
   27378:	f8ad 400d 	strh.w	r4, [sp, #13]
	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_HEARTBEAT, &hb, sizeof(hb),
   2737c:	f7ff ff42 	bl	27204 <bt_mesh_ctl_send>
}
   27380:	b00a      	add	sp, #40	; 0x28
   27382:	bd10      	pop	{r4, pc}

00027384 <sys_put_be32>:
	sys_put_be16(val >> 16, dst);
   27384:	0c03      	lsrs	r3, r0, #16
	dst[0] = val >> 8;
   27386:	0e02      	lsrs	r2, r0, #24
	dst[1] = val;
   27388:	704b      	strb	r3, [r1, #1]
	dst[0] = val >> 8;
   2738a:	f3c0 2307 	ubfx	r3, r0, #8, #8
   2738e:	700a      	strb	r2, [r1, #0]
   27390:	708b      	strb	r3, [r1, #2]
	dst[1] = val;
   27392:	70c8      	strb	r0, [r1, #3]
}
   27394:	4770      	bx	lr

00027396 <bt_mesh_aes_cmac>:
{
   27396:	b570      	push	{r4, r5, r6, lr}
   27398:	b0c2      	sub	sp, #264	; 0x108
   2739a:	460d      	mov	r5, r1
   2739c:	4614      	mov	r4, r2
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   2739e:	4601      	mov	r1, r0
   273a0:	aa16      	add	r2, sp, #88	; 0x58
   273a2:	4668      	mov	r0, sp
{
   273a4:	461e      	mov	r6, r3
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   273a6:	f7fe fad1 	bl	2594c <tc_cmac_setup>
   273aa:	b130      	cbz	r0, 273ba <bt_mesh_aes_cmac+0x24>
   273ac:	3508      	adds	r5, #8
	for (; sg_len; sg_len--, sg++) {
   273ae:	b944      	cbnz	r4, 273c2 <bt_mesh_aes_cmac+0x2c>
	if (tc_cmac_final(mac, &state) == TC_CRYPTO_FAIL) {
   273b0:	4669      	mov	r1, sp
   273b2:	4630      	mov	r0, r6
   273b4:	f7fe fb61 	bl	25a7a <tc_cmac_final>
   273b8:	b968      	cbnz	r0, 273d6 <bt_mesh_aes_cmac+0x40>
		return -EIO;
   273ba:	f06f 0004 	mvn.w	r0, #4
}
   273be:	b042      	add	sp, #264	; 0x108
   273c0:	bd70      	pop	{r4, r5, r6, pc}
		if (tc_cmac_update(&state, sg->data,
   273c2:	e955 1202 	ldrd	r1, r2, [r5, #-8]
   273c6:	4668      	mov	r0, sp
   273c8:	f7fe faeb 	bl	259a2 <tc_cmac_update>
   273cc:	3508      	adds	r5, #8
   273ce:	2800      	cmp	r0, #0
   273d0:	d0f3      	beq.n	273ba <bt_mesh_aes_cmac+0x24>
	for (; sg_len; sg_len--, sg++) {
   273d2:	3c01      	subs	r4, #1
   273d4:	e7eb      	b.n	273ae <bt_mesh_aes_cmac+0x18>
	return 0;
   273d6:	4620      	mov	r0, r4
   273d8:	e7f1      	b.n	273be <bt_mesh_aes_cmac+0x28>

000273da <bt_mesh_aes_cmac_one>:
{
   273da:	b507      	push	{r0, r1, r2, lr}
	struct bt_mesh_sg sg = { m, len };
   273dc:	e9cd 1200 	strd	r1, r2, [sp]
	return bt_mesh_aes_cmac(key, &sg, 1, mac);
   273e0:	2201      	movs	r2, #1
   273e2:	4669      	mov	r1, sp
   273e4:	f7ff ffd7 	bl	27396 <bt_mesh_aes_cmac>
}
   273e8:	b003      	add	sp, #12
   273ea:	f85d fb04 	ldr.w	pc, [sp], #4

000273ee <bt_mesh_s1>:
{
   273ee:	b530      	push	{r4, r5, lr}
	const u8_t zero[16] = { 0 };
   273f0:	2200      	movs	r2, #0
{
   273f2:	b085      	sub	sp, #20
   273f4:	460d      	mov	r5, r1
	const u8_t zero[16] = { 0 };
   273f6:	e9cd 2200 	strd	r2, r2, [sp]
   273fa:	e9cd 2202 	strd	r2, r2, [sp, #8]
{
   273fe:	4604      	mov	r4, r0
	return bt_mesh_aes_cmac_one(zero, m, strlen(m), salt);
   27400:	f7fe fc20 	bl	25c44 <strlen>
   27404:	462b      	mov	r3, r5
   27406:	4602      	mov	r2, r0
   27408:	4621      	mov	r1, r4
   2740a:	4668      	mov	r0, sp
   2740c:	f7ff ffe5 	bl	273da <bt_mesh_aes_cmac_one>
}
   27410:	3800      	subs	r0, #0
   27412:	bf18      	it	ne
   27414:	2001      	movne	r0, #1
   27416:	b005      	add	sp, #20
   27418:	bd30      	pop	{r4, r5, pc}

0002741a <bt_mesh_k1>:
{
   2741a:	b570      	push	{r4, r5, r6, lr}
   2741c:	9d04      	ldr	r5, [sp, #16]
   2741e:	4606      	mov	r6, r0
   27420:	461c      	mov	r4, r3
   27422:	4610      	mov	r0, r2
	err = bt_mesh_aes_cmac_one(salt, ikm, ikm_len, okm);
   27424:	462b      	mov	r3, r5
   27426:	460a      	mov	r2, r1
   27428:	4631      	mov	r1, r6
   2742a:	f7ff ffd6 	bl	273da <bt_mesh_aes_cmac_one>
	if (err < 0) {
   2742e:	2800      	cmp	r0, #0
   27430:	db0a      	blt.n	27448 <bt_mesh_k1+0x2e>
	return bt_mesh_aes_cmac_one(okm, info, strlen(info), okm);
   27432:	4620      	mov	r0, r4
   27434:	f7fe fc06 	bl	25c44 <strlen>
   27438:	462b      	mov	r3, r5
   2743a:	4602      	mov	r2, r0
   2743c:	4621      	mov	r1, r4
   2743e:	4628      	mov	r0, r5
}
   27440:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_mesh_aes_cmac_one(okm, info, strlen(info), okm);
   27444:	f7ff bfc9 	b.w	273da <bt_mesh_aes_cmac_one>
}
   27448:	bd70      	pop	{r4, r5, r6, pc}

0002744a <bt_mesh_net_encrypt>:
{
   2744a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t mic_len = NET_MIC_LEN(buf->data);
   2744e:	680c      	ldr	r4, [r1, #0]
{
   27450:	4607      	mov	r7, r0
   27452:	4610      	mov	r0, r2
	u8_t mic_len = NET_MIC_LEN(buf->data);
   27454:	f994 2001 	ldrsb.w	r2, [r4, #1]
   27458:	f894 9001 	ldrb.w	r9, [r4, #1]
   2745c:	f894 8002 	ldrb.w	r8, [r4, #2]
   27460:	f894 e003 	ldrb.w	lr, [r4, #3]
   27464:	f894 c004 	ldrb.w	ip, [r4, #4]
   27468:	2a00      	cmp	r2, #0
{
   2746a:	460d      	mov	r5, r1
   2746c:	79a2      	ldrb	r2, [r4, #6]
   2746e:	7961      	ldrb	r1, [r4, #5]
   27470:	b089      	sub	sp, #36	; 0x24
	u8_t mic_len = NET_MIC_LEN(buf->data);
   27472:	bfb4      	ite	lt
   27474:	2608      	movlt	r6, #8
   27476:	2604      	movge	r6, #4
	if (IS_ENABLED(CONFIG_BT_MESH_PROXY) && proxy) {
   27478:	b363      	cbz	r3, 274d4 <bt_mesh_net_encrypt+0x8a>
	nonce[0] = 0x03;
   2747a:	2303      	movs	r3, #3
   2747c:	f8ad 3010 	strh.w	r3, [sp, #16]
	nonce[2] = pdu[2];
   27480:	f88d 8012 	strb.w	r8, [sp, #18]
	nonce[3] = pdu[3];
   27484:	f88d e013 	strb.w	lr, [sp, #19]
	nonce[4] = pdu[4];
   27488:	f88d c014 	strb.w	ip, [sp, #20]
	nonce[5] = pdu[5];
   2748c:	f88d 1015 	strb.w	r1, [sp, #21]
	nonce[6] = pdu[6];
   27490:	f88d 2016 	strb.w	r2, [sp, #22]
	nonce[7] = 0U;
   27494:	2300      	movs	r3, #0
	sys_put_be32(iv_index, &nonce[9]);
   27496:	f10d 0119 	add.w	r1, sp, #25
	nonce[7] = 0U;
   2749a:	f88d 3017 	strb.w	r3, [sp, #23]
	nonce[8] = 0U;
   2749e:	f88d 3018 	strb.w	r3, [sp, #24]
	sys_put_be32(iv_index, &nonce[9]);
   274a2:	f7ff ff6f 	bl	27384 <sys_put_be32>
	err = bt_ccm_encrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   274a6:	682a      	ldr	r2, [r5, #0]
   274a8:	88ab      	ldrh	r3, [r5, #4]
   274aa:	3207      	adds	r2, #7
   274ac:	2100      	movs	r1, #0
   274ae:	e9cd 1100 	strd	r1, r1, [sp]
   274b2:	e9cd 2602 	strd	r2, r6, [sp, #8]
   274b6:	3b07      	subs	r3, #7
   274b8:	a904      	add	r1, sp, #16
   274ba:	4638      	mov	r0, r7
   274bc:	f7fe fe9c 	bl	261f8 <bt_ccm_encrypt>
	if (!err) {
   274c0:	4604      	mov	r4, r0
   274c2:	b918      	cbnz	r0, 274cc <bt_mesh_net_encrypt+0x82>
		net_buf_simple_add(buf, mic_len);
   274c4:	4631      	mov	r1, r6
   274c6:	4628      	mov	r0, r5
   274c8:	f7f7 ff06 	bl	1f2d8 <net_buf_simple_add>
}
   274cc:	4620      	mov	r0, r4
   274ce:	b009      	add	sp, #36	; 0x24
   274d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	nonce[0] = 0x00;
   274d4:	f88d 3010 	strb.w	r3, [sp, #16]
	nonce[1] = pdu[1];
   274d8:	f88d 9011 	strb.w	r9, [sp, #17]
	nonce[2] = pdu[2];
   274dc:	f88d 8012 	strb.w	r8, [sp, #18]
	nonce[3] = pdu[3];
   274e0:	f88d e013 	strb.w	lr, [sp, #19]
	nonce[4] = pdu[4];
   274e4:	f88d c014 	strb.w	ip, [sp, #20]
	nonce[5] = pdu[5];
   274e8:	f88d 1015 	strb.w	r1, [sp, #21]
	nonce[6] = pdu[6];
   274ec:	f88d 2016 	strb.w	r2, [sp, #22]
   274f0:	e7d1      	b.n	27496 <bt_mesh_net_encrypt+0x4c>

000274f2 <bt_mesh_net_decrypt>:
{
   274f2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t mic_len = NET_MIC_LEN(buf->data);
   274f6:	680c      	ldr	r4, [r1, #0]
{
   274f8:	4606      	mov	r6, r0
   274fa:	4610      	mov	r0, r2
	u8_t mic_len = NET_MIC_LEN(buf->data);
   274fc:	f994 2001 	ldrsb.w	r2, [r4, #1]
   27500:	f894 9001 	ldrb.w	r9, [r4, #1]
   27504:	f894 8002 	ldrb.w	r8, [r4, #2]
   27508:	f894 e003 	ldrb.w	lr, [r4, #3]
   2750c:	f894 c004 	ldrb.w	ip, [r4, #4]
   27510:	2a00      	cmp	r2, #0
{
   27512:	460d      	mov	r5, r1
   27514:	79a2      	ldrb	r2, [r4, #6]
   27516:	7961      	ldrb	r1, [r4, #5]
   27518:	b089      	sub	sp, #36	; 0x24
	u8_t mic_len = NET_MIC_LEN(buf->data);
   2751a:	bfb4      	ite	lt
   2751c:	2708      	movlt	r7, #8
   2751e:	2704      	movge	r7, #4
	if (IS_ENABLED(CONFIG_BT_MESH_PROXY) && proxy) {
   27520:	b343      	cbz	r3, 27574 <bt_mesh_net_decrypt+0x82>
	nonce[0] = 0x03;
   27522:	2303      	movs	r3, #3
   27524:	f8ad 3010 	strh.w	r3, [sp, #16]
	nonce[2] = pdu[2];
   27528:	f88d 8012 	strb.w	r8, [sp, #18]
	nonce[3] = pdu[3];
   2752c:	f88d e013 	strb.w	lr, [sp, #19]
	nonce[4] = pdu[4];
   27530:	f88d c014 	strb.w	ip, [sp, #20]
	nonce[5] = pdu[5];
   27534:	f88d 1015 	strb.w	r1, [sp, #21]
	nonce[6] = pdu[6];
   27538:	f88d 2016 	strb.w	r2, [sp, #22]
	nonce[7] = 0U;
   2753c:	2300      	movs	r3, #0
	sys_put_be32(iv_index, &nonce[9]);
   2753e:	f10d 0119 	add.w	r1, sp, #25
	nonce[7] = 0U;
   27542:	f88d 3017 	strb.w	r3, [sp, #23]
	nonce[8] = 0U;
   27546:	f88d 3018 	strb.w	r3, [sp, #24]
	sys_put_be32(iv_index, &nonce[9]);
   2754a:	f7ff ff1b 	bl	27384 <sys_put_be32>
	buf->len -= mic_len;
   2754e:	88ab      	ldrh	r3, [r5, #4]
	return bt_ccm_decrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   27550:	682a      	ldr	r2, [r5, #0]
	buf->len -= mic_len;
   27552:	1bdb      	subs	r3, r3, r7
	return bt_ccm_decrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   27554:	3207      	adds	r2, #7
	buf->len -= mic_len;
   27556:	b29b      	uxth	r3, r3
	return bt_ccm_decrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   27558:	2100      	movs	r1, #0
   2755a:	e9cd 1100 	strd	r1, r1, [sp]
	buf->len -= mic_len;
   2755e:	80ab      	strh	r3, [r5, #4]
	return bt_ccm_decrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   27560:	e9cd 2702 	strd	r2, r7, [sp, #8]
   27564:	3b07      	subs	r3, #7
   27566:	a904      	add	r1, sp, #16
   27568:	4630      	mov	r0, r6
   2756a:	f7fe fe16 	bl	2619a <bt_ccm_decrypt>
}
   2756e:	b009      	add	sp, #36	; 0x24
   27570:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	nonce[0] = 0x00;
   27574:	f88d 3010 	strb.w	r3, [sp, #16]
	nonce[1] = pdu[1];
   27578:	f88d 9011 	strb.w	r9, [sp, #17]
	nonce[2] = pdu[2];
   2757c:	f88d 8012 	strb.w	r8, [sp, #18]
	nonce[3] = pdu[3];
   27580:	f88d e013 	strb.w	lr, [sp, #19]
	nonce[4] = pdu[4];
   27584:	f88d c014 	strb.w	ip, [sp, #20]
	nonce[5] = pdu[5];
   27588:	f88d 1015 	strb.w	r1, [sp, #21]
	nonce[6] = pdu[6];
   2758c:	f88d 2016 	strb.w	r2, [sp, #22]
   27590:	e7d5      	b.n	2753e <bt_mesh_net_decrypt+0x4c>

00027592 <bt_mesh_app_encrypt>:
{
   27592:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   27596:	b089      	sub	sp, #36	; 0x24
   27598:	4606      	mov	r6, r0
	sys_put_be32((seq_num | ((u32_t)aszmic << 31)), &nonce[1]);
   2759a:	9813      	ldr	r0, [sp, #76]	; 0x4c
{
   2759c:	f8bd 9044 	ldrh.w	r9, [sp, #68]	; 0x44
   275a0:	f8bd 7048 	ldrh.w	r7, [sp, #72]	; 0x48
   275a4:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
	if (dev_key) {
   275a8:	2900      	cmp	r1, #0
{
   275aa:	461c      	mov	r4, r3
	sys_put_be32((seq_num | ((u32_t)aszmic << 31)), &nonce[1]);
   275ac:	ea40 70c2 	orr.w	r0, r0, r2, lsl #31
		nonce[0] = 0x01;
   275b0:	bf14      	ite	ne
   275b2:	2302      	movne	r3, #2
   275b4:	2301      	moveq	r3, #1
	sys_put_be32((seq_num | ((u32_t)aszmic << 31)), &nonce[1]);
   275b6:	f10d 0111 	add.w	r1, sp, #17
{
   275ba:	4615      	mov	r5, r2
   275bc:	f88d 3010 	strb.w	r3, [sp, #16]
	sys_put_be32((seq_num | ((u32_t)aszmic << 31)), &nonce[1]);
   275c0:	f7ff fee0 	bl	27384 <sys_put_be32>
	dst[0] = val >> 8;
   275c4:	ea4f 2319 	mov.w	r3, r9, lsr #8
	sys_put_be32(iv_index, &nonce[9]);
   275c8:	9814      	ldr	r0, [sp, #80]	; 0x50
   275ca:	f88d 3015 	strb.w	r3, [sp, #21]
   275ce:	f10d 0119 	add.w	r1, sp, #25
   275d2:	0a3b      	lsrs	r3, r7, #8
   275d4:	f88d 3017 	strb.w	r3, [sp, #23]
	dst[1] = val;
   275d8:	f88d 7018 	strb.w	r7, [sp, #24]
   275dc:	f88d 9016 	strb.w	r9, [sp, #22]
   275e0:	f7ff fed0 	bl	27384 <sys_put_be32>
	err = bt_ccm_encrypt(key, nonce, buf->data, buf->len, ad, ad ? 16 : 0,
   275e4:	f1b8 0f00 	cmp.w	r8, #0
   275e8:	bf14      	ite	ne
   275ea:	2310      	movne	r3, #16
   275ec:	2300      	moveq	r3, #0
   275ee:	6822      	ldr	r2, [r4, #0]
   275f0:	2d00      	cmp	r5, #0
   275f2:	bf14      	ite	ne
   275f4:	2708      	movne	r7, #8
   275f6:	2704      	moveq	r7, #4
   275f8:	e9cd 8300 	strd	r8, r3, [sp]
   275fc:	e9cd 2702 	strd	r2, r7, [sp, #8]
   27600:	88a3      	ldrh	r3, [r4, #4]
   27602:	a904      	add	r1, sp, #16
   27604:	4630      	mov	r0, r6
   27606:	f7fe fdf7 	bl	261f8 <bt_ccm_encrypt>
	if (!err) {
   2760a:	4605      	mov	r5, r0
   2760c:	b918      	cbnz	r0, 27616 <bt_mesh_app_encrypt+0x84>
		net_buf_simple_add(buf, APP_MIC_LEN(aszmic));
   2760e:	4639      	mov	r1, r7
   27610:	4620      	mov	r0, r4
   27612:	f7f7 fe61 	bl	1f2d8 <net_buf_simple_add>
}
   27616:	4628      	mov	r0, r5
   27618:	b009      	add	sp, #36	; 0x24
   2761a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0002761e <bt_mesh_app_decrypt>:
{
   2761e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   27622:	b088      	sub	sp, #32
   27624:	4606      	mov	r6, r0
	sys_put_be32((seq_num | ((u32_t)aszmic << 31)), &nonce[1]);
   27626:	9814      	ldr	r0, [sp, #80]	; 0x50
{
   27628:	f8bd a048 	ldrh.w	sl, [sp, #72]	; 0x48
   2762c:	f8bd 904c 	ldrh.w	r9, [sp, #76]	; 0x4c
	if (dev_key) {
   27630:	2900      	cmp	r1, #0
{
   27632:	461c      	mov	r4, r3
   27634:	e9dd 7810 	ldrd	r7, r8, [sp, #64]	; 0x40
		nonce[0] = 0x01;
   27638:	bf14      	ite	ne
   2763a:	2302      	movne	r3, #2
   2763c:	2301      	moveq	r3, #1
	sys_put_be32((seq_num | ((u32_t)aszmic << 31)), &nonce[1]);
   2763e:	ea40 70c2 	orr.w	r0, r0, r2, lsl #31
   27642:	f10d 0111 	add.w	r1, sp, #17
{
   27646:	4615      	mov	r5, r2
   27648:	f88d 3010 	strb.w	r3, [sp, #16]
	sys_put_be32((seq_num | ((u32_t)aszmic << 31)), &nonce[1]);
   2764c:	f7ff fe9a 	bl	27384 <sys_put_be32>
	dst[0] = val >> 8;
   27650:	ea4f 231a 	mov.w	r3, sl, lsr #8
	sys_put_be32(iv_index, &nonce[9]);
   27654:	f10d 0119 	add.w	r1, sp, #25
   27658:	9815      	ldr	r0, [sp, #84]	; 0x54
   2765a:	f88d 3015 	strb.w	r3, [sp, #21]
   2765e:	ea4f 2319 	mov.w	r3, r9, lsr #8
   27662:	f88d 3017 	strb.w	r3, [sp, #23]
	dst[1] = val;
   27666:	f88d a016 	strb.w	sl, [sp, #22]
   2766a:	f88d 9018 	strb.w	r9, [sp, #24]
   2766e:	f7ff fe89 	bl	27384 <sys_put_be32>
	err = bt_ccm_decrypt(key, nonce, buf->data, buf->len, ad, ad ? 16 : 0,
   27672:	f1b8 0f00 	cmp.w	r8, #0
   27676:	683a      	ldr	r2, [r7, #0]
   27678:	bf14      	ite	ne
   2767a:	2310      	movne	r3, #16
   2767c:	2300      	moveq	r3, #0
   2767e:	2d00      	cmp	r5, #0
   27680:	bf14      	ite	ne
   27682:	2108      	movne	r1, #8
   27684:	2104      	moveq	r1, #4
   27686:	e9cd 2102 	strd	r2, r1, [sp, #8]
   2768a:	e9cd 8300 	strd	r8, r3, [sp]
   2768e:	6822      	ldr	r2, [r4, #0]
   27690:	88a3      	ldrh	r3, [r4, #4]
   27692:	a904      	add	r1, sp, #16
   27694:	4630      	mov	r0, r6
   27696:	f7fe fd80 	bl	2619a <bt_ccm_decrypt>
	if (!err) {
   2769a:	4605      	mov	r5, r0
   2769c:	b918      	cbnz	r0, 276a6 <bt_mesh_app_decrypt+0x88>
		net_buf_simple_add(out, buf->len);
   2769e:	88a1      	ldrh	r1, [r4, #4]
   276a0:	4638      	mov	r0, r7
   276a2:	f7f7 fe19 	bl	1f2d8 <net_buf_simple_add>
}
   276a6:	4628      	mov	r0, r5
   276a8:	b008      	add	sp, #32
   276aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000276ae <bt_mesh_prov_conf_salt>:
{
   276ae:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	const u8_t conf_salt_key[16] = { 0 };
   276b0:	2200      	movs	r2, #0
   276b2:	e9cd 2200 	strd	r2, r2, [sp]
   276b6:	e9cd 2202 	strd	r2, r2, [sp, #8]
{
   276ba:	460b      	mov	r3, r1
	return bt_mesh_aes_cmac_one(conf_salt_key, conf_inputs, 145, salt);
   276bc:	2291      	movs	r2, #145	; 0x91
   276be:	4601      	mov	r1, r0
   276c0:	4668      	mov	r0, sp
   276c2:	f7ff fe8a 	bl	273da <bt_mesh_aes_cmac_one>
}
   276c6:	b005      	add	sp, #20
   276c8:	f85d fb04 	ldr.w	pc, [sp], #4

000276cc <bt_mesh_prov_conf>:

int bt_mesh_prov_conf(const u8_t conf_key[16], const u8_t rand[16],
		      const u8_t auth[16], u8_t conf[16])
{
   276cc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct bt_mesh_sg sg[] = { { rand, 16 }, { auth, 16 } };
   276ce:	9100      	str	r1, [sp, #0]
   276d0:	2110      	movs	r1, #16
   276d2:	e9cd 1201 	strd	r1, r2, [sp, #4]
   276d6:	9103      	str	r1, [sp, #12]

	BT_DBG("ConfirmationKey %s", bt_hex(conf_key, 16));
	BT_DBG("RandomDevice %s", bt_hex(rand, 16));
	BT_DBG("AuthValue %s", bt_hex(auth, 16));

	return bt_mesh_aes_cmac(conf_key, sg, ARRAY_SIZE(sg), conf);
   276d8:	2202      	movs	r2, #2
   276da:	4669      	mov	r1, sp
   276dc:	f7ff fe5b 	bl	27396 <bt_mesh_aes_cmac>
}
   276e0:	b005      	add	sp, #20
   276e2:	f85d fb04 	ldr.w	pc, [sp], #4

000276e6 <bt_mesh_prov_decrypt>:

int bt_mesh_prov_decrypt(const u8_t key[16], u8_t nonce[13],
			 const u8_t data[25 + 8], u8_t out[25])
{
   276e6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_ccm_decrypt(key, nonce, data, 25, NULL, 0, out, 8);
   276e8:	2408      	movs	r4, #8
   276ea:	e9cd 3402 	strd	r3, r4, [sp, #8]
   276ee:	2300      	movs	r3, #0
   276f0:	e9cd 3300 	strd	r3, r3, [sp]
   276f4:	2319      	movs	r3, #25
   276f6:	f7fe fd50 	bl	2619a <bt_ccm_decrypt>
}
   276fa:	b004      	add	sp, #16
   276fc:	bd10      	pop	{r4, pc}

000276fe <bt_mesh_beacon_auth>:
}

int bt_mesh_beacon_auth(const u8_t beacon_key[16], u8_t flags,
			const u8_t net_id[8], u32_t iv_index,
			u8_t auth[8])
{
   276fe:	b530      	push	{r4, r5, lr}
   27700:	b089      	sub	sp, #36	; 0x24
   27702:	4604      	mov	r4, r0
   27704:	4608      	mov	r0, r1
   27706:	461d      	mov	r5, r3
   27708:	4611      	mov	r1, r2

	BT_DBG("BeaconKey %s", bt_hex(beacon_key, 16));
	BT_DBG("NetId %s", bt_hex(net_id, 8));
	BT_DBG("IV Index 0x%08x", iv_index);

	msg[0] = flags;
   2770a:	f88d 0000 	strb.w	r0, [sp]
	memcpy(&msg[1], net_id, 8);
   2770e:	2208      	movs	r2, #8
   27710:	f10d 0001 	add.w	r0, sp, #1
   27714:	f7fe fac8 	bl	25ca8 <memcpy>
	sys_put_be32(iv_index, &msg[9]);
   27718:	f10d 0109 	add.w	r1, sp, #9
   2771c:	4628      	mov	r0, r5
   2771e:	f7ff fe31 	bl	27384 <sys_put_be32>

	BT_DBG("BeaconMsg %s", bt_hex(msg, sizeof(msg)));

	err = bt_mesh_aes_cmac_one(beacon_key, msg, sizeof(msg), tmp);
   27722:	4620      	mov	r0, r4
   27724:	ab04      	add	r3, sp, #16
   27726:	220d      	movs	r2, #13
   27728:	4669      	mov	r1, sp
   2772a:	f7ff fe56 	bl	273da <bt_mesh_aes_cmac_one>
	if (!err) {
   2772e:	4604      	mov	r4, r0
   27730:	b920      	cbnz	r0, 2773c <bt_mesh_beacon_auth+0x3e>
		memcpy(auth, tmp, 8);
   27732:	980c      	ldr	r0, [sp, #48]	; 0x30
   27734:	2208      	movs	r2, #8
   27736:	a904      	add	r1, sp, #16
   27738:	f7fe fab6 	bl	25ca8 <memcpy>
	}

	return err;
}
   2773c:	4620      	mov	r0, r4
   2773e:	b009      	add	sp, #36	; 0x24
   27740:	bd30      	pop	{r4, r5, pc}

00027742 <k_uptime_get_32>:
{
   27742:	b510      	push	{r4, lr}
   27744:	f001 fe65 	bl	29412 <z_impl_k_uptime_ticks>
   27748:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   2774c:	fba0 2304 	umull	r2, r3, r0, r4
   27750:	fb04 3301 	mla	r3, r4, r1, r3
   27754:	0bd0      	lsrs	r0, r2, #15
}
   27756:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   2775a:	bd10      	pop	{r4, pc}

0002775c <bt_mesh_model_find_group>:
		.mod = *mod,
   2775c:	6800      	ldr	r0, [r0, #0]
		if (mod->groups[i] == addr) {
   2775e:	8a03      	ldrh	r3, [r0, #16]
   27760:	428b      	cmp	r3, r1
   27762:	d007      	beq.n	27774 <bt_mesh_model_find_group+0x18>
   27764:	8a43      	ldrh	r3, [r0, #18]
   27766:	428b      	cmp	r3, r1
   27768:	d106      	bne.n	27778 <bt_mesh_model_find_group+0x1c>
	for (i = 0; i < ARRAY_SIZE(mod->groups); i++) {
   2776a:	2301      	movs	r3, #1
			return &mod->groups[i];
   2776c:	3308      	adds	r3, #8
   2776e:	eb00 0043 	add.w	r0, r0, r3, lsl #1
	if (ctx->entry) {
   27772:	4770      	bx	lr
	for (i = 0; i < ARRAY_SIZE(mod->groups); i++) {
   27774:	2300      	movs	r3, #0
   27776:	e7f9      	b.n	2776c <bt_mesh_model_find_group+0x10>
	ctx->entry = model_group_get(mod, ctx->addr);
   27778:	2000      	movs	r0, #0
}
   2777a:	4770      	bx	lr

0002777c <bt_mesh_fixed_group_match>:
	switch (addr) {
   2777c:	f5a0 407f 	sub.w	r0, r0, #65280	; 0xff00
   27780:	38fc      	subs	r0, #252	; 0xfc
{
   27782:	b508      	push	{r3, lr}
   27784:	2803      	cmp	r0, #3
   27786:	d803      	bhi.n	27790 <bt_mesh_fixed_group_match+0x14>
   27788:	e8df f000 	tbb	[pc, r0]
   2778c:	100d0a04 	.word	0x100d0a04
		return true;
   27790:	2000      	movs	r0, #0
}
   27792:	bd08      	pop	{r3, pc}
		return (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED);
   27794:	f7ea ff02 	bl	1259c <bt_mesh_gatt_proxy_get>
		return (bt_mesh_friend_get() == BT_MESH_FRIEND_ENABLED);
   27798:	1e43      	subs	r3, r0, #1
   2779a:	4258      	negs	r0, r3
   2779c:	4158      	adcs	r0, r3
   2779e:	e7f8      	b.n	27792 <bt_mesh_fixed_group_match+0x16>
   277a0:	f7ea fdb6 	bl	12310 <bt_mesh_friend_get>
   277a4:	e7f8      	b.n	27798 <bt_mesh_fixed_group_match+0x1c>
		return (bt_mesh_relay_get() == BT_MESH_RELAY_ENABLED);
   277a6:	f7ea fda9 	bl	122fc <bt_mesh_relay_get>
   277aa:	e7f5      	b.n	27798 <bt_mesh_fixed_group_match+0x1c>
		return true;
   277ac:	2001      	movs	r0, #1
   277ae:	e7f0      	b.n	27792 <bt_mesh_fixed_group_match+0x16>

000277b0 <bt_mesh_model_msg_init>:
{
   277b0:	b538      	push	{r3, r4, r5, lr}
	if (!buf->__buf) {
   277b2:	6883      	ldr	r3, [r0, #8]
   277b4:	4604      	mov	r4, r0
   277b6:	b913      	cbnz	r3, 277be <bt_mesh_model_msg_init+0xe>
		buf->__buf = (u8_t *)buf + sizeof(*buf);
   277b8:	f100 030c 	add.w	r3, r0, #12
   277bc:	6083      	str	r3, [r0, #8]
	buf->data = buf->__buf + reserve_head;
   277be:	68a3      	ldr	r3, [r4, #8]
   277c0:	6023      	str	r3, [r4, #0]
	switch (BT_MESH_MODEL_OP_LEN(opcode)) {
   277c2:	29ff      	cmp	r1, #255	; 0xff
	buf->len = 0U;
   277c4:	f04f 0300 	mov.w	r3, #0
   277c8:	80a3      	strh	r3, [r4, #4]
   277ca:	d805      	bhi.n	277d8 <bt_mesh_model_msg_init+0x28>
		net_buf_simple_add_u8(msg, opcode);
   277cc:	4620      	mov	r0, r4
   277ce:	b2c9      	uxtb	r1, r1
}
   277d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_simple_add_u8(msg, opcode);
   277d4:	f001 bafb 	b.w	28dce <net_buf_simple_add_u8>
	switch (BT_MESH_MODEL_OP_LEN(opcode)) {
   277d8:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
   277dc:	b28d      	uxth	r5, r1
   277de:	d205      	bcs.n	277ec <bt_mesh_model_msg_init+0x3c>
		net_buf_simple_add_be16(msg, opcode);
   277e0:	4629      	mov	r1, r5
   277e2:	4620      	mov	r0, r4
}
   277e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_simple_add_be16(msg, opcode);
   277e8:	f001 bb01 	b.w	28dee <net_buf_simple_add_be16>
		net_buf_simple_add_u8(msg, ((opcode >> 16) & 0xff));
   277ec:	f3c1 4107 	ubfx	r1, r1, #16, #8
   277f0:	4620      	mov	r0, r4
   277f2:	f001 faec 	bl	28dce <net_buf_simple_add_u8>
		net_buf_simple_add_le16(msg, opcode & 0xffff);
   277f6:	4629      	mov	r1, r5
   277f8:	4620      	mov	r0, r4
}
   277fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_simple_add_le16(msg, opcode & 0xffff);
   277fe:	f001 baed 	b.w	28ddc <net_buf_simple_add_le16>

00027802 <bt_mesh_model_send>:
{
   27802:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27806:	b086      	sub	sp, #24
   27808:	4604      	mov	r4, r0
	struct bt_mesh_net_tx tx = {
   2780a:	2500      	movs	r5, #0
		.sub = bt_mesh_subnet_get(ctx->net_idx),
   2780c:	8808      	ldrh	r0, [r1, #0]
	struct bt_mesh_net_tx tx = {
   2780e:	9505      	str	r5, [sp, #20]
{
   27810:	460e      	mov	r6, r1
   27812:	4617      	mov	r7, r2
   27814:	4698      	mov	r8, r3
	struct bt_mesh_net_tx tx = {
   27816:	e9cd 5503 	strd	r5, r5, [sp, #12]
		.sub = bt_mesh_subnet_get(ctx->net_idx),
   2781a:	f7e5 f8e7 	bl	c9ec <bt_mesh_subnet_get>
	struct bt_mesh_net_tx tx = {
   2781e:	e9cd 0603 	strd	r0, r6, [sp, #12]
		.src = bt_mesh_model_elem(model)->addr,
   27822:	4620      	mov	r0, r4
   27824:	f7e8 f8c0 	bl	f9a8 <bt_mesh_model_elem>
	struct bt_mesh_net_tx tx = {
   27828:	8803      	ldrh	r3, [r0, #0]
   2782a:	f8ad 3014 	strh.w	r3, [sp, #20]
		.xmit = bt_mesh_net_transmit_get(),
   2782e:	f7ea fce9 	bl	12204 <bt_mesh_net_transmit_get>
	return model_send(model, &tx, false, msg, cb, cb_data);
   27832:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	struct bt_mesh_net_tx tx = {
   27834:	f88d 0016 	strb.w	r0, [sp, #22]
	return model_send(model, &tx, false, msg, cb, cb_data);
   27838:	e9cd 8300 	strd	r8, r3, [sp]
   2783c:	462a      	mov	r2, r5
   2783e:	463b      	mov	r3, r7
   27840:	a903      	add	r1, sp, #12
   27842:	4620      	mov	r0, r4
   27844:	f7e7 ff86 	bl	f754 <model_send>
}
   27848:	b006      	add	sp, #24
   2784a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002784e <bt_mesh_model_find_vnd>:
{
   2784e:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0U; i < elem->vnd_model_count; i++) {
   27850:	7947      	ldrb	r7, [r0, #5]
{
   27852:	4604      	mov	r4, r0
	for (i = 0U; i < elem->vnd_model_count; i++) {
   27854:	2300      	movs	r3, #0
   27856:	b2d8      	uxtb	r0, r3
   27858:	4287      	cmp	r7, r0
   2785a:	d801      	bhi.n	27860 <bt_mesh_model_find_vnd+0x12>
	return NULL;
   2785c:	2000      	movs	r0, #0
}
   2785e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (elem->vnd_models[i].vnd.company == company &&
   27860:	68e6      	ldr	r6, [r4, #12]
   27862:	015d      	lsls	r5, r3, #5
   27864:	eb06 1043 	add.w	r0, r6, r3, lsl #5
   27868:	5b75      	ldrh	r5, [r6, r5]
   2786a:	428d      	cmp	r5, r1
   2786c:	d102      	bne.n	27874 <bt_mesh_model_find_vnd+0x26>
   2786e:	8845      	ldrh	r5, [r0, #2]
   27870:	4295      	cmp	r5, r2
   27872:	d0f4      	beq.n	2785e <bt_mesh_model_find_vnd+0x10>
	for (i = 0U; i < elem->vnd_model_count; i++) {
   27874:	3301      	adds	r3, #1
   27876:	e7ee      	b.n	27856 <bt_mesh_model_find_vnd+0x8>

00027878 <bt_mesh_model_find>:
{
   27878:	b570      	push	{r4, r5, r6, lr}
	for (i = 0U; i < elem->model_count; i++) {
   2787a:	7906      	ldrb	r6, [r0, #4]
{
   2787c:	4602      	mov	r2, r0
	for (i = 0U; i < elem->model_count; i++) {
   2787e:	2300      	movs	r3, #0
   27880:	b2d8      	uxtb	r0, r3
   27882:	4286      	cmp	r6, r0
   27884:	d801      	bhi.n	2788a <bt_mesh_model_find+0x12>
	return NULL;
   27886:	2000      	movs	r0, #0
   27888:	e008      	b.n	2789c <bt_mesh_model_find+0x24>
		if (elem->models[i].id == id) {
   2788a:	6895      	ldr	r5, [r2, #8]
   2788c:	015c      	lsls	r4, r3, #5
   2788e:	eb05 1043 	add.w	r0, r5, r3, lsl #5
   27892:	5b2c      	ldrh	r4, [r5, r4]
   27894:	428c      	cmp	r4, r1
   27896:	f103 0301 	add.w	r3, r3, #1
   2789a:	d1f1      	bne.n	27880 <bt_mesh_model_find+0x8>
}
   2789c:	bd70      	pop	{r4, r5, r6, pc}

0002789e <bt_mesh_model_root>:
	while (mod->next) {
		mod = mod->next;
	}
#endif
	return mod;
}
   2789e:	4770      	bx	lr

000278a0 <bt_mesh_model_tree_walk>:
void bt_mesh_model_tree_walk(struct bt_mesh_model *root,
			     enum bt_mesh_walk (*cb)(struct bt_mesh_model *mod,
						     u32_t depth,
						     void *user_data),
			     void *user_data)
{
   278a0:	460b      	mov	r3, r1
	struct bt_mesh_model *m = root;
	u32_t depth = 0;

	do {
		if (cb(m, depth, user_data) == BT_MESH_WALK_STOP) {
   278a2:	2100      	movs	r1, #0
   278a4:	4718      	bx	r3

000278a6 <key_idx_pack>:

#include <sys/byteorder.h>

static inline void key_idx_pack(struct net_buf_simple *buf,
				u16_t idx1, u16_t idx2)
{
   278a6:	b538      	push	{r3, r4, r5, lr}
	net_buf_simple_add_le16(buf, idx1 | ((idx2 & 0x00f) << 12));
   278a8:	ea41 3102 	orr.w	r1, r1, r2, lsl #12
{
   278ac:	4605      	mov	r5, r0
   278ae:	4614      	mov	r4, r2
	net_buf_simple_add_le16(buf, idx1 | ((idx2 & 0x00f) << 12));
   278b0:	b289      	uxth	r1, r1
   278b2:	f001 fa93 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_u8(buf, idx2 >> 4);
   278b6:	f3c4 1107 	ubfx	r1, r4, #4, #8
   278ba:	4628      	mov	r0, r5
}
   278bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	net_buf_simple_add_u8(buf, idx2 >> 4);
   278c0:	f001 ba85 	b.w	28dce <net_buf_simple_add_u8>

000278c4 <heartbeat_pub_get>:
	hb_pub_send_status(model, ctx, STATUS_SUCCESS, NULL);
   278c4:	2300      	movs	r3, #0
   278c6:	461a      	mov	r2, r3
   278c8:	f7e8 bcb8 	b.w	1023c <hb_pub_send_status>

000278cc <key_idx_unpack>:

static inline void key_idx_unpack(struct net_buf_simple *buf,
				  u16_t *idx1, u16_t *idx2)
{
   278cc:	b430      	push	{r4, r5}
	*idx1 = sys_get_le16(&buf->data[0]) & 0xfff;
   278ce:	6804      	ldr	r4, [r0, #0]
	return ((u16_t)src[1] << 8) | src[0];
   278d0:	7865      	ldrb	r5, [r4, #1]
   278d2:	7823      	ldrb	r3, [r4, #0]
   278d4:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
   278d8:	f3c3 030b 	ubfx	r3, r3, #0, #12
   278dc:	800b      	strh	r3, [r1, #0]
   278de:	78a1      	ldrb	r1, [r4, #2]
   278e0:	7863      	ldrb	r3, [r4, #1]
	*idx2 = sys_get_le16(&buf->data[1]) >> 4;
   278e2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   278e6:	091b      	lsrs	r3, r3, #4
	net_buf_simple_pull(buf, 3);
}
   278e8:	bc30      	pop	{r4, r5}
	*idx2 = sys_get_le16(&buf->data[1]) >> 4;
   278ea:	8013      	strh	r3, [r2, #0]
	net_buf_simple_pull(buf, 3);
   278ec:	2103      	movs	r1, #3
   278ee:	f7f7 bcb1 	b.w	1f254 <net_buf_simple_pull>

000278f2 <mod_unbind.part.0>:
static u8_t mod_unbind(struct bt_mesh_model *model, u16_t key_idx, bool store)
   278f2:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   278f6:	4604      	mov	r4, r0
   278f8:	460e      	mov	r6, r1
   278fa:	4617      	mov	r7, r2
   278fc:	f100 050c 	add.w	r5, r0, #12
   27900:	f100 0910 	add.w	r9, r0, #16
		model->keys[i] = BT_MESH_KEY_UNUSED;
   27904:	f64f 7aff 	movw	sl, #65535	; 0xffff
			_mod_pub_set(model, BT_MESH_ADDR_UNASSIGNED,
   27908:	f04f 0800 	mov.w	r8, #0
		if (model->keys[i] != key_idx) {
   2790c:	f835 3b02 	ldrh.w	r3, [r5], #2
   27910:	42b3      	cmp	r3, r6
   27912:	d116      	bne.n	27942 <mod_unbind.part.0+0x50>
		model->keys[i] = BT_MESH_KEY_UNUSED;
   27914:	f825 ac02 	strh.w	sl, [r5, #-2]
		if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
   27918:	b117      	cbz	r7, 27920 <mod_unbind.part.0+0x2e>
			bt_mesh_store_mod_bind(model);
   2791a:	4620      	mov	r0, r4
   2791c:	f000 fa09 	bl	27d32 <bt_mesh_store_mod_bind>
		if (model->pub && model->pub->key == key_idx) {
   27920:	68a3      	ldr	r3, [r4, #8]
   27922:	b173      	cbz	r3, 27942 <mod_unbind.part.0+0x50>
   27924:	88db      	ldrh	r3, [r3, #6]
   27926:	f3c3 030b 	ubfx	r3, r3, #0, #12
   2792a:	42b3      	cmp	r3, r6
   2792c:	d109      	bne.n	27942 <mod_unbind.part.0+0x50>
			_mod_pub_set(model, BT_MESH_ADDR_UNASSIGNED,
   2792e:	2300      	movs	r3, #0
   27930:	e9cd 8702 	strd	r8, r7, [sp, #8]
   27934:	e9cd 8800 	strd	r8, r8, [sp]
   27938:	461a      	mov	r2, r3
   2793a:	4619      	mov	r1, r3
   2793c:	4620      	mov	r0, r4
   2793e:	f7e8 fb59 	bl	fff4 <_mod_pub_set>
	for (i = 0; i < ARRAY_SIZE(model->keys); i++) {
   27942:	454d      	cmp	r5, r9
   27944:	d1e2      	bne.n	2790c <mod_unbind.part.0+0x1a>
}
   27946:	2000      	movs	r0, #0
   27948:	b004      	add	sp, #16
   2794a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0002794e <friend_get>:
	send_friend_status(model, ctx);
   2794e:	f7e9 b83f 	b.w	109d0 <send_friend_status>

00027952 <create_mod_app_status.isra.0>:
static void create_mod_app_status(struct net_buf_simple *msg,
   27952:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   27956:	f89d 9020 	ldrb.w	r9, [sp, #32]
   2795a:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
   2795e:	4604      	mov	r4, r0
   27960:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(msg, OP_MOD_APP_STATUS);
   27962:	f248 013e 	movw	r1, #32830	; 0x803e
static void create_mod_app_status(struct net_buf_simple *msg,
   27966:	4617      	mov	r7, r2
   27968:	461e      	mov	r6, r3
	bt_mesh_model_msg_init(msg, OP_MOD_APP_STATUS);
   2796a:	f7ff ff21 	bl	277b0 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(msg, status);
   2796e:	4649      	mov	r1, r9
   27970:	4620      	mov	r0, r4
   27972:	f001 fa2c 	bl	28dce <net_buf_simple_add_u8>
	net_buf_simple_add_le16(msg, elem_addr);
   27976:	4639      	mov	r1, r7
   27978:	4620      	mov	r0, r4
   2797a:	f001 fa2f 	bl	28ddc <net_buf_simple_add_le16>
	net_buf_simple_add_le16(msg, app_idx);
   2797e:	4631      	mov	r1, r6
   27980:	4620      	mov	r0, r4
   27982:	f001 fa2b 	bl	28ddc <net_buf_simple_add_le16>
	if (vnd) {
   27986:	b14d      	cbz	r5, 2799c <create_mod_app_status.isra.0+0x4a>
		memcpy(net_buf_simple_add(msg, 4), mod_id, 4);
   27988:	2104      	movs	r1, #4
   2798a:	4620      	mov	r0, r4
   2798c:	f7f7 fca4 	bl	1f2d8 <net_buf_simple_add>
   27990:	2204      	movs	r2, #4
		memcpy(net_buf_simple_add(msg, 2), mod_id, 2);
   27992:	4641      	mov	r1, r8
}
   27994:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		memcpy(net_buf_simple_add(msg, 2), mod_id, 2);
   27998:	f7fe b986 	b.w	25ca8 <memcpy>
   2799c:	2102      	movs	r1, #2
   2799e:	4620      	mov	r0, r4
   279a0:	f7f7 fc9a 	bl	1f2d8 <net_buf_simple_add>
   279a4:	2202      	movs	r2, #2
   279a6:	e7f4      	b.n	27992 <create_mod_app_status.isra.0+0x40>

000279a8 <get_model>:
{
   279a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buf->len < 4) {
   279aa:	888b      	ldrh	r3, [r1, #4]
   279ac:	2b03      	cmp	r3, #3
{
   279ae:	4605      	mov	r5, r0
   279b0:	460c      	mov	r4, r1
   279b2:	4616      	mov	r6, r2
		id = net_buf_simple_pull_le16(buf);
   279b4:	4608      	mov	r0, r1
	if (buf->len < 4) {
   279b6:	d809      	bhi.n	279cc <get_model+0x24>
		id = net_buf_simple_pull_le16(buf);
   279b8:	f001 f9d5 	bl	28d66 <net_buf_simple_pull_le16>
		*vnd = false;
   279bc:	2300      	movs	r3, #0
		id = net_buf_simple_pull_le16(buf);
   279be:	4601      	mov	r1, r0
		*vnd = false;
   279c0:	7033      	strb	r3, [r6, #0]
		return bt_mesh_model_find(elem, id);
   279c2:	4628      	mov	r0, r5
}
   279c4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		return bt_mesh_model_find(elem, id);
   279c8:	f7ff bf56 	b.w	27878 <bt_mesh_model_find>
		company = net_buf_simple_pull_le16(buf);
   279cc:	f001 f9cb 	bl	28d66 <net_buf_simple_pull_le16>
   279d0:	4607      	mov	r7, r0
		id = net_buf_simple_pull_le16(buf);
   279d2:	4620      	mov	r0, r4
   279d4:	f001 f9c7 	bl	28d66 <net_buf_simple_pull_le16>
		*vnd = true;
   279d8:	2301      	movs	r3, #1
		id = net_buf_simple_pull_le16(buf);
   279da:	4602      	mov	r2, r0
		*vnd = true;
   279dc:	7033      	strb	r3, [r6, #0]
		return bt_mesh_model_find_vnd(elem, company, id);
   279de:	4639      	mov	r1, r7
   279e0:	4628      	mov	r0, r5
}
   279e2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		return bt_mesh_model_find_vnd(elem, company, id);
   279e6:	f7ff bf32 	b.w	2784e <bt_mesh_model_find_vnd>

000279ea <hb_pwr2.constprop.0>:
	if (!val) {
   279ea:	b158      	cbz	r0, 27a04 <hb_pwr2.constprop.0+0x1a>
	} else if (val == 0xff || val == 0x11) {
   279ec:	28ff      	cmp	r0, #255	; 0xff
   279ee:	d007      	beq.n	27a00 <hb_pwr2.constprop.0+0x16>
   279f0:	2811      	cmp	r0, #17
   279f2:	d005      	beq.n	27a00 <hb_pwr2.constprop.0+0x16>
		return (1 << (val - sub));
   279f4:	2301      	movs	r3, #1
   279f6:	3801      	subs	r0, #1
   279f8:	fa03 f000 	lsl.w	r0, r3, r0
   279fc:	b280      	uxth	r0, r0
   279fe:	4770      	bx	lr
		return 0xffff;
   27a00:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
   27a04:	4770      	bx	lr

00027a06 <va_store>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   27a06:	3014      	adds	r0, #20
   27a08:	f3bf 8f5b 	dmb	ish
   27a0c:	e850 3f00 	ldrex	r3, [r0]
   27a10:	f043 0301 	orr.w	r3, r3, #1
   27a14:	e840 3200 	strex	r2, r3, [r0]
   27a18:	2a00      	cmp	r2, #0
   27a1a:	d1f7      	bne.n	27a0c <va_store+0x6>
   27a1c:	f3bf 8f5b 	dmb	ish
		bt_mesh_store_label();
   27a20:	f000 b99c 	b.w	27d5c <bt_mesh_store_label>

00027a24 <_mod_unbind>:
{
   27a24:	b570      	push	{r4, r5, r6, lr}
   27a26:	9e04      	ldr	r6, [sp, #16]
	mod_unbind(mod, data->app_idx, data->store);
   27a28:	8835      	ldrh	r5, [r6, #0]
{
   27a2a:	4604      	mov	r4, r0
	if (!app_key_is_valid(key_idx)) {
   27a2c:	4628      	mov	r0, r5
   27a2e:	f7e8 fac3 	bl	ffb8 <app_key_is_valid>
   27a32:	b130      	cbz	r0, 27a42 <_mod_unbind+0x1e>
   27a34:	78b2      	ldrb	r2, [r6, #2]
   27a36:	4629      	mov	r1, r5
   27a38:	4620      	mov	r0, r4
}
   27a3a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   27a3e:	f7ff bf58 	b.w	278f2 <mod_unbind.part.0>
   27a42:	bd70      	pop	{r4, r5, r6, pc}

00027a44 <heartbeat_sub_get>:
	hb_sub_send_status(model, ctx, STATUS_SUCCESS);
   27a44:	f7ea b948 	b.w	11cd8 <hb_sub_send_status.constprop.0>

00027a48 <app_key_set>:
{
   27a48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   27a4c:	4680      	mov	r8, r0
   27a4e:	460f      	mov	r7, r1
   27a50:	4616      	mov	r6, r2
   27a52:	4699      	mov	r9, r3
	sub = bt_mesh_subnet_get(net_idx);
   27a54:	f7e4 ffca 	bl	c9ec <bt_mesh_subnet_get>
	if (!sub) {
   27a58:	4605      	mov	r5, r0
   27a5a:	2800      	cmp	r0, #0
   27a5c:	d039      	beq.n	27ad2 <app_key_set+0x8a>
	key = bt_mesh_app_key_find(app_idx);
   27a5e:	4638      	mov	r0, r7
   27a60:	f7e6 fec8 	bl	e7f4 <bt_mesh_app_key_find>
   27a64:	4604      	mov	r4, r0
	if (update) {
   27a66:	f1b9 0f00 	cmp.w	r9, #0
   27a6a:	d024      	beq.n	27ab6 <app_key_set+0x6e>
		if (!key) {
   27a6c:	2800      	cmp	r0, #0
   27a6e:	d047      	beq.n	27b00 <app_key_set+0xb8>
		if (key->net_idx != net_idx) {
   27a70:	8803      	ldrh	r3, [r0, #0]
   27a72:	4543      	cmp	r3, r8
   27a74:	d146      	bne.n	27b04 <app_key_set+0xbc>
		if (sub->kr_phase != BT_MESH_KR_PHASE_1) {
   27a76:	7feb      	ldrb	r3, [r5, #31]
   27a78:	2b01      	cmp	r3, #1
   27a7a:	d002      	beq.n	27a82 <app_key_set+0x3a>
			return STATUS_CANNOT_UPDATE;
   27a7c:	200b      	movs	r0, #11
}
   27a7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (key->updated) {
   27a82:	7902      	ldrb	r2, [r0, #4]
   27a84:	b142      	cbz	r2, 27a98 <app_key_set+0x50>
			if (memcmp(keys->val, val, 16)) {
   27a86:	2210      	movs	r2, #16
   27a88:	4631      	mov	r1, r6
   27a8a:	3017      	adds	r0, #23
   27a8c:	f7fe f8fc 	bl	25c88 <memcmp>
   27a90:	2800      	cmp	r0, #0
   27a92:	d1f3      	bne.n	27a7c <app_key_set+0x34>
				return STATUS_SUCCESS;
   27a94:	2000      	movs	r0, #0
   27a96:	e7f2      	b.n	27a7e <app_key_set+0x36>
		keys = &key->keys[1];
   27a98:	f100 0a16 	add.w	sl, r0, #22
		key->updated = true;
   27a9c:	7103      	strb	r3, [r0, #4]
	return bt_mesh_k4(app_key, app_id);
   27a9e:	4651      	mov	r1, sl
   27aa0:	4630      	mov	r0, r6
   27aa2:	f7e7 fd65 	bl	f570 <bt_mesh_k4>
	if (bt_mesh_app_id(val, &keys->id)) {
   27aa6:	b1f0      	cbz	r0, 27ae6 <app_key_set+0x9e>
		if (update) {
   27aa8:	f1b9 0f00 	cmp.w	r9, #0
   27aac:	d001      	beq.n	27ab2 <app_key_set+0x6a>
			key->updated = false;
   27aae:	2300      	movs	r3, #0
   27ab0:	7123      	strb	r3, [r4, #4]
		return STATUS_STORAGE_FAIL;
   27ab2:	2009      	movs	r0, #9
   27ab4:	e7e3      	b.n	27a7e <app_key_set+0x36>
		if (key) {
   27ab6:	b170      	cbz	r0, 27ad6 <app_key_set+0x8e>
			if (key->net_idx == net_idx &&
   27ab8:	8805      	ldrh	r5, [r0, #0]
   27aba:	4545      	cmp	r5, r8
   27abc:	d109      	bne.n	27ad2 <app_key_set+0x8a>
			    !memcmp(key->keys[0].val, val, 16)) {
   27abe:	2210      	movs	r2, #16
   27ac0:	4631      	mov	r1, r6
   27ac2:	3006      	adds	r0, #6
   27ac4:	f7fe f8e0 	bl	25c88 <memcmp>
			if (key->net_idx == net_idx &&
   27ac8:	2800      	cmp	r0, #0
   27aca:	d0e3      	beq.n	27a94 <app_key_set+0x4c>
			if (key->net_idx == net_idx) {
   27acc:	8823      	ldrh	r3, [r4, #0]
   27ace:	42ab      	cmp	r3, r5
   27ad0:	d01a      	beq.n	27b08 <app_key_set+0xc0>
				return STATUS_INVALID_NETKEY;
   27ad2:	2004      	movs	r0, #4
   27ad4:	e7d3      	b.n	27a7e <app_key_set+0x36>
		key = bt_mesh_app_key_alloc(app_idx);
   27ad6:	4638      	mov	r0, r7
   27ad8:	f7ea fa14 	bl	11f04 <bt_mesh_app_key_alloc>
		if (!key) {
   27adc:	4604      	mov	r4, r0
   27ade:	b1a8      	cbz	r0, 27b0c <app_key_set+0xc4>
		keys = &key->keys[0];
   27ae0:	f100 0a05 	add.w	sl, r0, #5
   27ae4:	e7db      	b.n	27a9e <app_key_set+0x56>
	key->net_idx = net_idx;
   27ae6:	f8a4 8000 	strh.w	r8, [r4]
	key->app_idx = app_idx;
   27aea:	8067      	strh	r7, [r4, #2]
	memcpy(keys->val, val, 16);
   27aec:	2210      	movs	r2, #16
   27aee:	4631      	mov	r1, r6
   27af0:	f10a 0001 	add.w	r0, sl, #1
   27af4:	f7fe f8d8 	bl	25ca8 <memcpy>
		bt_mesh_store_app_key(key);
   27af8:	4620      	mov	r0, r4
   27afa:	f000 f8a1 	bl	27c40 <bt_mesh_store_app_key>
	return STATUS_SUCCESS;
   27afe:	e7c9      	b.n	27a94 <app_key_set+0x4c>
			return STATUS_INVALID_APPKEY;
   27b00:	2003      	movs	r0, #3
   27b02:	e7bc      	b.n	27a7e <app_key_set+0x36>
			return STATUS_INVALID_BINDING;
   27b04:	2011      	movs	r0, #17
   27b06:	e7ba      	b.n	27a7e <app_key_set+0x36>
				return STATUS_IDX_ALREADY_STORED;
   27b08:	2006      	movs	r0, #6
   27b0a:	e7b8      	b.n	27a7e <app_key_set+0x36>
			return STATUS_INSUFF_RESOURCES;
   27b0c:	2005      	movs	r0, #5
   27b0e:	e7b6      	b.n	27a7e <app_key_set+0x36>

00027b10 <gatt_proxy_get>:
	send_gatt_proxy_status(model, ctx);
   27b10:	f7ea bd4e 	b.w	125b0 <send_gatt_proxy_status>

00027b14 <mod_sub_clear_visitor>:
{
   27b14:	b508      	push	{r3, lr}
	mod_sub_list_clear(mod);
   27b16:	f7ea fe69 	bl	127ec <mod_sub_list_clear>
}
   27b1a:	2001      	movs	r0, #1
   27b1c:	bd08      	pop	{r3, pc}

00027b1e <mod_reset>:
{
   27b1e:	b570      	push	{r4, r5, r6, lr}
   27b20:	4604      	mov	r4, r0
   27b22:	4615      	mov	r5, r2
	clear_count = mod_sub_list_clear(mod);
   27b24:	f7ea fe62 	bl	127ec <mod_sub_list_clear>
		if (clear_count) {
   27b28:	b110      	cbz	r0, 27b30 <mod_reset+0x12>
			bt_mesh_store_mod_sub(mod);
   27b2a:	4620      	mov	r0, r4
   27b2c:	f000 f908 	bl	27d40 <bt_mesh_store_mod_sub>
		bt_mesh_model_data_store(mod, vnd, NULL, 0);
   27b30:	2300      	movs	r3, #0
   27b32:	461a      	mov	r2, r3
   27b34:	4629      	mov	r1, r5
   27b36:	4620      	mov	r0, r4
   27b38:	f7ec f952 	bl	13de0 <bt_mesh_model_data_store>
	if (mod->cb && mod->cb->reset) {
   27b3c:	69a3      	ldr	r3, [r4, #24]
   27b3e:	b12b      	cbz	r3, 27b4c <mod_reset+0x2e>
   27b40:	68db      	ldr	r3, [r3, #12]
   27b42:	b11b      	cbz	r3, 27b4c <mod_reset+0x2e>
		mod->cb->reset(mod);
   27b44:	4620      	mov	r0, r4
}
   27b46:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		mod->cb->reset(mod);
   27b4a:	4718      	bx	r3
}
   27b4c:	bd70      	pop	{r4, r5, r6, pc}

00027b4e <atomic_or>:
{
   27b4e:	4603      	mov	r3, r0
}
   27b50:	f3bf 8f5b 	dmb	ish
   27b54:	e853 0f00 	ldrex	r0, [r3]
   27b58:	ea40 0201 	orr.w	r2, r0, r1
   27b5c:	e843 2c00 	strex	ip, r2, [r3]
   27b60:	f1bc 0f00 	cmp.w	ip, #0
   27b64:	d1f6      	bne.n	27b54 <atomic_or+0x6>
   27b66:	f3bf 8f5b 	dmb	ish
   27b6a:	4770      	bx	lr

00027b6c <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   27b6c:	f3bf 8f5b 	dmb	ish
   27b70:	6800      	ldr	r0, [r0, #0]
   27b72:	f3bf 8f5b 	dmb	ish
}
   27b76:	4770      	bx	lr

00027b78 <vnd_mod_set>:
{
   27b78:	b507      	push	{r0, r1, r2, lr}
	return mod_set(true, name, len_rd, read_cb, cb_arg);
   27b7a:	9300      	str	r3, [sp, #0]
   27b7c:	4613      	mov	r3, r2
   27b7e:	460a      	mov	r2, r1
   27b80:	4601      	mov	r1, r0
   27b82:	2001      	movs	r0, #1
   27b84:	f7eb fa30 	bl	12fe8 <mod_set>
}
   27b88:	b003      	add	sp, #12
   27b8a:	f85d fb04 	ldr.w	pc, [sp], #4

00027b8e <sig_mod_set>:
{
   27b8e:	b507      	push	{r0, r1, r2, lr}
	return mod_set(false, name, len_rd, read_cb, cb_arg);
   27b90:	9300      	str	r3, [sp, #0]
   27b92:	4613      	mov	r3, r2
   27b94:	460a      	mov	r2, r1
   27b96:	4601      	mov	r1, r0
   27b98:	2000      	movs	r0, #0
   27b9a:	f7eb fa25 	bl	12fe8 <mod_set>
}
   27b9e:	b003      	add	sp, #12
   27ba0:	f85d fb04 	ldr.w	pc, [sp], #4

00027ba4 <atomic_test_and_clear_bit>:
{
   27ba4:	b500      	push	{lr}
	atomic_val_t mask = ATOMIC_MASK(bit);
   27ba6:	2301      	movs	r3, #1
   27ba8:	fa03 f101 	lsl.w	r1, r3, r1
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   27bac:	43ca      	mvns	r2, r1
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   27bae:	f3bf 8f5b 	dmb	ish
   27bb2:	e850 3f00 	ldrex	r3, [r0]
   27bb6:	ea03 0c02 	and.w	ip, r3, r2
   27bba:	e840 ce00 	strex	lr, ip, [r0]
   27bbe:	f1be 0f00 	cmp.w	lr, #0
   27bc2:	d1f6      	bne.n	27bb2 <atomic_test_and_clear_bit+0xe>
   27bc4:	f3bf 8f5b 	dmb	ish
	return (old & mask) != 0;
   27bc8:	420b      	tst	r3, r1
}
   27bca:	bf14      	ite	ne
   27bcc:	2001      	movne	r0, #1
   27bce:	2000      	moveq	r0, #0
   27bd0:	f85d fb04 	ldr.w	pc, [sp], #4

00027bd4 <bt_mesh_store_net>:
	schedule_store(BT_MESH_NET_PENDING);
   27bd4:	2008      	movs	r0, #8
   27bd6:	f7eb bf9b 	b.w	13b10 <schedule_store>

00027bda <bt_mesh_store_iv>:
{
   27bda:	b510      	push	{r4, lr}
   27bdc:	4604      	mov	r4, r0
	schedule_store(BT_MESH_IV_PENDING);
   27bde:	2009      	movs	r0, #9
   27be0:	f7eb ff96 	bl	13b10 <schedule_store>
	if (!only_duration) {
   27be4:	b924      	cbnz	r4, 27bf0 <bt_mesh_store_iv+0x16>
}
   27be6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		schedule_store(BT_MESH_SEQ_PENDING);
   27bea:	200a      	movs	r0, #10
   27bec:	f7eb bf90 	b.w	13b10 <schedule_store>
}
   27bf0:	bd10      	pop	{r4, pc}

00027bf2 <bt_mesh_store_rpl>:
	entry->store = true;
   27bf2:	2301      	movs	r3, #1
   27bf4:	70c3      	strb	r3, [r0, #3]
	schedule_store(BT_MESH_RPL_PENDING);
   27bf6:	2006      	movs	r0, #6
   27bf8:	f7eb bf8a 	b.w	13b10 <schedule_store>

00027bfc <bt_mesh_store_subnet>:
{
   27bfc:	b513      	push	{r0, r1, r4, lr}
	update = key_update_find(false, sub->net_idx, &free_slot);
   27bfe:	8b81      	ldrh	r1, [r0, #28]
{
   27c00:	4604      	mov	r4, r0
	update = key_update_find(false, sub->net_idx, &free_slot);
   27c02:	aa01      	add	r2, sp, #4
   27c04:	2000      	movs	r0, #0
   27c06:	f7ea ff1f 	bl	12a48 <key_update_find>
	if (update) {
   27c0a:	b138      	cbz	r0, 27c1c <bt_mesh_store_subnet+0x20>
		update->clear = 0U;
   27c0c:	7843      	ldrb	r3, [r0, #1]
   27c0e:	f36f 1386 	bfc	r3, #6, #1
   27c12:	7043      	strb	r3, [r0, #1]
	schedule_store(BT_MESH_KEYS_PENDING);
   27c14:	2007      	movs	r0, #7
   27c16:	f7eb ff7b 	bl	13b10 <schedule_store>
   27c1a:	e004      	b.n	27c26 <bt_mesh_store_subnet+0x2a>
	if (!free_slot) {
   27c1c:	9a01      	ldr	r2, [sp, #4]
   27c1e:	b922      	cbnz	r2, 27c2a <bt_mesh_store_subnet+0x2e>
		store_net_key(sub);
   27c20:	4620      	mov	r0, r4
   27c22:	f7eb fb71 	bl	13308 <store_net_key>
}
   27c26:	b002      	add	sp, #8
   27c28:	bd10      	pop	{r4, pc}
	free_slot->key_idx = sub->net_idx;
   27c2a:	8ba3      	ldrh	r3, [r4, #28]
   27c2c:	8811      	ldrh	r1, [r2, #0]
   27c2e:	f3c3 030b 	ubfx	r3, r3, #0, #12
   27c32:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   27c36:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
   27c3a:	430b      	orrs	r3, r1
   27c3c:	8013      	strh	r3, [r2, #0]
   27c3e:	e7e9      	b.n	27c14 <bt_mesh_store_subnet+0x18>

00027c40 <bt_mesh_store_app_key>:
{
   27c40:	b513      	push	{r0, r1, r4, lr}
	update = key_update_find(true, key->app_idx, &free_slot);
   27c42:	8841      	ldrh	r1, [r0, #2]
{
   27c44:	4604      	mov	r4, r0
	update = key_update_find(true, key->app_idx, &free_slot);
   27c46:	aa01      	add	r2, sp, #4
   27c48:	2001      	movs	r0, #1
   27c4a:	f7ea fefd 	bl	12a48 <key_update_find>
	if (update) {
   27c4e:	b138      	cbz	r0, 27c60 <bt_mesh_store_app_key+0x20>
		update->clear = 0U;
   27c50:	7843      	ldrb	r3, [r0, #1]
   27c52:	f36f 1386 	bfc	r3, #6, #1
   27c56:	7043      	strb	r3, [r0, #1]
	schedule_store(BT_MESH_KEYS_PENDING);
   27c58:	2007      	movs	r0, #7
   27c5a:	f7eb ff59 	bl	13b10 <schedule_store>
   27c5e:	e004      	b.n	27c6a <bt_mesh_store_app_key+0x2a>
	if (!free_slot) {
   27c60:	9a01      	ldr	r2, [sp, #4]
   27c62:	b922      	cbnz	r2, 27c6e <bt_mesh_store_app_key+0x2e>
		store_app_key(key);
   27c64:	4620      	mov	r0, r4
   27c66:	f7eb f983 	bl	12f70 <store_app_key>
}
   27c6a:	b002      	add	sp, #8
   27c6c:	bd10      	pop	{r4, pc}
	free_slot->key_idx = key->app_idx;
   27c6e:	8863      	ldrh	r3, [r4, #2]
   27c70:	8811      	ldrh	r1, [r2, #0]
   27c72:	f3c3 030b 	ubfx	r3, r3, #0, #12
   27c76:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
   27c7a:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
   27c7e:	430b      	orrs	r3, r1
   27c80:	8013      	strh	r3, [r2, #0]
   27c82:	e7e9      	b.n	27c58 <bt_mesh_store_app_key+0x18>

00027c84 <bt_mesh_store_hb_pub>:
	schedule_store(BT_MESH_HB_PUB_PENDING);
   27c84:	200b      	movs	r0, #11
   27c86:	f7eb bf43 	b.w	13b10 <schedule_store>

00027c8a <bt_mesh_store_cfg>:
	schedule_store(BT_MESH_CFG_PENDING);
   27c8a:	200c      	movs	r0, #12
   27c8c:	f7eb bf40 	b.w	13b10 <schedule_store>

00027c90 <bt_mesh_clear_net>:
{
   27c90:	b508      	push	{r3, lr}
	schedule_store(BT_MESH_NET_PENDING);
   27c92:	2008      	movs	r0, #8
   27c94:	f7eb ff3c 	bl	13b10 <schedule_store>
	schedule_store(BT_MESH_IV_PENDING);
   27c98:	2009      	movs	r0, #9
   27c9a:	f7eb ff39 	bl	13b10 <schedule_store>
}
   27c9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	schedule_store(BT_MESH_CFG_PENDING);
   27ca2:	200c      	movs	r0, #12
   27ca4:	f7eb bf34 	b.w	13b10 <schedule_store>

00027ca8 <bt_mesh_clear_subnet>:
{
   27ca8:	b513      	push	{r0, r1, r4, lr}
	update = key_update_find(false, sub->net_idx, &free_slot);
   27caa:	8b81      	ldrh	r1, [r0, #28]
{
   27cac:	4604      	mov	r4, r0
	update = key_update_find(false, sub->net_idx, &free_slot);
   27cae:	aa01      	add	r2, sp, #4
   27cb0:	2000      	movs	r0, #0
   27cb2:	f7ea fec9 	bl	12a48 <key_update_find>
	if (update) {
   27cb6:	b138      	cbz	r0, 27cc8 <bt_mesh_clear_subnet+0x20>
		update->clear = 1U;
   27cb8:	7843      	ldrb	r3, [r0, #1]
   27cba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   27cbe:	7043      	strb	r3, [r0, #1]
	schedule_store(BT_MESH_KEYS_PENDING);
   27cc0:	2007      	movs	r0, #7
   27cc2:	f7eb ff25 	bl	13b10 <schedule_store>
   27cc6:	e004      	b.n	27cd2 <bt_mesh_clear_subnet+0x2a>
	if (!free_slot) {
   27cc8:	9b01      	ldr	r3, [sp, #4]
   27cca:	8ba0      	ldrh	r0, [r4, #28]
   27ccc:	b91b      	cbnz	r3, 27cd6 <bt_mesh_clear_subnet+0x2e>
		clear_net_key(sub->net_idx);
   27cce:	f7eb fb53 	bl	13378 <clear_net_key>
}
   27cd2:	b002      	add	sp, #8
   27cd4:	bd10      	pop	{r4, pc}
	free_slot->key_idx = sub->net_idx;
   27cd6:	881a      	ldrh	r2, [r3, #0]
   27cd8:	f3c0 000b 	ubfx	r0, r0, #0, #12
   27cdc:	f440 40a0 	orr.w	r0, r0, #20480	; 0x5000
   27ce0:	f402 4200 	and.w	r2, r2, #32768	; 0x8000
   27ce4:	4310      	orrs	r0, r2
   27ce6:	8018      	strh	r0, [r3, #0]
   27ce8:	e7ea      	b.n	27cc0 <bt_mesh_clear_subnet+0x18>

00027cea <bt_mesh_clear_app_key>:
{
   27cea:	b513      	push	{r0, r1, r4, lr}
	update = key_update_find(true, key->app_idx, &free_slot);
   27cec:	8841      	ldrh	r1, [r0, #2]
{
   27cee:	4604      	mov	r4, r0
	update = key_update_find(true, key->app_idx, &free_slot);
   27cf0:	aa01      	add	r2, sp, #4
   27cf2:	2001      	movs	r0, #1
   27cf4:	f7ea fea8 	bl	12a48 <key_update_find>
	if (update) {
   27cf8:	b138      	cbz	r0, 27d0a <bt_mesh_clear_app_key+0x20>
		update->clear = 1U;
   27cfa:	7843      	ldrb	r3, [r0, #1]
   27cfc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   27d00:	7043      	strb	r3, [r0, #1]
	schedule_store(BT_MESH_KEYS_PENDING);
   27d02:	2007      	movs	r0, #7
   27d04:	f7eb ff04 	bl	13b10 <schedule_store>
   27d08:	e004      	b.n	27d14 <bt_mesh_clear_app_key+0x2a>
	if (!free_slot) {
   27d0a:	9b01      	ldr	r3, [sp, #4]
   27d0c:	8860      	ldrh	r0, [r4, #2]
   27d0e:	b91b      	cbnz	r3, 27d18 <bt_mesh_clear_app_key+0x2e>
		clear_app_key(key->app_idx);
   27d10:	f7eb fb54 	bl	133bc <clear_app_key>
}
   27d14:	b002      	add	sp, #8
   27d16:	bd10      	pop	{r4, pc}
	free_slot->key_idx = key->app_idx;
   27d18:	881a      	ldrh	r2, [r3, #0]
   27d1a:	f3c0 000b 	ubfx	r0, r0, #0, #12
   27d1e:	f440 40e0 	orr.w	r0, r0, #28672	; 0x7000
   27d22:	f402 4200 	and.w	r2, r2, #32768	; 0x8000
   27d26:	4310      	orrs	r0, r2
   27d28:	8018      	strh	r0, [r3, #0]
   27d2a:	e7ea      	b.n	27d02 <bt_mesh_clear_app_key+0x18>

00027d2c <bt_mesh_clear_rpl>:
	schedule_store(BT_MESH_RPL_PENDING);
   27d2c:	2006      	movs	r0, #6
   27d2e:	f7eb beef 	b.w	13b10 <schedule_store>

00027d32 <bt_mesh_store_mod_bind>:
	mod->flags |= BT_MESH_MOD_BIND_PENDING;
   27d32:	88c3      	ldrh	r3, [r0, #6]
   27d34:	f043 0301 	orr.w	r3, r3, #1
   27d38:	80c3      	strh	r3, [r0, #6]
	schedule_store(BT_MESH_MOD_PENDING);
   27d3a:	200d      	movs	r0, #13
   27d3c:	f7eb bee8 	b.w	13b10 <schedule_store>

00027d40 <bt_mesh_store_mod_sub>:
	mod->flags |= BT_MESH_MOD_SUB_PENDING;
   27d40:	88c3      	ldrh	r3, [r0, #6]
   27d42:	f043 0302 	orr.w	r3, r3, #2
   27d46:	80c3      	strh	r3, [r0, #6]
	schedule_store(BT_MESH_MOD_PENDING);
   27d48:	200d      	movs	r0, #13
   27d4a:	f7eb bee1 	b.w	13b10 <schedule_store>

00027d4e <bt_mesh_store_mod_pub>:
	mod->flags |= BT_MESH_MOD_PUB_PENDING;
   27d4e:	88c3      	ldrh	r3, [r0, #6]
   27d50:	f043 0304 	orr.w	r3, r3, #4
   27d54:	80c3      	strh	r3, [r0, #6]
	schedule_store(BT_MESH_MOD_PENDING);
   27d56:	200d      	movs	r0, #13
   27d58:	f7eb beda 	b.w	13b10 <schedule_store>

00027d5c <bt_mesh_store_label>:
	schedule_store(BT_MESH_VA_PENDING);
   27d5c:	200e      	movs	r0, #14
   27d5e:	f7eb bed7 	b.w	13b10 <schedule_store>

00027d62 <friend_clear_sent>:
			      K_SECONDS(frnd->clear.repeat_sec));
   27d62:	f8b1 305a 	ldrh.w	r3, [r1, #90]	; 0x5a
{
   27d66:	b510      	push	{r4, lr}
   27d68:	460c      	mov	r4, r1
	k_delayed_work_submit(&frnd->clear.timer,
   27d6a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   27d6e:	4359      	muls	r1, r3
   27d70:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   27d74:	f7ec f8d2 	bl	13f1c <k_delayed_work_submit>
	frnd->clear.repeat_sec *= 2U;
   27d78:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   27d7c:	005b      	lsls	r3, r3, #1
   27d7e:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
}
   27d82:	bd10      	pop	{r4, pc}

00027d84 <net_buf_skip>:
 * @return Pointer to the fragment or
 *         NULL and pos is 0 after successful skip,
 *         NULL and pos is 0xffff otherwise.
 */
static inline struct net_buf *net_buf_skip(struct net_buf *buf, size_t len)
{
   27d84:	b538      	push	{r3, r4, r5, lr}
   27d86:	460d      	mov	r5, r1
	while (buf && len--) {
		net_buf_pull_u8(buf);
		if (!buf->len) {
			buf = net_buf_frag_del(NULL, buf);
   27d88:	4604      	mov	r4, r0
	while (buf && len--) {
   27d8a:	b10c      	cbz	r4, 27d90 <net_buf_skip+0xc>
   27d8c:	3d01      	subs	r5, #1
   27d8e:	d201      	bcs.n	27d94 <net_buf_skip+0x10>
		}
	}

	return buf;
}
   27d90:	4620      	mov	r0, r4
   27d92:	bd38      	pop	{r3, r4, r5, pc}
		net_buf_pull_u8(buf);
   27d94:	f104 0008 	add.w	r0, r4, #8
   27d98:	f000 ffdd 	bl	28d56 <net_buf_simple_pull_u8>
		if (!buf->len) {
   27d9c:	89a0      	ldrh	r0, [r4, #12]
   27d9e:	2800      	cmp	r0, #0
   27da0:	d1f3      	bne.n	27d8a <net_buf_skip+0x6>
			buf = net_buf_frag_del(NULL, buf);
   27da2:	4621      	mov	r1, r4
   27da4:	f7f7 f9f2 	bl	1f18c <net_buf_frag_del>
   27da8:	e7ee      	b.n	27d88 <net_buf_skip+0x4>

00027daa <friend_lpn_matches>:
	if (!frnd->established) {
   27daa:	78c3      	ldrb	r3, [r0, #3]
{
   27dac:	b510      	push	{r4, lr}
   27dae:	4604      	mov	r4, r0
	if (!frnd->established) {
   27db0:	f013 0020 	ands.w	r0, r3, #32
   27db4:	d00f      	beq.n	27dd6 <friend_lpn_matches+0x2c>
	if (net_idx != frnd->net_idx) {
   27db6:	89e3      	ldrh	r3, [r4, #14]
   27db8:	428b      	cmp	r3, r1
   27dba:	d119      	bne.n	27df0 <friend_lpn_matches+0x46>
	if (BT_MESH_ADDR_IS_UNICAST(addr)) {
   27dbc:	b213      	sxth	r3, r2
   27dbe:	2b00      	cmp	r3, #0
   27dc0:	dc0a      	bgt.n	27dd8 <friend_lpn_matches+0x2e>
		if (frnd->sub_list[i] == addr) {
   27dc2:	8a23      	ldrh	r3, [r4, #16]
   27dc4:	4293      	cmp	r3, r2
   27dc6:	d015      	beq.n	27df4 <friend_lpn_matches+0x4a>
   27dc8:	8a63      	ldrh	r3, [r4, #18]
   27dca:	4293      	cmp	r3, r2
   27dcc:	d012      	beq.n	27df4 <friend_lpn_matches+0x4a>
   27dce:	8aa3      	ldrh	r3, [r4, #20]
   27dd0:	1a9b      	subs	r3, r3, r2
   27dd2:	4258      	negs	r0, r3
   27dd4:	4158      	adcs	r0, r3
}
   27dd6:	bd10      	pop	{r4, pc}
	if (frnd->lpn == BT_MESH_ADDR_UNASSIGNED) {
   27dd8:	8820      	ldrh	r0, [r4, #0]
   27dda:	2800      	cmp	r0, #0
   27ddc:	d0fb      	beq.n	27dd6 <friend_lpn_matches+0x2c>
	return (addr >= frnd->lpn && addr < (frnd->lpn + frnd->num_elem));
   27dde:	4282      	cmp	r2, r0
   27de0:	d306      	bcc.n	27df0 <friend_lpn_matches+0x46>
   27de2:	7a23      	ldrb	r3, [r4, #8]
   27de4:	4418      	add	r0, r3
   27de6:	4282      	cmp	r2, r0
   27de8:	bfac      	ite	ge
   27dea:	2000      	movge	r0, #0
   27dec:	2001      	movlt	r0, #1
   27dee:	e7f2      	b.n	27dd6 <friend_lpn_matches+0x2c>
		return false;
   27df0:	2000      	movs	r0, #0
   27df2:	e7f0      	b.n	27dd6 <friend_lpn_matches+0x2c>
			return true;
   27df4:	2001      	movs	r0, #1
   27df6:	e7ee      	b.n	27dd6 <friend_lpn_matches+0x2c>

00027df8 <purge_buffers>:
{
   27df8:	b538      	push	{r3, r4, r5, lr}
   27dfa:	4604      	mov	r4, r0
		buf->frags = NULL;
   27dfc:	2500      	movs	r5, #0
Z_GENLIST_IS_EMPTY(slist)
   27dfe:	6820      	ldr	r0, [r4, #0]
	while (!sys_slist_is_empty(list)) {
   27e00:	b900      	cbnz	r0, 27e04 <purge_buffers+0xc>
}
   27e02:	bd38      	pop	{r3, r4, r5, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   27e04:	6862      	ldr	r2, [r4, #4]
   27e06:	6803      	ldr	r3, [r0, #0]
	list->head = node;
   27e08:	6023      	str	r3, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   27e0a:	4290      	cmp	r0, r2
	list->tail = node;
   27e0c:	bf08      	it	eq
   27e0e:	6063      	streq	r3, [r4, #4]
		buf->flags &= ~NET_BUF_FRAGS;
   27e10:	7943      	ldrb	r3, [r0, #5]
		buf->frags = NULL;
   27e12:	6005      	str	r5, [r0, #0]
		buf->flags &= ~NET_BUF_FRAGS;
   27e14:	f023 0301 	bic.w	r3, r3, #1
   27e18:	7143      	strb	r3, [r0, #5]
		net_buf_unref(buf);
   27e1a:	f7f7 f955 	bl	1f0c8 <net_buf_unref>
   27e1e:	e7ee      	b.n	27dfe <purge_buffers+0x6>

00027e20 <is_seg>:
{
   27e20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct net_buf *buf = (void *)sys_slist_peek_head(&seg->queue);
   27e24:	6804      	ldr	r4, [r0, #0]
{
   27e26:	460f      	mov	r7, r1
   27e28:	4616      	mov	r6, r2
	if (!buf) {
   27e2a:	b33c      	cbz	r4, 27e7c <is_seg+0x5c>
	net_buf_simple_save(&buf->b, &state);
   27e2c:	f104 0908 	add.w	r9, r4, #8
	state->offset = net_buf_simple_headroom(buf);
   27e30:	4648      	mov	r0, r9
   27e32:	f000 ffb4 	bl	28d9e <net_buf_simple_headroom>
	net_buf_skip(buf, 5);   /* skip IVI, NID, CTL, TTL, SEQ */
   27e36:	2105      	movs	r1, #5
   27e38:	4605      	mov	r5, r0
   27e3a:	4620      	mov	r0, r4
	state->len = buf->len;
   27e3c:	f8b4 a00c 	ldrh.w	sl, [r4, #12]
   27e40:	f7ff ffa0 	bl	27d84 <net_buf_skip>
	buf_src = net_buf_pull_be16(buf);
   27e44:	4648      	mov	r0, r9
   27e46:	f000 ff96 	bl	28d76 <net_buf_simple_pull_be16>
	net_buf_skip(buf, 3);   /* skip DST, OP/AID */
   27e4a:	2103      	movs	r1, #3
	buf_src = net_buf_pull_be16(buf);
   27e4c:	4680      	mov	r8, r0
	net_buf_skip(buf, 3);   /* skip DST, OP/AID */
   27e4e:	4620      	mov	r0, r4
   27e50:	f7ff ff98 	bl	27d84 <net_buf_skip>
	buf_seq_zero = ((net_buf_pull_be16(buf) >> 2) & TRANS_SEQ_ZERO_MASK);
   27e54:	4648      	mov	r0, r9
   27e56:	f000 ff8e 	bl	28d76 <net_buf_simple_pull_be16>
	buf->data = buf->__buf + state->offset;
   27e5a:	6923      	ldr	r3, [r4, #16]
	buf->len = state->len;
   27e5c:	f8a4 a00c 	strh.w	sl, [r4, #12]
	buf->data = buf->__buf + state->offset;
   27e60:	fa13 f585 	uxtah	r5, r3, r5
	return ((src == buf_src) && (seq_zero == buf_seq_zero));
   27e64:	45b8      	cmp	r8, r7
   27e66:	60a5      	str	r5, [r4, #8]
   27e68:	d106      	bne.n	27e78 <is_seg+0x58>
   27e6a:	f3c0 008c 	ubfx	r0, r0, #2, #13
   27e6e:	1b83      	subs	r3, r0, r6
   27e70:	4258      	negs	r0, r3
   27e72:	4158      	adcs	r0, r3
}
   27e74:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return ((src == buf_src) && (seq_zero == buf_seq_zero));
   27e78:	2000      	movs	r0, #0
   27e7a:	e7fb      	b.n	27e74 <is_seg+0x54>
		return false;
   27e7c:	4620      	mov	r0, r4
   27e7e:	e7f9      	b.n	27e74 <is_seg+0x54>

00027e80 <friend_queue_has_space.part.0>:
static bool friend_queue_has_space(struct bt_mesh_friend *frnd, u16_t addr,
   27e80:	b538      	push	{r3, r4, r5, lr}
   27e82:	4604      	mov	r4, r0
   27e84:	461d      	mov	r5, r3
		if (seq_auth && is_seg(seg, addr, *seq_auth & TRANS_SEQ_ZERO_MASK)) {
   27e86:	b942      	cbnz	r2, 27e9a <friend_queue_has_space.part.0+0x1a>
		total += seg->seg_count;
   27e88:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
	return (CONFIG_BT_MESH_FRIEND_QUEUE_SIZE - total) > seg_count;
   27e8c:	f1c0 0010 	rsb	r0, r0, #16
   27e90:	42a8      	cmp	r0, r5
   27e92:	bf94      	ite	ls
   27e94:	2000      	movls	r0, #0
   27e96:	2001      	movhi	r0, #1
}
   27e98:	bd38      	pop	{r3, r4, r5, pc}
		if (seq_auth && is_seg(seg, addr, *seq_auth & TRANS_SEQ_ZERO_MASK)) {
   27e9a:	8812      	ldrh	r2, [r2, #0]
   27e9c:	3038      	adds	r0, #56	; 0x38
   27e9e:	f3c2 020c 	ubfx	r2, r2, #0, #13
   27ea2:	f7ff ffbd 	bl	27e20 <is_seg>
   27ea6:	2800      	cmp	r0, #0
   27ea8:	d1f6      	bne.n	27e98 <friend_queue_has_space.part.0+0x18>
   27eaa:	e7ed      	b.n	27e88 <friend_queue_has_space.part.0+0x8>

00027eac <prov_capabilities>:
}
   27eac:	4770      	bx	lr

00027eae <prov_buf_init>:
{
   27eae:	b538      	push	{r3, r4, r5, lr}
   27eb0:	4604      	mov	r4, r0
   27eb2:	460d      	mov	r5, r1
	net_buf_simple_reserve(buf, PROV_BEARER_BUF_HEADROOM);
   27eb4:	2105      	movs	r1, #5
   27eb6:	f7f7 f803 	bl	1eec0 <net_buf_simple_reserve>
	net_buf_simple_add_u8(buf, type);
   27eba:	4629      	mov	r1, r5
   27ebc:	4620      	mov	r0, r4
}
   27ebe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	net_buf_simple_add_u8(buf, type);
   27ec2:	f000 bf84 	b.w	28dce <net_buf_simple_add_u8>

00027ec6 <atomic_or>:
{
   27ec6:	4603      	mov	r3, r0
}
   27ec8:	f3bf 8f5b 	dmb	ish
   27ecc:	e853 0f00 	ldrex	r0, [r3]
   27ed0:	ea40 0201 	orr.w	r2, r0, r1
   27ed4:	e843 2c00 	strex	ip, r2, [r3]
   27ed8:	f1bc 0f00 	cmp.w	ip, #0
   27edc:	d1f6      	bne.n	27ecc <atomic_or+0x6>
   27ede:	f3bf 8f5b 	dmb	ish
   27ee2:	4770      	bx	lr

00027ee4 <prov_bearer_error>:
	prov_fail(err);
   27ee4:	4610      	mov	r0, r2
   27ee6:	f7ed be5d 	b.w	15ba4 <prov_fail>

00027eea <prov_complete>:
   27eea:	4770      	bx	lr

00027eec <prov_input_complete>:
	notify_input_complete();
   27eec:	f7ee bae4 	b.w	164b8 <notify_input_complete>

00027ef0 <bt_prov_active>:
{
   27ef0:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   27ef2:	f7ed fdcf 	bl	15a94 <atomic_get.constprop.0>
}
   27ef6:	f3c0 0040 	ubfx	r0, r0, #1, #1
   27efa:	bd08      	pop	{r3, pc}

00027efc <clear_tx>:
}
   27efc:	4770      	bx	lr

00027efe <prov_ccc_changed>:
}
   27efe:	4770      	bx	lr

00027f00 <filter_add>:
{
   27f00:	b510      	push	{r4, lr}
	if (addr == BT_MESH_ADDR_UNASSIGNED) {
   27f02:	b179      	cbz	r1, 27f24 <filter_add+0x24>
		if (client->filter[i] == addr) {
   27f04:	8883      	ldrh	r3, [r0, #4]
   27f06:	4299      	cmp	r1, r3
   27f08:	d00c      	beq.n	27f24 <filter_add+0x24>
   27f0a:	88c4      	ldrh	r4, [r0, #6]
   27f0c:	42a1      	cmp	r1, r4
   27f0e:	d009      	beq.n	27f24 <filter_add+0x24>
   27f10:	8902      	ldrh	r2, [r0, #8]
   27f12:	4291      	cmp	r1, r2
   27f14:	d006      	beq.n	27f24 <filter_add+0x24>
		if (client->filter[i] == BT_MESH_ADDR_UNASSIGNED) {
   27f16:	b113      	cbz	r3, 27f1e <filter_add+0x1e>
   27f18:	b12c      	cbz	r4, 27f26 <filter_add+0x26>
   27f1a:	b91a      	cbnz	r2, 27f24 <filter_add+0x24>
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   27f1c:	2302      	movs	r3, #2
			client->filter[i] = addr;
   27f1e:	eb00 0043 	add.w	r0, r0, r3, lsl #1
   27f22:	8081      	strh	r1, [r0, #4]
}
   27f24:	bd10      	pop	{r4, pc}
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   27f26:	2301      	movs	r3, #1
   27f28:	e7f9      	b.n	27f1e <filter_add+0x1e>

00027f2a <proxy_ccc_changed>:
   27f2a:	4770      	bx	lr

00027f2c <proxy_segment_and_send>:
{
   27f2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27f30:	4688      	mov	r8, r1
   27f32:	4614      	mov	r4, r2
   27f34:	4606      	mov	r6, r0
	mtu = bt_gatt_get_mtu(conn) - 3;
   27f36:	f7ff f800 	bl	26f3a <bt_gatt_get_mtu>
	if (mtu > msg->len) {
   27f3a:	88a3      	ldrh	r3, [r4, #4]
	mtu = bt_gatt_get_mtu(conn) - 3;
   27f3c:	1ec5      	subs	r5, r0, #3
   27f3e:	b2ad      	uxth	r5, r5
	if (mtu > msg->len) {
   27f40:	42ab      	cmp	r3, r5
   27f42:	f008 073f 	and.w	r7, r8, #63	; 0x3f
   27f46:	d20a      	bcs.n	27f5e <proxy_segment_and_send+0x32>
		net_buf_simple_push_u8(msg, PDU_HDR(SAR_COMPLETE, type));
   27f48:	4639      	mov	r1, r7
   27f4a:	4620      	mov	r0, r4
   27f4c:	f000 fef0 	bl	28d30 <net_buf_simple_push_u8>
		return proxy_send(conn, msg->data, msg->len);
   27f50:	88a2      	ldrh	r2, [r4, #4]
   27f52:	6821      	ldr	r1, [r4, #0]
   27f54:	4630      	mov	r0, r6
}
   27f56:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return proxy_send(conn, msg->data, msg->len);
   27f5a:	f7ef ba5f 	b.w	1741c <proxy_send>
	net_buf_simple_push_u8(msg, PDU_HDR(SAR_FIRST, type));
   27f5e:	f047 0140 	orr.w	r1, r7, #64	; 0x40
   27f62:	4620      	mov	r0, r4
   27f64:	f000 fee4 	bl	28d30 <net_buf_simple_push_u8>
	proxy_send(conn, msg->data, mtu);
   27f68:	6821      	ldr	r1, [r4, #0]
   27f6a:	462a      	mov	r2, r5
   27f6c:	4630      	mov	r0, r6
   27f6e:	f7ef fa55 	bl	1741c <proxy_send>
	net_buf_simple_pull(msg, mtu);
   27f72:	4629      	mov	r1, r5
   27f74:	4620      	mov	r0, r4
   27f76:	f7f7 f96d 	bl	1f254 <net_buf_simple_pull>
		net_buf_simple_push_u8(msg, PDU_HDR(SAR_CONT, type));
   27f7a:	f047 0780 	orr.w	r7, r7, #128	; 0x80
	while (msg->len) {
   27f7e:	88a3      	ldrh	r3, [r4, #4]
   27f80:	b163      	cbz	r3, 27f9c <proxy_segment_and_send+0x70>
		if (msg->len + 1 < mtu) {
   27f82:	3301      	adds	r3, #1
   27f84:	42ab      	cmp	r3, r5
   27f86:	da0c      	bge.n	27fa2 <proxy_segment_and_send+0x76>
			net_buf_simple_push_u8(msg, PDU_HDR(SAR_LAST, type));
   27f88:	f048 01c0 	orr.w	r1, r8, #192	; 0xc0
   27f8c:	4620      	mov	r0, r4
   27f8e:	f000 fecf 	bl	28d30 <net_buf_simple_push_u8>
			proxy_send(conn, msg->data, msg->len);
   27f92:	88a2      	ldrh	r2, [r4, #4]
   27f94:	6821      	ldr	r1, [r4, #0]
   27f96:	4630      	mov	r0, r6
   27f98:	f7ef fa40 	bl	1741c <proxy_send>
}
   27f9c:	2000      	movs	r0, #0
   27f9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_buf_simple_push_u8(msg, PDU_HDR(SAR_CONT, type));
   27fa2:	4639      	mov	r1, r7
   27fa4:	4620      	mov	r0, r4
   27fa6:	f000 fec3 	bl	28d30 <net_buf_simple_push_u8>
		proxy_send(conn, msg->data, mtu);
   27faa:	6821      	ldr	r1, [r4, #0]
   27fac:	462a      	mov	r2, r5
   27fae:	4630      	mov	r0, r6
   27fb0:	f7ef fa34 	bl	1741c <proxy_send>
		net_buf_simple_pull(msg, mtu);
   27fb4:	4629      	mov	r1, r5
   27fb6:	4620      	mov	r0, r4
   27fb8:	f7f7 f94c 	bl	1f254 <net_buf_simple_pull>
   27fbc:	e7df      	b.n	27f7e <proxy_segment_and_send+0x52>

00027fbe <beacon_send>:
{
   27fbe:	b530      	push	{r4, r5, lr}
   27fc0:	b08b      	sub	sp, #44	; 0x2c
	NET_BUF_SIMPLE_DEFINE(buf, 23);
   27fc2:	ab04      	add	r3, sp, #16
   27fc4:	f44f 12b8 	mov.w	r2, #1507328	; 0x170000
{
   27fc8:	4604      	mov	r4, r0
   27fca:	460d      	mov	r5, r1
	net_buf_simple_reserve(&buf, 1);
   27fcc:	a801      	add	r0, sp, #4
   27fce:	2101      	movs	r1, #1
	NET_BUF_SIMPLE_DEFINE(buf, 23);
   27fd0:	e9cd 2302 	strd	r2, r3, [sp, #8]
   27fd4:	9301      	str	r3, [sp, #4]
	net_buf_simple_reserve(&buf, 1);
   27fd6:	f7f6 ff73 	bl	1eec0 <net_buf_simple_reserve>
	bt_mesh_beacon_create(sub, &buf);
   27fda:	a901      	add	r1, sp, #4
   27fdc:	4628      	mov	r0, r5
   27fde:	f7e4 f969 	bl	c2b4 <bt_mesh_beacon_create>
	return proxy_segment_and_send(conn, BT_MESH_PROXY_BEACON, &buf);
   27fe2:	aa01      	add	r2, sp, #4
   27fe4:	2101      	movs	r1, #1
   27fe6:	4620      	mov	r0, r4
   27fe8:	f7ff ffa0 	bl	27f2c <proxy_segment_and_send>
}
   27fec:	b00b      	add	sp, #44	; 0x2c
   27fee:	bd30      	pop	{r4, r5, pc}

00027ff0 <bt_mesh_proxy_identity_stop>:
	sub->node_id = BT_MESH_NODE_IDENTITY_STOPPED;
   27ff0:	2300      	movs	r3, #0
   27ff2:	f880 3020 	strb.w	r3, [r0, #32]
	sub->node_id_start = 0U;
   27ff6:	6243      	str	r3, [r0, #36]	; 0x24
}
   27ff8:	4770      	bx	lr

00027ffa <bt_mesh_proxy_addr_add>:
	if (client->filter_type == WHITELIST) {
   27ffa:	f810 3c2e 	ldrb.w	r3, [r0, #-46]
   27ffe:	2b01      	cmp	r3, #1
{
   28000:	460a      	mov	r2, r1
	if (client->filter_type == WHITELIST) {
   28002:	d102      	bne.n	2800a <bt_mesh_proxy_addr_add+0x10>
		filter_add(client, addr);
   28004:	3838      	subs	r0, #56	; 0x38
   28006:	f7ff bf7b 	b.w	27f00 <filter_add>
	} else if (client->filter_type == BLACKLIST) {
   2800a:	2b02      	cmp	r3, #2
   2800c:	d111      	bne.n	28032 <bt_mesh_proxy_addr_add+0x38>
	if (addr == BT_MESH_ADDR_UNASSIGNED) {
   2800e:	b181      	cbz	r1, 28032 <bt_mesh_proxy_addr_add+0x38>
		if (client->filter[i] == addr) {
   28010:	f830 1c34 	ldrh.w	r1, [r0, #-52]
   28014:	4291      	cmp	r1, r2
   28016:	d00d      	beq.n	28034 <bt_mesh_proxy_addr_add+0x3a>
   28018:	f830 1c32 	ldrh.w	r1, [r0, #-50]
   2801c:	4291      	cmp	r1, r2
   2801e:	d00b      	beq.n	28038 <bt_mesh_proxy_addr_add+0x3e>
   28020:	f830 1c30 	ldrh.w	r1, [r0, #-48]
   28024:	4291      	cmp	r1, r2
   28026:	d104      	bne.n	28032 <bt_mesh_proxy_addr_add+0x38>
			client->filter[i] = BT_MESH_ADDR_UNASSIGNED;
   28028:	eb00 0043 	add.w	r0, r0, r3, lsl #1
   2802c:	2300      	movs	r3, #0
   2802e:	f820 3c34 	strh.w	r3, [r0, #-52]
}
   28032:	4770      	bx	lr
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   28034:	2300      	movs	r3, #0
   28036:	e7f7      	b.n	28028 <bt_mesh_proxy_addr_add+0x2e>
   28038:	2301      	movs	r3, #1
   2803a:	e7f5      	b.n	28028 <bt_mesh_proxy_addr_add+0x2e>

0002803c <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, u16_t mem_size, u16_t mem_count,
	      void **mem_head)
{
   2803c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	*mem_head = mem_pool;
   2803e:	6018      	str	r0, [r3, #0]

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   28040:	1dc3      	adds	r3, r0, #7
   28042:	f023 0303 	bic.w	r3, r3, #3
{
   28046:	460e      	mov	r6, r1
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   28048:	801a      	strh	r2, [r3, #0]

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   2804a:	3a01      	subs	r2, #1
   2804c:	b294      	uxth	r4, r2
{
   2804e:	4605      	mov	r5, r0
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   28050:	2204      	movs	r2, #4
   28052:	2100      	movs	r1, #0
   28054:	fb06 0004 	mla	r0, r6, r4, r0
   28058:	f7fd fe51 	bl	25cfe <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
   2805c:	f64f 77ff 	movw	r7, #65535	; 0xffff
   28060:	3c01      	subs	r4, #1
   28062:	b2a4      	uxth	r4, r4
   28064:	42bc      	cmp	r4, r7
   28066:	d101      	bne.n	2806c <mem_init+0x30>
		next = (u32_t)((u8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
		       (void *)&next, sizeof(next));
	}
}
   28068:	b003      	add	sp, #12
   2806a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			       (mem_size * (mem_count + 1)));
   2806c:	fb04 6006 	mla	r0, r4, r6, r6
		next = (u32_t)((u8_t *) mem_pool +
   28070:	182b      	adds	r3, r5, r0
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
   28072:	2204      	movs	r2, #4
   28074:	1b80      	subs	r0, r0, r6
   28076:	eb0d 0102 	add.w	r1, sp, r2
   2807a:	4428      	add	r0, r5
		next = (u32_t)((u8_t *) mem_pool +
   2807c:	9301      	str	r3, [sp, #4]
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
   2807e:	f7fd fe13 	bl	25ca8 <memcpy>
   28082:	e7ed      	b.n	28060 <mem_init+0x24>

00028084 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
   28084:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (*mem_head) {
   28086:	6804      	ldr	r4, [r0, #0]
{
   28088:	4605      	mov	r5, r0
	if (*mem_head) {
   2808a:	b18c      	cbz	r4, 280b0 <mem_acquire+0x2c>
		u16_t free_count;
		void *head;
		void *mem;

		/* Get the free count from the list and decrement it */
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   2808c:	1de3      	adds	r3, r4, #7
   2808e:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
   28092:	2204      	movs	r2, #4
   28094:	4621      	mov	r1, r4
   28096:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   2809a:	881e      	ldrh	r6, [r3, #0]
		memcpy(&head, mem, sizeof(head));
   2809c:	f7fd fe04 	bl	25ca8 <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
   280a0:	9b01      	ldr	r3, [sp, #4]
   280a2:	b123      	cbz	r3, 280ae <mem_acquire+0x2a>
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   280a4:	1dda      	adds	r2, r3, #7
   280a6:	f022 0203 	bic.w	r2, r2, #3
		free_count--;
   280aa:	3e01      	subs	r6, #1
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   280ac:	8016      	strh	r6, [r2, #0]
				free_count;
		}

		*mem_head = head;
   280ae:	602b      	str	r3, [r5, #0]
		return mem;
	}

	return NULL;
}
   280b0:	4620      	mov	r0, r4
   280b2:	b002      	add	sp, #8
   280b4:	bd70      	pop	{r4, r5, r6, pc}

000280b6 <mem_release>:

void mem_release(void *mem, void **mem_head)
{
   280b6:	b570      	push	{r4, r5, r6, lr}
	u16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
   280b8:	680c      	ldr	r4, [r1, #0]
{
   280ba:	4606      	mov	r6, r0
   280bc:	460d      	mov	r5, r1
	if (*mem_head) {
   280be:	b11c      	cbz	r4, 280c8 <mem_release+0x12>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   280c0:	1de3      	adds	r3, r4, #7
   280c2:	f023 0303 	bic.w	r3, r3, #3
   280c6:	881c      	ldrh	r4, [r3, #0]
					       sizeof(mem_head)));
	}
	free_count++;

	memcpy(mem, mem_head, sizeof(mem));
   280c8:	2204      	movs	r2, #4
   280ca:	4629      	mov	r1, r5
   280cc:	4630      	mov	r0, r6
   280ce:	f7fd fdeb 	bl	25ca8 <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
   280d2:	1df2      	adds	r2, r6, #7
   280d4:	f022 0203 	bic.w	r2, r2, #3
	free_count++;
   280d8:	1c63      	adds	r3, r4, #1
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
   280da:	8013      	strh	r3, [r2, #0]

	*mem_head = mem;
   280dc:	602e      	str	r6, [r5, #0]
}
   280de:	bd70      	pop	{r4, r5, r6, pc}

000280e0 <mem_get>:
}

void *mem_get(void *mem_pool, u16_t mem_size, u16_t index)
{
	return ((void *)((u8_t *)mem_pool + (mem_size * index)));
}
   280e0:	fb02 0001 	mla	r0, r2, r1, r0
   280e4:	4770      	bx	lr

000280e6 <mem_index_get>:

u16_t mem_index_get(void *mem, void *mem_pool, u16_t mem_size)
{
	return ((u16_t)((u8_t *)mem - (u8_t *)mem_pool) / mem_size);
   280e6:	1a40      	subs	r0, r0, r1
   280e8:	b280      	uxth	r0, r0
}
   280ea:	fbb0 f0f2 	udiv	r0, r0, r2
   280ee:	4770      	bx	lr

000280f0 <mem_rcopy>:
/**
 * @brief  Copy bytes in reverse
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(u8_t *dst, u8_t const *src, u16_t len)
{
   280f0:	b510      	push	{r4, lr}
	src += len;
   280f2:	4411      	add	r1, r2
	while (len--) {
   280f4:	3801      	subs	r0, #1
   280f6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   280fa:	3a01      	subs	r2, #1
   280fc:	b292      	uxth	r2, r2
   280fe:	429a      	cmp	r2, r3
   28100:	d100      	bne.n	28104 <mem_rcopy+0x14>
		*dst++ = *--src;
	}
}
   28102:	bd10      	pop	{r4, pc}
		*dst++ = *--src;
   28104:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
   28108:	f800 4f01 	strb.w	r4, [r0, #1]!
   2810c:	e7f5      	b.n	280fa <mem_rcopy+0xa>

0002810e <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
u8_t mem_nz(u8_t *src, u16_t len)
{
	while (len--) {
   2810e:	4401      	add	r1, r0
   28110:	4288      	cmp	r0, r1
   28112:	d101      	bne.n	28118 <mem_nz+0xa>
		if (*src++) {
			return 1;
		}
	}

	return 0;
   28114:	2000      	movs	r0, #0
   28116:	4770      	bx	lr
		if (*src++) {
   28118:	f810 3b01 	ldrb.w	r3, [r0], #1
   2811c:	2b00      	cmp	r3, #0
   2811e:	d0f7      	beq.n	28110 <mem_nz+0x2>
			return 1;
   28120:	2001      	movs	r0, #1
}
   28122:	4770      	bx	lr

00028124 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
   28124:	6010      	str	r0, [r2, #0]
   28126:	6008      	str	r0, [r1, #0]

	return link;
}
   28128:	4770      	bx	lr

0002812a <memq_deinit>:
memq_link_t *memq_deinit(memq_link_t **head, memq_link_t **tail)
{
	memq_link_t *old_head;

	/* If head and tail are not equal, then queue is not empty */
	if (*head != *tail) {
   2812a:	680a      	ldr	r2, [r1, #0]
{
   2812c:	4603      	mov	r3, r0
	if (*head != *tail) {
   2812e:	6800      	ldr	r0, [r0, #0]
   28130:	4290      	cmp	r0, r2
   28132:	f04f 0200 	mov.w	r2, #0
		return NULL;
	}

	old_head = *head;
	*head = *tail = NULL;
   28136:	bf0a      	itet	eq
   28138:	600a      	streq	r2, [r1, #0]
		return NULL;
   2813a:	4610      	movne	r0, r2
	*head = *tail = NULL;
   2813c:	601a      	streq	r2, [r3, #0]

	return old_head;
}
   2813e:	4770      	bx	lr

00028140 <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
   28140:	b510      	push	{r4, lr}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
   28142:	6814      	ldr	r4, [r2, #0]
   28144:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
   28146:	6814      	ldr	r4, [r2, #0]
   28148:	6061      	str	r1, [r4, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	*tail = link;
   2814a:	6010      	str	r0, [r2, #0]

	return link;
}
   2814c:	bd10      	pop	{r4, pc}

0002814e <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
   2814e:	4288      	cmp	r0, r1
   28150:	d003      	beq.n	2815a <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
   28152:	b11a      	cbz	r2, 2815c <memq_peek+0xe>
		*mem = head->mem;
   28154:	6843      	ldr	r3, [r0, #4]
   28156:	6013      	str	r3, [r2, #0]
   28158:	4770      	bx	lr
		return NULL;
   2815a:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
   2815c:	4770      	bx	lr

0002815e <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
   2815e:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
   28160:	4283      	cmp	r3, r0
   28162:	d009      	beq.n	28178 <memq_dequeue+0x1a>
	if (mem) {
   28164:	b122      	cbz	r2, 28170 <memq_dequeue+0x12>
		*mem = head->mem;
   28166:	6858      	ldr	r0, [r3, #4]
   28168:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
   2816a:	681a      	ldr	r2, [r3, #0]
   2816c:	600a      	str	r2, [r1, #0]

	return old_head;
   2816e:	e001      	b.n	28174 <memq_dequeue+0x16>
	if (old_head == NULL) {
   28170:	2b00      	cmp	r3, #0
   28172:	d1fa      	bne.n	2816a <memq_dequeue+0xc>
}
   28174:	4618      	mov	r0, r3
   28176:	4770      	bx	lr
		return NULL; /* queue is empty */
   28178:	2300      	movs	r3, #0
   2817a:	e7fb      	b.n	28174 <memq_dequeue+0x16>

0002817c <util_ones_count_get>:
{
   2817c:	b510      	push	{r4, lr}
   2817e:	1e42      	subs	r2, r0, #1
	u8_t one_count = 0U;
   28180:	2000      	movs	r0, #0
	while (octets_len--) {
   28182:	3901      	subs	r1, #1
   28184:	b2c9      	uxtb	r1, r1
   28186:	29ff      	cmp	r1, #255	; 0xff
   28188:	d100      	bne.n	2818c <util_ones_count_get+0x10>
}
   2818a:	bd10      	pop	{r4, pc}
		bite = *octets;
   2818c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		while (bite) {
   28190:	2b00      	cmp	r3, #0
   28192:	d0f6      	beq.n	28182 <util_ones_count_get+0x6>
			bite &= (bite - 1);
   28194:	b25b      	sxtb	r3, r3
   28196:	1e5c      	subs	r4, r3, #1
   28198:	4023      	ands	r3, r4
			one_count++;
   2819a:	3001      	adds	r0, #1
			bite &= (bite - 1);
   2819c:	b2db      	uxtb	r3, r3
			one_count++;
   2819e:	b2c0      	uxtb	r0, r0
   281a0:	e7f6      	b.n	28190 <util_ones_count_get+0x14>

000281a2 <ticker_dequeue>:
{
   281a2:	b5f0      	push	{r4, r5, r6, r7, lr}
	previous = instance->ticker_id_head;
   281a4:	7f42      	ldrb	r2, [r0, #29]
	node = &instance->nodes[0];
   281a6:	6804      	ldr	r4, [r0, #0]
{
   281a8:	4605      	mov	r5, r0
	previous = instance->ticker_id_head;
   281aa:	4613      	mov	r3, r2
	total = 0U;
   281ac:	2000      	movs	r0, #0
	while (current != TICKER_NULL) {
   281ae:	2aff      	cmp	r2, #255	; 0xff
   281b0:	d101      	bne.n	281b6 <ticker_dequeue+0x14>
		return 0;
   281b2:	2000      	movs	r0, #0
}
   281b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ticker_current = &node[current];
   281b6:	eb02 0682 	add.w	r6, r2, r2, lsl #2
   281ba:	eb04 0cc6 	add.w	ip, r4, r6, lsl #3
		if (current == id) {
   281be:	428a      	cmp	r2, r1
   281c0:	f8dc 7008 	ldr.w	r7, [ip, #8]
   281c4:	f814 6036 	ldrb.w	r6, [r4, r6, lsl #3]
   281c8:	4438      	add	r0, r7
   281ca:	d002      	beq.n	281d2 <ticker_dequeue+0x30>
   281cc:	4613      	mov	r3, r2
   281ce:	4632      	mov	r2, r6
   281d0:	e7ed      	b.n	281ae <ticker_dequeue+0xc>
	if (previous == current) {
   281d2:	4293      	cmp	r3, r2
   281d4:	d100      	bne.n	281d8 <ticker_dequeue+0x36>
		instance->ticker_id_head = ticker_current->next;
   281d6:	776e      	strb	r6, [r5, #29]
	node[previous].next = ticker_current->next;
   281d8:	b21b      	sxth	r3, r3
   281da:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   281de:	f804 6033 	strb.w	r6, [r4, r3, lsl #3]
	if (ticker_current->next != TICKER_NULL) {
   281e2:	f89c 3000 	ldrb.w	r3, [ip]
   281e6:	2bff      	cmp	r3, #255	; 0xff
   281e8:	d0e4      	beq.n	281b4 <ticker_dequeue+0x12>
		node[ticker_current->next].ticks_to_expire += timeout;
   281ea:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   281ee:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
   281f2:	68a3      	ldr	r3, [r4, #8]
   281f4:	443b      	add	r3, r7
   281f6:	60a3      	str	r3, [r4, #8]
	return (total + timeout);
   281f8:	e7dc      	b.n	281b4 <ticker_dequeue+0x12>

000281fa <ticks_to_expire_prep>:
{
   281fa:	b530      	push	{r4, r5, lr}
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   281fc:	1a55      	subs	r5, r2, r1
   281fe:	f415 0f00 	tst.w	r5, #8388608	; 0x800000
	u32_t ticks_to_expire = ticker->ticks_to_expire;
   28202:	6883      	ldr	r3, [r0, #8]
	u32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
   28204:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   28206:	d109      	bne.n	2821c <ticks_to_expire_prep+0x22>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   28208:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
   2820c:	442b      	add	r3, r5
	if (ticks_to_expire > ticks_to_expire_minus) {
   2820e:	42a3      	cmp	r3, r4
   28210:	d90e      	bls.n	28230 <ticks_to_expire_prep+0x36>
		ticks_to_expire -= ticks_to_expire_minus;
   28212:	1b1b      	subs	r3, r3, r4
		ticks_to_expire_minus = 0U;
   28214:	2400      	movs	r4, #0
	ticker->ticks_to_expire = ticks_to_expire;
   28216:	6083      	str	r3, [r0, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
   28218:	6144      	str	r4, [r0, #20]
}
   2821a:	bd30      	pop	{r4, r5, pc}
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2821c:	1a8a      	subs	r2, r1, r2
   2821e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
   28222:	4293      	cmp	r3, r2
   28224:	d901      	bls.n	2822a <ticks_to_expire_prep+0x30>
			ticks_to_expire -= delta_current_start;
   28226:	1a9b      	subs	r3, r3, r2
   28228:	e7f1      	b.n	2820e <ticks_to_expire_prep+0x14>
			ticks_to_expire_minus +=
   2822a:	4414      	add	r4, r2
   2822c:	1ae4      	subs	r4, r4, r3
			ticks_to_expire = 0U;
   2822e:	2300      	movs	r3, #0
		ticks_to_expire_minus -= ticks_to_expire;
   28230:	1ae4      	subs	r4, r4, r3
		ticks_to_expire = 0U;
   28232:	2300      	movs	r3, #0
   28234:	e7ef      	b.n	28216 <ticks_to_expire_prep+0x1c>

00028236 <ticker_job_op_cb>:
{
   28236:	4603      	mov	r3, r0
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   28238:	2200      	movs	r2, #0
   2823a:	701a      	strb	r2, [r3, #0]
	if (user_op->fp_op_func) {
   2823c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	user_op->status = status;
   2823e:	6259      	str	r1, [r3, #36]	; 0x24
{
   28240:	4608      	mov	r0, r1
	if (user_op->fp_op_func) {
   28242:	b10a      	cbz	r2, 28248 <ticker_job_op_cb+0x12>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   28244:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   28246:	4710      	bx	r2
}
   28248:	4770      	bx	lr

0002824a <ticker_worker>:
{
   2824a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (instance->job_guard) {
   2824e:	7f85      	ldrb	r5, [r0, #30]
	instance->worker_trigger = 1U;
   28250:	2301      	movs	r3, #1
{
   28252:	4604      	mov	r4, r0
	instance->worker_trigger = 1U;
   28254:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
   28256:	b91d      	cbnz	r5, 28260 <ticker_worker+0x16>
	if (instance->ticker_id_head == TICKER_NULL) {
   28258:	7f43      	ldrb	r3, [r0, #29]
   2825a:	2bff      	cmp	r3, #255	; 0xff
   2825c:	d102      	bne.n	28264 <ticker_worker+0x1a>
		instance->worker_trigger = 0U;
   2825e:	77c5      	strb	r5, [r0, #31]
}
   28260:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
   28264:	f7f6 f886 	bl	1e374 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   28268:	6967      	ldr	r7, [r4, #20]
	ticker_id_head = instance->ticker_id_head;
   2826a:	7f66      	ldrb	r6, [r4, #29]
	node = &instance->nodes[0];
   2826c:	f8d4 8000 	ldr.w	r8, [r4]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   28270:	1bc7      	subs	r7, r0, r7
   28272:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
	while (ticker_id_head != TICKER_NULL) {
   28276:	2eff      	cmp	r6, #255	; 0xff
   28278:	d006      	beq.n	28288 <ticker_worker+0x3e>
		ticker = &node[ticker_id_head];
   2827a:	eb06 0686 	add.w	r6, r6, r6, lsl #2
   2827e:	eb08 01c6 	add.w	r1, r8, r6, lsl #3
		ticks_to_expire = ticker->ticks_to_expire;
   28282:	688b      	ldr	r3, [r1, #8]
		if (ticks_elapsed < ticks_to_expire) {
   28284:	429f      	cmp	r7, r3
   28286:	d218      	bcs.n	282ba <ticker_worker+0x70>
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
   28288:	7ae2      	ldrb	r2, [r4, #11]
   2828a:	7aa3      	ldrb	r3, [r4, #10]
   2828c:	4293      	cmp	r3, r2
   2828e:	d105      	bne.n	2829c <ticker_worker+0x52>
	u8_t idx = *ticks_elapsed_index + 1;
   28290:	3301      	adds	r3, #1
   28292:	b2db      	uxtb	r3, r3
		idx = 0U;
   28294:	2b02      	cmp	r3, #2
   28296:	bf08      	it	eq
   28298:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   2829a:	72e3      	strb	r3, [r4, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   2829c:	7ae3      	ldrb	r3, [r4, #11]
   2829e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   282a2:	2201      	movs	r2, #1
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   282a4:	60dd      	str	r5, [r3, #12]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   282a6:	6a65      	ldr	r5, [r4, #36]	; 0x24
	instance->worker_trigger = 0U;
   282a8:	2300      	movs	r3, #0
   282aa:	77e3      	strb	r3, [r4, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   282ac:	46ac      	mov	ip, r5
   282ae:	4623      	mov	r3, r4
   282b0:	2104      	movs	r1, #4
}
   282b2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   282b6:	2003      	movs	r0, #3
   282b8:	4760      	bx	ip
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   282ba:	788a      	ldrb	r2, [r1, #2]
		ticker_id_head = ticker->next;
   282bc:	f818 6036 	ldrb.w	r6, [r8, r6, lsl #3]
		ticks_elapsed -= ticks_to_expire;
   282c0:	1aff      	subs	r7, r7, r3
		ticks_expired += ticks_to_expire;
   282c2:	441d      	add	r5, r3
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   282c4:	784b      	ldrb	r3, [r1, #1]
   282c6:	1a9b      	subs	r3, r3, r2
   282c8:	b2db      	uxtb	r3, r3
   282ca:	2b01      	cmp	r3, #1
   282cc:	d1d3      	bne.n	28276 <ticker_worker+0x2c>
		if (ticker->timeout_func) {
   282ce:	f8d1 900c 	ldr.w	r9, [r1, #12]
		ticker->ack--;
   282d2:	3a01      	subs	r2, #1
   282d4:	708a      	strb	r2, [r1, #2]
		if (ticker->timeout_func) {
   282d6:	f1b9 0f00 	cmp.w	r9, #0
   282da:	d0cc      	beq.n	28276 <ticker_worker+0x2c>
					   ticks_expired -
   282dc:	6948      	ldr	r0, [r1, #20]
   282de:	6963      	ldr	r3, [r4, #20]
			ticker->timeout_func(ticks_at_expire,
   282e0:	8bca      	ldrh	r2, [r1, #30]
					   ticks_expired -
   282e2:	1a28      	subs	r0, r5, r0
   282e4:	4418      	add	r0, r3
			ticker->timeout_func(ticks_at_expire,
   282e6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   282ea:	690b      	ldr	r3, [r1, #16]
   282ec:	6a49      	ldr	r1, [r1, #36]	; 0x24
   282ee:	47c8      	blx	r9
   282f0:	e7c1      	b.n	28276 <ticker_worker+0x2c>

000282f2 <ticker_ticks_now_get>:
	return cntr_cnt_get();
   282f2:	f7f6 b83f 	b.w	1e374 <cntr_cnt_get>

000282f6 <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   282f6:	1a40      	subs	r0, r0, r1
}
   282f8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   282fc:	4770      	bx	lr

000282fe <ll_tx_pwr_lvl_get>:
#include "ull_conn_types.h"
#include "ull_conn_internal.h"

u8_t ll_tx_pwr_lvl_get(u8_t handle_type,
		       u16_t handle, u8_t type, s8_t *tx_pwr_lvl)
{
   282fe:	b538      	push	{r3, r4, r5, lr}
   28300:	4604      	mov	r4, r0
	switch (handle_type) {
   28302:	2c02      	cmp	r4, #2
{
   28304:	4608      	mov	r0, r1
   28306:	461d      	mov	r5, r3
	switch (handle_type) {
   28308:	d106      	bne.n	28318 <ll_tx_pwr_lvl_get+0x1a>
#endif /* CONFIG_BT_OBSERVER && CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL*/
#if defined(CONFIG_BT_CONN)
		case (BT_HCI_VS_LL_HANDLE_TYPE_CONN): {
			struct ll_conn *conn;

			conn = ll_connected_get(handle);
   2830a:	f000 f95d 	bl	285c8 <ll_connected_get>
			if (!conn) {
   2830e:	b108      	cbz	r0, 28314 <ll_tx_pwr_lvl_get+0x16>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
				/* Level desired is maximum available */
				*tx_pwr_lvl = lll_radio_tx_pwr_max_get();
#else  /* !CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
				/* Return default if not multiple TXP */
				*tx_pwr_lvl = RADIO_TXP_DEFAULT;
   28310:	2400      	movs	r4, #0
   28312:	702c      	strb	r4, [r5, #0]
			return BT_HCI_ERR_UNKNOWN_CMD;
		}
	}

	return BT_HCI_ERR_SUCCESS;
}
   28314:	4620      	mov	r0, r4
   28316:	bd38      	pop	{r3, r4, r5, pc}
			return BT_HCI_ERR_UNKNOWN_CMD;
   28318:	2401      	movs	r4, #1
   2831a:	e7fb      	b.n	28314 <ll_tx_pwr_lvl_get+0x16>

0002831c <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
   2831c:	2300      	movs	r3, #0
   2831e:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
   28320:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
   28322:	4770      	bx	lr

00028324 <sys_get_le64>:
{
   28324:	4603      	mov	r3, r0
}
   28326:	6800      	ldr	r0, [r0, #0]
   28328:	6859      	ldr	r1, [r3, #4]
   2832a:	4770      	bx	lr

0002832c <hci_evt_create>:
{
   2832c:	b538      	push	{r3, r4, r5, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
   2832e:	3008      	adds	r0, #8
{
   28330:	460d      	mov	r5, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
   28332:	2102      	movs	r1, #2
{
   28334:	4614      	mov	r4, r2
	hdr = net_buf_add(buf, sizeof(*hdr));
   28336:	f7f6 ffcf 	bl	1f2d8 <net_buf_simple_add>
	hdr->evt = evt;
   2833a:	7005      	strb	r5, [r0, #0]
	hdr->len = len;
   2833c:	7044      	strb	r4, [r0, #1]
}
   2833e:	bd38      	pop	{r3, r4, r5, pc}

00028340 <meta_evt>:
{
   28340:	b570      	push	{r4, r5, r6, lr}
   28342:	4604      	mov	r4, r0
   28344:	4615      	mov	r5, r2
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   28346:	3201      	adds	r2, #1
{
   28348:	460e      	mov	r6, r1
	me = net_buf_add(buf, sizeof(*me));
   2834a:	3408      	adds	r4, #8
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   2834c:	b2d2      	uxtb	r2, r2
   2834e:	213e      	movs	r1, #62	; 0x3e
   28350:	f7ff ffec 	bl	2832c <hci_evt_create>
	me = net_buf_add(buf, sizeof(*me));
   28354:	2101      	movs	r1, #1
   28356:	4620      	mov	r0, r4
   28358:	f7f6 ffbe 	bl	1f2d8 <net_buf_simple_add>
	me->subevent = subevt;
   2835c:	7006      	strb	r6, [r0, #0]
	return net_buf_add(buf, melen);
   2835e:	4629      	mov	r1, r5
   28360:	4620      	mov	r0, r4
}
   28362:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return net_buf_add(buf, melen);
   28366:	f7f6 bfb7 	b.w	1f2d8 <net_buf_simple_add>

0002836a <hci_num_cmplt_encode>:
{
   2836a:	b570      	push	{r4, r5, r6, lr}
   2836c:	4606      	mov	r6, r0
   2836e:	460d      	mov	r5, r1
   28370:	4614      	mov	r4, r2
	hci_evt_create(buf, BT_HCI_EVT_NUM_COMPLETED_PACKETS, len);
   28372:	2113      	movs	r1, #19
   28374:	2205      	movs	r2, #5
   28376:	f7ff ffd9 	bl	2832c <hci_evt_create>
	ep = net_buf_add(buf, len);
   2837a:	2105      	movs	r1, #5
   2837c:	f106 0008 	add.w	r0, r6, #8
   28380:	f7f6 ffaa 	bl	1f2d8 <net_buf_simple_add>
	ep->num_handles = num_handles;
   28384:	2301      	movs	r3, #1
   28386:	7003      	strb	r3, [r0, #0]
	hc->handle = sys_cpu_to_le16(handle);
   28388:	f8a0 5001 	strh.w	r5, [r0, #1]
	hc->count = sys_cpu_to_le16(num);
   2838c:	f8a0 4003 	strh.w	r4, [r0, #3]
}
   28390:	bd70      	pop	{r4, r5, r6, pc}

00028392 <bt_rand>:

#include "hal/ecb.h"

int bt_rand(void *buf, size_t len)
{
	return util_rand(buf, len);
   28392:	f7ef bfd9 	b.w	18348 <util_rand>

00028396 <bt_encrypt_be>:
	return 0;
}

int bt_encrypt_be(const u8_t key[16], const u8_t plaintext[16],
		  u8_t enc_data[16])
{
   28396:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt_be(key, plaintext, enc_data);
   28398:	f000 fbab 	bl	28af2 <ecb_encrypt_be>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
   2839c:	2000      	movs	r0, #0
   2839e:	bd08      	pop	{r3, pc}

000283a0 <disabled_cb>:
	z_impl_k_sem_give(sem);
   283a0:	f7fa b986 	b.w	226b0 <z_impl_k_sem_give>

000283a4 <rx_demux_conn_tx_ack>:
{
   283a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   283a6:	4606      	mov	r6, r0
   283a8:	4614      	mov	r4, r2
   283aa:	9300      	str	r3, [sp, #0]
   283ac:	f8ad 1006 	strh.w	r1, [sp, #6]
		ull_conn_ack_dequeue();
   283b0:	f7f4 f9b6 	bl	1c720 <ull_conn_ack_dequeue>
		conn = ull_conn_tx_ack(handle, link, node_tx);
   283b4:	9a00      	ldr	r2, [sp, #0]
   283b6:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   283ba:	4621      	mov	r1, r4
   283bc:	f7f4 f9f4 	bl	1c7a8 <ull_conn_tx_ack>
   283c0:	4605      	mov	r5, r0
		ull_conn_link_tx_release(link);
   283c2:	4620      	mov	r0, r4
   283c4:	f7f4 f972 	bl	1c6ac <ull_conn_link_tx_release>
		ull_conn_tx_demux(1);
   283c8:	2001      	movs	r0, #1
   283ca:	f7f3 ffb1 	bl	1c330 <ull_conn_tx_demux>
		if (conn) {
   283ce:	b11d      	cbz	r5, 283d8 <rx_demux_conn_tx_ack+0x34>
			ull_conn_tx_lll_enqueue(conn, 1);
   283d0:	2101      	movs	r1, #1
   283d2:	4628      	mov	r0, r5
   283d4:	f7f4 f932 	bl	1c63c <ull_conn_tx_lll_enqueue>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
   283d8:	466a      	mov	r2, sp
   283da:	f10d 0106 	add.w	r1, sp, #6
   283de:	4630      	mov	r0, r6
   283e0:	f7f4 f988 	bl	1c6f4 <ull_conn_ack_by_last_peek>
	} while (link);
   283e4:	4604      	mov	r4, r0
   283e6:	2800      	cmp	r0, #0
   283e8:	d1e2      	bne.n	283b0 <rx_demux_conn_tx_ack+0xc>
			ll_rx_sched();
   283ea:	f7f2 f893 	bl	1a514 <ll_rx_sched>
}
   283ee:	b002      	add	sp, #8
   283f0:	bd70      	pop	{r4, r5, r6, pc}

000283f2 <ll_timeslice_ticker_id_get>:
	*instance_index = TICKER_INSTANCE_ID_CTLR;
   283f2:	2300      	movs	r3, #0
   283f4:	7003      	strb	r3, [r0, #0]
	*user_id = (TICKER_NODES - FLASH_TICKER_NODES);
   283f6:	2306      	movs	r3, #6
   283f8:	700b      	strb	r3, [r1, #0]
}
   283fa:	4770      	bx	lr

000283fc <ll_radio_state_is_idle>:
	return lll_radio_is_idle();
   283fc:	f000 b9f0 	b.w	287e0 <lll_radio_is_idle>

00028400 <lll_chan_sel_1>:
#endif /* CONFIG_BT_CONN */

#if defined(CONFIG_BT_CONN)
u8_t lll_chan_sel_1(u8_t *chan_use, u8_t hop, u16_t latency, u8_t *chan_map,
		    u8_t chan_count)
{
   28400:	b570      	push	{r4, r5, r6, lr}
	u8_t chan_next;

	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   28402:	fb02 1101 	mla	r1, r2, r1, r1
   28406:	7802      	ldrb	r2, [r0, #0]
{
   28408:	f89d 6010 	ldrb.w	r6, [sp, #16]
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   2840c:	4411      	add	r1, r2
   2840e:	2225      	movs	r2, #37	; 0x25
   28410:	fbb1 f4f2 	udiv	r4, r1, r2
   28414:	fb02 1114 	mls	r1, r2, r4, r1
{
   28418:	4605      	mov	r5, r0
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   2841a:	b2c8      	uxtb	r0, r1
	*chan_use = chan_next;

	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   2841c:	08c2      	lsrs	r2, r0, #3
	*chan_use = chan_next;
   2841e:	7028      	strb	r0, [r5, #0]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   28420:	5c9c      	ldrb	r4, [r3, r2]
   28422:	f001 0107 	and.w	r1, r1, #7
   28426:	fa44 f101 	asr.w	r1, r4, r1
   2842a:	f011 0101 	ands.w	r1, r1, #1
   2842e:	d109      	bne.n	28444 <lll_chan_sel_1+0x44>
		u8_t chan_index;

		chan_index = chan_next % chan_count;
   28430:	fbb0 f2f6 	udiv	r2, r0, r6
   28434:	fb06 0212 	mls	r2, r6, r2, r0
   28438:	1e5c      	subs	r4, r3, #1
   2843a:	b2d2      	uxtb	r2, r2
	u8_t chan_next;
	u8_t byte_count;

	chan_next = 0U;
	byte_count = 5U;
	while (byte_count--) {
   2843c:	3304      	adds	r3, #4
	chan_next = 0U;
   2843e:	4608      	mov	r0, r1
	while (byte_count--) {
   28440:	42a3      	cmp	r3, r4
   28442:	d100      	bne.n	28446 <lll_chan_sel_1+0x46>
}
   28444:	bd70      	pop	{r4, r5, r6, pc}
		u8_t bite;
		u8_t bit_count;

		bite = *chan_map;
   28446:	f100 0108 	add.w	r1, r0, #8
   2844a:	f814 5f01 	ldrb.w	r5, [r4, #1]!
		bit_count = 8U;
		while (bit_count--) {
   2844e:	b2c9      	uxtb	r1, r1
   28450:	4288      	cmp	r0, r1
   28452:	d0f5      	beq.n	28440 <lll_chan_sel_1+0x40>
			if (bite & 0x01) {
   28454:	07ee      	lsls	r6, r5, #31
   28456:	d503      	bpl.n	28460 <lll_chan_sel_1+0x60>
				if (chan_index == 0U) {
   28458:	2a00      	cmp	r2, #0
   2845a:	d0f3      	beq.n	28444 <lll_chan_sel_1+0x44>
					break;
				}
				chan_index--;
   2845c:	3a01      	subs	r2, #1
   2845e:	b2d2      	uxtb	r2, r2
			}
			chan_next++;
   28460:	3001      	adds	r0, #1
   28462:	b2c0      	uxtb	r0, r0
			bite >>= 1;
   28464:	086d      	lsrs	r5, r5, #1
   28466:	e7f3      	b.n	28450 <lll_chan_sel_1+0x50>

00028468 <ull_adv_init>:
}
   28468:	2000      	movs	r0, #0
   2846a:	4770      	bx	lr

0002846c <ull_adv_reset>:
{
   2846c:	b508      	push	{r3, lr}
		(void)disable(handle);
   2846e:	f7f2 fe19 	bl	1b0a4 <disable.constprop.0>
}
   28472:	2000      	movs	r0, #0
   28474:	bd08      	pop	{r3, pc}

00028476 <ull_adv_is_enabled>:
{
   28476:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   28478:	f7f2 fe06 	bl	1b088 <ull_adv_is_enabled_get>
}
   2847c:	3800      	subs	r0, #0
   2847e:	bf18      	it	ne
   28480:	2001      	movne	r0, #1
   28482:	bd08      	pop	{r3, pc}

00028484 <ull_scan_init>:
}
   28484:	2000      	movs	r0, #0
   28486:	4770      	bx	lr

00028488 <disable.constprop.0>:

static u8_t disable(u16_t handle)
   28488:	b510      	push	{r4, lr}
{
	struct ll_scan_set *scan;
	u8_t ret;

	scan = ull_scan_is_enabled_get(handle);
   2848a:	2000      	movs	r0, #0
   2848c:	f7f2 ff4e 	bl	1b32c <ull_scan_is_enabled_get>
	if (!scan) {
   28490:	4604      	mov	r4, r0
   28492:	b158      	cbz	r0, 284ac <disable.constprop.0+0x24>
	if (scan->lll.conn) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif

	ret = ull_scan_disable(handle, scan);
   28494:	4601      	mov	r1, r0
   28496:	2000      	movs	r0, #0
   28498:	f7f2 fed4 	bl	1b244 <ull_scan_disable>
	if (ret) {
   2849c:	b928      	cbnz	r0, 284aa <disable.constprop.0+0x22>
		return ret;
	}

	scan->is_enabled = 0U;
   2849e:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   284a2:	f360 0300 	bfi	r3, r0, #0, #1
   284a6:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
		ull_filter_adv_scan_state_cb(0);
	}
#endif

	return 0;
}
   284aa:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   284ac:	200c      	movs	r0, #12
   284ae:	e7fc      	b.n	284aa <disable.constprop.0+0x22>

000284b0 <ull_scan_reset>:
{
   284b0:	b508      	push	{r3, lr}
		(void)disable(handle);
   284b2:	f7ff ffe9 	bl	28488 <disable.constprop.0>
}
   284b6:	2000      	movs	r0, #0
   284b8:	bd08      	pop	{r3, pc}

000284ba <ll_scan_enable>:
{
   284ba:	b510      	push	{r4, lr}
	if (!enable) {
   284bc:	b918      	cbnz	r0, 284c6 <ll_scan_enable+0xc>
}
   284be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return disable(0);
   284c2:	f7ff bfe1 	b.w	28488 <disable.constprop.0>
	scan = ull_scan_is_disabled_get(0);
   284c6:	2000      	movs	r0, #0
   284c8:	f7f2 ff3e 	bl	1b348 <ull_scan_is_disabled_get>
	if (!scan) {
   284cc:	4604      	mov	r4, r0
   284ce:	b198      	cbz	r0, 284f8 <ll_scan_enable+0x3e>
	if (scan->own_addr_type & 0x1) {
   284d0:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
   284d4:	079b      	lsls	r3, r3, #30
   284d6:	d404      	bmi.n	284e2 <ll_scan_enable+0x28>
	return ull_scan_enable(scan);
   284d8:	4620      	mov	r0, r4
}
   284da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return ull_scan_enable(scan);
   284de:	f7d8 b9a7 	b.w	830 <ull_scan_enable>
		if (!mem_nz(ll_addr_get(1, NULL), BDADDR_SIZE)) {
   284e2:	2100      	movs	r1, #0
   284e4:	2001      	movs	r0, #1
   284e6:	f7f0 fc83 	bl	18df0 <ll_addr_get>
   284ea:	2106      	movs	r1, #6
   284ec:	f7ff fe0f 	bl	2810e <mem_nz>
   284f0:	2800      	cmp	r0, #0
   284f2:	d1f1      	bne.n	284d8 <ll_scan_enable+0x1e>
			return BT_HCI_ERR_INVALID_PARAM;
   284f4:	2012      	movs	r0, #18
}
   284f6:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   284f8:	200c      	movs	r0, #12
   284fa:	e7fc      	b.n	284f6 <ll_scan_enable+0x3c>

000284fc <ull_scan_is_enabled>:
{
   284fc:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
   284fe:	f7f2 ff15 	bl	1b32c <ull_scan_is_enabled_get>
	if (!scan) {
   28502:	b140      	cbz	r0, 28516 <ull_scan_is_enabled+0x1a>
	return (((u32_t)scan->is_enabled << scan->lll.type) |
   28504:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
   28508:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
   2850c:	f003 0301 	and.w	r3, r3, #1
   28510:	09c0      	lsrs	r0, r0, #7
   28512:	fa03 f000 	lsl.w	r0, r3, r0
}
   28516:	bd08      	pop	{r3, pc}

00028518 <tx_ull_dequeue>:
{
   28518:	4603      	mov	r3, r0
   2851a:	4608      	mov	r0, r1
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   2851c:	e9d3 2145 	ldrd	r2, r1, [r3, #276]	; 0x114
{
   28520:	b510      	push	{r4, lr}
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   28522:	b979      	cbnz	r1, 28544 <tx_ull_dequeue+0x2c>
   28524:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   28528:	4291      	cmp	r1, r2
   2852a:	d00b      	beq.n	28544 <tx_ull_dequeue+0x2c>
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   2852c:	7911      	ldrb	r1, [r2, #4]
   2852e:	f001 0103 	and.w	r1, r1, #3
   28532:	2903      	cmp	r1, #3
   28534:	d104      	bne.n	28540 <tx_ull_dequeue+0x28>
		    ((pdu_data_tx->llctrl.opcode !=
   28536:	79d1      	ldrb	r1, [r2, #7]
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   28538:	2903      	cmp	r1, #3
   2853a:	d003      	beq.n	28544 <tx_ull_dequeue+0x2c>
		      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   2853c:	290a      	cmp	r1, #10
   2853e:	d001      	beq.n	28544 <tx_ull_dequeue+0x2c>
			conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   28540:	e9c3 2246 	strd	r2, r2, [r3, #280]	; 0x118
	if (conn->tx_head == conn->tx_ctrl) {
   28544:	f8d3 4118 	ldr.w	r4, [r3, #280]	; 0x118
   28548:	6811      	ldr	r1, [r2, #0]
   2854a:	4294      	cmp	r4, r2
   2854c:	d10c      	bne.n	28568 <tx_ull_dequeue+0x50>
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   2854e:	f8d3 411c 	ldr.w	r4, [r3, #284]	; 0x11c
		conn->tx_head = conn->tx_head->next;
   28552:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   28556:	42a2      	cmp	r2, r4
			conn->tx_ctrl = NULL;
   28558:	bf06      	itte	eq
   2855a:	2200      	moveq	r2, #0
			conn->tx_ctrl_last = NULL;
   2855c:	e9c3 2246 	strdeq	r2, r2, [r3, #280]	; 0x118
			conn->tx_ctrl = conn->tx_head;
   28560:	f8c3 1118 	strne.w	r1, [r3, #280]	; 0x118
		tx->next = tx;
   28564:	6000      	str	r0, [r0, #0]
}
   28566:	bd10      	pop	{r4, pc}
		if (conn->tx_head == conn->tx_data) {
   28568:	f8d3 4120 	ldr.w	r4, [r3, #288]	; 0x120
		conn->tx_head = conn->tx_head->next;
   2856c:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
		if (conn->tx_head == conn->tx_data) {
   28570:	4294      	cmp	r4, r2
			conn->tx_data = conn->tx_data->next;
   28572:	bf08      	it	eq
   28574:	f8c3 1120 	streq.w	r1, [r3, #288]	; 0x120
		tx->next = NULL;
   28578:	2300      	movs	r3, #0
   2857a:	6003      	str	r3, [r0, #0]
   2857c:	e7f3      	b.n	28566 <tx_ull_dequeue+0x4e>

0002857e <ctrl_tx_enqueue>:
	if (
   2857e:	e9d0 3245 	ldrd	r3, r2, [r0, #276]	; 0x114
{
   28582:	b510      	push	{r4, lr}
	if (
   28584:	b18b      	cbz	r3, 285aa <ctrl_tx_enqueue+0x2c>
		if (conn->tx_head == conn->tx_data) {
   28586:	f8d0 4120 	ldr.w	r4, [r0, #288]	; 0x120
   2858a:	42a3      	cmp	r3, r4
			conn->tx_data = conn->tx_data->next;
   2858c:	bf04      	itt	eq
   2858e:	681c      	ldreq	r4, [r3, #0]
   28590:	f8c0 4120 	streq.w	r4, [r0, #288]	; 0x120
		if (!conn->tx_ctrl) {
   28594:	b992      	cbnz	r2, 285bc <ctrl_tx_enqueue+0x3e>
			tx->next = conn->tx_head->next;
   28596:	681a      	ldr	r2, [r3, #0]
   28598:	600a      	str	r2, [r1, #0]
			conn->tx_head->next = tx;
   2859a:	6019      	str	r1, [r3, #0]
				conn->tx_ctrl = tx;
   2859c:	f8c0 1118 	str.w	r1, [r0, #280]	; 0x118
	conn->tx_ctrl_last = tx;
   285a0:	f8c0 111c 	str.w	r1, [r0, #284]	; 0x11c
	if (!tx->next) {
   285a4:	680b      	ldr	r3, [r1, #0]
   285a6:	b133      	cbz	r3, 285b6 <ctrl_tx_enqueue+0x38>
}
   285a8:	bd10      	pop	{r4, pc}
		if (!conn->tx_ctrl) {
   285aa:	b93a      	cbnz	r2, 285bc <ctrl_tx_enqueue+0x3e>
			tx->next = conn->tx_head;
   285ac:	600a      	str	r2, [r1, #0]
				conn->tx_ctrl = tx;
   285ae:	e9c0 1145 	strd	r1, r1, [r0, #276]	; 0x114
				conn->tx_ctrl_last = tx;
   285b2:	f8c0 111c 	str.w	r1, [r0, #284]	; 0x11c
		conn->tx_data_last = tx;
   285b6:	f8c0 1124 	str.w	r1, [r0, #292]	; 0x124
}
   285ba:	e7f5      	b.n	285a8 <ctrl_tx_enqueue+0x2a>
	tx->next = conn->tx_ctrl_last->next;
   285bc:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
   285c0:	681a      	ldr	r2, [r3, #0]
   285c2:	600a      	str	r2, [r1, #0]
	conn->tx_ctrl_last->next = tx;
   285c4:	6019      	str	r1, [r3, #0]
   285c6:	e7eb      	b.n	285a0 <ctrl_tx_enqueue+0x22>

000285c8 <ll_connected_get>:
{
   285c8:	b508      	push	{r3, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
   285ca:	b918      	cbnz	r0, 285d4 <ll_connected_get+0xc>
	conn = ll_conn_get(handle);
   285cc:	f7f3 f87a 	bl	1b6c4 <ll_conn_get>
	if (conn->lll.handle != handle) {
   285d0:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
   285d2:	b103      	cbz	r3, 285d6 <ll_connected_get+0xe>
		return NULL;
   285d4:	2000      	movs	r0, #0
}
   285d6:	bd08      	pop	{r3, pc}

000285d8 <ll_conn_update>:
{
   285d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   285dc:	460c      	mov	r4, r1
   285de:	f8bd a020 	ldrh.w	sl, [sp, #32]
   285e2:	f8bd 9024 	ldrh.w	r9, [sp, #36]	; 0x24
   285e6:	f8bd 8028 	ldrh.w	r8, [sp, #40]	; 0x28
   285ea:	4617      	mov	r7, r2
   285ec:	461e      	mov	r6, r3
	conn = ll_connected_get(handle);
   285ee:	f7ff ffeb 	bl	285c8 <ll_connected_get>
	if (!conn) {
   285f2:	4605      	mov	r5, r0
   285f4:	2800      	cmp	r0, #0
   285f6:	d068      	beq.n	286ca <ll_conn_update+0xf2>
	if (!cmd) {
   285f8:	bb7c      	cbnz	r4, 2865a <ll_conn_update+0x82>
		if (!conn->llcp_conn_param.disabled &&
   285fa:	f890 30ee 	ldrb.w	r3, [r0, #238]	; 0xee
   285fe:	06da      	lsls	r2, r3, #27
   28600:	d408      	bmi.n	28614 <ll_conn_update+0x3c>
		    (!conn->common.fex_valid ||
   28602:	f890 1080 	ldrb.w	r1, [r0, #128]	; 0x80
		if (!conn->llcp_conn_param.disabled &&
   28606:	f011 0101 	ands.w	r1, r1, #1
   2860a:	d044      	beq.n	28696 <ll_conn_update+0xbe>
		     (conn->llcp_feature.features &
   2860c:	f8d0 30b8 	ldr.w	r3, [r0, #184]	; 0xb8
		    (!conn->common.fex_valid ||
   28610:	079b      	lsls	r3, r3, #30
   28612:	d423      	bmi.n	2865c <ll_conn_update+0x84>
		} else if (conn->lll.role) {
   28614:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
   28618:	2b00      	cmp	r3, #0
   2861a:	db54      	blt.n	286c6 <ll_conn_update+0xee>
		if (conn->llcp_cu.req != conn->llcp_cu.ack) {
   2861c:	f895 30a0 	ldrb.w	r3, [r5, #160]	; 0xa0
   28620:	f895 20a1 	ldrb.w	r2, [r5, #161]	; 0xa1
   28624:	429a      	cmp	r2, r3
   28626:	d150      	bne.n	286ca <ll_conn_update+0xf2>
		conn->llcp_cu.win_size = 1U;
   28628:	2301      	movs	r3, #1
   2862a:	f885 30b0 	strb.w	r3, [r5, #176]	; 0xb0
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2862e:	f895 30a2 	ldrb.w	r3, [r5, #162]	; 0xa2
		conn->llcp_cu.interval = interval_max;
   28632:	f8a5 a0a4 	strh.w	sl, [r5, #164]	; 0xa4
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   28636:	f023 0307 	bic.w	r3, r3, #7
		conn->llcp_cu.win_offset_us = 0U;
   2863a:	2000      	movs	r0, #0
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2863c:	f043 0305 	orr.w	r3, r3, #5
		conn->llcp_cu.req++;
   28640:	3201      	adds	r2, #1
		conn->llcp_cu.win_offset_us = 0U;
   28642:	f8c5 00ac 	str.w	r0, [r5, #172]	; 0xac
		conn->llcp_cu.latency = latency;
   28646:	f8a5 90a6 	strh.w	r9, [r5, #166]	; 0xa6
		conn->llcp_cu.timeout = timeout;
   2864a:	f8a5 80a8 	strh.w	r8, [r5, #168]	; 0xa8
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2864e:	f885 30a2 	strb.w	r3, [r5, #162]	; 0xa2
		conn->llcp_cu.req++;
   28652:	f885 20a0 	strb.w	r2, [r5, #160]	; 0xa0
}
   28656:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2865a:	4621      	mov	r1, r4
		cmd--;
   2865c:	3901      	subs	r1, #1
		if (cmd) {
   2865e:	f011 00ff 	ands.w	r0, r1, #255	; 0xff
   28662:	f895 30ec 	ldrb.w	r3, [r5, #236]	; 0xec
   28666:	f895 20ed 	ldrb.w	r2, [r5, #237]	; 0xed
   2866a:	d016      	beq.n	2869a <ll_conn_update+0xc2>
			if ((conn->llcp_conn_param.req ==
   2866c:	4293      	cmp	r3, r2
   2866e:	d02c      	beq.n	286ca <ll_conn_update+0xf2>
			    (conn->llcp_conn_param.state !=
   28670:	f895 30ee 	ldrb.w	r3, [r5, #238]	; 0xee
			     conn->llcp_conn_param.ack) ||
   28674:	f003 0207 	and.w	r2, r3, #7
   28678:	2a03      	cmp	r2, #3
   2867a:	d126      	bne.n	286ca <ll_conn_update+0xf2>
			conn->llcp_conn_param.state = cmd;
   2867c:	f000 0007 	and.w	r0, r0, #7
   28680:	f040 0008 	orr.w	r0, r0, #8
   28684:	f023 030f 	bic.w	r3, r3, #15
   28688:	4318      	orrs	r0, r3
   2868a:	f885 00ee 	strb.w	r0, [r5, #238]	; 0xee
			conn->llcp_conn_param.status = status;
   2868e:	f885 70ef 	strb.w	r7, [r5, #239]	; 0xef
	return 0;
   28692:	2000      	movs	r0, #0
   28694:	e7df      	b.n	28656 <ll_conn_update+0x7e>
			cmd++;
   28696:	2101      	movs	r1, #1
   28698:	e7e0      	b.n	2865c <ll_conn_update+0x84>
			if (conn->llcp_conn_param.req !=
   2869a:	4293      	cmp	r3, r2
   2869c:	d115      	bne.n	286ca <ll_conn_update+0xf2>
			conn->llcp_conn_param.state = cmd;
   2869e:	f8b5 20ee 	ldrh.w	r2, [r5, #238]	; 0xee
			conn->llcp_conn_param.interval_min = interval_min;
   286a2:	f8a5 60f0 	strh.w	r6, [r5, #240]	; 0xf0
			conn->llcp_conn_param.state = cmd;
   286a6:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
   286aa:	f042 0208 	orr.w	r2, r2, #8
			conn->llcp_conn_param.req++;
   286ae:	3301      	adds	r3, #1
			conn->llcp_conn_param.interval_max = interval_max;
   286b0:	f8a5 a0f2 	strh.w	sl, [r5, #242]	; 0xf2
			conn->llcp_conn_param.latency = latency;
   286b4:	f8a5 90f4 	strh.w	r9, [r5, #244]	; 0xf4
			conn->llcp_conn_param.timeout = timeout;
   286b8:	f8a5 80f6 	strh.w	r8, [r5, #246]	; 0xf6
			conn->llcp_conn_param.state = cmd;
   286bc:	f8a5 20ee 	strh.w	r2, [r5, #238]	; 0xee
			conn->llcp_conn_param.req++;
   286c0:	f885 30ec 	strb.w	r3, [r5, #236]	; 0xec
   286c4:	e7c7      	b.n	28656 <ll_conn_update+0x7e>
			return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   286c6:	201a      	movs	r0, #26
   286c8:	e7c5      	b.n	28656 <ll_conn_update+0x7e>
		return BT_HCI_ERR_CMD_DISALLOWED;
   286ca:	200c      	movs	r0, #12
   286cc:	e7c3      	b.n	28656 <ll_conn_update+0x7e>

000286ce <ll_chm_get>:
{
   286ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   286d0:	460d      	mov	r5, r1
	conn = ll_connected_get(handle);
   286d2:	f7ff ff79 	bl	285c8 <ll_connected_get>
	if (!conn) {
   286d6:	4604      	mov	r4, r0
   286d8:	b170      	cbz	r0, 286f8 <ll_chm_get+0x2a>
		conn->chm_updated = 0U;
   286da:	2700      	movs	r7, #0
		memcpy(chm, conn->lll.data_chan_map,
   286dc:	f100 0638 	add.w	r6, r0, #56	; 0x38
		conn->chm_updated = 0U;
   286e0:	f884 7128 	strb.w	r7, [r4, #296]	; 0x128
		memcpy(chm, conn->lll.data_chan_map,
   286e4:	2205      	movs	r2, #5
   286e6:	4631      	mov	r1, r6
   286e8:	4628      	mov	r0, r5
   286ea:	f7fd fadd 	bl	25ca8 <memcpy>
	} while (conn->chm_updated);
   286ee:	f894 0128 	ldrb.w	r0, [r4, #296]	; 0x128
   286f2:	2800      	cmp	r0, #0
   286f4:	d1f4      	bne.n	286e0 <ll_chm_get+0x12>
}
   286f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   286f8:	200c      	movs	r0, #12
   286fa:	e7fc      	b.n	286f6 <ll_chm_get+0x28>

000286fc <ll_terminate_ind_send>:
{
   286fc:	b510      	push	{r4, lr}
   286fe:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   28700:	f7ff ff62 	bl	285c8 <ll_connected_get>
	if (!conn) {
   28704:	b140      	cbz	r0, 28718 <ll_terminate_ind_send+0x1c>
	conn->llcp_terminate.req++;
   28706:	f890 30c4 	ldrb.w	r3, [r0, #196]	; 0xc4
	conn->llcp_terminate.reason_own = reason;
   2870a:	f880 40c6 	strb.w	r4, [r0, #198]	; 0xc6
	conn->llcp_terminate.req++;
   2870e:	3301      	adds	r3, #1
   28710:	f880 30c4 	strb.w	r3, [r0, #196]	; 0xc4
	return 0;
   28714:	2000      	movs	r0, #0
}
   28716:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   28718:	200c      	movs	r0, #12
   2871a:	e7fc      	b.n	28716 <ll_terminate_ind_send+0x1a>

0002871c <ll_feature_req_send>:
{
   2871c:	b508      	push	{r3, lr}
	conn = ll_connected_get(handle);
   2871e:	f7ff ff53 	bl	285c8 <ll_connected_get>
	if (!conn) {
   28722:	b150      	cbz	r0, 2873a <ll_feature_req_send+0x1e>
	if (conn->llcp_feature.req != conn->llcp_feature.ack) {
   28724:	f890 20b4 	ldrb.w	r2, [r0, #180]	; 0xb4
   28728:	f890 30b5 	ldrb.w	r3, [r0, #181]	; 0xb5
   2872c:	4293      	cmp	r3, r2
   2872e:	d104      	bne.n	2873a <ll_feature_req_send+0x1e>
	conn->llcp_feature.req++;
   28730:	3301      	adds	r3, #1
   28732:	f880 30b4 	strb.w	r3, [r0, #180]	; 0xb4
	return 0;
   28736:	2000      	movs	r0, #0
}
   28738:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2873a:	200c      	movs	r0, #12
   2873c:	e7fc      	b.n	28738 <ll_feature_req_send+0x1c>

0002873e <ll_version_ind_send>:
{
   2873e:	b508      	push	{r3, lr}
	conn = ll_connected_get(handle);
   28740:	f7ff ff42 	bl	285c8 <ll_connected_get>
	if (!conn) {
   28744:	b150      	cbz	r0, 2875c <ll_version_ind_send+0x1e>
	if (conn->llcp_version.req != conn->llcp_version.ack) {
   28746:	f890 20bc 	ldrb.w	r2, [r0, #188]	; 0xbc
   2874a:	f890 30bd 	ldrb.w	r3, [r0, #189]	; 0xbd
   2874e:	4293      	cmp	r3, r2
   28750:	d104      	bne.n	2875c <ll_version_ind_send+0x1e>
	conn->llcp_version.req++;
   28752:	3301      	adds	r3, #1
   28754:	f880 30bc 	strb.w	r3, [r0, #188]	; 0xbc
	return 0;
   28758:	2000      	movs	r0, #0
}
   2875a:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2875c:	200c      	movs	r0, #12
   2875e:	e7fc      	b.n	2875a <ll_version_ind_send+0x1c>

00028760 <ull_conn_lll_max_tx_octets_get>:
}
   28760:	201b      	movs	r0, #27
   28762:	4770      	bx	lr

00028764 <swi_lll_nrf5_isr>:
	mayfly_run(TICKER_USER_ID_LLL);
   28764:	2000      	movs	r0, #0
   28766:	f7ef bd31 	b.w	181cc <mayfly_run>

0002876a <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   2876a:	4668      	mov	r0, sp
   2876c:	f020 0107 	bic.w	r1, r0, #7
   28770:	468d      	mov	sp, r1
   28772:	b501      	push	{r0, lr}
	isr_radio();
   28774:	f7f5 feae 	bl	1e4d4 <isr_radio>
	ISR_DIRECT_PM();
   28778:	f7dc f952 	bl	4a20 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
   2877c:	f7dc f886 	bl	488c <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   28780:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   28784:	4685      	mov	sp, r0
   28786:	4770      	bx	lr

00028788 <lll_reset>:
}
   28788:	2000      	movs	r0, #0
   2878a:	4770      	bx	lr

0002878c <lll_prepare>:
{
   2878c:	b513      	push	{r0, r1, r4, lr}
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
   2878e:	2400      	movs	r4, #0
   28790:	9401      	str	r4, [sp, #4]
   28792:	9c04      	ldr	r4, [sp, #16]
   28794:	9400      	str	r4, [sp, #0]
   28796:	f7f4 f9d3 	bl	1cb40 <prepare>
}
   2879a:	b002      	add	sp, #8
   2879c:	bd10      	pop	{r4, pc}

0002879e <lll_prepare_done>:
}
   2879e:	2000      	movs	r0, #0
   287a0:	4770      	bx	lr

000287a2 <lll_evt_offset_get>:
{
   287a2:	4603      	mov	r3, r0
   287a4:	e9d0 2000 	ldrd	r2, r0, [r0]
	} else if (evt->ticks_xtal_to_start & XON_BITMASK) {
   287a8:	2a00      	cmp	r2, #0
   287aa:	da04      	bge.n	287b6 <lll_evt_offset_get+0x14>
		return MAX(evt->ticks_active_to_start,
   287ac:	689b      	ldr	r3, [r3, #8]
   287ae:	4298      	cmp	r0, r3
   287b0:	bf38      	it	cc
   287b2:	4618      	movcc	r0, r3
   287b4:	4770      	bx	lr
		return MAX(evt->ticks_active_to_start,
   287b6:	4290      	cmp	r0, r2
   287b8:	bf38      	it	cc
   287ba:	4610      	movcc	r0, r2
}
   287bc:	4770      	bx	lr

000287be <lll_preempt_calc>:
{
   287be:	b510      	push	{r4, lr}
   287c0:	4614      	mov	r4, r2
	u32_t ticks_now = ticker_ticks_now_get();
   287c2:	f7ff fd96 	bl	282f2 <ticker_ticks_now_get>
	diff = ticker_ticks_diff_get(ticks_now, ticks_at_event);
   287c6:	4621      	mov	r1, r4
   287c8:	f7ff fd95 	bl	282f6 <ticker_ticks_diff_get>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
   287cc:	3003      	adds	r0, #3
	if (!(diff & BIT(HAL_TICKER_CNTR_MSBIT)) &&
   287ce:	0203      	lsls	r3, r0, #8
   287d0:	d404      	bmi.n	287dc <lll_preempt_calc+0x1e>
   287d2:	2809      	cmp	r0, #9
   287d4:	bf94      	ite	ls
   287d6:	2000      	movls	r0, #0
   287d8:	2001      	movhi	r0, #1
}
   287da:	bd10      	pop	{r4, pc}
	return 0;
   287dc:	2000      	movs	r0, #0
   287de:	e7fc      	b.n	287da <lll_preempt_calc+0x1c>

000287e0 <lll_radio_is_idle>:
	return radio_is_idle();
   287e0:	f7f5 bf88 	b.w	1e6f4 <radio_is_idle>

000287e4 <clock_ready>:
	return err;
}

static void clock_ready(struct device *dev, clock_control_subsys_t subsys,
			void *user_data)
{
   287e4:	4610      	mov	r0, r2
   287e6:	f7f9 bf63 	b.w	226b0 <z_impl_k_sem_give>

000287ea <isr_race>:
	radio_status_reset();
   287ea:	f7f5 bf63 	b.w	1e6b4 <radio_status_reset>

000287ee <isr_abort>:
{
   287ee:	b510      	push	{r4, lr}
   287f0:	4604      	mov	r4, r0
	radio_status_reset();
   287f2:	f7f5 ff5f 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   287f6:	f7f6 f80d 	bl	1e814 <radio_tmr_status_reset>
	radio_filter_status_reset();
   287fa:	f7f5 fff3 	bl	1e7e4 <radio_filter_status_reset>
	radio_ar_status_reset();
   287fe:	f7f6 f91f 	bl	1ea40 <radio_ar_status_reset>
	radio_rssi_status_reset();
   28802:	f7f5 ffd3 	bl	1e7ac <radio_rssi_status_reset>
	radio_filter_disable();
   28806:	f7f5 ffe3 	bl	1e7d0 <radio_filter_disable>
	isr_cleanup(param);
   2880a:	4620      	mov	r0, r4
}
   2880c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   28810:	f7f4 bb7a 	b.w	1cf08 <isr_cleanup>

00028814 <isr_rx_ci_adva_check>:
		       BDADDR_SIZE);
}

static inline bool isr_rx_ci_adva_check(struct pdu_adv *adv,
					struct pdu_adv *ci)
{
   28814:	b570      	push	{r4, r5, r6, lr}
	return (adv->tx_addr == ci->rx_addr) &&
   28816:	7804      	ldrb	r4, [r0, #0]
   28818:	780a      	ldrb	r2, [r1, #0]
   2881a:	f3c4 1380 	ubfx	r3, r4, #6, #1
   2881e:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   28822:	d119      	bne.n	28858 <isr_rx_ci_adva_check+0x44>
   28824:	f004 040f 	and.w	r4, r4, #15
   28828:	2c01      	cmp	r4, #1
   2882a:	f100 0502 	add.w	r5, r0, #2
   2882e:	f101 0608 	add.w	r6, r1, #8
   28832:	d008      	beq.n	28846 <isr_rx_ci_adva_check+0x32>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
			 BDADDR_SIZE)) ||
		 (!memcmp(adv->adv_ind.addr, ci->connect_ind.adv_addr,
   28834:	2206      	movs	r2, #6
   28836:	4631      	mov	r1, r6
   28838:	4628      	mov	r0, r5
   2883a:	f7fd fa25 	bl	25c88 <memcmp>
			 BDADDR_SIZE)) ||
   2883e:	fab0 f080 	clz	r0, r0
   28842:	0940      	lsrs	r0, r0, #5
			  BDADDR_SIZE)));
}
   28844:	bd70      	pop	{r4, r5, r6, pc}
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
   28846:	2206      	movs	r2, #6
   28848:	4631      	mov	r1, r6
   2884a:	4628      	mov	r0, r5
   2884c:	f7fd fa1c 	bl	25c88 <memcmp>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
   28850:	2800      	cmp	r0, #0
   28852:	d1ef      	bne.n	28834 <isr_rx_ci_adva_check+0x20>
	return (adv->tx_addr == ci->rx_addr) &&
   28854:	4620      	mov	r0, r4
   28856:	e7f5      	b.n	28844 <isr_rx_ci_adva_check+0x30>
   28858:	2000      	movs	r0, #0
   2885a:	e7f3      	b.n	28844 <isr_rx_ci_adva_check+0x30>

0002885c <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   2885c:	68c3      	ldr	r3, [r0, #12]
{
   2885e:	b570      	push	{r4, r5, r6, lr}
   28860:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   28862:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   28864:	f7ff fd45 	bl	282f2 <ticker_ticks_now_get>
   28868:	4605      	mov	r5, r0
   2886a:	4630      	mov	r0, r6
   2886c:	f7ff ff99 	bl	287a2 <lll_evt_offset_get>
	p->remainder = 0;
   28870:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   28872:	1a2d      	subs	r5, r5, r0
   28874:	6025      	str	r5, [r4, #0]
	p->remainder = 0;
   28876:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   28878:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
   2887a:	4620      	mov	r0, r4
}
   2887c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
   28880:	f7f4 bd96 	b.w	1d3b0 <prepare_cb>

00028884 <isr_done>:
{
   28884:	b510      	push	{r4, lr}
   28886:	4604      	mov	r4, r0
	radio_status_reset();
   28888:	f7f5 ff14 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   2888c:	f7f5 ffc2 	bl	1e814 <radio_tmr_status_reset>
	radio_filter_status_reset();
   28890:	f7f5 ffa8 	bl	1e7e4 <radio_filter_status_reset>
	radio_ar_status_reset();
   28894:	f7f6 f8d4 	bl	1ea40 <radio_ar_status_reset>
	radio_rssi_status_reset();
   28898:	f7f5 ff88 	bl	1e7ac <radio_rssi_status_reset>
	if (!IS_ENABLED(CONFIG_BT_CTLR_LOW_LAT) && lll->is_hdcd &&
   2889c:	7b23      	ldrb	r3, [r4, #12]
   2889e:	f003 0271 	and.w	r2, r3, #113	; 0x71
   288a2:	2a01      	cmp	r2, #1
		lll->chan_map_curr = lll->chan_map;
   288a4:	bf02      	ittt	eq
   288a6:	f3c3 0242 	ubfxeq	r2, r3, #1, #3
   288aa:	f362 1306 	bfieq	r3, r2, #4, #3
   288ae:	7323      	strbeq	r3, [r4, #12]
	if (lll->chan_map_curr) {
   288b0:	7b23      	ldrb	r3, [r4, #12]
   288b2:	f013 0f70 	tst.w	r3, #112	; 0x70
   288b6:	d008      	beq.n	288ca <isr_done+0x46>
		chan_prepare(lll);
   288b8:	4620      	mov	r0, r4
   288ba:	f7f4 fd0f 	bl	1d2dc <chan_prepare>
		radio_tx_enable();
   288be:	f7f5 fee1 	bl	1e684 <radio_tx_enable>
}
   288c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
   288c6:	f7f6 b8a1 	b.w	1ea0c <radio_tmr_end_capture>
	radio_filter_disable();
   288ca:	f7f5 ff81 	bl	1e7d0 <radio_filter_disable>
	isr_cleanup(param);
   288ce:	4620      	mov	r0, r4
}
   288d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   288d4:	f7f4 bb18 	b.w	1cf08 <isr_cleanup>

000288d8 <lll_adv_init>:
}
   288d8:	2000      	movs	r0, #0
   288da:	4770      	bx	lr

000288dc <lll_adv_reset>:
   288dc:	2000      	movs	r0, #0
   288de:	4770      	bx	lr

000288e0 <isr_race>:
	radio_status_reset();
   288e0:	f7f5 bee8 	b.w	1e6b4 <radio_status_reset>

000288e4 <isr_done>:
{
   288e4:	b508      	push	{r3, lr}
	isr_common_done(param);
   288e6:	f7f4 fef3 	bl	1d6d0 <isr_common_done>
	radio_rx_enable();
   288ea:	f7f5 fec5 	bl	1e678 <radio_rx_enable>
}
   288ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
   288f2:	f7f6 b88b 	b.w	1ea0c <radio_tmr_end_capture>

000288f6 <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   288f6:	68c3      	ldr	r3, [r0, #12]
{
   288f8:	b570      	push	{r4, r5, r6, lr}
   288fa:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   288fc:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   288fe:	f7ff fcf8 	bl	282f2 <ticker_ticks_now_get>
   28902:	4605      	mov	r5, r0
   28904:	4630      	mov	r0, r6
   28906:	f7ff ff4c 	bl	287a2 <lll_evt_offset_get>
	p->remainder = 0;
   2890a:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   2890c:	1a2d      	subs	r5, r5, r0
   2890e:	6025      	str	r5, [r4, #0]
	p->remainder = 0;
   28910:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   28912:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
   28914:	4620      	mov	r0, r4
}
   28916:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
   2891a:	f7f4 be0b 	b.w	1d534 <prepare_cb>

0002891e <isr_window>:
{
   2891e:	b508      	push	{r3, lr}
	isr_common_done(param);
   28920:	f7f4 fed6 	bl	1d6d0 <isr_common_done>
	ticks_at_start = ticker_ticks_now_get() +
   28924:	f7ff fce5 	bl	282f2 <ticker_ticks_now_get>
	remainder_us = radio_tmr_start_tick(0, ticks_at_start);
   28928:	1cc1      	adds	r1, r0, #3
   2892a:	2000      	movs	r0, #0
   2892c:	f7f5 fffe 	bl	1e92c <radio_tmr_start_tick>
}
   28930:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
   28934:	f7f6 b86a 	b.w	1ea0c <radio_tmr_end_capture>

00028938 <isr_abort>:
{
   28938:	b513      	push	{r0, r1, r4, lr}
   2893a:	4604      	mov	r4, r0
	radio_status_reset();
   2893c:	f7f5 feba 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   28940:	f7f5 ff68 	bl	1e814 <radio_tmr_status_reset>
	radio_filter_status_reset();
   28944:	f7f5 ff4e 	bl	1e7e4 <radio_filter_status_reset>
	radio_ar_status_reset();
   28948:	f7f6 f87a 	bl	1ea40 <radio_ar_status_reset>
	radio_rssi_status_reset();
   2894c:	f7f5 ff2e 	bl	1e7ac <radio_rssi_status_reset>
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   28950:	2300      	movs	r3, #0
   28952:	9300      	str	r3, [sp, #0]
   28954:	2203      	movs	r2, #3
   28956:	4619      	mov	r1, r3
   28958:	4618      	mov	r0, r3
   2895a:	f7f0 fa11 	bl	18d80 <ticker_stop>
	radio_disable();
   2895e:	f7f5 fe97 	bl	1e690 <radio_disable>
	isr_cleanup(param);
   28962:	4620      	mov	r0, r4
}
   28964:	b002      	add	sp, #8
   28966:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   2896a:	f7f4 bfc9 	b.w	1d900 <isr_cleanup>

0002896e <isr_rx_scan_report.isra.0>:
			&srsp->scan_rsp.addr[0], BDADDR_SIZE) == 0));
}

static u32_t isr_rx_scan_report(struct lll_scan *lll, u8_t rssi_ready,
   2896e:	b538      	push	{r3, r4, r5, lr}
   28970:	4605      	mov	r5, r0
				u8_t rl_idx, bool dir_report)
{
	struct node_rx_pdu *node_rx;
	struct pdu_adv *pdu_adv_rx;

	node_rx = ull_pdu_rx_alloc_peek(3);
   28972:	2003      	movs	r0, #3
   28974:	f7f1 fed4 	bl	1a720 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
   28978:	4604      	mov	r4, r0
   2897a:	b1b0      	cbz	r0, 289aa <isr_rx_scan_report.isra.0+0x3c>
		return 1;
	}
	ull_pdu_rx_alloc();
   2897c:	f7f1 fee8 	bl	1a750 <ull_pdu_rx_alloc>

	/* Prepare the report (adv or scan resp) */
	node_rx->hdr.handle = 0xffff;
   28980:	f64f 73ff 	movw	r3, #65535	; 0xffff
   28984:	80e3      	strh	r3, [r4, #6]
			LL_ASSERT(0);
			break;
		}
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
   28986:	2304      	movs	r3, #4
   28988:	7123      	strb	r3, [r4, #4]
	}

	pdu_adv_rx = (void *)node_rx->pdu;

	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
   2898a:	b165      	cbz	r5, 289a6 <isr_rx_scan_report.isra.0+0x38>
				   (radio_rssi_get() & 0x7f)
   2898c:	f7f5 ff08 	bl	1e7a0 <radio_rssi_get>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
   28990:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   28994:	7720      	strb	r0, [r4, #28]
		node_rx->hdr.rx_ftr.chan = _radio.scanner.chan - 1;
		node_rx->hdr.rx_ftr.ticks_anchor = _radio.ticks_anchor;
	}
#endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */

	ull_rx_put(node_rx->hdr.link, node_rx);
   28996:	4621      	mov	r1, r4
   28998:	6820      	ldr	r0, [r4, #0]
   2899a:	f7f1 feef 	bl	1a77c <ull_rx_put>
	ull_rx_sched();
   2899e:	f7f1 fefd 	bl	1a79c <ull_rx_sched>

	return 0;
   289a2:	2000      	movs	r0, #0
}
   289a4:	bd38      	pop	{r3, r4, r5, pc}
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
   289a6:	207f      	movs	r0, #127	; 0x7f
   289a8:	e7f4      	b.n	28994 <isr_rx_scan_report.isra.0+0x26>
		return 1;
   289aa:	2001      	movs	r0, #1
   289ac:	e7fa      	b.n	289a4 <isr_rx_scan_report.isra.0+0x36>

000289ae <lll_scan_init>:
}
   289ae:	2000      	movs	r0, #0
   289b0:	4770      	bx	lr

000289b2 <lll_scan_reset>:
   289b2:	2000      	movs	r0, #0
   289b4:	4770      	bx	lr

000289b6 <isr_race>:
	radio_status_reset();
   289b6:	f7f5 be7d 	b.w	1e6b4 <radio_status_reset>

000289ba <empty_tx_enqueue>:

	return 0;
}

static struct pdu_data *empty_tx_enqueue(struct lll_conn *lll)
{
   289ba:	b538      	push	{r3, r4, r5, lr}
	struct pdu_data *p;

	lll->empty = 1;
   289bc:	f890 3056 	ldrb.w	r3, [r0, #86]	; 0x56
   289c0:	f043 0304 	orr.w	r3, r3, #4
   289c4:	f880 3056 	strb.w	r3, [r0, #86]	; 0x56
{
   289c8:	4605      	mov	r5, r0

	p = (void *)radio_pkt_empty_get();
   289ca:	f7f5 feb3 	bl	1e734 <radio_pkt_empty_get>
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   289ce:	7803      	ldrb	r3, [r0, #0]
   289d0:	2201      	movs	r2, #1
   289d2:	f362 0301 	bfi	r3, r2, #0, #2
	p->len = 0;
   289d6:	2200      	movs	r2, #0
   289d8:	7042      	strb	r2, [r0, #1]
	p = (void *)radio_pkt_empty_get();
   289da:	4604      	mov	r4, r0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   289dc:	7003      	strb	r3, [r0, #0]
	if (memq_peek(lll->memq_tx.head, lll->memq_tx.tail, NULL)) {
   289de:	e9d5 0110 	ldrd	r0, r1, [r5, #64]	; 0x40
   289e2:	f7ff fbb4 	bl	2814e <memq_peek>
   289e6:	7823      	ldrb	r3, [r4, #0]
   289e8:	3800      	subs	r0, #0
   289ea:	bf18      	it	ne
   289ec:	2001      	movne	r0, #1
   289ee:	f360 1304 	bfi	r3, r0, #4, #1
   289f2:	7023      	strb	r3, [r4, #0]
	} else {
		p->md = 0;
	}

	return p;
}
   289f4:	4620      	mov	r0, r4
   289f6:	bd38      	pop	{r3, r4, r5, pc}

000289f8 <lll_conn_init>:
}
   289f8:	2000      	movs	r0, #0
   289fa:	4770      	bx	lr

000289fc <lll_conn_reset>:
   289fc:	2000      	movs	r0, #0
   289fe:	4770      	bx	lr

00028a00 <lll_conn_ppm_local_get>:
}
   28a00:	2014      	movs	r0, #20
   28a02:	4770      	bx	lr

00028a04 <lll_conn_is_abort_cb>:
}
   28a04:	f06f 0047 	mvn.w	r0, #71	; 0x47
   28a08:	4770      	bx	lr

00028a0a <lll_conn_isr_abort>:
{
   28a0a:	b510      	push	{r4, lr}
   28a0c:	4604      	mov	r4, r0
	radio_status_reset();
   28a0e:	f7f5 fe51 	bl	1e6b4 <radio_status_reset>
	radio_tmr_status_reset();
   28a12:	f7f5 feff 	bl	1e814 <radio_tmr_status_reset>
	radio_filter_status_reset();
   28a16:	f7f5 fee5 	bl	1e7e4 <radio_filter_status_reset>
	radio_ar_status_reset();
   28a1a:	f7f6 f811 	bl	1ea40 <radio_ar_status_reset>
	radio_rssi_status_reset();
   28a1e:	f7f5 fec5 	bl	1e7ac <radio_rssi_status_reset>
	isr_cleanup(param);
   28a22:	4620      	mov	r0, r4
}
   28a24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   28a28:	f7f5 b8f2 	b.w	1dc10 <isr_cleanup>

00028a2c <lll_conn_tx_pkt_set>:
{
   28a2c:	b510      	push	{r4, lr}
   28a2e:	460c      	mov	r4, r1
	radio_phy_set(phy, flags);
   28a30:	2100      	movs	r1, #0
   28a32:	4608      	mov	r0, r1
   28a34:	f7f5 fda2 	bl	1e57c <radio_phy_set>
		radio_pkt_configure(8, max_tx_octets, (phy << 1) | 0x01);
   28a38:	2008      	movs	r0, #8
   28a3a:	2201      	movs	r2, #1
   28a3c:	211b      	movs	r1, #27
   28a3e:	f7f5 fde3 	bl	1e608 <radio_pkt_configure>
		radio_pkt_tx_set(pdu_data_tx);
   28a42:	4620      	mov	r0, r4
}
   28a44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_pkt_tx_set(pdu_data_tx);
   28a48:	f7f5 be10 	b.w	1e66c <radio_pkt_tx_set>

00028a4c <lll_conn_pdu_tx_prep>:
	if (lll->empty) {
   28a4c:	f890 3056 	ldrb.w	r3, [r0, #86]	; 0x56
   28a50:	075b      	lsls	r3, r3, #29
{
   28a52:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   28a56:	4604      	mov	r4, r0
   28a58:	4688      	mov	r8, r1
	if (lll->empty) {
   28a5a:	d506      	bpl.n	28a6a <lll_conn_pdu_tx_prep+0x1e>
		*pdu_data_tx = empty_tx_enqueue(lll);
   28a5c:	f7ff ffad 	bl	289ba <empty_tx_enqueue>
   28a60:	f8c8 0000 	str.w	r0, [r8]
}
   28a64:	b003      	add	sp, #12
   28a66:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
   28a6a:	e9d0 0110 	ldrd	r0, r1, [r0, #64]	; 0x40
   28a6e:	aa01      	add	r2, sp, #4
   28a70:	f7ff fb6d 	bl	2814e <memq_peek>
	if (!link) {
   28a74:	4681      	mov	r9, r0
   28a76:	b960      	cbnz	r0, 28a92 <lll_conn_pdu_tx_prep+0x46>
		p = empty_tx_enqueue(lll);
   28a78:	4620      	mov	r0, r4
   28a7a:	f7ff ff9e 	bl	289ba <empty_tx_enqueue>
   28a7e:	4605      	mov	r5, r0
	p->rfu = 0U;
   28a80:	782b      	ldrb	r3, [r5, #0]
   28a82:	f36f 1347 	bfc	r3, #5, #3
   28a86:	702b      	strb	r3, [r5, #0]
	p->resv = 0U;
   28a88:	2300      	movs	r3, #0
   28a8a:	70ab      	strb	r3, [r5, #2]
	*pdu_data_tx = p;
   28a8c:	f8c8 5000 	str.w	r5, [r8]
   28a90:	e7e8      	b.n	28a64 <lll_conn_pdu_tx_prep+0x18>
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   28a92:	9f01      	ldr	r7, [sp, #4]
   28a94:	f894 6055 	ldrb.w	r6, [r4, #85]	; 0x55
		if (!lll->packet_tx_head_len) {
   28a98:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   28a9c:	3704      	adds	r7, #4
   28a9e:	19bd      	adds	r5, r7, r6
		if (!lll->packet_tx_head_len) {
   28aa0:	b913      	cbnz	r3, 28aa8 <lll_conn_pdu_tx_prep+0x5c>
			lll->packet_tx_head_len = p->len;
   28aa2:	786b      	ldrb	r3, [r5, #1]
   28aa4:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
		if (lll->packet_tx_head_offset) {
   28aa8:	b126      	cbz	r6, 28ab4 <lll_conn_pdu_tx_prep+0x68>
			p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   28aaa:	5dbb      	ldrb	r3, [r7, r6]
   28aac:	2201      	movs	r2, #1
   28aae:	f362 0301 	bfi	r3, r2, #0, #2
   28ab2:	55bb      	strb	r3, [r7, r6]
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
   28ab4:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
   28ab8:	1b9b      	subs	r3, r3, r6
   28aba:	706b      	strb	r3, [r5, #1]
		p->md = 0;
   28abc:	5dbb      	ldrb	r3, [r7, r6]
   28abe:	f36f 1304 	bfc	r3, #4, #1
   28ac2:	55bb      	strb	r3, [r7, r6]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
   28ac4:	4620      	mov	r0, r4
   28ac6:	f7ff fe4b 	bl	28760 <ull_conn_lll_max_tx_octets_get>
		if (p->len > max_tx_octets) {
   28aca:	786b      	ldrb	r3, [r5, #1]
   28acc:	4283      	cmp	r3, r0
			p->len = max_tx_octets;
   28ace:	bf84      	itt	hi
   28ad0:	7068      	strbhi	r0, [r5, #1]
			p->md = 1;
   28ad2:	5dbb      	ldrbhi	r3, [r7, r6]
		if (link->next != lll->memq_tx.tail) {
   28ad4:	f8d9 2000 	ldr.w	r2, [r9]
			p->md = 1;
   28ad8:	bf84      	itt	hi
   28ada:	f043 0310 	orrhi.w	r3, r3, #16
   28ade:	55bb      	strbhi	r3, [r7, r6]
		if (link->next != lll->memq_tx.tail) {
   28ae0:	6c63      	ldr	r3, [r4, #68]	; 0x44
   28ae2:	429a      	cmp	r2, r3
			p->md = 1;
   28ae4:	bf1e      	ittt	ne
   28ae6:	5dbb      	ldrbne	r3, [r7, r6]
   28ae8:	f043 0310 	orrne.w	r3, r3, #16
   28aec:	55bb      	strbne	r3, [r7, r6]
   28aee:	e7c7      	b.n	28a80 <lll_conn_pdu_tx_prep+0x34>

00028af0 <lll_conn_flush>:

void lll_conn_flush(u16_t handle, struct lll_conn *lll)
{
	/* Nothing to be flushed */
}
   28af0:	4770      	bx	lr

00028af2 <ecb_encrypt_be>:

void ecb_encrypt_be(u8_t const *const key_be, u8_t const *const clear_text_be,
		    u8_t * const cipher_text_be)
{
   28af2:	b530      	push	{r4, r5, lr}
   28af4:	b08d      	sub	sp, #52	; 0x34
   28af6:	460d      	mov	r5, r1
   28af8:	4614      	mov	r4, r2
	struct ecb_param ecb;

	memcpy(&ecb.key[0], key_be, sizeof(ecb.key));
   28afa:	4601      	mov	r1, r0
   28afc:	2210      	movs	r2, #16
   28afe:	4668      	mov	r0, sp
   28b00:	f7fd f8d2 	bl	25ca8 <memcpy>
	memcpy(&ecb.clear_text[0], clear_text_be, sizeof(ecb.clear_text));
   28b04:	2210      	movs	r2, #16
   28b06:	4629      	mov	r1, r5
   28b08:	eb0d 0002 	add.w	r0, sp, r2
   28b0c:	f7fd f8cc 	bl	25ca8 <memcpy>

	do_ecb(&ecb);
   28b10:	4668      	mov	r0, sp
   28b12:	f7f5 fc3d 	bl	1e390 <do_ecb>

	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
   28b16:	2210      	movs	r2, #16
   28b18:	a908      	add	r1, sp, #32
   28b1a:	4620      	mov	r0, r4
   28b1c:	f7fd f8c4 	bl	25ca8 <memcpy>
}
   28b20:	b00d      	add	sp, #52	; 0x34
   28b22:	bd30      	pop	{r4, r5, pc}

00028b24 <ecb_encrypt>:

void ecb_encrypt(u8_t const *const key_le, u8_t const *const clear_text_le,
		 u8_t * const cipher_text_le, u8_t * const cipher_text_be)
{
   28b24:	b570      	push	{r4, r5, r6, lr}
   28b26:	b08c      	sub	sp, #48	; 0x30
   28b28:	460e      	mov	r6, r1
   28b2a:	4615      	mov	r5, r2
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   28b2c:	4601      	mov	r1, r0
   28b2e:	2210      	movs	r2, #16
   28b30:	4668      	mov	r0, sp
{
   28b32:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   28b34:	f7ff fadc 	bl	280f0 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
   28b38:	2210      	movs	r2, #16
   28b3a:	eb0d 0002 	add.w	r0, sp, r2
   28b3e:	4631      	mov	r1, r6
   28b40:	f7ff fad6 	bl	280f0 <mem_rcopy>

	do_ecb(&ecb);
   28b44:	4668      	mov	r0, sp
   28b46:	f7f5 fc23 	bl	1e390 <do_ecb>

	if (cipher_text_le) {
   28b4a:	b125      	cbz	r5, 28b56 <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
   28b4c:	2210      	movs	r2, #16
   28b4e:	a908      	add	r1, sp, #32
   28b50:	4628      	mov	r0, r5
   28b52:	f7ff facd 	bl	280f0 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
   28b56:	b124      	cbz	r4, 28b62 <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
   28b58:	2210      	movs	r2, #16
   28b5a:	a908      	add	r1, sp, #32
   28b5c:	4620      	mov	r0, r4
   28b5e:	f7fd f8a3 	bl	25ca8 <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
   28b62:	b00c      	add	sp, #48	; 0x30
   28b64:	bd70      	pop	{r4, r5, r6, pc}

00028b66 <radio_tx_chain_delay_get>:
}
   28b66:	2001      	movs	r0, #1
   28b68:	4770      	bx	lr

00028b6a <radio_rx_ready_delay_get>:
}
   28b6a:	2029      	movs	r0, #41	; 0x29
   28b6c:	4770      	bx	lr

00028b6e <radio_rx_chain_delay_get>:
	switch (phy) {
   28b6e:	2802      	cmp	r0, #2
}
   28b70:	bf14      	ite	ne
   28b72:	200a      	movne	r0, #10
   28b74:	2005      	moveq	r0, #5
   28b76:	4770      	bx	lr

00028b78 <mayfly_prio_is_equal>:
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   28b78:	4288      	cmp	r0, r1
   28b7a:	d00c      	beq.n	28b96 <mayfly_prio_is_equal+0x1e>
	return (caller_id == callee_id) ||
   28b7c:	b978      	cbnz	r0, 28b9e <mayfly_prio_is_equal+0x26>
	       ((caller_id == MAYFLY_CALL_ID_LLL) &&
   28b7e:	1e48      	subs	r0, r1, #1
   28b80:	2801      	cmp	r0, #1
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   28b82:	bf8c      	ite	hi
   28b84:	2000      	movhi	r0, #0
   28b86:	2001      	movls	r0, #1
   28b88:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
   28b8a:	f011 0ffd 	tst.w	r1, #253	; 0xfd
   28b8e:	bf0c      	ite	eq
   28b90:	2001      	moveq	r0, #1
   28b92:	2000      	movne	r0, #0
   28b94:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   28b96:	2001      	movs	r0, #1
   28b98:	4770      	bx	lr
   28b9a:	2000      	movs	r0, #0
}
   28b9c:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   28b9e:	2801      	cmp	r0, #1
   28ba0:	d0f3      	beq.n	28b8a <mayfly_prio_is_equal+0x12>
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
   28ba2:	2802      	cmp	r0, #2
   28ba4:	d1f9      	bne.n	28b9a <mayfly_prio_is_equal+0x22>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   28ba6:	2901      	cmp	r1, #1
   28ba8:	e7eb      	b.n	28b82 <mayfly_prio_is_equal+0xa>

00028baa <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(u32_t value)
{
   28baa:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
   28bac:	2000      	movs	r0, #0
   28bae:	f7f5 bbe7 	b.w	1e380 <cntr_cmp_set>

00028bb2 <sys_put_le32>:
	dst[1] = val >> 8;
   28bb2:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   28bb6:	7008      	strb	r0, [r1, #0]
	sys_put_le16(val >> 16, &dst[2]);
   28bb8:	0c00      	lsrs	r0, r0, #16
	dst[0] = val;
   28bba:	7088      	strb	r0, [r1, #2]
	dst[1] = val >> 8;
   28bbc:	0a00      	lsrs	r0, r0, #8
   28bbe:	704b      	strb	r3, [r1, #1]
   28bc0:	70c8      	strb	r0, [r1, #3]
}
   28bc2:	4770      	bx	lr

00028bc4 <hci_vendor_read_static_addr>:
				 u8_t size)
{
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   28bc4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
{
   28bc8:	b510      	push	{r4, lr}
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   28bca:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
   28bce:	3201      	adds	r2, #1
{
   28bd0:	4604      	mov	r4, r0
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   28bd2:	d106      	bne.n	28be2 <hci_vendor_read_static_addr+0x1e>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   28bd4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   28bd8:	f64f 72ff 	movw	r2, #65535	; 0xffff
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   28bdc:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   28bde:	4293      	cmp	r3, r2
   28be0:	d044      	beq.n	28c6c <hci_vendor_read_static_addr+0xa8>
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
   28be2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   28be6:	f8d2 00a0 	ldr.w	r0, [r2, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   28bea:	f010 0001 	ands.w	r0, r0, #1
   28bee:	d036      	beq.n	28c5e <hci_vendor_read_static_addr+0x9a>
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
   28bf0:	4621      	mov	r1, r4
   28bf2:	f8d2 00a4 	ldr.w	r0, [r2, #164]	; 0xa4
   28bf6:	f7ff ffdc 	bl	28bb2 <sys_put_le32>
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
   28bfa:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
	dst[0] = val;
   28bfe:	7123      	strb	r3, [r4, #4]
	dst[1] = val >> 8;
   28c00:	f3c3 2307 	ubfx	r3, r3, #8, #8

		/* The FICR value is a just a random number, with no knowledge
		 * of the Bluetooth Specification requirements for random
		 * static addresses.
		 */
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
   28c04:	f063 033f 	orn	r3, r3, #63	; 0x3f
   28c08:	7163      	strb	r3, [r4, #5]

		/* If no public address is provided and a static address is
		 * available, then it is recommended to return an identity root
		 * key (if available) from this command.
		 */
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   28c0a:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
   28c0e:	3101      	adds	r1, #1
   28c10:	f104 0306 	add.w	r3, r4, #6
   28c14:	d024      	beq.n	28c60 <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   28c16:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   28c1a:	3101      	adds	r1, #1
   28c1c:	d020      	beq.n	28c60 <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   28c1e:	f8d2 1098 	ldr.w	r1, [r2, #152]	; 0x98
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   28c22:	3101      	adds	r1, #1
   28c24:	d01c      	beq.n	28c60 <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
   28c26:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   28c2a:	3101      	adds	r1, #1
   28c2c:	d018      	beq.n	28c60 <hci_vendor_read_static_addr+0x9c>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
   28c2e:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
   28c32:	4619      	mov	r1, r3
   28c34:	f7ff ffbd 	bl	28bb2 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
   28c38:	f104 010a 	add.w	r1, r4, #10
   28c3c:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
   28c40:	f7ff ffb7 	bl	28bb2 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
   28c44:	f104 010e 	add.w	r1, r4, #14
   28c48:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
   28c4c:	f7ff ffb1 	bl	28bb2 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
   28c50:	f104 0112 	add.w	r1, r4, #18
   28c54:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
   28c58:	f7ff ffab 	bl	28bb2 <sys_put_le32>
		} else {
			/* Mark IR as invalid */
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
		}

		return 1;
   28c5c:	2001      	movs	r0, #1
	}

	return 0;
}
   28c5e:	bd10      	pop	{r4, pc}
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
   28c60:	2210      	movs	r2, #16
   28c62:	2100      	movs	r1, #0
   28c64:	4618      	mov	r0, r3
   28c66:	f7fd f84a 	bl	25cfe <memset>
   28c6a:	e7f7      	b.n	28c5c <hci_vendor_read_static_addr+0x98>
	return 0;
   28c6c:	2000      	movs	r0, #0
   28c6e:	e7f6      	b.n	28c5e <hci_vendor_read_static_addr+0x9a>

00028c70 <hci_vendor_read_key_hierarchy_roots>:

void hci_vendor_read_key_hierarchy_roots(u8_t ir[16], u8_t er[16])
{
   28c70:	b510      	push	{r4, lr}
	/* Mark IR as invalid.
	 * No public address is available, and static address IR should be read
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);
   28c72:	2210      	movs	r2, #16
{
   28c74:	460c      	mov	r4, r1
	(void)memset(ir, 0x00, 16);
   28c76:	2100      	movs	r1, #0
   28c78:	f7fd f841 	bl	25cfe <memset>

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   28c7c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   28c80:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
   28c84:	3301      	adds	r3, #1
   28c86:	d023      	beq.n	28cd0 <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   28c88:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   28c8c:	3301      	adds	r3, #1
   28c8e:	d01f      	beq.n	28cd0 <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   28c90:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   28c94:	3301      	adds	r3, #1
   28c96:	d01b      	beq.n	28cd0 <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
   28c98:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   28c9c:	3301      	adds	r3, #1
   28c9e:	d017      	beq.n	28cd0 <hci_vendor_read_key_hierarchy_roots+0x60>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
   28ca0:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
   28ca4:	4621      	mov	r1, r4
   28ca6:	f7ff ff84 	bl	28bb2 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
   28caa:	1d21      	adds	r1, r4, #4
   28cac:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
   28cb0:	f7ff ff7f 	bl	28bb2 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
   28cb4:	f104 0108 	add.w	r1, r4, #8
   28cb8:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
   28cbc:	f7ff ff79 	bl	28bb2 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
   28cc0:	f104 010c 	add.w	r1, r4, #12
   28cc4:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
   28cc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
   28ccc:	f7ff bf71 	b.w	28bb2 <sys_put_le32>
		(void)memset(er, 0x00, 16);
   28cd0:	4620      	mov	r0, r4
   28cd2:	2210      	movs	r2, #16
}
   28cd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		(void)memset(er, 0x00, 16);
   28cd8:	2100      	movs	r1, #0
   28cda:	f7fd b810 	b.w	25cfe <memset>

00028cde <fixed_data_unref>:
}
   28cde:	4770      	bx	lr

00028ce0 <k_uptime_get_32>:
{
   28ce0:	b510      	push	{r4, lr}
	return z_impl_k_uptime_ticks();
   28ce2:	f000 fb96 	bl	29412 <z_impl_k_uptime_ticks>
   28ce6:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   28cea:	fba0 2304 	umull	r2, r3, r0, r4
   28cee:	fb04 3301 	mla	r3, r4, r1, r3
   28cf2:	0bd0      	lsrs	r0, r2, #15
}
   28cf4:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   28cf8:	bd10      	pop	{r4, pc}

00028cfa <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   28cfa:	69c3      	ldr	r3, [r0, #28]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   28cfc:	685b      	ldr	r3, [r3, #4]
{
   28cfe:	460a      	mov	r2, r1
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   28d00:	6819      	ldr	r1, [r3, #0]
   28d02:	f7f6 b807 	b.w	1ed14 <net_buf_alloc_len>

00028d06 <net_buf_simple_init_with_data>:
	buf->size  = size;
   28d06:	b292      	uxth	r2, r2
	buf->__buf = data;
   28d08:	6081      	str	r1, [r0, #8]
	buf->data  = data;
   28d0a:	6001      	str	r1, [r0, #0]
	buf->size  = size;
   28d0c:	80c2      	strh	r2, [r0, #6]
	buf->len   = size;
   28d0e:	8082      	strh	r2, [r0, #4]
}
   28d10:	4770      	bx	lr

00028d12 <net_buf_simple_clone>:
{
   28d12:	460b      	mov	r3, r1
	memcpy(clone, original, sizeof(struct net_buf_simple));
   28d14:	220c      	movs	r2, #12
   28d16:	4601      	mov	r1, r0
   28d18:	4618      	mov	r0, r3
   28d1a:	f7fc bfc5 	b.w	25ca8 <memcpy>

00028d1e <net_buf_simple_push_be16>:
{
   28d1e:	b510      	push	{r4, lr}
   28d20:	460c      	mov	r4, r1
	sys_put_be16(val, net_buf_simple_push(buf, sizeof(val)));
   28d22:	2102      	movs	r1, #2
   28d24:	f7f6 fa74 	bl	1f210 <net_buf_simple_push>
	dst[0] = val >> 8;
   28d28:	0a23      	lsrs	r3, r4, #8
   28d2a:	7003      	strb	r3, [r0, #0]
	dst[1] = val;
   28d2c:	7044      	strb	r4, [r0, #1]
}
   28d2e:	bd10      	pop	{r4, pc}

00028d30 <net_buf_simple_push_u8>:
{
   28d30:	b510      	push	{r4, lr}
   28d32:	460c      	mov	r4, r1
	u8_t *data = net_buf_simple_push(buf, 1);
   28d34:	2101      	movs	r1, #1
   28d36:	f7f6 fa6b 	bl	1f210 <net_buf_simple_push>
	*data = val;
   28d3a:	7004      	strb	r4, [r0, #0]
}
   28d3c:	bd10      	pop	{r4, pc}

00028d3e <net_buf_simple_push_be24>:
{
   28d3e:	b510      	push	{r4, lr}
   28d40:	460c      	mov	r4, r1
	sys_put_be24(val, net_buf_simple_push(buf, 3));
   28d42:	2103      	movs	r1, #3
   28d44:	f7f6 fa64 	bl	1f210 <net_buf_simple_push>
	dst[0] = val >> 16;
   28d48:	0c23      	lsrs	r3, r4, #16
   28d4a:	7003      	strb	r3, [r0, #0]
	dst[0] = val >> 8;
   28d4c:	f3c4 2307 	ubfx	r3, r4, #8, #8
   28d50:	7043      	strb	r3, [r0, #1]
	dst[1] = val;
   28d52:	7084      	strb	r4, [r0, #2]
}
   28d54:	bd10      	pop	{r4, pc}

00028d56 <net_buf_simple_pull_u8>:
{
   28d56:	b510      	push	{r4, lr}
	val = buf->data[0];
   28d58:	6803      	ldr	r3, [r0, #0]
   28d5a:	781c      	ldrb	r4, [r3, #0]
	net_buf_simple_pull(buf, 1);
   28d5c:	2101      	movs	r1, #1
   28d5e:	f7f6 fa79 	bl	1f254 <net_buf_simple_pull>
}
   28d62:	4620      	mov	r0, r4
   28d64:	bd10      	pop	{r4, pc}

00028d66 <net_buf_simple_pull_le16>:
{
   28d66:	b510      	push	{r4, lr}
	val = UNALIGNED_GET((u16_t *)buf->data);
   28d68:	6803      	ldr	r3, [r0, #0]
   28d6a:	881c      	ldrh	r4, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   28d6c:	2102      	movs	r1, #2
   28d6e:	f7f6 fa71 	bl	1f254 <net_buf_simple_pull>
}
   28d72:	4620      	mov	r0, r4
   28d74:	bd10      	pop	{r4, pc}

00028d76 <net_buf_simple_pull_be16>:
	val = UNALIGNED_GET((u16_t *)buf->data);
   28d76:	6803      	ldr	r3, [r0, #0]
{
   28d78:	b510      	push	{r4, lr}
	val = UNALIGNED_GET((u16_t *)buf->data);
   28d7a:	881c      	ldrh	r4, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   28d7c:	2102      	movs	r1, #2
   28d7e:	f7f6 fa69 	bl	1f254 <net_buf_simple_pull>
	return sys_be16_to_cpu(val);
   28d82:	0220      	lsls	r0, r4, #8
   28d84:	ea40 2014 	orr.w	r0, r0, r4, lsr #8
}
   28d88:	b280      	uxth	r0, r0
   28d8a:	bd10      	pop	{r4, pc}

00028d8c <net_buf_simple_pull_be32>:
{
   28d8c:	b510      	push	{r4, lr}
   28d8e:	6803      	ldr	r3, [r0, #0]
   28d90:	681c      	ldr	r4, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   28d92:	2104      	movs	r1, #4
   28d94:	ba24      	rev	r4, r4
   28d96:	f7f6 fa5d 	bl	1f254 <net_buf_simple_pull>
}
   28d9a:	4620      	mov	r0, r4
   28d9c:	bd10      	pop	{r4, pc}

00028d9e <net_buf_simple_headroom>:
	return buf->data - buf->__buf;
   28d9e:	6802      	ldr	r2, [r0, #0]
   28da0:	6880      	ldr	r0, [r0, #8]
}
   28da2:	1a10      	subs	r0, r2, r0
   28da4:	4770      	bx	lr

00028da6 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   28da6:	8883      	ldrh	r3, [r0, #4]
   28da8:	88c2      	ldrh	r2, [r0, #6]
   28daa:	1ad2      	subs	r2, r2, r3
	return buf->data - buf->__buf;
   28dac:	6803      	ldr	r3, [r0, #0]
   28dae:	6880      	ldr	r0, [r0, #8]
   28db0:	1a18      	subs	r0, r3, r0
}
   28db2:	1a10      	subs	r0, r2, r0
   28db4:	4770      	bx	lr

00028db6 <net_buf_simple_add_mem>:
{
   28db6:	b538      	push	{r3, r4, r5, lr}
   28db8:	460d      	mov	r5, r1
   28dba:	4614      	mov	r4, r2
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   28dbc:	4611      	mov	r1, r2
   28dbe:	f7f6 fa8b 	bl	1f2d8 <net_buf_simple_add>
   28dc2:	4622      	mov	r2, r4
   28dc4:	4629      	mov	r1, r5
}
   28dc6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   28dca:	f7fc bf6d 	b.w	25ca8 <memcpy>

00028dce <net_buf_simple_add_u8>:
{
   28dce:	b510      	push	{r4, lr}
   28dd0:	460c      	mov	r4, r1
	u8 = net_buf_simple_add(buf, 1);
   28dd2:	2101      	movs	r1, #1
   28dd4:	f7f6 fa80 	bl	1f2d8 <net_buf_simple_add>
	*u8 = val;
   28dd8:	7004      	strb	r4, [r0, #0]
}
   28dda:	bd10      	pop	{r4, pc}

00028ddc <net_buf_simple_add_le16>:
{
   28ddc:	b510      	push	{r4, lr}
   28dde:	460c      	mov	r4, r1
	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
   28de0:	2102      	movs	r1, #2
   28de2:	f7f6 fa79 	bl	1f2d8 <net_buf_simple_add>
	dst[0] = val;
   28de6:	7004      	strb	r4, [r0, #0]
	dst[1] = val >> 8;
   28de8:	0a24      	lsrs	r4, r4, #8
   28dea:	7044      	strb	r4, [r0, #1]
}
   28dec:	bd10      	pop	{r4, pc}

00028dee <net_buf_simple_add_be16>:
{
   28dee:	b510      	push	{r4, lr}
   28df0:	460c      	mov	r4, r1
	sys_put_be16(val, net_buf_simple_add(buf, sizeof(val)));
   28df2:	2102      	movs	r1, #2
   28df4:	f7f6 fa70 	bl	1f2d8 <net_buf_simple_add>
	dst[0] = val >> 8;
   28df8:	0a23      	lsrs	r3, r4, #8
   28dfa:	7003      	strb	r3, [r0, #0]
	dst[1] = val;
   28dfc:	7044      	strb	r4, [r0, #1]
}
   28dfe:	bd10      	pop	{r4, pc}

00028e00 <net_buf_simple_add_le24>:
{
   28e00:	b510      	push	{r4, lr}
   28e02:	460c      	mov	r4, r1
	sys_put_le24(val, net_buf_simple_add(buf, 3));
   28e04:	2103      	movs	r1, #3
   28e06:	f7f6 fa67 	bl	1f2d8 <net_buf_simple_add>
	dst[1] = val >> 8;
   28e0a:	f3c4 2307 	ubfx	r3, r4, #8, #8
	dst[0] = val;
   28e0e:	7004      	strb	r4, [r0, #0]
	dst[2] = val >> 16;
   28e10:	0c24      	lsrs	r4, r4, #16
	dst[1] = val >> 8;
   28e12:	7043      	strb	r3, [r0, #1]
	dst[2] = val >> 16;
   28e14:	7084      	strb	r4, [r0, #2]
}
   28e16:	bd10      	pop	{r4, pc}

00028e18 <net_buf_simple_add_be32>:
{
   28e18:	b510      	push	{r4, lr}
   28e1a:	460c      	mov	r4, r1
	sys_put_be32(val, net_buf_simple_add(buf, sizeof(val)));
   28e1c:	2104      	movs	r1, #4
   28e1e:	f7f6 fa5b 	bl	1f2d8 <net_buf_simple_add>
	sys_put_be16(val >> 16, dst);
   28e22:	0c23      	lsrs	r3, r4, #16
	dst[0] = val >> 8;
   28e24:	0e22      	lsrs	r2, r4, #24
	dst[1] = val;
   28e26:	7043      	strb	r3, [r0, #1]
	dst[0] = val >> 8;
   28e28:	f3c4 2307 	ubfx	r3, r4, #8, #8
   28e2c:	7002      	strb	r2, [r0, #0]
   28e2e:	7083      	strb	r3, [r0, #2]
	dst[1] = val;
   28e30:	70c4      	strb	r4, [r0, #3]
}
   28e32:	bd10      	pop	{r4, pc}

00028e34 <gpio_nrfx_port_get_raw>:
	return port->config->config_info;
   28e34:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   28e36:	689b      	ldr	r3, [r3, #8]
   28e38:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   28e3a:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
   28e3e:	600b      	str	r3, [r1, #0]
}
   28e40:	2000      	movs	r0, #0
   28e42:	4770      	bx	lr

00028e44 <gpio_nrfx_port_set_masked_raw>:
	return port->config->config_info;
   28e44:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   28e46:	689b      	ldr	r3, [r3, #8]
   28e48:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   28e4a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   28e4e:	4042      	eors	r2, r0
   28e50:	400a      	ands	r2, r1
   28e52:	4042      	eors	r2, r0
    p_reg->OUT = value;
   28e54:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   28e58:	2000      	movs	r0, #0
   28e5a:	4770      	bx	lr

00028e5c <gpio_nrfx_port_set_bits_raw>:
	return port->config->config_info;
   28e5c:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   28e5e:	689b      	ldr	r3, [r3, #8]
   28e60:	685b      	ldr	r3, [r3, #4]
}
   28e62:	2000      	movs	r0, #0
    p_reg->OUTSET = set_mask;
   28e64:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
   28e68:	4770      	bx	lr

00028e6a <gpio_nrfx_port_clear_bits_raw>:
	return port->config->config_info;
   28e6a:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   28e6c:	689b      	ldr	r3, [r3, #8]
   28e6e:	685b      	ldr	r3, [r3, #4]
}
   28e70:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   28e72:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
   28e76:	4770      	bx	lr

00028e78 <gpio_nrfx_port_toggle_bits>:
	return port->config->config_info;
   28e78:	6803      	ldr	r3, [r0, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   28e7a:	689b      	ldr	r3, [r3, #8]
   28e7c:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   28e7e:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value ^ mask);
   28e82:	404b      	eors	r3, r1
    p_reg->OUT = value;
   28e84:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
   28e88:	2000      	movs	r0, #0
   28e8a:	4770      	bx	lr

00028e8c <nrf_gpio_cfg_sense_set>:
{
   28e8c:	b513      	push	{r0, r1, r4, lr}
   28e8e:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   28e90:	a801      	add	r0, sp, #4
{
   28e92:	460c      	mov	r4, r1
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   28e94:	f7f6 fa42 	bl	1f31c <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   28e98:	9b01      	ldr	r3, [sp, #4]
   28e9a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   28e9e:	f8d0 3700 	ldr.w	r3, [r0, #1792]	; 0x700
   28ea2:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   28ea6:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
   28eaa:	f8c0 3700 	str.w	r3, [r0, #1792]	; 0x700
}
   28eae:	b002      	add	sp, #8
   28eb0:	bd10      	pop	{r4, pc}

00028eb2 <check_level_trigger_pins>:
	struct gpio_nrfx_data *data = get_port_data(port);
   28eb2:	6883      	ldr	r3, [r0, #8]
	return port->config->config_info;
   28eb4:	6802      	ldr	r2, [r0, #0]
{
   28eb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return port->config->config_info;
   28eba:	f8d2 8008 	ldr.w	r8, [r2, #8]
	u32_t out = data->int_en & data->pin_int_en;
   28ebe:	e9d3 2403 	ldrd	r2, r4, [r3, #12]
   28ec2:	4014      	ands	r4, r2
	out &= ~data->trig_edge & ~data->double_edge;
   28ec4:	e9d3 2106 	ldrd	r2, r1, [r3, #24]
   28ec8:	430a      	orrs	r2, r1
   28eca:	ea24 0402 	bic.w	r4, r4, r2
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   28ece:	f8d8 2004 	ldr.w	r2, [r8, #4]
	u32_t pin_states = ~(port_in ^ data->int_active_level);
   28ed2:	695b      	ldr	r3, [r3, #20]
    return p_reg->IN;
   28ed4:	f8d2 5510 	ldr.w	r5, [r2, #1296]	; 0x510
   28ed8:	405d      	eors	r5, r3
	u32_t out = pin_states & level_pins;
   28eda:	ea24 0505 	bic.w	r5, r4, r5
	u32_t bit = 1U << pin;
   28ede:	2601      	movs	r6, #1
	u32_t pin = 0U;
   28ee0:	2700      	movs	r7, #0
	while (level_pins) {
   28ee2:	b914      	cbnz	r4, 28eea <check_level_trigger_pins+0x38>
}
   28ee4:	4628      	mov	r0, r5
   28ee6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   28eea:	4234      	tst	r4, r6
   28eec:	d00a      	beq.n	28f04 <check_level_trigger_pins+0x52>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   28eee:	f898 3008 	ldrb.w	r3, [r8, #8]
   28ef2:	f007 001f 	and.w	r0, r7, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   28ef6:	2100      	movs	r1, #0
   28ef8:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   28efc:	f7ff ffc6 	bl	28e8c <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   28f00:	ea24 0406 	bic.w	r4, r4, r6
		++pin;
   28f04:	3701      	adds	r7, #1
		bit <<= 1;
   28f06:	0076      	lsls	r6, r6, #1
   28f08:	e7eb      	b.n	28ee2 <check_level_trigger_pins+0x30>

00028f0a <gpio_nrfx_pin_disable_callback>:
{
   28f0a:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
   28f0c:	6884      	ldr	r4, [r0, #8]
	WRITE_BIT(data->int_en, pin, enable);
   28f0e:	2301      	movs	r3, #1
   28f10:	fa03 f201 	lsl.w	r2, r3, r1
   28f14:	6923      	ldr	r3, [r4, #16]
   28f16:	ea23 0302 	bic.w	r3, r3, r2
   28f1a:	6123      	str	r3, [r4, #16]
}
   28f1c:	bc10      	pop	{r4}
	return gpiote_pin_int_cfg(port, pin);
   28f1e:	f7f6 bb37 	b.w	1f590 <gpiote_pin_int_cfg>

00028f22 <gpio_nrfx_pin_interrupt_configure>:
	if ((mode == GPIO_INT_MODE_EDGE) &&
   28f22:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
{
   28f26:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct gpio_nrfx_data *data = get_port_data(port);
   28f2a:	6884      	ldr	r4, [r0, #8]
{
   28f2c:	4606      	mov	r6, r0
   28f2e:	460f      	mov	r7, r1
   28f30:	4690      	mov	r8, r2
   28f32:	4699      	mov	r9, r3
	if ((mode == GPIO_INT_MODE_EDGE) &&
   28f34:	d13c      	bne.n	28fb0 <gpio_nrfx_pin_interrupt_configure+0x8e>
	return port->config->config_info;
   28f36:	6803      	ldr	r3, [r0, #0]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   28f38:	689b      	ldr	r3, [r3, #8]
   28f3a:	7a1a      	ldrb	r2, [r3, #8]
   28f3c:	f001 031f 	and.w	r3, r1, #31
   28f40:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   28f44:	a801      	add	r0, sp, #4
   28f46:	9301      	str	r3, [sp, #4]
   28f48:	f7f6 f9e8 	bl	1f31c <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   28f4c:	9b01      	ldr	r3, [sp, #4]
   28f4e:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   28f52:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	if ((mode == GPIO_INT_MODE_EDGE) &&
   28f56:	07db      	lsls	r3, r3, #31
   28f58:	d434      	bmi.n	28fc4 <gpio_nrfx_pin_interrupt_configure+0xa2>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
   28f5a:	68e3      	ldr	r3, [r4, #12]
   28f5c:	2501      	movs	r5, #1
   28f5e:	40bd      	lsls	r5, r7
   28f60:	431d      	orrs	r5, r3
   28f62:	6923      	ldr	r3, [r4, #16]
   28f64:	60e5      	str	r5, [r4, #12]
	WRITE_BIT(data->int_en, pin, mode != GPIO_INT_MODE_DISABLED);
   28f66:	2501      	movs	r5, #1
   28f68:	40bd      	lsls	r5, r7
   28f6a:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
   28f6e:	bf14      	ite	ne
   28f70:	432b      	orrne	r3, r5
   28f72:	43ab      	biceq	r3, r5
   28f74:	6123      	str	r3, [r4, #16]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
   28f76:	69a3      	ldr	r3, [r4, #24]
   28f78:	f5b8 3fa0 	cmp.w	r8, #81920	; 0x14000
   28f7c:	bf0c      	ite	eq
   28f7e:	432b      	orreq	r3, r5
   28f80:	43ab      	bicne	r3, r5
   28f82:	61a3      	str	r3, [r4, #24]
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
   28f84:	69e3      	ldr	r3, [r4, #28]
   28f86:	f5b9 2fc0 	cmp.w	r9, #393216	; 0x60000
   28f8a:	bf0c      	ite	eq
   28f8c:	432b      	orreq	r3, r5
   28f8e:	43ab      	bicne	r3, r5
   28f90:	61e3      	str	r3, [r4, #28]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
   28f92:	6963      	ldr	r3, [r4, #20]
   28f94:	f5b9 2f80 	cmp.w	r9, #262144	; 0x40000
   28f98:	bf0c      	ite	eq
   28f9a:	431d      	orreq	r5, r3
   28f9c:	ea23 0505 	bicne.w	r5, r3, r5
   28fa0:	6165      	str	r5, [r4, #20]
	return gpiote_pin_int_cfg(port, pin);
   28fa2:	4639      	mov	r1, r7
   28fa4:	4630      	mov	r0, r6
   28fa6:	f7f6 faf3 	bl	1f590 <gpiote_pin_int_cfg>
}
   28faa:	b003      	add	sp, #12
   28fac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
   28fb0:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
   28fb4:	d1d1      	bne.n	28f5a <gpio_nrfx_pin_interrupt_configure+0x38>
   28fb6:	2501      	movs	r5, #1
   28fb8:	fa05 f301 	lsl.w	r3, r5, r1
   28fbc:	68e5      	ldr	r5, [r4, #12]
   28fbe:	ea25 0503 	bic.w	r5, r5, r3
   28fc2:	e7ce      	b.n	28f62 <gpio_nrfx_pin_interrupt_configure+0x40>
		return -ENOTSUP;
   28fc4:	f06f 0022 	mvn.w	r0, #34	; 0x22
   28fc8:	e7ef      	b.n	28faa <gpio_nrfx_pin_interrupt_configure+0x88>

00028fca <cfg_level_pins>:
{
   28fca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return port->config->config_info;
   28fce:	6803      	ldr	r3, [r0, #0]
	const struct gpio_nrfx_data *data = get_port_data(port);
   28fd0:	6885      	ldr	r5, [r0, #8]
	return port->config->config_info;
   28fd2:	f8d3 8008 	ldr.w	r8, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   28fd6:	e9d5 3403 	ldrd	r3, r4, [r5, #12]
   28fda:	401c      	ands	r4, r3
	out &= ~data->trig_edge & ~data->double_edge;
   28fdc:	e9d5 3206 	ldrd	r3, r2, [r5, #24]
   28fe0:	4313      	orrs	r3, r2
   28fe2:	ea24 0403 	bic.w	r4, r4, r3
	u32_t bit = 1U << pin;
   28fe6:	2701      	movs	r7, #1
	u32_t pin = 0U;
   28fe8:	2600      	movs	r6, #0
	while (level_pins) {
   28fea:	b90c      	cbnz	r4, 28ff0 <cfg_level_pins+0x26>
}
   28fec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   28ff0:	4227      	tst	r7, r4
   28ff2:	d010      	beq.n	29016 <cfg_level_pins+0x4c>
	if ((BIT(pin) & data->int_active_level) != 0U) {
   28ff4:	6969      	ldr	r1, [r5, #20]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   28ff6:	f898 3008 	ldrb.w	r3, [r8, #8]
	if ((BIT(pin) & data->int_active_level) != 0U) {
   28ffa:	40f1      	lsrs	r1, r6
   28ffc:	f001 0101 	and.w	r1, r1, #1
   29000:	f1c1 0103 	rsb	r1, r1, #3
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   29004:	f006 001f 	and.w	r0, r6, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   29008:	b2c9      	uxtb	r1, r1
   2900a:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   2900e:	f7ff ff3d 	bl	28e8c <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   29012:	ea24 0407 	bic.w	r4, r4, r7
		++pin;
   29016:	3601      	adds	r6, #1
		bit <<= 1;
   29018:	007f      	lsls	r7, r7, #1
   2901a:	e7e6      	b.n	28fea <cfg_level_pins+0x20>

0002901c <gpio_nrfx_pin_enable_callback>:
{
   2901c:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
   2901e:	6884      	ldr	r4, [r0, #8]
	WRITE_BIT(data->int_en, pin, enable);
   29020:	2301      	movs	r3, #1
   29022:	fa03 f201 	lsl.w	r2, r3, r1
   29026:	6923      	ldr	r3, [r4, #16]
   29028:	4313      	orrs	r3, r2
   2902a:	6123      	str	r3, [r4, #16]
}
   2902c:	bc10      	pop	{r4}
	return gpiote_pin_int_cfg(port, pin);
   2902e:	f7f6 baaf 	b.w	1f590 <gpiote_pin_int_cfg>

00029032 <flash_nrf_write_protection>:
}
   29032:	2000      	movs	r0, #0
   29034:	4770      	bx	lr

00029036 <is_regular_addr_valid>:
{
   29036:	b538      	push	{r3, r4, r5, lr}
   29038:	4604      	mov	r4, r0
   2903a:	460d      	mov	r5, r1
	size_t flash_size = nrfx_nvmc_flash_size_get();
   2903c:	f000 f8a4 	bl	29188 <nrfx_nvmc_flash_size_get>
	if (addr >= flash_size ||
   29040:	4284      	cmp	r4, r0
   29042:	d209      	bcs.n	29058 <is_regular_addr_valid+0x22>
   29044:	2c00      	cmp	r4, #0
   29046:	db07      	blt.n	29058 <is_regular_addr_valid+0x22>
	    addr < 0 ||
   29048:	42a8      	cmp	r0, r5
   2904a:	d305      	bcc.n	29058 <is_regular_addr_valid+0x22>
	    (addr) + len > flash_size) {
   2904c:	442c      	add	r4, r5
	    len > flash_size ||
   2904e:	4284      	cmp	r4, r0
   29050:	bf8c      	ite	hi
   29052:	2000      	movhi	r0, #0
   29054:	2001      	movls	r0, #1
}
   29056:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   29058:	2000      	movs	r0, #0
   2905a:	e7fc      	b.n	29056 <is_regular_addr_valid+0x20>

0002905c <flash_nrf_read>:
{
   2905c:	b570      	push	{r4, r5, r6, lr}
   2905e:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
   29060:	4628      	mov	r0, r5
   29062:	4619      	mov	r1, r3
{
   29064:	4616      	mov	r6, r2
   29066:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   29068:	f7ff ffe5 	bl	29036 <is_regular_addr_valid>
   2906c:	b138      	cbz	r0, 2907e <flash_nrf_read+0x22>
	if (!len) {
   2906e:	b14c      	cbz	r4, 29084 <flash_nrf_read+0x28>
	memcpy(data, (void *)addr, len);
   29070:	4622      	mov	r2, r4
   29072:	4629      	mov	r1, r5
   29074:	4630      	mov	r0, r6
   29076:	f7fc fe17 	bl	25ca8 <memcpy>
	return 0;
   2907a:	2000      	movs	r0, #0
}
   2907c:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   2907e:	f06f 0015 	mvn.w	r0, #21
   29082:	e7fb      	b.n	2907c <flash_nrf_read+0x20>
		return 0;
   29084:	4620      	mov	r0, r4
   29086:	e7f9      	b.n	2907c <flash_nrf_read+0x20>

00029088 <flash_get_page_info>:

#include <drivers/flash.h>

static int flash_get_page_info(struct device *dev, off_t offs,
				   bool use_addr, struct flash_pages_info *info)
{
   29088:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2908c:	461e      	mov	r6, r3
	off_t group_offs = 0;
	u32_t num_in_group;
	off_t end = 0;
	size_t layout_size;

	api->page_layout(dev, &layout, &layout_size);
   2908e:	6843      	ldr	r3, [r0, #4]
{
   29090:	460c      	mov	r4, r1
	api->page_layout(dev, &layout, &layout_size);
   29092:	691b      	ldr	r3, [r3, #16]
   29094:	4669      	mov	r1, sp
{
   29096:	4617      	mov	r7, r2
	api->page_layout(dev, &layout, &layout_size);
   29098:	aa01      	add	r2, sp, #4
   2909a:	4798      	blx	r3

	while (layout_size--) {
   2909c:	e9dd 1000 	ldrd	r1, r0, [sp]
   290a0:	2300      	movs	r3, #0
   290a2:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
	off_t end = 0;
   290a6:	461d      	mov	r5, r3
	off_t group_offs = 0;
   290a8:	469e      	mov	lr, r3
	size_t page_count = 0;
   290aa:	469c      	mov	ip, r3
	while (layout_size--) {
   290ac:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   290b0:	d102      	bne.n	290b8 <flash_get_page_info+0x30>
		page_count += layout->pages_count;

		layout++;
	}

	return -EINVAL; /* page of the index doesn't exist */
   290b2:	f06f 0015 	mvn.w	r0, #21
   290b6:	e018      	b.n	290ea <flash_get_page_info+0x62>
		if (use_addr) {
   290b8:	680a      	ldr	r2, [r1, #0]
   290ba:	b1cf      	cbz	r7, 290f0 <flash_get_page_info+0x68>
			end += layout->pages_count * layout->pages_size;
   290bc:	6848      	ldr	r0, [r1, #4]
   290be:	fb00 5502 	mla	r5, r0, r2, r5
		if (offs < end) {
   290c2:	42a5      	cmp	r5, r4
   290c4:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   290c8:	dd17      	ble.n	290fa <flash_get_page_info+0x72>
   290ca:	b103      	cbz	r3, 290ce <flash_get_page_info+0x46>
   290cc:	9100      	str	r1, [sp, #0]
			info->size = layout->pages_size;
   290ce:	9b00      	ldr	r3, [sp, #0]
   290d0:	685b      	ldr	r3, [r3, #4]
   290d2:	6073      	str	r3, [r6, #4]
			if (use_addr) {
   290d4:	b177      	cbz	r7, 290f4 <flash_get_page_info+0x6c>
				num_in_group = (offs - group_offs) /
   290d6:	eba4 040e 	sub.w	r4, r4, lr
   290da:	fbb4 f4f3 	udiv	r4, r4, r3
			info->start_offset = group_offs +
   290de:	fb04 e303 	mla	r3, r4, r3, lr
			info->index = page_count + num_in_group;
   290e2:	4464      	add	r4, ip
			info->start_offset = group_offs +
   290e4:	6033      	str	r3, [r6, #0]
			info->index = page_count + num_in_group;
   290e6:	60b4      	str	r4, [r6, #8]
			return 0;
   290e8:	2000      	movs	r0, #0
}
   290ea:	b002      	add	sp, #8
   290ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			end += layout->pages_count;
   290f0:	4415      	add	r5, r2
   290f2:	e7e6      	b.n	290c2 <flash_get_page_info+0x3a>
				num_in_group = offs - page_count;
   290f4:	eba4 040c 	sub.w	r4, r4, ip
   290f8:	e7f1      	b.n	290de <flash_get_page_info+0x56>
		group_offs += layout->pages_count * layout->pages_size;
   290fa:	684b      	ldr	r3, [r1, #4]
		page_count += layout->pages_count;
   290fc:	4494      	add	ip, r2
		group_offs += layout->pages_count * layout->pages_size;
   290fe:	fb03 ee02 	mla	lr, r3, r2, lr
		layout++;
   29102:	3108      	adds	r1, #8
   29104:	2301      	movs	r3, #1
   29106:	e7d1      	b.n	290ac <flash_get_page_info+0x24>

00029108 <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(struct device *dev, off_t offs,
				      struct flash_pages_info *info)
{
   29108:	4613      	mov	r3, r2
	return flash_get_page_info(dev, offs, true, info);
   2910a:	2201      	movs	r2, #1
   2910c:	f7ff bfbc 	b.w	29088 <flash_get_page_info>

00029110 <flash_page_foreach>:

	return count;
}

void flash_page_foreach(struct device *dev, flash_page_cb cb, void *data)
{
   29110:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;

	api->page_layout(dev, &layout, &num_blocks);
   29114:	6843      	ldr	r3, [r0, #4]
{
   29116:	b086      	sub	sp, #24
	api->page_layout(dev, &layout, &num_blocks);
   29118:	691b      	ldr	r3, [r3, #16]
{
   2911a:	4688      	mov	r8, r1
   2911c:	4691      	mov	r9, r2
	api->page_layout(dev, &layout, &num_blocks);
   2911e:	a901      	add	r1, sp, #4
   29120:	aa02      	add	r2, sp, #8
   29122:	4798      	blx	r3
	off_t off = 0;
   29124:	2400      	movs	r4, #0
	size_t block, num_blocks, page = 0, i;
   29126:	46a2      	mov	sl, r4

	for (block = 0; block < num_blocks; block++) {
   29128:	4625      	mov	r5, r4
   2912a:	9b02      	ldr	r3, [sp, #8]
   2912c:	42ab      	cmp	r3, r5
   2912e:	d802      	bhi.n	29136 <flash_page_foreach+0x26>

			off += page_info.size;
			page++;
		}
	}
}
   29130:	b006      	add	sp, #24
   29132:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		const struct flash_pages_layout *l = &layout[block];
   29136:	9f01      	ldr	r7, [sp, #4]
   29138:	eb07 07c5 	add.w	r7, r7, r5, lsl #3
		for (i = 0; i < l->pages_count; i++) {
   2913c:	2600      	movs	r6, #0
		page_info.size = l->pages_size;
   2913e:	687b      	ldr	r3, [r7, #4]
   29140:	9304      	str	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   29142:	683a      	ldr	r2, [r7, #0]
   29144:	42b2      	cmp	r2, r6
   29146:	eb0a 0306 	add.w	r3, sl, r6
   2914a:	d802      	bhi.n	29152 <flash_page_foreach+0x42>
	for (block = 0; block < num_blocks; block++) {
   2914c:	3501      	adds	r5, #1
   2914e:	469a      	mov	sl, r3
   29150:	e7eb      	b.n	2912a <flash_page_foreach+0x1a>
			if (!cb(&page_info, data)) {
   29152:	4649      	mov	r1, r9
   29154:	a803      	add	r0, sp, #12
			page_info.start_offset = off;
   29156:	9403      	str	r4, [sp, #12]
			page_info.index = page;
   29158:	9305      	str	r3, [sp, #20]
			if (!cb(&page_info, data)) {
   2915a:	47c0      	blx	r8
   2915c:	2800      	cmp	r0, #0
   2915e:	d0e7      	beq.n	29130 <flash_page_foreach+0x20>
			off += page_info.size;
   29160:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   29162:	3601      	adds	r6, #1
			off += page_info.size;
   29164:	441c      	add	r4, r3
		for (i = 0; i < l->pages_count; i++) {
   29166:	e7ec      	b.n	29142 <flash_page_foreach+0x32>

00029168 <uart_nrfx_config_get>:
	*cfg = get_dev_data(dev)->uart_config;
   29168:	6882      	ldr	r2, [r0, #8]
{
   2916a:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   2916c:	e892 0003 	ldmia.w	r2, {r0, r1}
   29170:	e883 0003 	stmia.w	r3, {r0, r1}
}
   29174:	2000      	movs	r0, #0
   29176:	4770      	bx	lr

00029178 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   29178:	f000 b8c4 	b.w	29304 <z_impl_k_busy_wait>

0002917c <flash_total_size_get>:
   2917c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   29180:	6918      	ldr	r0, [r3, #16]
NRF_STATIC_INLINE uint32_t nrf_ficr_codesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODESIZE_CODESIZE_Msk)
    return p_reg->INFO.CODESIZE;
#else
    return p_reg->CODESIZE;
   29182:	695b      	ldr	r3, [r3, #20]
}
   29184:	4358      	muls	r0, r3
   29186:	4770      	bx	lr

00029188 <nrfx_nvmc_flash_size_get>:
    nvmc_readonly_mode_set();
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
   29188:	f7ff bff8 	b.w	2917c <flash_total_size_get>

0002918c <nrfx_nvmc_flash_page_size_get>:
    return p_reg->CODEPAGESIZE;
   2918c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   29190:	6918      	ldr	r0, [r3, #16]
}

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   29192:	4770      	bx	lr

00029194 <nrfx_nvmc_flash_page_count_get>:
    return p_reg->CODESIZE;
   29194:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   29198:	6958      	ldr	r0, [r3, #20]

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   2919a:	4770      	bx	lr

0002919c <arch_system_halt>:
	__asm__ volatile(
   2919c:	f04f 0220 	mov.w	r2, #32
   291a0:	f3ef 8311 	mrs	r3, BASEPRI
   291a4:	f382 8811 	msr	BASEPRI, r2
   291a8:	f3bf 8f6f 	isb	sy
	for (;;) {
   291ac:	e7fe      	b.n	291ac <arch_system_halt+0x10>

000291ae <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   291ae:	f7fb bbca 	b.w	24946 <z_clock_idle_exit>

000291b2 <k_mem_slab_init>:
{
   291b2:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   291b4:	2400      	movs	r4, #0
   291b6:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   291b8:	ea41 0402 	orr.w	r4, r1, r2
   291bc:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
   291c0:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
   291c4:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   291c6:	d10c      	bne.n	291e2 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
   291c8:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   291ca:	42a3      	cmp	r3, r4
   291cc:	d103      	bne.n	291d6 <k_mem_slab_init+0x24>
	list->tail = (sys_dnode_t *)list;
   291ce:	e9c0 0000 	strd	r0, r0, [r0]
}
   291d2:	2000      	movs	r0, #0
}
   291d4:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   291d6:	6945      	ldr	r5, [r0, #20]
   291d8:	600d      	str	r5, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
   291da:	3401      	adds	r4, #1
		slab->free_list = p;
   291dc:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   291de:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   291e0:	e7f3      	b.n	291ca <k_mem_slab_init+0x18>
		return -EINVAL;
   291e2:	f06f 0015 	mvn.w	r0, #21
	return rc;
   291e6:	e7f5      	b.n	291d4 <k_mem_slab_init+0x22>

000291e8 <k_mem_pool_malloc>:
{
   291e8:	b513      	push	{r0, r1, r4, lr}
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   291ea:	2404      	movs	r4, #4
   291ec:	190a      	adds	r2, r1, r4
   291ee:	d204      	bcs.n	291fa <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   291f0:	2300      	movs	r3, #0
   291f2:	4669      	mov	r1, sp
   291f4:	f7f7 fbb4 	bl	20960 <k_mem_pool_alloc>
   291f8:	b110      	cbz	r0, 29200 <k_mem_pool_malloc+0x18>
		return NULL;
   291fa:	2000      	movs	r0, #0
}
   291fc:	b002      	add	sp, #8
   291fe:	bd10      	pop	{r4, pc}
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
   29200:	9800      	ldr	r0, [sp, #0]
   29202:	4622      	mov	r2, r4
   29204:	a901      	add	r1, sp, #4
   29206:	f7fc fd4f 	bl	25ca8 <memcpy>
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   2920a:	9800      	ldr	r0, [sp, #0]
   2920c:	3004      	adds	r0, #4
   2920e:	e7f5      	b.n	291fc <k_mem_pool_malloc+0x14>

00029210 <k_free>:
	if (ptr != NULL) {
   29210:	b110      	cbz	r0, 29218 <k_free+0x8>
		k_mem_pool_free_id(ptr);
   29212:	3804      	subs	r0, #4
   29214:	f7f7 bc14 	b.w	20a40 <k_mem_pool_free_id>
}
   29218:	4770      	bx	lr

0002921a <z_impl_k_mutex_init>:
{
   2921a:	4603      	mov	r3, r0
	mutex->owner = NULL;
   2921c:	2000      	movs	r0, #0
	mutex->lock_count = 0U;
   2921e:	e9c3 0002 	strd	r0, r0, [r3, #8]
   29222:	e9c3 3300 	strd	r3, r3, [r3]
}
   29226:	4770      	bx	lr

00029228 <z_queue_node_peek>:
{
   29228:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   2922a:	4604      	mov	r4, r0
   2922c:	b130      	cbz	r0, 2923c <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2922e:	6802      	ldr	r2, [r0, #0]
   29230:	0793      	lsls	r3, r2, #30
   29232:	d003      	beq.n	2923c <z_queue_node_peek+0x14>
		ret = anode->data;
   29234:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   29236:	b109      	cbz	r1, 2923c <z_queue_node_peek+0x14>
			k_free(anode);
   29238:	f7ff ffea 	bl	29210 <k_free>
}
   2923c:	4620      	mov	r0, r4
   2923e:	bd10      	pop	{r4, pc}

00029240 <z_impl_k_queue_init>:
	list->head = NULL;
   29240:	2300      	movs	r3, #0
	list->tail = NULL;
   29242:	e9c0 3300 	strd	r3, r3, [r0]
	queue->lock = (struct k_spinlock) {};
   29246:	6083      	str	r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
   29248:	f100 030c 	add.w	r3, r0, #12
   2924c:	e9c0 3303 	strd	r3, r3, [r0, #12]
}
   29250:	4770      	bx	lr

00029252 <k_queue_append>:
{
   29252:	460a      	mov	r2, r1
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   29254:	2300      	movs	r3, #0
   29256:	6841      	ldr	r1, [r0, #4]
   29258:	f7f7 bdfe 	b.w	20e58 <queue_insert>

0002925c <k_queue_prepend>:
	(void)queue_insert(queue, NULL, data, false);
   2925c:	2300      	movs	r3, #0
{
   2925e:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false);
   29260:	4619      	mov	r1, r3
   29262:	f7f7 bdf9 	b.w	20e58 <queue_insert>

00029266 <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   29266:	f990 000e 	ldrsb.w	r0, [r0, #14]
   2926a:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   2926e:	4298      	cmp	r0, r3
   29270:	bfac      	ite	ge
   29272:	2000      	movge	r0, #0
   29274:	2001      	movlt	r0, #1
   29276:	4770      	bx	lr

00029278 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   29278:	4603      	mov	r3, r0
   2927a:	b920      	cbnz	r0, 29286 <z_reschedule_irqlock+0xe>
   2927c:	f3ef 8205 	mrs	r2, IPSR
   29280:	b90a      	cbnz	r2, 29286 <z_reschedule_irqlock+0xe>
   29282:	f7db bb11 	b.w	48a8 <arch_swap>
	__asm__ volatile(
   29286:	f383 8811 	msr	BASEPRI, r3
   2928a:	f3bf 8f6f 	isb	sy
}
   2928e:	4770      	bx	lr

00029290 <z_reschedule_unlocked>:
	__asm__ volatile(
   29290:	f04f 0320 	mov.w	r3, #32
   29294:	f3ef 8011 	mrs	r0, BASEPRI
   29298:	f383 8811 	msr	BASEPRI, r3
   2929c:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   292a0:	f7ff bfea 	b.w	29278 <z_reschedule_irqlock>

000292a4 <z_priq_dumb_best>:
{
   292a4:	4603      	mov	r3, r0
	return list->head == list;
   292a6:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   292a8:	4283      	cmp	r3, r0
   292aa:	d003      	beq.n	292b4 <z_priq_dumb_best+0x10>
	if (n != NULL) {
   292ac:	2800      	cmp	r0, #0
   292ae:	bf38      	it	cc
   292b0:	2000      	movcc	r0, #0
   292b2:	4770      	bx	lr
	struct k_thread *thread = NULL;
   292b4:	2000      	movs	r0, #0
}
   292b6:	4770      	bx	lr

000292b8 <z_unpend_all>:
{
   292b8:	b538      	push	{r3, r4, r5, lr}
   292ba:	4605      	mov	r5, r0
	int need_sched = 0;
   292bc:	2000      	movs	r0, #0
	return list->head == list;
   292be:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   292c0:	42a5      	cmp	r5, r4
   292c2:	d000      	beq.n	292c6 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   292c4:	b904      	cbnz	r4, 292c8 <z_unpend_all+0x10>
}
   292c6:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   292c8:	4620      	mov	r0, r4
   292ca:	f7f8 f99d 	bl	21608 <z_unpend_thread>
		z_ready_thread(thread);
   292ce:	4620      	mov	r0, r4
   292d0:	f7f8 fade 	bl	21890 <z_ready_thread>
		need_sched = 1;
   292d4:	2001      	movs	r0, #1
   292d6:	e7f2      	b.n	292be <z_unpend_all+0x6>

000292d8 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
   292d8:	b15a      	cbz	r2, 292f2 <z_impl_k_sem_init+0x1a>
   292da:	428a      	cmp	r2, r1
   292dc:	d309      	bcc.n	292f2 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   292de:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   292e2:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   292e6:	e9c0 0000 	strd	r0, r0, [r0]
   292ea:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   292ee:	2000      	movs	r0, #0
   292f0:	4770      	bx	lr
		return -EINVAL;
   292f2:	f06f 0015 	mvn.w	r0, #21
}
   292f6:	4770      	bx	lr

000292f8 <k_is_in_isr>:
   292f8:	f3ef 8005 	mrs	r0, IPSR
}
   292fc:	3800      	subs	r0, #0
   292fe:	bf18      	it	ne
   29300:	2001      	movne	r0, #1
   29302:	4770      	bx	lr

00029304 <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
   29304:	f7dc bdf4 	b.w	5ef0 <arch_busy_wait>

00029308 <k_thread_name_get>:
}
   29308:	305c      	adds	r0, #92	; 0x5c
   2930a:	4770      	bx	lr

0002930c <z_new_thread_init>:
{
   2930c:	b510      	push	{r4, lr}
	thread_base->user_options = (u8_t)options;
   2930e:	9c02      	ldr	r4, [sp, #8]
   29310:	7304      	strb	r4, [r0, #12]
	thread_base->prio = priority;
   29312:	7383      	strb	r3, [r0, #14]
	thread_base->thread_state = (u8_t)initial_state;
   29314:	2404      	movs	r4, #4
	thread_base->sched_locked = 0U;
   29316:	2300      	movs	r3, #0
	node->prev = NULL;
   29318:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
   2931c:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
	thread->stack_info.size = (u32_t)stackSize;
   29320:	e9c0 1220 	strd	r1, r2, [r0, #128]	; 0x80
	thread_base->thread_state = (u8_t)initial_state;
   29324:	7344      	strb	r4, [r0, #13]
	thread_base->sched_locked = 0U;
   29326:	73c3      	strb	r3, [r0, #15]
	thread->name[0] = '\0';
   29328:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
}
   2932c:	bd10      	pop	{r4, pc}

0002932e <k_work_submit_to_queue>:
{
   2932e:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   29330:	f101 0308 	add.w	r3, r1, #8
   29334:	f3bf 8f5b 	dmb	ish
   29338:	e853 2f00 	ldrex	r2, [r3]
   2933c:	f042 0c01 	orr.w	ip, r2, #1
   29340:	e843 ce00 	strex	lr, ip, [r3]
   29344:	f1be 0f00 	cmp.w	lr, #0
   29348:	d1f6      	bne.n	29338 <k_work_submit_to_queue+0xa>
   2934a:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   2934e:	07d3      	lsls	r3, r2, #31
   29350:	d403      	bmi.n	2935a <k_work_submit_to_queue+0x2c>
}
   29352:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   29356:	f7ff bf7c 	b.w	29252 <k_queue_append>
}
   2935a:	f85d fb04 	ldr.w	pc, [sp], #4

0002935e <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   2935e:	f1a0 010c 	sub.w	r1, r0, #12
   29362:	6900      	ldr	r0, [r0, #16]
   29364:	f7ff bfe3 	b.w	2932e <k_work_submit_to_queue>

00029368 <work_cancel>:
	CHECKIF(work->work_q == NULL) {
   29368:	69c3      	ldr	r3, [r0, #28]
{
   2936a:	b570      	push	{r4, r5, r6, lr}
   2936c:	4604      	mov	r4, r0
	CHECKIF(work->work_q == NULL) {
   2936e:	b913      	cbnz	r3, 29376 <work_cancel+0xe>
		return -EALREADY;
   29370:	f06f 0044 	mvn.w	r0, #68	; 0x44
}
   29374:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   29376:	f3bf 8f5b 	dmb	ish
   2937a:	6883      	ldr	r3, [r0, #8]
   2937c:	f3bf 8f5b 	dmb	ish
	if (k_work_pending(&work->work)) {
   29380:	07db      	lsls	r3, r3, #31
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   29382:	f100 0508 	add.w	r5, r0, #8
   29386:	d532      	bpl.n	293ee <work_cancel+0x86>
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   29388:	69c2      	ldr	r2, [r0, #28]
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   2938a:	6813      	ldr	r3, [r2, #0]
   2938c:	2100      	movs	r1, #0
   2938e:	b913      	cbnz	r3, 29396 <work_cancel+0x2e>
			return -EINVAL;
   29390:	f06f 0015 	mvn.w	r0, #21
   29394:	e7ee      	b.n	29374 <work_cancel+0xc>
   29396:	429c      	cmp	r4, r3
   29398:	d124      	bne.n	293e4 <work_cancel+0x7c>
Z_GENLIST_REMOVE(sflist, sfnode)
   2939a:	6823      	ldr	r3, [r4, #0]
   2939c:	6856      	ldr	r6, [r2, #4]
   2939e:	f023 0003 	bic.w	r0, r3, #3
   293a2:	b9b1      	cbnz	r1, 293d2 <work_cancel+0x6a>
   293a4:	42b4      	cmp	r4, r6
	list->head = node;
   293a6:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   293a8:	d100      	bne.n	293ac <work_cancel+0x44>
	list->tail = node;
   293aa:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   293ac:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   293ae:	f003 0303 	and.w	r3, r3, #3
   293b2:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   293b4:	2000      	movs	r0, #0
   293b6:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   293b8:	f3bf 8f5b 	dmb	ish
   293bc:	e855 3f00 	ldrex	r3, [r5]
   293c0:	f023 0301 	bic.w	r3, r3, #1
   293c4:	e845 3200 	strex	r2, r3, [r5]
   293c8:	2a00      	cmp	r2, #0
   293ca:	d1f7      	bne.n	293bc <work_cancel+0x54>
   293cc:	f3bf 8f5b 	dmb	ish
   293d0:	e7d0      	b.n	29374 <work_cancel+0xc>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   293d2:	680b      	ldr	r3, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   293d4:	f003 0303 	and.w	r3, r3, #3
   293d8:	4303      	orrs	r3, r0
Z_GENLIST_REMOVE(sflist, sfnode)
   293da:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   293dc:	600b      	str	r3, [r1, #0]
	list->tail = node;
   293de:	bf08      	it	eq
   293e0:	6051      	streq	r1, [r2, #4]
}
   293e2:	e7e3      	b.n	293ac <work_cancel+0x44>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   293e4:	6818      	ldr	r0, [r3, #0]
   293e6:	4619      	mov	r1, r3
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   293e8:	f020 0303 	bic.w	r3, r0, #3
   293ec:	e7cf      	b.n	2938e <work_cancel+0x26>
		int err = z_abort_timeout(&work->timeout);
   293ee:	300c      	adds	r0, #12
   293f0:	f7f9 fd94 	bl	22f1c <z_abort_timeout>
		if (err) {
   293f4:	2800      	cmp	r0, #0
   293f6:	d0dd      	beq.n	293b4 <work_cancel+0x4c>
   293f8:	e7ba      	b.n	29370 <work_cancel+0x8>

000293fa <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   293fa:	2300      	movs	r3, #0
   293fc:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
   29400:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
   29404:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
   29406:	61c3      	str	r3, [r0, #28]
}
   29408:	4770      	bx	lr

0002940a <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   2940a:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   2940c:	f7f9 ff66 	bl	232dc <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   29410:	bd08      	pop	{r3, pc}

00029412 <z_impl_k_uptime_ticks>:

s64_t z_impl_k_uptime_ticks(void)
{
	return z_tick_get();
   29412:	f7f9 bf63 	b.w	232dc <z_tick_get>

00029416 <z_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
u64_t z_timeout_end_calc(k_timeout_t timeout)
{
   29416:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   29418:	1c43      	adds	r3, r0, #1
{
   2941a:	4601      	mov	r1, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2941c:	d01e      	beq.n	2945c <z_timeout_end_calc+0x46>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2941e:	b918      	cbnz	r0, 29428 <z_timeout_end_calc+0x12>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
		return Z_TICK_ABS(dt);
	}
#endif
	return z_tick_get() + MAX(1, dt);
}
   29420:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return z_tick_get();
   29424:	f7f9 bf5a 	b.w	232dc <z_tick_get>
			return (u32_t)((t * to_hz + off) / from_hz);
   29428:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   2942c:	f240 34e7 	movw	r4, #999	; 0x3e7
   29430:	2500      	movs	r5, #0
   29432:	fbe0 4501 	umlal	r4, r5, r0, r1
   29436:	4620      	mov	r0, r4
   29438:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2943c:	2300      	movs	r3, #0
   2943e:	4629      	mov	r1, r5
   29440:	f7d6 feae 	bl	1a0 <__aeabi_uldivmod>
   29444:	4604      	mov	r4, r0
	return z_tick_get() + MAX(1, dt);
   29446:	f7f9 ff49 	bl	232dc <z_tick_get>
   2944a:	b12c      	cbz	r4, 29458 <z_timeout_end_calc+0x42>
   2944c:	4623      	mov	r3, r4
   2944e:	2200      	movs	r2, #0
   29450:	18c0      	adds	r0, r0, r3
   29452:	eb42 0101 	adc.w	r1, r2, r1
}
   29456:	bd38      	pop	{r3, r4, r5, pc}
	return z_tick_get() + MAX(1, dt);
   29458:	2301      	movs	r3, #1
   2945a:	e7f8      	b.n	2944e <z_timeout_end_calc+0x38>
		return UINT64_MAX;
   2945c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29460:	4601      	mov	r1, r0
   29462:	e7f8      	b.n	29456 <z_timeout_end_calc+0x40>

00029464 <k_timer_init>:
	timer->status = 0U;
   29464:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   29466:	e9c0 1206 	strd	r1, r2, [r0, #24]
	sys_dlist_init(&w->waitq);
   2946a:	f100 0210 	add.w	r2, r0, #16
	list->tail = (sys_dnode_t *)list;
   2946e:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
   29472:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   29476:	6243      	str	r3, [r0, #36]	; 0x24
	timer->user_data = NULL;
   29478:	6283      	str	r3, [r0, #40]	; 0x28
}
   2947a:	4770      	bx	lr

0002947c <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   2947c:	b510      	push	{r4, lr}
   2947e:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   29480:	f7f9 fd4c 	bl	22f1c <z_abort_timeout>

	if (inactive) {
   29484:	b9d8      	cbnz	r0, 294be <z_impl_k_timer_stop+0x42>
		return;
	}

	if (timer->stop_fn != NULL) {
   29486:	69e3      	ldr	r3, [r4, #28]
   29488:	b10b      	cbz	r3, 2948e <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   2948a:	4620      	mov	r0, r4
   2948c:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   2948e:	f104 0010 	add.w	r0, r4, #16
   29492:	2100      	movs	r1, #0
   29494:	f7f7 ff3a 	bl	2130c <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   29498:	4604      	mov	r4, r0
   2949a:	b180      	cbz	r0, 294be <z_impl_k_timer_stop+0x42>
		z_unpend_thread_no_timeout(thread);
   2949c:	f7f7 ff80 	bl	213a0 <z_unpend_thread_no_timeout>
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
   294a0:	4620      	mov	r0, r4
   294a2:	f7f8 f9f5 	bl	21890 <z_ready_thread>
   294a6:	f04f 0320 	mov.w	r3, #32
   294aa:	f3ef 8011 	mrs	r0, BASEPRI
   294ae:	f383 8811 	msr	BASEPRI, r3
   294b2:	f3bf 8f6f 	isb	sy
		z_reschedule_unlocked();
	}
}
   294b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   294ba:	f7ff bedd 	b.w	29278 <z_reschedule_irqlock>
   294be:	bd10      	pop	{r4, pc}

000294c0 <signal_poll_event>:
{
   294c0:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   294c2:	6884      	ldr	r4, [r0, #8]
{
   294c4:	4605      	mov	r5, r0
   294c6:	460e      	mov	r6, r1
	if (poller) {
   294c8:	b19c      	cbz	r4, 294f2 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   294ca:	68a3      	ldr	r3, [r4, #8]
   294cc:	b95b      	cbnz	r3, 294e6 <signal_poll_event+0x26>
		poller->is_polling = false;
   294ce:	7023      	strb	r3, [r4, #0]
	int retcode = 0;
   294d0:	4618      	mov	r0, r3
	event->poller = NULL;
   294d2:	2300      	movs	r3, #0
   294d4:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   294d6:	68eb      	ldr	r3, [r5, #12]
   294d8:	f3c3 3104 	ubfx	r1, r3, #12, #5
   294dc:	430e      	orrs	r6, r1
   294de:	f366 3310 	bfi	r3, r6, #12, #5
   294e2:	60eb      	str	r3, [r5, #12]
	return retcode;
   294e4:	e004      	b.n	294f0 <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   294e6:	4798      	blx	r3
		poller->is_polling = false;
   294e8:	2300      	movs	r3, #0
		if (retcode < 0) {
   294ea:	2800      	cmp	r0, #0
		poller->is_polling = false;
   294ec:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   294ee:	daf0      	bge.n	294d2 <signal_poll_event+0x12>
}
   294f0:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   294f2:	4620      	mov	r0, r4
   294f4:	e7ed      	b.n	294d2 <signal_poll_event+0x12>

000294f6 <add_event>:
{
   294f6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   294f8:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   294fa:	e9d0 2300 	ldrd	r2, r3, [r0]
   294fe:	4290      	cmp	r0, r2
   29500:	4604      	mov	r4, r0
   29502:	460d      	mov	r5, r1
   29504:	d106      	bne.n	29514 <add_event+0x1e>
	node->prev = list->tail;
   29506:	6863      	ldr	r3, [r4, #4]
   29508:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   2950a:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   2950c:	602c      	str	r4, [r5, #0]
	list->tail->next = node;
   2950e:	601d      	str	r5, [r3, #0]
	list->tail = node;
   29510:	6065      	str	r5, [r4, #4]
}
   29512:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   29514:	2b00      	cmp	r3, #0
   29516:	d0f6      	beq.n	29506 <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   29518:	689b      	ldr	r3, [r3, #8]
   2951a:	6879      	ldr	r1, [r7, #4]
   2951c:	6858      	ldr	r0, [r3, #4]
   2951e:	f7ff fea2 	bl	29266 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   29522:	2800      	cmp	r0, #0
   29524:	d1ef      	bne.n	29506 <add_event+0x10>
	return list->head == list;
   29526:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   29528:	42b4      	cmp	r4, r6
   2952a:	d0ec      	beq.n	29506 <add_event+0x10>
   2952c:	2e00      	cmp	r6, #0
   2952e:	bf38      	it	cc
   29530:	2600      	movcc	r6, #0
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29532:	2e00      	cmp	r6, #0
   29534:	d0e7      	beq.n	29506 <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   29536:	68b3      	ldr	r3, [r6, #8]
   29538:	6878      	ldr	r0, [r7, #4]
   2953a:	6859      	ldr	r1, [r3, #4]
   2953c:	f7ff fe93 	bl	29266 <z_is_t1_higher_prio_than_t2>
   29540:	b128      	cbz	r0, 2954e <add_event+0x58>
	node->prev = successor->prev;
   29542:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   29544:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   29548:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   2954a:	6075      	str	r5, [r6, #4]
			return;
   2954c:	e7e1      	b.n	29512 <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   2954e:	6863      	ldr	r3, [r4, #4]
   29550:	42b3      	cmp	r3, r6
   29552:	d0d8      	beq.n	29506 <add_event+0x10>
   29554:	6836      	ldr	r6, [r6, #0]
   29556:	e7ec      	b.n	29532 <add_event+0x3c>

00029558 <z_handle_obj_poll_events>:
{
   29558:	4603      	mov	r3, r0
	return list->head == list;
   2955a:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   2955c:	4283      	cmp	r3, r0
   2955e:	d008      	beq.n	29572 <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   29560:	e9d0 3200 	ldrd	r3, r2, [r0]
   29564:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   29566:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   29568:	2300      	movs	r3, #0
	node->prev = NULL;
   2956a:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
   2956e:	f7ff bfa7 	b.w	294c0 <signal_poll_event>
}
   29572:	4770      	bx	lr

00029574 <_OffsetAbsSyms>:
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
   29574:	4770      	bx	lr
